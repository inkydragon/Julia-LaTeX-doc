\documentclass{memoir}

\usepackage{./documenter}
\usepackage{./custom}

\title{
    {\HUGE Julia中文文档}\\
    {\Large }
}
\author{Julia中文社区}

\begin{document}

\frontmatter
\maketitle
\tableofcontents

\mainmatter



\part{主页}


\hypertarget{12259063490654611425}{}


\part{Julia 1.5 中文文档}



欢迎来到 Julia 1.5 中文文档(\href{https://raw.githubusercontent.com/JuliaCN/JuliaZH.jl/pdf/dev/Julia中文文档.pdf}{PDF版本})!



请先阅读 \href{https://julialang.org/blog/2018/08/one-point-zero-zh\_cn}{Julia 1.0 正式发布博文} 以获得对这门语言的总体概观。我们推荐刚刚开始学习 Julia 语言的朋友阅读中文社区提供的 \href{https://discourse.juliacn.com/t/topic/159}{Julia入门指引}，也推荐你在\href{https://discourse.juliacn.com}{中文论坛}对遇到的问题进行提问。



\begin{quote}
\textbf{关于中文文档}

Julia 语言相关的本地化工作是一个由社区驱动的开源项目 \href{https://github.com/JuliaCN/JuliaZH.jl}{JuliaZH.jl}，旨在方便 Julia 的中文用户。我们目前使用 \href{https://www.transifex.com}{Transifex} 作为翻译平台。翻译工作正在进行，有任何疑问或建议请到\href{https://discourse.juliacn.com/c/community/document}{社区论坛文档区}反馈。若有意参与翻译工作，请参考\href{https://discourse.juliacn.com/t/topic/277}{翻译指南}。

\end{quote}


\hypertarget{3498245216777255645}{}


\chapter{简介}



科学计算对性能一直有着最高的需求，但目前各领域的专家却大量使用较慢的动态语言来开展他们的日常工作。 偏爱动态语言有很多很好的理由，因此我们不会舍弃动态的特性。 幸运的是，现代编程语言设计与编译器技术可以大大消除性能折衷（trade-off），并提供有足够生产力的单一环境进行原型设计，而且能高效地部署性能密集型应用程序。 Julia 语言在这其中扮演了这样一个角色：它是一门灵活的动态语言，适合用于科学计算和数值计算，并且性能可与传统的静态类型语言媲美。



由于 Julia 的编译器和其它语言比如 Python 或 R 的解释器有所不同，一开始你可能发现 Julia 的性能并不是很突出。 如果你觉得速度有点慢，我们强烈建议在尝试其他功能前，先读一读文档中的\hyperlink{818954303942149020}{提高性能的窍门}。 在理解了 Julia 的运作方式后，写出和 C 一样快的代码对你而言就是小菜一碟。



Julia 拥有可选类型标注和多重派发这两个特性，同时还拥有很棒的性能。 这些都得归功于使用 \href{https://en.wikipedia.org/wiki/Low\_Level\_Virtual\_Machine}{LLVM} 实现的类型推导和\href{https://en.wikipedia.org/wiki/Just-in-time\_compilation}{即时编译（JIT）}技术。Julia 是一门支持过程式、函数式和面向对象的多范式语言。 它像 R、MATLAB 和 Python 一样简单，在高级数值计算方面有丰富的表现力，并且支持通用编程。 为了实现这个目标，Julia 以数学编程语言（mathematical programming languages）为基础，同时也参考了不少流行的动态语言，例如 \href{https://en.wikipedia.org/wiki/Lisp\_(programming\_language)}{Lisp}、\href{https://en.wikipedia.org/wiki/Perl\_(programming\_language)}{Perl}、\href{https://en.wikipedia.org/wiki/Python\_(programming\_language)}{Python}、\href{https://en.wikipedia.org/wiki/Lua\_(programming\_language)}{Lua}、和 \href{https://en.wikipedia.org/wiki/Ruby\_(programming\_language)}{Ruby}。



Julia 与传统动态语言最重要的区别是：



\begin{itemize}
\item 核心语言很小：标准库是用 Julia 自身写的，包括整数运算这样的基础运算


\item 丰富的基础类型：既可用于定义和描述对象，也可用于做可选的类型标注


\item 通过\href{https://en.wikipedia.org/wiki/Multiple\_dispatch}{多重派发}，可以根据类型的不同，来调用同名函数的不同实现


\item 为不同的参数类型，自动生成高效、专用的代码


\item 接近 C 语言的性能

\end{itemize}


尽管人们有时会说动态语言是“无类型的”，但实际上绝对不是这样的：每一个对象都有一个类型，无论它是基础的类型（primitive）还是用户自定义的类型。 大多数的动态语言都缺乏类型声明，这意味着程序员无法告诉编译器值的类型，也就无法显式地讨论类型。 另一方面，在静态语言中，往往必须标注对象的类型。但类型只在编译期才存在，而无法在运行时进行操作和表达。 而在 Julia 中，类型本身是运行时的对象，并可用于向编译器传达信息。



类型系统和多重派发是 Julia 语言最主要的特征，但一般不需要显式地手动标注或使用：函数通过函数名称和不同类型参数的组合进行定义，在调用时会派发到最接近（most specific）的定义上去。这样的编程模型非常适合数学化的编程，尤其是在传统的面向对象派发中，一些函数的第一个变量理论上并不“拥有”这样一个操作时。 在 Julia 中运算符只是函数的一个特殊标记——例如，为用户定义的新类型添加加法运算，你只要为 \texttt{+} 函数定义一个新的方法就可以了。 已有的代码就可以无缝接入这个新的类型。



Julia 在设计之初就非常看重性能，再加上它的动态类型推导（可以被可选的类型标注增强），使得 Julia 的计算性能超过了其它的动态语言，甚至能够与静态编译语言竞争。对于大型数值问题，速度一直都是，也一直会是一个重要的关注点：在过去的几十年里，需要处理的数据量很容易与摩尔定律保持同步。



Julia 的目标是创建一个前所未有的集易用、强大、高效于一体的语言。除此之外，Julia 还拥有以下优势：



\begin{itemize}
\item 采用 \href{https://github.com/JuliaLang/julia/blob/master/LICENSE.md}{MIT 许可证}：免费又开源


\item 用户自定义类型的速度与兼容性和内建类型一样好


\item 无需特意编写向量化的代码：非向量化的代码就很快


\item 为并行计算和分布式计算设计


\item 轻量级的“绿色”线程：\href{https://en.wikipedia.org/wiki/Coroutine}{协程}


\item 低调又牛逼的类型系统


\item 优雅、可扩展的类型转换和类型提升


\item 对 \href{https://en.wikipedia.org/wiki/Unicode}{Unicode} 的有效支持，包括但不限于 \href{https://en.wikipedia.org/wiki/UTF-8}{UTF-8}


\item 直接调用 C 函数，无需封装或调用特别的 API


\item 像 Shell 一样强大的管理其他进程的能力


\item 像 Lisp 一样的宏和其他元编程工具

\end{itemize}


\part{手册}


\hypertarget{14943148626325101976}{}


\chapter{入门}



无论是使用预编译好的二进制程序，还是自己从源码编译，安装 Julia 都是一件很简单的事情。 请按照 \href{https://julialang.org/downloads/}{https://julialang.org/downloads/} 的提示来下载并安装 Julia。



启动一个交互式会话（也叫 REPL）是学习和尝试 Julia 最简单的方法。双击 Julia 的可执行文件或是从命令行运行 \texttt{julia} 就可以启动：




\begin{lstlisting}
$ julia

               _
   _       _ _(_)_     |  Documentation: https://docs.julialang.org
  (_)     | (_) (_)    |
   _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 1.4.2 (2020-05-23)
 _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release
|__/                   |


julia> 1 + 2
3

julia> ans
3
\end{lstlisting}



输入 \texttt{CTRL-D}（同时按 \texttt{Ctrl} 键和 \texttt{d} 键）或 \texttt{exit()} 便可以退出交互式会话。在交互式模式中，\texttt{julia} 会显示一条横幅并提示用户输入。一旦用户输入了一段完整的代码（表达式），例如 \texttt{1 + 2}，然后按回车，交互式会话就会执行这段代码，并将结果显示出来。如果输入的代码以分号结尾，那么结果将不会显示出来。然而不管结果显示与否，变量 \texttt{ans} 总会存储上一次执行代码的结果，需要注意的是，变量 \texttt{ans} 只在交互式会话中才有。



在交互式会话中，要运行写在源文件 \texttt{file.jl} 中的代码，只需输入 \texttt{include({\textquotedbl}file.jl{\textquotedbl})}。



如果想非交互式地执行文件中的代码，可以把文件名作为 \texttt{julia} 命令的第一个参数：




\begin{lstlisting}
$ julia script.jl arg1 arg2...
\end{lstlisting}



如这个例子所示，\texttt{julia} 后跟着的命令行参数会被作为程序 \texttt{script.jl} 的命令行参数。这些参数使用全局常量 \texttt{ARGS} 来传递，脚本自身的名字会以全局变量 \texttt{PROGRAM\_FILE} 传入。注意当脚本以命令行里的 \texttt{-e} 选项输入时，\texttt{ARGS} 也会被设定（详见此页末尾列表）但是 \texttt{PROGRAM\_FILE} 会是空的。例如，要把一个脚本的输入参数显示出来，你可以：




\begin{lstlisting}
$ julia -e 'println(PROGRAM_FILE); for x in ARGS; println(x); end' foo bar

foo
bar
\end{lstlisting}



或者你可以把代码写到一个脚本文件中再执行它：




\begin{lstlisting}
$ echo 'println(PROGRAM_FILE); for x in ARGS; println(x); end' > script.jl
$ julia script.jl foo bar
script.jl
foo
bar
\end{lstlisting}



可以使用 \texttt{--} 分隔符来将传给脚本文件的参数和 Julia 本身的命令行参数区分开：




\begin{lstlisting}
$ julia --color=yes -O -- foo.jl arg1 arg2..
\end{lstlisting}



有关编写 Julia 脚本的更多信息，请参阅 \hyperlink{9384335615524550131}{脚本}。



使用选项 \texttt{-p} 或者 \texttt{--machine-file} 可以在并行模式下启动 Julia。 \texttt{-p n} 会启动额外的 \texttt{n} 个 worker，使用 \texttt{--machine-file file} 会为 \texttt{file} 文件中的每一行启动一个 worker。 定义在 \texttt{file} 中的机器必须能够通过一个不需要密码的 \texttt{ssh} 登陆访问到，且 Julia 的安装位置需要和当前主机相同。 定义机器的格式为 \texttt{[count*][user@]host[:port] [bind\_addr[:port]]}。 \texttt{user} 默认值是当前用户； \texttt{port} 默认值是标准 ssh 端口； \texttt{count} 是在这个节点上的 worker 的数量，默认是 1； 可选的 \texttt{bind-to bind\_addr[:port]} 指定了其它 worker 访问当前 worker 应当使用的 IP 地址与端口。



要让 Julia 每次启动都自动执行一些代码，你可以把它们放在 \texttt{{\textasciitilde}/.julia/config/startup.jl} 中：




\begin{lstlisting}
$ echo 'println("Greetings! 你好! 안녕하세요?")' > ~/.julia/config/startup.jl
$ julia
Greetings! 你好! 안녕하세요?

...
\end{lstlisting}



Note that although you should have a \texttt{{\textasciitilde}/.julia} directory once you{\textquotesingle}ve run Julia for the first time, you may need to create the \texttt{{\textasciitilde}/.julia/config} folder and the \texttt{{\textasciitilde}/.julia/config/startup.jl} file if you use it.



和 \texttt{perl} 和 \texttt{ruby} 程序类似，还有很多种运行 Julia 代码的方式，运行代码时也有很多选项：




\begin{lstlisting}
julia [switches] -- [programfile] [args...]
\end{lstlisting}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
选项 & 描述 \\
\hline
\texttt{-v}, \texttt{--version} & 显示版本信息 \\
\hline
\texttt{-h}, \texttt{--help} & Print command-line options (this message). \\
\hline
\texttt{--project[=\{<dir>|@.\}]} & 将 <dir> 设置为主项目/环境。默认的 @. 选项将搜索父目录，直至找到 Project.toml 或 JuliaProject.toml 文件。 \\
\hline
\texttt{-J}, \texttt{--sysimage <file>} & 用指定的镜像文件（system image file）启动 \\
\hline
\texttt{-H}, \texttt{--home <dir>} & 设置 \texttt{julia} 可执行文件的路径 \\
\hline
\texttt{--startup-file=\{yes|no\}} & 是否载入 \texttt{{\textasciitilde}/.julia/config/startup.jl} \\
\hline
\texttt{--handle-signals=\{yes|no\}} & 开启或关闭 Julia 默认的 signal handlers \\
\hline
\texttt{--sysimage-native-code=\{yes|no\}} & 在可能的情况下，使用系统镜像里的原生代码 \\
\hline
\texttt{--compiled-modules=\{yes|no\}} & 开启或关闭 module 的增量预编译功能 \\
\hline
\texttt{-e}, \texttt{--eval <expr>} & 执行 \texttt{<expr>} \\
\hline
\texttt{-E}, \texttt{--print <expr>} & 执行 \texttt{<expr>} 并显示结果 \\
\hline
\texttt{-L}, \texttt{--load <file>} & 立即在所有进程中载入 \texttt{<file>} \\
\hline
\texttt{-t}, \texttt{--threads \{N|auto\}} & Enable N threads; \texttt{auto} currently sets N to the number of local CPU threads but this might change in the future \\
\hline
\texttt{-p}, \texttt{--procs \{N|auto\}} & 这里的整数 N 表示启动 N 个额外的工作进程；\texttt{auto} 表示启动与 CPU 线程数目（logical cores）一样多的进程 \\
\hline
\texttt{--machine-file <file>} & 在 \texttt{<file>} 中列出的主机上运行进程 \\
\hline
\texttt{-i} & 交互式模式；REPL 运行且 \texttt{isinteractive()} 为 true \\
\hline
\texttt{-q}, \texttt{--quiet} & 安静的启动；REPL 启动时无横幅，不显示警告 \\
\hline
\texttt{--banner=\{yes|no|auto\}} & 开启或关闭 REPL 横幅 \\
\hline
\texttt{--color=\{yes|no|auto\}} & 开启或关闭文字颜色 \\
\hline
\texttt{--history-file=\{yes|no\}} & 载入或导出历史记录 \\
\hline
\texttt{--depwarn=\{yes|no|error\}} & 开启或关闭语法弃用警告，\texttt{error} 表示将弃用警告转换为错误。 \\
\hline
\texttt{--warn-overwrite=\{yes|no\}} & 开启或关闭“method overwrite”警告 \\
\hline
\texttt{-C}, \texttt{--cpu-target <target>} & 设置 \texttt{<target>} 来限制使用 CPU 的某些特性；设置为 \texttt{help} 可以查看可用的选项 \\
\hline
\texttt{-O}, \texttt{--optimize=\{0,1,2,3\}} & 设置编译器优化级别(若未配置此选项，则默认等级为2；若配置了此选项却没指定具体级别，则默认级别为3)。 \\
\hline
\texttt{-g}, \texttt{-g <level>} & 开启或设置 debug 信息的生成等级。若未配置此选项，则默认 debug 信息的级别为 1；若配置了此选项却没指定具体级别，则默认级别为 2。 \\
\hline
\texttt{--inline=\{yes|no\}} & 控制是否允许函数内联，此选项会覆盖源文件中的 \texttt{@inline} 声明 \\
\hline
\texttt{--check-bounds=\{yes|no\}} & 设置边界检查状态：始终检查或永不检查。永不检查时会忽略源文件中的相应声明 \\
\hline
\texttt{--math-mode=\{ieee,fast\}} & 开启或关闭非安全的浮点数代数计算优化，此选项会覆盖源文件中的 \texttt{@fastmath} 声明 \\
\hline
\texttt{--code-coverage=\{none|user|all\}} & 对源文件中每行代码执行的次数计数 \\
\hline
\texttt{--code-coverage} & 等价于 \texttt{--code-coverage=user} \\
\hline
\texttt{--track-allocation=\{none|user|all\}} & 对源文件中每行代码的内存分配计数，单位 byte \\
\hline
\texttt{--track-allocation} & 等价于 \texttt{--track-allocation=user} \\
\hline
\end{tabulary}

\end{table}



\begin{quote}
\textbf{Julia 1.1}

在 Julia 1.0 中，默认的 \texttt{--project=@.} 选项不会在 Git 仓库的根目录中寻找 \texttt{Project.toml} 文件。从 Julia 1.1 开始，此选项会在其中寻找该文件。

\end{quote}


\hypertarget{17073013932993739054}{}


\section{资源}



除了本手册以外，官方网站还提供了一个有用的\textbf{\href{https://julialang.org/learning/}{学习资源列表}}来帮助新用户学习 Julia。



\hypertarget{10731958648755981077}{}


\chapter{Variables}



Julia 语言中，变量是与某个值相关联（或绑定）的名字。你可以用它来保存一个值（例如某些计算得到的结果），供之后的代码使用。例如：




\begin{minted}{jlcon}
# 将 10 赋值给变量 x
julia> x = 10
10

# 使用 x 的值做计算
julia> x + 1
11

# 重新给 x 赋值
julia> x = 1 + 1
2

# 也可以给 x 赋其它类型的值, 比如字符串文本
julia> x = "Hello World!"
"Hello World!"
\end{minted}



Julia 提供了非常灵活的变量命名策略。变量名是大小写敏感的，且不包含语义，意思是说，Julia 不会根据变量的名字来区别对待它们。 （译者注：Julia \textbf{不会}自动将全大写的变量识别为常量，也\textbf{不会}将有特定前后缀的变量自动识别为某种特定类型的变量，即不会根据变量名字，自动判断变量的任何属性。）




\begin{minted}{jlcon}
julia> x = 1.0
1.0

julia> y = -3
-3

julia> Z = "My string"
"My string"

julia> customary_phrase = "Hello world!"
"Hello world!"

julia> UniversalDeclarationOfHumanRightsStart = "人人生而自由，在尊严和权利上一律平等。"
"人人生而自由，在尊严和权利上一律平等。"
\end{minted}



你还可以使用 UTF-8 编码的 Unicode 字符作为变量名：




\begin{minted}{jlcon}
julia> δ = 0.00001
1.0e-5

julia> 안녕하세요 = "Hello"
"Hello"
\end{minted}



在 Julia REPL 和一些其它的 Julia 编辑环境中，很多 Unicode 数学符号可以使用反斜杠加 LaTeX 符号名再按 \emph{tab} 健打出。 例如：变量名 \texttt{δ} 可以通过 \texttt{{\textbackslash}delta} \emph{tab} 来输入，甚至可以用 \texttt{{\textbackslash}alpha} \emph{tab} \texttt{{\textbackslash}hat} \emph{tab} \texttt{{\textbackslash}\_2} \emph{tab} 来输入 \texttt{α̂₂}  这种复杂的变量名。 如果你在某个地方（比如别人的代码里）看到了一个不知道怎么输入的符号，你可以在REPL中输入 \texttt{?}，然后粘贴那个符号，帮助文档会告诉你输入方法。



如果有需要的话，Julia 甚至允许你重定义内置常量和函数。（这样做可能引发潜在的混淆，所以并不推荐）




\begin{minted}{jlcon}
julia> pi = 3
3

julia> pi
3

julia> sqrt = 4
4
\end{minted}



然而，如果你试图重定义一个已经在使用中的内置常量或函数，Julia 会报错：




\begin{minted}{jlcon}
julia> pi
π = 3.1415926535897...

julia> pi = 3
ERROR: cannot assign a value to variable MathConstants.pi from module Main

julia> sqrt(100)
10.0

julia> sqrt = 4
ERROR: cannot assign a value to variable Base.sqrt from module Main
\end{minted}



\hypertarget{8427534705431371449}{}


\section{合法的变量名}



变量名字必须以英文字母（A-Z 或 a-z）、下划线或编码大于 00A0 的 Unicode 字符的一个子集开头。 具体来说指的是，\href{http://www.fileformat.info/info/unicode/category/index.htm}{Unicode字符分类}中的 Lu/Ll/Lt/Lm/Lo/Nl（字母）、Sc/So（货币和其他符号）以及一些其它像字母的符号（例如 Sm 类别数学符号中的一部分）。 变量名的非首字符还允许使用惊叹号 \texttt{!}、数字（包括 0-9 和其他 Nd/No 类别中的 Unicode 字符）以及其它 Unicode 字符：变音符号和其他修改标记（Mn/Mc/Me/Sk 类别）、标点和连接符（Pc 类别）、引号和少许其他字符。



像 \texttt{+} 这样的运算符也是合法的标识符，但是它们会被特别地解析。 在一些语境中，运算符可以像变量一样使用，比如 \texttt{(+)} 表示加函数，语句 \texttt{(+) = f} 会把它重新赋值。 大部分 Sm 类别中的 Unicode 中缀运算符，像 \texttt{⊕}，则会被解析成真正的中缀运算符，并且支持用户自定义方法（举个例子，你可以使用语句 \texttt{const ⊗ = kron} 将 \texttt{⊗} 定义为中缀的 Kronecker 积）。 运算符也可以使用修改标记、引号和上标/下标进行加缀，例如 \texttt{+̂ₐ″} 被解析成一个与 \texttt{+} 具有相同优先级的中缀运算符。



The only explicitly disallowed names for variables are the names of the built-in \href{@ref}{Keywords}:




\begin{minted}{jlcon}
julia> else = false
ERROR: syntax: unexpected "else"

julia> try = "No"
ERROR: syntax: unexpected "="
\end{minted}



Some Unicode characters are considered to be equivalent in identifiers. Different ways of entering Unicode combining characters (e.g., accents) are treated as equivalent (specifically, Julia identifiers are \href{http://www.macchiato.com/unicode/nfc-faq}{NFC}-normalized). The Unicode characters \texttt{ɛ} (U+025B: Latin small letter open e) and \texttt{µ} (U+00B5: micro sign) are treated as equivalent to the corresponding Greek letters, because the former are easily accessible via some input methods.



\hypertarget{1519367584459167025}{}


\section{命名规范}



虽然 Julia 语言对合法名字的限制非常少，但是遵循以下这些命名规范是非常有用的：



\begin{itemize}
\item 变量的名字采用小写。


\item 用下划线（\texttt{\_}）分隔名字中的单词，但是不鼓励使用下划线， 除非在不使用下划线时名字会非常难读。


\item 类型（Type）和模块（Module）的名字使用大写字母开头，并且用大写字母 而不是用下划线分隔单词。


\item 函数（Function）和宏（Macro）的名字使用小写，不使用下划线。


\item 会对输入参数进行更改的函数要使用 \texttt{!} 结尾。这些函数有时叫做 “mutating” 或 “in-place” 函数，因为它们在被调用后，不仅仅会返回一些值 还会更改输入参数的内容。

\end{itemize}


关于命名规范的更多信息，可查看\hyperlink{12507952184948113283}{代码风格指南}。



\hypertarget{9431281250101057989}{}


\chapter{整数和浮点数}



整数和浮点值是算术和计算的基础。这些数值的内置表示被称作原始数值类型（numeric primitive），且整数和浮点数在代码中作为立即数时称作数值字面量（numeric literal）。例如，\texttt{1} 是个整型字面量，\texttt{1.0} 是个浮点型字面量，它们在内存中作为对象的二进制表示就是原始数值类型。



Julia 提供了很丰富的原始数值类型，并基于它们定义了一整套算术操作，还提供按位运算符以及一些标准数学函数。这些函数能够直接映射到现代计算机原生支持的数值类型及运算上，因此 Julia 可以充分地利用运算资源。此外，Julia 还为\hyperlink{7537478913062818871}{任意精度算术}提供了软件支持，对于无法使用原生硬件表示的数值类型，Julia 也能够高效地处理其数值运算。当然，这需要相对的牺牲一些性能。



以下是 Julia 的原始数值类型：



\begin{itemize}
\item \textbf{整数类型：}

\end{itemize}



\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|L|L|}
\hline
类型 & 带符号？ & 比特数 & 最小值 & 最大值 \\
\hline
\hyperlink{5857518405103968275}{\texttt{Int8}} & ✓ & 8 & -2{\textasciicircum}7 & 2{\textasciicircum}7 - 1 \\
\hline
\hyperlink{6609065134969660118}{\texttt{UInt8}} &  & 8 & 0 & 2{\textasciicircum}8 - 1 \\
\hline
\hyperlink{6667287249103968645}{\texttt{Int16}} & ✓ & 16 & -2{\textasciicircum}15 & 2{\textasciicircum}15 - 1 \\
\hline
\hyperlink{7018610346698168012}{\texttt{UInt16}} &  & 16 & 0 & 2{\textasciicircum}16 - 1 \\
\hline
\hyperlink{10103694114785108551}{\texttt{Int32}} & ✓ & 32 & -2{\textasciicircum}31 & 2{\textasciicircum}31 - 1 \\
\hline
\hyperlink{8690996847580776341}{\texttt{UInt32}} &  & 32 & 0 & 2{\textasciicircum}32 - 1 \\
\hline
\hyperlink{7720564657383125058}{\texttt{Int64}} & ✓ & 64 & -2{\textasciicircum}63 & 2{\textasciicircum}63 - 1 \\
\hline
\hyperlink{5500998675195555601}{\texttt{UInt64}} &  & 64 & 0 & 2{\textasciicircum}64 - 1 \\
\hline
\hyperlink{8012327724714767060}{\texttt{Int128}} & ✓ & 128 & -2{\textasciicircum}127 & 2{\textasciicircum}127 - 1 \\
\hline
\hyperlink{14811222188335428522}{\texttt{UInt128}} &  & 128 & 0 & 2{\textasciicircum}128 - 1 \\
\hline
\hyperlink{46725311238864537}{\texttt{Bool}} & N/A & 8 & \texttt{false} (0) & \texttt{true} (1) \\
\hline
\end{tabulary}

\end{table}



\begin{itemize}
\item \textbf{浮点类型:}

\end{itemize}



\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
类型 & 精度 & 比特数 \\
\hline
\hyperlink{2727296760866702904}{\texttt{Float16}} & \href{https://en.wikipedia.org/wiki/Half-precision\_floating-point\_format}{half} & 16 \\
\hline
\hyperlink{8101639384272933082}{\texttt{Float32}} & \href{https://en.wikipedia.org/wiki/Single\_precision\_floating-point\_format}{single} & 32 \\
\hline
\hyperlink{5027751419500983000}{\texttt{Float64}} & \href{https://en.wikipedia.org/wiki/Double\_precision\_floating-point\_format}{double} & 64 \\
\hline
\end{tabulary}

\end{table}



此外，对\hyperlink{13366825053081777829}{复数和有理数}的完整支持是在这些原始数据类型之上建立起来的。多亏了 Julia 有一个很灵活的、用户可扩展的\hyperlink{10374023657104680331}{类型提升系统}，所有的数值类型都无需显式转换就可以很自然地相互进行运算。



\hypertarget{1329060658000677295}{}


\section{整数}



整数字面量以标准形式表示：




\begin{minted}{jlcon}
julia> 1
1

julia> 1234
1234
\end{minted}



整型字面量的默认类型取决于目标系统是 32 位还是 64 位架构：




\begin{minted}{jlcon}
# 32 位系统：
julia> typeof(1)
Int32

# 64 位系统：
julia> typeof(1)
Int64
\end{minted}



Julia 的内置变量 \hyperlink{6553323097149877235}{\texttt{Sys.WORD\_SIZE}} 表明了目标系统是 32 位还是 64 位架构：




\begin{minted}{jlcon}
# 32 位系统：
julia> Sys.WORD_SIZE
32

# 64 位系统：
julia> Sys.WORD_SIZE
64
\end{minted}



Julia 也定义了 \texttt{Int} 与 \texttt{UInt} 类型，它们分别是系统有符号和无符号的原生整数类型的别名。




\begin{minted}{jlcon}
# 32 位系统：
julia> Int
Int32
julia> UInt
UInt32

# 64 位系统：
julia> Int
Int64
julia> UInt
UInt64
\end{minted}



那些超过 32 位表示范围的大整数，如果能用 64 位表示，那么无论是什么系统都会用 64 位表示：




\begin{minted}{jlcon}
# 32 位或 64 位系统：
julia> typeof(3000000000)
Int64
\end{minted}



无符号整数会通过 \texttt{0x} 前缀以及十六进制数 \texttt{0-9a-f} 来输入和输出（输入也可以使用大写的 \texttt{A-F}）。无符号值的位数取决于十六进制数字使用的数量：




\begin{minted}{jlcon}
julia> 0x1
0x01

julia> typeof(ans)
UInt8

julia> 0x123
0x0123

julia> typeof(ans)
UInt16

julia> 0x1234567
0x01234567

julia> typeof(ans)
UInt32

julia> 0x123456789abcdef
0x0123456789abcdef

julia> typeof(ans)
UInt64

julia> 0x11112222333344445555666677778888
0x11112222333344445555666677778888

julia> typeof(ans)
UInt128
\end{minted}



采用这种做法是因为，当人们使用无符号十六进制字面量表示整数值的时候，通常会用它们来表示一个固定的数值字节序列，而不仅仅是个整数值。



还记得这个 \hyperlink{11288188119698492222}{\texttt{ans}} 变量吗？它存着交互式会话中上一个表达式的运算结果，但以其他方式运行的 Julia 代码中没有这个变量。



二进制和八进制字面量也是支持的：




\begin{minted}{jlcon}
julia> 0b10
0x02

julia> typeof(ans)
UInt8

julia> 0o010
0x08

julia> typeof(ans)
UInt8

julia> 0x00000000000000001111222233334444
0x00000000000000001111222233334444

julia> typeof(ans)
UInt128
\end{minted}



二进制、八进制和十六进制的字面量都会产生无符号的整数类型。当字面量不是开头全是 0 时，它们二进制数据项的位数会是最少需要的位数。当开头都是 \texttt{0} 时，位数取决于一个字面量需要的最少位数，这里的字面量指的是一个有着同样长度但开头都为 \texttt{1} 的数。这样用户就可以控制位数了。那些无法使用 \texttt{UInt128} 类型存储下的值无法写成这样的字面量。



二进制、八进制和十六进制的字面量可以在前面紧接着加一个负号 \texttt{-}，这样可以产生一个和原字面量有着同样位数而值为原数的补码的数（二补数）：




\begin{minted}{jlcon}
julia> -0x2
0xfe

julia> -0x0002
0xfffe
\end{minted}



整型等原始数值类型的最小和最大可表示的值可用 \hyperlink{3613894539247233488}{\texttt{typemin}} 和 \hyperlink{17760305803764597758}{\texttt{typemax}} 函数得到：




\begin{minted}{jlcon}
julia> (typemin(Int32), typemax(Int32))
(-2147483648, 2147483647)

julia> for T in [Int8,Int16,Int32,Int64,Int128,UInt8,UInt16,UInt32,UInt64,UInt128]
           println("$(lpad(T,7)): [$(typemin(T)),$(typemax(T))]")
       end
   Int8: [-128,127]
  Int16: [-32768,32767]
  Int32: [-2147483648,2147483647]
  Int64: [-9223372036854775808,9223372036854775807]
 Int128: [-170141183460469231731687303715884105728,170141183460469231731687303715884105727]
  UInt8: [0,255]
 UInt16: [0,65535]
 UInt32: [0,4294967295]
 UInt64: [0,18446744073709551615]
UInt128: [0,340282366920938463463374607431768211455]
\end{minted}



The values returned by \hyperlink{3613894539247233488}{\texttt{typemin}} and \hyperlink{17760305803764597758}{\texttt{typemax}} are always of the given argument type. (The above expression uses several features that have yet to be introduced, including \hyperlink{9034109510149997190}{for loops}, \hyperlink{205866387929607333}{Strings}, and \hyperlink{4452850363638134205}{Interpolation}, but should be easy enough to understand for users with some existing programming experience.)



\hypertarget{7600249066838051055}{}


\subsection{溢出行为}



Julia 中，超出一个类型可表示的最大值会导致循环行为：




\begin{minted}{jlcon}
julia> x = typemax(Int64)
9223372036854775807

julia> x + 1
-9223372036854775808

julia> x + 1 == typemin(Int64)
true
\end{minted}



因此，Julia 的整数算术实际上是\href{https://zh.wikipedia.org/wiki/\%E6\%A8\%A1\%E7\%AE\%97\%E6\%95\%B8}{模算数}的一种形式，它反映了现代计算机实现底层算术的特点。在可能有溢出产生的程序中，对最值边界出现循环进行显式检查是必要的。否则，推荐使用\hyperlink{7537478913062818871}{任意精度算术}中的 \hyperlink{423405808990690832}{\texttt{BigInt}} 类型作为替代。



An example of overflow behavior and how to potentially resolve it is as follows:




\begin{minted}{jlcon}
julia> 10^19
-8446744073709551616

julia> big(10)^19
10000000000000000000
\end{minted}



\hypertarget{18099425100953658872}{}


\subsection{除法错误}



\texttt{div} 函数的整数除法有两种异常情况：除以零，以及使用 -1 去除最小的负数（\hyperlink{3613894539247233488}{\texttt{typemin}}）。 这两种情况都会抛出一个 \hyperlink{4168463413201806292}{\texttt{DivideError}} 错误。 \texttt{rem} 取余函数和 \texttt{mod} 取模函数在除零时抛出 \hyperlink{4168463413201806292}{\texttt{DivideError}} 错误。



\hypertarget{7313324545649063110}{}


\section{浮点数}



浮点数字面量也使用标准格式表示，必要时可使用 \href{https://en.wikipedia.org/wiki/Scientific\_notation\#E-notation}{E-表示法}：




\begin{minted}{jlcon}
julia> 1.0
1.0

julia> 1.
1.0

julia> 0.5
0.5

julia> .5
0.5

julia> -1.23
-1.23

julia> 1e10
1.0e10

julia> 2.5e-4
0.00025
\end{minted}



上面的结果都是 \hyperlink{5027751419500983000}{\texttt{Float64}} 值。使用 \texttt{f} 替代 \texttt{e} 可以得到 \hyperlink{8101639384272933082}{\texttt{Float32}} 的字面量：




\begin{minted}{jlcon}
julia> 0.5f0
0.5f0

julia> typeof(ans)
Float32

julia> 2.5f-4
0.00025f0
\end{minted}



数值容易就能转换成 \hyperlink{8101639384272933082}{\texttt{Float32}}：




\begin{minted}{jlcon}
julia> Float32(-1.5)
-1.5f0

julia> typeof(ans)
Float32
\end{minted}



也存在十六进制的浮点数字面量，但只适用于 \hyperlink{5027751419500983000}{\texttt{Float64}} 值。一般使用 \texttt{p} 前缀及以 2 为底的指数来表示：




\begin{minted}{jlcon}
julia> 0x1p0
1.0

julia> 0x1.8p3
12.0

julia> 0x.4p-1
0.125

julia> typeof(ans)
Float64
\end{minted}



Julia 也支持半精度浮点数（\hyperlink{2727296760866702904}{\texttt{Float16}}），但它们是使用 \hyperlink{8101639384272933082}{\texttt{Float32}} 进行模拟实现的。




\begin{minted}{jlcon}
julia> sizeof(Float16(4.))
2

julia> 2*Float16(4.)
Float16(8.0)
\end{minted}



下划线 \texttt{\_} 可用作数字分隔符：




\begin{minted}{jlcon}
julia> 10_000, 0.000_000_005, 0xdead_beef, 0b1011_0010
(10000, 5.0e-9, 0xdeadbeef, 0xb2)
\end{minted}



\hypertarget{3917895508430327726}{}


\subsection{浮点数中的零}



浮点数有\href{https://zh.wikipedia.org/wiki/\%E2\%88\%920}{两个零}，正零和负零。它们相互相等但有着不同的二进制表示，可以使用 \hyperlink{9171163989026657457}{\texttt{bitstring}} 函数来查看：




\begin{minted}{jlcon}
julia> 0.0 == -0.0
true

julia> bitstring(0.0)
"0000000000000000000000000000000000000000000000000000000000000000"

julia> bitstring(-0.0)
"1000000000000000000000000000000000000000000000000000000000000000"
\end{minted}



\hypertarget{16626704755049875766}{}


\subsection{特殊的浮点值}



有三种特定的标准浮点值不和实数轴上任何一点对应：




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|L|L|}
\hline
\texttt{Float16} & \texttt{Float32} & \texttt{Float64} & 名称 & 描述 \\
\hline
\texttt{Inf16} & \texttt{Inf32} & \texttt{Inf} & 正无穷 & 一个大于所有有限浮点数的数 \\
\hline
\texttt{-Inf16} & \texttt{-Inf32} & \texttt{-Inf} & 负无穷 & 一个小于所有有限浮点数的数 \\
\hline
\texttt{NaN16} & \texttt{NaN32} & \texttt{NaN} & 不是数（Not a Number） & 一个不和任何浮点值（包括自己）相等（\texttt{==}）的值 \\
\hline
\end{tabulary}

\end{table}



对于这些非有限浮点值相互之间以及关于其它浮点值的顺序的更多讨论，请参见\hyperlink{7125151170457482788}{数值比较}。根据 \href{https://en.wikipedia.org/wiki/IEEE\_754\_revision}{IEEE 754 标准}，这些浮点值是某些算术运算的结果：




\begin{minted}{jlcon}
julia> 1/Inf
0.0

julia> 1/0
Inf

julia> -5/0
-Inf

julia> 0.000001/0
Inf

julia> 0/0
NaN

julia> 500 + Inf
Inf

julia> 500 - Inf
-Inf

julia> Inf + Inf
Inf

julia> Inf - Inf
NaN

julia> Inf * Inf
Inf

julia> Inf / Inf
NaN

julia> 0 * Inf
NaN
\end{minted}



\hyperlink{3613894539247233488}{\texttt{typemin}} 和 \hyperlink{17760305803764597758}{\texttt{typemax}} 函数同样适用于浮点类型：




\begin{minted}{jlcon}
julia> (typemin(Float16),typemax(Float16))
(-Inf16, Inf16)

julia> (typemin(Float32),typemax(Float32))
(-Inf32, Inf32)

julia> (typemin(Float64),typemax(Float64))
(-Inf, Inf)
\end{minted}



\hypertarget{7614874233242990296}{}


\subsection{机器精度}



大多数实数都无法用浮点数准确地表示，因此有必要知道两个相邻可表示的浮点数间的距离。它通常被叫做\href{https://en.wikipedia.org/wiki/Machine\_epsilon}{机器精度}。



Julia 提供了 \hyperlink{4594213520310841636}{\texttt{eps}} 函数，它可以给出 \texttt{1.0} 与下一个 Julia 能表示的浮点数之间的差值：




\begin{minted}{jlcon}
julia> eps(Float32)
1.1920929f-7

julia> eps(Float64)
2.220446049250313e-16

julia> eps() # 与 eps(Float64) 相同
2.220446049250313e-16
\end{minted}



这些值分别是 \hyperlink{8101639384272933082}{\texttt{Float32}} 中的 \texttt{2.0{\textasciicircum}-23} 和 \hyperlink{5027751419500983000}{\texttt{Float64}} 中的 \texttt{2.0{\textasciicircum}-52}。\hyperlink{4594213520310841636}{\texttt{eps}} 函数也可以接受一个浮点值作为参数，然后给出这个值与下一个可表示的值直接的绝对差。也就是说，\texttt{eps(x)} 产生一个和 \texttt{x} 类型相同的值使得 \texttt{x + eps(x)} 是比 \texttt{x} 更大的下一个可表示的浮点值：




\begin{minted}{jlcon}
julia> eps(1.0)
2.220446049250313e-16

julia> eps(1000.)
1.1368683772161603e-13

julia> eps(1e-27)
1.793662034335766e-43

julia> eps(0.0)
5.0e-324
\end{minted}



两个相邻可表示的浮点数之间的距离并不是常数，数值越小，间距越小，数值越大，间距越大。换句话说，可表示的浮点数在实数轴上的零点附近最稠密，并沿着远离零点的方向以指数型的速度变得越来越稀疏。根据定义，\texttt{eps(1.0)} 与 \texttt{eps(Float64)} 相等，因为 \texttt{1.0} 是个 64 位浮点值。



Julia 也提供了 \hyperlink{8339500090035450608}{\texttt{nextfloat}} 和 \hyperlink{14035790731013288499}{\texttt{prevfloat}} 两个函数分别返回基于参数的下一个更大或更小的可表示的浮点数：




\begin{minted}{jlcon}
julia> x = 1.25f0
1.25f0

julia> nextfloat(x)
1.2500001f0

julia> prevfloat(x)
1.2499999f0

julia> bitstring(prevfloat(x))
"00111111100111111111111111111111"

julia> bitstring(x)
"00111111101000000000000000000000"

julia> bitstring(nextfloat(x))
"00111111101000000000000000000001"
\end{minted}



这个例子体现了一般原则，即相邻可表示的浮点数也有着相邻的二进制整数表示。



\hypertarget{5125794393878787955}{}


\subsection{舍入模式}



一个数如果没有精确的浮点表示，就必须被舍入到一个合适的可表示的值。然而，如果想的话，可以根据舍入模式改变舍入的方式，如 \href{https://en.wikipedia.org/wiki/IEEE\_754-2008}{IEEE 754 标准} 所述。 



Julia 所使用的默认模式总是 \hyperlink{868115654703135309}{\texttt{RoundNearest}}，指舍入到最接近的可表示的值，这个被舍入的值会使用尽量少的有效位数。



\hypertarget{6428114724945706317}{}


\subsection{基础知识与参考文献}



浮点算术带来了很多微妙之处，它们可能对于那些不熟悉底层实现细节的用户会是很出人意料的。然而，这些微妙之处在大部分科学计算的书籍中以及以下的参考资料中都有详细介绍:



\begin{itemize}
\item 浮点数算术的权威指南是 \href{https://standards.ieee.org/standard/754-2008.html}{IEEE 754-2008 标准}； 然而这篇标准在网上无法免费获得。


\item 关于浮点数是如何表示的，想要一个简单而明白的介绍的话，可以看 John D. Cook 的\href{https://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-point-number/}{文章}以及他关于从这种表示与实数理想的抽象化的差别中产生的一些问题的\href{https://www.johndcook.com/blog/2009/04/06/numbers-are-a-leaky-abstraction/}{介绍}


\item 同样推荐 Bruce Dawson 的\href{https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats}{一系列关于浮点数的博客文章}。


\item 想要一个对浮点数和使用浮点数计算时产生的数值精度问题的极好的、有深度的讨论，可以参见 David Goldberg 的文章 \href{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.6768\&rep=rep1\&type=pdf}{What Every Computer Scientist Should Know About Floating-Point Arithmetic}。


\item 更多延伸文档，包括浮点数的历史、基础理论、问题以及数值计算中很多其它主题的讨论，可以参见 \href{https://en.wikipedia.org/wiki/William\_Kahan}{William Kahan} 的\href{https://people.eecs.berkeley.edu/{\textasciitilde}wkahan/}{写作集}。他以“浮点数之父”闻名。特别感兴趣的话可以看 \href{https://people.eecs.berkeley.edu/{\textasciitilde}wkahan/ieee754status/754story.html}{An Interview with the Old Man of Floating-Point}。

\end{itemize}


\hypertarget{5997763766467609329}{}


\section{任意精度算术}



为了允许使用任意精度的整数与浮点数，Julia 分别包装了 \href{https://gmplib.org}{GNU Multiple Precision Arithmetic Library (GMP)} 以及 \href{https://www.mpfr.org}{GNU MPFR Library}。Julia 中的 \hyperlink{423405808990690832}{\texttt{BigInt}} 与 \hyperlink{749816618809421837}{\texttt{BigFloat}} 两种类型分别提供了任意精度的整数和浮点数。



Constructors exist to create these types from primitive numerical types, and the \href{@ref non-standard-string-literals}{string literal} \hyperlink{4226571565562941917}{\texttt{@big\_str}} or \hyperlink{14207407853646164654}{\texttt{parse}} can be used to construct them from \texttt{AbstractString}s.  Once created, they participate in arithmetic with all other numeric types thanks to Julia{\textquotesingle}s \hyperlink{10374023657104680331}{type promotion and conversion mechanism}:




\begin{minted}{jlcon}
julia> BigInt(typemax(Int64)) + 1
9223372036854775808

julia> big"123456789012345678901234567890" + 1
123456789012345678901234567891

julia> parse(BigInt, "123456789012345678901234567890") + 1
123456789012345678901234567891

julia> big"1.23456789012345678901"
1.234567890123456789010000000000000000000000000000000000000000000000000000000004

julia> parse(BigFloat, "1.23456789012345678901")
1.234567890123456789010000000000000000000000000000000000000000000000000000000004

julia> BigFloat(2.0^66) / 3
2.459565876494606882133333333333333333333333333333333333333333333333333333333344e+19

julia> factorial(BigInt(40))
815915283247897734345611269596115894272000000000
\end{minted}



然而，上面的原始类型与 \hyperlink{423405808990690832}{\texttt{BigInt}}/\hyperlink{749816618809421837}{\texttt{BigFloat}} 之间的类型提升并不是自动的，需要明确地指定：




\begin{minted}{jlcon}
julia> x = typemin(Int64)
-9223372036854775808

julia> x = x - 1
9223372036854775807

julia> typeof(x)
Int64

julia> y = BigInt(typemin(Int64))
-9223372036854775808

julia> y = y - 1
-9223372036854775809

julia> typeof(y)
BigInt
\end{minted}



\hyperlink{749816618809421837}{\texttt{BigFloat}} 的默认精度（有效数字的位数）和舍入模式可以通过调用 \hyperlink{3543074496498234209}{\texttt{setprecision}} 和 \hyperlink{12025922235501343815}{\texttt{setrounding}} 来全局地改变，所有之后的计算都会根据这些改变进行。还有一种方法，可以使用同样的函数以及 \texttt{do}-block 来只在运行一个特定代码块时改变精度和舍入模式：




\begin{minted}{jlcon}
julia> setrounding(BigFloat, RoundUp) do
           BigFloat(1) + parse(BigFloat, "0.1")
       end
1.100000000000000000000000000000000000000000000000000000000000000000000000000003

julia> setrounding(BigFloat, RoundDown) do
           BigFloat(1) + parse(BigFloat, "0.1")
       end
1.099999999999999999999999999999999999999999999999999999999999999999999999999986

julia> setprecision(40) do
           BigFloat(1) + parse(BigFloat, "0.1")
       end
1.1000000000004
\end{minted}



\hypertarget{14058350023597195643}{}


\section{数值字面量系数}



为了让常见的数值公式和表达式更清楚，Julia 允许变量直接跟在一个数值字面量后，暗指乘法。这可以让写多项式变得很清楚：




\begin{minted}{jlcon}
julia> x = 3
3

julia> 2x^2 - 3x + 1
10

julia> 1.5x^2 - .5x + 1
13.0
\end{minted}



也会让写指数函数变得更加优雅：




\begin{minted}{jlcon}
julia> 2^2x
64
\end{minted}



数值字面量系数的优先级跟一元运算符相同，比如说取相反数。所以 \texttt{2{\textasciicircum}3x} 会被解析成 \texttt{2{\textasciicircum}(3x)}，而 \texttt{2x{\textasciicircum}3} 会被解析成 \texttt{2*(x{\textasciicircum}3)}。



数值字面量也能作为被括号表达式的系数：




\begin{minted}{jlcon}
julia> 2(x-1)^2 - 3(x-1) + 1
3
\end{minted}



\begin{quote}
\textbf{Note}

用于隐式乘法的数值字面量系数的优先级高于其它的二元运算符，例如乘法（\texttt{*}）和除法（\texttt{/}、\texttt{{\textbackslash}} 以及 \texttt{//}）。这意味着，比如说，\texttt{1 / 2im} 等于 \texttt{-0.5im} 以及 \texttt{6 // 2(2+1)} 等于 \texttt{1 // 1}。

\end{quote}


此外，括号表达式可以被用作变量的系数，暗指表达式与变量相乘：




\begin{minted}{jlcon}
julia> (x-1)x
6
\end{minted}



但是，无论是把两个括号表达式并列，还是把变量放在括号表达式之前，都不会被用作暗指乘法：




\begin{minted}{jlcon}
julia> (x-1)(x+1)
ERROR: MethodError: objects of type Int64 are not callable

julia> x(x+1)
ERROR: MethodError: objects of type Int64 are not callable
\end{minted}



这两种表达式都会被解释成函数调用：所有不是数值字面量的表达式，后面紧跟一个括号，就会被解释成使用括号内的值来调用函数（更多关于函数的信息请参见\hyperlink{16900494992832782120}{函数}）。因此，在这两种情况中，都会因为左手边的值并不是函数而产生错误。



上述的语法糖显著地降低了在写普通数学公式时的视觉干扰。注意数值字面量系数和后面用来相乘的标识符或括号表达式之间不能有空格。



\hypertarget{5522643503764211248}{}


\subsection{语法冲突}



并列的字面量系数语法可能和两种数值字面量语法产生冲突：十六进制整数字面量以及浮点字面量的工程表示法。下面是几种会产生语法冲突的情况：



\begin{itemize}
\item 十六进制整数字面量 \texttt{0xff} 可能被解释成数值字面量 \texttt{0} 乘以变量 \texttt{xff}。


\item 浮点字面量表达式 \texttt{1e10} 可以被解释成数值字面量 \texttt{1} 乘以变量 \texttt{e10}，与之等价的 \texttt{E}-表示法也存在类似的情况。


\item 32-bit 的浮点数字面量 \texttt{1.5f22} 被解释成数值字面量 \texttt{1.5} 乘以变量 \texttt{f22}。

\end{itemize}


在这些所有的情况中，都使用这样的解释方式来解决歧义：



\begin{itemize}
\item \texttt{0x} 开头的表达式总是十六进制字面量。


\item 数值开头跟着 \texttt{e} 和 \texttt{E} 的表达式总是浮点字面量。


\item 数值开头跟着 \texttt{f} 的表达式总是 32-bit 浮点字面量。

\end{itemize}


由于历史原因 \texttt{E} 和 \texttt{e} 在数值字面量上是等价的，与之不同的是，\texttt{F} 只是一个行为和 \texttt{f} 不同的字母。因此开头为 \texttt{F} 的表达式将会被 解析为一个数值字面量乘以一个变量，例如 \texttt{1.5F22}等价于 \texttt{1.5 * F22}。



\hypertarget{15171481192117197140}{}


\section{零和一的字面量}



Julia 提供了 0 和 1 的字面量函数，可以返回特定类型或所给变量的类型。




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
函数 & 描述 \\
\hline
\hyperlink{240596739242881814}{\texttt{zero(x)}} & \texttt{x} 类型或变量 \texttt{x} 的类型的零字面量 \\
\hline
\hyperlink{11395333326208453101}{\texttt{one(x)}} & \texttt{x} 类型或变量 \texttt{x} 的类型的一字面量 \\
\hline
\end{tabulary}

\end{table}



这些函数在\hyperlink{7125151170457482788}{数值比较}中可以用来避免不必要的\hyperlink{10374023657104680331}{类型转换}带来的开销。



例如：




\begin{minted}{jlcon}
julia> zero(Float32)
0.0f0

julia> zero(1.0)
0.0

julia> one(Int32)
1

julia> one(BigFloat)
1.0
\end{minted}



\hypertarget{7792257531330504645}{}


\chapter{数学运算和初等函数}



Julia 为它所有的基础数值类型，提供了整套的基础算术和位运算，也提供了一套高效、可移植的标准数学函数。



\hypertarget{11578520796345832337}{}


\section{算术运算符}



以下\href{https://en.wikipedia.org/wiki/Arithmetic\#Arithmetic\_operations}{算术运算符}支持所有的原始数值类型：




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
表达式 & 名称 & 描述 \\
\hline
\texttt{+x} & 一元加法运算符 & 全等操作 \\
\hline
\texttt{-x} & 一元减法运算符 & 将值变为其相反数 \\
\hline
\texttt{x + y} & 二元加法运算符 & 执行加法 \\
\hline
\texttt{x - y} & 二元减法运算符 & 执行减法 \\
\hline
\texttt{x * y} & 乘法运算符 & 执行乘法 \\
\hline
\texttt{x / y} & 除法运算符 & 执行除法 \\
\hline
\texttt{x ÷ y} & 整除 & 取 x / y 的整数部分 \\
\hline
\texttt{x {\textbackslash} y} & 反向除法 & 等价于 \texttt{y / x} \\
\hline
\texttt{x {\textasciicircum} y} & 幂操作符 & \texttt{x} 的 \texttt{y} 次幂 \\
\hline
\texttt{x \% y} & 取余 & 等价于 \texttt{rem(x,y)} \\
\hline
\end{tabulary}

\end{table}



以及对 \hyperlink{46725311238864537}{\texttt{Bool}} 类型的否定：




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
表达式 & 名称 & 描述 \\
\hline
\texttt{!x} & 否定 & 将 \texttt{true} 和 \texttt{false} 互换 \\
\hline
\end{tabulary}

\end{table}



除了优先级比二元操作符高以外，直接放在标识符或括号前的数字，如 \texttt{2x} 或 \texttt{2(x+y)} 还会被视为乘法。详见\hyperlink{7285052708387693199}{数值字面量系数}。



Julia 的类型提升系统使得混合参数类型上的代数运算也能顺其自然的工作，请参考\hyperlink{10374023657104680331}{类型提升系统}来了解更多内容。



这里是使用算术运算符的一些简单例子：




\begin{minted}{jlcon}
julia> 1 + 2 + 3
6

julia> 1 - 2
-1

julia> 3*2/12
0.5
\end{minted}



习惯上我们会把优先运算的操作符紧邻操作数，比如 \texttt{-x + 2} 表示先要给 \texttt{x}  取反，然后再加 \texttt{2} 。



When used in multiplication, \texttt{false} acts as a \emph{strong zero}:




\begin{minted}{jlcon}
julia> NaN * false
0.0

julia> false * Inf
0.0
\end{minted}



This is useful for preventing the propagation of \texttt{NaN} values in quantities that are known to be zero. See \href{https://arxiv.org/abs/math/9205211}{Knuth (1992)} for motivation.



\hypertarget{17155361622718020970}{}


\section{位运算符}



所有原始整数类型都支持以下\href{https://en.wikipedia.org/wiki/Bitwise\_operation\#Bitwise\_operators}{位运算符}：




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
表达式 & 名称 \\
\hline
\texttt{{\textasciitilde}x} & 按位取反 \\
\hline
\texttt{x \& y} & 按位与 \\
\hline
\texttt{x | y} & 按位或 \\
\hline
\texttt{x \unicodeveebar{} y} & 按位异或（逻辑异或） \\
\hline
\texttt{x >>> y} & \href{https://en.wikipedia.org/wiki/Logical\_shift}{逻辑右移} \\
\hline
\texttt{x >> y} & \href{https://en.wikipedia.org/wiki/Arithmetic\_shift}{算术右移} \\
\hline
\texttt{x << y} & 逻辑/算术左移 \\
\hline
\end{tabulary}

\end{table}



以下是位运算符的一些示例：




\begin{minted}[escapeinside=\#\%]{jlcon}
julia> ~123
-124

julia> 123 & 234
106

julia> 123 | 234
251

julia> 123 #\unicodeveebar% 234
145

julia> xor(123, 234)
145

julia> ~UInt32(123)
0xffffff84

julia> ~UInt8(123)
0x84
\end{minted}



\hypertarget{7921616576688360161}{}


\section{复合赋值操作符}



每一个二元运算符和位运算符都可以给左操作数复合赋值：方法是把 \texttt{=} 直接放在二元运算符后面。比如，\texttt{x += 3} 等价于 \texttt{x = x + 3} 。




\begin{minted}{jlcon}
julia> x = 1
1

julia> x += 3
4

julia> x
4
\end{minted}



二元运算和位运算的复合赋值操作符有下面几种：




\begin{lstlisting}[escapeinside=\%\%]
+=  -=  *=  /=  \=  ÷=  %\%%=  ^=  &=  |=  %\unicodeveebar%=  >>>=  >>=  <<=
\end{lstlisting}



\begin{quote}
\textbf{Note}

复合赋值后会把变量重新绑定到左操作数上，所以变量的类型可能会改变。


\begin{minted}{jlcon}
julia> x = 0x01; typeof(x)
UInt8

julia> x *= 2 # 与 x = x * 2 相同
2

julia> typeof(x)
Int64
\end{minted}

\end{quote}


\hypertarget{6173297391052343261}{}


\section{向量化 \texttt{dot} 运算符}



Julia 中，\textbf{每个}二元运算符都有一个 \texttt{dot} 运算符与之对应，例如 \texttt{{\textasciicircum}} 就有对应的 \texttt{.{\textasciicircum}} 存在。这个对应的 \texttt{.{\textasciicircum}} 被 Julia \textbf{自动地}定义为逐元素地执行 \texttt{{\textasciicircum}} 运算。比如 \texttt{[1,2,3] {\textasciicircum} 3} 是非法的，因为数学上没有给（长宽不一样的）数组的立方下过定义。但是 \texttt{[1,2,3] .{\textasciicircum} 3} 在 Julia 里是合法的，它会逐元素地执行 \texttt{{\textasciicircum}} 运算（或称向量化运算），得到 \texttt{[1{\textasciicircum}3, 2{\textasciicircum}3, 3{\textasciicircum}3]}。类似地，\texttt{!} 或 \texttt{√} 这样的一元运算符，也都有一个对应的 \texttt{.√} 用于执行逐元素运算。




\begin{minted}{jlcon}
julia> [1,2,3] .^ 3
3-element Array{Int64,1}:
  1
  8
 27
\end{minted}



具体来说，\texttt{a .{\textasciicircum} b} 被解析为 \hyperlink{17801130558550430478}{\texttt{dot} 调用} \texttt{({\textasciicircum}).(a,b)}，这会执行 \href{@ref Broadcasting}{broadcast} 操作：该操作能结合数组和标量、相同大小的数组（元素之间的运算）、甚至不同形状的数组（例如行、列向量结合生成矩阵）。更进一步，就像所有向量化的 \texttt{dot} 调用一样，这些 \texttt{dot} 运算符是\textbf{融合}的（fused）。例如，在计算表达式 \texttt{2 .* A.{\textasciicircum}2 .+ sin.(A)} 时，Julia 只对 \texttt{A} 进行做\textbf{一次}循环，遍历 \texttt{A} 中的每个元素 a 并计算 \texttt{2a{\textasciicircum}2 + sin(a)}。上述表达式也可以用\hyperlink{16688502228717894452}{\texttt{@.}} 宏简写为 \texttt{@. 2A{\textasciicircum}2 + sin(A)}。特别的，类似 \texttt{f.(g.(x))} 的嵌套 \texttt{dot} 调用也是\textbf{融合}的，并且“相邻的”二元运算符表达式 \texttt{x .+ 3 .* x.{\textasciicircum}2} 可以等价转换为嵌套 \texttt{dot} 调用：\texttt{(+).(x, (*).(3, ({\textasciicircum}).(x, 2)))}。



除了 \texttt{dot} 运算符，我们还有 \texttt{dot} 复合赋值运算符，类似 \texttt{a .+= b}（或者 \texttt{@. a += b}）会被解析成 \texttt{a .= a .+ b}，这里的 \texttt{.=} 是一个\textbf{融合}的 in-place 运算，更多信息请查看 \hyperlink{17801130558550430478}{\texttt{dot} 文档}）。



这个点语法，也能用在用户自定义的运算符上。例如，通过定义 \texttt{⊗(A,B) = kron(A,B)} 可以为 Kronecker 积（\hyperlink{14153417388267953812}{\texttt{kron}}）提供一个方便的中缀语法 \texttt{A ⊗ B}，那么配合点语法 \texttt{[A,B] .⊗ [C,D]} 就等价于 \texttt{[A⊗C, B⊗D]}。



将点运算符用于数值字面量可能会导致歧义。例如，\texttt{1.+x} 到底是表示 \texttt{1. + x} 还是 \texttt{1 .+ x}？这会令人疑惑。因此不允许使用这种语法，遇到这种情况时，必须明确地用空格消除歧义。



\hypertarget{2028216132575181376}{}


\section{数值比较}



标准的比较操作对所有原始数值类型有定义：




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
操作符 & 名称 \\
\hline
\hyperlink{15143149452920304570}{\texttt{==}} & 相等 \\
\hline
\hyperlink{3046079188653285114}{\texttt{!=}}, \hyperlink{3046079188653285114}{\texttt{≠}} & 不等 \\
\hline
\hyperlink{702782232449268329}{\texttt{<}} & 小于 \\
\hline
\hyperlink{11411050964021316526}{\texttt{<=}}, \hyperlink{11411050964021316526}{\texttt{≤}} & 小于等于 \\
\hline
\hyperlink{8677991761303191103}{\texttt{>}} & 大于 \\
\hline
\hyperlink{7019639580556993898}{\texttt{>=}}, \hyperlink{7019639580556993898}{\texttt{≥}} & 大于等于 \\
\hline
\end{tabulary}

\end{table}



下面是一些简单的例子：




\begin{minted}{jlcon}
julia> 1 == 1
true

julia> 1 == 2
false

julia> 1 != 2
true

julia> 1 == 1.0
true

julia> 1 < 2
true

julia> 1.0 > 3
false

julia> 1 >= 1.0
true

julia> -1 <= 1
true

julia> -1 <= -1
true

julia> -1 <= -2
false

julia> 3 < -0.5
false
\end{minted}



整数的比较方式是标准的按位比较，而浮点数的比较方式则遵循 \href{https://en.wikipedia.org/wiki/IEEE\_754-2008}{IEEE 754 标准}。



\begin{itemize}
\item 有限数的大小顺序，和我们所熟知的相同。


\item \texttt{+0} 等于但不大于 \texttt{-0}.


\item \texttt{Inf} 等于自身，并且大于除了 \texttt{NaN} 外的所有数。


\item \texttt{-Inf} is equal to itself and less than everything else except \texttt{NaN}.


\item \texttt{NaN} 不等于、不小于且不大于任何数值，包括它自己。

\end{itemize}


\texttt{NaN} 不等于它自己这一点可能会令人感到惊奇，所以需要注意：




\begin{minted}{jlcon}
julia> NaN == NaN
false

julia> NaN != NaN
true

julia> NaN < NaN
false

julia> NaN > NaN
false
\end{minted}



当你将 \texttt{NaN} 和 \hyperlink{16720099245556932994}{数组} 一起连用时，你就会感到头疼：




\begin{minted}{jlcon}
julia> [1 NaN] == [1 NaN]
false
\end{minted}



为此，Julia 给这些特别的数提供了下面几个额外的测试函数。这些函数在某些情况下很有用处，比如在做 hash 比较时。




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
函数 & 测试是否满足如下性质 \\
\hline
\hyperlink{269533589463185031}{\texttt{isequal(x, y)}} & \texttt{x} 与 \texttt{y} 是完全相同的 \\
\hline
\hyperlink{2906021895910968108}{\texttt{isfinite(x)}} & \texttt{x} 是有限大的数字 \\
\hline
\hyperlink{4492113908831448207}{\texttt{isinf(x)}} & \texttt{x} 是（正/负）无穷大 \\
\hline
\hyperlink{6770390199496851634}{\texttt{isnan(x)}} & \texttt{x} 是 \texttt{NaN} \\
\hline
\end{tabulary}

\end{table}



\hyperlink{269533589463185031}{\texttt{isequal}} 认为 \texttt{NaN} 之间是相等的：




\begin{minted}{jlcon}
julia> isequal(NaN, NaN)
true

julia> isequal([1 NaN], [1 NaN])
true

julia> isequal(NaN, NaN32)
true
\end{minted}



\texttt{isequal} 也能用来区分带符号的零：




\begin{minted}{jlcon}
julia> -0.0 == 0.0
true

julia> isequal(-0.0, 0.0)
false
\end{minted}



有符号整数、无符号整数以及浮点数之间的混合类型比较是很棘手的。开发者费了很大精力来确保 Julia 在这个问题上做的是正确的。



对于其它类型，\texttt{isequal} 会默认调用 \hyperlink{15143149452920304570}{\texttt{==}}，所以如果你想给自己的类型定义相等，那么就只需要为 \hyperlink{15143149452920304570}{\texttt{==}} 增加一个方法。如果你想定义一个你自己的相等函数，你可能需要定义一个对应的 \hyperlink{13797072367283572032}{\texttt{hash}} 方法，用于确保 \texttt{isequal(x,y)} 隐含着 \texttt{hash(x) == hash(y)}。



\hypertarget{9107485161550737856}{}


\subsection{链式比较}



与其他多数语言不同，就像 \href{https://en.wikipedia.org/wiki/Python\_syntax\_and\_semantics\#Comparison\_operators}{notable exception of Python} 一样，Julia 允许链式比较：




\begin{minted}{jlcon}
julia> 1 < 2 <= 2 < 3 == 3 > 2 >= 1 == 1 < 3 != 5
true
\end{minted}



链式比较在写数值代码时特别方便，它使用 \texttt{\&\&} 运算符比较标量，数组则用 \hyperlink{1494761116451616317}{\texttt{\&}} 进行按元素比较。比如，\texttt{0 .< A .< 1} 会得到一个 boolean 数组，如果 \texttt{A} 的元素都在 0 和 1 之间则数组元素就都是 true。



注意链式比较的执行顺序：




\begin{minted}{jlcon}
julia> v(x) = (println(x); x)
v (generic function with 1 method)

julia> v(1) < v(2) <= v(3)
2
1
3
true

julia> v(1) > v(2) <= v(3)
2
1
false
\end{minted}



中间的表达式只会计算一次，而如果写成 \texttt{v(1) < v(2) \&\& v(2) <= v(3)} 是计算了两次的。然而，链式比较中的顺序是不确定的。强烈建议不要在表达式中使用有副作用（比如 printing）的函数。如果的确需要，请使用短路运算符 \texttt{\&\&}（请参考\hyperlink{7551496361738057869}{短路求值}）。



\hypertarget{6116621209452494602}{}


\subsection{初等函数}



Julia 提供了强大的数学函数和运算符集合。这些数学运算定义在各种合理的数值上，包括整型、浮点数、分数和复数，只要这些定义有数学意义就行。



而且，和其它 Julia 函数一样，这些函数也能通过 \hyperlink{17801130558550430478}{点语法} \texttt{f.(A)} 以“向量化”的方式作用于数组和其它集合上。 比如，\texttt{sin.(A)} 会计算 \texttt{A} 中每个元素的 sin 值。



\hypertarget{1086128937891391302}{}


\section{运算符的优先级与结合性}



从高到低，Julia 运算符的优先级与结合性为：




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
分类 & 运算符 & 结合性 \\
\hline
语法 & \texttt{.} followed by \texttt{::} & 左结合 \\
\hline
幂运算 & \texttt{{\textasciicircum}} & 右结合 \\
\hline
一元运算符 & \texttt{+ - √} & 右结合\footnotemark[1] \\
\hline
移位运算 & \texttt{<< >> >>>} & 左结合 \\
\hline
除法 & \texttt{//} & 左结合 \\
\hline
乘法 & \texttt{* / \% \& {\textbackslash} ÷} & 左结合\footnotemark[2] \\
\hline
加法 & \texttt{+ - | \unicodeveebar{}} & 左结合\footnotemark[2] \\
\hline
语法 & \texttt{: ..} & 左结合 \\
\hline
语法 & \texttt{|>} & 左结合 \\
\hline
语法 & \texttt{<|} & 右结合 \\
\hline
比较 & \texttt{> < >= <= == === != !== <:} & 无结合性 \\
\hline
流程控制 & \texttt{\&\&} followed by \texttt{||} followed by \texttt{?} & 右结合 \\
\hline
Pair 操作 & \texttt{=>} & 右结合 \\
\hline
赋值 & \texttt{= += -= *= /= //= {\textbackslash}= {\textasciicircum}= ÷= \%= |= \&= \unicodeveebar{}= <<= >>= >>>=} & 右结合 \\
\hline
\end{tabulary}

\end{table}



\footnotetext[1]{一元运算符 \texttt{+} 和 \texttt{-} 需要显式调用，即给它们的参数加上括号，以免和 \texttt{++} 等运算符混淆。其它一元运算符的混合使用都被解析为右结合的，比如 \texttt{√√-a} 解析为 \texttt{√(√(-a))}。

}


\footnotetext[2]{The operators \texttt{+}, \texttt{++} and \texttt{*} are non-associative. \texttt{a + b + c} is parsed as \texttt{+(a, b, c)} not \texttt{+(+(a, b), c)}. However, the fallback methods for \texttt{+(a, b, c, d...)} and \texttt{*(a, b, c, d...)} both default to left-associative evaluation.

}


要看\textbf{全部} Julia 运算符的优先级关系，可以看这个文件的最上面部分：\href{https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm}{\texttt{src/julia-parser.scm}}



\hyperlink{7285052708387693199}{数字字面量系数}，例如 \texttt{2x} 中的 2，它的优先级比二元运算符高，因此会当作乘法，并且它的优先级也比 \texttt{{\textasciicircum}} 高。



你也可以通过内置函数 \texttt{Base.operator\_precedence} 查看任何给定运算符的优先级数值，数值越大优先级越高：




\begin{minted}{jlcon}
julia> Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)
(11, 12, 17)

julia> Base.operator_precedence(:sin), Base.operator_precedence(:+=), Base.operator_precedence(:(=))  # (Note the necessary parens on `:(=)`)
(0, 1, 1)
\end{minted}



另外，内置函数 \texttt{Base.operator\_associativity} 可以返回运算符结合性的符号表示：




\begin{minted}{jlcon}
julia> Base.operator_associativity(:-), Base.operator_associativity(:+), Base.operator_associativity(:^)
(:left, :none, :right)

julia> Base.operator_associativity(:⊗), Base.operator_associativity(:sin), Base.operator_associativity(:→)
(:left, :none, :right)
\end{minted}



注意诸如 \texttt{:sin} 这样的符号返回优先级 \texttt{0}，此值代表无效的运算符或非最低优先级运算符。类似地，它们的结合性被认为是 \texttt{:none}。



\hypertarget{1678218620254251806}{}


\section{数值转换}



Julia 支持三种数值转换，它们在处理不精确转换上有所不同。



\begin{itemize}
\item \texttt{T(x)} 和 \texttt{convert(T,x)} 都会把 \texttt{x} 转换为 \texttt{T}类型。

\begin{itemize}
\item 如果 \texttt{T} 是浮点类型，转换的结果就是最近的可表示值， 可能会是正负无穷大。


\item 如果 \texttt{T} 为整数类型，当 \texttt{x} 不能由 \texttt{T} 类型表示时，会抛出 \texttt{InexactError}。

\end{itemize}

\item \texttt{x \% T} 将整数 \texttt{x} 转换为整型 \texttt{T}，与 \texttt{x} 模 \texttt{2{\textasciicircum}n} 的结果一致，其中 \texttt{n} 是 \texttt{T} 的位数。换句话说，在二进制表示下被截掉了一部分。


\item \hyperlink{9997236062216946610}{舍入函数} 接收一个 \texttt{T} 类型的可选参数。比如，\texttt{round(Int,x)} 是 \texttt{Int(round(x))} 的简写版。

\end{itemize}


下面的例子展示了不同的形式




\begin{minted}{jlcon}
julia> Int8(127)
127

julia> Int8(128)
ERROR: InexactError: trunc(Int8, 128)
Stacktrace:
[...]

julia> Int8(127.0)
127

julia> Int8(3.14)
ERROR: InexactError: Int8(3.14)
Stacktrace:
[...]

julia> Int8(128.0)
ERROR: InexactError: Int8(128.0)
Stacktrace:
[...]

julia> 127 % Int8
127

julia> 128 % Int8
-128

julia> round(Int8,127.4)
127

julia> round(Int8,127.6)
ERROR: InexactError: trunc(Int8, 128.0)
Stacktrace:
[...]
\end{minted}



请参考\hyperlink{10374023657104680331}{类型转换与类型提升}一节来定义你自己的类型转换和提升规则。



\hypertarget{10733784297691347404}{}


\subsection{舍入函数}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
函数 & 描述 & 返回类型 \\
\hline
\hyperlink{12930779325193350739}{\texttt{round(x)}} & \texttt{x} 舍到最接近的整数 & \texttt{typeof(x)} \\
\hline
\hyperlink{12930779325193350739}{\texttt{round(T, x)}} & \texttt{x} 舍到最接近的整数 & \texttt{T} \\
\hline
\hyperlink{11115257331910840693}{\texttt{floor(x)}} & \texttt{x} 向 \texttt{-Inf} 舍入 & \texttt{typeof(x)} \\
\hline
\hyperlink{11115257331910840693}{\texttt{floor(T, x)}} & \texttt{x} 向 \texttt{-Inf} 舍入 & \texttt{T} \\
\hline
\hyperlink{10519509038312853061}{\texttt{ceil(x)}} & \texttt{x} 向 \texttt{+Inf} 方向取整 & \texttt{typeof(x)} \\
\hline
\hyperlink{10519509038312853061}{\texttt{ceil(T, x)}} & \texttt{x} 向 \texttt{+Inf} 方向取整 & \texttt{T} \\
\hline
\hyperlink{1728363361565303194}{\texttt{trunc(x)}} & \texttt{x} 向 0 取整 & \texttt{typeof(x)} \\
\hline
\hyperlink{1728363361565303194}{\texttt{trunc(T, x)}} & \texttt{x} 向 0 取整 & \texttt{T} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{3613448754755213273}{}


\subsection{除法函数}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
函数 & 描述 \\
\hline
\hyperlink{8020976424566491334}{\texttt{div(x,y)}}, \texttt{x÷y} & 截断除法；商向零近似 \\
\hline
\hyperlink{15067916827074788527}{\texttt{fld(x,y)}} & 向下取整除法；商向 \texttt{-Inf} 近似 \\
\hline
\hyperlink{7922388465305816555}{\texttt{cld(x,y)}} & 向上取整除法；商向 \texttt{+Inf} 近似 \\
\hline
\hyperlink{3827563084771191385}{\texttt{rem(x,y)}} & 取余；满足 \texttt{x == div(x,y)*y + rem(x,y)}；符号与 \texttt{x} 一致 \\
\hline
\hyperlink{2082041235715276573}{\texttt{mod(x,y)}} & 取模；满足 \texttt{x == fld(x,y)*y + mod(x,y)}；符号与 \texttt{y} 一致 \\
\hline
\hyperlink{13778479217547823795}{\texttt{mod1(x,y)}} & 偏移 1 的 \texttt{mod}；若 \texttt{y>0}，则返回 \texttt{r∈(0,y]}，若 \texttt{y<0}，则 \texttt{r∈[y,0)} 且满足 \texttt{mod(r, y) == mod(x, y)} \\
\hline
\hyperlink{15322754370885673769}{\texttt{mod2pi(x)}} & 以 2pi 为基取模；\texttt{0 <= mod2pi(x) < 2pi} \\
\hline
\hyperlink{6106909621813654214}{\texttt{divrem(x,y)}} & 返回 \texttt{(div(x,y),rem(x,y))} \\
\hline
\hyperlink{2806360720034558325}{\texttt{fldmod(x,y)}} & 返回 \texttt{(fld(x,y),mod(x,y))} \\
\hline
\hyperlink{15906911311436241979}{\texttt{gcd(x,y...)}} & \texttt{x}, \texttt{y},... 的最大公约数 \\
\hline
\hyperlink{12975400110924105221}{\texttt{lcm(x,y...)}} & \texttt{x}, \texttt{y},... 的最小公倍数 \\
\hline
\end{tabulary}

\end{table}



\hypertarget{1398763230003382412}{}


\subsection{符号和绝对值函数}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
函数 & 描述 \\
\hline
\hyperlink{9614495866226399167}{\texttt{abs(x)}} & \texttt{x} 的模 \\
\hline
\hyperlink{15686257922156163743}{\texttt{abs2(x)}} & \texttt{x} 的模的平方 \\
\hline
\hyperlink{14349105033929355161}{\texttt{sign(x)}} & 表示 \texttt{x} 的符号，返回 -1，0，或 +1 \\
\hline
\hyperlink{9457038569823603490}{\texttt{signbit(x)}} & 表示符号位是 true 或 false \\
\hline
\hyperlink{6024566200716053110}{\texttt{copysign(x,y)}} & 返回一个数，其值等于 \texttt{x} 的模，符号与 \texttt{y} 一致 \\
\hline
\hyperlink{2689022981470151558}{\texttt{flipsign(x,y)}} & 返回一个数，其值等于 \texttt{x} 的模，符号与 \texttt{x*y} 一致 \\
\hline
\end{tabulary}

\end{table}



\hypertarget{15750140405864720482}{}


\subsection{幂、对数与平方根}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
函数 & 描述 \\
\hline
\hyperlink{4551113327515323898}{\texttt{sqrt(x)}}, \texttt{√x} & \texttt{x} 的平方根 \\
\hline
\hyperlink{15104025502404840355}{\texttt{cbrt(x)}}, \texttt{∛x} & \texttt{x} 的立方根 \\
\hline
\hyperlink{18304489571285447949}{\texttt{hypot(x,y)}} & 当直角边的长度为 \texttt{x} 和 \texttt{y}时，直角三角形斜边的长度 \\
\hline
\hyperlink{5801729597955756107}{\texttt{exp(x)}} & 自然指数函数在 \texttt{x} 处的值 \\
\hline
\hyperlink{4939309737829480377}{\texttt{expm1(x)}} & 当 \texttt{x} 接近 0 时的 \texttt{exp(x)-1} 的精确值 \\
\hline
\hyperlink{14721177606508229464}{\texttt{ldexp(x,n)}} & \texttt{x*2{\textasciicircum}n} 的高效算法，\texttt{n} 为整数 \\
\hline
\hyperlink{17317607370922767936}{\texttt{log(x)}} & \texttt{x} 的自然对数 \\
\hline
\hyperlink{17317607370922767936}{\texttt{log(b,x)}} & 以 \texttt{b} 为底 \texttt{x} 的对数 \\
\hline
\hyperlink{18341149201477905713}{\texttt{log2(x)}} & 以 2 为底 \texttt{x} 的对数 \\
\hline
\hyperlink{3481560771470480868}{\texttt{log10(x)}} & 以 10 为底 \texttt{x} 的对数 \\
\hline
\hyperlink{5533050447473188877}{\texttt{log1p(x)}} & 当 \texttt{x}接近 0 时的 \texttt{log(1+x)} 的精确值 \\
\hline
\hyperlink{39736318364195845}{\texttt{exponent(x)}} & \texttt{x} 的二进制指数 \\
\hline
\hyperlink{11312242195671521747}{\texttt{significand(x)}} & 浮点数 \texttt{x} 的二进制有效数（也就是尾数） \\
\hline
\end{tabulary}

\end{table}



想大概了解一下为什么诸如 \hyperlink{18304489571285447949}{\texttt{hypot}}、\hyperlink{4939309737829480377}{\texttt{expm1}}和 \hyperlink{5533050447473188877}{\texttt{log1p}} 函数是必要和有用的，可以看一下 John D. Cook 关于这些主题的两篇优秀博文：\href{https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/}{expm1, log1p, erfc}， 和 \href{https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/}{hypot}。



\hypertarget{16706884854236336909}{}


\subsection{三角和双曲函数}



所有标准的三角函数和双曲函数也都已经定义了：




\begin{lstlisting}
sin    cos    tan    cot    sec    csc
sinh   cosh   tanh   coth   sech   csch
asin   acos   atan   acot   asec   acsc
asinh  acosh  atanh  acoth  asech  acsch
sinc   cosc
\end{lstlisting}



所有这些函数都是单参数函数，不过 \hyperlink{16445804261034090556}{\texttt{atan}} 也可以接收两个参数 来表示传统的 \href{https://en.wikipedia.org/wiki/Atan2}{\texttt{atan2}} 函数。



另外，\hyperlink{16554510911661822298}{\texttt{sinpi(x)}} 和 \hyperlink{2974547424856180253}{\texttt{cospi(x)}} 分别用来对 \hyperlink{10540279982054240733}{\texttt{sin(pi*x)}} 和 \hyperlink{10355926621556840804}{\texttt{cos(pi*x)}} 进行更精确的计算。



要计算角度而非弧度的三角函数，以 \texttt{d} 做后缀。 比如，\hyperlink{38337471195460170}{\texttt{sind(x)}} 计算 \texttt{x} 的 sine 值，其中 \texttt{x} 是一个角度值。 下面是角度变量的三角函数完整列表：




\begin{lstlisting}
sind   cosd   tand   cotd   secd   cscd
asind  acosd  atand  acotd  asecd  acscd
\end{lstlisting}



\hypertarget{17986622034630654775}{}


\subsection{特殊函数}



\href{https://github.com/JuliaMath/SpecialFunctions.jl}{SpecialFunctions.jl} 提供了许多其他的特殊数学函数。



\hypertarget{9739813100592614250}{}


\chapter{复数和有理数}



Julia 语言包含了预定义的复数和有理数类型，并且支持它们的各种标准\hyperlink{16865688524696028421}{数学运算和初等函数}。由于也定义了复数与分数的\hyperlink{10374023657104680331}{类型转换与类型提升}，因此对预定义数值类型（无论是原始的还是复合的）的任意组合进行的操作都会表现得如预期的一样。



\hypertarget{5868123017618904517}{}


\section{复数}



在Julia中,全局常量 \hyperlink{15097910740298861288}{\texttt{im}} 被绑定到复数 \emph{i}，表示 -1 的主平方根（不应使用数学家习惯的 \texttt{i} 或工程师习惯的 \texttt{j} 来表示此全局常量，因为它们是非常常用的索引变量名）。由于 Julia 允许数值字面量\hyperlink{7285052708387693199}{作为系数与标识符并置}，这种绑定就足够为复数提供很方便的语法，类似于传统的数学记法：




\begin{minted}{jlcon}
julia> 1+2im
1 + 2im
\end{minted}



你可以对复数进行各种标准算术操作：




\begin{minted}{jlcon}
julia> (1 + 2im)*(2 - 3im)
8 + 1im

julia> (1 + 2im)/(1 - 2im)
-0.6 + 0.8im

julia> (1 + 2im) + (1 - 2im)
2 + 0im

julia> (-3 + 2im) - (5 - 1im)
-8 + 3im

julia> (-1 + 2im)^2
-3 - 4im

julia> (-1 + 2im)^2.5
2.729624464784009 - 6.9606644595719im

julia> (-1 + 2im)^(1 + 1im)
-0.27910381075826657 + 0.08708053414102428im

julia> 3(2 - 5im)
6 - 15im

julia> 3(2 - 5im)^2
-63 - 60im

julia> 3(2 - 5im)^-1.0
0.20689655172413796 + 0.5172413793103449im
\end{minted}



类型提升机制也确保你可以使用不同类型的操作数的组合：




\begin{minted}{jlcon}
julia> 2(1 - 1im)
2 - 2im

julia> (2 + 3im) - 1
1 + 3im

julia> (1 + 2im) + 0.5
1.5 + 2.0im

julia> (2 + 3im) - 0.5im
2.0 + 2.5im

julia> 0.75(1 + 2im)
0.75 + 1.5im

julia> (2 + 3im) / 2
1.0 + 1.5im

julia> (1 - 3im) / (2 + 2im)
-0.5 - 1.0im

julia> 2im^2
-2 + 0im

julia> 1 + 3/4im
1.0 - 0.75im
\end{minted}



注意 \texttt{3/4im == 3/(4*im) == -(3/4*im)}，因为系数比除法的优先级更高。



Julia 提供了一些操作复数的标准函数：




\begin{minted}{jlcon}
julia> z = 1 + 2im
1 + 2im

julia> real(1 + 2im) # z 的实部
1

julia> imag(1 + 2im) # z 的虚部
2

julia> conj(1 + 2im) # z 的复共轭
1 - 2im

julia> abs(1 + 2im) # z 的绝对值
2.23606797749979

julia> abs2(1 + 2im) # 取平方后的绝对值
5

julia> angle(1 + 2im) # 以弧度为单位的相位角
1.1071487177940904
\end{minted}



按照惯例，复数的绝对值（\hyperlink{9614495866226399167}{\texttt{abs}}）是从零点到它的距离。\hyperlink{15686257922156163743}{\texttt{abs2}} 给出绝对值的平方，作用于复数上时非常有用，因为它避免了取平方根。\hyperlink{9465547375318501186}{\texttt{angle}} 返回以弧度为单位的相位角（也被称为辐角函数）。所有其它的\hyperlink{7194628046456539104}{初等函数}在复数上也都有完整的定义：




\begin{minted}{jlcon}
julia> sqrt(1im)
0.7071067811865476 + 0.7071067811865475im

julia> sqrt(1 + 2im)
1.272019649514069 + 0.7861513777574233im

julia> cos(1 + 2im)
2.0327230070196656 - 3.0518977991518im

julia> exp(1 + 2im)
-1.1312043837568135 + 2.4717266720048188im

julia> sinh(1 + 2im)
-0.4890562590412937 + 1.4031192506220405im
\end{minted}



注意数学函数通常应用于实数就返回实数值，应用于复数就返回复数值。例如，当 \hyperlink{4551113327515323898}{\texttt{sqrt}} 应用于 \texttt{-1} 与 \texttt{-1 + 0im} 会有不同的表现，虽然 \texttt{-1 == -1 + 0im}：




\begin{minted}{jlcon}
julia> sqrt(-1)
ERROR: DomainError with -1.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
[...]

julia> sqrt(-1 + 0im)
0.0 + 1.0im
\end{minted}



从变量构建复数时，\hyperlink{7285052708387693199}{文本型数值系数记法}不再适用。相反地，乘法必须显式地写出：




\begin{minted}{jlcon}
julia> a = 1; b = 2; a + b*im
1 + 2im
\end{minted}



然而，我们\textbf{并不}推荐这样做，而应改为使用更高效的 \hyperlink{16014240202095271744}{\texttt{complex}} 函数直接通过实部与虚部构建一个复数值：




\begin{minted}{jlcon}
julia> a = 1; b = 2; complex(a, b)
1 + 2im
\end{minted}



这种构建避免了乘法和加法操作。



\hyperlink{1907914141659611007}{\texttt{Inf}} 和 \hyperlink{11449618129446476597}{\texttt{NaN}} 可能出现在复数的实部和虚部，正如\hyperlink{17731750208832839264}{特殊的浮点值}章节所描述的：




\begin{minted}{jlcon}
julia> 1 + Inf*im
1.0 + Inf*im

julia> 1 + NaN*im
1.0 + NaN*im
\end{minted}



\hypertarget{8440700082217486421}{}


\section{有理数}



Julia 有一个用于表示整数精确比值的分数类型。分数通过 \hyperlink{17539582191808611917}{\texttt{//}} 运算符构建：




\begin{minted}{jlcon}
julia> 2//3
2//3
\end{minted}



如果一个分数的分子和分母含有公因子，它们会被约分到最简形式且分母非负：




\begin{minted}{jlcon}
julia> 6//9
2//3

julia> -4//8
-1//2

julia> 5//-15
-1//3

julia> -4//-12
1//3
\end{minted}



整数比值的这种标准化形式是唯一的，所以分数值的相等性可由校验分子与分母都相等来测试。分数值的标准化分子和分母可以使用 \hyperlink{7885506453580572157}{\texttt{numerator}} 和 \hyperlink{12407209279719593434}{\texttt{denominator}} 函数得到：




\begin{minted}{jlcon}
julia> numerator(2//3)
2

julia> denominator(2//3)
3
\end{minted}



分子和分母的直接比较通常是不必要的，因为标准算术和比较操作对分数值也有定义：




\begin{minted}{jlcon}
julia> 2//3 == 6//9
true

julia> 2//3 == 9//27
false

julia> 3//7 < 1//2
true

julia> 3//4 > 2//3
true

julia> 2//4 + 1//6
2//3

julia> 5//12 - 1//4
1//6

julia> 5//8 * 3//12
5//32

julia> 6//5 / 10//7
21//25
\end{minted}



分数可以很容易地转换成浮点数：




\begin{minted}{jlcon}
julia> float(3//4)
0.75
\end{minted}



对任意整数值 \texttt{a} 和 \texttt{b}（除了 \texttt{a == 0} 且 \texttt{b == 0} 时），从分数到浮点数的转换遵从以下的一致性：




\begin{minted}{jlcon}
julia> a = 1; b = 2;

julia> isequal(float(a//b), a/b)
true
\end{minted}



Julia接受构建无穷分数值：




\begin{minted}{jlcon}
julia> 5//0
1//0

julia> -3//0
-1//0

julia> typeof(ans)
Rational{Int64}
\end{minted}



但不接受试图构建一个 \hyperlink{11449618129446476597}{\texttt{NaN}} 分数值：




\begin{minted}{jlcon}
julia> 0//0
ERROR: ArgumentError: invalid rational: zero(Int64)//zero(Int64)
Stacktrace:
[...]
\end{minted}



像往常一样，类型提升系统使得分数可以轻松地同其它数值类型进行交互：




\begin{minted}{jlcon}
julia> 3//5 + 1
8//5

julia> 3//5 - 0.5
0.09999999999999998

julia> 2//7 * (1 + 2im)
2//7 + 4//7*im

julia> 2//7 * (1.5 + 2im)
0.42857142857142855 + 0.5714285714285714im

julia> 3//2 / (1 + 2im)
3//10 - 3//5*im

julia> 1//2 + 2im
1//2 + 2//1*im

julia> 1 + 2//3im
1//1 - 2//3*im

julia> 0.5 == 1//2
true

julia> 0.33 == 1//3
false

julia> 0.33 < 1//3
true

julia> 1//3 - 0.33
0.0033333333333332993
\end{minted}



\hypertarget{3772396547767597421}{}


\chapter{字符串}



字符串是由有限个字符组成的序列。而字符在英文中一般包括字母 \texttt{A},\texttt{B}, \texttt{C} 等、数字和常用的标点符号。这些字符由 \href{https://en.wikipedia.org/wiki/ASCII}{ASCII} 标准统一标准化并且与 0 到 127 范围内的整数一一对应。当然，还有很多非英文字符，包括 ASCII 字符在注音或其他方面的变体，例如西里尔字母和希腊字母，以及与 ASCII 和英文均完全无关的字母系统，包括阿拉伯语，中文， 希伯来语，印度语， 日本语， 和韩语。\href{https://en.wikipedia.org/wiki/Unicode}{Unicode} 标准对这些复杂的字符做了统一的定义，是一种大家普遍接受标准。 根据需求，写代码时可以忽略这种复杂性而只处理 ASCII 字符，也可针对可能出现的非 ASCII 文本而处理所有的字符或编码。Julia 可以简单高效地处理纯粹的 ASCII 文本以及 Unicode 文本。 甚至，在 Julia 中用 C 语言风格的代码来处理 ASCII 字符串，可以在不失性能和易读性的前提下达到预期效果。当遇到非 ASCII 文本时，Julia会优雅明确地提示错误信息而不是引入乱码。 这时，直接修改代码使其可以处理非 ASCII 数据即可。



关于 Julia 的字符串类型有一些值得注意的高级特性：



\begin{itemize}
\item Julia 中用于字符串（和字符串文字）的内置具体类型是 \hyperlink{2825695355940841177}{\texttt{String}}。 它支持全部 \href{https://en.wikipedia.org/wiki/Unicode}{Unicode} 字符 通过 \href{https://en.wikipedia.org/wiki/UTF-8}{UTF-8} 编码。（\hyperlink{11147209877072452260}{\texttt{transcode}} 函数是 提供 Unicode 编码和其他编码转换的函数。）


\item 所有的字符串类型都是抽象类型 \texttt{AbstractString} 的子类型，而一些外部包定义了别的 \texttt{AbstractString} 子类型（例如为其它的编码定义的子类型）。若要定义需要字符串参数的函数，你应当声明此类型为 \texttt{AbstractString} 来让这函数接受任何字符串类型。


\item 类似 C 和 Java，但是和大多数动态语言不同的是，Julia 有优秀的表示单字符的类型，即 \hyperlink{17842511721012314372}{\texttt{AbstractChar}}。\hyperlink{3463806064296245385}{\texttt{Char}} 是 \texttt{AbstractChar} 的内置子类型，它能表示任何 Unicode 字符的 32 位原始类型（基于 UTF-8 编码）。


\item 如 Java 中那样，字符串不可改——任何 \texttt{AbstractString} 对象的值不可改变。 若要构造不同的字符串值，应当从其它字符串的部分构造一个新的字符串。


\item 从概念上讲，字符串是从索引到字符的\emph{部分函数}：对于某些索引值，它不返回字符值，而是引发异常。这允许通过编码表示形式的字节索引来实现高效的字符串索引，而不是通过字符索引——它不能简单高效地实现可变宽度的 Unicode 字符串编码。

\end{itemize}


\hypertarget{11743000381881707413}{}


\section{字符}



\texttt{Char} 类型的值代表单个字符：它只是带有特殊文本表示法和适当算术行为的 32 位原始类型，不能转化为代表 \href{https://en.wikipedia.org/wiki/Code\_point}{Unicode 代码} 的数值。（Julia 的包可能会定义别的 \texttt{AbstractChar} 子类型，比如当为了优化对其它 \href{https://en.wikipedia.org/wiki/Character\_encoding}{字符编码} 的操作时）\texttt{Char} 类型的值以这样的方式输入和显示：




\begin{minted}{jlcon}
julia> 'x'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia> typeof(ans)
Char
\end{minted}



你可以轻松地将 \texttt{Char} 转换为其对应的整数值，即 Unicode 代码：




\begin{minted}{jlcon}
julia> Int('x')
120

julia> typeof(ans)
Int64
\end{minted}



在 32 位架构中，\hyperlink{13440452181855594120}{\texttt{typeof(ans)}} 将显示为 \hyperlink{10103694114785108551}{\texttt{Int32}}。你可以轻松地将一个整数值转回 \texttt{Char}。




\begin{minted}{jlcon}
julia> Char(120)
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)
\end{minted}



并非所有的整数值都是有效的 Unicode 代码，但是为了性能，\texttt{Char} 的转化不会检查每个值是否有效。如果你想检查每个转换的值是否为有效值，请使用 \hyperlink{9678448882095016755}{\texttt{isvalid}} 函数：




\begin{minted}{jlcon}
julia> Char(0x110000)
'\U110000': Unicode U+110000 (category In: Invalid, too high)

julia> isvalid(Char, 0x110000)
false
\end{minted}



As of this writing, the valid Unicode code points are \texttt{U+0000} through \texttt{U+D7FF} and \texttt{U+E000} through \texttt{U+10FFFF}. These have not all been assigned intelligible meanings yet, nor are they necessarily interpretable by applications, but all of these values are considered to be valid Unicode characters.



你可以在单引号中输入任何 Unicode 字符，通过使用 \texttt{{\textbackslash}u} 加上至多 ４ 个十六进制数字或者 \texttt{{\textbackslash}U} 加上至多 ８ 个十六进制数（最长的有效值也只需要 6 个）：




\begin{minted}{jlcon}
julia> '\u0'
'\0': ASCII/Unicode U+0000 (category Cc: Other, control)

julia> '\u78'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia> '\u2200'
'∀': Unicode U+2200 (category Sm: Symbol, math)

julia> '\U10ffff'
'\U10ffff': Unicode U+10FFFF (category Cn: Other, not assigned)
\end{minted}



Julia 使用系统默认的区域和语言设置来确定，哪些字符可以被正确显示，哪些需要用 \texttt{{\textbackslash}u} 或 \texttt{{\textbackslash}U} 的转义来显示。除 Unicode 转义格式之外，还可以使用所有的\href{https://en.wikipedia.org/wiki/C\_syntax\#Backslash\_escapes}{传统 C 语言转义输入形式}：




\begin{minted}{jlcon}
julia> Int('\0')
0

julia> Int('\t')
9

julia> Int('\n')
10

julia> Int('\e')
27

julia> Int('\x7f')
127

julia> Int('\177')
127
\end{minted}



你可以对 \texttt{Char} 的值进行比较和有限的算术运算：




\begin{minted}{jlcon}
julia> 'A' < 'a'
true

julia> 'A' <= 'a' <= 'Z'
false

julia> 'A' <= 'X' <= 'Z'
true

julia> 'x' - 'a'
23

julia> 'A' + 1
'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)
\end{minted}



\hypertarget{6723865345393966445}{}


\section{字符串基础}



字符串字面量由双引号或三重双引号分隔：




\begin{minted}{jlcon}
julia> str = "Hello, world.\n"
"Hello, world.\n"

julia> """Contains "quote" characters"""
"Contains \"quote\" characters"
\end{minted}



If you want to extract a character from a string, you index into it:




\begin{minted}{jlcon}
julia> str[begin]
'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)

julia> str[1]
'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)

julia> str[6]
',': ASCII/Unicode U+002C (category Po: Punctuation, other)

julia> str[end]
'\n': ASCII/Unicode U+000A (category Cc: Other, control)
\end{minted}



Many Julia objects, including strings, can be indexed with integers. The index of the first element (the first character of a string) is returned by \hyperlink{16943669671291374223}{\texttt{firstindex(str)}}, and the index of the last element (character) with \hyperlink{15780929618270241785}{\texttt{lastindex(str)}}. The keywords \texttt{begin} and \texttt{end} can be used inside an indexing operation as shorthand for the first and last indices, respectively, along the given dimension. String indexing, like most indexing in Julia, is 1-based: \texttt{firstindex} always returns \texttt{1} for any \texttt{AbstractString}. As we will see below, however, \texttt{lastindex(str)} is \emph{not} in general the same as \texttt{length(str)} for a string, because some Unicode characters can occupy multiple {\textquotedbl}code units{\textquotedbl}.



你可以用 \hyperlink{11574363005673055470}{\texttt{end}} 进行算术以及其它操作，就像普通值一样：




\begin{minted}{jlcon}
julia> str[end-1]
'.': ASCII/Unicode U+002E (category Po: Punctuation, other)

julia> str[end÷2]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)
\end{minted}



Using an index less than \texttt{begin} (\texttt{1}) or greater than \texttt{end} raises an error:




\begin{minted}{jlcon}
julia> str[begin-1]
ERROR: BoundsError: attempt to access String
  at index [0]
[...]

julia> str[end+1]
ERROR: BoundsError: attempt to access String
  at index [15]
[...]
\end{minted}



你也可以用范围索引来提取子字符串：




\begin{minted}{jlcon}
julia> str[4:9]
"lo, wo"
\end{minted}



Notice that the expressions \texttt{str[k]} and \texttt{str[k:k]} do not give the same result:




\begin{minted}{jlcon}
julia> str[6]
',': ASCII/Unicode U+002C (category Po: Punctuation, other)

julia> str[6:6]
","
\end{minted}



前者是 \texttt{Char} 类型的单个字符值，后者是碰巧只有单个字符的字符串值。在 Julia 里面两者大不相同。



范围索引复制了原字符串的选定部分。此外，也可以用 \hyperlink{2624824381693370630}{\texttt{SubString}} 类型创建字符串的 \texttt{view}，例如：




\begin{minted}{jlcon}
julia> str = "long string"
"long string"

julia> substr = SubString(str, 1, 4)
"long"

julia> typeof(substr)
SubString{String}
\end{minted}



几个标准函数，像 \hyperlink{18002354026785919806}{\texttt{chop}}, \hyperlink{5360081372937794006}{\texttt{chomp}} 或者 \hyperlink{7002432768371197450}{\texttt{strip}} 都会返回一个 \hyperlink{2624824381693370630}{\texttt{SubString}}。



\hypertarget{12357763399910926447}{}


\section{Unicode 和 UTF-8}



Julia 完全支持 Unicode 字符和字符串。\hyperlink{16744269384625214739}{如上所述}，在字符字面量中，Unicode 代码可以用 Unicode \texttt{{\textbackslash}u} 和 \texttt{{\textbackslash}U} 转义序列表示，也可以用所有标准 C 转义序列表示。这些同样可以用来写字符串字面量：




\begin{minted}{jlcon}
julia> s = "\u2200 x \u2203 y"
"∀ x ∃ y"
\end{minted}



Whether these Unicode characters are displayed as escapes or shown as special characters depends on your terminal{\textquotesingle}s locale settings and its support for Unicode. String literals are encoded using the UTF-8 encoding. UTF-8 is a variable-width encoding, meaning that not all characters are encoded in the same number of bytes ({\textquotedbl}code units{\textquotedbl}). In UTF-8, ASCII characters — i.e. those with code points less than 0x80 (128) – are encoded as they are in ASCII, using a single byte, while code points 0x80 and above are encoded using multiple bytes — up to four per character.



String indices in Julia refer to code units (= bytes for UTF-8), the fixed-width building blocks that are used to encode arbitrary characters (code points). This means that not every index into a \texttt{String} is necessarily a valid index for a character. If you index into a string at such an invalid byte index, an error is thrown:




\begin{minted}{jlcon}
julia> s[1]
'∀': Unicode U+2200 (category Sm: Symbol, math)

julia> s[2]
ERROR: StringIndexError("∀ x ∃ y", 2)
[...]

julia> s[3]
ERROR: StringIndexError("∀ x ∃ y", 3)
Stacktrace:
[...]

julia> s[4]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)
\end{minted}



在这种情况下，字符 \texttt{∀} 是一个三字节字符，因此索引 2 和 3 都是无效的，而下一个字符的索引是 4；这个接下来的有效索引可以用 \hyperlink{7455293228649070526}{\texttt{nextind(s,1)}} 来计算，再接下来的用 \texttt{nextind(s,4)}，依此类推。



Since \texttt{end} is always the last valid index into a collection, \texttt{end-1} references an invalid byte index if the second-to-last character is multibyte.




\begin{minted}{jlcon}
julia> s[end-1]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)

julia> s[end-2]
ERROR: StringIndexError("∀ x ∃ y", 9)
Stacktrace:
[...]

julia> s[prevind(s, end, 2)]
'∃': Unicode U+2203 (category Sm: Symbol, math)
\end{minted}



The first case works, because the last character \texttt{y} and the space are one-byte characters, whereas \texttt{end-2} indexes into the middle of the \texttt{∃} multibyte representation. The correct way for this case is using \texttt{prevind(s, lastindex(s), 2)} or, if you{\textquotesingle}re using that value to index into \texttt{s} you can write \texttt{s[prevind(s, end, 2)]} and \texttt{end} expands to \texttt{lastindex(s)}.



Extraction of a substring using range indexing also expects valid byte indices or an error is thrown:




\begin{minted}{jlcon}
julia> s[1:1]
"∀"

julia> s[1:2]
ERROR: StringIndexError("∀ x ∃ y", 2)
Stacktrace:
[...]

julia> s[1:4]
"∀ "
\end{minted}



Because of variable-length encodings, the number of characters in a string (given by \hyperlink{3699181304419743826}{\texttt{length(s)}}) is not always the same as the last index. If you iterate through the indices 1 through \hyperlink{15780929618270241785}{\texttt{lastindex(s)}} and index into \texttt{s}, the sequence of characters returned when errors aren{\textquotesingle}t thrown is the sequence of characters comprising the string \texttt{s}. Thus we have the identity that \texttt{length(s) <= lastindex(s)}, since each character in a string must have its own index. The following is an inefficient and verbose way to iterate through the characters of \texttt{s}:




\begin{minted}{jlcon}
julia> for i = firstindex(s):lastindex(s)
           try
               println(s[i])
           catch
               # ignore the index error
           end
       end
∀

x

∃

y
\end{minted}



The blank lines actually have spaces on them. Fortunately, the above awkward idiom is unnecessary for iterating through the characters in a string, since you can just use the string as an iterable object, no exception handling required:




\begin{minted}{jlcon}
julia> for c in s
           println(c)
       end
∀

x

∃

y
\end{minted}



If you need to obtain valid indices for a string, you can use the \hyperlink{7455293228649070526}{\texttt{nextind}} and \hyperlink{15871508897466976220}{\texttt{prevind}} functions to increment/decrement to the next/previous valid index, as mentioned above. You can also use the \hyperlink{4701773772897287974}{\texttt{eachindex}} function to iterate over the valid character indices:




\begin{minted}{jlcon}
julia> collect(eachindex(s))
7-element Array{Int64,1}:
  1
  4
  5
  6
  7
 10
 11
\end{minted}



To access the raw code units (bytes for UTF-8) of the encoding, you can use the \hyperlink{16983098119361955361}{\texttt{codeunit(s,i)}} function, where the index \texttt{i} runs consecutively from \texttt{1} to \hyperlink{1775518749150675445}{\texttt{ncodeunits(s)}}.  The \hyperlink{17283482973786973382}{\texttt{codeunits(s)}} function returns an \texttt{AbstractVector\{UInt8\}} wrapper that lets you access these raw codeunits (bytes) as an array.



Strings in Julia can contain invalid UTF-8 code unit sequences. This convention allows to treat any byte sequence as a \texttt{String}. In such situations a rule is that when parsing a sequence of code units from left to right characters are formed by the longest sequence of 8-bit code units that matches the start of one of the following bit patterns (each \texttt{x} can be \texttt{0} or \texttt{1}):



\begin{itemize}
\item \texttt{0xxxxxxx};


\item \texttt{110xxxxx} \texttt{10xxxxxx};


\item \texttt{1110xxxx} \texttt{10xxxxxx} \texttt{10xxxxxx};


\item \texttt{11110xxx} \texttt{10xxxxxx} \texttt{10xxxxxx} \texttt{10xxxxxx};


\item \texttt{10xxxxxx};


\item \texttt{11111xxx}.

\end{itemize}


In particular this means that overlong and too-high code unit sequences and prefixes thereof are treated as a single invalid character rather than multiple invalid characters. This rule may be best explained with an example:




\begin{minted}{jlcon}
julia> s = "\xc0\xa0\xe2\x88\xe2|"
"\xc0\xa0\xe2\x88\xe2|"

julia> foreach(display, s)
'\xc0\xa0': [overlong] ASCII/Unicode U+0020 (category Zs: Separator, space)
'\xe2\x88': Malformed UTF-8 (category Ma: Malformed, bad data)
'\xe2': Malformed UTF-8 (category Ma: Malformed, bad data)
'|': ASCII/Unicode U+007C (category Sm: Symbol, math)

julia> isvalid.(collect(s))
4-element BitArray{1}:
 0
 0
 0
 1

julia> s2 = "\xf7\xbf\xbf\xbf"
"\U1fffff"

julia> foreach(display, s2)
'\U1fffff': Unicode U+1FFFFF (category In: Invalid, too high)
\end{minted}



我们可以看到字符串 \texttt{s} 中的前两个代码单元形成了一个过长的空格字符编码。这是无效的，但是在字符串中作为单个字符是可以接受的。接下来的两个代码单元形成了一个有效的 3 位 UTF-8 序列开头。然而，第五个代码单元 \texttt{{\textbackslash}xe2} 不是它的有效延续，所以代码单元 3 和 4 在这个字符串中也被解释为格式错误的字符。同理，由于 \texttt{|} 不是它的有效延续，代码单元 5 形成了一个格式错误的字符。最后字符串 \texttt{s2} 包含了一个太高的代码。



Julia 默认使用 UTF-8 编码，对于新编码的支持可以通过包加上。例如，\href{https://github.com/JuliaStrings/LegacyStrings.jl}{LegacyStrings.jl} 包实现了 \texttt{UTF16String} 和 \texttt{UTF32String} 类型。关于其它编码的额外讨论以及如何实现对它们的支持暂时超过了这篇文档的讨论范围。UTF-8 编码相关问题的进一步讨论参见下面的\href{@ref man-byte-array-literals}{字节数组字面量}章节。\hyperlink{11147209877072452260}{\texttt{transcode}} 函数可在各种 UTF-xx 编码之间转换，主要用于外部数据和包。



\hypertarget{3486870924145745190}{}


\section{拼接}



最常见最有用的字符串操作是级联：




\begin{minted}{jlcon}
julia> greet = "Hello"
"Hello"

julia> whom = "world"
"world"

julia> string(greet, ", ", whom, ".\n")
"Hello, world.\n"
\end{minted}



意识到像对无效 UTF-8 字符进行级联这样的潜在危险情形是非常重要的。生成的字符串可能会包含和输入字符串不同的字符，并且其中字符的数目也可能少于被级联字符串中字符数目之和，例如：




\begin{minted}{jlcon}
julia> a, b = "\xe2\x88", "\x80"
("\xe2\x88", "\x80")

julia> c = a*b
"∀"

julia> collect.([a, b, c])
3-element Array{Array{Char,1},1}:
 ['\xe2\x88']
 ['\x80']
 ['∀']

julia> length.([a, b, c])
3-element Array{Int64,1}:
 1
 1
 1
\end{minted}



这种情形只可能发生于无效 UTF-8 字符串上。对于有效 UTF-8 字符串，级联保留字符串中的所有字符和字符串的总长度。



Julia 也提供 \hyperlink{7592762607639177347}{\texttt{*}} 用于字符串级联：




\begin{minted}{jlcon}
julia> greet * ", " * whom * ".\n"
"Hello, world.\n"
\end{minted}



尽管对于提供 \texttt{+} 函数用于字符串拼接的语言使用者而言，\texttt{*} 似乎是一个令人惊讶的选择，但 \texttt{*} 的这种用法在数学中早有先例，尤其是在抽象代数中。



在数学上，\texttt{+} 通常表示可交换运算（\emph{commutative} operation）——运算对象的顺序不重要。一个例子是矩阵加法：对于任何形状相同的矩阵 \texttt{A} 和 \texttt{B}，都有 \texttt{A + B == B + A}。与之相反，\texttt{*} 通常表示不可交换运算——运算对象的顺序很重要。例如，对于矩阵乘法，一般 \texttt{A * B != B * A}。同矩阵乘法类似，字符串拼接是不可交换的：\texttt{greet * whom != whom * greet}。在这一点上，对于插入字符串的拼接操作，\texttt{*} 是一个自然而然的选择，与它在数学中的用法一致。



更确切地说，有限长度字符串集合 \emph{S} 和字符串拼接操作 \texttt{*} 构成了一个\href{https://en.wikipedia.org/wiki/Free\_monoid}{自由幺半群} (\emph{S}, \texttt{*})。该集合的单位元是空字符串，\texttt{{\textquotedbl}{\textquotedbl}}。当一个自由幺半群不是交换的时，它的运算通常表示为 \texttt{{\textbackslash}cdot}，\texttt{*}，或者类似的符号，而非暗示交换性的 \texttt{+}。



\hypertarget{12583298261221600612}{}


\section{插值}



拼接构造字符串的方式有时有些麻烦。为了减少对于 \hyperlink{7919678712989769360}{\texttt{string}} 的冗余调用或者重复地做乘法，Julia 允许像 Perl 中一样使用 \texttt{\$} 对字符串字面量进行插值：




\begin{minted}{jlcon}
julia> "$greet, $whom.\n"
"Hello, world.\n"
\end{minted}



This is more readable and convenient and equivalent to the above string concatenation – the system rewrites this apparent single string literal into the call \texttt{string(greet, {\textquotedbl}, {\textquotedbl}, whom, {\textquotedbl}.{\textbackslash}n{\textquotedbl})}.



在 \texttt{\$} 之后最短的完整表达式被视为插入其值于字符串中的表达式。因此，你可以用括号向字符串中插入任何表达式：




\begin{minted}{jlcon}
julia> "1 + 2 = $(1 + 2)"
"1 + 2 = 3"
\end{minted}



Both concatenation and string interpolation call \hyperlink{7919678712989769360}{\texttt{string}} to convert objects into string form. However, \texttt{string} actually just returns the output of \hyperlink{8248717042415202230}{\texttt{print}}, so new types should add methods to \hyperlink{8248717042415202230}{\texttt{print}} or \hyperlink{14071376285304310153}{\texttt{show}} instead of \texttt{string}.



Most non-\texttt{AbstractString} objects are converted to strings closely corresponding to how they are entered as literal expressions:




\begin{minted}{jlcon}
julia> v = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia> "v: $v"
"v: [1, 2, 3]"
\end{minted}



\hyperlink{7919678712989769360}{\texttt{string}} 是 \texttt{AbstractString} 和 \texttt{AbstractChar} 值的标识，所以它们作为自身被插入字符串，无需引用，无需转义：




\begin{minted}{jlcon}
julia> c = 'x'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia> "hi, $c"
"hi, x"
\end{minted}



若要在字符串字面量中包含文本 \texttt{\$}，就用反斜杠转义：




\begin{minted}{jlcon}
julia> print("I have \$100 in my account.\n")
I have $100 in my account.
\end{minted}



\hypertarget{6215712550513853493}{}


\section{三引号字符串字面量}



当使用三引号（\texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}...{\textquotedbl}{\textquotedbl}{\textquotedbl}}）创建字符串时，它们有一些在创建更长文本块时可能用到的特殊行为。



首先，三引号字符串也被反缩进到最小缩进线的水平。这在定义包含缩进的字符串时很有用。例如：




\begin{minted}{jlcon}
julia> str = """
           Hello,
           world.
         """
"  Hello,\n  world.\n"
\end{minted}



在这里，后三引号 \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}} 前面的最后一（空）行设置了缩进级别。



反缩进级别被确定为所有行中空格或制表符的最大公共起始序列，不包括前三引号 \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}} 后面的一行以及只包含空格或制表符的行（总包含结尾 \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}} 的行）。那么对于所有不包括前三引号 \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}} 后面文本的行而言，公共起始序列就被移除了（包括只含空格和制表符而以此序列开始的行），例如：




\begin{minted}{jlcon}
julia> """    This
         is
           a test"""
"    This\nis\n  a test"
\end{minted}



接下来，如果前三引号 \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}} 后面紧跟换行符，那么换行符就从生成的字符串中被剥离。




\begin{minted}{julia}
"""hello"""
\end{minted}



等价于




\begin{minted}{julia}
"""
hello"""
\end{minted}



但是




\begin{minted}{julia}
"""

hello"""
\end{minted}



将在开头包含一个文本换行符。



换行符的移除是在反缩进之后进行的。例如：




\begin{minted}{jlcon}
julia> """
         Hello,
         world."""
"Hello,\nworld."
\end{minted}



尾随空格保持不变。



Triple-quoted string literals can contain \texttt{{\textquotedbl}} characters without escaping.



注意，无论是用单引号还是三引号，在文本字符串中换行符都会生成一个换行 (LF) 字符 \texttt{{\textbackslash}n}，即使你的编辑器使用回车组合符 \texttt{{\textbackslash}r} (CR) 或 CRLF 来结束行。为了在字符串中包含 CR，总是应该使用显式转义符 \texttt{{\textbackslash}r}；比如，可以输入文本字符串 \texttt{{\textquotedbl}a CRLF line ending{\textbackslash}r{\textbackslash}n{\textquotedbl}}。



\hypertarget{2767013232051989875}{}


\section{常见操作}



你可以使用标准的比较操作符按照字典顺序比较字符串：




\begin{minted}{jlcon}
julia> "abracadabra" < "xylophone"
true

julia> "abracadabra" == "xylophone"
false

julia> "Hello, world." != "Goodbye, world."
true

julia> "1 + 2 = 3" == "1 + 2 = $(1 + 2)"
true
\end{minted}



你可以使用 \hyperlink{13752961745140943082}{\texttt{findfirst}} 与 \hyperlink{16601358451866933976}{\texttt{findlast}} 函数搜索特定字符的索引：




\begin{minted}{jlcon}
julia> findfirst(isequal('o'), "xylophone")
4

julia> findlast(isequal('o'), "xylophone")
7

julia> findfirst(isequal('z'), "xylophone")
\end{minted}



你可以带上第三个参数，用 \hyperlink{9906000186778518011}{\texttt{findnext}} 与 \hyperlink{3864667477361062614}{\texttt{findprev}} 函数来在给定偏移量处搜索字符：




\begin{minted}{jlcon}
julia> findnext(isequal('o'), "xylophone", 1)
4

julia> findnext(isequal('o'), "xylophone", 5)
7

julia> findprev(isequal('o'), "xylophone", 5)
4

julia> findnext(isequal('o'), "xylophone", 8)
\end{minted}



你可以用 \hyperlink{7988132114328914630}{\texttt{occursin}} 函数检查在字符串中某子字符串可否找到。




\begin{minted}{jlcon}
julia> occursin("world", "Hello, world.")
true

julia> occursin("o", "Xylophon")
true

julia> occursin("a", "Xylophon")
false

julia> occursin('o', "Xylophon")
true
\end{minted}



最后那个例子表明 \hyperlink{7988132114328914630}{\texttt{occursin}} 也可用于搜寻字符字面量。



另外还有两个方便的字符串函数 \hyperlink{15426606278434194584}{\texttt{repeat}} 和 \hyperlink{18064910688022011979}{\texttt{join}}：




\begin{minted}{jlcon}
julia> repeat(".:Z:.", 10)
".:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:."

julia> join(["apples", "bananas", "pineapples"], ", ", " and ")
"apples, bananas and pineapples"
\end{minted}



其它有用的函数还包括：



\begin{itemize}
\item \hyperlink{16943669671291374223}{\texttt{firstindex(str)}} 给出可用来索引到 \texttt{str} 的最小（字节）索引（对字符串来说这总是 1，对于别的容器来说却不一定如此）。


\item \hyperlink{15780929618270241785}{\texttt{lastindex(str)}} 给出可用来索引到 \texttt{str} 的最大（字节）索引。


\item \hyperlink{3699181304419743826}{\texttt{length(str)}}，\texttt{str} 中的字符个数。


\item \hyperlink{3699181304419743826}{\texttt{length(str, i, j)}}，\texttt{str} 中从 \texttt{i} 到 \texttt{j} 的有效字符索引个数。


\item \hyperlink{1775518749150675445}{\texttt{ncodeunits(str)}}，字符串中\href{https://en.wikipedia.org/wiki/Character\_encoding\#Terminology}{代码单元}（\href{https://zh.wikipedia.org/wiki/字符编码\#字符集、代码页，与字符映射}{码元}）的数目。


\item \hyperlink{16983098119361955361}{\texttt{codeunit(str, i)}} 给出在字符串 \texttt{str} 中索引为 \texttt{i} 的代码单元值。


\item \hyperlink{11299403048911786045}{\texttt{thisind(str, i)}}，给定一个字符串的任意索引，查找索引点所在的首个索引。


\item \hyperlink{7455293228649070526}{\texttt{nextind(str, i, n=1)}} 查找在索引 \texttt{i} 之后第 \texttt{n} 个字符的开头。


\item \hyperlink{15871508897466976220}{\texttt{prevind(str, i, n=1)}} 查找在索引 \texttt{i} 之前第 \texttt{n} 个字符的开始。

\end{itemize}


\hypertarget{7550171062631975520}{}


\section{非标准字符串字面量}



有时当你想构造字符串或者使用字符串语义，标准的字符串构造却不能很好的满足需求。Julia 为这种情形提供了非标准字符串字面量。非标准字符串字面量看似常规双引号字符串字面量，但却直接加上了标识符前缀因而并不那么像普通的字符串字面量。下面将提到，正则表达式，字节数组字面量和版本号字面量都是非标准字符串字面量的例子。其它例子见\hyperlink{12781685063176814936}{元编程}章。



\hypertarget{2492267677934939291}{}


\section{正则表达式}



Julia has Perl-compatible regular expressions (regexes), as provided by the \href{http://www.pcre.org/}{PCRE} library (a description of the syntax can be found \href{http://www.pcre.org/current/doc/html/pcre2syntax.html}{here}). Regular expressions are related to strings in two ways: the obvious connection is that regular expressions are used to find regular patterns in strings; the other connection is that regular expressions are themselves input as strings, which are parsed into a state machine that can be used to efficiently search for patterns in strings. In Julia, regular expressions are input using non-standard string literals prefixed with various identifiers beginning with \texttt{r}. The most basic regular expression literal without any options turned on just uses \texttt{r{\textquotedbl}...{\textquotedbl}}:




\begin{minted}{jlcon}
julia> r"^\s*(?:#|$)"
r"^\s*(?:#|$)"

julia> typeof(ans)
Regex
\end{minted}



若要检查正则表达式是否匹配某字符串，就用 \hyperlink{7988132114328914630}{\texttt{occursin}}：




\begin{minted}{jlcon}
julia> occursin(r"^\s*(?:#|$)", "not a comment")
false

julia> occursin(r"^\s*(?:#|$)", "# a comment")
true
\end{minted}



可以看到，\hyperlink{7988132114328914630}{\texttt{occursin}} 只返回正确或错误，表明给定正则表达式是否在该字符串中出现。然而，通常我们不只想知道字符串是否匹配，更想了解它是如何匹配的。要捕获匹配的信息，可以改用 \hyperlink{2695862412477105800}{\texttt{match}} 函数：




\begin{minted}{jlcon}
julia> match(r"^\s*(?:#|$)", "not a comment")

julia> match(r"^\s*(?:#|$)", "# a comment")
RegexMatch("#")
\end{minted}



若正则表达式与给定字符串不匹配，\hyperlink{2695862412477105800}{\texttt{match}} 返回 \hyperlink{9331422207248206047}{\texttt{nothing}}——在交互式提示框中不打印任何东西的特殊值。除了不打印，它是一个完全正常的值，这可以用程序来测试：




\begin{minted}{julia}
m = match(r"^\s*(?:#|$)", line)
if m === nothing
    println("not a comment")
else
    println("blank or comment")
end
\end{minted}



如果正则表达式匹配，\hyperlink{2695862412477105800}{\texttt{match}} 的返回值是 \texttt{RegexMatch} 对象。这些对象记录了表达式是如何匹配的，包括该模式匹配的子字符串和任何可能被捕获的子字符串。上面的例子仅仅捕获了匹配的部分子字符串，但也许我们想要捕获的是公共字符后面的任何非空文本。我们可以这样做：




\begin{minted}{jlcon}
julia> m = match(r"^\s*(?:#\s*(.*?)\s*$|$)", "# a comment ")
RegexMatch("# a comment ", 1="a comment")
\end{minted}



当调用 \hyperlink{2695862412477105800}{\texttt{match}} 时，你可以选择指定开始搜索的索引。例如：




\begin{minted}{jlcon}
julia> m = match(r"[0-9]","aaaa1aaaa2aaaa3",1)
RegexMatch("1")

julia> m = match(r"[0-9]","aaaa1aaaa2aaaa3",6)
RegexMatch("2")

julia> m = match(r"[0-9]","aaaa1aaaa2aaaa3",11)
RegexMatch("3")
\end{minted}



你可以从 \texttt{RegexMatch} 对象中提取如下信息：



\begin{itemize}
\item 匹配的整个子字符串：\texttt{m.match}


\item 作为字符串数组捕获的子字符串：\texttt{m.captures}


\item 整个匹配开始处的偏移：\texttt{m.offset}


\item 作为向量的捕获子字符串的偏移：\texttt{m.offsets}

\end{itemize}


当捕获不匹配时，\texttt{m.captures} 在该处不再包含一个子字符串，而是 \texttt{什么也不} 包含；此外，\texttt{m.offsets} 的偏移量为 0（回想一下，Julia 的索引是从 1 开始的，因此字符串的零偏移是无效的）。下面是两个有些牵强的例子：




\begin{minted}{jlcon}
julia> m = match(r"(a|b)(c)?(d)", "acd")
RegexMatch("acd", 1="a", 2="c", 3="d")

julia> m.match
"acd"

julia> m.captures
3-element Array{Union{Nothing, SubString{String}},1}:
 "a"
 "c"
 "d"

julia> m.offset
1

julia> m.offsets
3-element Array{Int64,1}:
 1
 2
 3

julia> m = match(r"(a|b)(c)?(d)", "ad")
RegexMatch("ad", 1="a", 2=nothing, 3="d")

julia> m.match
"ad"

julia> m.captures
3-element Array{Union{Nothing, SubString{String}},1}:
 "a"
 nothing
 "d"

julia> m.offset
1

julia> m.offsets
3-element Array{Int64,1}:
 1
 0
 2
\end{minted}



让捕获作为数组返回是很方便的，这样就可以用解构语法把它们和局域变量绑定起来：




\begin{minted}{jlcon}
julia> first, second, third = m.captures; first
"a"
\end{minted}



通过使用捕获组的编号或名称对 \texttt{RegexMatch} 对象进行索引，也可实现对捕获的访问：




\begin{minted}{jlcon}
julia> m=match(r"(?<hour>\d+):(?<minute>\d+)","12:45")
RegexMatch("12:45", hour="12", minute="45")

julia> m[:minute]
"45"

julia> m[2]
"45"
\end{minted}



使用 \hyperlink{17608641146794059481}{\texttt{replace}} 时利用 \texttt{{\textbackslash}n} 引用第 n 个捕获组和给替换字符串加上 \texttt{s} 的前缀，可以实现替换字符串中对捕获的引用。捕获组 0 指的是整个匹配对象。可在替换中用 \texttt{{\textbackslash}g<groupname>} 对命名捕获组进行引用。例如：




\begin{minted}{jlcon}
julia> replace("first second", r"(\w+) (?<agroup>\w+)" => s"\g<agroup> \1")
"second first"
\end{minted}



为明确起见，编号捕获组也可用 \texttt{{\textbackslash}g<n>} 进行引用，例如：




\begin{minted}{jlcon}
julia> replace("a", r"." => s"\g<0>1")
"a1"
\end{minted}



你可以在后双引号的后面加上 \texttt{i}, \texttt{m}, \texttt{s} 和 \texttt{x} 等标志对正则表达式进行修改。这些标志和 Perl 里面的含义一样，详见以下对 \href{http://perldoc.perl.org/perlre.html\#Modifiers}{perlre 手册}的摘录：




\begin{lstlisting}
i   不区分大小写的模式匹配。

    若区域设置规则有效，相应映射中代码点小于 255 的部分取自当前区域设置，更大代码点的部分取自 Unicode 规则。然而，跨越 Unicode 规则（ords 255/256）和 非 Unicode 规则边界的匹配将失败。

m   将字符串视为多行。也即更改 "^" 和 "$", 使其从匹配字符串的开头和结尾变为匹配字符串中任意一行的开头或结尾。

s   将字符串视为单行。也即更改 "." 以匹配任何字符，即使是通常不能匹配的换行符。

    像这样一起使用，r""ms，它们让 "." 匹配任何字符，同时也支持分别在字符串中换行符的后面和前面用 "^" 和 "$" 进行匹配。

x   令正则表达式解析器忽略多数既不是反斜杠也不属于字符类的空白。它可以用来把正则表达式分解成（略为）更易读的部分。和普通代码中一样，`#` 字符也被当作引入注释的元字符。
\end{lstlisting}



例如，下面的正则表达式已打开所有三个标志：




\begin{minted}{jlcon}
julia> r"a+.*b+.*?d$"ism
r"a+.*b+.*?d$"ims

julia> match(r"a+.*b+.*?d$"ism, "Goodbye,\nOh, angry,\nBad world\n")
RegexMatch("angry,\nBad world")
\end{minted}



\texttt{r{\textquotedbl}...{\textquotedbl}} 文本的构造没有插值和转义（除了引号 \texttt{{\textquotedbl}} 仍然需要转义）。下面例子展示了它和标准字符串字面量之间的差别：




\begin{minted}{jlcon}
julia> x = 10
10

julia> r"$x"
r"$x"

julia> "$x"
"10"

julia> r"\x"
r"\x"

julia> "\x"
ERROR: syntax: invalid escape sequence
\end{minted}



Julia 也支持 \texttt{r{\textquotedbl}{\textquotedbl}{\textquotedbl}...{\textquotedbl}{\textquotedbl}{\textquotedbl}} 形式的三引号正则表达式字符串（或许便于处理包含引号和换行符的正则表达式）。



\texttt{Regex()} 构造函数可以用于以编程方式创建合法的正则表达式字符串。这允许在构造正则表达式字符串时使用字符串变量的内容和其他字符串操作。上面的任何正则表达式代码可以在 \texttt{Regex()} 的单字符串参数中使用。下面是一些例子：




\begin{minted}{jlcon}
julia> using Dates

julia> d = Date(1962,7,10)
1962-07-10

julia> regex_d = Regex("Day " * string(day(d)))
r"Day 10"

julia> match(regex_d, "It happened on Day 10")
RegexMatch("Day 10")

julia> name = "Jon"
"Jon"

julia> regex_name = Regex("[\"( ]$name[\") ]")  # 插入 name 的值
r"[\"( ]Jon[\") ]"

julia> match(regex_name," Jon ")
RegexMatch(" Jon ")

julia> match(regex_name,"[Jon]") === nothing
true
\end{minted}



\hypertarget{6357751790368299582}{}


\section{字节数组字面量}



另一个有用的非标准字符串字面量是字节数组字面量：\texttt{b{\textquotedbl}...{\textquotedbl}}。这种形式使你能够用字符串表示法来表达只读字面量字节数组，也即 \hyperlink{6609065134969660118}{\texttt{UInt8}} 值的数组。字节数组字面量的规则如下：



\begin{itemize}
\item ASCII 字符和 ASCII 转义生成单个字节。


\item \texttt{{\textbackslash}x} 和八进制转义序列生成与转义值对应的\emph{字节}。


\item Unicode 转义序列生成编码 UTF-8 中该代码点的字节序列。

\end{itemize}


这些规则有一些重叠，这是因为 \texttt{{\textbackslash}x} 的行为和小于 0x80(128) 的八进制转义被前两个规则同时包括了；但这两个规则又是一致的。通过这些规则可以方便地同时使用 ASCII 字符，任意字节值，以及 UTF-8 序列来生成字节数组。下面是一个用到全部三个规则的例子：




\begin{minted}{jlcon}
julia> b"DATA\xff\u2200"
8-element Base.CodeUnits{UInt8,String}:
 0x44
 0x41
 0x54
 0x41
 0xff
 0xe2
 0x88
 0x80
\end{minted}



其中，ASCII 字符串 {\textquotedbl}DATA{\textquotedbl} 对应于字节 68, 65, 84, 65。\texttt{{\textbackslash}xff} 生成单个字节 255。Unicode 转义 \texttt{{\textbackslash}u2200} 在 UTF-8 中被编码为三个字节 226, 136, 128。注意生成的字节数组不对应任何有效 UTF-8 字符串。




\begin{minted}{jlcon}
julia> isvalid("DATA\xff\u2200")
false
\end{minted}



如前所述，\texttt{CodeUnits\{UInt8,String\}} 类型的行为类似于只读 \texttt{UInt8} 数组。如果需要标准数组，你可以 `Vector\{UInt8\} 进行转换。




\begin{minted}{jlcon}
julia> x = b"123"
3-element Base.CodeUnits{UInt8,String}:
 0x31
 0x32
 0x33

julia> x[1]
0x31

julia> x[1] = 0x32
ERROR: setindex! not defined for Base.CodeUnits{UInt8,String}
[...]

julia> Vector{UInt8}(x)
3-element Array{UInt8,1}:
 0x31
 0x32
 0x33
\end{minted}



同时，要注意到 \texttt{{\textbackslash}xff} 和 \texttt{{\textbackslash}uff} 之间的显著差别：前面的转义序列编码为\emph{字节 255}，而后者代表 \emph{代码 255}，它在 UTF-8 中编码为两个字节：




\begin{minted}{jlcon}
julia> b"\xff"
1-element Base.CodeUnits{UInt8,String}:
 0xff

julia> b"\uff"
2-element Base.CodeUnits{UInt8,String}:
 0xc3
 0xbf
\end{minted}



字符字面量也用到了相同的行为。



对于小于 \texttt{{\textbackslash}u80} 的代码，每个代码的 UTF-8 编码恰好只是由相应 \texttt{{\textbackslash}x} 转义产生的单个字节，因此忽略两者的差别无伤大雅。然而，从 \texttt{x80} 到 \texttt{{\textbackslash}xff} 的转义比起从 \texttt{u80} 到 \texttt{{\textbackslash}uff} 的转义来，就有一个主要的差别：前者都只编码为一个字节，它没有形成任何有效 UTF-8 数据，除非它后面有非常特殊的连接字节；而后者则都代表 2 字节编码的 Unicode 代码。



如果这些还是太难理解，试着读一下 \href{https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/}{{\textquotedbl}每个软件开发人员绝对必须知道的最基础 Unicode 和字符集知识{\textquotedbl}}。它是一个优质的 Unicode 和 UTF-8 指南，或许能帮助解除一些这方面的疑惑。



\hypertarget{10038787961375920908}{}


\section{版本号字面量}



版本号很容易用 \hyperlink{8914616188788850763}{\texttt{v{\textquotedbl}...{\textquotedbl}}} 形式的非标准字符串字面量表示。版本号字面量生成遵循\href{https://semver.org/}{语义版本}规范的 \hyperlink{16653194174751393225}{\texttt{VersionNumber}} 对象，因此由主、次、补丁号构成，后跟预发行 (pre-release) 和生成阿尔法数注释（build alpha-numeric）。例如，\texttt{v{\textquotedbl}0.2.1-rc1+win64{\textquotedbl}} 可分为主版本号 \texttt{0}，次版本号 \texttt{2}，补丁版本号 \texttt{1}，预发行版号 \texttt{rc1}，以及生成版本 \texttt{win64}。输入版本字面量时，除了主版本号以外所有内容都是可选的，因此 \texttt{v{\textquotedbl}0.2{\textquotedbl}} 等效于 \texttt{v{\textquotedbl}0.2.0{\textquotedbl}}（预发行号和生成注释为空），\texttt{v{\textquotedbl}2{\textquotedbl}} 等效于 \texttt{v{\textquotedbl}2.0.0{\textquotedbl}}，等等。



\texttt{VersionNumber} 对象在轻松正确地比较两个（或更多）版本时非常有用。例如，常数 \texttt{VERSION} 把 Julia 的版本号保留为一个 \texttt{VersionNumber} 对象，因此可以像下面这样用简单的声明定义一些特定版本的行为：




\begin{minted}{julia}
if v"0.2" <= VERSION < v"0.3-"
    # 针对 0.2 发行版系列做些事情
end
\end{minted}



注意在上例中用到了非标准版本号 \texttt{v{\textquotedbl}0.3-{\textquotedbl}}，其中有尾随符 \texttt{-}：这个符号是 Julia 标准的扩展，它可以用来表明低于任何 \texttt{0.3} 发行版的版本，包括所有的预发行版。所以上例中代码只能在稳定版本 \texttt{0.2} 上运行，而不能在 \texttt{v{\textquotedbl}0.3.0-rc1{\textquotedbl}} 这样的版本上运行。为了支持非稳定（即预发行）的 \texttt{0.2} 版本，下限检查应像这样应该改为：\texttt{v{\textquotedbl}0.2-{\textquotedbl} <= VERSION}。



另一个非标准版本规范扩展使得能够使用 \texttt{+} 来表示生成版本的上限，例如 \texttt{VERSION > v{\textquotedbl}0.2-rc1+{\textquotedbl}} 可以用来表示任意高于 \texttt{0.2-rc1} 和其任意生成版本的版本：它对 \texttt{v{\textquotedbl}0.2-rc1+win64{\textquotedbl}} 返回 \texttt{false} 而对 \texttt{v{\textquotedbl}0.2-rc2{\textquotedbl}} 返回 \texttt{true}。



在比较中使用这样的特殊版本是个好办法（特别是，总是应该对高版本使用尾随 \texttt{-}，除非有好理由不这样），但它们不应该被用作任何内容的实际版本，因为它们在语义版本控制方案中无效。



除了用于定义常数 \hyperlink{12605722316331458198}{\texttt{VERSION}}，\texttt{VersionNumber} 对象在 \texttt{Pkg} 模块应用广泛，常用于指定软件包的版本及其依赖。



\hypertarget{5096496368362976040}{}


\section{原始字符串字面量}



无插值和非转义的原始字符串可用 \texttt{raw{\textquotedbl}...{\textquotedbl}} 形式的非标准字符串字面量表示。原始字符串字面量生成普通的 \texttt{String} 对象，它无需插值和非转义地包含和输入完全一样的封闭式内容。这对于包含其他语言中使用 {\textquotedbl} 或 {\textbackslash}{\textquotedbl} 作为特殊字符的代码或标记的字符串很有用。



例外的是，引号仍必须转义，例如 \texttt{raw{\textquotedbl}{\textbackslash}{\textquotedbl}{\textquotedbl}} 等效于 \texttt{{\textquotedbl}{\textbackslash}{\textquotedbl}{\textquotedbl}}。为了能够表达所有字符串，反斜杠也必须转义，不过只是当它刚好出现在引号前面时。




\begin{minted}{jlcon}
julia> println(raw"\\ \\\"")
\\ \"
\end{minted}



请注意，前两个反斜杠在输出中逐字显示，这是因为它们不是在引号前面。然而，接下来的一个反斜杠字符转义了后面的一个反斜杠；又由于这些反斜杠出现在引号前面，最后一个反斜杠转义了一个引号。



\hypertarget{11836327794581856778}{}


\chapter{函数}



In Julia, a function is an object that maps a tuple of argument values to a return value. Julia functions are not pure mathematical functions, because they can alter and be affected by the global state of the program. The basic syntax for defining functions in Julia is:




\begin{minted}{jlcon}
julia> function f(x,y)
           x + y
       end
f (generic function with 1 method)
\end{minted}



This function accepts two arguments \texttt{x} and \texttt{y} and returns the value of the last expression evaluated, which is \texttt{x + y}.



在 Julia 中定义函数还有第二种更简洁的语法。上述的传统函数声明语法等效于以下紧凑性的“赋值形式”：




\begin{minted}{jlcon}
julia> f(x,y) = x + y
f (generic function with 1 method)
\end{minted}



尽管函数可以是复合表达式 (见 \hyperlink{14178955634857450370}{复合表达式})，但在赋值形式下，函数体必须是一个一行的表达式。简短的函数定义在 Julia 中是很常见的。非常惯用的短函数语法大大减少了打字和视觉方面的干扰。



使用传统的括号语法调用函数：




\begin{minted}{jlcon}
julia> f(2,3)
5
\end{minted}



Without parentheses, the expression \texttt{f} refers to the function object, and can be passed around like any other value:




\begin{minted}{jlcon}
julia> g = f;

julia> g(2,3)
5
\end{minted}



和变量名一样，Unicode 字符也可以用作函数名：




\begin{minted}{jlcon}
julia> ∑(x,y) = x + y
∑ (generic function with 1 method)

julia> ∑(2, 3)
5
\end{minted}



\hypertarget{7147748673565495429}{}


\section{参数传递行为}



Julia 函数参数遵循有时称为 “pass-by-sharing” 的约定，这意味着变量在被传递给函数时其值并不会被复制。函数参数本身充当新的变量绑定（指向变量值的新地址），它们所指向的值与所传递变量的值完全相同。调用者可以看到对函数内可变值（如数组）的修改。这与 Scheme，大多数 Lisps，Python，Ruby 和 Perl 以及其他动态语言中的行为相同。



\hypertarget{8101712267958021215}{}


\section{\texttt{return} 关键字}



The value returned by a function is the value of the last expression evaluated, which, by default, is the last expression in the body of the function definition. In the example function, \texttt{f}, from the previous section this is the value of the expression \texttt{x + y}. As an alternative, as in many other languages, the \texttt{return} keyword causes a function to return immediately, providing an expression whose value is returned:




\begin{minted}{julia}
function g(x,y)
    return x * y
    x + y
end
\end{minted}



由于函数定义可以输入到交互式会话中，因此可以很容易的比较这些定义：




\begin{minted}{jlcon}
julia> f(x,y) = x + y
f (generic function with 1 method)

julia> function g(x,y)
           return x * y
           x + y
       end
g (generic function with 1 method)

julia> f(2,3)
5

julia> g(2,3)
6
\end{minted}



当然，在一个单纯的线性执行的函数体内，例如 \texttt{g}，使用 \texttt{return} 是没有意义的，因为表达式 \texttt{x + y} 永远不会被执行到，我们可以简单地把 \texttt{x * y} 写为最后一个表达式从而省略掉 \texttt{return}。 然而在使用其他控制流程的函数体内，\texttt{return} 却是有用的。 例如，在计算两条边长分别为 \texttt{x} 和 \texttt{y} 的三角形的斜边长度时可以避免溢出：




\begin{minted}{jlcon}
julia> function hypot(x,y)
           x = abs(x)
           y = abs(y)
           if x > y
               r = y/x
               return x*sqrt(1+r*r)
           end
           if y == 0
               return zero(x)
           end
           r = x/y
           return y*sqrt(1+r*r)
       end
hypot (generic function with 1 method)

julia> hypot(3, 4)
5.0
\end{minted}



这个函数有三个可能的返回处，返回三个不同表达式的值，具体取决于 \texttt{x} 和 \texttt{y} 的值。 最后一行的 \texttt{return} 可以省略，因为它是最后一个表达式。



\hypertarget{3145756716608098346}{}


\subsection{返回类型}



A return type can be specified in the function declaration using the \texttt{::} operator. This converts the return value to the specified type.




\begin{minted}{jlcon}
julia> function g(x, y)::Int8
           return x * y
       end;

julia> typeof(g(1, 2))
Int8
\end{minted}



这个函数将忽略 \texttt{x} 和 \texttt{y} 的类型，返回 \texttt{Int8} 类型的值。有关返回类型的更多信息，请参见\href{@ref}{类型声明}。



\hypertarget{720555615078928815}{}


\subsection{Returning nothing}



For functions that do not need to return a value (functions used only for some side effects), the Julia convention is to return the value \hyperlink{9331422207248206047}{\texttt{nothing}}:




\begin{minted}{julia}
function printx(x)
    println("x = $x")
    return nothing
end
\end{minted}



This is a \emph{convention} in the sense that \texttt{nothing} is not a Julia keyword but a only singleton object of type \texttt{Nothing}. Also, you may notice that the \texttt{printx} function example above is contrived, because \texttt{println} already returns \texttt{nothing}, so that the \texttt{return} line is redundant.



There are two possible shortened forms for the \texttt{return nothing} expression. On the one hand, the \texttt{return} keyword implicitly returns \texttt{nothing}, so it can be used alone. On the other hand, since functions implicitly return their last expression evaluated, \texttt{nothing} can be used alone when it{\textquotesingle}s the last expression. The preference for the expression \texttt{return nothing} as opposed to \texttt{return} or \texttt{nothing} alone is a matter of coding style.



\hypertarget{6095699413160695994}{}


\section{操作符也是函数}



在 Julia中，大多数操作符只不过是支持特殊语法的函数（ \texttt{\&\&} 和\texttt{||} 等具有特殊评估语义的操作符除外，他们不能是函数，因为\hyperlink{7551496361738057869}{短路求值}要求在计算整个表达式的值之前不计算每个操作数）。因此，您也可以使用带括号的参数列表来使用它们，就和任何其他函数一样：




\begin{minted}{jlcon}
julia> 1 + 2 + 3
6

julia> +(1,2,3)
6
\end{minted}



中缀表达式和函数形式完全等价。—— 事实上，前一种形式会被编译器转换为函数调用。这也意味着你可以对操作符，例如 \hyperlink{3677358729494553841}{\texttt{+}} 和 \hyperlink{7592762607639177347}{\texttt{*}} ，进行赋值和传参，就像其它函数传参一样。




\begin{minted}{jlcon}
julia> f = +;

julia> f(1,2,3)
6
\end{minted}



然而，函数以\texttt{f}命名时不再支持中缀表达式。



\hypertarget{11001836393552529826}{}


\section{具有特殊名称的操作符}



有一些特殊的表达式对应的函数调用没有显示的函数名称，它们是：




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
表达式 & 函数调用 \\
\hline
\texttt{[A B C ...]} & \hyperlink{8862791894748483563}{\texttt{hcat}} \\
\hline
\texttt{[A; B; C; ...]} & \hyperlink{14691815416955507876}{\texttt{vcat}} \\
\hline
\texttt{[A B; C D; ...]} & \hyperlink{16279083053557795116}{\texttt{hvcat}} \\
\hline
\texttt{A{\textquotesingle}} & \hyperlink{10565518144285607255}{\texttt{adjoint}} \\
\hline
\texttt{A[i]} & \hyperlink{13720608614876840481}{\texttt{getindex}} \\
\hline
\texttt{A[i] = x} & \hyperlink{1309244355901386657}{\texttt{setindex!}} \\
\hline
\texttt{A.n} & \hyperlink{11040282462516403506}{\texttt{getproperty}} \\
\hline
\texttt{A.n = x} & \hyperlink{9055518433069578344}{\texttt{setproperty!}} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{8300730259363458305}{}


\section{匿名函数}



函数在Julia里是\href{https://en.wikipedia.org/wiki/First-class\_citizen}{一等公民}：可以指定给变量，并使用标准函数调用语法通过被指定的变量调用。函数可以用作参数，也可以当作返回值。函数也可以不带函数名称地匿名创建，使用语法如下：




\begin{minted}{jlcon}
julia> x -> x^2 + 2x - 1
#1 (generic function with 1 method)

julia> function (x)
           x^2 + 2x - 1
       end
#3 (generic function with 1 method)
\end{minted}



这样就创建了一个接受一个参数 \texttt{x} 并返回当前值的多项式 \texttt{x{\textasciicircum}2+2x-1} 的函数。注意结果是个泛型函数，但是带了编译器生成的连续编号的名字。



匿名函数最主要的用法是传递给接收函数作为参数的函数。一个经典的例子是 \hyperlink{11483231213869150535}{\texttt{map}} ，为数组的每个元素应用一次函数，然后返回一个包含结果值的新数组：




\begin{minted}{jlcon}
julia> map(round, [1.2, 3.5, 1.7])
3-element Array{Float64,1}:
 1.0
 4.0
 2.0
\end{minted}



如果做为第一个参数传递给 \hyperlink{11483231213869150535}{\texttt{map}} 的转换函数已经存在，那直接使用函数名称是没问题的。但是通常要使用的函数还没有定义好，这样使用匿名函数就更加方便：




\begin{minted}{jlcon}
julia> map(x -> x^2 + 2x - 1, [1, 3, -1])
3-element Array{Int64,1}:
  2
 14
 -2
\end{minted}



接受多个参数的匿名函数写法可以使用语法 \texttt{(x,y,z)->2x+y-z}，而无参匿名函数写作 \texttt{()->3} 。无参函数的这种写法看起来可能有些奇怪，不过它对于延迟计算很有必要。这种用法会把代码块包进一个无参函数中，后续把它当做 \texttt{f} 调用。



As an example, consider this call to \hyperlink{282460992333585641}{\texttt{get}}:




\begin{minted}{julia}
get(dict, key) do
    # default value calculated here
    time()
end
\end{minted}



上面的代码等效于使用包含代码的匿名函数调用\texttt{get}。 被包围在do和end之间，如下所示




\begin{minted}{julia}
get(()->time(), dict, key)
\end{minted}



The call to \hyperlink{2441622941271736623}{\texttt{time}} is delayed by wrapping it in a 0-argument anonymous function that is called only when the requested key is absent from \texttt{dict}.



\hypertarget{9218398227562398910}{}


\section{元组}



Julia 有一个和函数参数与返回值密切相关的内置数据结构叫做元组（\emph{tuple}）。 一个元组是一个固定长度的容器，可以容纳任何值，但不可以被修改(是\emph{immutable}的)。 元组通过圆括号和逗号来构造，其内容可以通过索引来访问：




\begin{minted}{jlcon}
julia> (1, 1+1)
(1, 2)

julia> (1,)
(1,)

julia> x = (0.0, "hello", 6*7)
(0.0, "hello", 42)

julia> x[2]
"hello"
\end{minted}



注意，长度为1的元组必须使用逗号 \texttt{(1,)}，而 \texttt{(1)} 只是一个带括号的值。\texttt{()} 表示空元组（长度为0）。



\hypertarget{14936898299796428859}{}


\section{具名元组}



元组的元素可以有名字，这时候就有了\emph{具名元组}：




\begin{minted}{jlcon}
julia> x = (a=2, b=1+2)
(a = 2, b = 3)

julia> x[1]
2

julia> x.a
2
\end{minted}



Named tuples are very similar to tuples, except that fields can additionally be accessed by name using dot syntax (\texttt{x.a}) in addition to the regular indexing syntax (\texttt{x[1]}).



\hypertarget{14329153377204363380}{}


\section{多返回值}



Julia 中，一个函数可以返回一个元组来实现返回多个值。不过，元组的创建和消除都不一定要用括号，这时候给人的感觉就是返回了多个值而非一个元组。比如下面这个例子，函数返回了两个值：




\begin{minted}{jlcon}
julia> function foo(a,b)
           a+b, a*b
       end
foo (generic function with 1 method)
\end{minted}



如果你在交互式会话中调用它且不把返回值赋值给任何变量，你会看到返回的元组：




\begin{minted}{jlcon}
julia> foo(2,3)
(5, 6)
\end{minted}



这种值对的典型用法是把每个值抽取为一个变量。Julia 支持简洁的元组“解构”：




\begin{minted}{jlcon}
julia> x, y = foo(2,3)
(5, 6)

julia> x
5

julia> y
6
\end{minted}



You can also return multiple values using the \texttt{return} keyword:




\begin{minted}{julia}
function foo(a,b)
    return a+b, a*b
end
\end{minted}



这与之前的定义的\texttt{foo}函数具有完全相同的效果。



\hypertarget{13913778167558632631}{}


\section{参数解构}



析构特性也可以被用在函数参数中。 如果一个函数的参数被写成了元组形式 (如  \texttt{(x, y)}) 而不是简单的符号，那么一个赋值运算 \texttt{(x, y) = argument} 将会被默认插入：




\begin{minted}{julia}
julia> minmax(x, y) = (y < x) ? (y, x) : (x, y)

julia> gap((min, max)) = max - min

julia> gap(minmax(10, 2))
8
\end{minted}



Notice the extra set of parentheses in the definition of \texttt{gap}. Without those, \texttt{gap} would be a two-argument function, and this example would not work.



\hypertarget{2609189760420802889}{}


\section{变参函数}



It is often convenient to be able to write functions taking an arbitrary number of arguments. Such functions are traditionally known as {\textquotedbl}varargs{\textquotedbl} functions, which is short for {\textquotedbl}variable number of arguments{\textquotedbl}. You can define a varargs function by following the last positional argument with an ellipsis:




\begin{minted}{jlcon}
julia> bar(a,b,x...) = (a,b,x)
bar (generic function with 1 method)
\end{minted}



变量 \texttt{a} 和 \texttt{b} 和以前一样被绑定给前两个参数，后面的参数整个做为迭代集合被绑定到变量 \texttt{x} 上 :




\begin{minted}{jlcon}
julia> bar(1,2)
(1, 2, ())

julia> bar(1,2,3)
(1, 2, (3,))

julia> bar(1, 2, 3, 4)
(1, 2, (3, 4))

julia> bar(1,2,3,4,5,6)
(1, 2, (3, 4, 5, 6))
\end{minted}



在所有这些情况下，\texttt{x} 被绑定到传递给 \texttt{bar} 的尾随值的元组。



也可以限制可以传递给函数的参数的数量，这部分内容稍后在  \hyperlink{14394864568540094383}{参数化约束的可变参数方法}  中讨论。



另一方面，将可迭代集中包含的值拆解为单独的参数进行函数调用通常很方便。 要实现这一点，需要在函数调用中额外使用 \texttt{...} 而不仅仅只是变量：




\begin{minted}{jlcon}
julia> x = (3, 4)
(3, 4)

julia> bar(1,2,x...)
(1, 2, (3, 4))
\end{minted}



在这个情况下一组值会被精确切片成一个可变参数调用，这里参数的数量是可变的。但是并不需要成为这种情况：




\begin{minted}{jlcon}
julia> x = (2, 3, 4)
(2, 3, 4)

julia> bar(1,x...)
(1, 2, (3, 4))

julia> x = (1, 2, 3, 4)
(1, 2, 3, 4)

julia> bar(x...)
(1, 2, (3, 4))
\end{minted}



进一步，拆解给函数调用中的可迭代对象不需要是个元组：




\begin{minted}{jlcon}
julia> x = [3,4]
2-element Array{Int64,1}:
 3
 4

julia> bar(1,2,x...)
(1, 2, (3, 4))

julia> x = [1,2,3,4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> bar(x...)
(1, 2, (3, 4))
\end{minted}



另外，参数可拆解的函数也不一定就是变参函数 —— 尽管一般都是：




\begin{minted}{jlcon}
julia> baz(a,b) = a + b;

julia> args = [1,2]
2-element Array{Int64,1}:
1
2

julia> baz(args...)
3

julia> args = [1,2,3]
3-element Array{Int64,1}:
1
2
3

julia> baz(args...)
ERROR: MethodError: no method matching baz(::Int64, ::Int64, ::Int64)
Closest candidates are:
baz(::Any, ::Any) at none:1
\end{minted}



正如你所见，如果要拆解的容器（比如元组或数组）元素数量不匹配就会报错，和直接给多个参数报错一样。



\hypertarget{16207703858977287144}{}


\section{可选参数}



It is often possible to provide sensible default values for function arguments. This can save users from having to pass every argument on every call. For example, the function \hyperlink{4488183467971164548}{\texttt{Date(y, [m, d])}} from \texttt{Dates} module constructs a \texttt{Date} type for a given year \texttt{y}, month \texttt{m} and day \texttt{d}. However, \texttt{m} and \texttt{d} arguments are optional and their default value is \texttt{1}. This behavior can be expressed concisely as:




\begin{minted}{julia}
function Date(y::Int64, m::Int64=1, d::Int64=1)
    err = validargs(Date, y, m, d)
    err === nothing || throw(err)
    return Date(UTD(totaldays(y, m, d)))
end
\end{minted}



Observe, that this definition calls another method of the \texttt{Date} function that takes one argument of type \texttt{UTInstant\{Day\}}.



With this definition, the function can be called with either one, two or three arguments, and \texttt{1} is automatically passed when only one or two of the arguments are specified:




\begin{minted}{jlcon}
julia> using Dates

julia> Date(2000, 12, 12)
2000-12-12

julia> Date(2000, 12)
2000-12-01

julia> Date(2000)
2000-01-01
\end{minted}



可选参数实际上只是一种方便的语法，用于编写多种具有不同数量参数的方法定义（请参阅 \hyperlink{15680937628543940678}{可选参数和关键字的参数的注意事项}）。这可通过调用 \texttt{methods} 函数来检查我们的 \texttt{Date} 函数示例。



\hypertarget{8084690442149965313}{}


\section{关键字参数}



某些函数需要大量参数，或者具有大量行为。记住如何调用这样的函数可能很困难。关键字参数允许通过名称而不是仅通过位置来识别参数，使得这些复杂接口易于使用和扩展。



例如，考虑绘制一条线的函数 \texttt{plot}。这个函数可能有很多选项，用来控制线条的样式、宽度、颜色等。如果它接受关键字参数，一个可行的调用可能看起来像 \texttt{plot(x, y, width=2)}，这里我们仅指定线的宽度。请注意，这样做有两个目的。调用更可读，因为我们能以其意义标记参数。也使得大量参数的任意子集都能以任意次序传递。



具有关键字参数的函数在签名中使用分号定义：




\begin{minted}{julia}
function plot(x, y; style="solid", width=1, color="black")
    ###
end
\end{minted}



在函数调用时，分号是可选的：可以调用 \texttt{plot(x, y, width=2)} 或 \texttt{plot(x, y; width=2)}，但前者的风格更为常见。显式的分号只有在传递可变参数或下文中描述的需计算的关键字时是必要的。



关键字参数的默认值只在必需时求值（当相应的关键字参数没有被传入），并且按从左到右的顺序求值，因为默认值的表达式可能会参照先前的关键字参数。



关键字参数的类型可以通过如下的方式显式指定：




\begin{minted}{julia}
function f(;x::Int=1)
    ###
end
\end{minted}



Keyword arguments can also be used in varargs functions:




\begin{minted}{julia}
function plot(x...; style="solid")
    ###
end
\end{minted}



附加的关键字参数可用 \texttt{...} 收集，正如在变参函数中：




\begin{minted}{julia}
function f(x; y=0, kwargs...)
    ###
end
\end{minted}



在 \texttt{f} 内部，\texttt{kwargs} 会是一个具名元组。具名元组（以及键类型为 \texttt{Symbol} 的字典）可作为关键字参数传递，这通过在调用中使用分号，例如 \texttt{f(x, z=1; kwargs...)}。



如果一个关键字参数在方法定义中未指定默认值，那么它就是\emph{必需的}：如果调用者没有为其赋值，那么将会抛出一个 \hyperlink{14325831233857471256}{\texttt{UndefKeywordError}} 异常：




\begin{minted}{julia}
function f(x; y)
    ###
end
f(3, y=5) # ok, y is assigned
f(3)      # throws UndefKeywordError(:y)
\end{minted}



在分号后也可传递 \texttt{key => value} 表达式。例如，\texttt{plot(x, y; :width => 2)} 等价于 \texttt{plot(x, y, width=2)}。当关键字名称需要在运行时被计算时，这就很实用了。



When a bare identifier or dot expression occurs after a semicolon, the keyword argument name is implied by the identifier or field name. For example \texttt{plot(x, y; width)} is equivalent to \texttt{plot(x, y; width=width)} and \texttt{plot(x, y; options.width)} is equivalent to \texttt{plot(x, y; width=options.width)}.



可选参数的性质使得可以多次指定同一参数的值。例如，在调用 \texttt{plot(x, y; options..., width=2)} 的过程中，\texttt{options} 结构也能包含一个 \texttt{width} 的值。在这种情况下，最右边的值优先级最高；在此例中，\texttt{width} 的值可以确定是 \texttt{2}。但是，显式地多次指定同一参数的值是不允许的，例如 \texttt{plot(x, y, width=2, width=3)}，这会导致语法错误。



\hypertarget{5412457164020493169}{}


\section{默认值作用域的计算}



当计算可选和关键字参数的默认值表达式时，只有\emph{先前}的参数才在作用域内。例如，给出以下定义：




\begin{minted}{julia}
function f(x, a=b, b=1)
    ###
end
\end{minted}



\texttt{a=b} 中的 \texttt{b} 指的是外部作用域内的 \texttt{b}，而不是后续参数中的 \texttt{b}。



\hypertarget{6290715684433505788}{}


\section{函数参数中的 Do 结构}



把函数作为参数传递给其他函数是一种强大的技术，但它的语法并不总是很方便。当函数参数占据多行时，这样的调用便特别难以编写。例如，考虑在具有多种情况的函数上调用 \hyperlink{11483231213869150535}{\texttt{map}}：




\begin{minted}{julia}
map(x->begin
           if x < 0 && iseven(x)
               return 0
           elseif x == 0
               return 1
           else
               return x
           end
       end,
    [A, B, C])
\end{minted}



Julia 提供了一个保留字 \texttt{do}，用于更清楚地重写此代码：




\begin{minted}{julia}
map([A, B, C]) do x
    if x < 0 && iseven(x)
        return 0
    elseif x == 0
        return 1
    else
        return x
    end
end
\end{minted}



\texttt{do x} 语法创建一个带有参数 \texttt{x} 的匿名函数，并将其作为第一个参数传递 \hyperlink{11483231213869150535}{\texttt{map}}。类似地，\texttt{do a，b} 会创建一个双参数匿名函数，而一个简单的 \texttt{do} 会声明一个满足形式 \texttt{() -> ...} 的匿名函数。



这些参数如何初始化取决于「外部」函数；在这里，\hyperlink{11483231213869150535}{\texttt{map}} 将会依次将 \texttt{x} 设置为 \texttt{A}、\texttt{B}、\texttt{C}，再分别调用调用匿名函数，正如在 \texttt{map(func, [A, B, C])} 语法中所发生的。



这种语法使得更容易使用函数来有效地扩展语言，因为调用看起来就像普通代码块。有许多可能的用法与 \hyperlink{11483231213869150535}{\texttt{map}} 完全不同，比如管理系统状态。例如，有一个版本的 \hyperlink{300818094931158296}{\texttt{open}} 可以通过运行代码来确保已经打开的文件最终会被关闭：




\begin{minted}{julia}
open("outfile", "w") do io
    write(io, data)
end
\end{minted}



这是通过以下定义实现的：




\begin{minted}{julia}
function open(f::Function, args...)
    io = open(args...)
    try
        f(io)
    finally
        close(io)
    end
end
\end{minted}



在这里，\hyperlink{300818094931158296}{\texttt{open}} 首先打开要写入的文件，接着将结果输出流传递给你在 \texttt{do ... end} 代码快中定义的匿名函数。在你的函数退出后，\hyperlink{300818094931158296}{\texttt{open}} 将确保流被正确关闭，无论你的函数是正常退出还是抛出了一个异常（\texttt{try/finally} 结构会在 \hyperlink{6880586223574224557}{流程控制} 中描述）。



使用 \texttt{do} 代码块语法时，查阅文档或实现有助于了解用户函数的参数是如何初始化的。



A \texttt{do} block, like any other inner function, can {\textquotedbl}capture{\textquotedbl} variables from its enclosing scope. For example, the variable \texttt{data} in the above example of \texttt{open...do} is captured from the outer scope. Captured variables can create performance challenges as discussed in \hyperlink{627547588659365489}{performance tips}.



\hypertarget{8022546101791804390}{}


\section{Function composition and piping}



Functions in Julia can be combined by composing or piping (chaining) them together.



Function composition is when you combine functions together and apply the resulting composition to arguments. You use the function composition operator (\texttt{∘}) to compose the functions, so \texttt{(f ∘ g)(args...)} is the same as \texttt{f(g(args...))}.



You can type the composition operator at the REPL and suitably-configured editors using \texttt{{\textbackslash}circ<tab>}.



For example, the \texttt{sqrt} and \texttt{+} functions can be composed like this:




\begin{minted}{jlcon}
julia> (sqrt ∘ +)(3, 6)
3.0
\end{minted}



这个语句先把数字相加，再对结果求平方根。



The next example composes three functions and maps the result over an array of strings:




\begin{minted}{jlcon}
julia> map(first ∘ reverse ∘ uppercase, split("you can compose functions like this"))
6-element Array{Char,1}:
 'U': ASCII/Unicode U+0055 (category Lu: Letter, uppercase)
 'N': ASCII/Unicode U+004E (category Lu: Letter, uppercase)
 'E': ASCII/Unicode U+0045 (category Lu: Letter, uppercase)
 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)
 'E': ASCII/Unicode U+0045 (category Lu: Letter, uppercase)
 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)
\end{minted}



Function chaining (sometimes called {\textquotedbl}piping{\textquotedbl} or {\textquotedbl}using a pipe{\textquotedbl} to send data to a subsequent function) is when you apply a function to the previous function{\textquotesingle}s output:




\begin{minted}{jlcon}
julia> 1:10 |> sum |> sqrt
7.416198487095663
\end{minted}



Here, the total produced by \texttt{sum} is passed to the \texttt{sqrt} function. The equivalent composition would be:




\begin{minted}{jlcon}
julia> (sqrt ∘ sum)(1:10)
7.416198487095663
\end{minted}



The pipe operator can also be used with broadcasting, as \texttt{.|>}, to provide a useful combination of the chaining/piping and dot vectorization syntax (described next).




\begin{minted}{jlcon}
julia> ["a", "list", "of", "strings"] .|> [uppercase, reverse, titlecase, length]
4-element Array{Any,1}:
  "A"
  "tsil"
  "Of"
 7
\end{minted}



\hypertarget{13590013989415065742}{}


\section{向量化函数的点语法}



在科学计算语言中，通常会有函数的「向量化」版本，它简单地将给定函数 \texttt{f(x)} 作用于数组 \texttt{A} 的每个元素，接着通过 \texttt{f(A)} 生成一个新数组。这种语法便于数据处理，但在其它语言中，向量化通常也是性能所需要的：如果循环很慢，函数的「向量化」版本可以调用由低级语言编写的、快速的库代码。在 Julia 中，向量化函数\emph{不}是性能所必需的，实际上编写自己的循环通常也是有益的（请参阅 \hyperlink{818954303942149020}{Performance Tips}），但它们仍然很方便。因此，\emph{任何} Julia 函数 \texttt{f} 能够以元素方式作用于任何数组（或者其它集合），这通过语法 \texttt{f.(A)} 实现。例如，\texttt{sin} 可以作用于向量 \texttt{A} 中的所有元素，如下所示：




\begin{minted}{jlcon}
julia> A = [1.0, 2.0, 3.0]
3-element Array{Float64,1}:
 1.0
 2.0
 3.0

julia> sin.(A)
3-element Array{Float64,1}:
 0.8414709848078965
 0.9092974268256817
 0.1411200080598672
\end{minted}



Of course, you can omit the dot if you write a specialized {\textquotedbl}vector{\textquotedbl} method of \texttt{f}, e.g. via \texttt{f(A::AbstractArray) = map(f, A)}, and this is just as efficient as \texttt{f.(A)}. The advantage of the \texttt{f.(A)} syntax is that which functions are vectorizable need not be decided upon in advance by the library writer.



更一般地，\texttt{f.(args...)} 实际上等价于 \texttt{broadcast(f, args...)}，它允许你操作多个数组（甚至是不同形状的），或是数组和标量的混合（请参阅 \href{@ref}{Broadcasting}）。例如，如果有 \texttt{f(x,y) = 3x + 4y}，那么 \texttt{f.(pi,A)} 将为 \texttt{A} 中的每个 \texttt{a} 返回一个由 \texttt{f(pi,a)} 组成的新数组，而 \texttt{f.(vector1,vector2)} 将为每个索引 \texttt{i} 返回一个由 \texttt{f(vector1[i],vector2[i])} 组成的新向量（如果向量具有不同的长度则会抛出异常）。




\begin{minted}{jlcon}
julia> f(x,y) = 3x + 4y;

julia> A = [1.0, 2.0, 3.0];

julia> B = [4.0, 5.0, 6.0];

julia> f.(pi, A)
3-element Array{Float64,1}:
 13.42477796076938
 17.42477796076938
 21.42477796076938

julia> f.(A, B)
3-element Array{Float64,1}:
 19.0
 26.0
 33.0
\end{minted}



此外，\emph{嵌套的} \texttt{f.(args...)} 调用会被\emph{融合}到一个 \texttt{broadcast} 循环中。例如，\texttt{sin.(cos.(X))} 等价于 \texttt{broadcast(x -> sin(cos(x)), X)}，类似于 \texttt{[sin(cos(x)) for x in X]}：在 \texttt{X} 上只有一个循环，并且只为结果分配了一个数组。[ 相反，在典型的「向量化」语言中，\texttt{sin(cos(X))} 首先会为 \texttt{tmp=cos(X)} 分配第一个临时数组，然后在单独的循环中计算 \texttt{sin(tmp)}，再分配第二个数组。] 这种循环融合不是可能发生也可能不发生的编译器优化，只要遇到了嵌套的 \texttt{f.(args...)} 调用，它就是一个\emph{语法保证}。技术上，一旦遇到「非点」函数调用，融合就会停止；例如，在 \texttt{sin.(sort(cos.(X)))} 中，由于插入的 \texttt{sort} 函数，\texttt{sin} 和 \texttt{cos} 无法被合并。



Finally, the maximum efficiency is typically achieved when the output array of a vectorized operation is \emph{pre-allocated}, so that repeated calls do not allocate new arrays over and over again for the results (see \href{@ref}{Pre-allocating outputs}). A convenient syntax for this is \texttt{X .= ...}, which is equivalent to \texttt{broadcast!(identity, X, ...)} except that, as above, the \texttt{broadcast!} loop is fused with any nested {\textquotedbl}dot{\textquotedbl} calls. For example, \texttt{X .= sin.(Y)} is equivalent to \texttt{broadcast!(sin, X, Y)}, overwriting \texttt{X} with \texttt{sin.(Y)} in-place. If the left-hand side is an array-indexing expression, e.g. \texttt{X[begin+1:end] .= sin.(Y)}, then it translates to \texttt{broadcast!} on a \texttt{view}, e.g. \texttt{broadcast!(sin, view(X, firstindex(X)+1:lastindex(X)), Y)}, so that the left-hand side is updated in-place.



由于在表达式中为许多操作和函数调用添加点可能很乏味并导致难以阅读的代码，宏 \hyperlink{16688502228717894452}{\texttt{@.}} 用于将表达式中的\emph{每个}函数调用、操作和赋值转换为「点」版本。




\begin{minted}{jlcon}
julia> Y = [1.0, 2.0, 3.0, 4.0];

julia> X = similar(Y); # pre-allocate output array

julia> @. X = sin(cos(Y)) # equivalent to X .= sin.(cos.(Y))
4-element Array{Float64,1}:
  0.5143952585235492
 -0.4042391538522658
 -0.8360218615377305
 -0.6080830096407656
\end{minted}



像 \texttt{.+} 这样的二元（或一元）运算符使用相同的机制进行管理：它们等价于 \texttt{broadcast} 调用且可与其它嵌套的「点」调用融合。\texttt{X .+= Y} 等等价于 \texttt{X .= X .+ Y}，结果为一个融合的 in-place 赋值；另见 \hyperlink{15967322336376951940}{dot operators}。



您也可以使用 \hyperlink{5135459825603202944}{\texttt{|>}} 将点操作与函数链组合在一起，如本例所示：




\begin{minted}{jlcon}
julia> [1:5;] .|> [x->x^2, inv, x->2*x, -, isodd]
5-element Array{Real,1}:
    1
    0.5
    6
   -4
 true
\end{minted}



\hypertarget{17965614568943116111}{}


\section{更多阅读}



我们应该在这里提到，这远不是定义函数的完整图景。Julia 拥有一个复杂的类型系统并且允许对参数类型进行多重分派。这里给出的示例都没有为它们的参数提供任何类型注释，意味着它们可以作用于任何类型的参数。类型系统在\hyperlink{8510890508040013186}{类型}中描述，而\hyperlink{3842379394166369470}{方法}则描述了根据运行时参数类型上的多重分派所选择的方法定义函数。



\hypertarget{8001618391799989953}{}


\chapter{流程控制}



Julia 提供了大量的流程控制构件：



\begin{itemize}
\item \hyperlink{14178955634857450370}{Compound Expressions}: \texttt{begin} and \texttt{;}.


\item \hyperlink{14451148373001501733}{条件表达式}：\texttt{if}-\texttt{elseif}-\texttt{else} 和 \texttt{?:} (三元运算符)。


\item \hyperlink{7551496361738057869}{短路求值}：\texttt{\&\&}、\texttt{||} 和链式比较。


\item \hyperlink{9034109510149997190}{重复执行：循环}：\texttt{while} 和 \texttt{for}。


\item \hyperlink{17887694433469406627}{异常处理}：\texttt{try}-\texttt{catch}、\hyperlink{17992125292605951734}{\texttt{error}} 和 \hyperlink{16410366672587017456}{\texttt{throw}}。


\item \hyperlink{17473131347184639576}{\texttt{Task}（协程）}：\hyperlink{4920987536368477483}{\texttt{yieldto}}。

\end{itemize}


前五个流程控制机制是高级编程语言的标准。\hyperlink{7131243650304654155}{\texttt{Task}} 不是那么的标准：它提供了非局部的流程控制，这使得在暂时挂起的计算任务之间进行切换成为可能。这是一个功能强大的构件：Julia 中的异常处理和协同多任务都是通过 \texttt{Task} 实现的。虽然日常编程并不需要直接使用 \texttt{Task}，但某些问题用 \texttt{Task} 处理会更加简单。



\hypertarget{16096814372489430927}{}


\section{复合表达式}



Sometimes it is convenient to have a single expression which evaluates several subexpressions in order, returning the value of the last subexpression as its value. There are two Julia constructs that accomplish this: \texttt{begin} blocks and \texttt{;} chains. The value of both compound expression constructs is that of the last subexpression. Here{\textquotesingle}s an example of a \texttt{begin} block:




\begin{minted}{jlcon}
julia> z = begin
           x = 1
           y = 2
           x + y
       end
3
\end{minted}



Since these are fairly small, simple expressions, they could easily be placed onto a single line, which is where the \texttt{;} chain syntax comes in handy:




\begin{minted}{jlcon}
julia> z = (x = 1; y = 2; x + y)
3
\end{minted}



This syntax is particularly useful with the terse single-line function definition form introduced in \hyperlink{645008301484218813}{Functions}. Although it is typical, there is no requirement that \texttt{begin} blocks be multiline or that \texttt{;} chains be single-line:




\begin{minted}{jlcon}
julia> begin x = 1; y = 2; x + y end
3

julia> (x = 1;
        y = 2;
        x + y)
3
\end{minted}



\hypertarget{9876835618453764646}{}


\section{条件表达式}



条件表达式（Conditional evaluation）可以根据布尔表达式的值，让部分代码被执行或者不被执行。下面是对 \texttt{if}-\texttt{elseif}-\texttt{else} 条件语法的分析：




\begin{minted}{julia}
if x < y
    println("x is less than y")
elseif x > y
    println("x is greater than y")
else
    println("x is equal to y")
end
\end{minted}



如果表达式 \texttt{x < y} 是 \texttt{true}，那么对应的代码块会被执行；否则判断条件表达式 \texttt{x > y}，如果它是 \texttt{true}，则执行对应的代码块；如果没有表达式是 true，则执行 \texttt{else} 代码块。下面是一个例子：




\begin{minted}{jlcon}
julia> function test(x, y)
           if x < y
               println("x is less than y")
           elseif x > y
               println("x is greater than y")
           else
               println("x is equal to y")
           end
       end
test (generic function with 1 method)

julia> test(1, 2)
x is less than y

julia> test(2, 1)
x is greater than y

julia> test(1, 1)
x is equal to y
\end{minted}



\texttt{elseif} 和 \texttt{else} 代码块是可选的，并且可以使用任意多个 \texttt{elseif} 代码块。 \texttt{if}-\texttt{elseif}-\texttt{else} 组件中的第一个条件表达式为 \texttt{true} 时，其他条件表达式才会被执行，当对应的代码块被执行后，其余的表达式或者代码块将不会被执行。



\texttt{if} 代码块是{\textquotedbl}有渗漏的{\textquotedbl}，也就是说它们不会引入局部作用域。这意味着在 \texttt{if} 语句中新定义的变量依然可以在 \texttt{if} 代码块之后使用，尽管这些变量没有在 \texttt{if} 语句之前定义过。所以，我们可以将上面的 \texttt{test} 函数定义为




\begin{minted}{jlcon}
julia> function test(x,y)
           if x < y
               relation = "less than"
           elseif x == y
               relation = "equal to"
           else
               relation = "greater than"
           end
           println("x is ", relation, " y.")
       end
test (generic function with 1 method)

julia> test(2, 1)
x is greater than y.
\end{minted}



变量 \texttt{relation} 是在 \texttt{if} 代码块内部声明的，但可以在外部使用。然而，在利用这种行为的时候，要保证变量在所有的分支下都进行了定义。对上述函数做如下修改会导致运行时错误




\begin{minted}{jlcon}
julia> function test(x,y)
           if x < y
               relation = "less than"
           elseif x == y
               relation = "equal to"
           end
           println("x is ", relation, " y.")
       end
test (generic function with 1 method)

julia> test(1,2)
x is less than y.

julia> test(2,1)
ERROR: UndefVarError: relation not defined
Stacktrace:
 [1] test(::Int64, ::Int64) at ./none:7
\end{minted}



\texttt{if} 代码块也会返回一个值，这可能对于一些从其他语言转过来的用户来说不是很直观。 这个返回值就是被执行的分支中最后一个被执行的语句的返回值。 所以




\begin{minted}{jlcon}
julia> x = 3
3

julia> if x > 0
           "positive!"
       else
           "negative..."
       end
"positive!"
\end{minted}



需要注意的是，在 Julia 中，经常会用短路求值来表示非常短的条件表达式（单行），这会在下一节中介绍。



与 C, MATLAB, Perl, Python，以及 Ruby 不同，但跟 Java，还有一些别的严谨的类型语言类似：一个条件表达式的值如果不是 \texttt{true} 或者 \texttt{false} 的话，会返回错误：




\begin{minted}{jlcon}
julia> if 1
           println("true")
       end
ERROR: TypeError: non-boolean (Int64) used in boolean context
\end{minted}



这个错误是说，条件判断结果的类型：\hyperlink{7720564657383125058}{\texttt{Int64}} 是错的，而不是期望的 \hyperlink{46725311238864537}{\texttt{Bool}}。



所谓的 {\textquotedbl}三元运算符{\textquotedbl}, \texttt{?:}，很类似 \texttt{if}-\texttt{elseif}-\texttt{else} 语法，它用于选择性获取单个表达式的值，而不是选择性执行大段的代码块。它因在很多语言中是唯一一个有三个操作数的运算符而得名：




\begin{minted}{julia}
a ? b : c
\end{minted}



在 \texttt{?} 之前的表达式 \texttt{a}, 是一个条件表达式，如果条件 \texttt{a} 是 \texttt{true}，三元运算符计算在 \texttt{:} 之前的表达式 \texttt{b}；如果条件 \texttt{a} 是 \texttt{false}，则执行 \texttt{:} 后面的表达式 \texttt{c}。注意，\texttt{?} 和 \texttt{:} 旁边的空格是强制的，像 \texttt{a?b:c} 这种表达式不是一个有效的三元表达式（但在\texttt{?} 和 \texttt{:} 之后的换行是允许的）。



理解这种行为的最简单方式是看一个实际的例子。在前一个例子中，虽然在三个分支中都有调用 \texttt{println}，但实质上是选择打印哪一个字符串。在这种情况下，我们可以用三元运算符更紧凑地改写。为了简明，我们先尝试只有两个分支的版本：




\begin{minted}{jlcon}
julia> x = 1; y = 2;

julia> println(x < y ? "less than" : "not less than")
less than

julia> x = 1; y = 0;

julia> println(x < y ? "less than" : "not less than")
not less than
\end{minted}



如果表达式 \texttt{x < y} 为真，整个三元运算符会执行字符串 \texttt{{\textquotedbl}less than{\textquotedbl}}，否则执行字符串 \texttt{{\textquotedbl}not less than{\textquotedbl}}。原本的三个分支的例子需要链式嵌套使用三元运算符：




\begin{minted}{jlcon}
julia> test(x, y) = println(x < y ? "x is less than y"    :
                            x > y ? "x is greater than y" : "x is equal to y")
test (generic function with 1 method)

julia> test(1, 2)
x is less than y

julia> test(2, 1)
x is greater than y

julia> test(1, 1)
x is equal to y
\end{minted}



为了方便链式传值，运算符从右到左连接到一起。



重要地是，与 \texttt{if}-\texttt{elseif}-\texttt{else} 类似，\texttt{:} 之前和之后的表达式只有在条件表达式为 \texttt{true} 或者 \texttt{false} 时才会被相应地执行：




\begin{minted}{jlcon}
julia> v(x) = (println(x); x)
v (generic function with 1 method)

julia> 1 < 2 ? v("yes") : v("no")
yes
"yes"

julia> 1 > 2 ? v("yes") : v("no")
no
"no"
\end{minted}



\hypertarget{736299957672008833}{}


\section{短路求值}



短路求值非常类似条件求值。这种行为在多数有 \texttt{\&\&} 和 \texttt{||} 布尔运算符地命令式编程语言里都可以找到：在一系列由这些运算符连接的布尔表达式中，为了得到整个链的最终布尔值，仅仅只有最小数量的表达式被计算。更明确的说，这意味着：



\begin{itemize}
\item 在表达式 \texttt{a \&\& b} 中，子表达式 \texttt{b} 仅当 \texttt{a} 为 \texttt{true} 的时候才会被执行。


\item 在表达式 \texttt{a || b} 中，子表达式 \texttt{b} 仅在 \texttt{a} 为 \texttt{false} 的时候才会被执行。

\end{itemize}


这里的原因是：如果 \texttt{a} 是 \texttt{false}，那么无论 \texttt{b} 的值是多少，\texttt{a \&\& b} 一定是 \texttt{false}。同理，如果 \texttt{a} 是 \texttt{true}，那么无论 \texttt{b} 的值是多少，\texttt{a || b} 的值一定是 true。\texttt{\&\&} 和 \texttt{||} 都依赖于右边，但是 \texttt{\&\&} 比 \texttt{||} 有更高的优先级。我们可以简单地测试一下这个行为：




\begin{minted}{jlcon}
julia> t(x) = (println(x); true)
t (generic function with 1 method)

julia> f(x) = (println(x); false)
f (generic function with 1 method)

julia> t(1) && t(2)
1
2
true

julia> t(1) && f(2)
1
2
false

julia> f(1) && t(2)
1
false

julia> f(1) && f(2)
1
false

julia> t(1) || t(2)
1
true

julia> t(1) || f(2)
1
true

julia> f(1) || t(2)
1
2
true

julia> f(1) || f(2)
1
2
false
\end{minted}



你可以用同样的方式测试不同 \texttt{\&\&} 和 \texttt{||} 运算符的组合条件下的关联和优先级。



这种行为在 Julia 中经常被用来作为简短 \texttt{if} 语句的替代。 可以用 \texttt{<cond> \&\& <statement>} (可读为: <cond> \emph{and then} <statement>)来替换 \texttt{if <cond> <statement> end}。 类似的， 可以用 \texttt{<cond> || <statement>} (可读为: <cond> \emph{or else} <statement>)来替换 \texttt{if ! <cond> <statement> end}.



例如，可以像这样定义递归阶乘：




\begin{minted}{jlcon}
julia> function fact(n::Int)
           n >= 0 || error("n must be non-negative")
           n == 0 && return 1
           n * fact(n-1)
       end
fact (generic function with 1 method)

julia> fact(5)
120

julia> fact(0)
1

julia> fact(-1)
ERROR: n must be non-negative
Stacktrace:
 [1] error at ./error.jl:33 [inlined]
 [2] fact(::Int64) at ./none:2
 [3] top-level scope
\end{minted}



\textbf{无}短路求值的布尔运算可以用位布尔运算符来完成，见\hyperlink{16865688524696028421}{数学运算和初等函数}：\texttt{\&} 和 \texttt{|}。这些是普通的函数，同时也刚好支持中缀运算符语法，但总是会计算它们的所有参数：




\begin{minted}{jlcon}
julia> f(1) & t(2)
1
2
false

julia> t(1) | t(2)
1
2
true
\end{minted}



与 \texttt{if}, \texttt{elseif} 或者三元运算符中的条件表达式相同，\texttt{\&\&} 或者 \texttt{||} 的操作数必须是布尔值（\texttt{true} 或者 \texttt{false}）。在链式嵌套的条件表达式中， 除最后一项外，使用非布尔值会导致错误：




\begin{minted}{jlcon}
julia> 1 && true
ERROR: TypeError: non-boolean (Int64) used in boolean context
\end{minted}



但在链的末尾允许使用任意类型的表达式，此表达式会根据前面的条件被执行并返回：




\begin{minted}{jlcon}
julia> true && (x = (1, 2, 3))
(1, 2, 3)

julia> false && (x = (1, 2, 3))
false
\end{minted}



\hypertarget{6800841505698205300}{}


\section{重复执行：循环}



有两个用于重复执行表达式的组件：\texttt{while} 循环和 \texttt{for} 循环。下面是一个 \texttt{while} 循环的例子：




\begin{minted}{jlcon}
julia> i = 1;

julia> while i <= 5
           println(i)
           global i += 1
       end
1
2
3
4
5
\end{minted}



\texttt{while} 循环会执行条件表达式（例子中为 \texttt{i <= 5}），只要它为 \texttt{true}，就一直执行\texttt{while} 循环的主体部分。当 \texttt{while} 循环第一次执行时，如果条件表达式为 \texttt{false}，那么主体代码就一次也不会被执行。



\texttt{for} 循环使得常见的重复执行代码写起来更容易。 像之前 \texttt{while} 循环中用到的向上和向下计数是可以用 \texttt{for} 循环更简明地表达：




\begin{minted}{jlcon}
julia> for i = 1:5
           println(i)
       end
1
2
3
4
5
\end{minted}



这里的 \texttt{1:5} 是一个范围对象，代表数字 1, 2, 3, 4, 5 的序列。\texttt{for} 循环在这些值之中迭代，对每一个变量 \texttt{i} 进行赋值。\texttt{for} 循环与之前 \texttt{while} 循环的一个非常重要区别是作用域，即变量的可见性。如果变量 \texttt{i} 没有在另一个作用域里引入，在 \texttt{for} 循环内，它就只在 \texttt{for} 循环内部可见，在外部和后面均不可见。你需要一个新的交互式会话实例或者一个新的变量名来测试这个特性：




\begin{minted}{jlcon}
julia> for j = 1:5
           println(j)
       end
1
2
3
4
5

julia> j
ERROR: UndefVarError: j not defined
\end{minted}



参见\hyperlink{11957539949537805757}{变量作用域}中对变量作用域的详细解释以及它在 Julia 中是如何工作的。



一般来说，\texttt{for} 循环组件可以用于迭代任一个容器。在这种情况下，相比 \texttt{=}，另外的（但完全相同）关键字 \texttt{in} 或者 \texttt{∈} 则更常用，因为它使得代码更清晰：




\begin{minted}{jlcon}
julia> for i in [1,4,0]
           println(i)
       end
1
4
0

julia> for s ∈ ["foo","bar","baz"]
           println(s)
       end
foo
bar
baz
\end{minted}



在手册后面的章节中会介绍和讨论各种不同的迭代容器（比如，\hyperlink{16720099245556932994}{多维数组}）。



为了方便，我们可能会在测试条件不成立之前终止一个 \texttt{while} 循环，或者在访问到迭代对象的结尾之前停止一个 \texttt{for} 循环，这可以用关键字 \texttt{break} 来完成：




\begin{minted}{jlcon}
julia> i = 1;

julia> while true
           println(i)
           if i >= 5
               break
           end
           global i += 1
       end
1
2
3
4
5

julia> for j = 1:1000
           println(j)
           if j >= 5
               break
           end
       end
1
2
3
4
5
\end{minted}



没有关键字 \texttt{break} 的话，上面的 \texttt{while} 循环永远不会自己结束，而 \texttt{for} 循环会迭代到 1000，这些循环都可以使用 \texttt{break} 来提前结束。



在某些场景下，需要直接结束此次迭代，并立刻进入下次迭代，\texttt{continue} 关键字可以用来完成此功能：




\begin{minted}{jlcon}
julia> for i = 1:10
           if i % 3 != 0
               continue
           end
           println(i)
       end
3
6
9
\end{minted}



这是一个有点做作的例子，因为我们可以通过否定这个条件，把 \texttt{println} 调用放到 \texttt{if} 代码块里来更简洁的实现同样的功能。在实际应用中，在 \texttt{continue} 后面还会有更多的代码要运行，并且调用 \texttt{continue} 的地方可能会有多个。



多个嵌套的 \texttt{for} 循环可以合并到一个外部循环，可以用来创建其迭代对象的笛卡尔积：




\begin{minted}{jlcon}
julia> for i = 1:2, j = 3:4
           println((i, j))
       end
(1, 3)
(1, 4)
(2, 3)
(2, 4)
\end{minted}



有了这个语法，迭代变量依然可以正常使用循环变量来进行索引，例如 \texttt{for i = 1:n, j = 1:i} 是合法的，但是在一个循环里面使用 \texttt{break} 语句则会跳出整个嵌套循环，不仅仅是内层循环。每次内层循环运行的时候，变量（\texttt{i} 和 \texttt{j}）会被赋值为他们当前的迭代变量值。所以对 \texttt{i} 的赋值对于接下来的迭代是不可见的：




\begin{minted}{jlcon}
julia> for i = 1:2, j = 3:4
           println((i, j))
           i = 0
       end
(1, 3)
(1, 4)
(2, 3)
(2, 4)
\end{minted}



如果这个例子给每个变量一个关键字 \texttt{for} 来重写，那么输出会不一样：第二个和第四个变量包含 \texttt{0}。



\hypertarget{11112426789887598982}{}


\section{异常处理}



当一个意外条件发生时，一个函数可能无法向调用者返回一个合理的值。在这种情况下，最好让意外条件终止程序并打印出调试的错误信息，或者根据程序员预先提供的异常处理代码来采取恰当的措施。



\hypertarget{18218681852389631555}{}


\subsection{内置的 \texttt{Exception}}



当一个意外的情况发生时，会抛出 \texttt{Exception}。下面列出的内置 \texttt{Exception} 都会中断正常的控制流程。




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|}
\hline
\texttt{Exception} \\
\hline
\hyperlink{9721838137887538764}{\texttt{ArgumentError}} \\
\hline
\hyperlink{9731558909100893938}{\texttt{BoundsError}} \\
\hline
\hyperlink{15047752250898038281}{\texttt{CompositeException}} \\
\hline
\hyperlink{13752533629496758140}{\texttt{DimensionMismatch}} \\
\hline
\hyperlink{4168463413201806292}{\texttt{DivideError}} \\
\hline
\hyperlink{14085880504701688639}{\texttt{DomainError}} \\
\hline
\hyperlink{2683611566077490148}{\texttt{EOFError}} \\
\hline
\hyperlink{12102596058483452470}{\texttt{ErrorException}} \\
\hline
\hyperlink{5399118524830636312}{\texttt{InexactError}} \\
\hline
\hyperlink{15248096136337910028}{\texttt{InitError}} \\
\hline
\hyperlink{11255134339055983338}{\texttt{InterruptException}} \\
\hline
\texttt{InvalidStateException} \\
\hline
\hyperlink{12862287453053981792}{\texttt{KeyError}} \\
\hline
\hyperlink{15548397364092946520}{\texttt{LoadError}} \\
\hline
\hyperlink{9656432107553099418}{\texttt{OutOfMemoryError}} \\
\hline
\hyperlink{5617183776424836760}{\texttt{ReadOnlyMemoryError}} \\
\hline
\hyperlink{10250718604436154991}{\texttt{RemoteException}} \\
\hline
\hyperlink{68769522931907606}{\texttt{MethodError}} \\
\hline
\hyperlink{10461069697702909970}{\texttt{OverflowError}} \\
\hline
\hyperlink{6896679243086513948}{\texttt{Meta.ParseError}} \\
\hline
\hyperlink{16303515589950241655}{\texttt{SystemError}} \\
\hline
\hyperlink{2622693721821893139}{\texttt{TypeError}} \\
\hline
\hyperlink{7764749529861419421}{\texttt{UndefRefError}} \\
\hline
\hyperlink{4452889246677411554}{\texttt{UndefVarError}} \\
\hline
\hyperlink{414193743931514144}{\texttt{StringIndexError}} \\
\hline
\end{tabulary}

\end{table}



例如，当输入参数为负实数时，\hyperlink{4551113327515323898}{\texttt{sqrt}} 函数会抛出一个 \hyperlink{14085880504701688639}{\texttt{DomainError}} ：




\begin{minted}{jlcon}
julia> sqrt(-1)
ERROR: DomainError with -1.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
[...]
\end{minted}



你可能需要根据下面的方式来定义你自己的异常：




\begin{minted}{jlcon}
julia> struct MyCustomException <: Exception end
\end{minted}



\hypertarget{11451631637715363921}{}


\subsection{\texttt{throw} 函数}



我们可以用 \hyperlink{16410366672587017456}{\texttt{throw}} 显式地创建异常。例如，若一个函数只对非负数有定义，当输入参数是负数的时候，可以用 \hyperlink{16410366672587017456}{\texttt{throw}} 抛出一个 \hyperlink{14085880504701688639}{\texttt{DomainError}}。




\begin{minted}{jlcon}
julia> f(x) = x>=0 ? exp(-x) : throw(DomainError(x, "argument must be nonnegative"))
f (generic function with 1 method)

julia> f(1)
0.36787944117144233

julia> f(-1)
ERROR: DomainError with -1:
argument must be nonnegative
Stacktrace:
 [1] f(::Int64) at ./none:1
\end{minted}



注意 \hyperlink{14085880504701688639}{\texttt{DomainError}} 后面不接括号的话不是一个异常，而是一个异常类型。我们需要调用它来获得一个 \texttt{Exception} 对象：




\begin{minted}{jlcon}
julia> typeof(DomainError(nothing)) <: Exception
true

julia> typeof(DomainError) <: Exception
false
\end{minted}



另外，一些异常类型会接受一个或多个参数来进行错误报告：




\begin{minted}{jlcon}
julia> throw(UndefVarError(:x))
ERROR: UndefVarError: x not defined
\end{minted}



我们可以仿照 \hyperlink{4452889246677411554}{\texttt{UndefVarError}} 的写法，用自定义异常类型来轻松实现这个机制：




\begin{minted}{jlcon}
julia> struct MyUndefVarError <: Exception
           var::Symbol
       end

julia> Base.showerror(io::IO, e::MyUndefVarError) = print(io, e.var, " not defined")
\end{minted}



\begin{quote}
\textbf{Note}

When writing an error message, it is preferred to make the first word lowercase. For example,

\texttt{size(A) == size(B) || throw(DimensionMismatch({\textquotedbl}size of A not equal to size of B{\textquotedbl}))}

is preferred over

\texttt{size(A) == size(B) || throw(DimensionMismatch({\textquotedbl}Size of A not equal to size of B{\textquotedbl}))}.

However, sometimes it makes sense to keep the uppercase first letter, for instance if an argument to a function is a capital letter:

\texttt{size(A,1) == size(B,2) || throw(DimensionMismatch({\textquotedbl}A has first dimension...{\textquotedbl}))}.

\end{quote}


\hypertarget{18278096073868016389}{}


\subsection{错误}



我们可以用 \hyperlink{17992125292605951734}{\texttt{error}} 函数生成一个 \hyperlink{12102596058483452470}{\texttt{ErrorException}} 来中断正常的控制流程。



假设我们希望在计算负数的平方根时让程序立即停止执行。为了实现它，我们可以定义一个挑剔的 \hyperlink{4551113327515323898}{\texttt{sqrt}} 函数，当它的参数是负数时，产生一个错误：




\begin{minted}{jlcon}
julia> fussy_sqrt(x) = x >= 0 ? sqrt(x) : error("negative x not allowed")
fussy_sqrt (generic function with 1 method)

julia> fussy_sqrt(2)
1.4142135623730951

julia> fussy_sqrt(-1)
ERROR: negative x not allowed
Stacktrace:
 [1] error at ./error.jl:33 [inlined]
 [2] fussy_sqrt(::Int64) at ./none:1
 [3] top-level scope
\end{minted}



如果另一个函数调用 \texttt{fussy\_sqrt} 和一个负数, 它会立马返回， 在交互会话中显示错误信息，而不会继续执行调用的函数：




\begin{minted}{jlcon}
julia> function verbose_fussy_sqrt(x)
           println("before fussy_sqrt")
           r = fussy_sqrt(x)
           println("after fussy_sqrt")
           return r
       end
verbose_fussy_sqrt (generic function with 1 method)

julia> verbose_fussy_sqrt(2)
before fussy_sqrt
after fussy_sqrt
1.4142135623730951

julia> verbose_fussy_sqrt(-1)
before fussy_sqrt
ERROR: negative x not allowed
Stacktrace:
 [1] error at ./error.jl:33 [inlined]
 [2] fussy_sqrt at ./none:1 [inlined]
 [3] verbose_fussy_sqrt(::Int64) at ./none:3
 [4] top-level scope
\end{minted}



\hypertarget{11842305126309838851}{}


\subsection{\texttt{try/catch} 语句}



通过 \texttt{try / catch} 语句，可以测试 Exception 并 优雅处理可能会破坏应用程序的事情。 例如， 在下面的代码中，平方根函数会引发异常。 通过 在其周围放置 \texttt{try / catch} 块可以缓解。 您可以选择如何 处理此异常，无论是记录它，返回占位符值还是 就像下面仅打印一句话。 要注意的是 在决定如何处理异常时，使用\texttt{try / catch} 块 比使用条件分支处理要慢得多。 以下是使用\texttt{try / catch} 块处理异常的更多示例：




\begin{minted}{jlcon}
julia> try
sqrt("ten")
catch e
println("You should have entered a numeric value")
end
You should have entered a numeric value
\end{minted}



\texttt{try/catch} 语句允许保存 \texttt{Exception} 到一个变量中。在下面这个做作的例子中，如果 \texttt{x} 是可索引的，则计算 \texttt{x} 的第二项的平方根，否则就假设 \texttt{x} 是一个实数，并返回它的平方根：




\begin{minted}{jlcon}
julia> sqrt_second(x) = try
           sqrt(x[2])
       catch y
           if isa(y, DomainError)
               sqrt(complex(x[2], 0))
           elseif isa(y, BoundsError)
               sqrt(x)
           end
       end
sqrt_second (generic function with 1 method)

julia> sqrt_second([1 4])
2.0

julia> sqrt_second([1 -4])
0.0 + 2.0im

julia> sqrt_second(9)
3.0

julia> sqrt_second(-9)
ERROR: DomainError with -9.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
[...]
\end{minted}



注意 \texttt{catch} 后面的字符会被一直认为是异常的名字，所以在写 \texttt{try/catch} 单行表达式时，需要特别小心。下面的代码\textbf{不会}在错误的情况下返回 \texttt{x} 的值：




\begin{minted}{julia}
try bad() catch x end
\end{minted}



正确的做法是在 \texttt{catch} 后添加一个分号或者直接换行：




\begin{minted}{julia}
try bad() catch; x end

try bad()
catch
    x
end
\end{minted}



\texttt{try/catch} 组件的强大之处在于能够将高度嵌套的计算立刻解耦成更高层次地调用函数。有时没有错误产生，但需要能够解耦堆栈，并传值到上层。Julia 提供了 \hyperlink{2102349972401293064}{\texttt{rethrow}}、\hyperlink{6187626674327343338}{\texttt{backtrace}}、\hyperlink{98342946516168163}{\texttt{catch\_backtrace}} 和 \hyperlink{5950075931444385711}{\texttt{Base.catch\_stack}} 函数进行更高级的错误处理。



\hypertarget{13560047635024894791}{}


\subsection{\texttt{finally} 子句}



在进行状态改变或者使用类似文件的资源的编程时，经常需要在代码结束的时候进行必要的清理工作（比如关闭文件）。由于异常会使得部分代码块在正常结束之前退出，所以可能会让上述工作变得复杂。\texttt{finally} 关键字提供了一种方式，无论代码块是如何退出的，都能够让代码块在退出时运行某段代码。



这里是一个确保一个打开的文件被关闭的例子：




\begin{minted}{julia}
f = open("file")
try
    # operate on file f
finally
    close(f)
end
\end{minted}



当控制流离开 \texttt{try} 代码块（例如，遇到 \texttt{return}，或者正常结束），\texttt{close(f)} 就会被执行。如果 \texttt{try} 代码块由于异常退出，这个异常会继续传递。\texttt{catch} 代码块可以和 \texttt{try} 还有 \texttt{finally} 配合使用。这时 \texttt{finally} 代码块会在 \texttt{catch} 处理错误之后才运行。



\hypertarget{15038256797533490288}{}


\section{\texttt{Task}（协程）}



Tasks are a control flow feature that allows computations to be suspended and resumed in a flexible manner. We mention them here only for completeness; for a full discussion see \href{@ref man-asynchronous}{Asynchronous Programming}.



\hypertarget{14993622729045334657}{}


\chapter{变量作用域}



The \emph{scope} of a variable is the region of code within which a variable is visible. Variable scoping helps avoid variable naming conflicts. The concept is intuitive: two functions can both have arguments called \texttt{x} without the two \texttt{x}{\textquotesingle}s referring to the same thing. Similarly, there are many other cases where different blocks of code can use the same name without referring to the same thing. The rules for when the same variable name does or doesn{\textquotesingle}t refer to the same thing are called scope rules; this section spells them out in detail.



Certain constructs in the language introduce \emph{scope blocks}, which are regions of code that are eligible to be the scope of some set of variables. The scope of a variable cannot be an arbitrary set of source lines; instead, it will always line up with one of these blocks. There are two main types of scopes in Julia, \emph{global scope} and \emph{local scope}. The latter can be nested. There is also a distinction in Julia between constructs which introduce a {\textquotedbl}hard scope{\textquotedbl} and those which only introduce a {\textquotedbl}soft scope{\textquotedbl}, which affects whether shadowing a global variable by the same name is allowed or not.



\hypertarget{10787034693073583413}{}


\subsection{作用域结构}



The constructs introducing scope blocks are:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|R|R|R|}
\hline
结构 & 作用域类型 & Allowed within \\
\hline
\hyperlink{16285380181904025577}{\texttt{module}}, \hyperlink{13329108222158426840}{\texttt{baremodule}} & 全局 & 全局 \\
\hline
\hyperlink{4119979838407461137}{\texttt{struct}} & local (soft) & 全局 \\
\hline
\hyperlink{9105224580875818383}{\texttt{for}}, \hyperlink{15133348314455964692}{\texttt{while}}, \hyperlink{16338536928035025961}{\texttt{try}} & local (soft) & 全局或局部 \\
\hline
\hyperlink{4625593635027008869}{\texttt{macro}} & local (hard) & 全局 \\
\hline
\hyperlink{4956741936243461891}{\texttt{let}}, functions, comprehensions, generators & local (hard) & 全局或局部 \\
\hline
\end{tabulary}

\end{table}



Notably missing from this table are \hyperlink{14178955634857450370}{begin blocks} and \hyperlink{14451148373001501733}{if blocks} which do \emph{not} introduce new scopes. The three types of scopes follow somewhat different rules which will be explained below.



Julia使用\href{https://en.wikipedia.org/wiki/Scope\_\%28computer\_science\%29\#Lexical\_scoping\_vs.\_dynamic\_scoping}{词法作用域}，也就是说一个函数的作用域不会从其调用者的作用域继承，而从函数定义处的作用域继承。举个例子，在下列的代码中\texttt{foo}中的\texttt{x}指向的是模块\texttt{Bar}的全局作用域中的\texttt{x}。




\begin{minted}{jlcon}
julia> module Bar
           x = 1
           foo() = x
       end;
\end{minted}



并且在\texttt{foo}被使用的地方\texttt{x}并不在作用域中：




\begin{minted}{jlcon}
julia> import .Bar

julia> x = -1;

julia> Bar.foo()
1
\end{minted}



Thus \emph{lexical scope} means that what a variable in a particular piece of code refers to can be deduced from the code in which it appears alone and does not depend on how the program executes. A scope nested inside another scope can {\textquotedbl}see{\textquotedbl} variables in all the outer scopes in which it is contained. Outer scopes, on the other hand, cannot see variables in inner scopes.



\hypertarget{4662569705122519760}{}


\section{全局作用域}



Each module introduces a new global scope, separate from the global scope of all other modules—there is no all-encompassing global scope. Modules can introduce variables of other modules into their scope through the \hyperlink{16725527896995457152}{using or import} statements or through qualified access using the dot-notation, i.e. each module is a so-called \emph{namespace} as well as a first-class data structure associating names with values. Note that while variable bindings can be read externally, they can only be changed within the module to which they belong. As an escape hatch, you can always evaluate code inside that module to modify a variable; this guarantees, in particular, that module bindings cannot be modified externally by code that never calls \texttt{eval}.




\begin{minted}{jlcon}
julia> module A
           a = 1 # a global in A's scope
       end;

julia> module B
           module C
               c = 2
           end
           b = C.c    # can access the namespace of a nested global scope
                      # through a qualified access
           import ..A # makes module A available
           d = A.a
       end;

julia> module D
           b = a # errors as D's global scope is separate from A's
       end;
ERROR: UndefVarError: a not defined

julia> module E
           import ..A # make module A available
           A.a = 2    # throws below error
       end;
ERROR: cannot assign variables in other modules
\end{minted}



注意交互式提示行（即REPL）是在模块\texttt{Main}的全局作用域中。



\hypertarget{8604224695833880734}{}


\section{局部作用域}



A new local scope is introduced by most code blocks (see above \hyperlink{8072811582823893323}{table} for a complete list). Some programming languages require explicitly declaring new variables before using them. Explicit declaration works in Julia too: in any local scope, writing \texttt{local x} declares a new local variable in that scope, regardless of whether there is already a variable named \texttt{x} in an outer scope or not. Declaring each new local like this is somewhat verbose and tedious, however, so Julia, like many other languages, considers assignment to a new variable in a local scope to implicitly declare that variable as a new local. Mostly this is pretty intuitive, but as with many things that behave intuitively, the details are more subtle than one might naïvely imagine.



When \texttt{x = <value>} occurs in a local scope, Julia applies the following rules to decide what the expression means based on where the assignment expression occurs and what \texttt{x} already refers to at that location:



\begin{itemize}
\item[1. ] \textbf{Existing local:} If \texttt{x} is \emph{already a local variable}, then the existing local \texttt{x} is assigned;


\item[2. ] \textbf{Hard scope:} If \texttt{x} is \emph{not already a local variable} and assignment occurs inside of any hard scope construct (i.e. within a let block, function or macro body, comprehension, or generator), a new local named \texttt{x} is created in the scope of the assignment;


\item[3. ] \textbf{Soft scope:} If \texttt{x} is \emph{not already a local variable} and all of the scope constructs containing the assignment are soft scopes (loops, \texttt{try}/\texttt{catch} blocks, or \texttt{struct} blocks), the behavior depends on whether the global variable \texttt{x} is defined:

\begin{itemize}
\item if global \texttt{x} is \emph{undefined}, a new local named \texttt{x} is created in the scope of the assignment;


\item if global \texttt{x} is \emph{defined}, the assignment is considered ambiguous:

\begin{itemize}
\item in \emph{non-interactive} contexts (files, eval), an ambiguity warning is printed and a new local is created;


\item in \emph{interactive} contexts (REPL, notebooks), the global variable \texttt{x} is assigned.

\end{itemize}
\end{itemize}
\end{itemize}


You may note that in non-interactive contexts the hard and soft scope behaviors are identical except that a warning is printed when an implicitly local variable (i.e. not declared with \texttt{local x}) shadows a global. In interactive contexts, the rules follow a more complex heuristic for the sake of convenience. This is covered in depth in examples that follow.



Now that you know the rules, let{\textquotesingle}s look at some examples. Each example is assumed to be evaluated in a fresh REPL session so that the only globals in each snippet are the ones that are assigned in that block of code.



We{\textquotesingle}ll begin with a nice and clear-cut situation—assignment inside of a hard scope, in this case a function body, when no local variable by that name already exists:




\begin{minted}{jlcon}
julia> function greet()
           x = "hello" # new local
           println(x)
       end
greet (generic function with 1 method)

julia> greet()
hello

julia> x # global
ERROR: UndefVarError: x not defined
\end{minted}



Inside of the \texttt{greet} function, the assignment \texttt{x = {\textquotedbl}hello{\textquotedbl}} causes \texttt{x} to be a new local variable in the function{\textquotesingle}s scope. There are two relevant facts: the assignment occurs in local scope and there is no existing local \texttt{x} variable. Since \texttt{x} is local, it doesn{\textquotesingle}t matter if there is a global named \texttt{x} or not. Here for example we define \texttt{x = 123} before defining and calling \texttt{greet}:




\begin{minted}{jlcon}
julia> x = 123 # global
123

julia> function greet()
           x = "hello" # new local
           println(x)
       end
greet (generic function with 1 method)

julia> greet()
hello

julia> x # global
123
\end{minted}



Since the \texttt{x} in \texttt{greet} is local, the value (or lack thereof) of the global \texttt{x} is unaffected by calling \texttt{greet}. The hard scope rule doesn{\textquotesingle}t care whether a global named \texttt{x} exists or not: assignment to \texttt{x} in a hard scope is local (unless \texttt{x} is declared global).



The next clear cut situation we{\textquotesingle}ll consider is when there is already a local variable named \texttt{x}, in which case \texttt{x = <value>} always assigns to this existing local \texttt{x}.  The function \texttt{sum\_to} computes the sum of the numbers from one up to \texttt{n}:




\begin{minted}{julia}
function sum_to(n)
    s = 0 # new local
    for i = 1:n
        s = s + i # assign existing local
    end
    return s # same local
end
\end{minted}



As in the previous example, the first assignment to \texttt{s} at the top of \texttt{sum\_to} causes \texttt{s} to be a new local variable in the body of the function. The \texttt{for} loop has its own inner local scope within the function scope. At the point where \texttt{s = s + i} occurs, \texttt{s} is already a local variable, so the assignment updates the existing \texttt{s} instead of creating a new local. We can test this out by calling \texttt{sum\_to} in the REPL:




\begin{minted}{jlcon}
julia> function sum_to(n)
           s = 0 # new local
           for i = 1:n
               s = s + i # assign existing local
           end
           return s # same local
       end
sum_to (generic function with 1 method)

julia> sum_to(10)
55

julia> s # global
ERROR: UndefVarError: s not defined
\end{minted}



Since \texttt{s} is local to the function \texttt{sum\_to}, calling the function has no effect on the global variable \texttt{s}. We can also see that the update \texttt{s = s + i} in the \texttt{for} loop must have updated the same \texttt{s} created by the initialization \texttt{s = 0} since we get the correct sum of 55 for the integers 1 through 10.



Let{\textquotesingle}s dig into the fact that the \texttt{for} loop body has its own scope for a second by writing a slightly more verbose variation which we{\textquotesingle}ll call \texttt{sum\_to′}, in which we save the sum \texttt{s + i} in a variable \texttt{t} before updating \texttt{s}:




\begin{minted}{jlcon}
julia> function sum_to′(n)
           s = 0 # new local
           for i = 1:n
               t = s + i # new local `t`
               s = t # assign existing local `s`
           end
           return s, @isdefined(t)
       end
sum_to′ (generic function with 1 method)

julia> sum_to′(10)
(55, false)
\end{minted}



This version returns \texttt{s} as before but it also uses the \texttt{@isdefined} macro to return a boolean indicating whether there is a local variable named \texttt{t} defined in the function{\textquotesingle}s outermost local scope. As you can see, there is no \texttt{t} defined outside of the \texttt{for} loop body. This is because of the hard scope rule again: since the assignment to \texttt{t} occurs inside of a function, which introduces a hard scope, the assignment causes \texttt{t} to become a new local variable in the local scope where it appears, i.e. inside of the loop body. Even if there were a global named \texttt{t}, it would make no difference—the hard scope rule isn{\textquotesingle}t affected by anything in global scope.



Let{\textquotesingle}s move onto some more ambiguous cases covered by the soft scope rule. We{\textquotesingle}ll explore this by extracting the bodies of the \texttt{greet} and \texttt{sum\_to′} functions into soft scope contexts. First, let{\textquotesingle}s put the body of \texttt{greet} in a \texttt{for} loop—which is soft, rather than hard—and evaluate it in the REPL:




\begin{minted}{jlcon}
julia> for i = 1:3
           x = "hello" # new local
           println(x)
       end
hello
hello
hello

julia> x
ERROR: UndefVarError: x not defined
\end{minted}



Since the global \texttt{x} is not defined when the \texttt{for} loop is evaluated, the first clause of the soft scope rule applies and \texttt{x} is created as local to the \texttt{for} loop and therefore global \texttt{x} remains undefined after the loop executes. Next, let{\textquotesingle}s consider the body of \texttt{sum\_to′} extracted into global scope, fixing its argument to \texttt{n = 10}




\begin{minted}{julia}
s = 0
for i = 1:10
    t = s + i
    s = t
end
s
@isdefined(t)
\end{minted}



What does this code do? Hint: it{\textquotesingle}s a trick question. The answer is {\textquotedbl}it depends.{\textquotedbl} If this code is entered interactively, it behaves the same way it does in a function body. But if the code appears in a file, it  prints an ambiguity warning and throws an undefined variable error. Let{\textquotesingle}s see it working in the REPL first:




\begin{minted}{jlcon}
julia> s = 0 # global
0

julia> for i = 1:10
           t = s + i # new local `t`
           s = t # assign global `s`
       end

julia> s # global
55

julia> @isdefined(t) # global
false
\end{minted}



The REPL approximates being in the body of a function by deciding whether assignment inside the loop assigns to a global or creates new local based on whether a global variable by that name is defined or not. If a global by the name exists, then the assignment updates it. If no global exists, then the assignment creates a new local variable. In this example we see both cases in action:



\begin{itemize}
\item There is no global named \texttt{t}, so \texttt{t = s + i} creates a new \texttt{t} that is local to the \texttt{for} loop;


\item There is a global named \texttt{s}, so \texttt{s = t} assigns to it.

\end{itemize}


The second fact is why execution of the loop changes the global value of \texttt{s} and the first fact is why \texttt{t} is still undefined after the loop executes. Now, let{\textquotesingle}s try evaluating this same code as though it were in a file instead:




\begin{minted}{jlcon}
julia> code = """
       s = 0 # global
       for i = 1:10
           t = s + i # new local `t`
           s = t # new local `s` with warning
       end
       s, # global
       @isdefined(t) # global
       """;

julia> include_string(Main, code)
┌ Warning: Assignment to `s` in soft scope is ambiguous because a global variable by the same name exists: `s` will be treated as a new local. Disambiguate by using `local s` to suppress this warning or `global s` to assign to the existing global variable.
└ @ string:4
ERROR: LoadError: UndefVarError: s not defined
\end{minted}



Here we use \hyperlink{2796348696499086186}{\texttt{include\_string}}, to evaluate \texttt{code} as though it were the contents of a file. We could also save \texttt{code} to a file and then call \texttt{include} on that file—the result would be the same. As you can see, this behaves quite different from evaluating the same code in the REPL. Let{\textquotesingle}s break down what{\textquotesingle}s happening here:



\begin{itemize}
\item global \texttt{s} is defined with the value \texttt{0} before the loop is evaluated


\item the assignment \texttt{s = t} occurs in a soft scope—a \texttt{for} loop outside of any function body or other hard scope construct


\item therefore the second clause of the soft scope rule applies, and the assignment is ambiguous so a warning is emitted


\item execution continues, making \texttt{s} local to the \texttt{for} loop body


\item since \texttt{s} is local to the \texttt{for} loop, it is undefined when \texttt{t = s + i} is evaluated, causing an error


\item evaluation stops there, but if it got to \texttt{s} and \texttt{@isdefined(t)}, it would return \texttt{0} and \texttt{false}.

\end{itemize}


This demonstrates some important aspects of scope: in a scope, each variable can only have one meaning, and that meaning is determined regardless of the order of expressions. The presence of the expression \texttt{s = t} in the loop causes \texttt{s} to be local to the loop, which means that it is also local when it appears on the right hand side of \texttt{t = s + i}, even though that expression appears first and is evaluated first. One might imagine that the \texttt{s} on the first line of the loop could be global while the \texttt{s} on the second line of the loop is local, but that{\textquotesingle}s not possible since the two lines are in the same scope block and each variable can only mean one thing in a given scope.



\hypertarget{1371816050938225763}{}


\subsubsection{On Soft Scope}



We have now covered all the local scope rules, but before wrapping up this section, perhaps a few words should be said about why the ambiguous soft scope case is handled differently in interactive and non-interactive contexts. There are two obvious questions one could ask:



\begin{itemize}
\item[1. ] Why doesn{\textquotesingle}t it just work like the REPL everywhere?


\item[2. ] Why doesn{\textquotesingle}t it just work like in files everywhere? And maybe skip the warning?

\end{itemize}


In Julia ≤ 0.6, all global scopes did work like the current REPL: when \texttt{x = <value>} occurred in a loop (or \texttt{try}/\texttt{catch}, or \texttt{struct} body) but outside of a function body (or \texttt{let} block or comprehension), it was decided based on whether a global named \texttt{x} was defined or not whether \texttt{x} should be local to the loop. This behavior has the advantage of being intuitive and convenient since it approximates the behavior inside of a function body as closely as possible. In particular, it makes it easy to move code back and forth between a function body and the REPL when trying to debug the behavior of a function. However, it has some downsides. First, it{\textquotesingle}s quite a complex behavior: many people over the years were confused about this behavior and complained that it was complicated and hard both to explain and understand. Fair point. Second, and arguably worse, is that it{\textquotesingle}s bad for programming {\textquotedbl}at scale.{\textquotedbl} When you see a small piece of code in one place like this, it{\textquotesingle}s quite clear what{\textquotesingle}s going on:




\begin{minted}{julia}
s = 0
for i = 1:10
    s += i
end
\end{minted}



Obviously the intention is to modify the existing global variable \texttt{s}. What else could it mean? However, not all real world code is so short or so clear. We found that code like the following often occurs in the wild:




\begin{minted}{julia}
x = 123

# much later
# maybe in a different file

for i = 1:10
    x = "hello"
    println(x)
end

# much later
# maybe in yet another file
# or maybe back in the first one where `x = 123`

y = x + 234
\end{minted}



It{\textquotesingle}s far less clear what should happen here. Since \texttt{x + {\textquotedbl}hello{\textquotedbl}} is a method error, it seems probable that the intention is for \texttt{x} to be local to the \texttt{for} loop. But runtime values and what methods happen to exist cannot be used to determine the scopes of variables. With the Julia ≤ 0.6 behavior, it{\textquotesingle}s especially concerning that someone might have written the \texttt{for} loop first, had it working just fine, but later when someone else adds a new global far away—possibly in a different file—the code suddenly changes meaning and either breaks noisily or, worse still, silently does the wrong thing. This kind of \href{https://en.wikipedia.org/wiki/Action\_at\_a\_distance\_(computer\_programming)}{{\textquotedbl}spooky action at a distance{\textquotedbl}} is something that good programming language designs should prevent.



So in Julia 1.0, we simplified the rules for scope: in any local scope, assignment to a name that wasn{\textquotesingle}t already a local variable created a new local variable. This eliminated the notion of soft scope entirely as well as removing the potential for spooky action. We uncovered and fixed a significant number of bugs due to the removal of soft scope, vindicating the choice to get rid of it. And there was much rejoicing! Well, no, not really. Because some people were angry that they now had to write:




\begin{minted}{julia}
s = 0
for i = 1:10
    global s += i
end
\end{minted}



Do you see that \texttt{global} annotation in there? Hideous. Obviously this situation could not be tolerated. But seriously, there are two main issues with requiring \texttt{global} for this kind of top-level code:



\begin{itemize}
\item[1. ] It{\textquotesingle}s no longer convenient to copy and paste the code from inside a function body into the REPL to debug it—you have to add \texttt{global} annotations and then remove them again to go back;


\item[2. ] Beginners will write this kind of code without the \texttt{global} and have no idea why their code doesn{\textquotesingle}t work—the error that they get is that \texttt{s} is undefined, which does not seem to enlighten anyone who happens to make this mistake.

\end{itemize}


As of Julia 1.5, this code works without the \texttt{global} annotation in interactive contexts like the REPL or Jupyter notebooks (just like Julia 0.6) and in files and other non-interactive contexts, it prints this very direct warning:



\begin{quote}
Assignment to \texttt{s} in soft scope is ambiguous because a global variable by the same name exists: \texttt{s} will be treated as a new local. Disambiguate by using \texttt{local s} to suppress this warning or \texttt{global s} to assign to the existing global variable.

\end{quote}


This addresses both issues while preserving the {\textquotedbl}programming at scale{\textquotedbl} benefits of the 1.0 behavior: global variables have no spooky effect on the meaning of code that may be far away; in the REPL copy-and-paste debugging works and beginners don{\textquotesingle}t have any issues; any time someone either forgets a \texttt{global} annotation or accidentally shadows an existing global with a local in a soft scope, which would be confusing anyway, they get a nice clear warning.



An important property of this design is that any code that executes in a file without a warning will behave the same way in a fresh REPL. And on the flip side, if you take a REPL session and save it to file, if it behaves differently than it did in the REPL, then you will get a warning.



\hypertarget{5946450612527580652}{}


\subsection{let块}



不像局部变量的赋值行为，\texttt{let}语句每次运行都新建一个新的变量绑定。赋值改变的是已存在值的位置，\texttt{let}会新建新的位置。这个区别通常都不重要，只会在通过闭包跳出作用域的变量的情况下能探测到。\texttt{let}语法接受由逗号隔开的一系列的赋值和变量名：




\begin{minted}{jlcon}
julia> x, y, z = -1, -1, -1;

julia> let x = 1, z
           println("x: $x, y: $y") # x is local variable, y the global
           println("z: $z") # errors as z has not been assigned yet but is local
       end
x: 1, y: -1
ERROR: UndefVarError: z not defined
\end{minted}



这个赋值会按顺序评估，在左边的新变量被引入之前右边的每隔两都会在作用域中被评估。所以编写像\texttt{let x = x}这样的东西是有意义的，因为两个\texttt{x}变量是不一样的，拥有不同的存储位置。这里有个例子，在例子中\texttt{let}的行为是必须的：




\begin{minted}{jlcon}
julia> Fs = Vector{Any}(undef, 2); i = 1;

julia> while i <= 2
           Fs[i] = ()->i
           global i += 1
       end

julia> Fs[1]()
3

julia> Fs[2]()
3
\end{minted}



这里我创建并存储了两个返回变量\texttt{i}的闭包。但是这两个始终是同一个变量\texttt{i}。所以这两个闭包行为是相同的。我们可以使用\texttt{let}来为\texttt{i}创建新的绑定：




\begin{minted}{jlcon}
julia> Fs = Vector{Any}(undef, 2); i = 1;

julia> while i <= 2
           let i = i
               Fs[i] = ()->i
           end
           global i += 1
       end

julia> Fs[1]()
1

julia> Fs[2]()
2
\end{minted}



因为 \texttt{begin} 结构不会引入新的作用域，使用没有参数的 \texttt{let} 来只引进一个新的作用域块而不创建新的绑定可能是有用的：




\begin{minted}{jlcon}
julia> let
           local x = 1
           let
               local x = 2
           end
           x
       end
1
\end{minted}



因为\texttt{let}引进了一个新的作用域块，内部的局部\texttt{x}与外部的局部\texttt{x}是不同的变量。



\hypertarget{17142085918864004510}{}


\subsection{Loops and Comprehensions}



In loops and \hyperlink{3967134426571365188}{comprehensions}, new variables introduced in their body scopes are freshly allocated for each loop iteration, as if the loop body were surrounded by a \texttt{let} block, as demonstrated by this example:




\begin{minted}{jlcon}
julia> Fs = Vector{Any}(undef, 2);

julia> for j = 1:2
           Fs[j] = ()->j
       end

julia> Fs[1]()
1

julia> Fs[2]()
2
\end{minted}



\texttt{for}循环或者推导式的迭代变量始终是个新的变量：




\begin{lstlisting}
julia> function f()
           i = 0
           for i = 1:3
               # empty
           end
           return i
       end;

julia> f()
0
\end{lstlisting}



However, it is occasionally useful to reuse an existing local variable as the iteration variable. This can be done conveniently by adding the keyword \texttt{outer}:




\begin{minted}{jlcon}
julia> function f()
           i = 0
           for outer i = 1:3
               # empty
           end
           return i
       end;

julia> f()
3
\end{minted}



\hypertarget{5407065244463689569}{}


\section{常量}



变量的经常的一个使用方式是给一个特定的不变的值一个名字。这样的变量只会被赋值一次。这个想法可以通过使用 \hyperlink{8421885763632484758}{\texttt{const}} 关键字传递给编译器：




\begin{minted}{jlcon}
julia> const e  = 2.71828182845904523536;

julia> const pi = 3.14159265358979323846;
\end{minted}



多个变量可以使用单个\texttt{const}语句进行声明：




\begin{minted}{jlcon}
julia> const a, b = 1, 2
(1, 2)
\end{minted}



\texttt{const}声明只应该在全局作用域中对全局变量使用。编译器很难为包含全局变量的代码优化，因为它们的值（甚至它们的类型）可以任何时候改变。如果一个全局变量不会改变，添加\texttt{const}声明会解决这个问题。



局部常量却大有不同。编译器能够自动确定一个局部变量什么时候是不变的，所以局部常量声明是不必要的，其实现在也并不支持。



特别的顶层赋值，比如使用\texttt{function}和\texttt{structure}关键字进行的，默认是不变的。



注意 \texttt{const} 只会影响变量绑定；变量可能会绑定到一个可变的对象上（比如一个数组）使得其仍然能被改变。另外当尝试给一个声明为常量的变量赋值时下列情景是可能的：



\begin{itemize}
\item 如果一个新值的类型与常量类型不一样时会扔出一个错误：

\end{itemize}



\begin{minted}{jlcon}
julia> const x = 1.0
1.0

julia> x = 1
ERROR: invalid redefinition of constant x
\end{minted}



\begin{itemize}
\item if a new value has the same type as the constant then a warning is printed:

\end{itemize}



\begin{minted}{jlcon}
julia> const y = 1.0
1.0

julia> y = 2.0
WARNING: redefinition of constant y. This may fail, cause incorrect answers, or produce other errors.
2.0
\end{minted}



\begin{itemize}
\item 如果赋值不会导致变量值的变化，不会给出任何信息：

\end{itemize}



\begin{minted}{jlcon}
julia> const z = 100
100

julia> z = 100
100
\end{minted}



最后一条规则适用于不可变对象，即使变量绑定会改变，例如：




\begin{minted}{jlcon}
julia> const s1 = "1"
"1"

julia> s2 = "1"
"1"

julia> pointer.([s1, s2], 1)
2-element Array{Ptr{UInt8},1}:
 Ptr{UInt8} @0x00000000132c9638
 Ptr{UInt8} @0x0000000013dd3d18

julia> s1 = s2
"1"

julia> pointer.([s1, s2], 1)
2-element Array{Ptr{UInt8},1}:
 Ptr{UInt8} @0x0000000013dd3d18
 Ptr{UInt8} @0x0000000013dd3d18
\end{minted}



但是对于可变对象，警告会如预期出现：




\begin{minted}{jlcon}
julia> const a = [1]
1-element Array{Int64,1}:
 1

julia> a = [1]
WARNING: redefinition of constant a. This may fail, cause incorrect answers, or produce other errors.
1-element Array{Int64,1}:
 1
\end{minted}



Note that although sometimes possible, changing the value of a \texttt{const} variable is strongly discouraged, and is intended only for convenience during interactive use. Changing constants can cause various problems or unexpected behaviors. For instance, if a method references a constant and is already compiled before the constant is changed, then it might keep using the old value:




\begin{minted}{jlcon}
julia> const x = 1
1

julia> f() = x
f (generic function with 1 method)

julia> f()
1

julia> x = 2
WARNING: redefinition of constant x. This may fail, cause incorrect answers, or produce other errors.
2

julia> f()
1
\end{minted}



\hypertarget{2141690262982725665}{}


\chapter{类型}



通常，我们把程序语言中的类型系统划分成两类：静态类型和动态类型。对于静态类型系统，在程序运行之前，我们就可计算每一个表达式的类型。而对于动态类型系统，我们只有通过运行那个程序，得到表达式具体的值，才能确定其具体的类型。通过让编写的代码无需在编译时知道值的确切类型，面向对象允许静态类型语言具有一定的灵活性。可以编写在不同类型上都能运行的代码的能力被称为多态。在经典的动态类型语言中，所有的代码都是多态的，这意味着这些代码对于其中值的类型没有约束，除非在代码中去具体的判断一个值的类型，或者对对象做一些它不支持的操作。



Julia 类型系统是动态的，但通过允许指出某些变量具有特定类型，获得了静态类型系统的一些优点。这对于生成高效的代码非常有帮助，但更重要的是，它允许针对函数参数类型的方法派发与语言深度集成。方法派发将在\hyperlink{3842379394166369470}{方法}中详细探讨，但它根植于此处提供的类型系统。



在类型被省略时，Julia 的默认行为是允许变量为任何类型。因此，可以编写许多有用的 Julia 函数，而无需显式使用类型。然而，当需要额外的表达力时，很容易逐渐将显式的类型注释引入先前的「无类型」代码中。添加类型注释主要有三个目的：利用 Julia 强大的多重派发机制、提高代码可读性以及捕获程序错误。



Julia 用\href{https://en.wikipedia.org/wiki/Type\_system}{类型系统}的术语描述是动态（dynamic）、主格（nominative）和参数（parametric）的。泛型可以被参数化，并且类型之间的层次关系可以被\href{https://en.wikipedia.org/wiki/Nominal\_type\_system}{显式地声明}，而不是\href{https://en.wikipedia.org/wiki/Structural\_type\_system}{隐含地通过兼容的结构}。Julia 类型系统的一个特别显著的特征是具体类型相互之间不能是子类型：所有具体类型都是最终的类型，并且只有抽象类型可以作为其超类型。虽然起初看起来这可能过于严格，但它有许多有益的结果，但缺点却少得出奇。事实证明，能够继承行为比继承结构更重要，同时继承两者在传统的面向对象语言中导致了重大困难。Julia 类型系统的其它高级方面应当在先言明：



\begin{itemize}
\item 对象值和非对象值之间没有分别：Julia 中的所有值都是具有类型的真实对象其类型属于一个单独的、完全连通的类型图，该类型图的所有节点作为类型一样都是头等的。


\item 「编译期类型」是没有任何意义的概念：变量所具有的唯一类型是程序运行时的实际类型。这在面向对象被称为「运行时类型」，其中静态编译和多态的组合使得这种区别变得显著。


\item 值有类型，变量没有类型——变量仅仅是绑定给值的名字而已。


\item 抽象类型和具体类型都可以通过其它类型进行参数化。它们的参数化还可通过符号、使得 \hyperlink{12980593021531333073}{\texttt{isbits}} 返回 true 的任意类型的值（实质上，也就是像数字或布尔变量这样的东西，存储方式像 C 类型或不包含指向其它对象的指针的 \texttt{struct}）和其元组。类型参数在不需要被引用或限制时可以省略。

\end{itemize}


Julia 的类型系统设计得强大而富有表现力，却清晰、直观且不引人注目。许多 Julia 程序员可能从未感觉需要编写明确使用类型的代码。但是，某些场景的编程可通过声明类型变得更加清晰、简单、快速和健壮。



\hypertarget{11271598028486730305}{}


\section{类型声明}



\texttt{::} 运算符可以用来在程序中给表达式和变量附加类型注释。这有两个主要原因：



\begin{itemize}
\item[1. ] 作为断言，帮助程序确认能是否正常运行，


\item[2. ] 给编译器提供额外的类型信息，这可能帮助程序提升性能，在某些情况下

\end{itemize}


当被附加到一个计算值的表达式时，\texttt{::} 操作符读作「是······的实例」。在任何地方都可以用它来断言左侧表达式的值是右侧类型的实例。当右侧类型是具体类型时，左侧的值必须能够以该类型作为其实现——回想一下，所有具体类型都是最终的，因此没有任何实现是任何其它具体类型的子类型。当右侧类型是抽象类型时，值是由该抽象类型子类型中的某个具体类型实现的才能满足该断言。如果类型断言非真，抛出一个异常，否则返回左侧的值：




\begin{minted}{jlcon}
julia> (1+2)::AbstractFloat
ERROR: TypeError: in typeassert, expected AbstractFloat, got a value of type Int64

julia> (1+2)::Int
3
\end{minted}



可以在任何表达式的所在位置做类型断言。



当被附加到赋值左侧的变量或作为 \texttt{local} 声明的一部分时，\texttt{::} 操作符的意义有所不同：它声明变量始终具有指定的类型，就像静态类型语言（如 C）中的类型声明。每个被赋给该变量的值都将使用 \hyperlink{1846942650946171605}{\texttt{convert}} 转换为被声明的类型：




\begin{minted}{jlcon}
julia> function foo()
           x::Int8 = 100
           x
       end
foo (generic function with 1 method)

julia> foo()
100

julia> typeof(ans)
Int8
\end{minted}



这个特性用于避免性能「陷阱」，即给一个变量赋值时意外更改了类型。



此「声明」行为仅发生在特定上下文中：




\begin{minted}{julia}
local x::Int8  # in a local declaration
x::Int8 = 10   # as the left-hand side of an assignment
\end{minted}



并应用于整个当前作用域，甚至在该声明之前。目前，类型声明不能在全局作用域中使用，例如在 REPL 中就不可以，因为 Julia 还没有常量类型的全局变量。



声明也可以附加到函数定义：




\begin{minted}{julia}
function sinc(x)::Float64
    if x == 0
        return 1
    end
    return sin(pi*x)/(pi*x)
end
\end{minted}



此函数的返回值就像赋值给了一个类型已被声明的变量：返回值始终转换为\texttt{Float64}。



\hypertarget{5929227155379782502}{}


\section{Abstract Types}



抽象类型不能实例化，只能作为类型图中的节点使用，从而描述由相关具体类型组成的集合：那些作为其后代的具体类型。我们从抽象类型开始，即使它们没有实例，因为它们是类型系统的主干：它们形成了概念的层次结构，这使得 Julia 的类型系统不只是对象实现的集合。



回想一下，在\hyperlink{8249022581856827126}{整数和浮点数}中，我们介绍了各种数值的具体类型：\hyperlink{5857518405103968275}{\texttt{Int8}}、\hyperlink{6609065134969660118}{\texttt{UInt8}}、\hyperlink{6667287249103968645}{\texttt{Int16}}、\hyperlink{7018610346698168012}{\texttt{UInt16}}、\hyperlink{10103694114785108551}{\texttt{Int32}}、\hyperlink{8690996847580776341}{\texttt{UInt32}}、\hyperlink{7720564657383125058}{\texttt{Int64}}、\hyperlink{5500998675195555601}{\texttt{UInt64}}、\hyperlink{8012327724714767060}{\texttt{Int128}}、\hyperlink{14811222188335428522}{\texttt{UInt128}}、\hyperlink{2727296760866702904}{\texttt{Float16}}、\hyperlink{8101639384272933082}{\texttt{Float32}} 和 \hyperlink{5027751419500983000}{\texttt{Float64}}。尽管 \texttt{Int8}、\texttt{Int16}、\texttt{Int32}、\texttt{Int64} 和 \texttt{Int128} 具有不同的表示大小，但都具有共同的特征，即它们都是带符号的整数类型。类似地，\texttt{UInt8}、\texttt{UInt16}、\texttt{UInt32}、\texttt{UInt64} 和 \texttt{UInt128} 都是无符号整数类型，而 \texttt{Float16}、\texttt{Float32} 和 \texttt{Float64} 是不同的浮点数类型而非整数类型。一段代码只对某些类型有意义是很常见的，比如，只在其参数是某种类型的整数，而不真正取决于特定\emph{类型}的整数时有意义。例如，最大公分母算法适用于所有类型的整数，但不适用于浮点数。抽象类型允许构造类型的层次结构，提供了具体类型可以适应的上下文。例如，这允许你轻松地为任何类型的整数编程，而不用将算法限制为某种特殊类型的整数。



使用 \hyperlink{12403756508738429935}{\texttt{abstract type}} 关键字来声明抽象类型。声明抽象类型的一般语法是：




\begin{lstlisting}
abstract type «name» end
abstract type «name» <: «supertype» end
\end{lstlisting}



该 \texttt{abstract type} 关键字引入了一个新的抽象类型，\texttt{«name»} 为其名称。此名称后面可以跟 \hyperlink{6254591906563366276}{\texttt{<:}} 和一个已存在的类型，表示新声明的抽象类型是此「父」类型的子类型。



如果没有给出超类型，则默认超类型为 \texttt{Any}——一个预定义的抽象类型，所有对象都是它的实例并且所有类型都是它的子类型。在类型理论中，\texttt{Any} 通常称为「top」，因为它位于类型图的顶点。Julia 还有一个预定义的抽象「bottom」类型，在类型图的最低点，写成 \texttt{Union\{\}}。这与 \texttt{Any} 完全相反：任何对象都不是 \texttt{Union\{\}} 的实例，所有的类型都是 \texttt{Union\{\}} 的超类型。



让我们考虑一些构成 Julia 数值类型层次结构的抽象类型：




\begin{minted}{julia}
abstract type Number end
abstract type Real     <: Number end
abstract type AbstractFloat <: Real end
abstract type Integer  <: Real end
abstract type Signed   <: Integer end
abstract type Unsigned <: Integer end
\end{minted}



\hyperlink{1990584313715697055}{\texttt{Number}} 类型为 \texttt{Any} 类型的直接子类型，并且 \hyperlink{6175959395021454412}{\texttt{Real}} 为它的子类型。反过来，\texttt{Real} 有两个子类型（它还有更多的子类型，但这里只展示了两个，稍后将会看到其它的子类型）： \hyperlink{8469131683393450448}{\texttt{Integer}} 和 \hyperlink{11465394427882483091}{\texttt{AbstractFloat}}，将世界分为整数的表示和实数的表示。实数的表示当然包括浮点类型，但也包括其他类型，例如有理数。因此，\texttt{AbstractFloat} 是一个 \texttt{Real} 的子类型，仅包括实数的浮点表示。整数被进一步细分为 \hyperlink{14154866400772377486}{\texttt{Signed}} 和 \hyperlink{4780971278803506664}{\texttt{Unsigned}} 两类。



\texttt{<:} 运算符的通常意义为「是······的子类型」，并被用于像这样的声明右侧类型是新声明类型的直接超类型。它也可以在表达式中用作子类型运算符，在其左操作数为其右操作数的子类型时返回 \texttt{true}：




\begin{minted}{jlcon}
julia> Integer <: Number
true

julia> Integer <: AbstractFloat
false
\end{minted}



抽象类型的一个重要用途是为具体类型提供默认实现。举个简单的例子，考虑：




\begin{minted}{julia}
function myplus(x,y)
    x+y
end
\end{minted}



首先需要注意的是上述的参数声明等价于 \texttt{x::Any} 和 \texttt{y::Any}。当函数被调用时，例如 \texttt{myplus(2,5)}，派发器会选择与给定参数相匹配的名称为 \texttt{myplus} 的最具体方法。（有关多重派发的更多信息，请参阅\hyperlink{3842379394166369470}{方法}。）



假设没有找到比上述方法更具体的方法，Julia 接下来会在内部定义并编译一个名为 \texttt{myplus} 的方法，专门用于基于上面给出的泛型函数的两个 \texttt{Int} 参数，即它定义并编译：




\begin{minted}{julia}
function myplus(x::Int,y::Int)
    x+y
end
\end{minted}



最后，调用这个具体的方法。



因此，抽象类型允许程序员编写泛型函数，之后可以通过许多具体类型的组合将其用作默认方法。多亏了多重分派，程序员可以完全控制是使用默认方法还是更具体的方法。



An important point to note is that there is no loss in performance if the programmer relies on a function whose arguments are abstract types, because it is recompiled for each tuple of argument concrete types with which it is invoked. (There may be a performance issue, however, in the case of function arguments that are containers of abstract types; see \hyperlink{16419743784254835624}{Performance Tips}.)



\hypertarget{7048513132833584013}{}


\section{原始类型}



\begin{quote}
\textbf{Warning}

\end{quote}


It is almost always preferable to wrap an existing primitive type in a new   composite type than to define your own primitive type.



This functionality exists to allow Julia to bootstrap the standard primitive   types that LLVM supports. Once they are defined, there is very little reason   to define more.



原始类型是具体类型，其数据是由简单的位组成。原始类型的经典示例是整数和浮点数。与大多数语言不同，Julia 允许你声明自己的原始类型，而不是只提供一组固定的内置原始类型。实际上，标准原始类型都是在语言本身中定义的：




\begin{minted}{julia}
primitive type Float16 <: AbstractFloat 16 end
primitive type Float32 <: AbstractFloat 32 end
primitive type Float64 <: AbstractFloat 64 end

primitive type Bool <: Integer 8 end
primitive type Char <: AbstractChar 32 end

primitive type Int8    <: Signed   8 end
primitive type UInt8   <: Unsigned 8 end
primitive type Int16   <: Signed   16 end
primitive type UInt16  <: Unsigned 16 end
primitive type Int32   <: Signed   32 end
primitive type UInt32  <: Unsigned 32 end
primitive type Int64   <: Signed   64 end
primitive type UInt64  <: Unsigned 64 end
primitive type Int128  <: Signed   128 end
primitive type UInt128 <: Unsigned 128 end
\end{minted}



声明原始类型的一般语法是：




\begin{lstlisting}
primitive type «name» «bits» end
primitive type «name» <: «supertype» «bits» end
\end{lstlisting}



The number of bits indicates how much storage the type requires and the name gives the new type a name. A primitive type can optionally be declared to be a subtype of some supertype. If a supertype is omitted, then the type defaults to having \texttt{Any} as its immediate supertype. The declaration of \hyperlink{46725311238864537}{\texttt{Bool}} above therefore means that a boolean value takes eight bits to store, and has \hyperlink{8469131683393450448}{\texttt{Integer}} as its immediate supertype. Currently, only sizes that are multiples of 8 bits are supported and you are likely to experience LLVM bugs with sizes other than those used above. Therefore, boolean values, although they really need just a single bit, cannot be declared to be any smaller than eight bits.



\hyperlink{46725311238864537}{\texttt{Bool}}，\hyperlink{5857518405103968275}{\texttt{Int8}} 和 \hyperlink{6609065134969660118}{\texttt{UInt8}} 类型都具有相同的表现形式：它们都是 8 位内存块。然而，由于 Julia 的类型系统是主格的，它们尽管具有相同的结构，但不是通用的。它们之间的一个根本区别是它们具有不同的超类型：\hyperlink{46725311238864537}{\texttt{Bool}} 的直接超类型是 \hyperlink{8469131683393450448}{\texttt{Integer}}、\hyperlink{5857518405103968275}{\texttt{Int8}} 的是 \hyperlink{14154866400772377486}{\texttt{Signed}} 而 \hyperlink{6609065134969660118}{\texttt{UInt8}} 的是 \hyperlink{4780971278803506664}{\texttt{Unsigned}}。\hyperlink{46725311238864537}{\texttt{Bool}}，\hyperlink{5857518405103968275}{\texttt{Int8}} 和 \hyperlink{6609065134969660118}{\texttt{UInt8}} 的所有其它差异是行为上的——定义函数的方式在这些类型的对象作为参数给定时起作用。这也是为什么主格的类型系统是必须的：如果结构确定类型，类型决定行为，就不可能使 \hyperlink{46725311238864537}{\texttt{Bool}} 的行为与 \hyperlink{5857518405103968275}{\texttt{Int8}} 或 \hyperlink{6609065134969660118}{\texttt{UInt8}} 有任何不同。



\hypertarget{805665046800217201}{}


\section{复合类型}



\href{https://en.wikipedia.org/wiki/Composite\_data\_type}{复合类型}在各种语言中被称为 record、struct 和 object。复合类型是命名字段的集合，其实例可以视为单个值。复合类型在许多语言中是唯一一种用户可定义的类型，也是 Julia 中最常用的用户定义类型。



在主流的面向对象语言中，比如 C++、Java、Python 和 Ruby，复合类型也具有与它们相关的命名函数，并且该组合称为「对象」。在纯粹的面向对象语言中，例如 Ruby 或 Smalltalk，所有值都是对象，无论它们是否为复合类型。在不太纯粹的面向对象语言中，包括 C++ 和 Java，一些值，比如整数和浮点值，不是对象，而用户定义的复合类型是具有相关方法的真实对象。在 Julia 中，所有值都是对象，但函数不与它们操作的对象捆绑在一起。这是必要的，因为 Julia 通过多重派发选择函数使用的方法，这意味着在选择方法时考虑\emph{所有}函数参数的类型，而不仅仅是第一个（有关方法和派发的更多信息，请参阅\hyperlink{3842379394166369470}{方法}）。因此，函数仅仅「属于」它们的第一个参数是不合适的。将方法组织到函数对象中而不是在每个对象「内部」命名方法最终成为语言设计中一个非常有益的方面。



\hyperlink{4119979838407461137}{\texttt{struct}} 关键字与复合类型一起引入，后跟一个字段名称的块，可选择使用 \texttt{::} 运算符注释类型：




\begin{minted}{jlcon}
julia> struct Foo
           bar
           baz::Int
           qux::Float64
       end
\end{minted}



没有类型注释的字段默认为 \texttt{Any} 类型，所以可以包含任何类型的值。



类型为 \texttt{Foo} 的新对象通过将 \texttt{Foo} 类型对象像函数一样应用于其字段的值来创建：




\begin{minted}{jlcon}
julia> foo = Foo("Hello, world.", 23, 1.5)
Foo("Hello, world.", 23, 1.5)

julia> typeof(foo)
Foo
\end{minted}



当像函数一样使用类型时，它被称为\emph{构造函数}。有两个构造函数会被自动生成（这些构造函数称为\emph{默认构造函数}）。一个接受任何参数并通过调用 \hyperlink{1846942650946171605}{\texttt{convert}} 函数将它们转换为字段的类型，另一个接受与字段类型完全匹配的参数。两者都生成的原因是，这使得更容易添加新定义而不会在无意中替换默认构造函数。



由于 \texttt{bar} 字段在类型上不受限制，因此任何值都可以。但是 \texttt{baz} 的值必须可转换为 \texttt{Int} 类型：




\begin{minted}{jlcon}
julia> Foo((), 23.5, 1)
ERROR: InexactError: Int64(23.5)
Stacktrace:
[...]
\end{minted}



可以使用 \hyperlink{17481253338332315021}{\texttt{fieldnames}} 函数找到字段名称列表。




\begin{minted}{jlcon}
julia> fieldnames(Foo)
(:bar, :baz, :qux)
\end{minted}



可以使用传统的 \texttt{foo.bar} 表示法访问复合对象的字段值：




\begin{minted}{jlcon}
julia> foo.bar
"Hello, world."

julia> foo.baz
23

julia> foo.qux
1.5
\end{minted}



使用 \texttt{struct} 声明的对象都是\emph{不可变的}，它们在构造后无法修改。一开始看来这很奇怪，但它有几个优点：



\begin{itemize}
\item 它可以更高效。某些 struct 可以被高效地打包到数组中，并且在某些情况下，编译器可以避免完全分配不可变对象。


\item 不可能违反由类型的构造函数提供的不变性。


\item 使用不可变对象的代码更容易推理。

\end{itemize}


不可变对象可以包含可变对象（比如数组）作为字段。那些被包含的对象将保持可变；只是不可变对象本身的字段不能更改为指向不同的对象。



如果需要，可以使用关键字 \hyperlink{15383430693516362700}{\texttt{mutable struct}} 声明可变复合对象，这将在下一节中讨论



没有字段的不可变复合类型是单态类型；这种类型只能有一个实例：




\begin{minted}{jlcon}
julia> struct NoFields
       end

julia> NoFields() === NoFields()
true
\end{minted}



\hyperlink{7974744969331231272}{\texttt{===}} 函数用来确认构造出来的「两个」\texttt{NoFields} 实例实际上是同一个。单态类型将在\hyperlink{14008188290941962431}{下面}进一步详细描述。



关于如何构造复合类型的实例还有很多要说的，但这种讨论依赖于\hyperlink{5603543911318150609}{参数类型}和\hyperlink{3842379394166369470}{方法}，并且这是非常重要的，应该在专门的章节中讨论：\hyperlink{1489967485005487723}{构造函数}。



\hypertarget{17783679803569553227}{}


\section{可变复合类型}



如果使用 \texttt{mutable struct} 而不是 \texttt{struct} 声明复合类型，则它的实例可以被修改：




\begin{minted}{jlcon}
julia> mutable struct Bar
           baz
           qux::Float64
       end

julia> bar = Bar("Hello", 1.5);

julia> bar.qux = 2.0
2.0

julia> bar.baz = 1//2
1//2
\end{minted}



为了支持修改，这种对象通常分配在堆上，并且具有稳定的内存地址。可变对象就像一个小容器，随着时间的推移，可能保持不同的值，因此只能通过其地址可靠地识别。相反地，不可变类型的实例与特定字段值相关——仅字段值就告诉你该对象的所有内容。在决定是否使类型为可变类型时，请询问具有相同字段值的两个实例是否被视为相同，或者它们是否可能需要随时间独立更改。如果它们被认为是相同的，该类型就应该是不可变的。



总结一下，Julia 的两个基本属性定义了不变性：



\begin{itemize}
\item 不允许修改不可变类型的值。

\begin{itemize}
\item 对于位类型，这意味着值的位模式一旦设置将不再改变，并且该值是位类型的标识。


\item 对于复合类型，这意味着其字段值的标识将不再改变。当字段是位类型时，这意味着它们的位将不再改变，对于其值是可变类型（如数组）的字段，这意味着字段将始终引用相同的可变值，尽管该可变值的内容本身可能被修改。

\end{itemize}

\item 具有不可变类型的对象可以被编译器自由复制，因为其不可变性使得不可能以编程方式区分原始对象和副本。

\begin{itemize}
\item 特别地，这意味着足够小的不可变值（如整数和浮点数）通常在寄存器（或栈分配）中传递给函数。


\item 另一方面，可变值是堆分配的，并作为指向堆分配值的指针传递给函数，除非编译器确定没有办法知道这不是正在发生的事情。

\end{itemize}
\end{itemize}


\hypertarget{11930598139930328403}{}


\section{已声明的类型}



前面章节中讨论的三种类型（抽象、原始、复合）实际上都是密切相关的。它们共有相同的关键属性：



\begin{itemize}
\item 它们都是显式声明的。


\item 它们都具有名称。


\item 它们都已经显式声明超类型。


\item 它们可以有参数。

\end{itemize}


由于这些共有属性，它们在内部表现为相同概念 \texttt{DataType} 的实例，其是任何这些类型的类型：




\begin{minted}{jlcon}
julia> typeof(Real)
DataType

julia> typeof(Int)
DataType
\end{minted}



\texttt{DataType} 可以是抽象的或具体的。它如果是具体的，就具有指定的大小、存储布局和字段名称（可选）。因此，原始类型是具有非零大小的 \texttt{DataType}，但没有字段名称。复合类型是具有字段名称或者为空（大小为零）的 \texttt{DataType}。



每一个具体的值在系统里都是某个 \texttt{DataType} 的实例。



\hypertarget{5785180493438363730}{}


\section{类型共用体}



类型共用体是一种特殊的抽象类型，它包含作为对象的任何参数类型的所有实例，使用特殊\hyperlink{5087820771052303592}{\texttt{Union}}关键字构造：




\begin{minted}{jlcon}
julia> IntOrString = Union{Int,AbstractString}
Union{Int64, AbstractString}

julia> 1 :: IntOrString
1

julia> "Hello!" :: IntOrString
"Hello!"

julia> 1.0 :: IntOrString
ERROR: TypeError: in typeassert, expected Union{Int64, AbstractString}, got a value of type Float64
\end{minted}



许多语言都有内建的共用体结构来推导类型；Julia 简单地将它暴露给程序员。Julia 编译器能在 \texttt{Union} 类型只具有少量类型\footnotemark[1]的情况下生成高效的代码，方法是为每个可能类型的不同分支都生成专用代码。



\texttt{Union} 类型的一种特别有用的情况是 \texttt{Union\{T, Nothing\}}，其中 \texttt{T} 可以是任何类型，\hyperlink{13508459519898889544}{\texttt{Nothing}} 是单态类型，其唯一实例是对象 \hyperlink{9331422207248206047}{\texttt{nothing}}。此模式是其它语言中 \href{https://en.wikipedia.org/wiki/Nullable\_type}{\texttt{Nullable}、\texttt{Option} 或 \texttt{Maybe}} 类型在 Julia 的等价。通过将函数参数或字段声明为 \texttt{Union\{T, Nothing\}}，可以将其设置为类型为 \texttt{T} 的值，或者 \texttt{nothing} 来表示没有值。有关详细信息，请参阅\hyperlink{11397816795210039176}{常见问题的此条目}。



\hypertarget{8667374522381748142}{}


\section{参数类型}



Julia 类型系统的一个重要和强大的特征是它是参数的：类型可以接受参数，因此类型声明实际上引入了一整套新类型——每一个参数值的可能组合引入一个新类型。许多语言支持某种版本的\href{https://en.wikipedia.org/wiki/Generic\_programming}{泛型编程}，其中，可以指定操作泛型的数据结构和算法，而无需指定所涉及的确切类型。例如，某些形式的泛型编程存在于 ML、Haskell、Ada、Eiffel、C++、Java、C\#、F\#、和 Scala 中，这只是其中的一些例子。这些语言中的一些支持真正的参数多态（例如 ML、Haskell、Scala），而其它语言基于模板的泛型编程风格（例如 C++、Java）。由于在不同语言中有多种不同种类的泛型编程和参数类型，我们甚至不会尝试将 Julia 的参数类型与其它语言的进行比较，而是专注于解释 Julia 系统本身。然而，我们将注意到，因为 Julia 是动态类型语言并且不需要在编译时做出所有类型决定，所以许多在静态参数类型系统中遇到的传统困难可以被相对容易地处理。



所有已声明的类型（\texttt{DataType} 类型）都可被参数化，在每种情况下都使用一样的语法。我们将按一下顺序讨论它们：首先是参数复合类型，接着是参数抽象类型，最后是参数原始类型。



\hypertarget{4169334510369531373}{}


\subsection{参数复合类型}



类型参数在类型名称后引入，用大括号扩起来：




\begin{minted}{jlcon}
julia> struct Point{T}
           x::T
           y::T
       end
\end{minted}



此声明定义了一个新的参数类型，\texttt{Point\{T\}}，拥有类型为 \texttt{T} 的两个「坐标」。有人可能会问 \texttt{T} 是什么？嗯，这恰恰是参数类型的重点：它可以是任何类型（或者任何位类型值，虽然它实际上在这里显然用作类型）。\texttt{Point\{Float64\}} 是一个具体类型，该类型等价于通过用 \hyperlink{5027751419500983000}{\texttt{Float64}} 替换 \texttt{Point} 的定义中的 \texttt{T} 所定义的类型。因此，单独这一个声明实际上声明了无限个类型：\texttt{Point\{Float64\}}，\texttt{Point\{AbstractString\}}，\texttt{Point\{Int64\}}，等等。这些类型中的每一个类型现在都是可用的具体类型：




\begin{minted}{jlcon}
julia> Point{Float64}
Point{Float64}

julia> Point{AbstractString}
Point{AbstractString}
\end{minted}



\texttt{Point\{Float64\}} 类型是坐标为 64 位浮点值的点，而 \texttt{Point\{AbstractString\}} 类型是「坐标」为字符串对象（请参阅 \href{@id man-strings}{Strings}）的「点」。



\texttt{Point} 本身也是一个有效的类型对象，包括所有实例 \texttt{Point\{Float64\}}、\texttt{Point\{AbstractString\}} 等作为子类型：




\begin{minted}{jlcon}
julia> Point{Float64} <: Point
true

julia> Point{AbstractString} <: Point
true
\end{minted}



当然，其他类型不是它的子类型：




\begin{minted}{jlcon}
julia> Float64 <: Point
false

julia> AbstractString <: Point
false
\end{minted}



\texttt{Point} 不同 \texttt{T} 值所声明的具体类型之间，不能互相作为子类型：




\begin{minted}{jlcon}
julia> Point{Float64} <: Point{Int64}
false

julia> Point{Float64} <: Point{Real}
false
\end{minted}



\begin{quote}
\textbf{Warning}

最后一点\emph{非常}重要：即使 \texttt{Float64 <: Real} 也\textbf{没有} \texttt{Point\{Float64\} <: Point\{Real\}}。

\end{quote}


换成类型理论说法，Julia 的类型参数是\emph{不变的}，而不是\href{https://en.wikipedia.org/wiki/Covariance\_and\_contravariance\_\%28computer\_science\%29}{协变的（或甚至是逆变的）}。这是出于实际原因：虽然任何 \texttt{Point\{Float64\}} 的实例在概念上也可能像是 \texttt{Point\{Real\}} 的实例，但这两种类型在内存中有不同的表示：



\begin{itemize}
\item \texttt{Point\{Float64\}} 的实例可以紧凑而高效地表示为一对 64 位立即数；


\item \texttt{Point\{Real\}} 的实例必须能够保存任何一对 \hyperlink{6175959395021454412}{\texttt{Real}} 的实例。由于 \texttt{Real} 实例的对象可以具有任意的大小和结构，\texttt{Point\{Real\}} 的实例实际上必须表示为一对指向单独分配的 \texttt{Real} 对象的指针。

\end{itemize}


在数组的情况下，能够以立即数存储 \texttt{Point\{Float64\}} 对象会极大地提高效率：\texttt{Array\{Float64\}} 可以存储为一段 64 位浮点值组成的连续内存块，而 \texttt{Array\{Real\}} 必须是一个由指向单独分配的 \hyperlink{6175959395021454412}{\texttt{Real}} 的指针组成的数组——这可能是 \href{https://en.wikipedia.org/wiki/Object\_type\_\%28object-oriented\_programming\%29\#Boxing}{boxed} 64 位浮点值，但也可能是任意庞大和复杂的对象，且其被声明为 \texttt{Real} 抽象类型的表示。



由于 \texttt{Point\{Float64\}} 不是 \texttt{Point\{Real\}} 的子类型，下面的方法不适用于类型为 \texttt{Point\{Float64\}} 的参数：




\begin{minted}{julia}
function norm(p::Point{Real})
    sqrt(p.x^2 + p.y^2)
end
\end{minted}



一种正确的方法来定义一个接受类型的所有参数的方法，\texttt{Point\{T\}}其中\texttt{T}是一个子类型\hyperlink{6175959395021454412}{\texttt{Real}}：




\begin{minted}{julia}
function norm(p::Point{<:Real})
    sqrt(p.x^2 + p.y^2)
end
\end{minted}



（等效地，另一种定义方法 \texttt{function norm(p::Point\{T\} where T<:Real)} 或 \texttt{function norm(p::Point\{T\}) where T<:Real}；查看 \hyperlink{11072845175692859046}{UnionAll 类型}。）



稍后将在\hyperlink{3842379394166369470}{方法}中讨论更多示例。



如何构造一个 \texttt{Point} 对象？可以为复合类型定义自定义的构造函数，这将在\hyperlink{1489967485005487723}{构造函数}中详细讨论，但在没有任何特别的构造函数声明的情况下，有两种默认方式可以创建新的复合对象，一种是显式地给出类型参数，另一种是通过传给对象构造函数的参数隐含地给出。



由于 \texttt{Point\{Float64\}} 类型等价于在 \texttt{Point} 声明时用 \hyperlink{5027751419500983000}{\texttt{Float64}} 替换 \texttt{T} 得到的具体类型，它可以相应地作为构造函数使用：




\begin{minted}{jlcon}
julia> Point{Float64}(1.0, 2.0)
Point{Float64}(1.0, 2.0)

julia> typeof(ans)
Point{Float64}
\end{minted}



对于默认的构造函数，必须为每个字段提供一个参数：




\begin{minted}{jlcon}
julia> Point{Float64}(1.0)
ERROR: MethodError: no method matching Point{Float64}(::Float64)
[...]

julia> Point{Float64}(1.0,2.0,3.0)
ERROR: MethodError: no method matching Point{Float64}(::Float64, ::Float64, ::Float64)
[...]
\end{minted}



参数类型只生成一个默认的构造函数，因为它无法覆盖。这个构造函数接受任何参数并将它们转换为字段的类型。



在许多情况下，提供想要构造的 \texttt{Point} 对象的类型是多余的，因为构造函数调用参数的类型已经隐式地提供了类型信息。因此，你也可以将 \texttt{Point} 本身用作构造函数，前提是参数类型 \texttt{T} 的隐含值是确定的：




\begin{minted}{jlcon}
julia> Point(1.0,2.0)
Point{Float64}(1.0, 2.0)

julia> typeof(ans)
Point{Float64}

julia> Point(1,2)
Point{Int64}(1, 2)

julia> typeof(ans)
Point{Int64}
\end{minted}



在 \texttt{Point} 的例子中，当且仅当 \texttt{Point} 的两个参数类型相同时，\texttt{T} 的类型才确实是隐含的。如果不是这种情况，构造函数将失败并出现 \hyperlink{68769522931907606}{\texttt{MethodError}}：




\begin{minted}{jlcon}
julia> Point(1,2.5)
ERROR: MethodError: no method matching Point(::Int64, ::Float64)
Closest candidates are:
  Point(::T, !Matched::T) where T at none:2
\end{minted}



可以定义适当处理此类混合情况的函数构造方法，将在后面的\hyperlink{1489967485005487723}{构造函数}中讨论。



\hypertarget{2167251626535554270}{}


\subsection{参数抽象类型}



参数抽象类型声明以非常相似的方式声明了一族抽象类型：




\begin{minted}{jlcon}
julia> abstract type Pointy{T} end
\end{minted}



在此声明中，对于每个类型或整数值 \texttt{T}，\texttt{Pointy\{T\}} 都是不同的抽象类型。与参数复合类型一样，每个此类型的实例都是 \texttt{Pointy} 的子类型：




\begin{minted}{jlcon}
julia> Pointy{Int64} <: Pointy
true

julia> Pointy{1} <: Pointy
true
\end{minted}



参数抽象类型是不变的，就像参数复合类型：




\begin{minted}{jlcon}
julia> Pointy{Float64} <: Pointy{Real}
false

julia> Pointy{Real} <: Pointy{Float64}
false
\end{minted}



符号 \texttt{Pointy\{<:Real\}} 可用于表示\emph{协变}类型的 Julia 类似物，而 \texttt{Pointy\{>:Int\}} 类似于\emph{逆变}类型，但从技术上讲，它们都代表了类型的\emph{集合}（参见 \hyperlink{11072845175692859046}{UnionAll 类型}）。




\begin{minted}{jlcon}
julia> Pointy{Float64} <: Pointy{<:Real}
true

julia> Pointy{Real} <: Pointy{>:Int}
true
\end{minted}



正如之前的普通抽象类型用于在具体类型上创建实用的类型层次结构一样，参数抽象类型在参数复合类型上具有相同的用途。例如，我们可以将 \texttt{Point\{T\}} 声明为 \texttt{Pointy\{T\}} 的子类型，如下所示：




\begin{minted}{jlcon}
julia> struct Point{T} <: Pointy{T}
           x::T
           y::T
       end
\end{minted}



鉴于此类声明，对每个 \texttt{T}，都有 \texttt{Point\{T\}} 是 \texttt{Pointy\{T\}} 的子类型：




\begin{minted}{jlcon}
julia> Point{Float64} <: Pointy{Float64}
true

julia> Point{Real} <: Pointy{Real}
true

julia> Point{AbstractString} <: Pointy{AbstractString}
true
\end{minted}



下面的关系依然不变：




\begin{minted}{jlcon}
julia> Point{Float64} <: Pointy{Real}
false

julia> Point{Float64} <: Pointy{<:Real}
true
\end{minted}



参数抽象类型（比如 \texttt{Pointy}）的用途是什么？考虑一下如果点都在对角线 \emph{x = y} 上，那我们创建的点的实现可以只有一个坐标：




\begin{minted}{jlcon}
julia> struct DiagPoint{T} <: Pointy{T}
           x::T
       end
\end{minted}



现在，\texttt{Point\{Float64\}} 和 \texttt{DiagPoint\{Float64\}} 都是抽象 \texttt{Pointy\{Float64\}} 的实现，每个类型 \texttt{T} 的其它可能选择与之类似。这允许对被所有 \texttt{Pointy} 对象共享的公共接口进行编程，接口都由 \texttt{Point} 和 \texttt{DiagPoint} 实现。但是，直到我们在下一节\hyperlink{3842379394166369470}{方法}中引入方法和分派前，这无法完全证明。



有时，类型参数取遍所有可能类型也许是无意义的。在这种情况下，可以像这样约束 \texttt{T} 的范围：




\begin{minted}{jlcon}
julia> abstract type Pointy{T<:Real} end
\end{minted}



With such a declaration, it is acceptable to use any type that is a subtype of \hyperlink{6175959395021454412}{\texttt{Real}} in place of \texttt{T}, but not types that are not subtypes of \texttt{Real}:




\begin{minted}{jlcon}
julia> Pointy{Float64}
Pointy{Float64}

julia> Pointy{Real}
Pointy{Real}

julia> Pointy{AbstractString}
ERROR: TypeError: in Pointy, in T, expected T<:Real, got Type{AbstractString}

julia> Pointy{1}
ERROR: TypeError: in Pointy, in T, expected T<:Real, got a value of type Int64
\end{minted}



参数化复合类型的类型参数可用相同的方式限制：




\begin{minted}{julia}
struct Point{T<:Real} <: Pointy{T}
    x::T
    y::T
end
\end{minted}



在这里给出一个真实示例，展示了所有这些参数类型机制如何发挥作用，下面是 Julia 的不可变类型 \hyperlink{8304566144531167610}{\texttt{Rational}} 的实际定义（除了我们为了简单起见省略了的构造函数），用来表示准确的整数比例：




\begin{minted}{julia}
struct Rational{T<:Integer} <: Real
    num::T
    den::T
end
\end{minted}



只有接受整数值的比例才是有意义的，因此参数类型 \texttt{T} 被限制为 \hyperlink{8469131683393450448}{\texttt{Integer}} 的子类型，又整数的比例代表实数轴上的值，因此任何 \hyperlink{8304566144531167610}{\texttt{Rational}} 都是抽象 \hyperlink{6175959395021454412}{\texttt{Real}} 的实现。



\hypertarget{5158816437121320312}{}


\subsection{元组类型}



元组类型是函数参数的抽象——不是函数本身的。函数参数的突出特征是它们的顺序和类型。因此，元组类型类似于参数化的不可变类型，其中每个参数都是一个字段的类型。例如，二元元组类型类似于以下不可变类型：




\begin{minted}{julia}
struct Tuple2{A,B}
    a::A
    b::B
end
\end{minted}



然而，有三个主要差异：



\begin{itemize}
\item 元组类型可以具有任意数量的参数。


\item 元组类型的参数是\emph{协变的}：\texttt{Tuple\{Int\}} 是 \texttt{Tuple\{Any\}} 的子类型。因此，\texttt{Tuple\{Any\}} 被认为是一种抽象类型，且元组类型只有在它们的参数都是具体类型时才是具体类型。 


\item 元组没有字段名称; 字段只能通过索引访问。

\end{itemize}


元组值用括号和逗号书写。构造元组时，会根据需要生成适当的元组类型：




\begin{minted}{jlcon}
julia> typeof((1,"foo",2.5))
Tuple{Int64,String,Float64}
\end{minted}



请注意协变性的含义：




\begin{minted}{jlcon}
julia> Tuple{Int,AbstractString} <: Tuple{Real,Any}
true

julia> Tuple{Int,AbstractString} <: Tuple{Real,Real}
false

julia> Tuple{Int,AbstractString} <: Tuple{Real,}
false
\end{minted}



直观地，这对应于函数参数的类型是函数签名（当函数签名匹配时）的子类型。



\hypertarget{5746534767732668628}{}


\subsection{变参元组类型}



元组类型的最后一个参数可以是特殊类型 \hyperlink{5941806424098279588}{\texttt{Vararg}}，它表示任意数量的尾随参数：




\begin{minted}{jlcon}
julia> mytupletype = Tuple{AbstractString,Vararg{Int}}
Tuple{AbstractString,Vararg{Int64,N} where N}

julia> isa(("1",), mytupletype)
true

julia> isa(("1",1), mytupletype)
true

julia> isa(("1",1,2), mytupletype)
true

julia> isa(("1",1,2,3.0), mytupletype)
false
\end{minted}



请注意，\texttt{Vararg\{T\}} 对应于零个或更多的类型为 \texttt{T} 的元素。变参元组类型被用来表示变参方法接受的参数（请参阅\hyperlink{9965084594348935329}{变参函数}）。



类型 \texttt{Vararg\{T,N\}} 对应于正好 \texttt{N} 个类型为 \texttt{T} 的元素。\texttt{NTuple\{N,T\}} 是 \texttt{Tuple\{Vararg\{T,N\}\}} 的别名，即包含正好 \texttt{N} 个类型为 \texttt{T} 元素的元组类型。



\hypertarget{6997324644254770141}{}


\subsection{具名元组类型}



具名元组是 \hyperlink{3845731488275720657}{\texttt{NamedTuple}} 类型的实例，该类型有两个参数：一个给出字段名称的符号元组，和一个给出字段类型的元组类型。




\begin{minted}{jlcon}
julia> typeof((a=1,b="hello"))
NamedTuple{(:a, :b),Tuple{Int64,String}}
\end{minted}



The \href{@ref}{\texttt{@NamedTuple}} macro provides a more convenient \texttt{struct}-like syntax for declaring \texttt{NamedTuple} types via \texttt{key::Type} declarations, where an omitted \texttt{::Type} corresponds to \texttt{::Any}.




\begin{minted}{jlcon}
julia> @NamedTuple{a::Int, b::String}
NamedTuple{(:a, :b),Tuple{Int64,String}}

julia> @NamedTuple begin
           a::Int
           b::String
       end
NamedTuple{(:a, :b),Tuple{Int64,String}}
\end{minted}



\texttt{NamedTuple} 类型可以用作构造函数，接受一个单独的元组作为参数。构造出来的 \texttt{NamedTuple} 类型可以是具体类型，如果参数都被指定，也可以是只由字段名称所指定的类型：




\begin{minted}{jlcon}
julia> @NamedTuple{a::Float32,b::String}((1,""))
(a = 1.0f0, b = "")

julia> NamedTuple{(:a, :b)}((1,""))
(a = 1, b = "")
\end{minted}



如果指定了字段类型，参数会被转换。否则，就直接使用参数的类型。



\hypertarget{647919389478144252}{}


\subsection{单态类型}



这里必须提到一种特殊的抽象类型：单态类型。对于每个类型 \texttt{T}，「单态类型」\texttt{Type\{T\}} 是个抽象类型且唯一的实例就是对象 \texttt{T}。由于定义有点难以解释，让我们看一些例子：




\begin{minted}{jlcon}
julia> isa(Float64, Type{Float64})
true

julia> isa(Real, Type{Float64})
false

julia> isa(Real, Type{Real})
true

julia> isa(Float64, Type{Real})
false
\end{minted}



换种说法，\hyperlink{7066325108767373297}{\texttt{isa(A,Type\{B\})}} 为真当且仅当 \texttt{A} 与 \texttt{B} 是同一对象且该对象是一个类型。不带参数时，\texttt{Type} 是个抽象类型，所有类型对象都是它的实例，当然也包括单态类型：




\begin{minted}{jlcon}
julia> isa(Type{Float64}, Type)
true

julia> isa(Float64, Type)
true

julia> isa(Real, Type)
true
\end{minted}



只有对象是类型时，才是 \texttt{Type} 的实例：




\begin{minted}{jlcon}
julia> isa(1, Type)
false

julia> isa("foo", Type)
false
\end{minted}



在我们讨论\hyperlink{5820282638415739482}{参数方法}和\hyperlink{10374023657104680331}{类型转换}之前，很难解释单态类型的作用，但简而言之，它允许针对特定类型\emph{值}专门指定函数行为。这对于编写方法（尤其是参数方法）很有用，这些方法的行为取决于作为显式参数给出的类型，而不是隐含在它的某个参数的类型中。



一些流行的语言有单态类型，比如 Haskell、Scala 和 Ruby。在一般用法中，术语「单态类型」指的是唯一实例为单个值的类型。这定义适用于 Julia 的单态类型，但需要注意的是 Julia 里只有类型对象具有对应的单态类型。



\hypertarget{2858316496912626713}{}


\subsection{参数原始类型}



原始类型也可以参数化声明，例如，指针都能表示为原始类型，其在 Julia 中以如下方式声明：




\begin{minted}{julia}
# 32-bit system:
primitive type Ptr{T} 32 end

# 64-bit system:
primitive type Ptr{T} 64 end
\end{minted}



与典型的参数复合类型相比，此声明中略显奇怪的特点是类型参数 \texttt{T} 并未在类型本身的定义里使用——它实际上只是一个抽象的标记，定义了一整族具有相同结构的类型，类型间仅由它们的类型参数来区分。因此，\texttt{Ptr\{Float64\}} 和 \texttt{Ptr\{Int64\}} 是不同的类型，就算它们具有相同的表示。当然，所有特定的指针类型都是总类型 \hyperlink{10630331440513004826}{\texttt{Ptr}} 的子类型：




\begin{minted}{jlcon}
julia> Ptr{Float64} <: Ptr
true

julia> Ptr{Int64} <: Ptr
true
\end{minted}



\hypertarget{1421020605730253291}{}


\section{UnionAll 类型}



我们已经说过像 \texttt{Ptr} 这样的参数类型充当它所有实例（\texttt{Ptr\{Int64\}} 等）的超类型。这是如何工作的？\texttt{Ptr} 本身不能是普通的数据类型，因为在不知道引用数据的类型时，该类型显然不能用于存储器操作。答案是 \texttt{Ptr}（或其它参数类型像 \texttt{Array}）是一种不同种类的类型，称为 \hyperlink{13291956087044414878}{\texttt{UnionAll}} 类型。这种类型表示某些参数的所有值的类型的\emph{迭代并集}。



\texttt{UnionAll} 类型通常使用关键字 \texttt{where} 编写。例如，\texttt{Ptr} 可以更精确地写为 \texttt{Ptr\{T\} where T}，也就是对于 \texttt{T} 的某些值，所有类型为 \texttt{Ptr\{T\}} 的值。在这种情况下，参数 \texttt{T} 也常被称为「类型变量」，因为它就像一个取值范围为类型的变量。每个 \texttt{where} 只引入一个类型变量，因此在具有多个参数的类型中这些表达式会被嵌套，例如 \texttt{Array\{T,N\} where N where T}。



类型应用语法 \texttt{A\{B,C\}} 要求 \texttt{A} 是个 \texttt{UnionAll} 类型，并先把 \texttt{B} 替换为 \texttt{A} 中最外层的类型变量。结果应该是另一个 \texttt{UnionAll} 类型，然后把 \texttt{C} 替换为该类型的类型变量。所以 \texttt{A\{B,C\}} 等价于 \texttt{A\{B\}\{C\}}。这解释了为什么可以部分实例化一个类型，比如 \texttt{Array\{Float64\}}：第一个参数已经被固定，但第二个参数仍取遍所有可能值。通过使用 \texttt{where} 语法，任何参数子集都能被固定。例如，所有一维数组的类型可以写为 \texttt{Array\{T,1\} where T}。



类型变量可以用子类型关系来加以限制。\texttt{Array\{T\} where T<:Integer} 指的是元素类型是某种 \hyperlink{8469131683393450448}{\texttt{Integer}} 的所有数组。语法 \texttt{Array\{<:Integer\}} 是 \texttt{Array\{T\} where T<:Integer} 的便捷的缩写。类型变量可同时具有上下界。\texttt{Array\{T\} where Int<:T<:Number} 指的是元素类型为能够包含 \texttt{Int} 的 \hyperlink{1990584313715697055}{\texttt{Number}} 的所有数组（因为 \texttt{T} 至少和 \texttt{Int} 一样大）。语法 \texttt{where T>:Int} 也能用来只指定类型变量的下界，且 \texttt{Array\{>:Int\}} 等价于 \texttt{Array\{T\} where T>:Int}。



由于 \texttt{where} 表达式可以嵌套，类型变量界可以引用更外层的类型变量。比如 \texttt{Tuple\{T,Array\{S\}\} where S<:AbstractArray\{T\} where T<:Real} 指的是二元元组，其第一个元素是某个 \hyperlink{6175959395021454412}{\texttt{Real}}，而第二个元素是任意种类的数组 \texttt{Array}，且该数组的元素类型包含于第一个元组元素的类型。



\texttt{where} 关键字本身可以嵌套在更复杂的声明里。例如，考虑由以下声明创建的两个类型：




\begin{minted}{jlcon}
julia> const T1 = Array{Array{T,1} where T, 1}
Array{Array{T,1} where T,1}

julia> const T2 = Array{Array{T,1}, 1} where T
Array{Array{T,1},1} where T
\end{minted}



类型 \texttt{T1} 定义了由一维数组组成的一维数组；每个内部数组由相同类型的对象组成，但此类型对于不同内部数组可以不同。另一方面，类型 \texttt{T2} 定义了由一维数组组成的一维数组，其中的每个内部数组必须具有相同的类型。请注意，\texttt{T2} 是个抽象类型，比如 \texttt{Array\{Array\{Int,1\},1\} <: T2}，而 \texttt{T1} 是个具体类型。因此，\texttt{T1} 可由零参数构造函数 \texttt{a=T1()} 构造，但 \texttt{T2} 不行。



命名此类型有一种方便的语法，类似于函数定义语法的简短形式：




\begin{minted}{julia}
Vector{T} = Array{T,1}
\end{minted}



这等价于 \texttt{const Vector = Array\{T,1\} where T}。编写 \texttt{Vector\{Float64\}} 等价于编写 \texttt{Array\{Float64,1\}}，总类型 \texttt{Vector} 具有所有 \texttt{Array} 对象的实例，其中 \texttt{Array} 对象的第二个参数——数组维数——是 1，而不考虑元素类型是什么。在参数类型必须总被完整指定的语言中，这不是特别有用，但在 Julia 中，这允许只编写 \texttt{Vector} 来表示包含任何元素类型的所有一维密集数组的抽象类型。



\hypertarget{11325503690546832900}{}


\section{类型别名}



有时为一个已经可表达的类型引入新名称是很方便的。这可通过一个简单的赋值语句完成。例如，\texttt{UInt} 是 \hyperlink{8690996847580776341}{\texttt{UInt32}} 或 \hyperlink{5500998675195555601}{\texttt{UInt64}} 的别名，因为它的大小与系统上的指针大小是相适应的。




\begin{minted}{jlcon}
# 32-bit system:
julia> UInt
UInt32

# 64-bit system:
julia> UInt
UInt64
\end{minted}



在 \texttt{base/boot.jl} 中，通过以下代码实现：




\begin{minted}{julia}
if Int === Int64
    const UInt = UInt64
else
    const UInt = UInt32
end
\end{minted}



当然，这依赖于 \texttt{Int} 的别名，但它被预定义成正确的类型—— \hyperlink{10103694114785108551}{\texttt{Int32}} 或 \hyperlink{7720564657383125058}{\texttt{Int64}}。



（注意，与 \texttt{Int} 不同，\texttt{Float} 不作为特定大小的 \hyperlink{11465394427882483091}{\texttt{AbstractFloat}} 类型的别名而存在。与整数寄存器不同，浮点数寄存器大小由 IEEE-754 标准指定，而 \texttt{Int} 的大小反映了该机器上本地指针的大小。）



\hypertarget{17381545984694686313}{}


\section{类型操作}



因为 Julia 中的类型本身就是对象，所以一般的函数可以对它们进行操作。已经引入了一些对于使用或探索类型特别有用的函数，例如 \texttt{<:} 运算符，它表示其左操作数是否为其右操作数的子类型。



\hyperlink{7066325108767373297}{\texttt{isa}} 函数测试对象是否具有给定类型并返回 true 或 false：




\begin{minted}{jlcon}
julia> isa(1, Int)
true

julia> isa(1, AbstractFloat)
false
\end{minted}



已经在手册各处的示例中使用的 \hyperlink{13440452181855594120}{\texttt{typeof}} 函数返回其参数的类型。如上所述，因为类型都是对象，所以它们也有类型，我们可以询问它们的类型：




\begin{minted}{jlcon}
julia> typeof(Rational{Int})
DataType

julia> typeof(Union{Real,String})
Union
\end{minted}



如果我们重复这个过程会怎样？一个类型的类型是什么？碰巧，每个类型都是复合值，因此都具有 \texttt{DataType} 类型：




\begin{minted}{jlcon}
julia> typeof(DataType)
DataType

julia> typeof(Union)
DataType
\end{minted}



\texttt{DataType} 是它自己的类型。



另一个适用于某些类型的操作是 \hyperlink{12192788431675298651}{\texttt{supertype}}，它显示了类型的超类型。只有已声明的类型（\texttt{DataType}）才有明确的超类型：




\begin{minted}{jlcon}
julia> supertype(Float64)
AbstractFloat

julia> supertype(Number)
Any

julia> supertype(AbstractString)
Any

julia> supertype(Any)
Any
\end{minted}



如果将 \hyperlink{12192788431675298651}{\texttt{supertype}} 应用于其它类型对象（或非类型对象），则会引发 \hyperlink{68769522931907606}{\texttt{MethodError}}：




\begin{minted}{jlcon}
julia> supertype(Union{Float64,Int64})
ERROR: MethodError: no method matching supertype(::Type{Union{Float64, Int64}})
Closest candidates are:
[...]
\end{minted}



\hypertarget{10200728548672135026}{}


\section{自定义 pretty-printing}



通常，人们会想要自定义显示类型实例的方式。这可通过重载 \hyperlink{14071376285304310153}{\texttt{show}} 函数来完成。举个例子，假设我们定义一个类型来表示极坐标形式的复数：




\begin{minted}{jlcon}
julia> struct Polar{T<:Real} <: Number
           r::T
           Θ::T
       end

julia> Polar(r::Real,Θ::Real) = Polar(promote(r,Θ)...)
Polar
\end{minted}



在这里，我们添加了一个自定义的构造函数，这样就可以接受不同 \hyperlink{6175959395021454412}{\texttt{Real}} 类型的参数并将它们类型提升为共同类型（请参阅\hyperlink{1489967485005487723}{构造函数}和\hyperlink{10374023657104680331}{类型转换和类型提升}）。（当然，为了让它表现地像个 \hyperlink{1990584313715697055}{\texttt{Number}}，我们需要定义许多其它方法，例如 \texttt{+}、\texttt{*}、\texttt{one}、\texttt{zero} 及类型提升规则等。）默认情况下，此类型的实例只是相当简单地显示有关类型名称和字段值的信息，比如，\texttt{Polar\{Float64\}(3.0,4.0)}。



如果我们希望它显示为 \texttt{3.0 * exp(4.0im)}，我们将定义以下方法来将对象打印到给定的输出对象 \texttt{io}（其代表文件、终端、及缓冲区等；请参阅\hyperlink{4176621353987521289}{网络和流}）：




\begin{minted}{jlcon}
julia> Base.show(io::IO, z::Polar) = print(io, z.r, " * exp(", z.Θ, "im)")
\end{minted}



\texttt{Polar} 对象的输出可以被更精细地控制。特别是，人们有时想要啰嗦的多行打印格式，用于在 REPL 和其它交互式环境中显示单个对象，以及一个更紧凑的单行格式，用于 \hyperlink{8248717042415202230}{\texttt{print}} 函数或在作为其它对象（比如一个数组）的部分是显示该对象。虽然在两种情况下默认都会调用 \texttt{show(io, z)} 函数，你仍可以定义一个\emph{不同}的多行格式来显示单个对象，这通过重载三参数形式的 \texttt{show} 函数，该函数接收 \texttt{text/plain} MIME 类型（请参阅 \hyperlink{9485638019478733873}{多媒体 I/O}）作为它的第二个参数，举个例子：




\begin{minted}{jlcon}
julia> Base.show(io::IO, ::MIME"text/plain", z::Polar{T}) where{T} =
           print(io, "Polar{$T} complex number:\n   ", z)
\end{minted}



（请注意 \texttt{print(..., z)} 在这里调用的是双参数的 \texttt{show(io, z)} 方法。）这导致：




\begin{minted}{jlcon}
julia> Polar(3, 4.0)
Polar{Float64} complex number:
   3.0 * exp(4.0im)

julia> [Polar(3, 4.0), Polar(4.0,5.3)]
2-element Array{Polar{Float64},1}:
 3.0 * exp(4.0im)
 4.0 * exp(5.3im)
\end{minted}



其中单行格式的 \texttt{show(io, z)} 仍用于由 \texttt{Polar} 值组成的数组。从技术上讲，REPL 调用 \texttt{display(z)} 来显示单行的执行结果，其默认为 \texttt{show(stdout, MIME({\textquotedbl}text/plain{\textquotedbl}), z)}，而后者又默认为 \texttt{show(stdout, z)}，但是你\emph{不应该}定义新的 \hyperlink{12073120410747960438}{\texttt{display}} 方法，除非你正在定义新的多媒体显示管理器（请参阅\hyperlink{9485638019478733873}{多媒体 I/O}）。



此外，你还可以为其它 MIME 类型定义 \texttt{show} 方法，以便在支持的环境（比如 IJulia）中实现更丰富的对象显示（HTML、图像等）。例如，我们可以定义 \texttt{Polar} 对象的 HTML 显示格式，使其带有上标和斜体：




\begin{minted}{jlcon}
julia> Base.show(io::IO, ::MIME"text/html", z::Polar{T}) where {T} =
           println(io, "<code>Polar{$T}</code> complex number: ",
                   z.r, " <i>e</i><sup>", z.Θ, " <i>i</i></sup>")
\end{minted}



之后会在支持 HTML 显示的环境中自动使用 HTML 显示 \texttt{Polar} 对象，但如果你想，也可以手动调用 \texttt{show} 来获取 HTML 输出：




\begin{minted}{jlcon}
julia> show(stdout, "text/html", Polar(3.0,4.0))
<code>Polar{Float64}</code> complex number: 3.0 <i>e</i><sup>4.0 <i>i</i></sup>
\end{minted}





根据经验，单行 \texttt{show} 方法应为创建的显示对象打印有效的 Julia 表达式。当这个 \texttt{show} 方法包含中缀运算符时，比如上面的 \texttt{Polar} 的单行 \texttt{show} 方法里的乘法运算符（\texttt{*}），在作为另一个对象的部分打印时，它可能无法被正确解析。要查看此问题，请考虑下面的表达式对象（请参阅\hyperlink{10559372927865899180}{程序表示}），它代表 \texttt{Polar} 类型的特定实例的平方：




\begin{minted}{jlcon}
julia> a = Polar(3, 4.0)
Polar{Float64} complex number:
   3.0 * exp(4.0im)

julia> print(:($a^2))
3.0 * exp(4.0im) ^ 2
\end{minted}



因为运算符 \texttt{{\textasciicircum}} 的优先级高于 \texttt{*}（请参阅\hyperlink{1006859879084707050}{运算符的优先级与结合性}），所以此输出不忠实地表示了表达式 \texttt{a {\textasciicircum} 2}，而该表达式等价于 \texttt{(3.0 * exp(4.0im)) {\textasciicircum} 2}。为了解决这个问题，我们必须为 \texttt{Base.show\_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)} 创建一个自定义方法，在打印时，表达式对象会在内部调用它：




\begin{minted}{jlcon}
julia> function Base.show_unquoted(io::IO, z::Polar, ::Int, precedence::Int)
           if Base.operator_precedence(:*) <= precedence
               print(io, "(")
               show(io, z)
               print(io, ")")
           else
               show(io, z)
           end
       end

julia> :($a^2)
:((3.0 * exp(4.0im)) ^ 2)
\end{minted}



当正在调用的运算符的优先级大于等于乘法的优先级时，上面定义的方法会在 \texttt{show} 调用的两侧加上括号。这个检查允许在没有括号的情况下被正确解析的表达式（例如 \texttt{:(\$a + 2)} 和 \texttt{:(\$a == 2)}）在打印时省略括号：




\begin{minted}{jlcon}
julia> :($a + 2)
:(3.0 * exp(4.0im) + 2)

julia> :($a == 2)
:(3.0 * exp(4.0im) == 2)
\end{minted}



在某些情况下，根据上下文调整 \texttt{show} 方法的行为是很有用的。这可通过 \hyperlink{13454403377667762339}{\texttt{IOContext}} 类型实现，它允许一起传递上下文属性和封装后的 IO 流。例如，我们可以在 \texttt{:compact} 属性设置为 \texttt{true} 时创建一个更短的表示，而在该属性为 \texttt{false} 或不存在时返回长的表示：




\begin{minted}{jlcon}
julia> function Base.show(io::IO, z::Polar)
           if get(io, :compact, false)
               print(io, z.r, "ℯ", z.Θ, "im")
           else
               print(io, z.r, " * exp(", z.Θ, "im)")
           end
       end
\end{minted}



当传入的 IO 流是设置了 \texttt{:compact}（译注：该属性还应当设置为 \texttt{true}）属性的 \texttt{IOContext} 对象时，将使用这个新的紧凑表示。特别地，当打印具有多列的数组（由于水平空间有限）时就是这种情况：




\begin{minted}{jlcon}
julia> show(IOContext(stdout, :compact=>true), Polar(3, 4.0))
3.0ℯ4.0im

julia> [Polar(3, 4.0) Polar(4.0,5.3)]
1×2 Array{Polar{Float64},2}:
 3.0ℯ4.0im  4.0ℯ5.3im
\end{minted}



有关调整打印效果的常用属性列表，请参阅文档 \hyperlink{13454403377667762339}{\texttt{IOContext}}。



\hypertarget{764608991862279222}{}


\section{值类型}



在 Julia 中，你无法根据诸如 \texttt{true} 或 \texttt{false} 之类的\emph{值}进行分派。然而，你可以根据参数类型进行分派，Julia 允许你包含「plain bits」值（类型、符号、整数、浮点数和元组等）作为类型参数。\texttt{Array\{T,N\}} 里的维度参数就是一个常见的例子，在那里 \texttt{T} 是类型（比如 \hyperlink{5027751419500983000}{\texttt{Float64}}），而 \texttt{N} 只是个 \texttt{Int}。



你可以创建把值作为参数的自定义类型，并使用它们控制自定义类型的分派。为了说明这个想法，让我们引入参数类型 \texttt{Val\{x\}} 和构造函数 \texttt{Val(x) = Val\{x\}()}，它可以作为一种习惯的方式来利用这种技术需要更精细的层次结构。这可以作为利用这种技术的惯用方式，而且不需要更精细的层次结构。



\hyperlink{1312938105781775871}{\texttt{Val}} 的定义为：




\begin{minted}{jlcon}
julia> struct Val{x}
       end

julia> Val(x) = Val{x}()
Val
\end{minted}



\texttt{Val} 的实现就只需要这些。一些 Julia 标准库里的函数接收 \texttt{Val} 的实例作为参数，你也可以使用它来编写你自己的函数，例如：




\begin{minted}{jlcon}
julia> firstlast(::Val{true}) = "First"
firstlast (generic function with 1 method)

julia> firstlast(::Val{false}) = "Last"
firstlast (generic function with 2 methods)

julia> firstlast(Val(true))
"First"

julia> firstlast(Val(false))
"Last"
\end{minted}



For consistency across Julia, the call site should always pass a \texttt{Val} \emph{instance} rather than using a \emph{type}, i.e., use \texttt{foo(Val(:bar))} rather than \texttt{foo(Val\{:bar\})}.



It{\textquotesingle}s worth noting that it{\textquotesingle}s extremely easy to mis-use parametric {\textquotedbl}value{\textquotedbl} types, including \texttt{Val}; in unfavorable cases, you can easily end up making the performance of your code much \emph{worse}.  In particular, you would never want to write actual code as illustrated above.  For more information about the proper (and improper) uses of \texttt{Val}, please read \hyperlink{17259605703392147735}{the more extensive discussion in the performance tips}.



\footnotetext[1]{「少数」由常数 \texttt{MAX\_UNION\_SPLITTING} 定义，目前设置为 4。

}


\hypertarget{12379207465798704957}{}


\chapter{方法}



我们回想一下，在\hyperlink{645008301484218813}{函数}中我们知道函数是这么一个对象，它把一组参数映射成一个返回值，或者当没有办法返回恰当的值时扔出一个异常。具有相同概念的函数或者运算，经常会根据参数类型的不同而进行有很大差异的实现：两个整数的加法与两个浮点数的加法是相当不一样的，整数与浮点数之间的加法也不一样。除了它们实现上的不同，这些运算都归在{\textquotedbl}加法{\textquotedbl}这么一个广义的概念之下，因此在 Julia 中这些行为都属于同一个对象：\texttt{+} 函数。



为了让对同样的概念使用许多不同的实现这件事更顺畅，函数没有必要马上全部都被定义，反而应该是一块一块地定义，为特定的参数类型和数量的组合提供指定的行为。对于一个函数的一个可能行为的定义叫做\emph{方法}。直到这里，我们只展示了那些只定了一个方法的，对参数的所有类型都适用的函数。但是方法定义的特征是不仅能表明参数的数量，也能表明参数的类型，并且能提供多个方法定义。当一个函数被应用于特殊的一组参数时，能用于这一组参数的最特定的方法会被使用。所以，函数的全体行为是他的不同的方法定义的行为的组合。如果这个组合被设计得好，即使方法们的实现之间会很不一样，函数的外部行为也会显得无缝而自洽。



当一个函数被应用时执行方法的选择被称为\emph{分派}。Julia 允许分派过程来基于给的参数的个数和所有的参数的类型来选择调用函数的哪个方法。这与传统的面对对象的语言不一样，面对对象语言的分派只基于第一参数，经常有特殊的参数语法并且有时是暗含而非显式写成一个参数。\footnotemark[1]使用函数的所有参数，而非只用第一个，来决定调用哪个方法被称为\href{https://en.wikipedia.org/wiki/Multiple\_dispatch}{多重分派}。多重分派对于数学代码来说特别有用，人工地将运算视为对于其中一个参数的属于程度比其他所有的参数都强的这个概念对于数学代码是几乎没有意义的：\texttt{x + y} 中的加法运算对 \texttt{x} 的属于程度比对 \texttt{y} 更强？一个数学运算符的实现普遍基于它所有的参数的类型。即使跳出数学运算，多重分派是对于结构和组织程序来说也是一个强大而方便的范式。



\footnotetext[1]{In C++ or Java, for example, in a method call like \texttt{obj.meth(arg1,arg2)}, the object obj {\textquotedbl}receives{\textquotedbl} the method call and is implicitly passed to the method via the \texttt{this} keyword, rather than as an explicit method argument. When the current \texttt{this} object is the receiver of a method call, it can be omitted altogether, writing just \texttt{meth(arg1,arg2)}, with \texttt{this} implied as the receiving object.

}


\hypertarget{17361934126771506898}{}


\section{定义方法}



直到这里，在我们的例子中，我们定义的函数只有一个不限制参数类型的方法。这种函数的行为就与传统动态类型语言中的函数一样。不过，我们已经在没有意识到的情况下已经使用了多重分派和方法：所有 Julia 标准函数和运算符，就像之前提到的 \texttt{+} 函数，都根据参数的类型和数量的不同组合而定义了大量方法。



当定义一个函数时，可以根据需要使用在\hyperlink{4168730090950432836}{复合类型}中介绍的 \texttt{::} 类型断言运算符来限制参数类型，




\begin{minted}{jlcon}
julia> f(x::Float64, y::Float64) = 2x + y
f (generic function with 1 method)
\end{minted}



这个函数只在 \texttt{x} 和 \texttt{y} 的类型都是 \hyperlink{5027751419500983000}{\texttt{Float64}} 的情况下才会被调用：




\begin{minted}{jlcon}
julia> f(2.0, 3.0)
7.0
\end{minted}



用其它任意的参数类型则会导致 \hyperlink{68769522931907606}{\texttt{MethodError}}:




\begin{minted}{jlcon}
julia> f(2.0, 3)
ERROR: MethodError: no method matching f(::Float64, ::Int64)
Closest candidates are:
  f(::Float64, !Matched::Float64) at none:1

julia> f(Float32(2.0), 3.0)
ERROR: MethodError: no method matching f(::Float32, ::Float64)
Closest candidates are:
  f(!Matched::Float64, ::Float64) at none:1

julia> f(2.0, "3.0")
ERROR: MethodError: no method matching f(::Float64, ::String)
Closest candidates are:
  f(::Float64, !Matched::Float64) at none:1

julia> f("2.0", "3.0")
ERROR: MethodError: no method matching f(::String, ::String)
\end{minted}



如同你所看到的，参数必须精确地是 \hyperlink{5027751419500983000}{\texttt{Float64}} 类型。其它数字类型，比如整数或者 32 位浮点数值，都不会自动转化成 64 位浮点数，字符串也不会解析成数字。由于 \texttt{Float64} 是一个具体类型，且在 Julia 中具体类型无法拥有子类，所以这种定义方式只能适用于函数的输入类型精确地是 \texttt{Float64} 的情况，但一个常见的做法是用抽象类型来定义通用的方法：




\begin{minted}{jlcon}
julia> f(x::Number, y::Number) = 2x - y
f (generic function with 2 methods)

julia> f(2.0, 3)
1.0
\end{minted}



用上面这种方式定义的方法可以接收任意一对 \hyperlink{1990584313715697055}{\texttt{Number}} 的实例参数，且它们不需要是同一类型的，只要求都是数值。如何根据不同的类型来做相应的处理就可以委托给表达式 \texttt{2x - y} 中的代数运算。



为了定义一个有多个方法的函数，只需简单定义这个函数多次，使用不同的参数数量和类型。函数的第一个方法定义会建立这个函数对象，后续的方法定义会添加新的方法到存在的函数对象中去。当函数被应用时，最符合参数的数量和类型的特定方法会被执行。所以，上面的两个方法定义在一起定义了函数\texttt{f}对于所有的一对虚拟类型\texttt{Number}实例的行为 – 但是针对一对\hyperlink{5027751419500983000}{\texttt{Float64}}值有不同的行为。如果一个参数是64位浮点数而另一个不是，\texttt{f(Float64,Float64)}方法不会被调用，而一定使用更加通用的\texttt{f(Number,Number)}方法：




\begin{minted}{jlcon}
julia> f(2.0, 3.0)
7.0

julia> f(2, 3.0)
1.0

julia> f(2.0, 3)
1.0

julia> f(2, 3)
1
\end{minted}



\texttt{2x + y} 定义只用于第一个情况，\texttt{2x - y} 定义用于其他的情况。没有使用任何自动的函数参数的指派或者类型转换：Julia中的所有转换都不是 magic 的，都是完全显式的。然而\hyperlink{10374023657104680331}{类型转换和类型提升}显示了足够先进的技术的智能应用能够与 magic 不可分辨到什么程度。\footnotemark[2] 对于非数字值，和比两个参数更多或者更少的情况，函数 \texttt{f} 并没有定义，应用会导致 \hyperlink{68769522931907606}{\texttt{MethodError}}：




\begin{minted}{jlcon}
julia> f("foo", 3)
ERROR: MethodError: no method matching f(::String, ::Int64)
Closest candidates are:
  f(!Matched::Number, ::Number) at none:1

julia> f()
ERROR: MethodError: no method matching f()
Closest candidates are:
  f(!Matched::Float64, !Matched::Float64) at none:1
  f(!Matched::Number, !Matched::Number) at none:1
\end{minted}



可以简单地看到对于函数存在哪些方法，通过在交互式会话中键入函数对象本身：




\begin{minted}{jlcon}
julia> f
f (generic function with 2 methods)
\end{minted}



这个输出告诉我们\texttt{f}是有两个方法的函数对象。为了找出那些方法的特征是什么，使用 \hyperlink{3025953302266245919}{\texttt{methods}}函数：




\begin{minted}{jlcon}
julia> methods(f)
# 2 methods for generic function "f":
[1] f(x::Float64, y::Float64) in Main at none:1
[2] f(x::Number, y::Number) in Main at none:1
\end{minted}



这表示\texttt{f}有两个方法，一个接受两个\texttt{Float64}参数一个接受两个\texttt{Number}类型的参数。它也显示了这些方法定义所在的文件和行数：因为这些方法是在REPL中定义的，我们得到了表面上的行数\texttt{none:1}.



没有\texttt{::}的类型声明，方法参数的类型默认为\texttt{Any}，这就意味着没有约束，因为Julia中的所有的值都是抽象类型\texttt{Any}的实例。所以，我们可以为\texttt{f}定义一个接受所有的方法，像这样：




\begin{minted}{jlcon}
julia> f(x,y) = println("Whoa there, Nelly.")
f (generic function with 3 methods)

julia> f("foo", 1)
Whoa there, Nelly.
\end{minted}



这个接受所有的方法比其他的对一堆参数值的其他任意可能的方法定义更不专用。所以他只会被没有其他方法定义应用的一对参数调用。



虽然这像是一个简单的概念，基于值的类型的多重分派可能是Julia语言的一个最强大和中心特性。核心运算符都典型地含有很多方法：




\begin{minted}{jlcon}
julia> methods(+)
# 180 methods for generic function "+":
[1] +(x::Bool, z::Complex{Bool}) in Base at complex.jl:227
[2] +(x::Bool, y::Bool) in Base at bool.jl:89
[3] +(x::Bool) in Base at bool.jl:86
[4] +(x::Bool, y::T) where T<:AbstractFloat in Base at bool.jl:96
[5] +(x::Bool, z::Complex) in Base at complex.jl:234
[6] +(a::Float16, b::Float16) in Base at float.jl:373
[7] +(x::Float32, y::Float32) in Base at float.jl:375
[8] +(x::Float64, y::Float64) in Base at float.jl:376
[9] +(z::Complex{Bool}, x::Bool) in Base at complex.jl:228
[10] +(z::Complex{Bool}, x::Real) in Base at complex.jl:242
[11] +(x::Char, y::Integer) in Base at char.jl:40
[12] +(c::BigInt, x::BigFloat) in Base.MPFR at mpfr.jl:307
[13] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt, e::BigInt) in Base.GMP at gmp.jl:392
[14] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt) in Base.GMP at gmp.jl:391
[15] +(a::BigInt, b::BigInt, c::BigInt) in Base.GMP at gmp.jl:390
[16] +(x::BigInt, y::BigInt) in Base.GMP at gmp.jl:361
[17] +(x::BigInt, c::Union{UInt16, UInt32, UInt64, UInt8}) in Base.GMP at gmp.jl:398
...
[180] +(a, b, c, xs...) in Base at operators.jl:424
\end{minted}



多重分派和灵活的参数类型系统让Julia有能力抽象地表达高层级算法，而与实现细节解耦，也能生成高效而专用的代码来在运行中处理每个情况。



\hypertarget{8405464025999625028}{}


\section{方法歧义}



在一系列的函数方法定义时有可能没有单独的最专用的方法能适用于参数的某些组合：




\begin{minted}{jlcon}
julia> g(x::Float64, y) = 2x + y
g (generic function with 1 method)

julia> g(x, y::Float64) = x + 2y
g (generic function with 2 methods)

julia> g(2.0, 3)
7.0

julia> g(2, 3.0)
8.0

julia> g(2.0, 3.0)
ERROR: MethodError: g(::Float64, ::Float64) is ambiguous. Candidates:
  g(x::Float64, y) in Main at none:1
  g(x, y::Float64) in Main at none:1
Possible fix, define
  g(::Float64, ::Float64)
\end{minted}



这里\texttt{g(2.0,3.0)}的调用使用\texttt{g(Float64, Any)}和\texttt{g(Any, Float64)}都能处理，并且两个都不更加专用。在这样的情况下，Julia会扔出\hyperlink{68769522931907606}{\texttt{MethodError}}而非任意选择一个方法。你可以通过对交叉情况指定一个合适的方法来避免方法歧义：




\begin{minted}{jlcon}
julia> g(x::Float64, y::Float64) = 2x + 2y
g (generic function with 3 methods)

julia> g(2.0, 3)
7.0

julia> g(2, 3.0)
8.0

julia> g(2.0, 3.0)
10.0
\end{minted}



建议先定义没有歧义的方法，因为不这样的话，歧义就会存在，即使是暂时性的，直到更加专用的方法被定义。



在更加复杂的情况下，解决方法歧义会会涉及到设计的某一个元素；这个主题将会在\hyperlink{15846346227037149553}{下面}进行进一步的探索。



\hypertarget{14064657876301533350}{}


\section{参数方法}



方法定义可以视需要存在限定特征的类型参数：




\begin{minted}{jlcon}
julia> same_type(x::T, y::T) where {T} = true
same_type (generic function with 1 method)

julia> same_type(x,y) = false
same_type (generic function with 2 methods)
\end{minted}



第一个方法应用于两个参数都是同一个具体类型时，不管类型是什么，而第二个方法接受一切，涉及其他所有情况。所以，总得来说，这个定义了一个布尔函数来检查两个参数是否是同样的类型：




\begin{minted}{jlcon}
julia> same_type(1, 2)
true

julia> same_type(1, 2.0)
false

julia> same_type(1.0, 2.0)
true

julia> same_type("foo", 2.0)
false

julia> same_type("foo", "bar")
true

julia> same_type(Int32(1), Int64(2))
false
\end{minted}



这样的定义对应着那些类型签名是 \texttt{UnionAll} 类型的方法（参见 \hyperlink{11072845175692859046}{UnionAll 类型}）。



在Julia中这种通过分派进行函数行为的定义是十分常见的，甚至是惯用的。方法类型参数并不局限于用作参数的类型：他们可以用在任意地方，只要值会在函数或者函数体的特征中。这里有个例子，例子中方法类型参数\texttt{T}用作方法特征中的参数类型\texttt{Vector\{T\}}的类型参数：




\begin{minted}{jlcon}
julia> myappend(v::Vector{T}, x::T) where {T} = [v..., x]
myappend (generic function with 1 method)

julia> myappend([1,2,3],4)
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> myappend([1,2,3],2.5)
ERROR: MethodError: no method matching myappend(::Array{Int64,1}, ::Float64)
Closest candidates are:
  myappend(::Array{T,1}, !Matched::T) where T at none:1

julia> myappend([1.0,2.0,3.0],4.0)
4-element Array{Float64,1}:
 1.0
 2.0
 3.0
 4.0

julia> myappend([1.0,2.0,3.0],4)
ERROR: MethodError: no method matching myappend(::Array{Float64,1}, ::Int64)
Closest candidates are:
  myappend(::Array{T,1}, !Matched::T) where T at none:1
\end{minted}



如你所看到的，追加的元素的类型必须匹配它追加到的向量的元素类型，否则会引起\hyperlink{68769522931907606}{\texttt{MethodError}}。在下面的例子中，方法类型参量\texttt{T}用作返回值：




\begin{minted}{jlcon}
julia> mytypeof(x::T) where {T} = T
mytypeof (generic function with 1 method)

julia> mytypeof(1)
Int64

julia> mytypeof(1.0)
Float64
\end{minted}



就像你能在类型声明时通过类型参数对子类型进行约束一样（参见\hyperlink{5603543911318150609}{参数类型}），你也可以约束方法的类型参数：




\begin{minted}{jlcon}
julia> same_type_numeric(x::T, y::T) where {T<:Number} = true
same_type_numeric (generic function with 1 method)

julia> same_type_numeric(x::Number, y::Number) = false
same_type_numeric (generic function with 2 methods)

julia> same_type_numeric(1, 2)
true

julia> same_type_numeric(1, 2.0)
false

julia> same_type_numeric(1.0, 2.0)
true

julia> same_type_numeric("foo", 2.0)
ERROR: MethodError: no method matching same_type_numeric(::String, ::Float64)
Closest candidates are:
  same_type_numeric(!Matched::T, ::T) where T<:Number at none:1
  same_type_numeric(!Matched::Number, ::Number) at none:1

julia> same_type_numeric("foo", "bar")
ERROR: MethodError: no method matching same_type_numeric(::String, ::String)

julia> same_type_numeric(Int32(1), Int64(2))
false
\end{minted}



\texttt{same\_type\_numeric}函数的行为与上面定义的\texttt{same\_type}函数基本相似，但是它只对一对数定义。



参数方法允许与 \texttt{where} 表达式同样的语法用来写类型（参见 \hyperlink{11072845175692859046}{UnionAll 类型}）。如果只有一个参数，封闭的大括号（在 \texttt{where \{T\}} 中）可以省略，但是为了清楚起见推荐写上。多个参数可以使用逗号隔开，例如 \texttt{where \{T, S <: Real\}}，或者使用嵌套的 \texttt{where} 来写，例如 \texttt{where S<:Real where T}。



\hypertarget{18141577506112006209}{}


\section{重定义方法}



当重定义一个方法或者增加一个方法时，知道这个变化不会立即生效很重要。这是Julia能够静态推断和编译代码使其运行很快而没有惯常的JIT技巧和额外开销的关键。实际上，任意新的方法定义不会对当前运行环境可见，包括Tasks和线程（和所有的之前定义的\texttt{@generated}函数）。让我们通过一个例子说明这意味着什么：




\begin{minted}{jlcon}
julia> function tryeval()
           @eval newfun() = 1
           newfun()
       end
tryeval (generic function with 1 method)

julia> tryeval()
ERROR: MethodError: no method matching newfun()
The applicable method may be too new: running in world age xxxx1, while current world is xxxx2.
Closest candidates are:
  newfun() at none:1 (method too new to be called from this world context.)
 in tryeval() at none:1
 ...

julia> newfun()
1
\end{minted}



在这个例子中看到\texttt{newfun}的新定义已经被创建，但是并不能立即调用。新的全局变量立即对\texttt{tryeval}函数可见，所以你可以写\texttt{return newfun}（没有小括号）。但是你，你的调用器，和他们调用的函数等等都不能调用这个新的方法定义！



但是这里有个例外：之后的\emph{在 REPL 中}的 \texttt{newfun} 的调用会按照预期工作，能够见到并调用\texttt{newfun} 的新定义。



但是，之后的 \texttt{tryeval} 的调用将会继续看到 \texttt{newfun} 的定义，因为该定义\emph{位于 REPL 的前一个语句中}并因此在之后的 \texttt{tryeval} 的调用之前。



你可以试试这个来让自己了解这是如何工作的。



这个行为的实现通过一个「world age 计数器」。这个单调递增的值会跟踪每个方法定义操作。此计数器允许用单个数字描述「对于给定运行时环境可见的方法定义集」，或者说「world age」。它还允许仅仅通过其序数值来比较在两个 world 中可用的方法。在上例中，我们看到（方法 \texttt{newfun} 所存在的）「current world」比局部于任务的「runtime world」大一，后者在 \texttt{tryeval} 开始执行时是固定的。



有时规避这个是必要的（例如，如果你在实现上面的REPL）。幸运的是这里有个简单地解决方法：使用\hyperlink{15240876280767285272}{\texttt{Base.invokelatest}}调用函数：




\begin{minted}{jlcon}
julia> function tryeval2()
           @eval newfun2() = 2
           Base.invokelatest(newfun2)
       end
tryeval2 (generic function with 1 method)

julia> tryeval2()
2
\end{minted}



最后，让我们看一些这个规则生效的更复杂的例子。 定义一个函数\texttt{f(x)}，最开始有一个方法：




\begin{minted}{jlcon}
julia> f(x) = "original definition"
f (generic function with 1 method)
\end{minted}



开始一些使用\texttt{f(x)}的运算：




\begin{minted}{jlcon}
julia> g(x) = f(x)
g (generic function with 1 method)

julia> t = @async f(wait()); yield();
\end{minted}



现在我们给\texttt{f(x)}加上一些新的方法：




\begin{minted}{jlcon}
julia> f(x::Int) = "definition for Int"
f (generic function with 2 methods)

julia> f(x::Type{Int}) = "definition for Type{Int}"
f (generic function with 3 methods)
\end{minted}



比较一下这些结果如何不同：




\begin{minted}{jlcon}
julia> f(1)
"definition for Int"

julia> g(1)
"definition for Int"

julia> fetch(schedule(t, 1))
"original definition"

julia> t = @async f(wait()); yield();

julia> fetch(schedule(t, 1))
"definition for Int"
\end{minted}



\hypertarget{1696520674414442593}{}


\section{使用参数方法设计样式}



虽然复杂的分派逻辑对于性能或者可用性并不是必须的，但是有时这是表达某些算法的最好的方法。 这里有一些常见的设计样式，在以这个方法使用分派时有时会出现。



\hypertarget{13813570673284607064}{}


\subsection{从超类型中提取出类型参数}



这里是一个正确地代码模板，它返回\texttt{AbstractArray}的任意子类型的元素类型\texttt{T}:




\begin{minted}{julia}
abstract type AbstractArray{T, N} end
eltype(::Type{<:AbstractArray{T}}) where {T} = T
\end{minted}



using so-called triangular dispatch.  Note that if \texttt{T} is a \texttt{UnionAll} type, as e.g. \texttt{eltype(Array\{T\} where T <: Integer)}, then \texttt{Any} is returned (as does the version of \texttt{eltype} in \texttt{Base}).



另外一个方法，这是在Julia v0.6中的三角分派到来之前的唯一正确方法，是：




\begin{minted}{julia}
abstract type AbstractArray{T, N} end
eltype(::Type{AbstractArray}) = Any
eltype(::Type{AbstractArray{T}}) where {T} = T
eltype(::Type{AbstractArray{T, N}}) where {T, N} = T
eltype(::Type{A}) where {A<:AbstractArray} = eltype(supertype(A))
\end{minted}



另外一个可能性如下例，这可以对适配那些参数\texttt{T}需要更严格匹配的情况有用：




\begin{minted}{julia}
eltype(::Type{AbstractArray{T, N} where {T<:S, N<:M}}) where {M, S} = Any
eltype(::Type{AbstractArray{T, N} where {T<:S}}) where {N, S} = Any
eltype(::Type{AbstractArray{T, N} where {N<:M}}) where {M, T} = T
eltype(::Type{AbstractArray{T, N}}) where {T, N} = T
eltype(::Type{A}) where {A <: AbstractArray} = eltype(supertype(A))
\end{minted}



一个常见的错误是试着使用内省来得到元素类型：




\begin{minted}{julia}
eltype_wrong(::Type{A}) where {A<:AbstractArray} = A.parameters[1]
\end{minted}



但是创建一个这个方法会失败的情况不难：




\begin{minted}{julia}
struct BitVector <: AbstractArray{Bool, 1}; end
\end{minted}



这里我们已经创建了一个没有参数的类型\texttt{BitVector}，但是元素类型已经完全指定了，\texttt{T}等于\texttt{Bool}！



\hypertarget{7211262558234007578}{}


\subsection{用不同的类型参数构建相似的类型}



当构建通用代码时，通常需要创建一些类似对象，在类型的布局上有一些变化，这就也让类型参数的变化变得必要。 例如，你会有一些任意元素类型的抽象数组，想使用特定的元素类型来编写你基于它的计算。你必须实现为每个\texttt{AbstractArray\{T\}}的子类型实现方法，这些方法描述了如何计算类型转换。从一个子类型转化成拥有一个不同参数的另一个子类型的通用方法在这里不存在。（快速复习：你明白为什么吗？）



\texttt{AbstractArray}的子类型典型情况下会实现两个方法来完成这个： 一个方法把输入输入转换成特定的\texttt{AbstractArray\{T,N\}}抽象类型的子类型；一个方法用特定的元素类型构建一个新的未初始化的数组。这些的样例实现可以在Julia Base里面找到。这里是一个基础的样例使用，保证\texttt{输入}与\texttt{输出}是同一种类型：




\begin{minted}{julia}
input = convert(AbstractArray{Eltype}, input)
output = similar(input, Eltype)
\end{minted}



作为这个的扩展，在算法需要输入数组的拷贝的情况下，\hyperlink{1846942650946171605}{\texttt{convert}}使无法胜任的，因为返回值可能只是原始输入的别名。把\hyperlink{15525808546723795098}{\texttt{similar}}（构建输出数组）和\hyperlink{12476124489163612623}{\texttt{copyto!}}（用输入数据填满）结合起来是需要给出输入参数的可变拷贝的一个范用方法：




\begin{minted}{julia}
copy_with_eltype(input, Eltype) = copyto!(similar(input, Eltype), input)
\end{minted}



\hypertarget{6940352566710127049}{}


\subsection{迭代分派}



为了分派一个多层的参数参量列表，将每一层分派分开到不同的函数中常常是最好的。这可能听起来跟单分派的方法相似，但是你会在下面见到，这个更加灵活。



例如，尝试按照数组的元素类型进行分派常常会引起歧义。相反地，常见的代码会首先按照容易类型分派，然后基于eltype递归到更加更加专用的方法。在大部分情况下，算法会很方便地就屈从与这个分层方法，在其他情况下，这种严苛的工作必须手动解决。这个分派分支能被观察到，例如在两个矩阵的加法的逻辑中：




\begin{minted}{julia}
# 首先分派选择了逐元素相加的map算法。
+(a::Matrix, b::Matrix) = map(+, a, b)
# 然后分派处理了每个元素然后选择了计算的
# 恰当的常见元素类型。
+(a, b) = +(promote(a, b)...)
# 一旦元素有了相同类型，它们就可以相加。
# 例如，通过处理器暴露出的原始运算。
+(a::Float64, b::Float64) = Core.add(a, b)
\end{minted}



\hypertarget{5085783943422577248}{}


\subsection{基于 Trait 的分派}



对于上面的可迭代分派的一个自然扩展是给方法选择加一个内涵层，这个层允许按照那些与类型层级定义的集合相独立的类型的集合来分派。我们可以通过写出问题中的类型的一个\texttt{Union}来创建这个一个集合，但是这不能够扩展，因为\texttt{Union}类型在创建之后无法改变。但是这么一个可扩展的集合可以通过一个叫做\href{https://github.com/JuliaLang/julia/issues/2345\#issuecomment-54537633}{{\textquotedbl}Holy-trait{\textquotedbl}}的一个设计样式来实现。



这个样式是通过定义一个范用函数来实现，这个函数为函数参数可能属于的每个trait集合都计算出不同的单例值（或者类型）。如果这个函数是单纯的，这与通常的分派对于性能没有任何影响。



上一节的例子掩盖了\hyperlink{11483231213869150535}{\texttt{map}}和\hyperlink{1760874576431605095}{\texttt{promote}}的实现细节，这两个都是依据trait来进行运算的。当对一个矩阵进行迭代，比如\texttt{map}的实现中，一个重要的问题是按照什么顺序去遍历数据。当\texttt{AbstractArray}的子类型实现了\hyperlink{7782790551324367092}{\texttt{Base.IndexStyle}}trait，其他函数，比如\texttt{map}就可以根据这个信息进行分派，以选择最好的算法（参见\hyperlink{9718377734213742156}{抽象数组接口}）。这意味着每个子类型就没有必要去实现对应的\texttt{map}版本，因为通用的定义加trait类就能让系统选择最快的版本。这里一个玩具似的\texttt{map}实现说明了基于trait的分派：




\begin{minted}{julia}
map(f, a::AbstractArray, b::AbstractArray) = map(Base.IndexStyle(a, b), f, a, b)
# generic implementation:
map(::Base.IndexCartesian, f, a::AbstractArray, b::AbstractArray) = ...
# linear-indexing implementation (faster)
map(::Base.IndexLinear, f, a::AbstractArray, b::AbstractArray) = ...
\end{minted}



这个基于trait的方法也出现在\hyperlink{1760874576431605095}{\texttt{promote}}机制中，被标量\texttt{+}使用。 它使用了\hyperlink{15048881762587391286}{\texttt{promote\_type}}，这在知道两个计算对象的类型的情况下返回计算这个运算的最佳的常用类型。这就使得我们不用为每一对可能的类型参数实现每一个函数，而把问题简化为对于每个类型实现一个类型转换运算这样一个小很多的问题，还有一个优选的逐对的类型提升规则的表格。



\hypertarget{8273619992944815153}{}


\subsection{输出类型计算}



基于trait的类型提升的讨论可以过渡到我们的下一个设计样式：为矩阵运算计算输出元素类型。



为了实现像加法这样的原始运算，我们使用\hyperlink{15048881762587391286}{\texttt{promote\_type}}函数来计算想要的输出类型。（像之前一样，我们在\texttt{+}调用中的\texttt{promote}调用中见到了这个工作）。



对于矩阵的更加复杂的函数，对于更加复杂的运算符序列来计算预期的返回类型是必要的。这经常按下列步骤进行：



\begin{itemize}
\item[1. ] 编写一个小函数\texttt{op}来表示算法核心中使用的运算的集合。


\item[2. ] 使用\texttt{promote\_op(op, argument\_types...)}计算结果矩阵的元素类型\texttt{R}， 这里\texttt{argument\_types}是通过应用到每个输入数组的\texttt{eltype}计算的。


\item[3. ] 创建类似于\texttt{similar(R, dims)}的输出矩阵，这里\texttt{dims}是输出矩阵的预期维度数。

\end{itemize}


作为一个更加具体的例子，一个范用的方阵乘法的伪代码是：




\begin{minted}{julia}
function matmul(a::AbstractMatrix, b::AbstractMatrix)
    op = (ai, bi) -> ai * bi + ai * bi

    ## this is insufficient because it assumes `one(eltype(a))` is constructable:
    # R = typeof(op(one(eltype(a)), one(eltype(b))))

    ## this fails because it assumes `a[1]` exists and is representative of all elements of the array
    # R = typeof(op(a[1], b[1]))

    ## this is incorrect because it assumes that `+` calls `promote_type`
    ## but this is not true for some types, such as Bool:
    # R = promote_type(ai, bi)

    # this is wrong, since depending on the return value
    # of type-inference is very brittle (as well as not being optimizable):
    # R = Base.return_types(op, (eltype(a), eltype(b)))

    ## but, finally, this works:
    R = promote_op(op, eltype(a), eltype(b))
    ## although sometimes it may give a larger type than desired
    ## it will always give a correct type

    output = similar(b, R, (size(a, 1), size(b, 2)))
    if size(a, 2) > 0
        for j in 1:size(b, 2)
            for i in 1:size(a, 1)
                ## here we don't use `ab = zero(R)`,
                ## since `R` might be `Any` and `zero(Any)` is not defined
                ## we also must declare `ab::R` to make the type of `ab` constant in the loop,
                ## since it is possible that typeof(a * b) != typeof(a * b + a * b) == R
                ab::R = a[i, 1] * b[1, j]
                for k in 2:size(a, 2)
                    ab += a[i, k] * b[k, j]
                end
                output[i, j] = ab
            end
        end
    end
    return output
end
\end{minted}



\hypertarget{1067448927897925814}{}


\subsection{分离转换和内核逻辑}



能有效减少编译时间和测试复杂度的一个方法是将预期的类型和计算转换的逻辑隔离。这会让编译器将与大型内核的其他部分相独立的类型转换逻辑特别化并内联。



将更大的类型类转换成被算法实际支持的特定参数类是一个常见的设计样式：




\begin{minted}{julia}
complexfunction(arg::Int) = ...
complexfunction(arg::Any) = complexfunction(convert(Int, arg))

matmul(a::T, b::T) = ...
matmul(a, b) = matmul(promote(a, b)...)
\end{minted}



\hypertarget{3661198273813942193}{}


\section{参数化约束的可变参数方法}



函数参数也可以用于约束应用于{\textquotedbl}可变参数{\textquotedbl}函数（\hyperlink{9965084594348935329}{变参函数}）的参数的数量。\texttt{Vararg\{T,N\}} 可用于表明这么一个约束。举个例子：




\begin{minted}{jlcon}
julia> bar(a,b,x::Vararg{Any,2}) = (a,b,x)
bar (generic function with 1 method)

julia> bar(1,2,3)
ERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64)
Closest candidates are:
  bar(::Any, ::Any, ::Any, !Matched::Any) at none:1

julia> bar(1,2,3,4)
(1, 2, (3, 4))

julia> bar(1,2,3,4,5)
ERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64, ::Int64, ::Int64)
Closest candidates are:
  bar(::Any, ::Any, ::Any, ::Any) at none:1
\end{minted}



更加有用的是，用一个参数就约束可变参数的方法是可能的。例如：




\begin{minted}{julia}
function getindex(A::AbstractArray{T,N}, indices::Vararg{Number,N}) where {T,N}
\end{minted}



只会在\texttt{indices}的个数与数组的维数相同时才会调用。



当只有提供的参数的类型需要被约束时，\texttt{Vararg\{T\}}可以写成\texttt{T...}。例如\texttt{f(x::Int...) = x}是\texttt{f(x::Vararg\{Int\}) = x}的简便写法。



\hypertarget{6114459498123607412}{}


\section{可选参数和关键字的参数的注意事项}



与在\hyperlink{645008301484218813}{函数}中简要提到的一样，可选参数是使用多方法定义语法来实现的。例如，这个定义：




\begin{minted}{julia}
f(a=1,b=2) = a+2b
\end{minted}



翻译成下列三个方法：




\begin{minted}{julia}
f(a,b) = a+2b
f(a) = f(a,2)
f() = f(1,2)
\end{minted}



这就意味着调用\texttt{f()}等于调用\texttt{f(1,2)}。在这个情况下结果是\texttt{5}，因为\texttt{f(1,2)}使用的是上面\texttt{f}的第一个方法。但是，不总是需要是这种情况。如果你定义了第四个对于整数更加专用的方法：




\begin{minted}{julia}
f(a::Int,b::Int) = a-2b
\end{minted}



此时\texttt{f()}和\texttt{f(1,2)}的结果都是\texttt{-3}。换句话说，可选参数只与函数捆绑，而不是函数的任意一个特定的方法。这个决定于使用的方法的可选参数的类型。当可选参数是用全局变量的形式定义时，可选参数的类型甚至会在运行时改变。



关键字参数与普通的位置参数的行为很不一样。特别地，他们不参与到方法分派中。方法只基于位置参数分派，在匹配得方法确定之后关键字参数才会被处理。



\hypertarget{12721694880938168924}{}


\section{类函数对象}



方法与类型相关，所以可以通过给类型加方法使得任意一个Julia类型变得{\textquotedbl}可被调用{\textquotedbl}。（这个{\textquotedbl}可调用{\textquotedbl}的对象有时称为{\textquotedbl}函子{\textquotedbl}。）



例如，你可以定义一个类型，存储着多项式的系数，但是行为像是一个函数，可以为多项式求值：




\begin{minted}{jlcon}
julia> struct Polynomial{R}
           coeffs::Vector{R}
       end

julia> function (p::Polynomial)(x)
           v = p.coeffs[end]
           for i = (length(p.coeffs)-1):-1:1
               v = v*x + p.coeffs[i]
           end
           return v
       end

julia> (p::Polynomial)() = p(5)
\end{minted}



注意函数是通过类型而非名字来指定的。如同普通函数一样这里有一个简洁的语法形式。在函数体内，\texttt{p}会指向被调用的对象。\texttt{Polynomial}会按如下方式使用：




\begin{minted}{jlcon}
julia> p = Polynomial([1,10,100])
Polynomial{Int64}([1, 10, 100])

julia> p(3)
931

julia> p()
2551
\end{minted}



这个机制也是Julia中类型构造函数和闭包（指向其环境的内部函数）的工作原理。



\hypertarget{117540638029415517}{}


\section{空泛型函数}



有时引入一个没有添加方法的范用函数是有用的。这会用于分离实现与接口定义。这也可为了文档或者代码可读性。为了这个的语法是没有参数组的一个空\texttt{函数}块：




\begin{minted}{julia}
function emptyfunc
end
\end{minted}



\hypertarget{11088607530909626670}{}


\section{方法设计与避免歧义}



Julia的方法多态性是其最有力的特性之一，利用这个功能会带来设计上的挑战。特别地，在更加复杂的方法层级中出现\hyperlink{1524461975045594238}{歧义}不能说不常见。



在上面我们曾经指出我们可以像这样解决歧义




\begin{minted}{julia}
f(x, y::Int) = 1
f(x::Int, y) = 2
\end{minted}



靠定义一个方法




\begin{minted}{julia}
f(x::Int, y::Int) = 3
\end{minted}



这是经常使用的对的方案；但是有些环境下盲目地遵从这个建议会适得其反。特别地，范用函数有的方法越多，出现歧义的可能性越高。当你的方法层级比这些简单的例子更加复杂时，就值得你花时间去仔细想想其他的方案。



下面我们会讨论特别的一些挑战和解决这些挑战的一些可选方法。



\hypertarget{17193104641044635373}{}


\subsection{元组和N元组参数}



\texttt{Tuple}（和\texttt{NTuple}）参数会带来特别的挑战。例如，




\begin{minted}{julia}
f(x::NTuple{N,Int}) where {N} = 1
f(x::NTuple{N,Float64}) where {N} = 2
\end{minted}



是有歧义的，因为存在\texttt{N == 0}的可能性：没有元素去确定\texttt{Int}还是\texttt{Float64}变体应该被调用。为了解决歧义，一个方法是为空元组定义方法：




\begin{minted}{julia}
f(x::Tuple{}) = 3
\end{minted}



作为一种选择，对于其中一个方法之外的所有的方法可以坚持元组中至少有一个元素：




\begin{minted}{julia}
f(x::NTuple{N,Int}) where {N} = 1           # this is the fallback
f(x::Tuple{Float64, Vararg{Float64}}) = 2   # this requires at least one Float64
\end{minted}



\hypertarget{2934107525015609338}{}


\subsection{正交化你的设计}



当你打算根据两个或更多的参数进行分派时，考虑一下，一个「包裹」函数是否会让设计简单一些。举个例子，与其编写多变量：




\begin{minted}{julia}
f(x::A, y::A) = ...
f(x::A, y::B) = ...
f(x::B, y::A) = ...
f(x::B, y::B) = ...
\end{minted}



不如考虑定义




\begin{minted}{julia}
f(x::A, y::A) = ...
f(x, y) = f(g(x), g(y))
\end{minted}



这里\texttt{g}把参数转变为类型\texttt{A}。这是更加普遍的\href{https://en.wikipedia.org/wiki/Orthogonality\_(programming)}{正交设计}原理的一个特别特殊的例子，在正交设计中不同的概念被分配到不同的方法中去。这里\texttt{g}最可能需要一个fallback定义




\begin{minted}{julia}
g(x::A) = x
\end{minted}



一个相关的方案使用\texttt{promote}来把\texttt{x}和\texttt{y}变成常见的类型：




\begin{minted}{julia}
f(x::T, y::T) where {T} = ...
f(x, y) = f(promote(x, y)...)
\end{minted}



One risk with this design is the possibility that if there is no suitable promotion method converting \texttt{x} and \texttt{y} to the same type, the second method will recurse on itself infinitely and trigger a stack overflow.



\hypertarget{2211158616759162982}{}


\subsection{一次只根据一个参数分派}



如果你你需要根据多个参数进行分派，并且有太多的为了能定义所有可能的变量而存在的组合，而存在很多回退函数，你可以考虑引入{\textquotedbl}名字级联{\textquotedbl}，这里（例如）你根据第一个参数分配然后调用一个内部的方法：




\begin{minted}{julia}
f(x::A, y) = _fA(x, y)
f(x::B, y) = _fB(x, y)
\end{minted}



接着内部方法\texttt{\_fA}和\texttt{\_fB}可以根据\texttt{y}进行分派，而不考虑有关\texttt{x}的歧义存在。



需要意识到这个方案至少有一个主要的缺点：在很多情况下，用户没有办法通过进一步定义你的输出函数\texttt{f}的具体行为来进一步定制\texttt{f}的行为。相反，他们需要去定义你的内部方法\texttt{\_fA}和\texttt{\_fB}的具体行为，这会模糊输出方法和内部方法之间的界线。



\hypertarget{7624993517486343641}{}


\subsection{抽象容器与元素类型}



在可能的情况下要试图避免定义根据抽象容器的具体元素类型来分派的方法。举个例子，




\begin{minted}{julia}
-(A::AbstractArray{T}, b::Date) where {T<:Date}
\end{minted}



会引起歧义，当定义了这个方法：




\begin{minted}{julia}
-(A::MyArrayType{T}, b::T) where {T}
\end{minted}



最好的方法是不要定义这些方法中的\emph{任何一个}。相反，使用范用方法\texttt{-(A::AbstractArray, b)}并确认这个方法是使用\emph{分别}对于每个容器类型和元素类型都是适用的通用调用(像\texttt{similar}和\texttt{-})实现的。这只是建议\hyperlink{1356336112225694303}{正交化}你的方法的一个更加复杂的变种而已。



当这个方法不可行时，这就值得与其他开发者开始讨论如果解决歧义；只是因为一个函数先定义并不总是意味着他不能改变或者被移除。作为最后一个手段，开发者可以定义{\textquotedbl}创可贴{\textquotedbl}方法




\begin{minted}{julia}
-(A::MyArrayType{T}, b::Date) where {T<:Date} = ...
\end{minted}



可以暴力解决歧义。



\hypertarget{5733743229509139145}{}


\subsection{与默认参数的复杂方法{\textquotedbl}级联{\textquotedbl}}



如果你定义了提供默认的方法{\textquotedbl}级联{\textquotedbl}，要小心去掉对应着潜在默认的任何参数。例如，假设你在写一个数字过滤算法，你有一个通过应用padding来出来信号的边的方法：




\begin{minted}{julia}
function myfilter(A, kernel, ::Replicate)
    Apadded = replicate_edges(A, size(kernel))
    myfilter(Apadded, kernel)  # now perform the "real" computation
end
\end{minted}



这会与提供默认padding的方法产生冲突：




\begin{minted}{julia}
myfilter(A, kernel) = myfilter(A, kernel, Replicate()) # replicate the edge by default
\end{minted}



这两个方法一起会生成无限的递归，\texttt{A}会不断变大。



更好的设计是像这样定义你的调用层级：




\begin{minted}{julia}
struct NoPad end # indicate that no padding is desired, or that it's already applied

myfilter(A, kernel) = myfilter(A, kernel, Replicate()) # default boundary conditions

function myfilter(A, kernel, ::Replicate)
 Apadded = replicate_edges(A, size(kernel))
 myfilter(Apadded, kernel, NoPad()) # indicate the new boundary conditions
end

# other padding methods go here

function myfilter(A, kernel, ::NoPad)
 # Here's the "real" implementation of the core computation
end
\end{minted}



\texttt{NoPad} 被置于与其他 padding 类型一致的参数位置上，这保持了分派层级的良好组织，同时降低了歧义的可能性。而且，它扩展了「公开」的 \texttt{myfilter} 接口：想要显式控制 padding 的用户可以直接调用 \texttt{NoPad} 变量。



\footnotetext[2]{Arthur C. Clarke, \emph{Profiles of the Future} (1961): Clarke{\textquotesingle}s Third Law.

}


\hypertarget{17317810227993044854}{}


\chapter{构造函数}



构造函数 \footnotemark[1] 是用来创建新对象的函数 – 确切地说，它创建的是\hyperlink{4168730090950432836}{复合类型}的实例。在 Julia 中，类型对象也同时充当构造函数的角色：可以用类名加参数元组的方式像函数调用一样来创建新实例。这一点在介绍复合类型（Composite Types）时已经大致谈过了。例如：




\begin{minted}{jlcon}
julia> struct Foo
           bar
           baz
       end

julia> foo = Foo(1, 2)
Foo(1, 2)

julia> foo.bar
1

julia> foo.baz
2
\end{minted}



For many types, forming new objects by binding their field values together is all that is ever needed to create instances. However, in some cases more functionality is required when creating composite objects. Sometimes invariants must be enforced, either by checking arguments or by transforming them. \href{https://en.wikipedia.org/wiki/Recursion\_\%28computer\_science\%29\#Recursive\_data\_structures\_.28structural\_recursion.29}{Recursive data structures}, especially those that may be self-referential, often cannot be constructed cleanly without first being created in an incomplete state and then altered programmatically to be made whole, as a separate step from object creation. Sometimes, it{\textquotesingle}s just convenient to be able to construct objects with fewer or different types of parameters than they have fields. Julia{\textquotesingle}s system for object construction addresses all of these cases and more.



\footnotetext[1]{Nomenclature: while the term {\textquotedbl}constructor{\textquotedbl} generally refers to the entire function which constructs objects of a type, it is common to abuse terminology slightly and refer to specific constructor methods as {\textquotedbl}constructors{\textquotedbl}. In such situations, it is generally clear from the context that the term is used to mean {\textquotedbl}constructor method{\textquotedbl} rather than {\textquotedbl}constructor function{\textquotedbl}, especially as it is often used in the sense of singling out a particular method of the constructor from all of the others.

}


\hypertarget{8095711241800911617}{}


\section{Outer Constructor Methods}



A constructor is just like any other function in Julia in that its overall behavior is defined by the combined behavior of its methods. Accordingly, you can add functionality to a constructor by simply defining new methods. For example, let{\textquotesingle}s say you want to add a constructor method for \texttt{Foo} objects that takes only one argument and uses the given value for both the \texttt{bar} and \texttt{baz} fields. This is simple:




\begin{minted}{jlcon}
julia> Foo(x) = Foo(x,x)
Foo

julia> Foo(1)
Foo(1, 1)
\end{minted}



你也可以为 \texttt{Foo} 添加新的零参数构造方法，它为 \texttt{bar} 和 \texttt{baz} 提供默认值：




\begin{minted}{jlcon}
julia> Foo() = Foo(0)
Foo

julia> Foo()
Foo(0, 0)
\end{minted}



Here the zero-argument constructor method calls the single-argument constructor method, which in turn calls the automatically provided two-argument constructor method. For reasons that will become clear very shortly, additional constructor methods declared as normal methods like this are called \emph{outer} constructor methods. Outer constructor methods can only ever create a new instance by calling another constructor method, such as the automatically provided default ones.



\hypertarget{3020780065533340945}{}


\section{Inner Constructor Methods}



While outer constructor methods succeed in addressing the problem of providing additional convenience methods for constructing objects, they fail to address the other two use cases mentioned in the introduction of this chapter: enforcing invariants, and allowing construction of self-referential objects. For these problems, one needs \emph{inner} constructor methods. An inner constructor method is like an outer constructor method, except for two differences:



\begin{itemize}
\item[1. ] It is declared inside the block of a type declaration, rather than outside of it like normal methods.


\item[2. ] It has access to a special locally existent function called \hyperlink{13888762393600028594}{\texttt{new}} that creates objects of the block{\textquotesingle}s type.

\end{itemize}


For example, suppose one wants to declare a type that holds a pair of real numbers, subject to the constraint that the first number is not greater than the second one. One could declare it like this:




\begin{minted}{jlcon}
julia> struct OrderedPair
           x::Real
           y::Real
           OrderedPair(x,y) = x > y ? error("out of order") : new(x,y)
       end
\end{minted}



现在 \texttt{OrderedPair} 对象只能在 \texttt{x <= y} 时被成功构造：




\begin{minted}{jlcon}
julia> OrderedPair(1, 2)
OrderedPair(1, 2)

julia> OrderedPair(2,1)
ERROR: out of order
Stacktrace:
 [1] error at ./error.jl:33 [inlined]
 [2] OrderedPair(::Int64, ::Int64) at ./none:4
 [3] top-level scope
\end{minted}



如果类型被声明为 \texttt{mutable}，你可以直接更改字段值来打破这个固有属性，然而，在未经允许的情况下，随意摆弄对象的内核一般都是不好的行为。你（或者其他人）可以在以后任何时候提供额外的外部构造方法，但一旦类型被声明了，就没有办法来添加更多的内部构造方法了。由于外部构造方法只能通过调用其它的构造方法来创建对象，所以最终构造对象的一定是某个内部构造函数。这保证了已声明类型的对象必须通过调用该类型的内部构造方法才得已存在，从而在某种程度上保证了类型的固有属性。



只要定义了任何一个内部构造方法，Julia 就不会再提供默认的构造方法：它会假定你已经为自己提供了所需的所有内部构造方法。默认构造方法等效于一个你自己编写的内部构造函数，该函数将所有成员作为参数（如果相应的字段具有类型，则约束为正确的类型），并将它们传递给 \texttt{new}，最后返回结果对象：




\begin{minted}{jlcon}
julia> struct Foo
           bar
           baz
           Foo(bar,baz) = new(bar,baz)
       end

\end{minted}



这个声明与前面没有显式内部构造方法的 \texttt{Foo} 类型的定义效果相同。 以下两个类型是等价的 – 一个具有默认构造方法，另一个具有显式构造方法：




\begin{minted}{jlcon}
julia> struct T1
           x::Int64
       end

julia> struct T2
           x::Int64
           T2(x) = new(x)
       end

julia> T1(1)
T1(1)

julia> T2(1)
T2(1)

julia> T1(1.0)
T1(1)

julia> T2(1.0)
T2(1)
\end{minted}



提供尽可能少的内部构造方法是一种良好的形式：仅在需要显式地处理所有参数，以及强制执行必要的错误检查和转换时候才使用内部构造。其它用于提供便利的构造方法，比如提供默认值或辅助转换，应该定义为外部构造函数，然后再通过调用内部构造函数来执行繁重的工作。这种解耦是很自然的。



\hypertarget{7871769496419060352}{}


\section{不完整初始化}



最后一个还没提到的问题是，如何构造具有自引用的对象，更广义地来说是构造递归数据结构。由于这其中的困难并不是那么显而易见，这里我们来简单解释一下，考虑如下的递归类型声明：




\begin{minted}{jlcon}
julia> mutable struct SelfReferential
           obj::SelfReferential
       end

\end{minted}



这种类型可能看起来没什么大不了，直到我们考虑如何来构造它的实例。 如果 \texttt{a} 是 \texttt{SelfReferential} 的一个实例，则第二个实例可以用如下的调用来创建：




\begin{minted}{jlcon}
julia> b = SelfReferential(a)
\end{minted}



但是，当没有实例存在的情况下，即没有可以传递给 \texttt{obj} 成员变量的有效值时，如何构造第一个实例？唯一的解决方案是允许使用未初始化的 \texttt{obj} 成员来创建一个未完全初始化的 \texttt{SelfReferential} 实例，并使用该不完整的实例作为另一个实例的 \texttt{obj} 成员的有效值，例如，它本身。



为了允许创建未完全初始化的对象，Julia 允许使用少于该类型成员数的参数来调用 \href{@ ref}{\texttt{new}} 函数，并返回一个具有某个未初始化成员的对象。然后，内部构造函数可以使用不完整的对象，在返回之前完成初始化。例如，我们在定义 \texttt{SelfReferential} 类型时采用了另一个方法，使用零参数内部构造函数来返回一个实例，此实例的 \texttt{obj} 成员指向其自身：




\begin{minted}{jlcon}
julia> mutable struct SelfReferential
           obj::SelfReferential
           SelfReferential() = (x = new(); x.obj = x)
       end

\end{minted}



我们可以验证这一构造函数有效性，且由其构造的对象确实是自引用的：




\begin{minted}{jlcon}
julia> x = SelfReferential();

julia> x === x
true

julia> x === x.obj
true

julia> x === x.obj.obj
true
\end{minted}



虽然从一个内部构造函数中返回一个完全初始化的对象是很好的，但是也可以返回未完全初始化的对象：




\begin{minted}{jlcon}
julia> mutable struct Incomplete
           data
           Incomplete() = new()
       end

julia> z = Incomplete();
\end{minted}



尽管允许创建含有未初始化成员的对象，然而任何对未初始化引用的访问都会立即报错：




\begin{minted}{jlcon}
julia> z.data
ERROR: UndefRefError: access to undefined reference
\end{minted}



这避免了不断地检测 \texttt{null} 值的需要。然而，并不是所有的对象成员都是引用。Julia 会将一些类型当作纯数据（{\textquotedbl}plain data{\textquotedbl}），这意味着它们的数据是自包含的，并且没有引用其它对象。这些纯数据包括原始类型（比如 \texttt{Int} ）和由其它纯数据类型构成的不可变结构体。纯数据类型的初始值是未定义的：




\begin{minted}{jlcon}
julia> struct HasPlain
           n::Int
           HasPlain() = new()
       end

julia> HasPlain()
HasPlain(438103441441)
\end{minted}



由纯数据组成的数组也具有一样的行为。



在内部构造函数中，你可以将不完整的对象传递给其它函数来委托其补全构造：




\begin{minted}{jlcon}
julia> mutable struct Lazy
           data
           Lazy(v) = complete_me(new(), v)
       end
\end{minted}



与构造函数返回的不完整对象一样，如果 \texttt{complete\_me} 或其任何被调用者尝试在初始化之前访问 \texttt{Lazy} 对象的 \texttt{data} 字段，就会立刻报错。



\hypertarget{12775137678629941390}{}


\section{参数类型的构造函数}



参数类型的存在为构造函数增加了更多的复杂性。首先，让我们回顾一下\hyperlink{5603543911318150609}{参数类型}。在默认情况下，我们可以用两种方法来实例化参数复合类型，一种是显式地提供类型参数，另一种是让 Julia 根据构造函数输入参数的类型来隐式地推导类型参数。这里有一些例子：




\begin{minted}{jlcon}
julia> struct Point{T<:Real}
           x::T
           y::T
       end

julia> Point(1,2) ## 隐式的 T ##
Point{Int64}(1, 2)

julia> Point(1.0,2.5) ## 隐式的 T ##
Point{Float64}(1.0, 2.5)

julia> Point(1,2.5) ## implicit T ##
ERROR: MethodError: no method matching Point(::Int64, ::Float64)
Closest candidates are:
  Point(::T, ::T) where T<:Real at none:2

julia> Point{Int64}(1, 2) ## 显式的 T ##
Point{Int64}(1, 2)

julia> Point{Int64}(1.0,2.5) ## 显式的 T ##
ERROR: InexactError: Int64(2.5)
Stacktrace:
[...]

julia> Point{Float64}(1.0, 2.5) ## 显式的 T ##
Point{Float64}(1.0, 2.5)

julia> Point{Float64}(1,2) ## 显式的 T ##
Point{Float64}(1.0, 2.0)
\end{minted}



就像你看到的那样，用类型参数显式地调用构造函数，其参数会被转换为指定的类型：\texttt{Point\{Int64\}(1,2)} 可以正常工作，但是 \texttt{Point\{Int64\}(1.0,2.5)} 则会在将 \texttt{2.5} 转换为 \hyperlink{7720564657383125058}{\texttt{Int64}} 的时候报一个 \hyperlink{5399118524830636312}{\texttt{InexactError}}。当类型是从构造函数的参数隐式推导出来的时候，比如在例子 \texttt{Point(1,2)} 中，输入参数的类型必须一致，否则就无法确定 \texttt{T} 是什么，但 \texttt{Point} 的构造函数仍可以适配任意同类型的实数对。



实际上，这里的 \texttt{Point}，\texttt{Point\{Float64\}} 以及 \texttt{Point\{Int64\}} 是不同的构造函数。\texttt{Point\{T\}} 表示对于每个类型 \texttt{T} 都存在一个不同的构造函数。如果不显式提供内部构造函数，在声明复合类型 \texttt{Point\{T<:Real\}} 的时候，Julia 会对每个满足 \texttt{T<:Real} 条件的类型都提供一个默认的内部构造函数 \texttt{Point\{T\}}，它们的行为与非参数类型的默认内部构造函数一致。Julia 同时也会提供了一个通用的外部构造函数 \texttt{Point}，用于适配任意同类型的实数对。Julia 默认提供的构造函数等价于下面这种显式的声明：




\begin{minted}{jlcon}
julia> struct Point{T<:Real}
           x::T
           y::T
           Point{T}(x,y) where {T<:Real} = new(x,y)
       end

julia> Point(x::T, y::T) where {T<:Real} = Point{T}(x,y);
\end{minted}



注意，每个构造函数定义的方式与调用它们的方式是一样的。调用 \texttt{Point\{Int64\}(1,2)} 会触发 \texttt{struct} 块内部的 \texttt{Point\{T\}(x,y)}。另一方面，外部构造函数声明的 \texttt{Point} 构造函数只会被同类型的实数对触发，它使得我们可以直接以 \texttt{Point(1,2)} 和 \texttt{Point(1.0,2.5)} 这种方式来创建实例，而不需要显示地使用类型参数。由于此方法的声明方式已经对输入参数的类型施加了约束，像 \texttt{Point(1,2.5)} 这种调用自然会导致 {\textquotedbl}no method{\textquotedbl} 错误。



假如我们想让 \texttt{Point(1,2.5)} 这种调用方式正常工作，比如，通过将整数 \texttt{1} 自动「提升」为浮点数 \texttt{1.0}，最简单的方法是像下面这样定义一个额外的外部构造函数：




\begin{minted}{jlcon}
julia> Point(x::Int64, y::Float64) = Point(convert(Float64,x),y);
\end{minted}



此方法采用了 \hyperlink{1846942650946171605}{\texttt{convert}} 函数，显式地将 \texttt{x} 转化成了 \hyperlink{5027751419500983000}{\texttt{Float64}} 类型，之后再委托前面讲到的那个通用的外部构造函数来进行具体的构造工作，经过转化，两个参数的类型都是 \hyperlink{5027751419500983000}{\texttt{Float64}}，所以可以正确构造出一个 \texttt{Point\{Float64\}} 对象，而不会像之前那样触发 \hyperlink{68769522931907606}{\texttt{MethodError}}。




\begin{minted}{jlcon}
julia> Point(1,2.5)
Point{Float64}(1.0, 2.5)

julia> typeof(ans)
Point{Float64}
\end{minted}



然而，其它类似的调用依然有问题：




\begin{minted}{jlcon}
julia> Point(1.5,2)
ERROR: MethodError: no method matching Point(::Float64, ::Int64)
Closest candidates are:
  Point(::T, !Matched::T) where T<:Real at none:1
\end{minted}



如果你想要找到一种方法可以使类似的调用都可以正常工作，请参阅\hyperlink{10374023657104680331}{类型转换与类型提升}。这里稍稍“剧透”一下，我们可以利用下面的这个外部构造函数来满足需求，无论输入参数的类型如何，它都可以触发通用的 \texttt{Point} 构造函数：




\begin{minted}{jlcon}
julia> Point(x::Real, y::Real) = Point(promote(x,y)...);
\end{minted}



这里的 \texttt{promote} 函数会将它的输入转化为同一类型，在此例中是 \hyperlink{5027751419500983000}{\texttt{Float64}}。定义了这个方法，\texttt{Point} 构造函数会自动提升输入参数的类型，且提升机制与算术运算符相同，比如 \hyperlink{3677358729494553841}{\texttt{+}}，因此对所有的实数输入参数都适用：




\begin{minted}{jlcon}
julia> Point(1.5,2)
Point{Float64}(1.5, 2.0)

julia> Point(1,1//2)
Point{Rational{Int64}}(1//1, 1//2)

julia> Point(1.0,1//2)
Point{Float64}(1.0, 0.5)
\end{minted}



所以，即使 Julia 提供的默认内部构造函数对于类型参数的要求非常严格，我们也有方法将其变得更加易用。正因为构造函数可以充分发挥类型系统、方法以及多重分派的作用，定义复杂的行为也会变得非常简单。



\hypertarget{4347124195691244322}{}


\section{案例分析：分数的实现}



上文主要讲了关于参数复合类型及其构造函数的一些零散内容，或许将这些内容结合起来的一个最佳方法是分析一个真实的案例。为此，我们来实现一个我们自己的分数类型 \texttt{OurRational}，它与 Julia 内置的分数类型 \hyperlink{8304566144531167610}{\texttt{Rational}} 很相似，它的定义在 \href{https://github.com/JuliaLang/julia/blob/master/base/rational.jl}{\texttt{rational.jl}} 里：




\begin{minted}{jlcon}
julia> struct OurRational{T<:Integer} <: Real
           num::T
           den::T
           function OurRational{T}(num::T, den::T) where T<:Integer
               if num == 0 && den == 0
                    error("invalid rational: 0//0")
               end
               g = gcd(den, num)
               num = div(num, g)
               den = div(den, g)
               new(num, den)
           end
       end

julia> OurRational(n::T, d::T) where {T<:Integer} = OurRational{T}(n,d)
OurRational

julia> OurRational(n::Integer, d::Integer) = OurRational(promote(n,d)...)
OurRational

julia> OurRational(n::Integer) = OurRational(n,one(n))
OurRational

julia> ⊘(n::Integer, d::Integer) = OurRational(n,d)
⊘ (generic function with 1 method)

julia> ⊘(x::OurRational, y::Integer) = x.num ⊘ (x.den*y)
⊘ (generic function with 2 methods)

julia> ⊘(x::Integer, y::OurRational) = (x*y.den) ⊘ y.num
⊘ (generic function with 3 methods)

julia> ⊘(x::Complex, y::Real) = complex(real(x) ⊘ y, imag(x) ⊘ y)
⊘ (generic function with 4 methods)

julia> ⊘(x::Real, y::Complex) = (x*y') ⊘ real(y*y')
⊘ (generic function with 5 methods)

julia> function ⊘(x::Complex, y::Complex)
           xy = x*y'
           yy = real(y*y')
           complex(real(xy) ⊘ yy, imag(xy) ⊘ yy)
       end
⊘ (generic function with 6 methods)
\end{minted}



第一行 – \texttt{struct OurRational\{T<:Integer\} <: Real} – 声明了 \texttt{OurRational} 会接收一个整数类型的类型参数，且它自己属于实数类型。它声明了两个成员：\texttt{num::T} 和 \texttt{den::T}。这表明一个 \texttt{OurRational\{T\}} 的实例中会包含一对整数，且类型为 \texttt{T}，其中一个表示分子，另一个表示分母。



现在事情开始变得有意思了，\texttt{OurRational} 只有一个内部构造函数，它的作用是检查 \texttt{num} 和 \texttt{den} 是否为 0，并确保构建的每个分数都是经过约分化简的形式，且分母为非负数。这可以令分子和分母同时除以它们的最大公约数来实现，最大公约数可以用 Julia 内置的 \texttt{gcd} 函数计算。由于 \texttt{gcd} 返回的最大公约数的符号是跟第一个参数 \texttt{den} 一致的，所以约分后一定会保证 \texttt{den} 的值为非负数。因为这是 \texttt{OurRational} 的唯一一个内部构造函数，所以我们可以确保构建出的 \texttt{OurRational} 对象一定是这种化简的形式。



为了方便，\texttt{OurRational} 也提供了一些其它的外部构造函数。第一个外部构造函数是“标准的”通用构造函数，当分子和分母的类型一致时，它就可以推导出类型参数 \texttt{T}。第二个外部构造函数可以用于分子和分母的类型不一致的情景，它会将分子和分母的类型提升至一个共同的类型，然后再委托第一个外部构造函数进行构造。第三个构造函数会将一个整数转化为分数，方法是将 1 当作分母。



在定义了外部构造函数之后，我们为 \texttt{⊘} 算符定义了一系列的方法，之后就可以使用 \texttt{⊘} 算符来写分数，比如 \texttt{1 ⊘ 2}。Julia 的 \texttt{Rational} 类型采用的是 \hyperlink{17539582191808611917}{\texttt{//}} 算符。在做上述定义之前，\texttt{⊘} 是一个无意的且未被定义的算符。它的行为与在\hyperlink{30883190695696392}{有理数}一节中描述的一致，注意它的所有行为都是那短短几行定义的。第一个也是最基础的定义只是将 \texttt{a ⊘ b} 中的 \texttt{a} 和 \texttt{b} 当作参数传递给 \texttt{OurRational} 的构造函数来实例化 \texttt{OurRational}，当然这要求 \texttt{a} 和 \texttt{b} 分别都是整数。在 \texttt{⊘} 的某个操作数已经是分数的情况下，我们采用了一个有点不一样的方法来构建新的分数，这实际上等价于用分数除以一个整数。最后，我们也可以让 \texttt{⊘} 作用于复数，用来创建一个类型为 \texttt{Complex\{OurRational\}} 的对象，即一个实部和虚部都是分数的复数：




\begin{minted}{jlcon}
julia> z = (1 + 2im) ⊘ (1 - 2im);

julia> typeof(z)
Complex{OurRational{Int64}}

julia> typeof(z) <: Complex{OurRational}
false
\end{minted}



因此，尽管 \texttt{⊘} 算符通常会返回一个 \texttt{OurRational} 的实例，但倘若其中一个操作数是复整数，那么就会返回 \texttt{Complex\{OurRational\}}。感兴趣的话可以读一读 \href{https://github.com/JuliaLang/julia/blob/master/base/rational.jl}{\texttt{rational.jl}}：它实现了一个完整的 Julia 基本类型，但却非常的简短，而且是自包涵的。



\hypertarget{11047482593881141721}{}


\section{Outer-only constructors}



正如我们所看到的，典型的参数类型都有一个内部构造函数，它仅在全部的类型参数都已知的情况下才会被调用。例如，可以用 \texttt{Point\{Int\}} 调用，但\texttt{Point} 就不行。我们可以选择性的添加外部构造函数来自动推导并添加类型参数，比如，调用 \texttt{Point(1,2)} 来构造 \texttt{Point\{Int\}}。外部构造函数调用内部构造函数来实际创建实例。然而，在某些情况下，我们可能并不想要内部构造函数，从而达到禁止手动指定类型参数的目的。



例如，假设我们要定义一个类型用于存储数组以及其累加和：




\begin{minted}{jlcon}
julia> struct SummedArray{T<:Number,S<:Number}
           data::Vector{T}
           sum::S
       end

julia> SummedArray(Int32[1; 2; 3], Int32(6))
SummedArray{Int32,Int32}(Int32[1, 2, 3], 6)
\end{minted}



问题在于我们想让 \texttt{S} 的类型始终比 \texttt{T} 大，这样做是为了确保累加过程不会丢失信息。例如，当 \texttt{T} 是 \hyperlink{10103694114785108551}{\texttt{Int32}} 时，我们想让 \texttt{S} 是 \hyperlink{7720564657383125058}{\texttt{Int64}}。所以我们想要一种接口来禁止用户创建像 \texttt{SummedArray\{Int32,Int32\}} 这种类型的实例。一种实现方式是只提供一个 \texttt{SummedArray} 构造函数，当需要将其放入 \texttt{struct}-block 中，从而不让 Julia 提供默认的构造函数：




\begin{minted}{jlcon}
julia> struct SummedArray{T<:Number,S<:Number}
           data::Vector{T}
           sum::S
           function SummedArray(a::Vector{T}) where T
               S = widen(T)
               new{T,S}(a, sum(S, a))
           end
       end

julia> SummedArray(Int32[1; 2; 3], Int32(6))
ERROR: MethodError: no method matching SummedArray(::Array{Int32,1}, ::Int32)
Closest candidates are:
  SummedArray(::Array{T,1}) where T at none:4
\end{minted}



此构造函数将会被 \texttt{SummedArray(a)} 这种写法触发。\texttt{new\{T,S\}} 的这种写法允许指定待构建类型的参数，也就是说调用它会返回一个 \texttt{SummedArray\{T,S\}} 的实例。\texttt{new\{T,S\}} 也可以用于其它构造函数的定义中，但为了方便，Julia 会根据正在构造的类型自动推导出 \texttt{new\{\}} 花括号里的参数（如果可行的话）。



\hypertarget{10686378388163930476}{}


\chapter{类型转换和类型提升}



Julia 有一个提升系统，可以将数学运算符的参数提升为通用类型，如在前面章节中提到的\hyperlink{8249022581856827126}{整数和浮点数}、\hyperlink{16865688524696028421}{数学运算和初等函数}、\hyperlink{8510890508040013186}{类型}和\hyperlink{3842379394166369470}{方法}。在本节中，我们将解释类型提升系统如何工作，以及如何将其扩展到新的类型，并将其应用于除内置数学运算符之外的其他函数。传统上，编程语言在参数的类型提升上分为两大阵营:



\begin{itemize}
\item \textbf{内置数学类型和运算符的自动类型提升。}大多数语言中，内置数值类型，当作为带有中缀语法的算术运算符的操作数时，例如 \texttt{+}、\texttt{-}、\texttt{*} 和 \texttt{/} 将自动提升为通用类型，以产生预期的结果。举例来说，C、Java、Perl 和 Python，都将 \texttt{1 + 1.5} 的和作为浮点值 \texttt{2.5}，即使 \texttt{+} 的一个操作数是整数。这些系统非常方便且设计得足够精细，以至于它对于程序员来讲通常是不可见的：在编写这样的表达式时，几乎没有人有意识地想到这种类型提升，但编译器和解释器必须在相加前执行转换，因为整数和浮点值无法按原样相加。因此，这种自动类型转换的复杂规则不可避免地是这些语言的规范和实现的一部分。


\item \textbf{没有自动类型提升。}这个阵营包括 Ada 和 ML——非常「严格的」 静态类型语言。在这些语言中，每个类型转换都必须由程序员明确指定。因此，示例表达式 \texttt{1 + 1.5} 在 Ada 和 ML 中都会导致编译错误。相反地，必须编写 \texttt{real(1) + 1.5}，来在执行加法前将整数 \texttt{1} 显式转换为浮点值。然而，处处都显式转换是如此地不方便，以至于连 Ada 也有一定程度的自动类型转换：整数字面量被类型提升为预期的整数类型，浮点字面量同样被类型提升为适当的浮点类型。

\end{itemize}


在某种意义上，Julia 属于「无自动类型提升」类别：数学操作符只是具有特殊语法的函数，函数的参数永远不会自动转换。然而，人们可能会发现数学运算能应用于各种混合的参数类型，但这只是多态的多重分派的极端情况——这是 Julia 的分派和类型系统特别适合处理的情况。数学操作数的「自动」类型提升只是作为一个特殊的应用出现：Julia 带有预定义的数学运算符的 catch-all 分派规则，其在某些操作数类型的组合没有特定实现时调用。这些 catch-all 分派规则首先使用用户可定义的类型提升规则将所有操作数提升到一个通用的类型，然后针对结果值（现在已属于相同类型）调用相关运算符的特定实现。用户定义的类型可简单地加入这个类型提升系统，这需要先定义与其它类型进行相互类型转换的方法，接着提供一些类型提升规则来定义与其它类型混合时应该提升到什么类型。



\hypertarget{5183188243565893084}{}


\section{类型转换}



The standard way to obtain a value of a certain type \texttt{T} is to call the type{\textquotesingle}s constructor, \texttt{T(x)}. However, there are cases where it{\textquotesingle}s convenient to convert a value from one type to another without the programmer asking for it explicitly. One example is assigning a value into an array: if \texttt{A} is a \texttt{Vector\{Float64\}}, the expression \texttt{A[1] = 2} should work by automatically converting the \texttt{2} from \texttt{Int} to \texttt{Float64}, and storing the result in the array. This is done via the \hyperlink{1846942650946171605}{\texttt{convert}} function.



\texttt{convert} 函数通常接受两个参数：第一个是类型对象，第二个是需要转换为该类型的值。返回的是已转换后的值。理解这个函数最简单的办法就是尝试：




\begin{minted}{jlcon}
julia> x = 12
12

julia> typeof(x)
Int64

julia> convert(UInt8, x)
0x0c

julia> typeof(ans)
UInt8

julia> convert(AbstractFloat, x)
12.0

julia> typeof(ans)
Float64

julia> a = Any[1 2 3; 4 5 6]
2×3 Array{Any,2}:
 1  2  3
 4  5  6

julia> convert(Array{Float64}, a)
2×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
\end{minted}



Conversion isn{\textquotesingle}t always possible, in which case a \hyperlink{68769522931907606}{\texttt{MethodError}} is thrown indicating that \texttt{convert} doesn{\textquotesingle}t know how to perform the requested conversion:




\begin{minted}{jlcon}
julia> convert(AbstractFloat, "foo")
ERROR: MethodError: Cannot `convert` an object of type String to an object of type AbstractFloat
[...]
\end{minted}



Some languages consider parsing strings as numbers or formatting numbers as strings to be conversions (many dynamic languages will even perform conversion for you automatically). This is not the case in Julia. Even though some strings can be parsed as numbers, most strings are not valid representations of numbers, and only a very limited subset of them are. Therefore in Julia the dedicated \hyperlink{14207407853646164654}{\texttt{parse}} function must be used to perform this operation, making it more explicit.



\hypertarget{7039772400060801175}{}


\subsection{什么时候使用 \texttt{convert} 函数?}



构造以下语言结构时需要调用 \texttt{convert} 函数：



\begin{itemize}
\item 对一个数组赋值会转换为数组元素的类型。


\item 对一个对象的字段赋值会转换为已声明的字段类型。


\item Constructing an object with \hyperlink{13888762393600028594}{\texttt{new}} converts to the object{\textquotesingle}s declared field types.


\item 对已声明类型的变量赋值（例如 \texttt{local x::T}）会转换为该类型。


\item 已声明返回类型的函数会转换其返回值为该类型。


\item Passing a value to \hyperlink{14245046751182637566}{\texttt{ccall}} converts it to the corresponding argument type.

\end{itemize}


\hypertarget{11541557100875125079}{}


\subsection{类型转换与构造}



注意到 \texttt{convert(T, x)} 的行为似乎与 \texttt{T(x)} 几乎相同，它的确通常是这样。但是，有一个关键的语义差别：因为 \texttt{convert} 能被隐式调用，所以它的方法仅限于被认为是「安全」或「意料之内」的情况。\texttt{convert} 只会在表示事物的相同基本种类的类型之间进行转换（例如，不同的数字表示和不同的字符串编码）。它通常也是无损的；将值转换为其它类型并再次转换回去应该产生完全相同的值。



这是四种一般的构造函数与 \texttt{convert} 不同的情况：



\hypertarget{17931790162561418365}{}


\subsubsection{与其参数类型无关的类型的构造函数}



一些构造函数没有体现「转换」的概念。例如，\texttt{Timer(2)} 创建一个时长 2 秒的定时器，它实际上并不是从整数到定时器的「转换」。



\hypertarget{8367796589961400339}{}


\subsubsection{可变的集合}



如果 \texttt{x} 类型已经为 \texttt{T}，\texttt{convert(T, x)} 应该返回原本的 \texttt{x}。相反地，如果 \texttt{T} 是一个可变的集合类型，那么 \texttt{T(x)} 应该总是创建一个新的集合（从 \texttt{x} 复制元素）。



\hypertarget{13864114731640700485}{}


\subsubsection{封装器类型}



对于某些「封装」其它值的类型，构造函数可能会将其参数封装在一个新对象中，即使它已经是所请求的类型。例如，用 \texttt{Some(x)} 表示封装了一个 \texttt{x} 值（在上下文中，其结果可能是一个 \texttt{Some} 或 \texttt{nothing}）。但是，\texttt{x} 本身可能是对象 \texttt{Some(y)}，在这种情况下，结果为 \texttt{Some(Some(y))}，封装了两层。然而，\texttt{convert(Some, x)} 只会返回 \texttt{x}，因为它已经是 \texttt{Some} 的实例了。



\hypertarget{1440871335026577968}{}


\subsubsection{不返回自身类型的实例的构造函数}



在\emph{极少见}的情况下，构造函数 \texttt{T(x)} 返回一个类型不为 \texttt{T} 的对象是有意义的。如果封装器类型是它自身的反转（例如 \texttt{Flip(Flip(x)) === x}），或者在重构库时为了支持某个旧的调用语法以实现向后兼容，则可能发生这种情况。但是，\texttt{convert(T, x)} 应该总是返回一个类型为 \texttt{T} 的值。



\hypertarget{16585115796165922811}{}


\subsection{定义新的类型转换}



在定义新类型时，最初创建它的所有方法都应定义为构造函数。如果隐式类型转换很明显是有用的，并且某些构造函数满足上面的「安全」标准，那么可以考虑添加 \texttt{convert} 方法。这些方法通常非常简单，因为它们只需要调用适当的构造函数。此类定义可能会像这样：




\begin{minted}{julia}
convert(::Type{MyType}, x) = MyType(x)
\end{minted}



此方法的第一个参数的类型是\hyperlink{14008188290941962431}{单态类型} \texttt{Type\{MyType\}}，其唯一实例是 \texttt{MyType}。因此，此方法仅在第一个参数是类型值 \texttt{MyType} 时才被调用。请注意第一个参数使用的语法：在 \texttt{::} 符号之前省略了参数名，只是给出了参数类型。这是 Julia 中用于函数参数的语法，该参数的类型已经指定，但其值无需通过名称引用。在此例中，由于参数类型是单态类型，我们已经知道其值而无需引用参数名称。



某些抽象类型的所有实例默认都被认为是「足够相似的」，在 Julia Base 中也提供了通用的 \texttt{convert} 定义。例如，这个定义声明通过调用单参数构造函数将任何 \texttt{Number} 类型 \texttt{convert} 为其它任何 \texttt{Number} 类型是有效的：




\begin{minted}{julia}
convert(::Type{T}, x::Number) where {T<:Number} = T(x)
\end{minted}



这意味着新的 \texttt{Number} 类型只需要定义构造函数，因为此定义将为它们处理 \texttt{convert}。在参数已经是所请求的类型的情况下，用恒同变换来处理 \texttt{convert}。




\begin{minted}{julia}
convert(::Type{T}, x::T) where {T<:Number} = x
\end{minted}



Similar definitions exist for \texttt{AbstractString}, \hyperlink{6514416309183787338}{\texttt{AbstractArray}}, and \hyperlink{6373987858401217649}{\texttt{AbstractDict}}.



\hypertarget{701866407360133120}{}


\section{类型提升}



类型提升是指将一组混合类型的值转换为单个通用类型。尽管不是绝对必要的，但一般暗示被转换的值的通用类型可以忠实地表示所有原始值。此意义下，术语「类型提升」是合适的，因为值被转换为「更大」的类型——即能用一个通用类型表示所有输入值的类型。但重要的是，不要将它与面向对象（结构）超类或 Julia 的抽象超类型混淆：类型提升与类型层次结构无关，而与备选的表示之间的转换有关。例如，尽管每个 \hyperlink{10103694114785108551}{\texttt{Int32}} 值可以表示为 \hyperlink{5027751419500983000}{\texttt{Float64}} 值，但 \texttt{Int32} 不是 \texttt{Float64} 的子类型。



Promotion to a common {\textquotedbl}greater{\textquotedbl} type is performed in Julia by the \hyperlink{1760874576431605095}{\texttt{promote}} function, which takes any number of arguments, and returns a tuple of the same number of values, converted to a common type, or throws an exception if promotion is not possible. The most common use case for promotion is to convert numeric arguments to a common type:




\begin{minted}{jlcon}
julia> promote(1, 2.5)
(1.0, 2.5)

julia> promote(1, 2.5, 3)
(1.0, 2.5, 3.0)

julia> promote(2, 3//4)
(2//1, 3//4)

julia> promote(1, 2.5, 3, 3//4)
(1.0, 2.5, 3.0, 0.75)

julia> promote(1.5, im)
(1.5 + 0.0im, 0.0 + 1.0im)

julia> promote(1 + 2im, 3//4)
(1//1 + 2//1*im, 3//4 + 0//1*im)
\end{minted}



浮点值被提升为最大的浮点参数类型。整数值会被提升为本机机器字大小或最大的整数参数类型中较大的一个。整数和浮点值的混合会被提升为一个足以包含所有值的浮点类型。与有理数混合的整数会被提升有理数。与浮点数混合的有理数会被提升为浮点数。与实数值混合的复数值会被提升为合适类型的复数值。



这就是使用类型提升的全部内容。剩下的只是聪明的应用，最典型的「聪明」应用是数值操作（如 \texttt{+}、\texttt{-}、\texttt{*} 和 \texttt{/}）的 catch-all 方法的定义。以下是在 \href{https://github.com/JuliaLang/julia/blob/master/base/promotion.jl}{\texttt{promotion.jl}} 中给出的几个 catch-all 方法的定义：




\begin{minted}{julia}
+(x::Number, y::Number) = +(promote(x,y)...)
-(x::Number, y::Number) = -(promote(x,y)...)
*(x::Number, y::Number) = *(promote(x,y)...)
/(x::Number, y::Number) = /(promote(x,y)...)
\end{minted}



这些方法的定义表明，如果没有更特殊的规则来加、减、乘及除一对数值，则将这些值提升为通用类型并再试一次。这就是它的全部内容：在其它任何地方都不需要为数值操作担心到通用数值类型的类型提升——它会自动进行。许多算术和数学函数的 catch-all 类型提升方法的定义在 \href{https://github.com/JuliaLang/julia/blob/master/base/promotion.jl}{\texttt{promotion.jl}} 中，但除此之外，Julia Base 中几乎不再需要调用 \texttt{promote}。\texttt{promote} 最常用于外部构造方法中，为了更方便，可允许使用混合类型的构造函数调用委托给一个内部构造函数，并将字段提升为适当的通用类型。例如，回想一下，\href{https://github.com/JuliaLang/julia/blob/master/base/rational.jl}{\texttt{rational.jl}} 提供了以下外部构造方法：




\begin{minted}{julia}
Rational(n::Integer, d::Integer) = Rational(promote(n,d)...)
\end{minted}



这允许像下面这样的调用正常工作：




\begin{minted}{jlcon}
julia> Rational(Int8(15),Int32(-5))
-3//1

julia> typeof(ans)
Rational{Int32}
\end{minted}



对于大多数用户定义的类型，最好要求程序员明确地向构造函数提供期待的类型，但有时，尤其是对于数值问题，自动进行类型提升会很方便。



\hypertarget{13578530399861722948}{}


\subsection{定义类型提升规则}



Although one could, in principle, define methods for the \texttt{promote} function directly, this would require many redundant definitions for all possible permutations of argument types. Instead, the behavior of \texttt{promote} is defined in terms of an auxiliary function called \hyperlink{16547112220540026290}{\texttt{promote\_rule}}, which one can provide methods for. The \texttt{promote\_rule} function takes a pair of type objects and returns another type object, such that instances of the argument types will be promoted to the returned type. Thus, by defining the rule:




\begin{minted}{julia}
promote_rule(::Type{Float64}, ::Type{Float32}) = Float64
\end{minted}



one declares that when 64-bit and 32-bit floating-point values are promoted together, they should be promoted to 64-bit floating-point. The promotion type does not need to be one of the argument types. For example, the following promotion rules both occur in Julia Base:




\begin{minted}{julia}
promote_rule(::Type{BigInt}, ::Type{Float64}) = BigFloat
promote_rule(::Type{BigInt}, ::Type{Int8}) = BigInt
\end{minted}



在后一种情况下，输出类型是 \hyperlink{423405808990690832}{\texttt{BigInt}}，因为 \texttt{BigInt} 是唯一一个足以容纳任意精度整数运算结果的类型。还要注意，不需要同时定义 \texttt{promote\_rule(::Type\{A\}, ::Type\{B\})} 和 \texttt{promote\_rule(::Type\{B\}, ::Type\{A\})}——对称性隐含在类型提升过程中使用 \texttt{promote\_rule} 的方式。



The \texttt{promote\_rule} function is used as a building block to define a second function called \hyperlink{15048881762587391286}{\texttt{promote\_type}}, which, given any number of type objects, returns the common type to which those values, as arguments to \texttt{promote} should be promoted. Thus, if one wants to know, in absence of actual values, what type a collection of values of certain types would promote to, one can use \texttt{promote\_type}:




\begin{minted}{jlcon}
julia> promote_type(Int8, Int64)
Int64
\end{minted}



在内部，\texttt{promote\_type} 在 \texttt{promote} 中用于确定参数值应被转换为什么类型以便进行类型提升。但是，它本身可能是有用的。好奇的读者可以阅读 \href{https://github.com/JuliaLang/julia/blob/master/base/promotion.jl}{\texttt{promotion.jl}}，该文件用大概 35 行定义了完整的类型提升规则。



\hypertarget{8231690970182763012}{}


\subsection{案例研究：有理数的类型提升}



最后，我们来完成关于 Julia 的有理数类型的案例研究，该案例通过以下类型提升规则相对复杂地使用了类型提升机制：




\begin{minted}{julia}
promote_rule(::Type{Rational{T}}, ::Type{S}) where {T<:Integer,S<:Integer} = Rational{promote_type(T,S)}
promote_rule(::Type{Rational{T}}, ::Type{Rational{S}}) where {T<:Integer,S<:Integer} = Rational{promote_type(T,S)}
promote_rule(::Type{Rational{T}}, ::Type{S}) where {T<:Integer,S<:AbstractFloat} = promote_type(T,S)
\end{minted}



第一条规则说，使用其它整数类型类型提升有理数类型会得到个有理数类型，其分子/分母类型是使用其它整数类型提升该有理数分子/分母类型的结果。第二条规则将相同的逻辑应用于两种不同的有理数类型，它们进行类型提升会得到有理数类型，其分子/分母类型是它们各自的分子/分母类型进行提升的结果。第三个也是最后一个规则规定，使用浮点数类型提升有理数类型与使用该浮点数类型提升其分子/分母类型会产生相同的类型。



这一小部分的类型提升规则，连同该类型的构造函数和数字的默认 \texttt{convert} 方法，便足以使有理数与 Julia 的其它数值类型——整数、浮点数和复数——完全自然地互操作。通过以相同的方式提供类型转换方法和类型提升规则，任何用户定义的数值类型都可像 Julia 的预定义数值类型一样自然地进行互操作。



\hypertarget{5506253490972465797}{}


\chapter{接口}



Julia 的很多能力和扩展性都来自于一些非正式的接口。通过为自定义的类型扩展一些特定的方法，自定义类型的对象不但获得那些方法的功能，而且也能够用于其它的基于那些行为而定义的通用方法中。



\hypertarget{5510379658285713272}{}


\section{迭代}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
必需方法 &  & 简短描述 \\
\hline
\texttt{iterate(iter)} &  & 通常返回由第一项及其初始状态组成的元组，但如果为空，则返回 \hyperlink{9331422207248206047}{\texttt{nothing}} \\
\hline
\texttt{iterate(iter, state)} &  & 通常返回由下一项及其状态组成的元组，或者在没有下一项存在时返回 \texttt{nothing}。 \\
\hline
\textbf{重要可选方法} & \textbf{默认定义} & \textbf{简短描述} \\
\hline
\texttt{IteratorSize(IterType)} & \texttt{HasLength()} & \texttt{HasLength()}，\texttt{HasShape\{N\}()}，\texttt{IsInfinite()} 或者 \texttt{SizeUnknown()} 中合适的一个 \\
\hline
\texttt{IteratorEltype(IterType)} & \texttt{HasEltype()} & \texttt{EltypeUnknown()} 或 \texttt{HasEltype()} 中合适的一个 \\
\hline
\texttt{eltype(IterType)} & \texttt{Any} & 由 \texttt{iterate()} 返回元组中第一项的类型。 \\
\hline
\texttt{length(iter)} & (\emph{未定义}) & 项数，如果已知 \\
\hline
\texttt{size(iter, [dim])} & (\emph{未定义}) & 在各个维度上项数，如果已知 \\
\hline
\end{tabulary}

\end{table}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
由 \texttt{IteratorSize(IterType)} 返回的值 & 必需方法 \\
\hline
\texttt{HasLength()} & \hyperlink{3699181304419743826}{\texttt{length(iter)}} \\
\hline
\texttt{HasShape\{N\}()} & \texttt{length(iter)} 和 \texttt{size(iter, [dim])} \\
\hline
\texttt{IsInfinite()} & (\emph{无}) \\
\hline
\texttt{SizeUnknown()} & (\emph{无}) \\
\hline
\end{tabulary}

\end{table}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
由 \texttt{IteratorEltype(IterType)} 返回的值 & 必需方法 \\
\hline
\texttt{HasEltype()} & \texttt{eltype(IterType)} \\
\hline
\texttt{EltypeUnknown()} & (\emph{none}) \\
\hline
\end{tabulary}

\end{table}



顺序迭代由 \hyperlink{1722534687975587846}{\texttt{iterate}} 函数实现。 Julia 的迭代器可以从对象外部跟踪迭代状态，而不是在迭代过程中改变对象本身。 迭代过程中的返回一个包含了当前迭代值及其状态的元组，或者在没有元素存在的情况下返回 \texttt{nothing}。 状态对象将在下一次迭代时传递回 iterate 函数，并且通常被认为是可迭代对象的私有实现细节。



任何定义了这个函数的对象都是可迭代的，并且可以被应用到\hyperlink{16454089156260356769}{许多依赖迭代的函数上} 。 也可以直接被应用到  \hyperlink{9105224580875818383}{\texttt{for}} 循环中，因为根据语法：




\begin{minted}{julia}
for i in iter   # or  "for i = iter"
    # body
end
\end{minted}



以上代码被解释为：




\begin{minted}{julia}
next = iterate(iter)
while next !== nothing
    (i, state) = next
    # body
    next = iterate(iter, state)
end
\end{minted}



举一个简单的例子：一组定长数据的平方数迭代序列：




\begin{minted}{jlcon}
julia> struct Squares
           count::Int
       end

julia> Base.iterate(S::Squares, state=1) = state > S.count ? nothing : (state*state, state+1)
\end{minted}



仅仅定义了 \hyperlink{1722534687975587846}{\texttt{iterate}} 函数的 \texttt{Squares} 类型就已经很强大了。我们现在可以迭代所有的元素了：




\begin{minted}{jlcon}
julia> for i in Squares(7)
           println(i)
       end
1
4
9
16
25
36
49
\end{minted}



我们可以利用许多内置方法来处理迭代，比如标准库 \texttt{Statistics}  中的 \hyperlink{17277603976666670638}{\texttt{in}}，\hyperlink{15061550543970113934}{\texttt{mean}} 和 \hyperlink{1955374586742019663}{\texttt{std}} 。




\begin{minted}{jlcon}
julia> 25 in Squares(10)
true

julia> using Statistics

julia> mean(Squares(100))
3383.5

julia> std(Squares(100))
3024.355854282583
\end{minted}



我们可以扩展一些其它的方法，为 Julia 提供有关此可迭代集合的更多信息。我们知道 \texttt{Squares} 序列中的元素总是 \texttt{Int} 型的。通过扩展 \hyperlink{6396209842929672718}{\texttt{eltype}} 方法，我们可以给 Julia 更多信息来帮助其在更复杂的方法中生成更具体的代码。我们同时也知道该序列中的元素数目，故同样地也可以扩展 \hyperlink{9362803119463040896}{\texttt{length}}：




\begin{minted}{jlcon}
julia> Base.eltype(::Type{Squares}) = Int # Note that this is defined for the type

julia> Base.length(S::Squares) = S.count
\end{minted}



现在，当我们让 Julia 去 \hyperlink{6278865767444641812}{\texttt{collect}} 所有元素到一个数组中时，Julia 可以预分配一个适当大小的 \texttt{Vector\{Int\}}，而不是盲目地 \hyperlink{18026893834387542681}{\texttt{push!}} 每一个元素到 \texttt{Vector\{Any\}}：




\begin{minted}{jlcon}
julia> collect(Squares(4))
4-element Array{Int64,1}:
  1
  4
  9
 16
\end{minted}



尽管大多时候我们都可以依赖一些通用的实现，但某些时候，如果我们知道一个更简单的算法，可以用其扩展具体方法。例如，计算平方和有公式，因此可以扩展出一个更高效的解法来替代通用方法：




\begin{minted}{jlcon}
julia> Base.sum(S::Squares) = (n = S.count; return n*(n+1)*(2n+1)÷6)

julia> sum(Squares(1803))
1955361914
\end{minted}



这种模式在 Julia Base 中很常见，一些必须实现的方法构成了一个小的集合，从而定义出一个非正式的接口，用于实现一些更加炫酷的操作。某些应用场景中，一些类型有更高效的算法，故可以扩展出额外的专用方法。



能以\emph{逆序}迭代集合也很有用，这可由 \hyperlink{12943296479800134710}{\texttt{Iterators.reverse(iterator)}} 迭代实现。但是，为了实际支持逆序迭代，迭代器类型 \texttt{T} 需要为 \texttt{Iterators.Reverse\{T\}} 实现 \texttt{iterate}。（给定 \texttt{r::Iterators.Reverse\{T\}}，类型 \texttt{T} 的底层迭代器是 \texttt{r.itr}。）在我们的 \texttt{Squares} 示例中，我们可以实现 \texttt{Iterators.Reverse\{Squares\}} 方法：




\begin{minted}{jlcon}
julia> Base.iterate(rS::Iterators.Reverse{Squares}, state=rS.itr.count) = state < 1 ? nothing : (state*state, state-1)

julia> collect(Iterators.reverse(Squares(4)))
4-element Array{Int64,1}:
 16
  9
  4
  1
\end{minted}



\hypertarget{14566118977838625303}{}


\section{Indexing}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Methods to implement & Brief description \\
\hline
\texttt{getindex(X, i)} & \texttt{X[i]}, indexed element access \\
\hline
\texttt{setindex!(X, v, i)} & \texttt{X[i] = v}, indexed assignment \\
\hline
\texttt{firstindex(X)} & The first index, used in \texttt{X[begin]} \\
\hline
\texttt{lastindex(X)} & The last index, used in \texttt{X[end]} \\
\hline
\end{tabulary}

\end{table}



For the \texttt{Squares} iterable above, we can easily compute the \texttt{i}th element of the sequence by squaring it.  We can expose this as an indexing expression \texttt{S[i]}. To opt into this behavior, \texttt{Squares} simply needs to define \hyperlink{13720608614876840481}{\texttt{getindex}}:




\begin{minted}{jlcon}
julia> function Base.getindex(S::Squares, i::Int)
           1 <= i <= S.count || throw(BoundsError(S, i))
           return i*i
       end

julia> Squares(100)[23]
529
\end{minted}



Additionally, to support the syntax \texttt{S[begin]} and \texttt{S[end]}, we must define \hyperlink{16943669671291374223}{\texttt{firstindex}} and \hyperlink{15780929618270241785}{\texttt{lastindex}} to specify the first and last valid indices, respectively:




\begin{minted}{jlcon}
julia> Base.firstindex(S::Squares) = 1

julia> Base.lastindex(S::Squares) = length(S)

julia> Squares(23)[end]
529
\end{minted}



但请注意，上面只定义了带有一个整数索引的 \hyperlink{13720608614876840481}{\texttt{getindex}}。使用除 \texttt{Int} 外的任何值进行索引会抛出 \hyperlink{68769522931907606}{\texttt{MethodError}}，表示没有匹配的方法。为了支持使用某个范围内的 \texttt{Int} 或 \texttt{Int} 向量进行索引，必须编写单独的方法：




\begin{minted}{jlcon}
julia> Base.getindex(S::Squares, i::Number) = S[convert(Int, i)]

julia> Base.getindex(S::Squares, I) = [S[i] for i in I]

julia> Squares(10)[[3,4.,5]]
3-element Array{Int64,1}:
  9
 16
 25
\end{minted}



虽然这开始支持更多\hyperlink{16717190941363337071}{某些内置类型支持的索引操作}，但仍然有很多行为不支持。因为我们为 \texttt{Squares} 序列所添加的行为，它开始看起来越来越像向量。我们可以正式定义其为 \hyperlink{6514416309183787338}{\texttt{AbstractArray}} 的子类型，而不是自己定义所有这些行为。



\hypertarget{522338241536202486}{}


\section{抽象数组}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
需要实现的方法 &  & 简短描述 \\
\hline
\texttt{size(A)} &  & 返回包含 \texttt{A} 各维度大小的元组 \\
\hline
\texttt{getindex(A, i::Int)} &  & （若为 \texttt{IndexLinear}）线性标量索引 \\
\hline
\texttt{getindex(A, I::Vararg\{Int, N\})} &  & （若为 \texttt{IndexCartesian}，其中 \texttt{N = ndims(A)}）N 维标量索引 \\
\hline
\texttt{setindex!(A, v, i::Int)} &  & （若为 \texttt{IndexLinear}）线性索引元素赋值 \\
\hline
\texttt{setindex!(A, v, I::Vararg\{Int, N\})} &  & （若为 \texttt{IndexCartesian}，其中 \texttt{N = ndims(A)}）N 维标量索引元素赋值 \\
\hline
\textbf{可选方法} & \textbf{默认定义} & \textbf{简短描述} \\
\hline
\texttt{IndexStyle(::Type)} & \texttt{IndexCartesian()} & 返回 \texttt{IndexLinear()} 或 \texttt{IndexCartesian()}。请参阅下文描述。 \\
\hline
\texttt{getindex(A, I...)} & 基于标量 \texttt{getindex} 定义 & \hyperlink{16717190941363337071}{多维非标量索引} \\
\hline
\texttt{setindex!(A, X, I...)} & 基于标量 \texttt{setindex!} 定义 & \hyperlink{16717190941363337071}{多维非标量索引元素赋值} \\
\hline
\texttt{iterate} & 基于标量 \texttt{getindex} 定义 & Iteration \\
\hline
\texttt{length(A)} & \texttt{prod(size(A))} & 元素数 \\
\hline
\texttt{similar(A)} & \texttt{similar(A, eltype(A), size(A))} & 返回具有相同形状和元素类型的可变数组 \\
\hline
\texttt{similar(A, ::Type\{S\})} & \texttt{similar(A, S, size(A))} & 返回具有相同形状和指定元素类型的可变数组 \\
\hline
\texttt{similar(A, dims::Dims)} & \texttt{similar(A, eltype(A), dims)} & 返回具有相同元素类型和大小为 \emph{dims} 的可变数组 \\
\hline
\texttt{similar(A, ::Type\{S\}, dims::Dims)} & \texttt{Array\{S\}(undef, dims)} & 返回具有指定元素类型及大小的可变数组 \\
\hline
\textbf{不遵循惯例的索引} & \textbf{默认定义} & \textbf{简短描述} \\
\hline
\texttt{axes(A)} & \texttt{map(OneTo, size(A))} & 返回有效索引的 \texttt{AbstractUnitRange} \\
\hline
\texttt{similar(A, ::Type\{S\}, inds)} & \texttt{similar(A, S, Base.to\_shape(inds))} & 返回使用特殊索引 \texttt{inds} 的可变数组（详见下文） \\
\hline
\texttt{similar(T::Union\{Type,Function\}, inds)} & \texttt{T(Base.to\_shape(inds))} & 返回类似于 \texttt{T} 的使用特殊索引 \texttt{inds} 的数组（详见下文） \\
\hline
\end{tabulary}

\end{table}



如果一个类型被定义为 \texttt{AbstractArray} 的子类型，那它就继承了一大堆丰富的行为，包括构建在单元素访问之上的迭代和多维索引。有关更多支持的方法，请参阅文档 \hyperlink{16720099245556932994}{多维数组} 及 \hyperlink{3951748617092839742}{Julia Base}。



定义 \texttt{AbstractArray} 子类型的关键部分是 \hyperlink{7782790551324367092}{\texttt{IndexStyle}}。由于索引是数组的重要部分且经常出现在 hot loops 中，使索引和索引赋值尽可能高效非常重要。数组数据结构通常以两种方式定义：要么仅使用一个索引（即线性索引）来最高效地访问其元素，要么实际上使用由各个维度确定的索引访问其元素。这两种方式被 Julia 标记为 \texttt{IndexLinear()} 和 \texttt{IndexCartesian()}。把线性索引转换为多重索引下标通常代价高昂，因此这提供了基于 traits 机制，以便能为所有矩阵类型提供高效的通用代码。



此区别决定了该类型必须定义的标量索引方法。\texttt{IndexLinear()} 很简单：只需定义 \texttt{getindex(A::ArrayType, i::Int)}。当数组后用多维索引集进行索引时，回退 \texttt{getindex(A::AbstractArray, I...)()} 高效地将该索引转换为线性索引，然后调用上述方法。另一方面，\texttt{IndexCartesian()} 数组需要为每个支持的、使用 \texttt{ndims(A)} 个 \texttt{Int} 索引的维度定义方法。例如，\texttt{SparseArrays} 标准库里的 \hyperlink{15099699527958384292}{\texttt{SparseMatrixCSC}} 只支持二维，所以它只定义了 \texttt{getindex(A::SparseMatrixCSC, i::Int, j::Int)}。\hyperlink{1309244355901386657}{\texttt{setindex!}} 也是如此。



回到上面的平方数序列，我们可以将它定义为 \texttt{AbstractArray\{Int, 1\}} 的子类型：




\begin{minted}{jlcon}
julia> struct SquaresVector <: AbstractArray{Int, 1}
           count::Int
       end

julia> Base.size(S::SquaresVector) = (S.count,)

julia> Base.IndexStyle(::Type{<:SquaresVector}) = IndexLinear()

julia> Base.getindex(S::SquaresVector, i::Int) = i*i
\end{minted}



请注意，指定 \texttt{AbstractArray} 的两个参数非常重要；第一个参数定义了 \hyperlink{6396209842929672718}{\texttt{eltype}}，第二个则定义了 \hyperlink{1688406579181746010}{\texttt{ndims}}。该超类型和这三个方法就足以使 \texttt{SquaresVector} 变成一个可迭代、可索引且功能齐全的数组：




\begin{minted}{jlcon}
julia> s = SquaresVector(4)
4-element SquaresVector:
  1
  4
  9
 16

julia> s[s .> 8]
2-element Array{Int64,1}:
  9
 16

julia> s + s
4-element Array{Int64,1}:
  2
  8
 18
 32

julia> sin.(s)
4-element Array{Float64,1}:
  0.8414709848078965
 -0.7568024953079282
  0.4121184852417566
 -0.2879033166650653
\end{minted}



作为一个更复杂的例子，让我们在 \hyperlink{3089397136845322041}{\texttt{Dict}} 之上定义自己的玩具性质的 N 维稀疏数组类型。




\begin{minted}{jlcon}
julia> struct SparseArray{T,N} <: AbstractArray{T,N}
           data::Dict{NTuple{N,Int}, T}
           dims::NTuple{N,Int}
       end

julia> SparseArray(::Type{T}, dims::Int...) where {T} = SparseArray(T, dims);

julia> SparseArray(::Type{T}, dims::NTuple{N,Int}) where {T,N} = SparseArray{T,N}(Dict{NTuple{N,Int}, T}(), dims);

julia> Base.size(A::SparseArray) = A.dims

julia> Base.similar(A::SparseArray, ::Type{T}, dims::Dims) where {T} = SparseArray(T, dims)

julia> Base.getindex(A::SparseArray{T,N}, I::Vararg{Int,N}) where {T,N} = get(A.data, I, zero(T))

julia> Base.setindex!(A::SparseArray{T,N}, v, I::Vararg{Int,N}) where {T,N} = (A.data[I] = v)
\end{minted}



请注意，这是个 \texttt{IndexCartesian} 数组，因此我们必须在数组的维度上手动定义 \hyperlink{13720608614876840481}{\texttt{getindex}} 和 \hyperlink{1309244355901386657}{\texttt{setindex!}}。与 \texttt{SquaresVector} 不同，我们可以定义 \hyperlink{1309244355901386657}{\texttt{setindex!}}，这样便能更改数组：




\begin{minted}{jlcon}
julia> A = SparseArray(Float64, 3, 3)
3×3 SparseArray{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0

julia> fill!(A, 2)
3×3 SparseArray{Float64,2}:
 2.0  2.0  2.0
 2.0  2.0  2.0
 2.0  2.0  2.0

julia> A[:] = 1:length(A); A
3×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
 3.0  6.0  9.0
\end{minted}



索引 \texttt{AbstractArray} 的结果本身可以是数组（例如，在使用 \texttt{AbstractRange} 时）。\texttt{AbstractArray} 回退方法使用 \hyperlink{15525808546723795098}{\texttt{similar}} 来分配具有适当大小和元素类型的 \texttt{Array}，该数组使用上述的基本索引方法填充。但是，在实现数组封装器时，你通常希望也封装结果：




\begin{minted}{jlcon}
julia> A[1:2,:]
2×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
\end{minted}



在此例中，创建合适的封装数组通过定义 \texttt{Base.similar\{T\}(A::SparseArray, ::Type\{T\}, dims::Dims)} 来实现。（请注意，虽然 \texttt{similar} 支持 1 参数和 2 参数形式，但在大多数情况下，你只需要专门定义 3 参数形式。）为此，\texttt{SparseArray} 是可变的（支持 \texttt{setindex!}）便很重要。为 \texttt{SparseArray} 定义 \texttt{similar}、\texttt{getindex} 和 \texttt{setindex!} 也使得该数组能够 \hyperlink{15665284441316555522}{\texttt{copy}} 。




\begin{minted}{jlcon}
julia> copy(A)
3×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
 3.0  6.0  9.0
\end{minted}



除了上面的所有可迭代和可索引方法之外，这些类型还能相互交互，并使用在 Julia Base 中为 \texttt{AbstractArray} 定义的大多数方法：




\begin{minted}{jlcon}
julia> A[SquaresVector(3)]
3-element SparseArray{Float64,1}:
 1.0
 4.0
 9.0

julia> sum(A)
45.0
\end{minted}



如果要定义允许非传统索引（索引以 1 之外的数字开始）的数组类型，你应该专门指定 \hyperlink{7074821531920287868}{\texttt{axes}}。你也应该专门指定 \hyperlink{15525808546723795098}{\texttt{similar}}，以便 \texttt{dims} 参数（通常是大小为 \texttt{Dims} 的元组）可以接收 \texttt{AbstractUnitRange} 对象，它也许是你自己设计的 range 类型 \texttt{Ind}。有关更多信息，请参阅\hyperlink{1238988360302116626}{使用自定义索引的数组}。



\hypertarget{2800090857858949975}{}


\section{Strided 数组}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
需要实现的方法 &  & 简短描述 \\
\hline
\texttt{strides(A)} &  & 返回每个维度中相邻元素之间的内存距离（以内存元素数量的形式）组成的元组。如果 \texttt{A} 是 \texttt{AbstractArray\{T,0\}}，这应该返回空元组。 \\
\hline
\texttt{Base.unsafe\_convert(::Type\{Ptr\{T\}\}, A)} &  & 返回数组的本地内存地址。 \\
\hline
\textbf{可选方法} & \textbf{默认定义} & \textbf{简短描述} \\
\hline
\texttt{stride(A, i::Int)} & \texttt{strides(A)[i]} & 返回维度 i（译注：原文为 k）上相邻元素之间的内存距离（以内存元素数量的形式）。 \\
\hline
\end{tabulary}

\end{table}



Strided 数组是 \texttt{AbstractArray} 的子类型，其条目以固定步长储存在内存中。如果数组的元素类型与 BLAS 兼容，则 strided 数组可以利用 BLAS 和 LAPACK 例程来实现更高效的线性代数例程。用户定义的 strided 数组的典型示例是把标准 \texttt{Array} 用附加结构进行封装的数组。



警告：如果底层存储实际上不是 strided，则不要实现这些方法，因为这可能导致错误的结果或段错误。



下面是一些示例，用来演示哪些数组类型是 strided 数组，哪些不是：




\begin{minted}{julia}
1:5   # not strided (there is no storage associated with this array.)
Vector(1:5)  # is strided with strides (1,)
A = [1 5; 2 6; 3 7; 4 8]  # is strided with strides (1,4)
V = view(A, 1:2, :)   # is strided with strides (1,4)
V = view(A, 1:2:3, 1:2)   # is strided with strides (2,4)
V = view(A, [1,2,4], :)   # is not strided, as the spacing between rows is not fixed.
\end{minted}



\hypertarget{8927705294232715192}{}


\section{自定义广播}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
需要实现的方法 & 简短描述 \\
\hline
\texttt{Base.BroadcastStyle(::Type\{SrcType\}) = SrcStyle()} & \texttt{SrcType} 的广播行为 \\
\hline
\texttt{Base.similar(bc::Broadcasted\{DestStyle\}, ::Type\{ElType\})} & 输出容器的分配 \\
\hline
\textbf{可选方法} &  \\
\hline
\texttt{Base.BroadcastStyle(::Style1, ::Style2) = Style12()} & 混合广播风格的优先级规则 \\
\hline
\texttt{Base.axes(x)} & 用于广播的 \texttt{x} 的索引的声明（默认为 \hyperlink{7074821531920287868}{\texttt{axes(x)}}） \\
\hline
\texttt{Base.broadcastable(x)} & 将 \texttt{x} 转换为一个具有 \texttt{axes} 且支持索引的对象 \\
\hline
\textbf{绕过默认机制} &  \\
\hline
\texttt{Base.copy(bc::Broadcasted\{DestStyle\})} & \texttt{broadcast} 的自定义实现 \\
\hline
\texttt{Base.copyto!(dest, bc::Broadcasted\{DestStyle\})} & 专门针对 \texttt{DestStyle} 的自定义 \texttt{broadcast!} 实现 \\
\hline
\texttt{Base.copyto!(dest::DestType, bc::Broadcasted\{Nothing\})} & 专门针对 \texttt{DestStyle} 的自定义 \texttt{broadcast!} 实现 \\
\hline
\texttt{Base.Broadcast.broadcasted(f, args...)} & 覆盖融合表达式中的默认惰性行为 \\
\hline
\texttt{Base.Broadcast.instantiate(bc::Broadcasted\{DestStyle\})} & 覆盖惰性广播的 axes 的计算 \\
\hline
\end{tabulary}

\end{table}



\hyperlink{10888979137852348176}{广播}可由 \texttt{broadcast} 或 \texttt{broadcast!} 的显式调用、或者像 \texttt{A .+ b} 或 \texttt{f.(x, y)} 这样的「点」操作隐式触发。任何具有 \hyperlink{7074821531920287868}{\texttt{axes}} 且支持索引的对象都可作为参数参与广播，默认情况下，广播结果储存在 \texttt{Array} 中。这个基本框架可通过三个主要方式扩展：



\begin{itemize}
\item 确保所有参数都支持广播


\item 为给定参数集选择合适的输出数组


\item 为给定参数集选择高效的实现

\end{itemize}


不是所有类型都支持 \texttt{axes} 和索引，但许多类型便于支持广播。\hyperlink{3229213625072672556}{\texttt{Base.broadcastable}} 函数会在每个广播参数上调用，它能返回与广播参数不同的支持 \texttt{axes} 和索引的对象。默认情况下，对于所有 \texttt{AbstractArray} 和 \texttt{Number} 来说这是 identity 函数——因为它们已经支持 \texttt{axes} 和索引了。少数其它类型（包括但不限于类型本身、函数、像 \hyperlink{14596725676261444434}{\texttt{missing}} 和 \hyperlink{9331422207248206047}{\texttt{nothing}} 这样的特殊单态类型以及日期）为了能被广播，\texttt{Base.broadcastable} 会返回封装在 \texttt{Ref} 的参数来充当 0 维「标量」。自定义类型可以类似地指定 \texttt{Base.broadcastable} 来定义其形状，但是它们应当遵循 \texttt{collect(Base.broadcastable(x)) == collect(x)} 的约定。一个值得注意的例外是 \texttt{AbstractString}；字符串是个特例，为了能被广播其表现为标量，尽管它们是其字符的可迭代集合（详见 \href{@id man-strings}{字符串}）。



接下来的两个步骤（选择输出数组和实现）依赖于如何确定给定参数集的唯一解。广播必须接受其参数的所有不同类型，并把它们折叠到一个输出数组和实现。广播称此唯一解为「风格」。每个可广播对象都有自己的首选风格，并使用类似于类型提升的系统将这些风格组合成一个唯一解——「目标风格」。



\hypertarget{5448969838863032993}{}


\subsection{广播风格}



抽象类型 \texttt{Base.BroadcastStyle} 派生了所有的广播风格。其在用作函数时有两种可能的形式，分别为一元形式（单参数）和二元形式。使用一元形式表明你打算实现特定的广播行为和/或输出类型，并且不希望依赖于默认的回退 \hyperlink{5203521679854231580}{\texttt{Broadcast.DefaultArrayStyle}}。



为了覆盖这些默认值，你可以为对象自定义 \texttt{BroadcastStyle}：




\begin{minted}{julia}
struct MyStyle <: Broadcast.BroadcastStyle end
Base.BroadcastStyle(::Type{<:MyType}) = MyStyle()
\end{minted}



在某些情况下，无需定义 \texttt{MyStyle} 也许很方便，在这些情况下，你可以利用一个通用的广播封装器：



\begin{itemize}
\item \texttt{Base.BroadcastStyle(::Type\{<:MyType\}) = Broadcast.Style\{MyType\}()} 可用于任意类型。


\item 如果 \texttt{MyType} 是一个 \texttt{AbstractArray}，首选是 \texttt{Base.BroadcastStyle(::Type\{<:MyType\}) = Broadcast.ArrayStyle\{MyType\}()}。


\item 对于只支持某个具体维度的 \texttt{AbstractArrays}，请创建 \texttt{Broadcast.AbstractArrayStyle\{N\}} 的子类型（请参阅下文）。

\end{itemize}


当你的广播操作涉及多个参数，各个广播风格将合并，来确定唯一一个 \texttt{DestStyle} 以控制输出容器的类型。有关更多详细信息，请参阅\hyperlink{17567878480973592299}{下文}。



\hypertarget{4710253435053989143}{}


\subsection{选择合适的输出数组}



每个广播操作都会计算广播风格以便支持派发和专门化。结果数组的实际分配由 \texttt{similar} 处理，其使用 Broadcasted 对象作为其第一个参数。




\begin{minted}{julia}
Base.similar(bc::Broadcasted{DestStyle}, ::Type{ElType})
\end{minted}



回退定义是




\begin{minted}{julia}
similar(bc::Broadcasted{DefaultArrayStyle{N}}, ::Type{ElType}) where {N,ElType} =
    similar(Array{ElType}, axes(bc))
\end{minted}



但是，如果需要，你可以专门化任何或所有这些参数。最后的参数 \texttt{bc} 是（还可能是融合的）广播操作的惰性表示，即 \texttt{Broadcasted} 对象。出于这些目的，该封装器中最重要的字段是 \texttt{f} 和 \texttt{args}，分别描述函数和参数列表。请注意，参数列表可以——并且经常——包含其它嵌套的 \texttt{Broadcasted} 封装器。



举个完整的例子，假设你创建了类型 \texttt{ArrayAndChar}，该类型存储一个数组和单个字符：




\begin{minted}{julia}
struct ArrayAndChar{T,N} <: AbstractArray{T,N}
    data::Array{T,N}
    char::Char
end
Base.size(A::ArrayAndChar) = size(A.data)
Base.getindex(A::ArrayAndChar{T,N}, inds::Vararg{Int,N}) where {T,N} = A.data[inds...]
Base.setindex!(A::ArrayAndChar{T,N}, val, inds::Vararg{Int,N}) where {T,N} = A.data[inds...] = val
Base.showarg(io::IO, A::ArrayAndChar, toplevel) = print(io, typeof(A), " with char '", A.char, "'")
\end{minted}



你可能想要保留「元数据」\texttt{char}。为此，我们首先定义




\begin{minted}{julia}
Base.BroadcastStyle(::Type{<:ArrayAndChar}) = Broadcast.ArrayStyle{ArrayAndChar}()
\end{minted}



这意味着我们还必须定义相应的 \texttt{similar} 方法：




\begin{minted}{julia}
function Base.similar(bc::Broadcast.Broadcasted{Broadcast.ArrayStyle{ArrayAndChar}}, ::Type{ElType}) where ElType
    # Scan the inputs for the ArrayAndChar:
    A = find_aac(bc)
    # Use the char field of A to create the output
    ArrayAndChar(similar(Array{ElType}, axes(bc)), A.char)
end

"`A = find_aac(As)` returns the first ArrayAndChar among the arguments."
find_aac(bc::Base.Broadcast.Broadcasted) = find_aac(bc.args)
find_aac(args::Tuple) = find_aac(find_aac(args[1]), Base.tail(args))
find_aac(x) = x
find_aac(::Tuple{}) = nothing
find_aac(a::ArrayAndChar, rest) = a
find_aac(::Any, rest) = find_aac(rest)
\end{minted}



在这些定义中，可以得到以下行为：




\begin{minted}{jlcon}
julia> a = ArrayAndChar([1 2; 3 4], 'x')
2×2 ArrayAndChar{Int64,2} with char 'x':
 1  2
 3  4

julia> a .+ 1
2×2 ArrayAndChar{Int64,2} with char 'x':
 2  3
 4  5

julia> a .+ [5,10]
2×2 ArrayAndChar{Int64,2} with char 'x':
  6   7
 13  14
\end{minted}



\hypertarget{5201970122303370123}{}


\subsection{使用自定义实现扩展广播}



一般来说，广播操作由一个惰性 \texttt{Broadcasted} 容器表示，该容器保存要应用的函数及其参数。这些参数可能本身是嵌套得更深的 \texttt{Broadcasted} 容器，并一起形成了一个待求值的大型表达式树。嵌套的 \texttt{Broadcasted} 容器树可由隐式的点语法直接构造；例如，\texttt{5 .+ 2.*x} 由 \texttt{Broadcasted(+, 5, Broadcasted(*, 2, x))} 暂时表示。这对于用户是不可见的，因为它是通过调用 \texttt{copy} 立即实现的，但是此容器为自定义类型的作者提供了广播可扩展性的基础。然后，内置的广播机制将根据参数确定结果的类型和大小，为它分配内存，并最终通过默认的 \texttt{copyto!(::AbstractArray, ::Broadcasted)} 方法将 \texttt{Broadcasted} 对象复制到其中。内置的回退 \texttt{broadcast} 和 \texttt{broadcast!} 方法类似地构造操作的暂时 \texttt{Broadcasted} 表示，因此它们共享相同的代码路径。这便允许自定义的数组实现通过提供它们自己的专门化 \texttt{copyto!} 来定义和优化广播。这再次由计算后的广播风格确定。此广播风格在广播操作中非常重要，以至于它被存储为 \texttt{Broadcasted} 类型的第一个类型参数，且允许派发和专门化。



对于某些类型，跨越层层嵌套的广播的「融合」操作无法实现，或者无法更高效地逐步完成。在这种情况下，你可能需要或者想要求值 \texttt{x .* (x .+ 1)}，就好像该式已被编写成 \texttt{broadcast(*, x, broadcast(+, x, 1))}，其中内部广播操作会在处理外部广播操作前进行求值。这种直接的操作以有点间接的方式得到直接支持；Julia 不会直接构造 \texttt{Broadcasted} 对象，而会将 待融合的表达式 \texttt{x .* (x .+ 1)} 降低为 \texttt{Broadcast.broadcasted(*, x, Broadcast.broadcasted(+, x, 1))}。现在，默认情况下，\texttt{broadcasted} 只会调用 \texttt{Broadcasted} 构造函数来创建待融合表达式树的惰性表示，但是你可以选择为函数和参数的特定组合覆盖它。



举个例子，内置的 \texttt{AbstractRange} 对象使用此机制优化广播表达式的片段，这些表达式片段可以只根据 start、step 和 length（或 stop）直接进行求值，而无需计算每个元素。与所有其它机制一样，\texttt{broadcasted} 也会计算并暴露其参数的组合广播风格，所以你可以为广播风格、函数和参数的任意组合专门化 \texttt{broadcasted(::DestStyle, f, args...)}，而不是专门化 \texttt{broadcasted(f, args...)}。



例如，以下定义支持 range 的负运算：




\begin{minted}{julia}
broadcasted(::DefaultArrayStyle{1}, ::typeof(-), r::OrdinalRange) = range(-first(r), step=-step(r), length=length(r))
\end{minted}



\hypertarget{13437862742050583795}{}


\subsection{扩展 in-place 广播}



In-place 广播可通过定义合适的 \texttt{copyto!(dest, bc::Broadcasted)} 方法来支持。由于你可能想要专门化 \texttt{dest} 或 \texttt{bc} 的特定子类型，为了避免包之间的歧义，我们建议采用以下约定。



如果你想要专门化特定的广播风格 \texttt{DestStyle}，请为其定义一个方法




\begin{minted}{julia}
copyto!(dest, bc::Broadcasted{DestStyle})
\end{minted}



你可选择使用此形式，如果使用，你还可以专门化 \texttt{dest} 的类型。



如果你想专门化目标类型 \texttt{DestType} 而不专门化 \texttt{DestStyle}，那么你应该定义一个带有以下签名的方法：




\begin{minted}{julia}
copyto!(dest::DestType, bc::Broadcasted{Nothing})
\end{minted}



这利用了 \texttt{copyto!} 的回退实现，它将该封装器转换为一个 \texttt{Broadcasted\{Nothing\}} 对象。因此，专门化 \texttt{DestType} 的方法优先级低于专门化 \texttt{DestStyle} 的方法。



同样，你可以使用 \texttt{copy(::Broadcasted)} 方法完全覆盖 out-of-place 广播。



\hypertarget{2171470859232296256}{}


\subsubsection{使用 \texttt{Broadcasted} 对象}



当然，为了实现这样的 \texttt{copy} 或 \texttt{copyto!} 方法，你必须使用 \texttt{Broadcasted} 封装器来计算每个元素。这主要有两种方式：



\begin{itemize}
\item \texttt{Broadcast.flatten} 将可能的嵌套操作重新计算为单个函数并平铺参数列表。你自己负责实现广播形状规则，但这在有限的情况下可能会有所帮助。


\item 迭代 \texttt{axes(::Broadcasted)} 的 \texttt{CartesianIndices} 并使用所生成的 \texttt{CartesianIndex} 对象的索引来计算结果。

\end{itemize}


\hypertarget{13308248870533973226}{}


\subsection{编写二元广播规则}



广播风格的优先级规则由二元 \texttt{BroadcastStyle} 调用定义：




\begin{minted}{julia}
Base.BroadcastStyle(::Style1, ::Style2) = Style12()
\end{minted}



其中，\texttt{Style12} 是你要为输出所选择的 \texttt{BroadcastStyle}，所涉及的参数具有 \texttt{Style1} 及 \texttt{Style2}。例如，




\begin{minted}{julia}
Base.BroadcastStyle(::Broadcast.Style{Tuple}, ::Broadcast.AbstractArrayStyle{0}) = Broadcast.Style{Tuple}()
\end{minted}



表示 \texttt{Tuple}「胜过」零维数组（输出容器将是元组）。值得注意的是，你不需要（也不应该）为此调用的两个参数顺序下定义；无论用户提供的以何种顺序提供参数，定义一个就够了。



对于 \texttt{AbstractArray} 类型，定义 \texttt{BroadcastStyle} 将取代回退选择 \hyperlink{5203521679854231580}{\texttt{Broadcast.DefaultArrayStyle}}。\texttt{DefaultArrayStyle} 及其抽象超类型 \texttt{AbstractArrayStyle} 将维度存储为类型参数，以支持具有固定维度需求的特定数组类型。



由于以下方法，\texttt{DefaultArrayStyle}「输给」任何其它已定义的 \texttt{AbstractArrayStyle}：




\begin{minted}{julia}
BroadcastStyle(a::AbstractArrayStyle{Any}, ::DefaultArrayStyle) = a
BroadcastStyle(a::AbstractArrayStyle{N}, ::DefaultArrayStyle{N}) where N = a
BroadcastStyle(a::AbstractArrayStyle{M}, ::DefaultArrayStyle{N}) where {M,N} =
    typeof(a)(_max(Val(M),Val(N)))
\end{minted}



除非你想要为两个或多个非 \texttt{DefaultArrayStyle} 的类型建立优先级，否则不需要编写二元 \texttt{BroadcastStyle} 规则。



如果你的数组类型确实有固定的维度需求，那么你应该定义一个 \texttt{AbstractArrayStyle} 的子类型。例如，稀疏数组的代码中有以下定义：




\begin{minted}{julia}
struct SparseVecStyle <: Broadcast.AbstractArrayStyle{1} end
struct SparseMatStyle <: Broadcast.AbstractArrayStyle{2} end
Base.BroadcastStyle(::Type{<:SparseVector}) = SparseVecStyle()
Base.BroadcastStyle(::Type{<:SparseMatrixCSC}) = SparseMatStyle()
\end{minted}



每当你定义一个 \texttt{AbstractArrayStyle} 的子类型，你还需要定义用于组合维度的规则，这通过为你的广播风格创建带有一个 \texttt{Val(N)} 参数的构造函数。例如：




\begin{minted}{julia}
SparseVecStyle(::Val{0}) = SparseVecStyle()
SparseVecStyle(::Val{1}) = SparseVecStyle()
SparseVecStyle(::Val{2}) = SparseMatStyle()
SparseVecStyle(::Val{N}) where N = Broadcast.DefaultArrayStyle{N}()
\end{minted}



这些规则表明 \texttt{SparseVecStyle} 与 0 维或 1 维数组的组合会产生另一个 \texttt{SparseVecStyle}，与 2 维数组的组合会产生 \texttt{SparseMatStyle}，而与维度更高的数组则回退到任意维密集矩阵的框架中。这些规则允许广播为产生一维或二维输出的操作保持其稀疏表示，但为任何其它维度生成 \texttt{Array}。



\hypertarget{10438697863683890874}{}


\chapter{模块}



Julia 中的模块（module）是一些互相隔离的可变工作空间，也就是说它们会引入新的全局作用域。它们在语法上以 \texttt{module Name ... end} 界定。模块允许你创建顶层定义（也称为全局变量），而无需担心命名冲突。在模块中，利用导入（importing），你可以控制其它模块中的哪些名称是可见的；利用导出（exporting），你可以控制你自己的模块中的哪些名称是公开的。



下面的示例演示了模块的主要功能。它不是为了运行，只是为了方便说明：




\begin{minted}{julia}
module MyModule
using Lib

using BigLib: thing1, thing2

import Base.show

export MyType, foo

struct MyType
    x
end

bar(x) = 2x
foo(a::MyType) = bar(a.x) + 1

show(io::IO, a::MyType) = print(io, "MyType $(a.x)")
end
\end{minted}



注意，模块中的代码样式不需要缩进，否则的话，会导致整个文件缩进。



上面的模块定义了一个 \texttt{MyType} 类型，以及两个函数，其中，函数 \texttt{foo} 和类型 \texttt{MyType} 被导出了，因而可以被导入到其它模块，而函数 \texttt{bar} 是模块 \texttt{MyModule} 的私有函数。



\texttt{using Lib} 意味着一个名称为 \texttt{Lib} 的模块会在需要的时候用于解释变量名。当一个全局变量在当前模块中没有定义时，系统就会从 \texttt{Lib} 中导出的变量中搜索该变量，如果找到了的话，就导入进来。也就是说，当前模块中，所有使用该全局变量的地方都会解释为 \texttt{Lib} 中对应的变量。



代码 \texttt{using BigLib: thing1, thing2} 显式地将标识符 \texttt{thing1} 和 \texttt{thing2} 从模块 \texttt{BigLib} 中引入到当前作用域。如果这两个变量是函数的话，则\textbf{不允许}给它们增加新的方法，毕竟代码里写的是 {\textquotedbl}using{\textquotedbl}（使用）它们，而不是扩展它们。



\hyperlink{16252475688663093021}{\texttt{import}} 关键字所支持的语法与 \hyperlink{169458112978175560}{\texttt{using}} 一致。 它并不会像 \texttt{using} 那样将模块添加到搜索空间中。 与 \texttt{using} 不同，\texttt{import} 引入的函数 \textbf{可以} 为其增加新的方法。



前面的 \texttt{MyModule} 模块中，我们希望给 \hyperlink{14071376285304310153}{\texttt{show}} 函数增加一个方法，需要写成 \texttt{import Base.show}。如果用 \texttt{using} 的话，就不能扩展 \texttt{show} 函数。通过 \texttt{using} 导入才可见的名字是不能被扩展的。



一旦一个变量通过 \texttt{using} 或 \texttt{import} 引入，当前模块就不能创建同名的变量了。而且导入的变量是只读的，给全局变量赋值只能影响到由当前模块拥有的变量，否则会报错。



\hypertarget{14242284106617888119}{}


\section{模块用法摘要}



要导入一个模块，可以用 \texttt{using} 或 \texttt{import} 关键字。为了更好地理解它们的区别，请参考下面的例子：




\begin{minted}{julia}
module MyModule

export x, y

x() = "x"
y() = "y"
p() = "p"

end
\end{minted}



这个模块用关键字 \texttt{export} 导出了 \texttt{x} 和 \texttt{y} 函数，此外还有一个没有被导出的函数 \texttt{p}。想要将该模块及其内部的函数导入当前模块有以下方法：




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
导入代码 & 当前作用域导入了哪些变量？ & 可增加新方法的名字 \\
\hline
\texttt{using MyModule} & All \texttt{export}ed names (\texttt{x} and \texttt{y}), \texttt{MyModule.x}, \texttt{MyModule.y} and \texttt{MyModule.p} & \texttt{MyModule.x}, \texttt{MyModule.y} and \texttt{MyModule.p} \\
\hline
\texttt{using MyModule: x, p} & \texttt{x} and \texttt{p} &  \\
\hline
\texttt{import MyModule} & \texttt{MyModule.x}、\texttt{MyModule.y} 和 \texttt{MyModule.p} & \texttt{MyModule.x}、\texttt{MyModule.y} 和 \texttt{MyModule.p} \\
\hline
\texttt{import MyModule.x, MyModule.p} & \texttt{x} 和 \texttt{p} & \texttt{x} 和 \texttt{p} \\
\hline
\texttt{import MyModule: x, p} & \texttt{x} 和 \texttt{p} & \texttt{x} 和 \texttt{p} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{14341239136076041524}{}


\subsection{模块和文件}



模块与文件和文件名无关；模块只与模块表达式有关。一个模块可以有多个文件，一个文件也可以有多个模块。




\begin{minted}{julia}
module Foo

include("file1.jl")
include("file2.jl")

end
\end{minted}



在不同的模块中引入同一段代码，可以提供一种类似 mixin 的行为。我们可以利用这个特性来观察，在不同的定义下，执行同一段代码会有什么结果。例如，在测试的时候，可以使用某些「安全」的运算符。




\begin{minted}{julia}
module Normal
include("mycode.jl")
end

module Testing
include("safe_operators.jl")
include("mycode.jl")
end
\end{minted}



\hypertarget{2129272965593313585}{}


\subsection{标准模块}



有三个重要的标准模块：



\begin{itemize}
\item \hyperlink{14876339894285762624}{\texttt{Core}} 包含了语言“内置”的所有功能。


\item \hyperlink{464144976511314225}{\texttt{Base}} 包含了绝大多数情况下都会用到的基本功能。


\item \hyperlink{7094459820733568273}{\texttt{Main}} 是顶层模块，当 julia 启动时，也是当前模块。

\end{itemize}


\hypertarget{3653095448809961286}{}


\subsection{默认顶层定义以及裸模块}



除了默认包含 \texttt{using Base} 之外，所有模块都还包含 \hyperlink{7507639810592563424}{\texttt{eval}} 和 \hyperlink{7507443674556842580}{\texttt{include}} 函数。这两个函数用于在对应模块的全局环境中，执行表达式或文件。



如果连这些默认的定义都不需要，那么可以用 \hyperlink{13329108222158426840}{\texttt{baremodule}} 定义裸模块（不过 \texttt{Core} 模块仍然会被引入，否则啥也干不了）。用裸模块表达的标准模块定义如下：




\begin{lstlisting}
baremodule Mod

using Base

eval(x) = Core.eval(Mod, x)
include(p) = Base.include(Mod, p)

...

end
\end{lstlisting}



\hypertarget{15942908766340569567}{}


\subsection{模块的绝对路径和相对路径}



给定语句 \texttt{using Foo}，系统在顶层模块的内部表中查找名为 \texttt{Foo} 的包。如果模块不存在，系统会尝试 \texttt{require(:Foo)}，这通常会从已安装的包中加载代码。



但是，某些模块包含子模块，这意味着你有时需要访问非顶层模块。有两种方法可以做到这一点。第一种是使用绝对路径，例如 \texttt{using Base.Sort}。第二种是使用相对路径，这样可以更容易地导入当前模块或其任何封闭模块的子模块：




\begin{lstlisting}
module Parent

module Utils
...
end

using .Utils

...
end
\end{lstlisting}



这里的模块 \texttt{Parent} 包含一个子模块 \texttt{Utils}，而 \texttt{Parent} 中的代码希望 \texttt{Utils} 的内容可见，这是可以使用 \texttt{using} 加点 \texttt{.} 这种相对路径来实现。添加更多的点会移动到模块层次结构中的更上级别。例如，\texttt{using ..Utils} 会在 \texttt{Parent} 的上级模块中查找 \texttt{Utils} 而不是在 \texttt{Parent} 中查找。



请注意，相对导入符号 \texttt{.} 仅在 \texttt{using} 和 \texttt{import} 语句中有效。



\hypertarget{5019601776205271706}{}


\subsection{命名空间的相关话题}



如果名称是限定的（例如 \texttt{Base.sin}），那么即使它没有被导出，我们也可以访问它。这通常在调试时很有用。若函数名也使用这种限定的方式，就可以为其添加方法。但是，对于函数名仅包含符号的情况，例如一个运算符，\texttt{Base.+}，由于会出现语法歧义，所以必须使用 \texttt{Base.:+} 来引用它。如果运算符的字符不止一个，则必须用括号括起来，例如：\texttt{Base.:(==)}。



宏名称在导入和导出语句中用 \texttt{@} 编写，例如：\texttt{import Mod.@mac}。其它模块中的宏可以用 \texttt{Mod.@mac} 或 \texttt{@Mod.mac} 触发。



不允许使用 \texttt{M.x = y} 这种写法给另一个模块中的全局变量赋值；必须在模块内部才能进行全局变量的赋值。



用 \texttt{global x} 声明变量可以仅“保留”名称而不赋值。有些全局变量需要在代码加载后才初始化，这样做可以防止命名冲突。



\hypertarget{10308651053456408379}{}


\subsection{模块初始化和预编译}



因为执行模块中的所有语句通常需要编译大量代码，大型模块可能需要几秒钟才能加载。Julia 会创建模块的预编译缓存以减少这个时间。



当用 \texttt{import} 或 \texttt{using} 加载一个模块时，模块增量预编译文件会自动创建并使用。这会让模块在第一次加载时自动编译。 另外，你也可以手工调用 \hyperlink{15403934372637978246}{\texttt{Base.compilecache(modulename)}}，产生的缓存文件会放在 \texttt{DEPOT\_PATH[1]/compiled/} 目录下。 之后，当该模块的任何一个依赖发生变更时，该模块会在 \texttt{using} 或 \texttt{import} 时自动重新编译； 模块的依赖指的是：任何它导入的模块、Julia 自身、include 的文件或由 \hyperlink{13423629850785876688}{\texttt{include\_dependency(path)}} 显式声明的依赖。



对于文件依赖，判断是否有变动的方法是：在 \texttt{include} 或 \texttt{include\_dependency} 的时候检查每个文件的变更时间（\texttt{mtime}）是否没变，或等于截断变更时间。截断变更时间是指将变更时间截断到最近的一秒，这是由于在某些操作系统中，用 \texttt{mtime} 无法获取亚秒级的精度。此外，也会考虑到 \texttt{require} 搜索到的文件路径与之前预编译文件中的是否匹配。对于已经加载到当前进程的依赖，即使它们的文件发成了变更，甚至是丢失，Julia 也不会重新编译这些模块，这是为了避免正在运行的系统与预编译缓存之间的不兼容性。



如果你认为预编译自己的模块是\textbf{不}安全的（基于下面所说的各种原因），那么你应该在模块文件中添加 \texttt{\_\_precompile\_\_(false)}，一般会将其写在文件的最上面。这就可以触发 \texttt{Base.compilecache} 报错，并且在直接使用 \texttt{using} / \texttt{import} 加载的时候跳过预编译和缓存。这样做同时也可以防止其它开启预编译的模块加载此模块。



在开发模块的时候，你可能需要了解一些与增量编译相关的固有行为。例如，外部状态不会被保留。为了解决这个问题，需要显式分离运行时与编译期的部分。Julia 允许你定义一个 \texttt{\_\_init\_\_()} 函数来执行任何需要在运行时发生的初始化。在编译期（\texttt{--output-*}），此函数将不会被调用。你可以假设在代码的生存周期中，此函数只会被运行一次。当然，如果有必要，你也可以手动调用它，但在默认的情况下，请假定此函数是为了处理与本机状态相关的信息，注意这些信息不需要，更不应该存入预编译镜像。此函数会在模块被导入到当前进程之后被调用，这包括在一个增量编译中导入该模块的时候（\texttt{--output-incremental=yes}），但在完整编译时该函数不会被调用。



特别的，如果你在模块里定义了一个名为 \texttt{\_\_init\_\_()} 的函数，那么 Julia 在加载这个模块之后会在第一次运行时（runtime）立刻调用这个函数（例如，通过 \texttt{import}，\texttt{using}，或者 \texttt{require} 加载时），也就是说 \texttt{\_\_init\_\_} 只会在模块中所有其它命令都执行完以后被调用一次。因为这个函数将在模块完全载入后被调用，任何子模块或者已经载入的模块都将在当前模块调用 \texttt{\_\_init\_\_} \textbf{之前} 调用自己的 \texttt{\_\_init\_\_} 函数。



\texttt{\_\_init\_\_}的典型用法有二，一是用于调用外部 C 库的运行时初始化函数，二是用于初始化涉及到外部库所返回的指针的全局常量。例如，假设我们正在调用一个 C 库 \texttt{libfoo}，它要求我们在运行时调用\texttt{foo\_init()} 这个初始化函数。假设我们还想定义一个全局常量 \texttt{foo\_data\_ptr}，它保存 \texttt{libfoo} 所定义的 \texttt{void *foo\_data()} 函数的返回值——必须在运行时（而非编译时）初始化这个常量，因为指针地址不是固定的。可以通过在模块中定义 \texttt{\_\_init\_\_} 函数来完成这个操作。




\begin{minted}{julia}
const foo_data_ptr = Ref{Ptr{Cvoid}}(0)
function __init__()
    ccall((:foo_init, :libfoo), Cvoid, ())
    foo_data_ptr[] = ccall((:foo_data, :libfoo), Ptr{Cvoid}, ())
    nothing
end
\end{minted}



注意，在像 \texttt{\_\_init\_\_} 这样的函数里定义一个全局变量是完全可以的，这是动态语言的优点之一。但是把全局作用域的值定义成常量，可以让编译器能确定该值的类型，并且能让编译器生成更好的优化过的代码。显然，你的模块（Module）中，任何其他依赖于 \texttt{foo\_data\_ptr} 的全局量也必须在 \texttt{\_\_init\_\_} 中被初始化。



涉及大多数不是由 \hyperlink{14245046751182637566}{\texttt{ccall}} 生成的 Julia 对象的常量，不需要放在 \texttt{\_\_init\_\_} 中：它们的定义可以预编译并从缓存的模块映像中加载。这包括复杂的堆分配对象，如数组。 但是，任何返回原始指针值的例程都必须在运行时调用，以便进行预编译（除非将 \hyperlink{10630331440513004826}{\texttt{Ptr}} 对象隐藏在 \hyperlink{12980593021531333073}{\texttt{isbits}} 对象中，否则它们将转换为空指针）。 这包括 Julia 函数 \texttt{cfunction} 和 \hyperlink{8901246211940014300}{\texttt{pointer}} 的返回值。



字典和集合类型，或者通常任何依赖于 \texttt{hash(key)} 方法的类型，都是比较棘手的情况。 通常当键是数字、字符串、符号、范围、\texttt{Expr} 或这些类型的组合（通过数组、元组、集合、映射对等）时，可以安全地预编译它们。但是，对于一些其它的键类型，例如 \texttt{Function} 或 \texttt{DataType}、以及还没有定义散列方法的通用用户定义类型，回退（fallback）的散列（\texttt{hash}）方法依赖于对象的内存地址（通过 \texttt{objectid}），因此可能会在每次运行时发生变化。 如果您有这些关键类型中的一种，或者您不确定，为了安全起见，您可以在您的 \texttt{\_\_init\_\_} 函数中初始化这个字典。或者，您可以使用 \hyperlink{14088500196255451490}{\texttt{IdDict}} 字典类型，它是由预编译专门处理的，因此在编译时初始化是安全的。



当使用预编译时，我们必须要清楚地区分代码的编译阶段和运行阶段。在此模式下，我们会更清楚发现 Julia 的编译器可以执行任何 Julia 代码，而不是一个用于生成编译后代码的独立的解释器。



其它已知的潜在失败场景包括：



\begin{itemize}
\item[1. ] 全局计数器，例如：为了试图唯一的标识对象。考虑以下代码片段：


\begin{minted}{julia}
mutable struct UniquedById
    myid::Int
    let counter = 0
        UniquedById() = new(counter += 1)
    end
end
\end{minted}

尽管这段代码的目标是给每个实例赋一个唯一的 ID，但计数器的值会在代码编译结束时被记录。任何对此增量编译模块的后续使用，计数器都将从同一个值开始计数。

注意 \texttt{objectid} （工作原理是取内存指针的 hash）也有类似的问题，请查阅下面关于 \texttt{Dict} 的用法。

一种解决方案是用宏捕捉 \hyperlink{8796901235206560169}{\texttt{@\_\_MODULE\_\_}}，并将它与目前的 \texttt{counter} 值一起保存。然而，更好的方案是对代码进行重新设计，不要依赖这种全局状态变量。


\item[2. ] 像 \texttt{Dict} 和 \texttt{Set} 这种关联集合需要在 \texttt{\_\_init\_\_} 中 re-hash。Julia 在未来很可能会提供一个机制来注册初始化函数。


\item[3. ] 依赖编译期的副作用会在加载时蔓延。例子包括：更改其它 Julia 模块里的数组或变量，操作文件或设备的句柄，保存指向其它系统资源（包括内存）的指针。


\item[4. ] 无意中从其它模块中“拷贝”了全局状态：通过直接引用的方式而不是通过查找的方式。例如，在全局作用域下：


\begin{minted}{julia}
#mystdout = Base.stdout #= will not work correctly, since this will copy Base.stdout into this module =#
# instead use accessor functions:
getstdout() = Base.stdout #= best option =#
# or move the assignment into the runtime:
__init__() = global mystdout = Base.stdout #= also works =#
\end{minted}

\end{itemize}


此处为预编译中的操作附加了若干限制，以帮助用户避免其他误操作：



\begin{itemize}
\item[1. ] 调用 \hyperlink{7507639810592563424}{\texttt{eval}} 来在另一个模块中引发副作用。当增量预编译被标记时，该操作同时会导致抛出一个警告。


\item[2. ] 当 \texttt{\_\_init\_\_()} 已经开始执行后，在局部作用域中声明 \texttt{global const}（见 issue \#12010，计划为此情况添加一个错误提示）


\item[3. ] 在增量预编译时替换模块是一个运行时错误。

\end{itemize}


一些其他需要注意的点：



\begin{itemize}
\item[1. ] 在源代码文件本身被修改之后，不会执行代码重载或缓存失效化处理（包括由 \texttt{Pkg.update} 执行的修改，此外在 \texttt{Pkg.rm} 执行后也没有清理操作）


\item[2. ] 变形数组的内存共享特性会被预编译忽略（每个数组样貌都会获得一个拷贝）


\item[3. ] 文件系统在编译期间和运行期间被假设为不变的，比如使用 \hyperlink{1518763743618824993}{\texttt{@\_\_FILE\_\_}}/\texttt{source\_path()} 在运行期间寻找资源、或使用 BinDeps 宏 \texttt{@checked\_lib}。有时这是不可避免的。但是可能的话，在编译期将资源复制到模块里面是个好做法，这样在运行期间，就不需要去寻找它们了。


\item[4. ] \texttt{WeakRef} 对象和完成器目前在序列化器中无法被恰当地处理（在接下来的发行版中将修复）。


\item[5. ] 通常，最好避免去捕捉内部元数据对象的引用，如 \texttt{Method}、\texttt{MethodInstance}、\texttt{TypeMapLevel}、\texttt{TypeMapEntry} 及这些对象的字段，因为这会迷惑序列化器，且可能会引发你不想要的结果。此操作不足以成为一个错误，但你需做好准备：系统会尝试拷贝一部分，然后创建其余部分的单个独立实例。

\end{itemize}


在开发模块时，关闭增量预编译可能会有所帮助。命令行标记 \texttt{--compiled-modules=\{yes|no\}} 可以让你切换预编译的开启和关闭。当 Julia 附加 \texttt{--compiled-modules=no} 启动，在载入模块和模块依赖时，编译缓存中的序列化模块会被忽略。\texttt{Base.compilecache} 仍可以被手动调用。此命令行标记的状态会被传递给 \texttt{Pkg.build}，禁止其在安装、更新、显式构建包时触发自动预编译。



\hypertarget{11221734891767592985}{}


\chapter{文档}



自Julia 0.4 开始，Julia 允许开发者和用户，使用其内置的文档系统更加便捷地为函数、类型以及其他对象编写文档。



The basic syntax is simple: any string appearing at the toplevel right before an object (function, macro, type or instance) will be interpreted as documenting it (these are called \emph{docstrings}). Note that no blank lines or comments may intervene between a docstring and the documented object. Here is a basic example:




\begin{minted}{julia}
"Tell whether there are too foo items in the array."
foo(xs::Array) = ...
\end{minted}



文档会被翻译成 \href{https://en.wikipedia.org/wiki/Markdown}{Markdown}，所以你可以 使用缩进和代码块来分隔代码示例和文本。从技术上来说，任何对象 都可以作为 metadata 与任何其他对象关联；Markdown 是默认的，但是可以创建 其它字符串宏并传递给 \texttt{@doc} 宏来使用其他格式。



\begin{quote}
\textbf{Note}

Markdown support is implemented in the \texttt{Markdown} standard library and for a full list of supported syntax see the \hyperlink{4003493111480691691}{documentation}.

\end{quote}


这里是一个更加复杂的例子，但仍然使用 Markdown：




\begin{minted}{julia}
"""
    bar(x[, y])

Compute the Bar index between `x` and `y`. If `y` is missing, compute
the Bar index between all pairs of columns of `x`.

# Examples
```julia-repl
julia> bar([1, 2], [1, 2])
1
```
"""
function bar(x, y) ...
\end{minted}



如上例所示，我们推荐在写文档时遵守一些简单约定：



\begin{itemize}
\item[1.  ] 始终在文档顶部显示函数的签名并带有四空格缩进，以便能够显示成 Julia 代码。

这和在 Julia 代码中的签名是一样的（比如 \texttt{mean(x::AbstractArray)}），或是简化版。可选参数应该尽可能与默认值一同显示（例如 \texttt{f(x, y=1)}），这与实际的 Julia 语法一致。没有默认值的可选参数应该放在括号中（例如 \texttt{f(x[, y])} 和 \texttt{f(x[, y[, z]])}）。可选的解决方法是使用多行：一个没有可选参数，其他的拥有可选参数（或者多个可选参数）。这个解决方案也可以用作给某个函数的多个方法来写文档。当一个函数接收到多个关键字参数，只在签名中包含占位符 \texttt{<keyword arguments>}（例如 \texttt{f(x; <keyword arguments>)}），并在 \texttt{\# Arguments} 章节给出完整列表（参照下列第 4 点）。


\item[2.  ] 在简化的签名块后请包含一个描述函数能做什么或者对象代表什么的单行句。如果需要的话，在一个空行之后，在第二段提供更详细的信息。

撰写函数的文档时，单行语句应使用祈使结构（比如「Do this」、「Return that」）而非第三人称（不要写「Returns the length...」）。并且应以句号结尾。如果函数的意义不能简单地总结，更好的方法是分成分开的组合句（虽然这不应被看做是对于每种情况下的绝对要求）。


\item[3.  ] 不要自我重复。

因为签名给出了函数名，所以没有必要用「The function \texttt{bar}...」开始文档：直接说要点。类似地，如果签名指定了参数的类型，在描述中提到这些是多余的。


\item[4.  ] 只在确实必要时提供参数列表。

对于简单函数，直接在函数目的的描述中提到参数的作用常常更加清楚。参数列表只会重复再其他地方提供过的信息。但是，对于拥有多个参数的（特别是含有关键字参数的）复杂函数来说，提供一个参数列表是个好主意。在这种情况下，请在函数的一般描述之后、标题 \texttt{\# Arguments} 之下插入参数列表，并在每个参数前加个着重号 \texttt{-}。参数列表应该提到参数的类型和默认值（如果有）：


\begin{minted}{julia}
"""
...
# Arguments
- `n::Integer`: the number of elements to compute.
- `dim::Integer=1`: the dimensions along which to perform the computation.
...
"""
\end{minted}


\item[5.  ] 给相关函数提供提示。

有时会存在具有功能相联系的函数。为了更易于发现相关函数，请在段落 \texttt{See also:} 中为其提供一个小列表。


\begin{lstlisting}
See also: [`bar!`](@ref), [`baz`](@ref), [`baaz`](@ref)
\end{lstlisting}


\item[6.  ] 请在 \texttt{\# Examples} 中包含一些代码例子。

例子应尽可能按照 \emph{doctest} 来写。\emph{doctest} 是一个栅栏分隔开的代码块（请参阅\href{@ref}{代码块}），其以 \texttt{```jldoctest} 开头并包含任意数量的提示符 \texttt{julia>} 以及用来模拟 Julia REPL 的输入和预期输出。

\begin{quote}
\textbf{Note}

Doctest 由 \href{https://github.com/JuliaDocs/Documenter.jl}{\texttt{Documenter.jl}} 支持。有关更详细的文档，请参阅 Documenter 的\href{https://juliadocs.github.io/Documenter.jl/}{手册}。

\end{quote}
例如在下面的 docstring 中定义了变量 \texttt{a}，预期的输出，跟在 Julia REPL 中打印的一样，出现在后面。


\begin{minted}{julia}
"""
Some nice documentation here.

# Examples
```jldoctest
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4
```
"""
\end{minted}

\begin{quote}
\textbf{Warning}

Calling \texttt{rand} and other RNG-related functions should be avoided in doctests since they will not produce consistent outputs during different Julia sessions. If you would like to show some random number generation related functionality, one option is to explicitly construct and seed your own \hyperlink{4960058165975837552}{\texttt{MersenneTwister}} (or other pseudorandom number generator) and pass it to the functions you are doctesting.

Operating system word size (\hyperlink{10103694114785108551}{\texttt{Int32}} or \hyperlink{7720564657383125058}{\texttt{Int64}}) as well as path separator differences (\texttt{/} or \texttt{{\textbackslash}}) will also affect the reproducibility of some doctests.

Note that whitespace in your doctest is significant! The doctest will fail if you misalign the output of pretty-printing an array, for example.

\end{quote}
你可以运行 \texttt{make -C doc doctest=true} 来运行在 Julia 手册和 API 文档中的 doctests，这样可以确保你的例子都能正常运行。

为了表示输出结果被截断了，你应该在校验应该停止的一行写上 \texttt{[...]}。这个在当 doctest 显示有个异常被抛出时隐藏堆栈跟踪时很有用（堆栈跟踪包含对 julia 代码的行的非永久引用），例如：


\begin{minted}{julia}
```jldoctest
julia> div(1, 0)
ERROR: DivideError: integer division error
[...]
```
\end{minted}

那些不能进行测试的例子应该写在以 \texttt{```julia} 开头的栅栏分隔的代码块中，以便在生成的文档中正确地高亮显示。

\begin{quote}
\textbf{Tip}

例子应尽可能\textbf{独立}和\textbf{可运行}以便读者可以在不需要引入任何依赖的情况下对它们进行实验。

\end{quote}

\item[7.  ] 使用倒引号来标识代码和方程。

Julia 标识符和代码摘录应该出现在倒引号 \texttt{`} 之间来使其能高亮显示。LaTeX 语法下的方程应该插入到双倒引号 \texttt{``} 之间。请使用 Unicode 字符而非 LaTeX 转义序列，比如 \texttt{``α = 1``} 而非 \texttt{``{\textbackslash}{\textbackslash}alpha = 1``}。


\item[8.  ] 请将起始和结束的\texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}}符号单独成行。

也就是说，请写：


\begin{minted}{julia}
"""
...

...
"""
f(x, y) = ...
\end{minted}

而非：


\begin{minted}{julia}
"""...

..."""
f(x, y) = ...
\end{minted}

This makes it clearer where docstrings start and end.


\item[9.  ] 请在代码中遵守单行长度限制。

Docstring 是使用与代码相同的工具编辑的。所以应运用同样的约定。 建议一行 92 个字符后换行。 It is recommended that lines are at most 92 characters wide.


\item[10. ] 请在 \texttt{\# Implementation} 章节中提供自定义类型如何实现该函数的信息。这些实现细节是针对开发者而非用户的，解释了例如哪些函数应该被重写、哪些函数自动使用恰当的回退函数等信息，最好与描述函数的主体描述分开。 \texttt{\# Implementation} section. These implementation details are intended for developers rather than users, explaining e.g. which functions should be overridden and which functions automatically use appropriate fallbacks. Such details are best kept separate from the main description of the function{\textquotesingle}s behavior.


\item[11. ] For long docstrings, consider splitting the documentation with an \texttt{\# Extended help} header. The typical help-mode will show only the material above the header; you can access the full help by adding a {\textquotesingle}?{\textquotesingle} at the beginning of the expression (i.e., {\textquotedbl}??foo{\textquotedbl} rather than {\textquotedbl}?foo{\textquotedbl}).

\end{itemize}


\hypertarget{10486321714157126961}{}


\section{访问文档}



文档可以在REPL中访问，也可以在 \href{https://github.com/JuliaLang/IJulia.jl}{IJulia} 中通过键入\texttt{?}紧接函数或者宏的名字并按下\texttt{Enter}访问。例如，




\begin{minted}{julia}
?cos
?@time
?r""
\end{minted}



will show documentation for the relevant function, macro or string macro respectively. In \href{http://junolab.org}{Juno} using \texttt{Ctrl-J, Ctrl-D} will show the documentation for the object under the cursor.



\hypertarget{5384792468741396562}{}


\section{函数与方法}



在Julia中函数可能有多种实现，被称为方法。虽然通用函数 一般只有一个目的，Julia允许在必要时可以对方法独立写文档。 通常，应该只有最通用的方法才有文档，或者甚至只是函数本身 （也就是在\texttt{function bar end}之前没有任何方法的对象）。特定方法应该 只因为其行为与其他通用方法有所区别才写文档。在任何情况下都不应 重复其他地方有的信息。例如




\begin{minted}{julia}
"""
    *(x, y, z...)

Multiplication operator. `x * y * z *...` calls this function with multiple
arguments, i.e. `*(x, y, z...)`.
"""
function *(x, y, z...)
    # ... [implementation sold separately] ...
end

"""
    *(x::AbstractString, y::AbstractString, z::AbstractString...)

When applied to strings, concatenates them.
"""
function *(x::AbstractString, y::AbstractString, z::AbstractString...)
    # ... [insert secret sauce here] ...
end

help?> *
search: * .*

  *(x, y, z...)

  Multiplication operator. x * y * z *... calls this function with multiple
  arguments, i.e. *(x,y,z...).

  *(x::AbstractString, y::AbstractString, z::AbstractString...)

  When applied to strings, concatenates them.
\end{minted}



当从通用函数里抽取文档时，每个方法的元数据会用函数\texttt{catdoc}拼接，其当然可以被自定义类型重写。



\hypertarget{9947466122062338539}{}


\section{进阶用法}



The \texttt{@doc} macro associates its first argument with its second in a per-module dictionary called \texttt{META}.



为了让写文档更加简单，语法分析器对宏名\texttt{@doc}特殊对待：如果\texttt{@doc}的调用只有一个参数，但是在下一行出现了另外一个表达式，那么这个表达式就会追加为宏的参数。所以接下来的语法会被分析成\texttt{@doc}的2个参数的调用：




\begin{minted}{julia}
@doc raw"""
...
"""
f(x) = x
\end{minted}



This makes it possible to use expressions other than normal string literals (such as the \texttt{raw{\textquotedbl}{\textquotedbl}} string macro) as a docstring.



当\texttt{@doc}宏（或者\texttt{doc}函数）用作抽取文档时，他会在所有的\texttt{META}字典寻找与对象相关的元数据并且返回。返回的对象（例如一些Markdown内容）会默认智能地显示。这个设计也让以编程方法使用文档系统变得容易；例如，在一个函数的不同版本中重用文档：




\begin{minted}{julia}
@doc "..." foo!
@doc (@doc foo!) foo
\end{minted}



或者与Julia的元编程功能一起使用：




\begin{minted}{julia}
for (f, op) in ((:add, :+), (:subtract, :-), (:multiply, :*), (:divide, :/))
    @eval begin
        $f(a,b) = $op(a,b)
    end
end
@doc "`add(a,b)` adds `a` and `b` together" add
@doc "`subtract(a,b)` subtracts `b` from `a`" subtract
\end{minted}



写在非顶级块，比如\texttt{begin}, \texttt{if}, \texttt{for}, 和 \texttt{let}，中的文档会根据块的评估情况加入文档系统中，例如：




\begin{minted}{julia}
if condition()
    "..."
    f(x) = x
end
\end{minted}



会被加到\texttt{f(x)}的文档中，当\texttt{condition()}是\texttt{true}的时候。注意即使\texttt{f(x)}在块的末尾离开了作用域，他的文档还会保留。



It is possible to make use of metaprogramming to assist in the creation of documentation. When using string-interpolation within the docstring you will need to use an extra \texttt{\$} as shown with \texttt{\$(\$name)}:




\begin{minted}{julia}
for func in (:day, :dayofmonth)
    name = string(func)
    @eval begin
        @doc """
            $($name)(dt::TimeType) -> Int64

        The day of month of a `Date` or `DateTime` as an `Int64`.
        """ $func(dt::Dates.TimeType)
    end
end
\end{minted}



\hypertarget{7588661187190124361}{}


\subsection{动态写文档}



有些时候类型的实例的合适的文档并非只取决于类型本身，也取决于实例的值。在这些情况下，你可以添加一个方法给自定义类型的\texttt{Docs.getdoc}函数，返回基于每个实例的文档。例如，




\begin{minted}{julia}
struct MyType
    value::String
end

Docs.getdoc(t::MyType) = "Documentation for MyType with value $(t.value)"

x = MyType("x")
y = MyType("y")
\end{minted}



输入\texttt{?x}会显示{\textquotedbl}Documentation for MyType with value x{\textquotedbl}，输入\texttt{?y}则会显示{\textquotedbl}Documentation for MyType with value y{\textquotedbl}。



\hypertarget{12360783788480513081}{}


\section{语法指南}



This guide provides a comprehensive overview of how to attach documentation to all Julia syntax constructs for which providing documentation is possible.



在下述例子中\texttt{{\textquotedbl}...{\textquotedbl}}用来表示任意的docstring。



\hypertarget{4617511478986608909}{}


\subsection{\texttt{\$} and \texttt{{\textbackslash}} characters}



The \texttt{\$} and \texttt{{\textbackslash}} characters are still parsed as string interpolation or start of an escape sequence in docstrings too. The \texttt{raw{\textquotedbl}{\textquotedbl}} string macro together with the \texttt{@doc} macro can be used to avoid having to escape them. This is handy when the docstrings include LaTeX or Julia source code examples containing interpolation:




\begin{minted}{julia}
@doc raw"""
```math
\LaTeX
```
"""
function f end
\end{minted}



\hypertarget{198065463690830309}{}


\subsection{函数与方法}




\begin{minted}{julia}
"..."
function f end

"..."
f
\end{minted}



把 docstring \texttt{{\textquotedbl}...{\textquotedbl}} 添加给了函数 \texttt{f}。首选的语法是第一种，虽然两者是等价的。




\begin{minted}{julia}
"..."
f(x) = x

"..."
function f(x)
    x
end

"..."
f(x)
\end{minted}



把 docstring \texttt{{\textquotedbl}...{\textquotedbl}} 添加给了方法 \texttt{f(::Any)}。




\begin{minted}{julia}
"..."
f(x, y = 1) = x + y
\end{minted}



把 docstring \texttt{{\textquotedbl}...{\textquotedbl}} 添加给了两个方法，分别为 \texttt{f(::Any)} 和 \texttt{f(::Any, ::Any)}。



\hypertarget{958098821246331521}{}


\subsection{宏}




\begin{minted}{julia}
"..."
macro m(x) end
\end{minted}



把 docstring \texttt{{\textquotedbl}...{\textquotedbl}} 添加给了宏 \texttt{@m(::Any)} 的定义。




\begin{minted}{julia}
"..."
:(@m)
\end{minted}



把 docstring \texttt{{\textquotedbl}...{\textquotedbl}} 添加给了名为 \texttt{@m} 的宏。



\hypertarget{5145884598618557277}{}


\subsection{类型}




\begin{lstlisting}
"..."
abstract type T1 end

"..."
mutable struct T2
    ...
end

"..."
struct T3
    ...
end
\end{lstlisting}



把 docstring \texttt{{\textquotedbl}...{\textquotedbl}} 添加给了类型 \texttt{T1}、\texttt{T2} 和 \texttt{T3}。




\begin{minted}{julia}
"..."
struct T
    "x"
    x
    "y"
    y
end
\end{minted}



把 docstring \texttt{{\textquotedbl}...{\textquotedbl}} 添加给了类型 \texttt{T}，\texttt{{\textquotedbl}x{\textquotedbl}} 添加给字段 \texttt{T.x}，\texttt{{\textquotedbl}y{\textquotedbl}} 添加给字段 \texttt{T.y}。也可以运用于\texttt{mutable struct} 类型。



\hypertarget{18307601734386005108}{}


\subsection{模块}




\begin{minted}{julia}
"..."
module M end

module M

"..."
M

end
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to the \texttt{Module} \texttt{M}. Adding the docstring above the \texttt{Module} is the preferred syntax, however both are equivalent.




\begin{minted}{julia}
"..."
baremodule M
# ...
end

baremodule M

import Base: @doc

"..."
f(x) = x

end
\end{minted}



通过把 docstring 放在表达式之上来给一个 \texttt{baremodule} 写文档会在模块中自动引入 \texttt{@doc}。它在模块表达式并没有文档时必须手动引入。空的 \texttt{baremodule} 不能有文档。



\hypertarget{17299710876257759093}{}


\subsection{全局变量}




\begin{minted}{julia}
"..."
const a = 1

"..."
b = 2

"..."
global c = 3
\end{minted}



把docstring\texttt{{\textquotedbl}...{\textquotedbl}}添加给了\texttt{绑定} \texttt{a}，\texttt{b}和\texttt{c}。



\texttt{绑定}是用来在\texttt{模块}中存储对于特定\texttt{符号}的引用而非存储被引用的值本身。



\begin{quote}
\textbf{Note}

当一个 \texttt{const} 定义只是用作定义另外一个定义的别名时，比如函数 \texttt{div} 和其在 \texttt{Base} 中的别名 \texttt{÷}，并不要为别名写文档，转而去为实际的函数写文档。

如果别名写了文档而实际定义没有，那么文档系统（\texttt{?} 模式）在寻找实际定义的文档时将不会返回别名的对应文档。

比如你应该写


\begin{minted}{julia}
"..."
f(x) = x + 1
const alias = f
\end{minted}

而非


\begin{minted}{julia}
f(x) = x + 1
"..."
const alias = f
\end{minted}

\end{quote}



\begin{minted}{julia}
"..."
sym
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to the value associated with \texttt{sym}. However, it is preferred that \texttt{sym} is documented where it is defined.



\hypertarget{6306013858572164490}{}


\subsection{多重对象}




\begin{minted}{julia}
"..."
a, b
\end{minted}



把docstring \texttt{{\textquotedbl}...{\textquotedbl}} 添加给\texttt{a}和\texttt{b}，两个都应该是可以写文档的表达式。这个语法等价于




\begin{minted}{julia}
"..."
a

"..."
b
\end{minted}



这种方法可以给任意数量的表达式写文档。当两个函数相关，比如非变版本\texttt{f}和可变版本\texttt{f!}，这个语法是有用的。



\hypertarget{5068022185116881179}{}


\subsection{宏生成代码}




\begin{minted}{julia}
"..."
@m expression
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to the expression generated by expanding \texttt{@m expression}. This allows for expressions decorated with \texttt{@inline}, \texttt{@noinline}, \texttt{@generated}, or any other macro to be documented in the same way as undecorated expressions.



宏作者应该注意到只有只生成单个表达式的宏才会自动支持docstring。如果宏返回的是含有多个子表达式的块，需要写文档的子表达式应该使用宏 \hyperlink{8194145670752069829}{\texttt{@\_\_doc\_\_}} 标记。



The \hyperlink{18177775477210803027}{\texttt{@enum}} macro makes use of \texttt{@\_\_doc\_\_} to allow for documenting \hyperlink{12477318268908279491}{\texttt{Enum}}s. Examining its definition should serve as an example of how to use \texttt{@\_\_doc\_\_} correctly.


\hypertarget{8194145670752069829}{} 
\hyperlink{8194145670752069829}{\texttt{Core.@\_\_doc\_\_}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@__doc__(ex)
\end{minted}

Low-level macro used to mark expressions returned by a macro that should be documented. If more than one expression is marked then the same docstring is applied to each expression.


\begin{lstlisting}
macro example(f)
    quote
        $(f)() = 0
        @__doc__ $(f)(x) = 1
        $(f)(x, y) = 2
    end |> esc
end
\end{lstlisting}

\texttt{@\_\_doc\_\_} has no effect when a macro that uses it is not documented.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/Docs.jl#L428-L443}{\texttt{source}}


\end{adjustwidth}

\hypertarget{899642791320764560}{}


\chapter{元编程}



Lisp 留给 Julia 最大的遗产就是它的元编程支持。和 Lisp 一样，Julia 把自己的代码表示为语言中的数据结构。既然代码被表示为了可以在语言中创建和操作的对象，程序就可以变换和生成自己的代码。这允许在没有额外构建步骤的情况下生成复杂的代码，并且还允许在 \href{https://en.wikipedia.org/wiki/Abstract\_syntax\_tree}{abstract syntax trees} 级别上运行的真正的 Lisp 风格的宏。与之相对的是预处理器“宏”系统，比如 C 和 C++ 中的，它们在解析和解释代码之前进行文本操作和变换。由于 Julia 中的所有数据类型和代码都被表示为 Julia 的 数据结构，强大的 \href{https://en.wikipedia.org/wiki/Reflection\_omputer\_\%28cprogramming\%29}{reflection} 功能可用于探索程序的内部及其类型，就像任何其他数据一样。



\hypertarget{13890173916214395200}{}


\section{程序表示}



每个 Julia 程序均以字符串开始：




\begin{minted}{jlcon}
julia> prog = "1 + 1"
"1 + 1"
\end{minted}



\textbf{What happens next?}



The next step is to \href{https://en.wikipedia.org/wiki/Parsing\#Computer\_languages}{parse} each string into an object called an expression, represented by the Julia type \hyperlink{17120496304147995299}{\texttt{Expr}}:




\begin{minted}{jlcon}
julia> ex1 = Meta.parse(prog)
:(1 + 1)

julia> typeof(ex1)
Expr
\end{minted}



\texttt{Expr} 对象包含两个部分：



\begin{itemize}
\item a \hyperlink{18332791376992528422}{\texttt{Symbol}} identifying the kind of expression. A symbol is an \href{https://en.wikipedia.org/wiki/String\_interning}{interned string} 标识符（下面会有更多讨论）

\end{itemize}



\begin{minted}{jlcon}
julia> ex1.head
:call
\end{minted}



\begin{itemize}
\item 表达式的参数，可能是符号、其他表达式或字面值：

\end{itemize}



\begin{minted}{jlcon}
julia> ex1.args
3-element Array{Any,1}:
  :+
 1
 1
\end{minted}



表达式也可能直接用 \href{https://en.wikipedia.org/wiki/Polish\_notation}{prefix notation} 构造：




\begin{minted}{jlcon}
julia> ex2 = Expr(:call, :+, 1, 1)
:(1 + 1)
\end{minted}



上面构造的两个表达式 – 一个通过解析构造一个通过直接构造 – 是等价的：




\begin{minted}{jlcon}
julia> ex1 == ex2
true
\end{minted}



\textbf{这里的关键点是 Julia 的代码在内部表示为可以从语言本身访问的数据结构}



函数 \hyperlink{15981569052160951906}{\texttt{dump}} 可以带有缩进和注释地显示 \texttt{Expr} 对象：




\begin{minted}{jlcon}
julia> dump(ex2)
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Int64 1
    3: Int64 1
\end{minted}



\texttt{Expr} 对象也可以嵌套：




\begin{minted}{jlcon}
julia> ex3 = Meta.parse("(4 + 4) / 2")
:((4 + 4) / 2)
\end{minted}



另外一个查看表达式的方法是使用 \texttt{Meta.show\_sexpr}，它能显示给定 \texttt{Expr} 的 \href{https://en.wikipedia.org/wiki/S-expression}{S-expression}，对 Lisp 用户来说，这看着很熟悉。下面是一个示例，阐释了如何显示嵌套的 \texttt{Expr}：




\begin{minted}{jlcon}
julia> Meta.show_sexpr(ex3)
(:call, :/, (:call, :+, 4, 4), 2)
\end{minted}



\hypertarget{17960433860062790097}{}


\subsection{符号}



字符 \texttt{:} 在 Julia 中有两个作用。第一种形式构造一个  \hyperlink{18332791376992528422}{\texttt{Symbol}}，这是作为表达式组成部分的一个 \href{https://en.wikipedia.org/wiki/String\_interning}{interned string}：




\begin{minted}{jlcon}
julia> :foo
:foo

julia> typeof(ans)
Symbol
\end{minted}



构造函数 \hyperlink{18332791376992528422}{\texttt{Symbol}} 接受任意数量的参数并通过把它们的字符串表示连在一起创建一个新的符号：




\begin{minted}{jlcon}
julia> :foo == Symbol("foo")
true

julia> Symbol("func",10)
:func10

julia> Symbol(:var,'_',"sym")
:var_sym
\end{minted}



Note that to use \texttt{:} syntax, the symbol{\textquotesingle}s name must be a valid identifier. Otherwise the \texttt{Symbol(str)} constructor must be used.



在表达式的上下文中，符号用来表示对变量的访问；当一个表达式被求值时，符号会被替换为这个符号在合适的 \hyperlink{11957539949537805757}{scope} 中所绑定的值。



Sometimes extra parentheses around the argument to \texttt{:} are needed to avoid ambiguity in parsing:




\begin{minted}{jlcon}
julia> :(:)
:(:)

julia> :(::)
:(::)
\end{minted}



\hypertarget{3051242913122022314}{}


\section{表达式与求值}



\hypertarget{12430289445905702597}{}


\subsection{引用}



The second syntactic purpose of the \texttt{:} character is to create expression objects without using the explicit \hyperlink{17120496304147995299}{\texttt{Expr}} constructor. This is referred to as \emph{quoting}. The \texttt{:} character, followed by paired parentheses around a single statement of Julia code, produces an \texttt{Expr} object based on the enclosed code. Here is example of the short form used to quote an arithmetic expression:




\begin{minted}{jlcon}
julia> ex = :(a+b*c+1)
:(a + b * c + 1)

julia> typeof(ex)
Expr
\end{minted}



（为了查看这个表达式的结构，可以试一试 \texttt{ex.head} 和 \texttt{ex.args}，或者使用 \hyperlink{15981569052160951906}{\texttt{dump}} 同时查看 \texttt{ex.head} 和 \texttt{ex.args} 或者 \hyperlink{11314997131411442967}{\texttt{Meta.@dump}}）



注意等价的表达式也可以使用 \hyperlink{10422957797582368651}{\texttt{Meta.parse}} 或者直接用 \texttt{Expr} 构造：




\begin{minted}{jlcon}
julia>      :(a + b*c + 1)       ==
       Meta.parse("a + b*c + 1") ==
       Expr(:call, :+, :a, Expr(:call, :*, :b, :c), 1)
true
\end{minted}



解析器提供的表达式通常只有符号、其它表达式和字面量值作为其参数，而由 Julia 代码构造的表达式能以非字面量形式的任意运行期值作为其参数。在此特例中，\texttt{+} 和 \texttt{a} 都是符号，\texttt{*(b,c)} 是子表达式，而 \texttt{1} 是 64 位带符号整数字面量。



引用多个表达式有第二种语法形式：在 \texttt{quote ... end} 中包含代码块。




\begin{minted}{jlcon}
julia> ex = quote
           x = 1
           y = 2
           x + y
       end
quote
    #= none:2 =#
    x = 1
    #= none:3 =#
    y = 2
    #= none:4 =#
    x + y
end

julia> typeof(ex)
Expr
\end{minted}



\hypertarget{6473060285850683914}{}


\subsection{Interpolation}



Direct construction of \hyperlink{17120496304147995299}{\texttt{Expr}} objects with value arguments is powerful, but \texttt{Expr} constructors can be tedious compared to {\textquotedbl}normal{\textquotedbl} Julia syntax. As an alternative, Julia allows \emph{interpolation} of literals or expressions into quoted expressions. Interpolation is indicated by a prefix \texttt{\$}.



在此示例中，插入了变量 \texttt{a} 的值：




\begin{minted}{jlcon}
julia> a = 1;

julia> ex = :($a + b)
:(1 + b)
\end{minted}



对未被引用的表达式进行插值是不支持的，这会导致编译期错误：




\begin{minted}{jlcon}
julia> $a + b
ERROR: syntax: "$" expression outside quote
\end{minted}



在此示例中，元组 \texttt{(1,2,3)} 作为表达式插入到条件测试中：




\begin{minted}{jlcon}
julia> ex = :(a in $:((1,2,3)) )
:(a in (1, 2, 3))
\end{minted}



在表达式插值中使用 \texttt{\$} 是有意让人联想到\hyperlink{4452850363638134205}{字符串插值}和\hyperlink{3603331931999023419}{命令插值}。表达式插值使得复杂 Julia 表达式的程序化构造变得方便和易读。



\hypertarget{12062767751485347352}{}


\subsection{Splatting 插值}



请注意，\texttt{\$} 插值语法只允许插入单个表达式到包含它的表达式中。有时，你手头有个由表达式组成的数组，需要它们都变成其所处表达式的参数，而这可通过 \texttt{\$(xs...)} 语法做到。例如，下面的代码生成了一个函数调用，其参数数量通过编程确定：




\begin{minted}{jlcon}
julia> args = [:x, :y, :z];

julia> :(f(1, $(args...)))
:(f(1, x, y, z))
\end{minted}



\hypertarget{15842920146318002847}{}


\subsection{嵌套引用}



自然地，引用表达式可以包含在其它引用表达式中。插值在这些情形中的工作方式可能会有点难以理解。考虑这个例子：




\begin{minted}{jlcon}
julia> x = :(1 + 2);

julia> e = quote quote $x end end
quote
    #= none:1 =#
    $(Expr(:quote, quote
    #= none:1 =#
    $(Expr(:$, :x))
end))
end
\end{minted}



Notice that the result contains \texttt{\$x}, which means that \texttt{x} has not been evaluated yet. In other words, the \texttt{\$} expression {\textquotedbl}belongs to{\textquotedbl} the inner quote expression, and so its argument is only evaluated when the inner quote expression is:




\begin{minted}{jlcon}
julia> eval(e)
quote
    #= none:1 =#
    1 + 2
end
\end{minted}



但是，外部 \texttt{quote} 表达式可以把值插入到内部引用表达式的 \texttt{\$} 中去。这通过多个 \texttt{\$} 实现：




\begin{minted}{jlcon}
julia> e = quote quote $$x end end
quote
    #= none:1 =#
    $(Expr(:quote, quote
    #= none:1 =#
    $(Expr(:$, :(1 + 2)))
end))
end
\end{minted}



Notice that \texttt{(1 + 2)} now appears in the result instead of the symbol \texttt{x}. Evaluating this expression yields an interpolated \texttt{3}:




\begin{minted}{jlcon}
julia> eval(e)
quote
    #= none:1 =#
    3
end
\end{minted}



这种行为背后的直觉是每个 \texttt{\$} 都将 \texttt{x} 求值一遍：一个 \texttt{\$} 工作方式类似于 \texttt{eval(:x)}，其返回 \texttt{x} 的值，而两个 \texttt{\$} 行为相当于 \texttt{eval(eval(:x))}。



\hypertarget{15194695339988120385}{}


\subsection{QuoteNode}



The usual representation of a \texttt{quote} form in an AST is an \hyperlink{17120496304147995299}{\texttt{Expr}} with head \texttt{:quote}:




\begin{minted}{jlcon}
julia> dump(Meta.parse(":(1+2)"))
Expr
  head: Symbol quote
  args: Array{Any}((1,))
    1: Expr
      head: Symbol call
      args: Array{Any}((3,))
        1: Symbol +
        2: Int64 1
        3: Int64 2
\end{minted}



As we have seen, such expressions support interpolation with \texttt{\$}. However, in some situations it is necessary to quote code \emph{without} performing interpolation. This kind of quoting does not yet have syntax, but is represented internally as an object of type \texttt{QuoteNode}:




\begin{minted}{jlcon}
julia> eval(Meta.quot(Expr(:$, :(1+2))))
3

julia> eval(QuoteNode(Expr(:$, :(1+2))))
:($(Expr(:$, :(1 + 2))))
\end{minted}



The parser yields \texttt{QuoteNode}s for simple quoted items like symbols:




\begin{minted}{jlcon}
julia> dump(Meta.parse(":x"))
QuoteNode
  value: Symbol x
\end{minted}



\texttt{QuoteNode} can also be used for certain advanced metaprogramming tasks.



\hypertarget{15751418549857902160}{}


\subsection{Evaluating expressions}



Given an expression object, one can cause Julia to evaluate (execute) it at global scope using \hyperlink{7507639810592563424}{\texttt{eval}}:




\begin{minted}{jlcon}
julia> :(1 + 2)
:(1 + 2)

julia> eval(ans)
3

julia> ex = :(a + b)
:(a + b)

julia> eval(ex)
ERROR: UndefVarError: b not defined
[...]

julia> a = 1; b = 2;

julia> eval(ex)
3
\end{minted}



Every \hyperlink{16725527896995457152}{module} has its own \hyperlink{7507639810592563424}{\texttt{eval}} function that evaluates expressions in its global scope. Expressions passed to \hyperlink{7507639810592563424}{\texttt{eval}} are not limited to returning values – they can also have side-effects that alter the state of the enclosing module{\textquotesingle}s environment:




\begin{minted}{jlcon}
julia> ex = :(x = 1)
:(x = 1)

julia> x
ERROR: UndefVarError: x not defined

julia> eval(ex)
1

julia> x
1
\end{minted}



这里，表达式对象的求值导致一个值被赋值给全局变量 \texttt{x}。



由于表达式只是 \texttt{Expr} 对象，而其可以通过编程方式构造然后对它求值，因此可以动态地生成任意代码，然后使用 \hyperlink{7507639810592563424}{\texttt{eval}} 运行所生成的代码。这是个简单的例子：




\begin{minted}{jlcon}
julia> a = 1;

julia> ex = Expr(:call, :+, a, :b)
:(1 + b)

julia> a = 0; b = 2;

julia> eval(ex)
3
\end{minted}



\texttt{a} 的值被用于构造表达式 \texttt{ex}，该表达式将函数 \texttt{+} 作用于值 1 和变量 \texttt{b}。请注意 \texttt{a} 和 \texttt{b} 使用方式间的重要区别：



\begin{itemize}
\item \emph{变量} \texttt{a} 在表达式构造时的值在表达式中用作立即值。因此，在对表达式求值时，\texttt{a} 的值就无关紧要了：表达式中的值已经是 \texttt{1}，与 \texttt{a} 的值无关。


\item 另一方面，因为在表达式构造时用的是符号 \texttt{:b}，所以变量 \texttt{b} 的值无关紧要——\texttt{:b} 只是一个符号，变量 \texttt{b} 甚至无需被定义。然而，在表达式求值时，符号 \texttt{:b} 的值通过寻找变量 \texttt{b} 的值来解析。

\end{itemize}


\hypertarget{2578517908282982662}{}


\subsection{关于表达式的函数}



As hinted above, one extremely useful feature of Julia is the capability to generate and manipulate Julia code within Julia itself. We have already seen one example of a function returning \hyperlink{17120496304147995299}{\texttt{Expr}} objects: the \hyperlink{14207407853646164654}{\texttt{parse}} function, which takes a string of Julia code and returns the corresponding \texttt{Expr}. A function can also take one or more \texttt{Expr} objects as arguments, and return another \texttt{Expr}. Here is a simple, motivating example:




\begin{minted}{jlcon}
julia> function math_expr(op, op1, op2)
           expr = Expr(:call, op, op1, op2)
           return expr
       end
math_expr (generic function with 1 method)

julia>  ex = math_expr(:+, 1, Expr(:call, :*, 4, 5))
:(1 + 4 * 5)

julia> eval(ex)
21
\end{minted}



作为另一个例子，这个函数将数值参数加倍，但不处理表达式：




\begin{minted}{jlcon}
julia> function make_expr2(op, opr1, opr2)
           opr1f, opr2f = map(x -> isa(x, Number) ? 2*x : x, (opr1, opr2))
           retexpr = Expr(:call, op, opr1f, opr2f)
           return retexpr
       end
make_expr2 (generic function with 1 method)

julia> make_expr2(:+, 1, 2)
:(2 + 4)

julia> ex = make_expr2(:+, 1, Expr(:call, :*, 5, 8))
:(2 + 5 * 8)

julia> eval(ex)
42
\end{minted}



\hypertarget{11146454106624591870}{}


\section{宏}



宏提供了在程序的最终主体中包含所生成的代码的方法。宏将参数元组映射到所返回的\emph{表达式}，且生成的表达式会被直接编译，并不需要运行时的 \hyperlink{7507639810592563424}{\texttt{eval}} 调用。宏的参数可以包括表达式、字面量值和符号。



\hypertarget{13022711559815737661}{}


\subsection{基础}



这是一个非常简单的宏：




\begin{minted}{jlcon}
julia> macro sayhello()
           return :( println("Hello, world!") )
       end
@sayhello (macro with 1 method)
\end{minted}



宏在Julia的语法中有一个专门的字符 \texttt{@} (at-sign)，紧接着是其使用\texttt{macro NAME ... end} 形式来声明的唯一的宏名。在这个例子中，编译器会把所有的\texttt{@sayhello} 替换成：




\begin{minted}{julia}
:( println("Hello, world!") )
\end{minted}



当 \texttt{@sayhello} 在REPL中被输入时，解释器立即执行，因此我们只会看到计算后的结果：




\begin{minted}{jlcon}
julia> @sayhello()
Hello, world!
\end{minted}



现在，考虑一个稍微复杂一点的宏：




\begin{minted}{jlcon}
julia> macro sayhello(name)
 return :( println("Hello, ", $name) )
 end
@sayhello (macro with 1 method)
\end{minted}



这个宏接受一个参数\texttt{name}。当遇到\texttt{@sayhello}时，quoted 表达式会被\emph{展开}并将参数中的值插入到最终的表达式中：




\begin{minted}{jlcon}
julia> @sayhello("human")
Hello, human
\end{minted}



We can view the quoted return expression using the function \hyperlink{8018172489611994488}{\texttt{macroexpand}} (\textbf{important note:} this is an extremely useful tool for debugging macros):




\begin{lstlisting}
julia> ex = macroexpand(Main, :(@sayhello("human")) )
:(Main.println("Hello, ", "human"))

julia> typeof(ex)
Expr
\end{lstlisting}



我们可以看到 \texttt{{\textquotedbl}human{\textquotedbl}} 字面量已被插入到表达式中了。



还有一个宏 \href{@ ref}{\texttt{@ macroexpand}}，它可能比 \texttt{macroexpand} 函数更方便：




\begin{minted}{jlcon}
julia> @macroexpand @sayhello "human"
:(println("Hello, ", "human"))
\end{minted}



\hypertarget{12261577225730588688}{}


\subsection{Hold up: why macros?}



We have already seen a function \texttt{f(::Expr...) -> Expr} in a previous section. In fact, \hyperlink{8018172489611994488}{\texttt{macroexpand}} is also such a function. So, why do macros exist?



Macros are necessary because they execute when code is parsed, therefore, macros allow the programmer to generate and include fragments of customized code \emph{before} the full program is run. To illustrate the difference, consider the following example:




\begin{lstlisting}
julia> macro twostep(arg)
           println("I execute at parse time. The argument is: ", arg)
           return :(println("I execute at runtime. The argument is: ", $arg))
       end
@twostep (macro with 1 method)

julia> ex = macroexpand(Main, :(@twostep :(1, 2, 3)) );
I execute at parse time. The argument is: :((1, 2, 3))
\end{lstlisting}



第一个 \hyperlink{783803254548423222}{\texttt{println}} 调用在调用 \hyperlink{8018172489611994488}{\texttt{macroexpand}} 时执行。生成的表达式\emph{只}包含第二个 \texttt{println}：




\begin{lstlisting}
julia> typeof(ex)
Expr

julia> ex
:(println("I execute at runtime. The argument is: ", $(Expr(:copyast, :($(QuoteNode(:((1, 2, 3)))))))))

julia> eval(ex)
I execute at runtime. The argument is: (1, 2, 3)
\end{lstlisting}



\hypertarget{14488850884072492512}{}


\subsection{宏的调用}



宏的通常调用语法如下：




\begin{minted}{julia}
@name expr1 expr2 ...
@name(expr1, expr2, ...)
\end{minted}



请注意，在宏名称前的标志 \texttt{@}，且在第一种形式中参数表达式间没有逗号，而在第二种形式中 \texttt{@name} 后没有空格。这两种风格不应混淆。例如，下列语法不同于上述例子；它把元组 \texttt{(expr1, expr2, ...)} 作为参数传给宏：




\begin{minted}{julia}
@name (expr1, expr2, ...)
\end{minted}



在数组字面量（或推导式）上调用宏的另一种方法是不使用括号直接并列两者。在这种情况下，数组将是唯一的传给宏的表达式。以下语法等价（且与 \texttt{@name [a b] * v} 不同）：




\begin{minted}{julia}
@name[a b] * v
@name([a b]) * v
\end{minted}



在这着重强调，宏把它们的参数作为表达式、字面量或符号接收。浏览宏参数的一种方法是在宏的内部调用 \hyperlink{14071376285304310153}{\texttt{show}} 函数：




\begin{minted}{jlcon}
julia> macro showarg(x)
           show(x)
           # ... remainder of macro, returning an expression
       end
@showarg (macro with 1 method)

julia> @showarg(a)
:a

julia> @showarg(1+1)
:(1 + 1)

julia> @showarg(println("Yo!"))
:(println("Yo!"))
\end{minted}



除了给定的参数列表，每个宏都会传递名为 \texttt{\_\_source\_\_} 和 \texttt{\_\_module\_\_} 的额外参数。



The argument \texttt{\_\_source\_\_} provides information (in the form of a \texttt{LineNumberNode} object) about the parser location of the \texttt{@} sign from the macro invocation. This allows macros to include better error diagnostic information, and is commonly used by logging, string-parser macros, and docs, for example, as well as to implement the \hyperlink{277452200962288519}{\texttt{@\_\_LINE\_\_}}, \hyperlink{1518763743618824993}{\texttt{@\_\_FILE\_\_}}, and \hyperlink{12719499456415901450}{\texttt{@\_\_DIR\_\_}} macros.



引用 \texttt{\_\_source\_\_.line} 和 \texttt{\_\_source\_\_.file} 即可访问位置信息：




\begin{minted}{jlcon}
julia> macro __LOCATION__(); return QuoteNode(__source__); end
@__LOCATION__ (macro with 1 method)

julia> dump(
            @__LOCATION__(
       ))
LineNumberNode
  line: Int64 2
  file: Symbol none
\end{minted}



参数 \texttt{\_\_module\_\_} 提供宏调用展开处的上下文相关信息（以 \texttt{Module} 对象的形式）。这允许宏查找上下文相关的信息，比如现有的绑定，或者将值作为附加参数插入到一个在当前模块中进行自我反射的运行时函数调用中。



\hypertarget{12271969370439662350}{}


\subsection{构建高级的宏}



Here is a simplified definition of Julia{\textquotesingle}s \hyperlink{4796942656392369899}{\texttt{@assert}} macro:




\begin{minted}{jlcon}
julia> macro assert(ex)
           return :( $ex ? nothing : throw(AssertionError($(string(ex)))) )
       end
@assert (macro with 1 method)
\end{minted}



这个宏可以像这样使用：




\begin{minted}{jlcon}
julia> @assert 1 == 1.0

julia> @assert 1 == 0
ERROR: AssertionError: 1 == 0
\end{minted}



宏调用在解析时扩展为其返回结果，并替代已编写的语法。这相当于编写：




\begin{minted}{julia}
1 == 1.0 ? nothing : throw(AssertionError("1 == 1.0"))
1 == 0 ? nothing : throw(AssertionError("1 == 0"))
\end{minted}



That is, in the first call, the expression \texttt{:(1 == 1.0)} is spliced into the test condition slot, while the value of \texttt{string(:(1 == 1.0))} is spliced into the assertion message slot. The entire expression, thus constructed, is placed into the syntax tree where the \texttt{@assert} macro call occurs. Then at execution time, if the test expression evaluates to true, then \hyperlink{9331422207248206047}{\texttt{nothing}} is returned, whereas if the test is false, an error is raised indicating the asserted expression that was false. Notice that it would not be possible to write this as a function, since only the \emph{value} of the condition is available and it would be impossible to display the expression that computed it in the error message.



The actual definition of \texttt{@assert} in Julia Base is more complicated. It allows the user to optionally specify their own error message, instead of just printing the failed expression. Just like in functions with a variable number of arguments (\href{@ref}{Varargs Functions}), this is specified with an ellipses following the last argument:




\begin{minted}{jlcon}
julia> macro assert(ex, msgs...)
           msg_body = isempty(msgs) ? ex : msgs[1]
           msg = string(msg_body)
           return :($ex ? nothing : throw(AssertionError($msg)))
       end
@assert (macro with 1 method)
\end{minted}



Now \texttt{@assert} has two modes of operation, depending upon the number of arguments it receives! If there{\textquotesingle}s only one argument, the tuple of expressions captured by \texttt{msgs} will be empty and it will behave the same as the simpler definition above. But now if the user specifies a second argument, it is printed in the message body instead of the failing expression. You can inspect the result of a macro expansion with the aptly named \hyperlink{14913190777653949565}{\texttt{@macroexpand}} macro:




\begin{lstlisting}
julia> @macroexpand @assert a == b
:(if Main.a == Main.b
        Main.nothing
    else
        Main.throw(Main.AssertionError("a == b"))
    end)

julia> @macroexpand @assert a==b "a should equal b!"
:(if Main.a == Main.b
        Main.nothing
    else
        Main.throw(Main.AssertionError("a should equal b!"))
    end)
\end{lstlisting}



实际的 \texttt{@assert} 宏还处理了另一种情形：我们如果除了打印「a should equal b」外还想打印它们的值？有人也许会天真地尝试在自定义消息中使用字符串插值，例如，\texttt{@assert a==b {\textquotedbl}a (\$a) should equal b (\$b)!{\textquotedbl}}，但这不会像上面的宏一样按预期工作。你能想到为什么吗？回想一下\hyperlink{4452850363638134205}{字符串插值}，内插字符串会被重写为 \hyperlink{7919678712989769360}{\texttt{string}} 的调用。比较：




\begin{minted}{jlcon}
julia> typeof(:("a should equal b"))
String

julia> typeof(:("a ($a) should equal b ($b)!"))
Expr

julia> dump(:("a ($a) should equal b ($b)!"))
Expr
  head: Symbol string
  args: Array{Any}((5,))
    1: String "a ("
    2: Symbol a
    3: String ") should equal b ("
    4: Symbol b
    5: String ")!"
\end{minted}



所以，现在宏在 \texttt{msg\_body} 中获得的不是单纯的字符串，其接收了一个完整的表达式，该表达式需进行求值才能按预期显示。这可作为 \hyperlink{7919678712989769360}{\texttt{string}} 调用的参数直接拼接到返回的表达式中；有关完整实现，请参阅 \href{https://github.com/JuliaLang/julia/blob/master/base/error.jl}{\texttt{error.jl}}。



\texttt{@assert} 宏充分利用拼接被引用的表达式，以便简化对宏内部表达式的操作。



\hypertarget{12123968542051578223}{}


\subsection{卫生宏}



在更复杂的宏中会出现关于\href{https://en.wikipedia.org/wiki/Hygienic\_macro}{卫生宏} 的问题。简而言之，宏必须确保在其返回表达式中引入的变量不会意外地与其展开处周围代码中的现有变量相冲突。相反，作为参数传递给宏的表达式通常被\emph{认为}在其周围代码的上下文中进行求值，与现有变量交互并修改之。另一个问题源于这样的事实：宏可以在不同于其定义所处模块的模块中调用。在这种情况下，我们需要确保所有全局变量都被解析到正确的模块中。Julia 比使用文本宏展开的语言（比如 C）具有更大的优势，因为它只需要考虑返回的表达式。所有其它变量（例如上面\texttt{@assert} 中的 \texttt{msg}）遵循\hyperlink{11957539949537805757}{通常的作用域块规则}。



为了演示这些问题，让我们来编写宏 \texttt{@time}，其以表达式为参数，记录当前时间，对表达式求值，再次记录当前时间，打印前后的时间差，然后以表达式的值作为其最终值。该宏可能看起来就像这样：




\begin{minted}{julia}
macro time(ex)
    return quote
        local t0 = time_ns()
        local val = $ex
        local t1 = time_ns()
        println("elapsed time: ", (t1-t0)/1e9, " seconds")
        val
    end
end
\end{minted}



在这里，我们希望 \texttt{t0}、\texttt{t1} 和 \texttt{val} 是私有的临时变量且 \texttt{time} 引用在 Julia Base 中的 \hyperlink{2441622941271736623}{\texttt{time}} 函数，而不是用户也许具有的任何 \texttt{time} 变量（对于 \texttt{println} 也是一样）。想象一下，如果用户表达式 \texttt{ex} 中也包含对名为 \texttt{t0} 的变量的赋值、或者定义了自己的 \texttt{time} 变量，则可能会出现问题，我们可能会得到错误或者诡异且不正确的行为。



Julia 的宏展开器以下列方式解决这些问题。首先，宏返回结果中的变量被分为局部变量或全局变量。如果一个变量被赋值（且未声明为全局变量）、声明为局部变量或者用作函数参数名称，则将其视为局部变量。否则，则认为它是全局变量。接着，局部变量重命名为唯一名称（通过生成新符号的 \hyperlink{3515345868651201289}{\texttt{gensym}} 函数），并在宏定义所处环境中解析全局变量。因此，上述两个问题都被解决了；宏的局部变量不会与任何用户变量相冲突，\texttt{time} 和 \texttt{println} 也将引用其在 Julia Base 中的定义。



然而，仍有另外的问题。考虑此宏的以下用法：




\begin{minted}{julia}
module MyModule
import Base.@time

time() = ... # compute something

@time time()
end
\end{minted}



在这里，用户表达式 \texttt{ex} 是对 \texttt{time} 的调用，但不是宏所使用的 \texttt{time} 函数。它明确地引用 \texttt{MyModule.time}。因此，我们必须将 \texttt{ex} 中的代码安排在宏调用所处环境中解析。这通过用 \hyperlink{17861659594346526773}{\texttt{esc}}「转义」表达式来完成：




\begin{minted}{julia}
macro time(ex)
    ...
    local val = $(esc(ex))
    ...
end
\end{minted}



以这种方式封装的表达式会被宏展开器单独保留，并将其简单地逐字粘贴到输出中。因此，它将在宏调用所处环境中解析。



这种转义机制可以在必要时用于「违反」卫生，以便于引入或操作用户变量。例如，以下宏在其调用所处环境中将 \texttt{x} 设置为零：




\begin{minted}{jlcon}
julia> macro zerox()
           return esc(:(x = 0))
       end
@zerox (macro with 1 method)

julia> function foo()
           x = 1
           @zerox
           return x # is zero
       end
foo (generic function with 1 method)

julia> foo()
0
\end{minted}



应当明智地使用这种变量操作，但它偶尔会很方便。



Getting the hygiene rules correct can be a formidable challenge. Before using a macro, you might want to consider whether a function closure would be sufficient. Another useful strategy is to defer as much work as possible to runtime. For example, many macros simply wrap their arguments in a \texttt{QuoteNode} or other similar \hyperlink{17120496304147995299}{\texttt{Expr}}. Some examples of this include \texttt{@task body} which simply returns \texttt{schedule(Task(() -> \$body))}, and \texttt{@eval expr}, which simply returns \texttt{eval(QuoteNode(expr))}.



为了演示，我们可以将上面的 \texttt{@time} 示例重新编写成：




\begin{minted}{julia}
macro time(expr)
    return :(timeit(() -> $(esc(expr))))
end
function timeit(f)
    t0 = time_ns()
    val = f()
    t1 = time_ns()
    println("elapsed time: ", (t1-t0)/1e9, " seconds")
    return val
end
\end{minted}



但是，我们不这样做也是有充分理由的：将 \texttt{expr} 封装在新的作用域块（该匿名函数）中也会稍微改变该表达式的含义（其中任何变量的作用域），而我们想要 \texttt{@time} 使用时对其封装的代码影响最小。



\hypertarget{11371303288264026631}{}


\subsection{宏与派发}



与 Julia 函数一样，宏也是泛型的。由于多重派发，这意味着宏也能有多个方法定义：




\begin{minted}{jlcon}
julia> macro m end
@m (macro with 0 methods)

julia> macro m(args...)
           println("$(length(args)) arguments")
       end
@m (macro with 1 method)

julia> macro m(x,y)
           println("Two arguments")
       end
@m (macro with 2 methods)

julia> @m "asd"
1 arguments

julia> @m 1 2
Two arguments
\end{minted}



但是应该记住，宏派发基于传递给宏的 AST 的类型，而不是 AST 在运行时进行求值的类型：




\begin{minted}{jlcon}
julia> macro m(::Int)
           println("An Integer")
       end
@m (macro with 3 methods)

julia> @m 2
An Integer

julia> x = 2
2

julia> @m x
1 arguments
\end{minted}



\hypertarget{4927517878935278303}{}


\section{代码生成}



当需要大量重复的样板代码时，为了避免冗余，通常以编程方式生成它。在大多数语言中，这需要一个额外的构建步骤以及生成重复代码的独立程序。在 Julia 中，表达式插值和 \hyperlink{7507639810592563424}{\texttt{eval}} 允许在通常的程序执行过程中生成这些代码。例如，考虑下列自定义类型




\begin{minted}{julia}
struct MyNumber
    x::Float64
end
# output

\end{minted}



我们想为该类型添加一些方法。在下面的循环中，我们以编程的方式完成此工作：




\begin{minted}{julia}
for op = (:sin, :cos, :tan, :log, :exp)
    eval(quote
        Base.$op(a::MyNumber) = MyNumber($op(a.x))
    end)
end
# output

\end{minted}



现在，我们对自定义类型调用这些函数：




\begin{minted}{jlcon}
julia> x = MyNumber(π)
MyNumber(3.141592653589793)

julia> sin(x)
MyNumber(1.2246467991473532e-16)

julia> cos(x)
MyNumber(-1.0)
\end{minted}



在这种方法中，Julia 充当了自己的\href{https://en.wikipedia.org/wiki/Preprocessor}{预处理器}，并且允许从语言内部生成代码。使用 \texttt{:} 前缀的引用形式编写上述代码会使其更简洁：




\begin{minted}{julia}
for op = (:sin, :cos, :tan, :log, :exp)
    eval(:(Base.$op(a::MyNumber) = MyNumber($op(a.x))))
end
\end{minted}



不管怎样，这种使用 \texttt{eval(quote(...))} 模式生成语言内部的代码很常见，为此，Julia 自带了一个宏来缩写该模式：




\begin{minted}{julia}
for op = (:sin, :cos, :tan, :log, :exp)
    @eval Base.$op(a::MyNumber) = MyNumber($op(a.x))
end
\end{minted}



\hyperlink{12895501458291832858}{\texttt{@eval}} 重写此调用，使其与上面的较长版本完全等价。为了生成较长的代码块，可以把一个代码块作为表达式参数传给 \hyperlink{12895501458291832858}{\texttt{@eval}}：




\begin{minted}{julia}
@eval begin
    # multiple lines
end
\end{minted}



\hypertarget{7550171062631975520}{}


\section{非标准字符串字面量}



回想一下在\href{@ref non-standard-string-literals}{字符串}的文档中，以标识符为前缀的字符串字面量被称为非标准字符串字面量，它们可以具有与未加前缀的字符串字面量不同的语义。例如：



\begin{itemize}
\item \texttt{r{\textquotedbl}{\textasciicircum}{\textbackslash}s*(?:\#|\$){\textquotedbl}} 生成一个正则表达式对象而不是一个字符串


\item \texttt{b{\textquotedbl}DATA{\textbackslash}xff{\textbackslash}u2200{\textquotedbl}} 是字节数组 \texttt{[68,65,84,65,255,226,136,128]} 的字面量。

\end{itemize}


可能令人惊讶的是，这些行为并没有被硬编码到 Julia 的解释器或编译器中。相反，它们是由一个通用机制实现的自定义行为，且任何人都可以使用该机制：带前缀的字符串字面量被解析为特定名称的宏的调用。例如，正则表达式宏如下：




\begin{minted}{julia}
macro r_str(p)
    Regex(p)
end
\end{minted}



这便是全部代码。这个宏说的是字符串字面量 \texttt{r{\textquotedbl}{\textasciicircum}{\textbackslash}s*(?:\#|\$){\textquotedbl}} 的字面内容应该传给宏 \texttt{@r\_str}，并且展开后的结果应当放在该字符串字面量出现处的语法树中。换句话说，表达式 \texttt{r{\textquotedbl}{\textasciicircum}{\textbackslash}s*(?:\#|\$){\textquotedbl}} 等价于直接把下列对象放进语法树中：




\begin{minted}{julia}
Regex("^\\s*(?:#|\$)")
\end{minted}



字符串字面量形式不仅更短、更方便，也更高效：因为正则表达式需要编译，\texttt{Regex} 对象实际上是\emph{在编译代码时}创建的，所以编译只发生一次，而不是每次执行代码时都再编译一次。请考虑如果正则表达式出现在循环中：




\begin{minted}{julia}
for line = lines
    m = match(r"^\s*(?:#|$)", line)
    if m === nothing
        # non-comment
    else
        # comment
    end
end
\end{minted}



因为正则表达式 \texttt{r{\textquotedbl}{\textasciicircum}{\textbackslash}s*(?:\#|\$){\textquotedbl}} 在这段代码解析时便已编译并被插入到语法树中，所以它只编译一次，而不是每次执行循环时都再编译一次。要在不使用宏的情况下实现此效果，必须像这样编写此循环：




\begin{minted}{julia}
re = Regex("^\\s*(?:#|\$)")
for line = lines
    m = match(re, line)
    if m === nothing
        # non-comment
    else
        # comment
    end
end
\end{minted}



此外，如果编译器无法确定在所有循环中正则表达式对象都是常量，可能无法进行某些优化，使得此版本的效率依旧低于上面的更方便的字面量形式。当然，在某些情况下，非字面量形式更方便：如果需要向正则表达式中插入变量，就必须采用这种更冗长的方法；如果正则表达式模式本身是动态的，可能在每次循环迭代时发生变化，就必须在每次迭代中构造新的正则表达式对象。然而，在绝大多数用例中，正则表达式不是基于运行时的数据构造的。在大多数情况下，将正则表达式编写为编译期值的能力是无法估量的。



与非标准字符串字面量一样，非标准命令字面量存在使用命令字面量语法的带前缀变种。命令字面量 \texttt{custom`literal`} 被解析为 \texttt{@custom\_cmd {\textquotedbl}literal{\textquotedbl}}。Julia 本身不包含任何非标准命令字面量，但包可以使用此语法。除了语法不同以及使用 \texttt{\_cmd} 而不是 \texttt{\_str} 后缀，非标准命令字面量的行为与非标准字符串字面量完全相同。



如果两个模块提供了同名的非标准字符串或命令字面量，能使用模块名限定该字符串或命令字面量。例如，如果 \texttt{Foo} 和 \texttt{Bar} 提供了相同的字符串字面量 \texttt{@x\_str}，那么可以编写 \texttt{Foo.x{\textquotedbl}literal{\textquotedbl}} 或 \texttt{Bar.x{\textquotedbl}literal{\textquotedbl}} 来消除两者的歧义。



用户定义的字符串字面量的机制十分强大。不仅 Julia 的非标准字面量的实现使用它，而且命令字面量的语法（\texttt{`echo {\textquotedbl}Hello, \$person{\textquotedbl}`}）用下面看起来人畜无害的宏实现：




\begin{minted}{julia}
macro cmd(str)
    :(cmd_gen($(shell_parse(str)[1])))
end
\end{minted}



当然，这个宏的定义中使用的函数隐藏了许多复杂性，但它们只是函数且完全用 Julia 编写。你可以阅读它们的源代码并精确地看到它们的行为——它们所做的一切就是构造要插入到你的程序的语法树的表达式对象。



\hypertarget{925665269920917597}{}


\section{生成函数}



有个非常特殊的宏叫 \hyperlink{11479538870805927749}{\texttt{@generated}}，它允许你定义所谓的\emph{生成函数}。它们能根据其参数类型生成专用代码，与用多重派发所能实现的代码相比，其代码更灵活和/或少。虽然宏在解析时使用表达式且无法访问其输入值的类型，但是生成函数在参数类型已知时会被展开，但该函数尚未编译。



生成函数的声明不会执行某些计算或操作，而会返回一个被引用的表达式，接着该表达式构成参数类型所对应方法的主体。在调用生成函数时，其返回的表达式会被编译然后执行。为了提高效率，通常会缓存结果。为了能推断是否缓存结果，只能使用语言的受限子集。因此，生成函数提供了一个灵活的方式来将工作重运行时移到编译时，代价则是其构造能力受到更大的限制。



When defining generated functions, there are five main differences to ordinary functions:



\begin{itemize}
\item[1. ] 使用 \texttt{@generated} 标注函数声明。这会向 AST 附加一些信息，让编译器知道这个函数是生成函数。


\item[2. ] 在生成函数的主体中，你只能访问参数的\emph{类型}，而不能访问其值，以及在生成函数的定义之前便已定义的任何函数。 not their values.


\item[3. ] 不应计算某些东西或执行某些操作，应返回一个\emph{被引用的}表达式，它会在被求值时执行你想要的操作。


\item[4. ] Generated functions are only permitted to call functions that were defined \emph{before} the definition of the generated function. (Failure to follow this may result in getting \texttt{MethodErrors} referring to functions from a future world-age.)


\item[5. ] 生成函数不能\emph{更改}或\emph{观察}任何非常量的全局状态。（例如，其包括 IO、锁、非局部的字典或者使用 \texttt{hasmethod}）即它们只能读取全局常量，且没有任何副作用。换句话说，它们必须是纯函数。由于实现限制，这也意味着它们目前无法定义闭包或生成器。 for example, IO, locks, non-local dictionaries, or using \hyperlink{6562783328134837372}{\texttt{hasmethod}}).

\end{itemize}


举例子来说明这个是最简单的。我们可以将生成函数 \texttt{foo} 声明为




\begin{minted}{jlcon}
julia> @generated function foo(x)
           Core.println(x)
           return :(x * x)
       end
foo (generic function with 1 method)
\end{minted}



请注意，代码主体返回一个被引用的表达式，即 \texttt{:(x * x)}，而不仅仅是 \texttt{x * x} 的值。



从调用者的角度看，这与通常的函数等价；实际上，你无需知道你所调用的是通常的函数还是生成函数。让我们看看 \texttt{foo} 的行为：




\begin{minted}{jlcon}
julia> x = foo(2); # note: output is from println() statement in the body
Int64

julia> x           # now we print x
4

julia> y = foo("bar");
String

julia> y
"barbar"
\end{minted}



因此，我们知道在生成函数的主体中，\texttt{x} 是所传递参数的\emph{类型}，并且，生成函数的返回值是其定义所返回的被引用的表达式的求值结果，在该表达式求值时 \texttt{x} 表示其\emph{值}。



如果我们使用我们已经使用过的类型再次对 \texttt{foo} 求值会发生什么？




\begin{minted}{jlcon}
julia> foo(4)
16
\end{minted}



请注意，这里并没有打印 \hyperlink{7720564657383125058}{\texttt{Int64}}。我们可以看到对于特定的参数类型集来说，生成函数的主体只执行一次，且结果会被缓存。此后，对于此示例，生成函数首次调用返回的表达式被重新用作方法主体。但是，实际的缓存行为是由实现定义的性能优化，过于依赖此行为并不实际。



生成函数\emph{可能}只生成一次函数,但也\emph{可能}多次生成，或者看起来根本就没有生成过函数。因此，你应该\emph{从不}编写有副作用的生成函数——因为副作用发生的时间和频率是不确定的。（对于宏来说也是如此——跟宏一样，在生成函数中使用 \hyperlink{7507639810592563424}{\texttt{eval}} 也许意味着你正以错误的方式做某事。）但是，与宏不同，运行时系统无法正确处理对 \hyperlink{7507639810592563424}{\texttt{eval}} 的调用，所以不允许这样做。



理解 \texttt{@generated} 函数与方法的重定义间如何相互作用也很重要。遵循正确的 \texttt{@generated} 函数不能观察任何可变状态或导致全局状态的任何更改的原则，我们看到以下行为。观察到，生成函数\emph{不能}调用在生成函数本身的\emph{定义}之前未定义的任何方法。



一开始 \texttt{f(x)} 有一个定义




\begin{minted}{jlcon}
julia> f(x) = "original definition";
\end{minted}



定义使用 \texttt{f(x)} 的其它操作：




\begin{minted}{jlcon}
julia> g(x) = f(x);

julia> @generated gen1(x) = f(x);

julia> @generated gen2(x) = :(f(x));
\end{minted}



我们现在为 \texttt{f(x)} 添加几个新定义：




\begin{minted}{jlcon}
julia> f(x::Int) = "definition for Int";

julia> f(x::Type{Int}) = "definition for Type{Int}";
\end{minted}



并比较这些结果的差异：




\begin{minted}{jlcon}
julia> f(1)
"definition for Int"

julia> g(1)
"definition for Int"

julia> gen1(1)
"original definition"

julia> gen2(1)
"definition for Int"
\end{minted}



生成函数的每个方法都有自己的已定义函数视图：




\begin{minted}{jlcon}
julia> @generated gen1(x::Real) = f(x);

julia> gen1(1)
"definition for Type{Int}"
\end{minted}



上例中的生成函数 \texttt{foo} 能做的，通常的函数 \texttt{foo(x) = x * x} 也能做（除了在第一次调用时打印类型，并产生了更高的开销）。但是，生成函数的强大之处在于其能够根据传递给它的类型计算不同的被引用的表达式：




\begin{minted}{jlcon}
julia> @generated function bar(x)
           if x <: Integer
               return :(x ^ 2)
           else
               return :(x)
           end
       end
bar (generic function with 1 method)

julia> bar(4)
16

julia> bar("baz")
"baz"
\end{minted}



（当然，这个刻意的例子可以更简单地通过多重派发实现······）



滥用它会破坏运行时系统并导致未定义行为：




\begin{minted}{jlcon}
julia> @generated function baz(x)
           if rand() < .9
               return :(x^2)
           else
               return :("boo!")
           end
       end
baz (generic function with 1 method)
\end{minted}



由于生成函数的主体具有不确定性，其行为和\emph{所有后续代码的行为}并未定义。



\emph{不要复制这些例子！}



这些例子有助于说明生成函数定义和调用的工作方式；但是，\emph{不要复制它们}，原因如下：



\begin{itemize}
\item \texttt{foo} 函数有副作用（对 \texttt{Core.println} 的调用），并且未确切定义这些副作用发生的时间、频率和次数。


\item \texttt{bar} 函数解决的问题可通过多重派发被更好地解决——定义 \texttt{bar(x) = x} 和 \texttt{bar(x::Integer) = x {\textasciicircum} 2} 会做同样的事，但它更简单和快捷。


\item \texttt{baz} 函数是病态的

\end{itemize}


请注意，不应在生成函数中尝试的操作并无严格限制，且运行时系统现在只能检测一部分无效操作。还有许多操作只会破坏运行时系统而没有通知，通常以微妙的方式而非显然地与错误的定义相关联。因为函数生成器是在类型推导期间运行的，所以它必须遵守该代码的所有限制。



一些不应该尝试的操作包括：



\begin{itemize}
\item[1. ] 缓存本地指针。


\item[2. ] 以任何方式与 \texttt{Core.Compiler} 的内容或方法交互。


\item[3. ] 观察任何可变状态。

\begin{itemize}
\item 生成函数的类型推导可以在\emph{任何}时候运行，包括你的代码正在尝试观察或更改此状态时。

\end{itemize}

\item[4. ] 采用任何锁：你调用的 C 代码可以在内部使用锁（例如，调用 \texttt{malloc} 不会有问题，即使大多数实现在内部需要锁），但是不要试图在执行 Julia 代码时保持或请求任何锁。


\item[5. ] 调用在生成函数的主体后定义的任何函数。对于增量加载的预编译模块，则放宽此条件，以允许调用模块中的任何函数。

\end{itemize}


那好，我们现在已经更好地理解了生成函数的工作方式，让我们使用它来构建一些更高级（和有效）的功能……



\hypertarget{13559476639927770222}{}


\subsection{一个高级的例子}



Julia{\textquotesingle}s base library has an internal \texttt{sub2ind} function to calculate a linear index into an n-dimensional array, based on a set of n multilinear indices - in other words, to calculate the index \texttt{i} that can be used to index into an array \texttt{A} using \texttt{A[i]}, instead of \texttt{A[x,y,z,...]}. One possible implementation is the following:




\begin{minted}{jlcon}
julia> function sub2ind_loop(dims::NTuple{N}, I::Integer...) where N
           ind = I[N] - 1
           for i = N-1:-1:1
               ind = I[i]-1 + dims[i]*ind
           end
           return ind + 1
       end
sub2ind_loop (generic function with 1 method)

julia> sub2ind_loop((3, 5), 1, 2)
4
\end{minted}



用递归可以完成同样的事情：




\begin{minted}{jlcon}
julia> sub2ind_rec(dims::Tuple{}) = 1;

julia> sub2ind_rec(dims::Tuple{}, i1::Integer, I::Integer...) =
           i1 == 1 ? sub2ind_rec(dims, I...) : throw(BoundsError());

julia> sub2ind_rec(dims::Tuple{Integer, Vararg{Integer}}, i1::Integer) = i1;

julia> sub2ind_rec(dims::Tuple{Integer, Vararg{Integer}}, i1::Integer, I::Integer...) =
           i1 + dims[1] * (sub2ind_rec(Base.tail(dims), I...) - 1);

julia> sub2ind_rec((3, 5), 1, 2)
4
\end{minted}



这两种实现虽然不同，但本质上做同样的事情：在数组维度上的运行时循环，将每个维度上的偏移量收集到最后的索引中。



然而，循环所需的信息都已嵌入到参数的类型信息中。因此，我们可以利用生成函数将迭代移动到编译期；用编译器的说法，我们用生成函数手动展开循环。代码主体变得几乎相同，但我们不是计算线性索引，而是建立计算索引的\emph{表达式}：




\begin{minted}{jlcon}
julia> @generated function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N
           ex = :(I[$N] - 1)
           for i = (N - 1):-1:1
               ex = :(I[$i] - 1 + dims[$i] * $ex)
           end
           return :($ex + 1)
       end
sub2ind_gen (generic function with 1 method)

julia> sub2ind_gen((3, 5), 1, 2)
4
\end{minted}



\textbf{这会生成什么代码？}



找出所生成代码的一个简单方法是将生成函数的主体提取到另一个（通常的）函数中：




\begin{minted}{jlcon}
julia> @generated function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N
           return sub2ind_gen_impl(dims, I...)
       end
sub2ind_gen (generic function with 1 method)

julia> function sub2ind_gen_impl(dims::Type{T}, I...) where T <: NTuple{N,Any} where N
           length(I) == N || return :(error("partial indexing is unsupported"))
           ex = :(I[$N] - 1)
           for i = (N - 1):-1:1
               ex = :(I[$i] - 1 + dims[$i] * $ex)
           end
           return :($ex + 1)
       end
sub2ind_gen_impl (generic function with 1 method)
\end{minted}



我们现在可以执行 \texttt{sub2ind\_gen\_impl} 并检查它所返回的表达式：




\begin{minted}{jlcon}
julia> sub2ind_gen_impl(Tuple{Int,Int}, Int, Int)
:(((I[1] - 1) + dims[1] * (I[2] - 1)) + 1)
\end{minted}



因此，这里使用的方法主体根本不包含循环——只有两个元组的索引、乘法和加法/减法。所有循环都是在编译期执行的，我们完全避免了在执行期间的循环。因此，我们只需对每个类型循环\emph{一次}，在本例中每个 \texttt{N} 循环一次（除了在该函数被多次生成的边缘情况——请参阅上面的免责声明）。



\hypertarget{2054450996027567500}{}


\subsection{可选地生成函数}



生成函数可以在运行时实现高效率，但需要编译时间成本：必须为具体的参数类型的每个组合生成新的函数体。通常，Julia 能够编译函数的「泛型」版本，其适用于任何参数，但对于生成函数，这是不可能的。这意味着大量使用生成函数的程序可能无法静态编译。



为了解决这个问题，语言提供用于编写生成函数的通常、非生成的替代实现的语法。应用于上面的 \texttt{sub2ind} 示例，它看起来像这样：




\begin{minted}{julia}
function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N
    if N != length(I)
        throw(ArgumentError("Number of dimensions must match number of indices."))
    end
    if @generated
        ex = :(I[$N] - 1)
        for i = (N - 1):-1:1
            ex = :(I[$i] - 1 + dims[$i] * $ex)
        end
        return :($ex + 1)
    else
        ind = I[N] - 1
        for i = (N - 1):-1:1
            ind = I[i] - 1 + dims[i]*ind
        end
        return ind + 1
    end
end
\end{minted}



在内部，这段代码创建了函数的两个实现：一个生成函数的实现，其使用 \texttt{if @generated} 中的第一个块，一个通常的函数的实现，其使用 \texttt{else} 块。在 \texttt{if @generated} 块的 \texttt{then} 部分中，代码与其它生成函数具有相同的语义：参数名称引用类型，且代码应返回表达式。可能会出现多个 \texttt{if @generated} 块，在这种情况下，生成函数的实现使用所有的 \texttt{then} 块，而替代实现使用所有的 \texttt{else} 块。



请注意，我们在函数顶部添加了错误检查。此代码对两个版本都是通用的，且是两个版本中的运行时代码（它将被引用并返回为生成函数版本中的表达式）。这意味着局部变量的值和类型在代码生成时不可用——用于代码生成的代码只能看到参数类型。



在这种定义方式中，代码生成功能本质上只是一种可选的优化。如果方便，编译器将使用它，否则可能选择使用通常的实现。这种方式是首选的，因为它允许编译器做出更多决策和以更多方式编译程序，还因为通常代码比由代码生成的代码更易读。但是，使用哪种实现取决于编译器实现细节，因此，两个实现的行为必须相同。



\hypertarget{12380164357355707963}{}


\chapter{多维数组}



与大多数技术计算语言一样，Julia 提供原生的数组实现。 大多数技术计算语言非常重视其数组实现，但需要付出使用其它容器的代价。Julia 用同样的方式来处理数组。就像和其它用 Julia 写的代码一样，Julia 的数组库几乎完全是用 Julia 自身实现的，它的性能源自编译器。这样一来，用户就可以通过继承 \hyperlink{6514416309183787338}{\texttt{AbstractArray}} 的方式来创建自定义数组类型。 实现自定义数组类型的更多详细信息，请参阅\hyperlink{9718377734213742156}{manual section on the AbstractArray interface}。



数组是存储在多维网格中对象的集合。在最一般的情况下， 数组中的对象可能是 \hyperlink{15014186392807667022}{\texttt{Any}} 类型。 对于大多数计算上的需求，数组中对象的类型应该更加具体，例如 \hyperlink{5027751419500983000}{\texttt{Float64}} 或 \hyperlink{10103694114785108551}{\texttt{Int32}}。



一般来说，与许多其他科学计算语言不同，Julia 不希望为了性能而以向量化的方式编写程序。Julia 的编译器使用类型推断，并为标量数组索引生成优化的代码，从而能够令用户方便地编写可读性良好的程序，而不牺牲性能，并且时常会减少内存使用。



在 Julia 中，所有函数的参数都是 \href{https://en.wikipedia.org/wiki/Evaluation\_strategy\#Call\_by\_sharing}{passed by sharing}。一些科学计算语言用传值的方式传递数组，尽管这样做可以防止数组在被调函数中被意外地篡改，但这也会导致不必要的数组拷贝。通常，以一个 \texttt{!} 结尾的函数名表示它会对自己的一个或者多个参数的值进行修改或者销毁（例如，请比较 \hyperlink{8473525809131227606}{\texttt{sort}} 和 \hyperlink{12296873681374954808}{\texttt{sort!}}）。被调函数必须进行显式拷贝，以确保它们不会无意中修改输入参数。很多 “non-mutating” 函数在实现的时候，都会先进行显式拷贝，然后调用一个以 \texttt{!} 结尾的同名函数，最后返回之前拷贝的副本。



\hypertarget{3050591823172658870}{}


\section{基本函数}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
函数 & 描述 \\
\hline
\hyperlink{6396209842929672718}{\texttt{eltype(A)}} & \texttt{A} 中元素的类型 \\
\hline
\hyperlink{3699181304419743826}{\texttt{length(A)}} & \texttt{A} 中元素的数量 \\
\hline
\hyperlink{1688406579181746010}{\texttt{ndims(A)}} & \texttt{A} 的维数 \\
\hline
\hyperlink{17888996102305087038}{\texttt{size(A)}} & 一个包含 \texttt{A} 各个维度上元素数量的元组 \\
\hline
\hyperlink{17888996102305087038}{\texttt{size(A,n)}} & \texttt{A} 第 \texttt{n} 维中的元素数量 \\
\hline
\hyperlink{7074821531920287868}{\texttt{axes(A)}} & 一个包含 \texttt{A} 有效索引的元组 \\
\hline
\hyperlink{7074821531920287868}{\texttt{axes(A,n)}} & 第 \texttt{n} 维有效索引的范围 \\
\hline
\hyperlink{4701773772897287974}{\texttt{eachindex(A)}} & 一个访问 \texttt{A} 中每一个位置的高效迭代器 \\
\hline
\hyperlink{97811245619734938}{\texttt{stride(A,k)}} & 在第 \texttt{k} 维上的间隔（stride）（相邻元素间的线性索引距离） \\
\hline
\hyperlink{13576557637670855932}{\texttt{strides(A)}} & 包含每一维上的间隔（stride）的元组 \\
\hline
\end{tabulary}

\end{table}



\hypertarget{10907259792659637782}{}


\section{构造和初始化}



Julia 提供了许多用于构造和初始化数组的函数。在下列函数中，参数 \texttt{dims ...} 可以是一个包含维数大小的元组，也可以表示用任意个参数传递的一系列维数大小值。大部分函数的第一个参数都表示数组的元素类型 \texttt{T} 。如果类型 \texttt{T} 被省略，那么将默认为 \hyperlink{5027751419500983000}{\texttt{Float64}}。




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
函数 & 描述 \\
\hline
\hyperlink{15492651498431872487}{\texttt{Array\{T\}(undef, dims...)}} & 一个没有初始化的密集 \hyperlink{15492651498431872487}{\texttt{Array}} \\
\hline
\hyperlink{13837674686090348619}{\texttt{zeros(T, dims...)}} & 一个全零 \texttt{Array} \\
\hline
\hyperlink{5858390260510292771}{\texttt{ones(T, dims...)}} & 一个元素均为 1 的 \texttt{Array} \\
\hline
\hyperlink{12844393578243965152}{\texttt{trues(dims...)}} & 一个每个元素都为 \texttt{true} 的 \hyperlink{18015155802543401629}{\texttt{BitArray}} \\
\hline
\hyperlink{12518029339635756199}{\texttt{falses(dims...)}} & 一个每个元素都为 \texttt{false} 的 \texttt{BitArray} \\
\hline
\hyperlink{3388738163419525310}{\texttt{reshape(A, dims...)}} & 一个包含跟 \texttt{A} 相同数据但维数不同的数组 \\
\hline
\hyperlink{15665284441316555522}{\texttt{copy(A)}} & 拷贝 \texttt{A} \\
\hline
\hyperlink{3259459540194502889}{\texttt{deepcopy(A)}} & 深拷贝，即拷贝 \texttt{A}，并递归地拷贝其元素 \\
\hline
\hyperlink{15525808546723795098}{\texttt{similar(A, T, dims...)}} & 一个与\texttt{A}具有相同类型（这里指的是密集，稀疏等）的未初始化数组，但具有指定的元素类型和维数。第二个和第三个参数都是可选的，如果省略则默认为元素类型和 \texttt{A} 的维数。 \\
\hline
\hyperlink{293815781001952115}{\texttt{reinterpret(T, A)}} & 与 \texttt{A} 具有相同二进制数据的数组，但元素类型为 \texttt{T} \\
\hline
\hyperlink{7668863842145012694}{\texttt{rand(T, dims...)}} & 一个随机 \texttt{Array}，元素值是  \([0, 1)\)  半开区间中的均匀分布且服从一阶独立同分布 \footnotemark[1] \\
\hline
\hyperlink{7347069443766288058}{\texttt{randn(T, dims...)}} & 一个随机 \texttt{Array}，元素为标准正态分布，服从独立同分布 \\
\hline
\hyperlink{5448927444601277512}{\texttt{Matrix\{T\}(I, m, n)}} & \texttt{m}-by-\texttt{n} identity matrix. Requires \texttt{using LinearAlgebra} for \hyperlink{15346645596018210602}{\texttt{I}}. \\
\hline
\hyperlink{737600656772861535}{\texttt{range(start, stop=stop, length=n)}} & 从 \texttt{start} 到 \texttt{stop} 的带有 \texttt{n} 个线性间隔元素的范围 \\
\hline
\hyperlink{5162290739791026948}{\texttt{fill!(A, x)}} & 用值 \texttt{x} 填充数组 \texttt{A} \\
\hline
\hyperlink{2836152204730819918}{\texttt{fill(x, dims...)}} & 一个被值 \texttt{x} 填充的 \texttt{Array} \\
\hline
\end{tabulary}

\end{table}



\footnotetext[1]{\emph{iid}，独立同分布

}


要查看各种方法，我们可以将不同维数传递给这些构造函数，请考虑以下示例：




\begin{minted}{jlcon}
julia> zeros(Int8, 2, 3)
2×3 Array{Int8,2}:
 0  0  0
 0  0  0

julia> zeros(Int8, (2, 3))
2×3 Array{Int8,2}:
 0  0  0
 0  0  0

julia> zeros((2, 3))
2×3 Array{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0
\end{minted}



Here, \texttt{(2, 3)} is a \hyperlink{17462354060312563026}{\texttt{Tuple}} and the first argument — the element type — is optional, defaulting to \texttt{Float64}.



\hypertarget{15443953423472878802}{}


\section{Array literals}



Arrays can also be directly constructed with square braces; the syntax \texttt{[A, B, C, ...]} creates a one dimensional array (i.e., a vector) containing the comma-separated arguments as its elements. The element type (\hyperlink{6396209842929672718}{\texttt{eltype}}) of the resulting array is automatically determined by the types of the arguments inside the braces. If all the arguments are the same type, then that is its \texttt{eltype}. If they all have a common \hyperlink{10374023657104680331}{promotion type} then they get converted to that type using \hyperlink{1846942650946171605}{\texttt{convert}} and that type is the array{\textquotesingle}s \texttt{eltype}. Otherwise, a heterogeneous array that can hold anything — a \texttt{Vector\{Any\}} — is constructed; this includes the literal \texttt{[]} where no arguments are given.




\begin{minted}{jlcon}
julia> [1,2,3] # An array of `Int`s
3-element Array{Int64,1}:
 1
 2
 3

julia> promote(1, 2.3, 4//5) # This combination of Int, Float64 and Rational promotes to Float64
(1.0, 2.3, 0.8)

julia> [1, 2.3, 4//5] # Thus that's the element type of this Array
3-element Array{Float64,1}:
 1.0
 2.3
 0.8

julia> []
Any[]
\end{minted}



\hypertarget{8665822927896221545}{}


\subsection{Concatenation}



If the arguments inside the square brackets are separated by semicolons (\texttt{;}) or newlines instead of commas, then their contents are \emph{vertically concatenated} together instead of the arguments being used as elements themselves.




\begin{minted}{jlcon}
julia> [1:2, 4:5] # Has a comma, so no concatenation occurs. The ranges are themselves the elements
2-element Array{UnitRange{Int64},1}:
 1:2
 4:5

julia> [1:2; 4:5]
4-element Array{Int64,1}:
 1
 2
 4
 5

julia> [1:2
        4:5
        6]
5-element Array{Int64,1}:
 1
 2
 4
 5
 6
\end{minted}



Similarly, if the arguments are separated by tabs or spaces, then their contents are \emph{horizontally concatenated} together.




\begin{minted}{jlcon}
julia> [1:2  4:5  7:8]
2×3 Array{Int64,2}:
 1  4  7
 2  5  8

julia> [[1,2]  [4,5]  [7,8]]
2×3 Array{Int64,2}:
 1  4  7
 2  5  8

julia> [1 2 3] # Numbers can also be horizontally concatenated
1×3 Array{Int64,2}:
 1  2  3
\end{minted}



Using semicolons (or newlines) and spaces (or tabs) can be combined to concatenate both horizontally and vertically at the same time.




\begin{minted}{jlcon}
julia> [1 2
        3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> [zeros(Int, 2, 2) [1; 2]
        [3 4]            5]
3×3 Array{Int64,2}:
 0  0  1
 0  0  2
 3  4  5
\end{minted}



More generally, concatenation can be accomplished through the \hyperlink{9868138443525443234}{\texttt{cat}} function. These syntaxes are shorthands for function calls that themselves are convenience functions:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
语法 & 函数 & 描述 \\
\hline
 & \hyperlink{9868138443525443234}{\texttt{cat}} & 沿着 s 的第 \texttt{k} 维拼接数组 \\
\hline
\texttt{[A; B; C; ...]} & \hyperlink{14691815416955507876}{\texttt{vcat}} & shorthand for `cat(A...; dims=1) \\
\hline
\texttt{[A B C ...]} & \hyperlink{8862791894748483563}{\texttt{hcat}} & shorthand for `cat(A...; dims=2) \\
\hline
\texttt{[A B; C D; ...]} & \hyperlink{16279083053557795116}{\texttt{hvcat}} & simultaneous vertical and horizontal concatenation \\
\hline
\end{tabulary}

\end{table}



\hypertarget{7617457072899643427}{}


\subsection{Typed array literals}



可以用 \texttt{T[A, B, C, ...]} 的方式声明一个元素为某种特定类型的数组。该方法定义一个元素类型为 \texttt{T} 的一维数组并且初始化元素为 \texttt{A}, \texttt{B}, \texttt{C}, ....。比如，\texttt{Any[x, y, z]} 会构建一个异构数组，该数组可以包含任意类型的元素。



类似的，拼接也可以用类型为前缀来指定结果的元素类型。




\begin{minted}{jlcon}
julia> [[1 2] [3 4]]
1×4 Array{Int64,2}:
 1  2  3  4

julia> Int8[[1 2] [3 4]]
1×4 Array{Int8,2}:
 1  2  3  4
\end{minted}



\hypertarget{12661687782855472919}{}


\section{Comprehensions}



（数组）推导提供了构造数组的通用且强大的方法。其语法类似于数学中的集合构造的写法：




\begin{lstlisting}
A = [ F(x,y,...) for x=rx, y=ry, ... ]
\end{lstlisting}



这种形式的含义是 \texttt{F(x,y,...)} 取其给定列表中变量 \texttt{x}，\texttt{y} 等的每个值进行计算。值可以指定为任何可迭代对象，但通常是 \texttt{1:n} 或 \texttt{2:(n-1)} 之类的范围，或者像 \texttt{[1.2, 3.4, 5.7]} 这样的显式数组值。结果是一个 N 维密集数组，其维数是变量范围 \texttt{rx}，\texttt{ry} 等的维数串联。每次 \texttt{F(x,y,...)} 计算返回一个标量。



下面的示例计算当前元素和沿一维网格其左，右相邻元素的加权平均值：




\begin{minted}{jlcon}
julia> x = rand(8)
8-element Array{Float64,1}:
 0.843025
 0.869052
 0.365105
 0.699456
 0.977653
 0.994953
 0.41084
 0.809411

julia> [ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]
6-element Array{Float64,1}:
 0.736559
 0.57468
 0.685417
 0.912429
 0.8446
 0.656511
\end{minted}



The resulting array type depends on the types of the computed elements just like \hyperlink{13961675686342166416}{array literals} do. In order to control the type explicitly, a type can be prepended to the comprehension. For example, we could have requested the result in single precision by writing:




\begin{minted}{julia}
Float32[ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]
\end{minted}



\hypertarget{5737546333215614116}{}


\section{生成器表达式}



也可以在没有方括号的情况下编写（数组）推导，从而产生称为生成器的对象。可以迭代此对象以按需生成值，而不是预先分配数组并存储它们（请参阅 \hyperlink{13048041929642713791}{迭代}）。例如，以下表达式在不分配内存的情况下对一个序列进行求和：




\begin{minted}{jlcon}
julia> sum(1/n^2 for n=1:1000)
1.6439345666815615
\end{minted}



在参数列表中使用具有多个维度的生成器表达式时，需要使用括号将生成器与后续参数分开：




\begin{minted}{jlcon}
julia> map(tuple, 1/(i+j) for i=1:2, j=1:2, [1:4;])
ERROR: syntax: invalid iteration specification
\end{minted}



\texttt{for} 后面所有逗号分隔的表达式都被解释为范围。 添加括号让我们可以向 \hyperlink{11483231213869150535}{\texttt{map}} 中添加第三个参数：




\begin{minted}{jlcon}
julia> map(tuple, (1/(i+j) for i=1:2, j=1:2), [1 3; 2 4])
2×2 Array{Tuple{Float64,Int64},2}:
 (0.5, 1)       (0.333333, 3)
 (0.333333, 2)  (0.25, 4)
\end{minted}



Generators are implemented via inner functions. Just like inner functions used elsewhere in the language, variables from the enclosing scope can be {\textquotedbl}captured{\textquotedbl} in the inner function.  For example, \texttt{sum(p[i] - q[i] for i=1:n)} captures the three variables \texttt{p}, \texttt{q} and \texttt{n} from the enclosing scope. Captured variables can present performance challenges; see \hyperlink{627547588659365489}{performance tips}.



通过编写多个 \texttt{for} 关键字，生成器和推导中的范围可以取决于之前的范围：




\begin{minted}{jlcon}
julia> [(i,j) for i=1:3 for j=1:i]
6-element Array{Tuple{Int64,Int64},1}:
 (1, 1)
 (2, 1)
 (2, 2)
 (3, 1)
 (3, 2)
 (3, 3)
\end{minted}



在这些情况下，结果都是一维的。



可以使用 \texttt{if} 关键字过滤生成的值：




\begin{minted}{jlcon}
julia> [(i,j) for i=1:3 for j=1:i if i+j == 4]
2-element Array{Tuple{Int64,Int64},1}:
 (2, 2)
 (3, 1)
\end{minted}



\hypertarget{14469287548874312017}{}


\section{索引}



索引 n 维数组 \texttt{A} 的一般语法是：




\begin{lstlisting}
X = A[I_1, I_2, ..., I_n]
\end{lstlisting}



其中每个 \texttt{I\_k} 可以是标量整数，整数数组或任何其他\hyperlink{3335763678693018755}{支持的索引类型}。这包括 \hyperlink{13649361117037263099}{\texttt{Colon}} (\texttt{:}) 来选择整个维度中的所有索引，形式为 \texttt{a:c} 或 \texttt{a:b:c} 的范围来选择连续或跨步的子区间，以及布尔数组以选择索引为 \texttt{true} 的元素。



如果所有索引都是标量，则结果 \texttt{X} 是数组 \texttt{A} 中的单个元素。否则，\texttt{X} 是一个数组，其维数与所有索引的维数之和相同。



如果所有索引 \texttt{I\_k} 都是向量，则 \texttt{X} 的形状将是 \texttt{(length(I\_1), length(I\_2), ..., length(I\_n))}，其中，\texttt{X} 中位于 \texttt{i\_1, i\_2, ..., i\_n} 处的元素为 \texttt{A[I\_1[i\_1], I\_2[i\_2], ..., I\_n[i\_n]]}。



例如：




\begin{minted}{jlcon}
julia> A = reshape(collect(1:16), (2, 2, 2, 2))
2×2×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia> A[1, 2, 1, 1] # all scalar indices
3

julia> A[[1, 2], [1], [1, 2], [1]] # all vector indices
2×1×2×1 Array{Int64,4}:
[:, :, 1, 1] =
 1
 2

[:, :, 2, 1] =
 5
 6

julia> A[[1, 2], [1], [1, 2], 1] # a mix of index types
2×1×2 Array{Int64,3}:
[:, :, 1] =
 1
 2

[:, :, 2] =
 5
 6
\end{minted}



请注意最后两种情况下得到的数组大小为何是不同的。



如果 \texttt{I\_1} 是二维矩阵，则 \texttt{X} 是 \texttt{n+1} 维数组，其形状为 \texttt{(size(I\_1, 1), size(I\_1, 2), length(I\_2), ..., length(I\_n))}。矩阵会添加一个维度。



例如：




\begin{minted}{jlcon}
julia> A = reshape(collect(1:16), (2, 2, 2, 2));

julia> A[[1 2; 1 2]]
2×2 Array{Int64,2}:
 1  2
 1  2

julia> A[[1 2; 1 2], 1, 2, 1]
2×2 Array{Int64,2}:
 5  6
 5  6
\end{minted}



位于 \texttt{i\_1, i\_2, i\_3, ..., i\_\{n+1\}} 处的元素值是 \texttt{A[I\_1[i\_1, i\_2], I\_2[i\_3], ..., I\_n[i\_\{n+1\}]]}。所有使用标量索引的维度都将被丢弃，例如，假设 \texttt{J} 是索引数组，那么 \texttt{A[2，J，3]} 的结果是一个大小为 \texttt{size(J)} 的数组、其第 j 个元素由 \texttt{A[2, J[j], 3]} 填充。



作为此语法的特殊部分，\texttt{end} 关键字可用于表示索引括号内每个维度的最后一个索引，由索引的最内层数组的大小决定。没有 \texttt{end} 关键字的索引语法相当于调用\hyperlink{13720608614876840481}{\texttt{getindex}}：




\begin{lstlisting}
X = getindex(A, I_1, I_2, ..., I_n)
\end{lstlisting}



例如：




\begin{minted}{jlcon}
julia> x = reshape(1:16, 4, 4)
4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> x[2:3, 2:end-1]
2×2 Array{Int64,2}:
 6  10
 7  11

julia> x[1, [2 3; 4 1]]
2×2 Array{Int64,2}:
  5  9
 13  1
\end{minted}



\hypertarget{7105044708769418916}{}


\section{Indexed Assignment}



在 n 维数组 \texttt{A} 中赋值的一般语法是：




\begin{lstlisting}
A[I_1, I_2, ..., I_n] = X
\end{lstlisting}



其中每个 \texttt{I\_k} 可以是标量整数，整数数组或任何其他\hyperlink{3335763678693018755}{支持的索引类型}。这包括 \hyperlink{13649361117037263099}{\texttt{Colon}} (\texttt{:}) 来选择整个维度中的所有索引，形式为 \texttt{a:c} 或 \texttt{a:b:c} 的范围来选择连续或跨步的子区间，以及布尔数组以选择索引为 \texttt{true} 的元素。



如果所有 \texttt{I\_k} 都为整数，则数组 \texttt{A} 中 \texttt{I\_1, I\_2, ..., I\_n} 位置的值将被 \texttt{X} 的值覆盖，必要时将 \hyperlink{1846942650946171605}{\texttt{convert}} 为数组 \texttt{A} 的 \hyperlink{6396209842929672718}{\texttt{eltype}}。



如果任一 \texttt{I\_k} 选择了一个以上的位置，则等号右侧的 \texttt{X} 必须为一个与 \texttt{A[I\_1, I\_2, ..., I\_n]} 形状一致的数组或一个具有相同元素数的向量。数组 \texttt{A} 中 \texttt{I\_1[i\_1], I\_2[i\_2], ..., I\_n[i\_n]} 位置的值将被 \texttt{X[I\_1, I\_2, ..., I\_n]} 的值覆盖，必要时会转换类型。逐元素的赋值运算符 \texttt{.=} 可以用于将 \texttt{X} 沿选择的位置 \hyperlink{10888979137852348176}{broadcast}：




\begin{lstlisting}
A[I_1, I_2, ..., I_n] .= X
\end{lstlisting}



就像在\hyperlink{16717190941363337071}{索引}中一样，\texttt{end}关键字可用于表示索引括号中每个维度的最后一个索引，由被赋值的数组大小决定。 没有\texttt{end}关键字的索引赋值语法相当于调用\hyperlink{1309244355901386657}{\texttt{setindex!}}：




\begin{lstlisting}
setindex!(A, X, I_1, I_2, ..., I_n)
\end{lstlisting}



例如：




\begin{minted}{jlcon}
julia> x = collect(reshape(1:9, 3, 3))
3×3 Array{Int64,2}:
 1  4  7
 2  5  8
 3  6  9

julia> x[3, 3] = -9;

julia> x[1:2, 1:2] = [-1 -4; -2 -5];

julia> x
3×3 Array{Int64,2}:
 -1  -4   7
 -2  -5   8
  3   6  -9
\end{minted}



\hypertarget{982887983034702059}{}


\section{支持的索引类型}



在表达式 \texttt{A[I\_1, I\_2, ..., I\_n]} 中，每个 \texttt{I\_k} 可以是标量索引，标量索引数组，或者用 \hyperlink{10027537986402266830}{\texttt{to\_indices}} 转换成的表示标量索引数组的对象：



\begin{itemize}
\item[1. ] 标量索引。默认情况下，这包括：

\begin{itemize}
\item 非布尔的整数


\item \href{@ref}{\href{@ref}{\texttt{CartesianIndex \{N\}}}s，其行为类似于跨越多个维度的 \texttt{N} 维整数元组（详见下文）}s, which behave like an \texttt{N}-tuple of integers spanning multiple dimensions (see below for more details)

\end{itemize}

\item[2. ] 标量索引数组。这包括：

\begin{itemize}
\item 整数向量和多维整数数组


\item 像 \texttt{[]} 这样的空数组，它不选择任何元素


\item 如 \texttt{a:c} 或 \texttt{a:b:c} 的范围，从 \texttt{a} 到 \texttt{c}（包括）选择连续或间隔的部分元素


\item 任何自定义标量索引数组，它是 \texttt{AbstractArray} 的子类型


\item \texttt{CartesianIndex\{N\}} 数组（详见下文）

\end{itemize}

\item[3. ] 一个表示标量索引数组的对象，可以通过\hyperlink{10027537986402266830}{\texttt{to\_indices}}转换为这样的对象。 默认情况下，这包括：

\begin{itemize}
\item \hyperlink{13649361117037263099}{\texttt{Colon()}} (\texttt{:})，表示整个维度内或整个数组中的所有索引


\item 布尔数组，选择其中值为 \texttt{true} 的索引对应的元素（更多细节见下文）

\end{itemize}
\end{itemize}


一些例子：




\begin{minted}{jlcon}
julia> A = reshape(collect(1:2:18), (3, 3))
3×3 Array{Int64,2}:
 1   7  13
 3   9  15
 5  11  17

julia> A[4]
7

julia> A[[2, 5, 8]]
3-element Array{Int64,1}:
  3
  9
 15

julia> A[[1 4; 3 8]]
2×2 Array{Int64,2}:
 1   7
 5  15

julia> A[[]]
Int64[]

julia> A[1:2:5]
3-element Array{Int64,1}:
 1
 5
 9

julia> A[2, :]
3-element Array{Int64,1}:
  3
  9
 15

julia> A[:, 3]
3-element Array{Int64,1}:
 13
 15
 17
\end{minted}



\hypertarget{6884198732360978942}{}


\subsection{笛卡尔索引}



特殊的 \texttt{CartesianIndex\{N\}} 对象表示一个标量索引，其行为类似于张成多个维度的 \texttt{N} 维整数元组。例如：




\begin{minted}{jlcon}
julia> A = reshape(1:32, 4, 4, 2);

julia> A[3, 2, 1]
7

julia> A[CartesianIndex(3, 2, 1)] == A[3, 2, 1] == 7
true
\end{minted}



如果单独考虑，这可能看起来相对微不足道；\texttt{CartesianIndex} 只是将多个整数聚合成一个表示单个多维索引的对象。 但是，当与其他索引形式和迭代器组合产生多个 \texttt{CartesianIndex} 时，这可以生成非常优雅和高效的代码。请参阅下面的\hyperlink{13048041929642713791}{迭代}，有关更高级的示例，请参阅\href{https://julialang.org/blog/2016/02/iteration}{关于多维算法和迭代博客文章}。



也支持 \texttt{CartesianIndex \{N\}} 的数组。它们代表一组标量索引，每个索引都跨越 \texttt{N} 个维度，从而实现一种有时也称为逐点索引的索引形式。例如，它可以从上面的 \texttt{A} 的第一「页」访问对角元素：




\begin{minted}{jlcon}
julia> page = A[:,:,1]
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> page[[CartesianIndex(1,1),
             CartesianIndex(2,2),
             CartesianIndex(3,3),
             CartesianIndex(4,4)]]
4-element Array{Int64,1}:
  1
  6
 11
 16
\end{minted}



这可以通过 \hyperlink{17801130558550430478}{dot broadcasting} 以及普通整数索引（而不是把从 \texttt{A} 中提取第一“页”作为单独的步骤）更加简单地表达。它甚至可以与 \texttt{:} 结合使用，同时从两个页面中提取两个对角线：




\begin{minted}{jlcon}
julia> A[CartesianIndex.(axes(A, 1), axes(A, 2)), 1]
4-element Array{Int64,1}:
  1
  6
 11
 16

julia> A[CartesianIndex.(axes(A, 1), axes(A, 2)), :]
4×2 Array{Int64,2}:
  1  17
  6  22
 11  27
 16  32
\end{minted}



\begin{quote}
\textbf{Warning}

\texttt{CartesianIndex} and arrays of \texttt{CartesianIndex} are not compatible with the \texttt{end} keyword to represent the last index of a dimension. Do not use \texttt{end} in indexing expressions that may contain either \texttt{CartesianIndex} or arrays thereof.

\end{quote}


\hypertarget{5700513412579425383}{}


\subsection{Logical indexing}



Often referred to as logical indexing or indexing with a logical mask, indexing by a boolean array selects elements at the indices where its values are \texttt{true}. Indexing by a boolean vector \texttt{B} is effectively the same as indexing by the vector of integers that is returned by \hyperlink{16067208921941164599}{\texttt{findall(B)}}. Similarly, indexing by a \texttt{N}-dimensional boolean array is effectively the same as indexing by the vector of \texttt{CartesianIndex\{N\}}s where its values are \texttt{true}. A logical index must be a vector of the same length as the dimension it indexes into, or it must be the only index provided and match the size and dimensionality of the array it indexes into. It is generally more efficient to use boolean arrays as indices directly instead of first calling \hyperlink{16067208921941164599}{\texttt{findall}}.




\begin{minted}{jlcon}
julia> x = reshape(1:16, 4, 4)
4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> x[[false, true, true, false], :]
2×4 Array{Int64,2}:
 2  6  10  14
 3  7  11  15

julia> mask = map(ispow2, x)
4×4 Array{Bool,2}:
 1  0  0  0
 1  0  0  0
 0  0  0  0
 1  1  0  1

julia> x[mask]
5-element Array{Int64,1}:
  1
  2
  4
  8
 16
\end{minted}



\hypertarget{8886266762373473264}{}


\subsection{Number of indices}



\hypertarget{740108784806621199}{}


\subsubsection{Cartesian indexing}



The ordinary way to index into an \texttt{N}-dimensional array is to use exactly \texttt{N} indices; each index selects the position(s) in its particular dimension. For example, in the three-dimensional array \texttt{A = rand(4, 3, 2)}, \texttt{A[2, 3, 1]} will select the number in the second row of the third column in the first {\textquotedbl}page{\textquotedbl} of the array. This is often referred to as \emph{cartesian indexing}.



\hypertarget{18413909182716267462}{}


\subsubsection{Linear indexing}



When exactly one index \texttt{i} is provided, that index no longer represents a location in a particular dimension of the array. Instead, it selects the \texttt{i}th element using the column-major iteration order that linearly spans the entire array. This is known as \emph{linear indexing}. It essentially treats the array as though it had been reshaped into a one-dimensional vector with \hyperlink{18435874855636770528}{\texttt{vec}}.




\begin{minted}{jlcon}
julia> A = [2 6; 4 7; 3 1]
3×2 Array{Int64,2}:
 2  6
 4  7
 3  1

julia> A[5]
7

julia> vec(A)[5]
7
\end{minted}



A linear index into the array \texttt{A} can be converted to a \texttt{CartesianIndex} for cartesian indexing with \texttt{CartesianIndices(A)[i]} (see \hyperlink{16831958174907250244}{\texttt{CartesianIndices}}), and a set of \texttt{N} cartesian indices can be converted to a linear index with \texttt{LinearIndices(A)[i\_1, i\_2, ..., i\_N]} (see \hyperlink{12250457823889413092}{\texttt{LinearIndices}}).




\begin{minted}{jlcon}
julia> CartesianIndices(A)[5]
CartesianIndex(2, 2)

julia> LinearIndices(A)[2, 2]
5
\end{minted}



It{\textquotesingle}s important to note that there{\textquotesingle}s a very large assymmetry in the performance of these conversions. Converting a linear index to a set of cartesian indices requires dividing and taking the remainder, whereas going the other way is just multiplies and adds. In modern processors, integer division can be 10-50 times slower than multiplication. While some arrays — like \hyperlink{15492651498431872487}{\texttt{Array}} itself — are implemented using a linear chunk of memory and directly use a linear index in their implementations, other arrays — like \hyperlink{3300114559258360989}{\texttt{Diagonal}} — need the full set of cartesian indices to do their lookup (see \hyperlink{7782790551324367092}{\texttt{IndexStyle}} to introspect which is which). As such, when iterating over an entire array, it{\textquotesingle}s much better to iterate over \hyperlink{4701773772897287974}{\texttt{eachindex(A)}} instead of \texttt{1:length(A)}. Not only will the former be much faster in cases where \texttt{A} is \texttt{IndexCartesian}, but it will also support OffsetArrays, too.



\hypertarget{3274469472431833212}{}


\subsubsection{Omitted and extra indices}



In addition to linear indexing, an \texttt{N}-dimensional array may be indexed with fewer or more than \texttt{N} indices in certain situations.



Indices may be omitted if the trailing dimensions that are not indexed into are all length one. In other words, trailing indices can be omitted only if there is only one possible value that those omitted indices could be for an in-bounds indexing expression. For example, a four-dimensional array with size \texttt{(3, 4, 2, 1)} may be indexed with only three indices as the dimension that gets skipped (the fourth dimension) has length one. Note that linear indexing takes precedence over this rule.




\begin{minted}{jlcon}
julia> A = reshape(1:24, 3, 4, 2, 1)
3×4×2×1 reshape(::UnitRange{Int64}, 3, 4, 2, 1) with eltype Int64:
[:, :, 1, 1] =
 1  4  7  10
 2  5  8  11
 3  6  9  12

[:, :, 2, 1] =
 13  16  19  22
 14  17  20  23
 15  18  21  24

julia> A[1, 3, 2] # Omits the fourth dimension (length 1)
19

julia> A[1, 3] # Attempts to omit dimensions 3 & 4 (lengths 2 and 1)
ERROR: BoundsError: attempt to access 3×4×2×1 reshape(::UnitRange{Int64}, 3, 4, 2, 1) with eltype Int64 at index [1, 3]

julia> A[19] # Linear indexing
19
\end{minted}



When omitting \emph{all} indices with \texttt{A[]}, this semantic provides a simple idiom to retrieve the only element in an array and simultaneously ensure that there was only one element.



Similarly, more than \texttt{N} indices may be provided if all the indices beyond the dimensionality of the array are \texttt{1} (or more generally are the first and only element of \texttt{axes(A, d)} where \texttt{d} is that particular dimension number). This allows vectors to be indexed like one-column matrices, for example:




\begin{minted}{jlcon}
julia> A = [8,6,7]
3-element Array{Int64,1}:
 8
 6
 7

julia> A[2,1]
6
\end{minted}



\hypertarget{5063194151918629111}{}


\section{迭代}



迭代整个数组的推荐方法是




\begin{minted}{julia}
for a in A
    # Do something with the element a
end

for i in eachindex(A)
    # Do something with i and/or A[i]
end
\end{minted}



当你需要每个元素的值而不是索引时，使用第一个构造。 在第二个构造中，如果 \texttt{A} 是具有快速线性索引的数组类型，\texttt{i} 将是 \texttt{Int}; 否则，它将是一个 \texttt{CartesianIndex}：




\begin{minted}{jlcon}
julia> A = rand(4,3);

julia> B = view(A, 1:3, 2:3);

julia> for i in eachindex(B)
           @show i
       end
i = CartesianIndex(1, 1)
i = CartesianIndex(2, 1)
i = CartesianIndex(3, 1)
i = CartesianIndex(1, 2)
i = CartesianIndex(2, 2)
i = CartesianIndex(3, 2)
\end{minted}



与 \texttt{for i = 1:length(A)} 相比，\hyperlink{4701773772897287974}{\texttt{eachindex}} 提供了一种迭代任何数组类型的有效方法。



\hypertarget{10166346050354504892}{}


\section{Array traits}



如果你编写一个自定义的 \hyperlink{6514416309183787338}{\texttt{AbstractArray}} 类型，你可以用以下代码指定它使用快速线性索引




\begin{minted}{julia}
Base.IndexStyle(::Type{<:MyArray}) = IndexLinear()
\end{minted}



此设置将导致 \texttt{myArray} 上的 \texttt{eachindex} 迭代使用整数。如果未指定此特征，则使用默认值 \texttt{IndexCartesian()}。



\hypertarget{1179855062476093403}{}


\section{Array and Vectorized Operators and Functions}



以下运算符支持对数组操作



\begin{itemize}
\item[1. ] 一元运算符 – \texttt{-}, \texttt{+}


\item[2. ] 二元运算符 – \texttt{-}, \texttt{+}, \texttt{*}, \texttt{/}, \texttt{{\textbackslash}}, \texttt{{\textasciicircum}}


\item[3. ] 比较操作符 – \texttt{==}, \texttt{!=}, \texttt{≈} (\hyperlink{12499503887608197213}{\texttt{isapprox}}), \texttt{≉}

\end{itemize}


另外，为了便于数学上和其他运算的向量化，Julia \hyperlink{17801130558550430478}{提供了点语法（dot syntax）} \texttt{f.(args...)}，例如，\texttt{sin.(x)} 或 \texttt{min.(x,y)}，用于数组或数组和标量的混合上的按元素运算（\hyperlink{10888979137852348176}{广播}运算）；当与其他点调用（dot call）结合使用时，它们的额外优点是能「融合」到单个循环中，例如，\texttt{sin.(cos.(x))}。



此外，\emph{每个}二元运算符支持相应的\hyperlink{15967322336376951940}{点操作版本}，可以应用于此类\hyperlink{17801130558550430478}{融合 broadcasting 操作}的数组（以及数组和标量的组合），例如 \texttt{z .== sin.(x .* y)}。



请注意，类似 \texttt{==} 的比较运算在作用于整个数组时，得到一个布尔结果。使用像 \texttt{.==} 这样的点运算符进行按元素的比较。（对于像 \texttt{<} 这样的比较操作，\emph{只有}按元素运算的版本 \texttt{.<} 适用于数组。）



还要注意 \texttt{max.(a,b)} 和 \hyperlink{14719513931696680717}{\texttt{maximum(a)}} 之间的区别，\texttt{max.(a,b)} 对 \texttt{a} 和 \texttt{b} 的每个元素 \hyperlink{616124539803111168}{\texttt{broadcast}}s \hyperlink{7839419811914289844}{\texttt{max}}，\hyperlink{14719513931696680717}{\texttt{maximum(a)}} 寻找在 \texttt{a} 中的最大值。\texttt{min.(a,b)} 和 \texttt{minimum(a)} 也有同样的关系。



\hypertarget{7321350919619265679}{}


\section{广播}



有时需要在不同尺寸的数组上执行元素对元素的操作，例如将矩阵的每一列加一个向量。一种低效的方法是将向量复制成矩阵的大小：




\begin{minted}{jlcon}
julia> a = rand(2,1); A = rand(2,3);

julia> repeat(a,1,3)+A
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846
\end{minted}



当维度较大的时候，这种方法将会十分浪费，所以 Julia 提供了广播 \hyperlink{616124539803111168}{\texttt{broadcast}}，它将会将参数中低维度的参数扩展，使得其与其他维度匹配，且不会使用额外的内存，并将所给的函数逐元素地应用。




\begin{minted}{jlcon}
julia> broadcast(+, a, A)
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846

julia> b = rand(1,2)
1×2 Array{Float64,2}:
 0.867535  0.00457906

julia> broadcast(+, a, b)
2×2 Array{Float64,2}:
 1.71056  0.847604
 1.73659  0.873631
\end{minted}



\hyperlink{15967322336376951940}{Dotted operators} such as \texttt{.+} and \texttt{.*} are equivalent to \texttt{broadcast} calls (except that they fuse, as \hyperlink{4802910107640435151}{described above}). There is also a \hyperlink{7631985657411687574}{\texttt{broadcast!}} function to specify an explicit destination (which can also be accessed in a fusing fashion by \texttt{.=} assignment). In fact, \texttt{f.(args...)} is equivalent to \texttt{broadcast(f, args...)}, providing a convenient syntax to broadcast any function (\hyperlink{17801130558550430478}{dot syntax}). Nested {\textquotedbl}dot calls{\textquotedbl} \texttt{f.(...)} (including calls to \texttt{.+} etcetera) \hyperlink{15967322336376951940}{automatically fuse} into a single \texttt{broadcast} call.



Additionally, \hyperlink{616124539803111168}{\texttt{broadcast}} is not limited to arrays (see the function documentation); it also handles scalars, tuples and other collections.  By default, only some argument types are considered scalars, including (but not limited to) \texttt{Number}s, \texttt{String}s, \texttt{Symbol}s, \texttt{Type}s, \texttt{Function}s and some common singletons like \texttt{missing} and \texttt{nothing}. All other arguments are iterated over or indexed into elementwise.




\begin{minted}{jlcon}
julia> convert.(Float32, [1, 2])
2-element Array{Float32,1}:
 1.0
 2.0

julia> ceil.(UInt8, [1.2 3.4; 5.6 6.7])
2×2 Array{UInt8,2}:
 0x02  0x04
 0x06  0x07

julia> string.(1:3, ". ", ["First", "Second", "Third"])
3-element Array{String,1}:
 "1. First"
 "2. Second"
 "3. Third"
\end{minted}



Sometimes, you want a container (like an array) that would normally participate in broadcast to be {\textquotedbl}protected{\textquotedbl} from broadcast{\textquotesingle}s behavior of iterating over all of its elements. By placing it inside another container (like a single element \hyperlink{17462354060312563026}{\texttt{Tuple}}) broadcast will treat it as a single value.




\begin{minted}{jlcon}
julia> ([1, 2, 3], [4, 5, 6]) .+ ([1, 2, 3],)
([2, 4, 6], [5, 7, 9])

julia> ([1, 2, 3], [4, 5, 6]) .+ tuple([1, 2, 3])
([2, 4, 6], [5, 7, 9])
\end{minted}



\hypertarget{2709595058891761459}{}


\section{实现}



Julia 中的基本数组类型是抽象类型 \hyperlink{6514416309183787338}{\texttt{AbstractArray\{T,N\}}}。它通过维数 \texttt{N} 和元素类型 \texttt{T} 进行参数化。\hyperlink{12517057979818647811}{\texttt{AbstractVector}} 和 \hyperlink{17966587371929951201}{\texttt{AbstractMatrix}} 是一维和二维情况下的别名。\texttt{AbstractArray} 对象的操作是使用更高级别的运算符和函数定义的，其方式独立于底层存储。这些操作可以正确地被用于任何特定数组实现的回退操作。



\texttt{AbstractArray} 类型包含任何模糊类似的东西，它的实现可能与传统数组完全不同。例如，可以根据请求而不是存储来计算元素。但是，任何具体的 \texttt{AbstractArray\{T,N\}} 类型通常应该至少实现 \hyperlink{17888996102305087038}{\texttt{size(A)}}（返回 \texttt{Int} 元组），\hyperlink{2839226020402435013}{\texttt{getindex(A,i)}} 和 \hyperlink{13720608614876840481}{\texttt{getindex(A,i1,...,iN)}}；可变数组也应该实现 \hyperlink{1309244355901386657}{\texttt{setindex!}}。建议这些操作具有几乎为常数的时间复杂性，或严格说来 Õ(1) 复杂性，否则某些数组函数可能出乎意料的慢。具体类型通常还应提供 \hyperlink{15525808546723795098}{\texttt{similar(A,T=eltype(A),dims=size(A))}} 方法，用于为 \hyperlink{15665284441316555522}{\texttt{copy}} 分配类似的数组和其他位于当前数组空间外的操作。无论在内部如何表示 \texttt{AbstractArray\{T,N\}}，\texttt{T} 是由 \emph{整数} 索引返回的对象类型（\texttt{A[1, ..., 1]}，当 \texttt{A} 不为空），\texttt{N} 应该是 \hyperlink{17888996102305087038}{\texttt{size}} 返回的元组的长度。有关定义自定义 \texttt{AbstractArray} 实现的更多详细信息，请参阅\hyperlink{9718377734213742156}{接口章节中的数组接口导则}。



\texttt{DenseArray} is an abstract subtype of \texttt{AbstractArray} intended to include all arrays where elements are stored contiguously in column-major order (see \hyperlink{11239800376478112527}{additional notes in Performance Tips}). The \hyperlink{15492651498431872487}{\texttt{Array}} type is a specific instance of \texttt{DenseArray};  \hyperlink{10571362059486397014}{\texttt{Vector}} and \hyperlink{5448927444601277512}{\texttt{Matrix}} are aliases for the 1-d and 2-d cases. Very few operations are implemented specifically for \texttt{Array} beyond those that are required for all \texttt{AbstractArray}s; much of the array library is implemented in a generic manner that allows all custom arrays to behave similarly.



\texttt{SubArray} 是 \texttt{AbstractArray} 的特例，它通过与原始数组共享内存而不是复制它来执行索引。 使用\hyperlink{4861450464669906845}{\texttt{view}} 函数创建 \texttt{SubArray}，它的调用方式与\hyperlink{13720608614876840481}{\texttt{getindex}} 相同（作用于数组和一系列索引参数）。 \hyperlink{4861450464669906845}{\texttt{view}} 的结果看起来与 \hyperlink{13720608614876840481}{\texttt{getindex}} 的结果相同，只是数据保持不变。 \hyperlink{4861450464669906845}{\texttt{view}} 将输入索引向量存储在 \texttt{SubArray} 对象中，该对象稍后可用于间接索引原始数组。 通过将  \hyperlink{4544474300423667148}{\texttt{@views}} 宏放在表达式或代码块之前，该表达式中的任何 \texttt{array [...]} 切片将被转换为创建一个 \texttt{SubArray} 视图。



\hyperlink{18015155802543401629}{\texttt{BitArray}} 是节省空间“压缩”的布尔数组，每个比特（bit）存储一个布尔值。 它们可以类似于 \texttt{Array\{Bool\}} 数组（每个字节（byte）存储一个布尔值），并且可以分别通过 \texttt{Array(bitarray)} 和 \texttt{BitArray(array)} 相互转换。



An array is {\textquotedbl}strided{\textquotedbl} if it is stored in memory with well-defined spacings (strides) between its elements. A strided array with a supported element type may be passed to an external (non-Julia) library like BLAS or LAPACK by simply passing its \hyperlink{8901246211940014300}{\texttt{pointer}} and the stride for each dimension. The \hyperlink{97811245619734938}{\texttt{stride(A, d)}} is the distance between elements along dimension \texttt{d}. For example, the builtin \texttt{Array} returned by \texttt{rand(5,7,2)} has its elements arranged contiguously in column major order. This means that the stride of the first dimension — the spacing between elements in the same column — is \texttt{1}:




\begin{minted}{jlcon}
julia> A = rand(5,7,2);

julia> stride(A,1)
1
\end{minted}



The stride of the second dimension is the spacing between elements in the same row, skipping as many elements as there are in a single column (\texttt{5}). Similarly, jumping between the two {\textquotedbl}pages{\textquotedbl} (in the third dimension) requires skipping \texttt{5*7 == 35} elements.  The \hyperlink{13576557637670855932}{\texttt{strides}} of this array is the tuple of these three numbers together:




\begin{minted}{jlcon}
julia> strides(A)
(1, 5, 35)
\end{minted}



In this particular case, the number of elements skipped \emph{in memory} matches the number of \emph{linear indices} skipped. This is only the case for contiguous arrays like \texttt{Array} (and other \texttt{DenseArray} subtypes) and is not true in general. Views with range indices are a good example of \emph{non-contiguous} strided arrays; consider \texttt{V = @view A[1:3:4, 2:2:6, 2:-1:1]}. This view \texttt{V} refers to the same memory as \texttt{A} but is skipping and re-arranging some of its elements. The stride of the first dimension of \texttt{V} is \texttt{3} because we{\textquotesingle}re only selecting every third row from our original array:




\begin{minted}{jlcon}
julia> V = @view A[1:3:4, 2:2:6, 2:-1:1];

julia> stride(V, 1)
3
\end{minted}



This view is similarly selecting every other column from our original \texttt{A} — and thus it needs to skip the equivalent of two five-element columns when moving between indices in the second dimension:




\begin{minted}{jlcon}
julia> stride(V, 2)
10
\end{minted}



The third dimension is interesting because its order is reversed! Thus to get from the first {\textquotedbl}page{\textquotedbl} to the second one it must go \emph{backwards} in memory, and so its stride in this dimension is negative!




\begin{minted}{jlcon}
julia> stride(V, 3)
-35
\end{minted}



This means that the \texttt{pointer} for \texttt{V} is actually pointing into the middle of \texttt{A}{\textquotesingle}s memory block, and it refers to elements both backwards and forwards in memory. See the \hyperlink{3010450308855105276}{interface guide for strided arrays} for more details on defining your own strided arrays. \hyperlink{18350706206094827862}{\texttt{StridedVector}} and \hyperlink{3855703768476610836}{\texttt{StridedMatrix}} are convenient aliases for many of the builtin array types that are considered strided arrays, allowing them to dispatch to select specialized implementations that call highly tuned and optimized BLAS and LAPACK functions using just the pointer and strides.



It is worth emphasizing that strides are about offsets in memory rather than indexing. If you are looking to convert between linear (single-index) indexing and cartesian (multi-index) indexing, see \hyperlink{12250457823889413092}{\texttt{LinearIndices}} and \hyperlink{16831958174907250244}{\texttt{CartesianIndices}}.



\hypertarget{16922701023279192482}{}


\chapter{缺失值}



Julia 支持表示统计意义上的缺失值，即某个变量在观察中没有可用值，但在理论上存在有效值的情况。缺失值由 \hyperlink{14596725676261444434}{\texttt{missing}} 对象表示，该对象是 \hyperlink{9306488559141158579}{\texttt{Missing}} 类型的唯一实例。\texttt{missing} 等价于 \href{https://en.wikipedia.org/wiki/NULL\_(SQL)}{SQL 中的 \texttt{NULL}} 以及 \href{https://cran.r-project.org/doc/manuals/r-release/R-lang.html\#NA-handling}{R 中的 \texttt{NA}}，并在大多数情况下表现得与它们一样。



\hypertarget{16983381017967078050}{}


\section{缺失值的传播}



\texttt{missing} values \emph{propagate} automatically when passed to standard mathematical operators and functions. For these functions, uncertainty about the value of one of the operands induces uncertainty about the result. In practice, this means a math operation involving a \texttt{missing} value generally returns \texttt{missing}




\begin{minted}{jlcon}
julia> missing + 1
missing

julia> "a" * missing
missing

julia> abs(missing)
missing
\end{minted}



As \texttt{missing} is a normal Julia object, this propagation rule only works for functions which have opted in to implement this behavior. This can be achieved either via a specific method defined for arguments of type \texttt{Missing}, or simply by accepting arguments of this type, and passing them to functions which propagate them (like standard math operators). Packages should consider whether it makes sense to propagate missing values when defining new functions, and define methods appropriately if that is the case. Passing a \texttt{missing} value to a function for which no method accepting arguments of type \texttt{Missing} is defined throws a \hyperlink{68769522931907606}{\texttt{MethodError}}, just like for any other type.



Functions that do not propagate \texttt{missing} values can be made to do so by wrapping them in the \texttt{passmissing} function provided by the \href{https://github.com/JuliaData/Missings.jl}{Missings.jl} package. For example, \texttt{f(x)} becomes \texttt{passmissing(f)(x)}.



\hypertarget{13926030736377467708}{}


\section{相等和比较运算符}



标准相等和比较运算符遵循上面给出的传播规则：如果任何操作数是 \texttt{missing}，那么结果是 \texttt{missing}。这是一些例子




\begin{minted}{jlcon}
julia> missing == 1
missing

julia> missing == missing
missing

julia> missing < 1
missing

julia> 2 >= missing
missing
\end{minted}



特别要注意，\texttt{missing == missing} 返回 \texttt{missing}，所以 \texttt{==} 不能用于测试值是否为缺失值。要测试 \texttt{x} 是否为 \texttt{missing}，请用 \hyperlink{3452327148507948899}{\texttt{ismissing(x)}}。



特殊的比较运算符 \hyperlink{269533589463185031}{\texttt{isequal}} 和 \hyperlink{7974744969331231272}{\texttt{===}} 是传播规则的例外：它们总返回一个 \texttt{Bool} 值，即使存在 \texttt{missing} 值，并认为 \texttt{missing} 与 \texttt{missing} 相等且其与任何其它值不同。因此，它们可用于测试某个值是否为 \texttt{missing}。




\begin{minted}{jlcon}
julia> missing === 1
false

julia> isequal(missing, 1)
false

julia> missing === missing
true

julia> isequal(missing, missing)
true
\end{minted}



\hyperlink{8062916604071842790}{\texttt{isless}} 运算符是另一个例外：\texttt{missing} 被认为比任何其它值大。此运算符被用于 \hyperlink{8473525809131227606}{\texttt{sort}}，因此 \texttt{missing} 值被放置在所有其它值之后。




\begin{minted}{jlcon}
julia> isless(1, missing)
true

julia> isless(missing, Inf)
false

julia> isless(missing, missing)
false
\end{minted}



\hypertarget{2677689633086417735}{}


\section{逻辑运算符}



逻辑（或布尔）运算符 \hyperlink{9633687763646488853}{\texttt{|}}、\hyperlink{1494761116451616317}{\texttt{\&}} 和 \hyperlink{7071880015536674935}{\texttt{xor}} 是另一种特殊情况，因为它们只有在逻辑上是必需的时传递 \texttt{missing} 值。对于这些运算符来说，结果是否不确定取决于具体操作，其遵循\href{https://en.wikipedia.org/wiki/Three-valued\_logic}{\emph{三值逻辑}}的既定规则，这些规则也由 SQL 中的 \texttt{NULL} 以及 R 中的 \texttt{NA} 实现。这个抽象的定义实际上对应于一系列相对自然的行为，这最好通过具体的例子来解释。



让我们用逻辑「或」运算符 \hyperlink{9633687763646488853}{\texttt{|}} 来说明这个原理。按照布尔逻辑的规则，如果其中一个操作数是 \texttt{true}，则另一个操作数对结果没影响，结果总是 \texttt{true}。




\begin{minted}{jlcon}
julia> true | true
true

julia> true | false
true

julia> false | true
true
\end{minted}



基于观察，我们可以得出结论，如果其中一个操作数是 \texttt{true} 而另一个是 \texttt{missing}，我们知道结果为 \texttt{true}，尽管另一个参数的实际值存在不确定性。如果我们能观察到第二个操作数的实际值，那么它只能是 \texttt{true} 或 \texttt{false}，在两种情况下结果都是 \texttt{true}。因此，在这种特殊情况下，值的缺失不会传播




\begin{minted}{jlcon}
julia> true | missing
true

julia> missing | true
true
\end{minted}



相反地，如果其中一个操作数是 \texttt{false}，结果可能是 \texttt{true} 或 \texttt{false}，这取决于另一个操作数的值。因此，如果一个操作数是 \texttt{missing}，那么结果也是 \texttt{missing}。




\begin{minted}{jlcon}
julia> false | true
true

julia> true | false
true

julia> false | false
false

julia> false | missing
missing

julia> missing | false
missing
\end{minted}



逻辑「且」运算符 \hyperlink{1494761116451616317}{\texttt{\&}} 的行为与 \texttt{|} 运算符相似，区别在于当其中一个操作数为 \texttt{false} 时，值的缺失不会传播。例如，当第一个操作数是 \texttt{false} 时




\begin{minted}{jlcon}
julia> false & false
false

julia> false & true
false

julia> false & missing
false
\end{minted}



另一方面，当其中一个操作数为 \texttt{true} 时，值的缺失会传播，例如，当第一个操作数是 \texttt{true} 时




\begin{minted}{jlcon}
julia> true & true
true

julia> true & false
false

julia> true & missing
missing
\end{minted}



最后，逻辑「异或」运算符 \hyperlink{7071880015536674935}{\texttt{xor}} 总传播 \texttt{missing} 值，因为两个操作数都总是对结果产生影响。还要注意，否定运算符 \hyperlink{4329035214952292986}{\texttt{!}} 在操作数是 \texttt{missing} 时返回 \texttt{missing}，这就像其它一元运算符。



\hypertarget{354241034752728129}{}


\section{流程控制和短路运算符}



流程控制操作符，包括 \hyperlink{11624168233949720742}{\texttt{if}}、\hyperlink{15133348314455964692}{\texttt{while}} 和\hyperlink{14451148373001501733}{三元运算符} \texttt{x ? y : z}，不允许缺失值。这是因为如果我们能够观察实际值，它是 \texttt{true} 还是 \texttt{false} 是不确定的，这意味着我们不知道程序应该如何运行。一旦在以下上下文中遇到 \texttt{missing} 值，就会抛出 \hyperlink{2622693721821893139}{\texttt{TypeError}}




\begin{minted}{jlcon}
julia> if missing
           println("here")
       end
ERROR: TypeError: non-boolean (Missing) used in boolean context
\end{minted}



出于同样的原因，并与上面给出的逻辑运算符相反，短路布尔运算符 \hyperlink{4714012140247170866}{\texttt{\&\&}} 和 \hyperlink{2053797086840563251}{\texttt{||}} 在当前操作数的值决定下一个操作数是否求值时不允许 \texttt{missing} 值。例如




\begin{minted}{jlcon}
julia> missing || false
ERROR: TypeError: non-boolean (Missing) used in boolean context

julia> missing && false
ERROR: TypeError: non-boolean (Missing) used in boolean context

julia> true && missing && false
ERROR: TypeError: non-boolean (Missing) used in boolean context
\end{minted}



另一方面，如果无需 \texttt{missing} 值即可确定结果，则不会引发错误。代码在对 \texttt{missing} 操作数求值前短路，以及 \texttt{missing} 是最后一个操作数都是这种情况。




\begin{minted}{jlcon}
julia> true && missing
missing

julia> false && missing
false
\end{minted}



\hypertarget{929400294062348079}{}


\section{包含缺失值的数组}



包含缺失值的数组的创建就像其它数组




\begin{minted}{jlcon}
julia> [1, missing]
2-element Array{Union{Missing, Int64},1}:
 1
  missing
\end{minted}



如此示例所示，此类数组的元素类型为 \texttt{Union\{Missing, T\}}，其中 \texttt{T} 为非缺失值的类型。这简单地反映了以下事实：数组条目可以具有类型 \texttt{T}（在这是 \texttt{Int64}）或类型 \texttt{Missing}。此类数组使用高效的内存存储，其等价于一个 \texttt{Array\{T\}} 组合一个 \texttt{Array\{UInt8\}}，前者保存实际值，后者表示条目类型（即它是 \texttt{Missing} 还是 \texttt{T}）。



允许缺失值的数组可以使用标准语法构造。使用 \texttt{Array\{Union\{Missing, T\}\}(missing, dims)} 来创建填充缺失值的数组：




\begin{minted}{jlcon}
julia> Array{Union{Missing, String}}(missing, 2, 3)
2×3 Array{Union{Missing, String},2}:
 missing  missing  missing
 missing  missing  missing
\end{minted}



允许但不包含 \texttt{missing} 值的数组可使用 \hyperlink{1846942650946171605}{\texttt{convert}} 转换回不允许缺失值的数组。如果该数组包含 \texttt{missing} 值，在类型转换时会抛出 \texttt{MethodError}




\begin{minted}{jlcon}
julia> x = Union{Missing, String}["a", "b"]
2-element Array{Union{Missing, String},1}:
 "a"
 "b"

julia> convert(Array{String}, x)
2-element Array{String,1}:
 "a"
 "b"

julia> y = Union{Missing, String}[missing, "b"]
2-element Array{Union{Missing, String},1}:
 missing
 "b"

julia> convert(Array{String}, y)
ERROR: MethodError: Cannot `convert` an object of type Missing to an object of type String
\end{minted}



\hypertarget{12164012210983849465}{}


\section{跳过缺失值}



由于 \texttt{missing} 会随着标准数学运算符传播，归约函数会在调用的数组包含缺失值时返回 \texttt{missing}




\begin{minted}{jlcon}
julia> sum([1, missing])
missing
\end{minted}



在这种情况下，使用 \hyperlink{2012470681884771400}{\texttt{skipmissing}} 即可跳过缺失值




\begin{minted}{jlcon}
julia> sum(skipmissing([1, missing]))
1
\end{minted}



This convenience function returns an iterator which filters out \texttt{missing} values efficiently. It can therefore be used with any function which supports iterators




\begin{minted}{jlcon}
julia> x = skipmissing([3, missing, 2, 1])
skipmissing(Union{Missing, Int64}[3, missing, 2, 1])

julia> maximum(x)
3

julia> mean(x)
2.0

julia> mapreduce(sqrt, +, x)
4.146264369941973
\end{minted}



Objects created by calling \texttt{skipmissing} on an array can be indexed using indices from the parent array. Indices corresponding to missing values are not valid for these objects and an error is thrown when trying to use them (they are also skipped by \texttt{keys} and \texttt{eachindex})




\begin{minted}{jlcon}
julia> x[1]
3

julia> x[2]
ERROR: MissingException: the value at index (2,) is missing
[...]
\end{minted}



This allows functions which operate on indices to work in combination with \texttt{skipmissing}. This is notably the case for search and find functions, which return indices valid for the object returned by \texttt{skipmissing} which are also the indices of the matching entries \emph{in the parent array}




\begin{minted}{jlcon}
julia> findall(==(1), x)
1-element Array{Int64,1}:
 4

julia> findfirst(!iszero, x)
1

julia> argmax(x)
1
\end{minted}



Use \hyperlink{6278865767444641812}{\texttt{collect}} to extract non-\texttt{missing} values and store them in an array




\begin{minted}{jlcon}
julia> collect(x)
3-element Array{Int64,1}:
 3
 2
 1
\end{minted}



\hypertarget{15378768208982642165}{}


\section{数组上的逻辑运算}



上面描述的逻辑运算符的三值逻辑也适用于针对数组的函数。因此，使用 \hyperlink{15143149452920304570}{\texttt{==}} 运算符的数组相等性测试中，若在未知 \texttt{missing} 条目实际值时无法确定结果，就返回 \texttt{missing}。在实际应用中意味着，在待比较数组中所有非缺失值都相等，且某个或全部数组包含缺失值（也许在不同位置）时会返回 \texttt{missing}。




\begin{minted}{jlcon}
julia> [1, missing] == [2, missing]
false

julia> [1, missing] == [1, missing]
missing

julia> [1, 2, missing] == [1, missing, 2]
missing
\end{minted}



对于单个值，\hyperlink{269533589463185031}{\texttt{isequal}} 会将 \texttt{missing} 值视为与其它 \texttt{missing} 值相等但与非缺失值不同。




\begin{minted}{jlcon}
julia> isequal([1, missing], [1, missing])
true

julia> isequal([1, 2, missing], [1, missing, 2])
false
\end{minted}



函数 \hyperlink{14612039032155203548}{\texttt{any}} 和 \hyperlink{7942004983516218646}{\texttt{all}} 遵循三值逻辑的规则，会在结果无法被确定时返回 \texttt{missing}。




\begin{minted}{jlcon}
julia> all([true, missing])
missing

julia> all([false, missing])
false

julia> any([true, missing])
true

julia> any([false, missing])
missing
\end{minted}



\hypertarget{15469988008975030780}{}


\chapter{网络和流}



Julia 提供了一个功能丰富的接口来处理流式 I/O 对象，如终端、管道和 TCP 套接字。此接口虽然在系统级是异步的，但是其以同步的方式展现给程序员，通常也不需要考虑底层的异步操作。这是通过大量使用 Julia 协作线程（\hyperlink{17473131347184639576}{协程}）功能实现的。



\hypertarget{16725310763095786332}{}


\section{基础流 I/O}



所有 Julia stream 都暴露了 \hyperlink{8104134490906192097}{\texttt{read}} 和 \hyperlink{16947913578760238729}{\texttt{write}} 方法，将 stream 作为它们的第一个参数，如：




\begin{minted}{jlcon}
julia> write(stdout, "Hello World");  # suppress return value 11 with ;
Hello World
julia> read(stdin, Char)

'\n': ASCII/Unicode U+000a (category Cc: Other, control)
\end{minted}



注意，\hyperlink{16947913578760238729}{\texttt{write}} 返回 11，字节数（\texttt{{\textquotedbl}Hello World{\textquotedbl}}）写入 \hyperlink{18181294266083891471}{\texttt{stdout}}，但是返回值使用 \texttt{;} 抑制。



这里按了两次回车，以便 Julia 能够读取到换行符。正如你在这个例子中所看到的，\hyperlink{16947913578760238729}{\texttt{write}} 以待写入的数据作为其第二个参数，而 \hyperlink{8104134490906192097}{\texttt{read}} 以待读取的数据的类型作为其第二个参数。



例如，为了读取一个简单的字节数组，我们可以这样做：




\begin{minted}{jlcon}
julia> x = zeros(UInt8, 4)
4-element Array{UInt8,1}:
 0x00
 0x00
 0x00
 0x00

julia> read!(stdin, x)
abcd
4-element Array{UInt8,1}:
 0x61
 0x62
 0x63
 0x64
\end{minted}



但是，因为这有些繁琐，所以提供了几个方便的方法。例如，我们可以把上面的代码编写为：




\begin{minted}{jlcon}
julia> read(stdin, 4)
abcd
4-element Array{UInt8,1}:
 0x61
 0x62
 0x63
 0x64
\end{minted}



或者如果我们想要读取一整行：




\begin{minted}{jlcon}
julia> readline(stdin)
abcd
"abcd"
\end{minted}



请注意，根据你的终端设置，你的 TTY 可能是行缓冲的，因此在数据发送给 Julia 前可能需要额外的回车。



若要读取 \hyperlink{3330957653919693521}{\texttt{stdin}} 的每一行，可以使用 \hyperlink{3474649815265066504}{\texttt{eachline}}：




\begin{minted}{julia}
for line in eachline(stdin)
    print("Found $line")
end
\end{minted}



或者如果你想要按字符读取的话，使用 \hyperlink{8104134490906192097}{\texttt{read}} ：




\begin{minted}{julia}
while !eof(stdin)
    x = read(stdin, Char)
    println("Found: $x")
end
\end{minted}



\hypertarget{14803809014545196748}{}


\section{文本 I/O}



请注意，上面提到的 \hyperlink{16947913578760238729}{\texttt{write}} 方法对二进制流进行操作。具体来说，值不会转换为任何规范的文本表示形式，而是按原样输出：




\begin{minted}{jlcon}
julia> write(stdout, 0x61);  # suppress return value 1 with ;
a
\end{minted}



请注意，\texttt{a} 被 \hyperlink{16947913578760238729}{\texttt{write}} 函数写入到 \hyperlink{18181294266083891471}{\texttt{stdout}} 并且返回值为 \texttt{1}（因为 \texttt{0x61} 为一个字节）。



对于文本 I/O，请根据需要使用 \hyperlink{8248717042415202230}{\texttt{print}} 或 \hyperlink{14071376285304310153}{\texttt{show}} 方法（有关这两个方法之间的差异的详细讨论，请参阅它们的文档）：




\begin{minted}{jlcon}
julia> print(stdout, 0x61)
97
\end{minted}



有关如何实现自定义类型的显示方法的更多信息，请参阅 \hyperlink{5246022684399876238}{自定义 pretty-printing}。



\hypertarget{11059597754503252223}{}


\section{IO 输出的上下文信息}



有时，IO 输出可受益于将上下文信息传递到 show 方法的能力。\hyperlink{13454403377667762339}{\texttt{IOContext}} 对象提供了将任意元数据与 IO 对象相关联的框架。例如，\texttt{:compact => true} 向 IO 对象添加一个参数来提示调用的 show 方法应该打印一个较短的输出（如果适用）。有关常用属性的列表，请参阅 \hyperlink{13454403377667762339}{\texttt{IOContext}} 文档。



\hypertarget{17626527008259433393}{}


\section{使用文件}



Like many other environments, Julia has an \hyperlink{300818094931158296}{\texttt{open}} function, which takes a filename and returns an \hyperlink{12496894737220238417}{\texttt{IOStream}} object that you can use to read and write things from the file. For example, if we have a file, \texttt{hello.txt}, whose contents are \texttt{Hello, World!}:




\begin{minted}{jlcon}
julia> f = open("hello.txt")
IOStream(<file hello.txt>)

julia> readlines(f)
1-element Array{String,1}:
 "Hello, World!"
\end{minted}



若要写入文件，则可以带着 write（\texttt{{\textquotedbl}w{\textquotedbl}}）标志来打开它：




\begin{minted}{jlcon}
julia> f = open("hello.txt","w")
IOStream(<file hello.txt>)

julia> write(f,"Hello again.")
12
\end{minted}



你如果在此刻检查 \texttt{hello.txt} 的内容，会注意到它是空的；改动实际上还没有写入到磁盘中。这是因为 \texttt{IOStream} 必须在写入实际刷新到磁盘前关闭：




\begin{minted}{jlcon}
julia> close(f)
\end{minted}



再次检查 \texttt{hello.txt} 将显示其内容已被更改。



打开文件，对其内容执行一些操作，并再次关闭它是一种非常常见的模式。为了使这更容易，\hyperlink{300818094931158296}{\texttt{open}} 还有另一种调用方式，它以一个函数作为其第一个参数，以文件名作为其第二个参数，以该文件为参数调用该函数，然后再次关闭它。例如，给定函数：




\begin{minted}{julia}
function read_and_capitalize(f::IOStream)
    return uppercase(read(f, String))
end
\end{minted}



可以调用：




\begin{minted}{jlcon}
julia> open(read_and_capitalize, "hello.txt")
"HELLO AGAIN."
\end{minted}



来打开 \texttt{hello.txt}，对它调用 \texttt{read\_and\_capitalize}，关闭 \texttt{hello.txt} 并返回大写的内容。



为了避免被迫定义一个命名函数，你可以使用 \texttt{do} 语法，它可以动态地创建匿名函数：




\begin{minted}{jlcon}
julia> open("hello.txt") do f
           uppercase(read(f, String))
       end
"HELLO AGAIN."
\end{minted}



\hypertarget{15377875155010529137}{}


\section{一个简单的 TCP 示例}



让我们直接进入一个 TCP 套接字相关的简单示例。此功能位于名为 \texttt{Sockets} 的标准库中。让我们先创建一个简单的服务器：




\begin{minted}{jlcon}
julia> using Sockets

julia> @async begin
           server = listen(2000)
           while true
               sock = accept(server)
               println("Hello World\n")
           end
       end
Task (runnable) @0x00007fd31dc11ae0
\end{minted}



对于那些熟悉 Unix 套接字 API 的人，这些方法名称会让人感觉很熟悉，可是它们的用法比原始的 Unix 套接字 API 要简单些。在本例中，首次调用 \hyperlink{780704944207038170}{\texttt{listen}} 会创建一个服务器，等待传入指定端口（2000）的连接。




\begin{minted}{jlcon}
julia> listen(2000) # 监听（IPv4 下的）localhost:2000
Sockets.TCPServer(active)

julia> listen(ip"127.0.0.1",2000) # 等价于第一个
Sockets.TCPServer(active)

julia> listen(ip"::1",2000) # 监听（IPv6 下的）localhost:2000
Sockets.TCPServer(active)

julia> listen(IPv4(0),2001) # 监听所有 IPv4 接口的端口 2001
Sockets.TCPServer(active)

julia> listen(IPv6(0),2001) # 监听所有 IPv6 接口的端口 2001
Sockets.TCPServer(active)

julia> listen("testsocket") # 监听 UNIX 域套接字
Sockets.PipeServer(active)

julia> listen("\\\\.\\pipe\\testsocket") # 监听 Windows 命名管道
Sockets.PipeServer(active)
\end{minted}



Note that the return type of the last invocation is different. This is because this server does not listen on TCP, but rather on a named pipe (Windows) or UNIX domain socket. Also note that Windows named pipe format has to be a specific pattern such that the name prefix (\texttt{{\textbackslash}{\textbackslash}.{\textbackslash}pipe{\textbackslash}}) uniquely identifies the \href{https://docs.microsoft.com/windows/desktop/ipc/pipe-names}{file type}. The difference between TCP and named pipes or UNIX domain sockets is subtle and has to do with the \hyperlink{1426793569216032849}{\texttt{accept}} and \hyperlink{9743233285520657275}{\texttt{connect}} methods. The \hyperlink{1426793569216032849}{\texttt{accept}} method retrieves a connection to the client that is connecting on the server we just created, while the \hyperlink{9743233285520657275}{\texttt{connect}} function connects to a server using the specified method. The \hyperlink{9743233285520657275}{\texttt{connect}} function takes the same arguments as \hyperlink{780704944207038170}{\texttt{listen}}, so, assuming the environment (i.e. host, cwd, etc.) is the same you should be able to pass the same arguments to \hyperlink{9743233285520657275}{\texttt{connect}} as you did to listen to establish the connection. So let{\textquotesingle}s try that out (after having created the server above):




\begin{minted}{jlcon}
julia> connect(2000)
TCPSocket(open, 0 bytes waiting)

julia> Hello World
\end{minted}



不出所料，我们看到「Hello World」被打印出来。那么，让我们分析一下幕后发生的事情。在我们调用 \hyperlink{9743233285520657275}{\texttt{connect}} 时，我们连接到刚刚创建的服务器。与此同时，accept 函数返回到新创建的套接字的服务器端连接，并打印「Hello World」来表明连接成功。



Julia 的强大优势在于，即使 I/O 实际上是异步发生的，API 也以同步方式暴露，我们不必担心回调，甚至不必确保服务器能够运行。在我们调用 \hyperlink{9743233285520657275}{\texttt{connect}} 时，当前任务等待建立连接，并在这之后才继续执行。在此暂停中，服务器任务恢复执行（因为现在有一个连接请求是可用的），接受该连接，打印信息并等待下一个客户端。读取和写入以同样的方式运行。为了理解这一点，请考虑以下简单的 echo 服务器：




\begin{minted}{jlcon}
julia> @async begin
           server = listen(2001)
           while true
               sock = accept(server)
               @async while isopen(sock)
                   write(sock, readline(sock, keep=true))
               end
           end
       end
Task (runnable) @0x00007fd31dc12e60

julia> clientside = connect(2001)
TCPSocket(RawFD(28) open, 0 bytes waiting)

julia> @async while isopen(clientside)
           write(stdout, readline(clientside, keep=true))
       end
Task (runnable) @0x00007fd31dc11870

julia> println(clientside,"Hello World from the Echo Server")
Hello World from the Echo Server
\end{minted}



与其他流一样，使用 \hyperlink{5331333469799487255}{\texttt{close}} 即可断开该套接字：




\begin{minted}{jlcon}
julia> close(clientside)
\end{minted}



\hypertarget{8798664283149579111}{}


\section{解析 IP 地址}



与 \hyperlink{780704944207038170}{\texttt{listen}} 方法不一致的 \hyperlink{9743233285520657275}{\texttt{connect}} 方法之一是 \texttt{connect(host::String,port)}，它将尝试连接到由 \texttt{host} 参数给定的主机上的由 \texttt{port} 参数给定的端口。它允许你执行以下操作：




\begin{minted}{jlcon}
julia> connect("google.com", 80)
TCPSocket(RawFD(30) open, 0 bytes waiting)
\end{minted}



此功能的基础是 \hyperlink{10301989504197190983}{\texttt{getaddrinfo}}，它将执行适当的地址解析：




\begin{minted}{jlcon}
julia> getaddrinfo("google.com")
ip"74.125.226.225"
\end{minted}



\hypertarget{6184253979084926}{}


\chapter{并行计算}



Julia supports three main categories of features for concurrent and parallel programming:



\begin{itemize}
\item[1. ] Asynchronous {\textquotedbl}tasks{\textquotedbl}, or coroutines


\item[2. ] Multi-threading


\item[3. ] Distributed computing

\end{itemize}


Julia Tasks allow suspending and resuming computations for I/O, event handling, producer-consumer processes, and similar patterns. Tasks can synchronize through operations like \hyperlink{13761789780433862250}{\texttt{wait}} and \hyperlink{11007884648860062495}{\texttt{fetch}}, and communicate via \hyperlink{12548845729684045604}{\texttt{Channel}}s.



Multi-threading functionality builds on tasks by allowing them to run simultaneously on more than one thread or CPU core, sharing memory.



Finally, distributed computing runs multiple processes with separate memory spaces, potentially on different machines. This functionality is provided by the \texttt{Distributed} standard library as well as external packages like \texttt{MPI.jl} and \texttt{DistributedArrays.jl}.



\hypertarget{12867141128563676518}{}


\chapter{运行外部程序}



Julia 中命令的反引号记法借鉴于 shell、Perl 和 Ruby。然而，在 Julia 中编写




\begin{minted}{jlcon}
julia> `echo hello`
`echo hello`
\end{minted}



在多个方面上与 shell、Perl 和 Ruby 中的行为有所不同：



\begin{itemize}
\item 反引号创建一个 \hyperlink{10541952265148699805}{\texttt{Cmd}} 对象来表示命令，而不是立即运行命令。 你可以使用此对象将命令通过管道连接到其它命令、\hyperlink{18309243184998755104}{\texttt{run}} 它以及对它进行 \hyperlink{8104134490906192097}{\texttt{read}} 或 \hyperlink{16947913578760238729}{\texttt{write}}。


\item 在命令运行时，Julia 不会捕获命令的输出结果，除非你对它专门安排。相反，在默认情况下，命令的输出会被定向到 \hyperlink{18181294266083891471}{\texttt{stdout}}，因为它将使用 \texttt{libc} 的 \texttt{system} 调用。


\item 命令从不会在 shell 中运行。相反地，Julia 会直接解析命令语法，适当地插入变量并像 shell 那样拆分单词，同时遵从 shell 的引用语法。命令会作为 \texttt{julia} 的直接子进程运行，使用 \texttt{fork} 和 \texttt{exec} 调用。

\end{itemize}


这是运行外部程序的简单示例：




\begin{minted}{jlcon}
julia> mycommand = `echo hello`
`echo hello`

julia> typeof(mycommand)
Cmd

julia> run(mycommand);
hello
\end{minted}



\texttt{hello} 是 \texttt{echo} 命令的输出，会被发送到 \hyperlink{18181294266083891471}{\texttt{stdout}} 中去。run 方法本身返回 \texttt{nothing}，如果外部命令未能成功运行，则抛出 \hyperlink{12102596058483452470}{\texttt{ErrorException}}。



如果要读取外部命令的输出，可以使用 \hyperlink{8104134490906192097}{\texttt{read}}：




\begin{minted}{jlcon}
julia> a = read(`echo hello`, String)
"hello\n"

julia> chomp(a) == "hello"
true
\end{minted}



更一般地，你可以使用 \hyperlink{300818094931158296}{\texttt{open}} 来读取或写入外部命令。




\begin{minted}{jlcon}
julia> open(`less`, "w", stdout) do io
           for i = 1:3
               println(io, i)
           end
       end
1
2
3
\end{minted}



命令中的程序名称和各个参数可以访问和迭代，这就好像命令也是一个字符串数组：




\begin{minted}{jlcon}
julia> collect(`echo "foo bar"`)
2-element Array{String,1}:
 "echo"
 "foo bar"

julia> `echo "foo bar"`[2]
"foo bar"
\end{minted}



\hypertarget{6373319844820183024}{}


\section{插值}



假设你想要做的事情更复杂，并使用以变量 \texttt{file} 表示的文件名作为命令的参数。那你可以像在字符串字面量中那样使用 \texttt{\$} 进行插值：




\begin{minted}{jlcon}
julia> file = "/etc/passwd"
"/etc/passwd"

julia> `sort $file`
`sort /etc/passwd`
\end{minted}



通过 shell 运行外部程序的一个常见陷阱是，如果文件名中包含 shell 中的特殊字符，那么可能会导致不希望出现的行为。例如，假设我们想要对其内容进行排序的文件是 \texttt{/Volumes/External HD/data.csv}，而不是 \texttt{/etc/passwd}。让我们来试试：




\begin{minted}{jlcon}
julia> file = "/Volumes/External HD/data.csv"
"/Volumes/External HD/data.csv"

julia> `sort $file`
`sort '/Volumes/External HD/data.csv'`
\end{minted}



文件名是如何被引用的？Julia 知道 \texttt{file} 是作为单个参数插入的，因此它替你引用了此单词。事实上，这不太准确：\texttt{file} 的值始终不会被 shell 解释，因此并不需要实际引用；插入引号只是为了展现给用户。就算你把值作为 shell 单词的一部分插入，这也可以工作：




\begin{minted}{jlcon}
julia> path = "/Volumes/External HD"
"/Volumes/External HD"

julia> name = "data"
"data"

julia> ext = "csv"
"csv"

julia> `sort $path/$name.$ext`
`sort '/Volumes/External HD/data.csv'`
\end{minted}



如你所见，\texttt{path} 变量中的空格被恰当地转义了。但是，如果你\emph{想}插入多个单词怎么办？在此情况下，只需使用数组（或其它可迭代容器）：




\begin{minted}{jlcon}
julia> files = ["/etc/passwd","/Volumes/External HD/data.csv"]
2-element Array{String,1}:
 "/etc/passwd"
 "/Volumes/External HD/data.csv"

julia> `grep foo $files`
`grep foo /etc/passwd '/Volumes/External HD/data.csv'`
\end{minted}



如果将数组作为 shell 单词的一部分插入，Julia 将模拟 shell 的 \texttt{\{a,b,c\}} 参数生成：




\begin{minted}{jlcon}
julia> names = ["foo","bar","baz"]
3-element Array{String,1}:
 "foo"
 "bar"
 "baz"

julia> `grep xylophone $names.txt`
`grep xylophone foo.txt bar.txt baz.txt`
\end{minted}



此外，若在同一单词中插入多个数组，则将模拟 shell 的笛卡尔积生成行为：




\begin{minted}{jlcon}
julia> names = ["foo","bar","baz"]
3-element Array{String,1}:
 "foo"
 "bar"
 "baz"

julia> exts = ["aux","log"]
2-element Array{String,1}:
 "aux"
 "log"

julia> `rm -f $names.$exts`
`rm -f foo.aux foo.log bar.aux bar.log baz.aux baz.log`
\end{minted}



因为可以插入字面量数组，所以你可以使用此生成功能，而无需先创建临时数组对象：




\begin{minted}{jlcon}
julia> `rm -rf $["foo","bar","baz","qux"].$["aux","log","pdf"]`
`rm -rf foo.aux foo.log foo.pdf bar.aux bar.log bar.pdf baz.aux baz.log baz.pdf qux.aux qux.log qux.pdf`
\end{minted}



\hypertarget{12430289445905702597}{}


\section{引用}



不可避免地，我们会想要编写不那么简单的命令，且有必要使用引号。下面是 shell 提示符下单行 Perl 程序的简单示例：




\begin{lstlisting}
sh$ perl -le '$|=1; for (0..3) { print }'
0
1
2
3
\end{lstlisting}



该 Perl 表达式需要使用单引号有两个原因：一是为了避免空格将表达式分解为多个 shell 单词，二是为了在使用像 \texttt{\$|}（是的，这在 Perl 中是变量名）这样的 Perl 变量时避免发生插值。在其它情况下，你可能想要使用双引号来\emph{真的}进行插值：




\begin{lstlisting}
sh$ first="A"
sh$ second="B"
sh$ perl -le '$|=1; print for @ARGV' "1: $first" "2: $second"
1: A
2: B
\end{lstlisting}



总之，Julia 反引号语法是经过精心设计的，因此你可以只是将 shell 命令剪切并粘贴到反引号中，接着它们将会工作：转义、引用和插值行为与 shell 相同。唯一的不同是，插值是集成的并且知道在 Julia 的概念中什么是单个字符串值、什么是多个值的容器。让我们在 Julia 中尝试上面的两个例子：




\begin{minted}{jlcon}
julia> A = `perl -le '$|=1; for (0..3) { print }'`
`perl -le '$|=1; for (0..3) { print }'`

julia> run(A);
0
1
2
3

julia> first = "A"; second = "B";

julia> B = `perl -le 'print for @ARGV' "1: $first" "2: $second"`
`perl -le 'print for @ARGV' '1: A' '2: B'`

julia> run(B);
1: A
2: B
\end{minted}



结果是相同的，且 Julia 的插值行为模仿了 shell 的并对其做了一些改进，因为 Julia 支持头等的可迭代对象，但大多数 shell 通过使用空格分隔字符串来实现这一点，而这又引入了歧义。在尝试将 shell 命令移植到 Julia 中时，请先试着剪切并粘贴它。因为 Julia 会在运行命令前向你显示命令，所以你可以在不造成任何破坏的前提下轻松并安全地检查命令的解释。



\hypertarget{565642647898476823}{}


\section{管道}



Shell 元字符，如 \texttt{|}、\texttt{\&} 和 \texttt{>}，在 Julia 的反引号中需被引用（或转义）：




\begin{minted}{jlcon}
julia> run(`echo hello '|' sort`);
hello | sort

julia> run(`echo hello \| sort`);
hello | sort
\end{minted}



此表达式调用 \texttt{echo} 命令并以三个单词作为其参数：\texttt{hello}、\texttt{|} 和 \texttt{sort}。结果是只打印了一行：\texttt{hello | sort}。那么，如何构造管道呢？为此，请使用 \hyperlink{17710887576380723118}{\texttt{pipeline}}，而不是在反引号内使用 \texttt{{\textquotesingle}|{\textquotesingle}}：




\begin{minted}{jlcon}
julia> run(pipeline(`echo hello`, `sort`));
hello
\end{minted}



这将 \texttt{echo} 命令的输出传输到 \texttt{sort} 命令中。当然，这不是很有趣，因为只有一行要排序，但是我们的当然可以做更多、更有趣的事：




\begin{minted}{jlcon}
julia> run(pipeline(`cut -d: -f3 /etc/passwd`, `sort -n`, `tail -n5`))
210
211
212
213
214
\end{minted}



这将打印在 UNIX 系统上最高的五个用户 ID。\texttt{cut}、\texttt{sort} 和 \texttt{tail} 命令都是当前 \texttt{julia} 进程的直接子进程，这中间没有 shell 进程的干预。Julia 自己负责设置管道和连接文件描述符，而这通常由 shell 完成。因为 Julia 自己做了这些事，所以它能更好的控制并做 shell 做不到的一些事情。



Julia 可以并行地运行多个命令：




\begin{minted}{jlcon}
julia> run(`echo hello` & `echo world`);
world
hello
\end{minted}



这里的输出顺序是不确定的，因为两个 \texttt{echo} 进程几乎同时启动，并且争着先写入 \hyperlink{18181294266083891471}{\texttt{stdout}} 描述符和 \texttt{julia} 父进程。Julia 允许你将这两个进程的输出通过管道传输到另一个程序：




\begin{minted}{jlcon}
julia> run(pipeline(`echo world` & `echo hello`, `sort`));
hello
world
\end{minted}



在 UNIX 管道方面，这里发生的是，一个 UNIX 管道对象由两个 \texttt{echo} 进程创建和写入，管道的另一端由 \texttt{sort} 命令读取。



IO 重定向可以通过向 \texttt{pipeline} 函数传递关键字参数 \texttt{stdin}、\texttt{stdout} 和 \texttt{stderr} 来实现：




\begin{minted}{julia}
pipeline(`do_work`, stdout=pipeline(`sort`, "out.txt"), stderr="errs.txt")
\end{minted}



\hypertarget{10119727931012697003}{}


\subsection{避免管道中的死锁}



在单个进程中读取和写入管道的两端时，避免强制内核缓冲所有数据是很重要的。



例如，在读取命令的所有输出时，请调用 \texttt{read(out, String)}，而非 \texttt{wait(process)}，因为前者会积极地消耗由该进程写入的所有数据，而后者在等待读取者连接时会尝试将数据存储内核的缓冲区中。



另一个常见的解决方案是将读取者和写入者分离到单独的 \hyperlink{7131243650304654155}{\texttt{Task}} 中：




\begin{minted}{julia}
writer = @async write(process, "data")
reader = @async do_compute(read(process, String))
wait(writer)
fetch(reader)
\end{minted}



\hypertarget{14183945833806948978}{}


\subsection{复杂示例}



高级编程语言、头等的命令抽象以及进程间管道的自动设置，三者组合起来非常强大。为了更好地理解可被轻松创建的复杂管道，这里有一些更复杂的例子，以避免对单行 Perl 程序的滥用。




\begin{minted}{jlcon}
julia> prefixer(prefix, sleep) = `perl -nle '$|=1; print "'$prefix' ", $_; sleep '$sleep';'`;

julia> run(pipeline(`perl -le '$|=1; for(0..5){ print; sleep 1 }'`, prefixer("A",2) & prefixer("B",2)));
B 0
A 1
B 2
A 3
B 4
A 5
\end{minted}



这是一个经典的例子，一个生产者为两个并发的消费者提供内容：一个 \texttt{perl} 进程生成从数字 0 到 5 的行，而两个并行进程则使用该输出，一个行首加字母「A」，另一个行首加字母「B」。哪个进程使用第一行是不确定的，但是一旦赢得了竞争，这些行会先后被其中一个进程及另一个进程交替使用。（在 Perl 中设置 \texttt{\$|=1} 会导致每个 print 语句刷新 \hyperlink{18181294266083891471}{\texttt{stdout}} 句柄，这是本例工作所必需的。此外，所有输出将被缓存并一次性打印到管道中，以便只由一个消费者进程读取。）



这是一个更加复杂的多阶段生产者——消费者示例：




\begin{minted}{jlcon}
julia> run(pipeline(`perl -le '$|=1; for(0..5){ print; sleep 1 }'`,
           prefixer("X",3) & prefixer("Y",3) & prefixer("Z",3),
           prefixer("A",2) & prefixer("B",2)));
A X 0
B Y 1
A Z 2
B X 3
A Y 4
B Z 5
\end{minted}



此示例与前一个类似，不同之处在于本例中的消费者有两个阶段，并且阶段间有不同的延迟，因此它们使用不同数量的并行 worker 来维持饱和的吞吐量。



我们强烈建议你尝试所有这些例子，以便了解它们的工作原理。



\hypertarget{6259308371449123088}{}


\chapter{调用 C 和 Fortran 代码}



在数值计算领域，尽管有很多用 C 语言或 Fortran 写的高质量且成熟的库都可以用 Julia 重写，但为了便捷利用现有的 C 或 Fortran 代码，Julia 提供简洁且高效的调用方式。Julia 的哲学是 \texttt{no boilerplate}： Julia 可以直接调用 C/Fortran 的函数，不需要任何{\textquotedbl}胶水{\textquotedbl}代码，代码生成或其它编译过程 – 即使在交互式会话 (REPL/Jupyter notebook) 中使用也一样. 在 Julia 中，上述特性可以仅仅通过调用 \hyperlink{14245046751182637566}{\texttt{ccall}} 实现，它的语法看起来就像是普通的函数调用。



The code to be called must be available as a shared library. Most C and Fortran libraries ship compiled as shared libraries already, but if you are compiling the code yourself using GCC (or Clang), you will need to use the \texttt{-shared} and \texttt{-fPIC} options. The machine instructions generated by Julia{\textquotesingle}s JIT are the same as a native C call would be, so the resulting overhead is the same as calling a library function from C code. \footnotemark[1]



Shared libraries and functions are referenced by a tuple of the form \texttt{(:function, {\textquotedbl}library{\textquotedbl})} or \texttt{({\textquotedbl}function{\textquotedbl}, {\textquotedbl}library{\textquotedbl})} where \texttt{function} is the C-exported function name, and \texttt{library} refers to the shared library name.  Shared libraries available in the (platform-specific) load path will be resolved by name.  The full path to the library may also be specified.



可以单独使用函数名来代替元组（只用 \texttt{:function} 或 \texttt{{\textquotedbl}function{\textquotedbl}}）。在这种情况下，函数名在当前进程中进行解析。这一调用形式可用于调用 C 库函数、Julia 运行时中的函数或链接到 Julia 的应用程序中的函数。



默认情况下，Fortran 编译器会\href{https://en.wikipedia.org/wiki/Name\_mangling\#Fortran}{进行名称修饰}（例如，将函数名转换为小写或大写，通常会添加下划线），要通过 \hyperlink{14245046751182637566}{\texttt{ccall}} 调用 Fortran 函数，传递的标识符必须与 Fortran 编译器名称修饰之后的一致。此外，在调用 Fortran 函数时，\textbf{所有}输入必须以指针形式传递，并已在堆或栈上分配内存。这不仅适用于通常是堆分配的数组及可变对象，而且适用于整数和浮点数等标量值，尽管这些值通常是栈分配的，且在使用 C 或 Julia 调用约定时通常是通过寄存器传递的。



Finally, you can use \hyperlink{14245046751182637566}{\texttt{ccall}} to actually generate a call to the library function. The arguments to \hyperlink{14245046751182637566}{\texttt{ccall}} are:



\begin{itemize}
\item[1. ] A \texttt{(:function, {\textquotedbl}library{\textquotedbl})} pair (most common),

或

a \texttt{:function} name symbol or \texttt{{\textquotedbl}function{\textquotedbl}} name string (for symbols in the current process or libc),

或

一个函数指针（例如，从 \texttt{dlsym} 获得的指针）。


\item[2. ] The function{\textquotesingle}s return type


\item[3. ] A tuple of input types, corresponding to the function signature


\item[4. ] The actual argument values to be passed to the function, if any; each is a separate parameter.

\end{itemize}


\begin{quote}
\textbf{Note}

The \texttt{(:function, {\textquotedbl}library{\textquotedbl})} pair, return type, and input types must be literal constants (i.e., they can{\textquotesingle}t be variables, but see \hyperlink{415091760485310867}{Non-constant Function Specifications} below).

The remaining parameters are evaluated at compile time, when the containing method is defined.

\end{quote}


\begin{quote}
\textbf{Note}

See below for how to \hyperlink{10872711251657367863}{map C types to Julia types}.

\end{quote}


As a complete but simple example, the following calls the \texttt{clock} function from the standard C library on most Unix-derived systems:




\begin{minted}{jlcon}
julia> t = ccall(:clock, Int32, ())
2292761

julia> t
2292761

julia> typeof(ans)
Int32
\end{minted}



\texttt{clock} takes no arguments and returns an \hyperlink{10103694114785108551}{\texttt{Int32}}. One common mistake is forgetting that a 1-tuple of argument types must be written with a trailing comma. For example, to call the \texttt{getenv} function to get a pointer to the value of an environment variable, one makes a call like this:




\begin{minted}{jlcon}
julia> path = ccall(:getenv, Cstring, (Cstring,), "SHELL")
Cstring(@0x00007fff5fbffc45)

julia> unsafe_string(path)
"/bin/bash"
\end{minted}



Note that the argument type tuple must be written as \texttt{(Cstring,)}, not \texttt{(Cstring)}. This is because \texttt{(Cstring)} is just the expression \texttt{Cstring} surrounded by parentheses, rather than a 1-tuple containing \texttt{Cstring}:




\begin{minted}{jlcon}
julia> (Cstring)
Cstring

julia> (Cstring,)
(Cstring,)
\end{minted}



In practice, especially when providing reusable functionality, one generally wraps \hyperlink{14245046751182637566}{\texttt{ccall}} uses in Julia functions that set up arguments and then check for errors in whatever manner the C or Fortran function specifies. And if an error occurs it is thrown as a normal Julia exception. This is especially important since C and Fortran APIs are notoriously inconsistent about how they indicate error conditions. For example, the \texttt{getenv} C library function is wrapped in the following Julia function, which is a simplified version of the actual definition from \href{https://github.com/JuliaLang/julia/blob/master/base/env.jl}{\texttt{env.jl}}:




\begin{minted}{julia}
function getenv(var::AbstractString)
    val = ccall(:getenv, Cstring, (Cstring,), var)
    if val == C_NULL
        error("getenv: undefined variable: ", var)
    end
    return unsafe_string(val)
end
\end{minted}



C 函数 \texttt{getenv} 通过返回 \texttt{NULL} 的方式进行报错，但是其他 C 标准库函数也会通过多种不同的方式来报错，这包括返回 -1，0，1 以及其它特殊值。此封装能够明确地抛出异常信息，即是否调用者在尝试获取一个不存在的环境变量：




\begin{minted}{jlcon}
julia> getenv("SHELL")
"/bin/bash"

julia> getenv("FOOBAR")
getenv: undefined variable: FOOBAR
\end{minted}



Here is a slightly more complex example that discovers the local machine{\textquotesingle}s hostname. In this example, the networking library code is assumed to be in a shared library named {\textquotedbl}libc{\textquotedbl}. In practice, this function is usually part of the C standard library, and so the {\textquotedbl}libc{\textquotedbl} portion should be omitted, but we wish to show here the usage of this syntax.




\begin{minted}{julia}
function gethostname()
    hostname = Vector{UInt8}(undef, 256) # MAXHOSTNAMELEN
    err = ccall((:gethostname, "libc"), Int32,
                (Ptr{UInt8}, Csize_t),
                hostname, sizeof(hostname))
    Base.systemerror("gethostname", err != 0)
    hostname[end] = 0 # ensure null-termination
    return unsafe_string(pointer(hostname))
end
\end{minted}



This example first allocates an array of bytes. It then calls the C library function \texttt{gethostname} to populate the array with the hostname. Finally, it takes a pointer to the hostname buffer, and converts the pointer to a Julia string, assuming that it is a NUL-terminated C string. It is common for C libraries to use this pattern of requiring the caller to allocate memory to be passed to the callee and populated. Allocation of memory from Julia like this is generally accomplished by creating an uninitialized array and passing a pointer to its data to the C function. This is why we don{\textquotesingle}t use the \texttt{Cstring} type here: as the array is uninitialized, it could contain NUL bytes. Converting to a \texttt{Cstring} as part of the \hyperlink{14245046751182637566}{\texttt{ccall}} checks for contained NUL bytes and could therefore throw a conversion error.



\hypertarget{17519979972664810183}{}


\section{创建和C兼容的Julia函数指针}



可以将Julia函数传递给接受函数指针参数的原生C函数。例如，要匹配满足下面的C原型：




\begin{lstlisting}
typedef returntype (*functiontype)(argumenttype, ...)
\end{lstlisting}



The macro \hyperlink{11617107520401351255}{\texttt{@cfunction}} generates the C-compatible function pointer for a call to a Julia function. The arguments to \hyperlink{11617107520401351255}{\texttt{@cfunction}} are:



\begin{itemize}
\item[1. ] A Julia function


\item[2. ] The function{\textquotesingle}s return type


\item[3. ] A tuple of input types, corresponding to the function signature

\end{itemize}


\begin{quote}
\textbf{Note}

As with \texttt{ccall}, the return type and tuple of input types must be literal constants.

\end{quote}


\begin{quote}
\textbf{Note}

Currently, only the platform-default C calling convention is supported. This means that \texttt{@cfunction}-generated pointers cannot be used in calls where WINAPI expects a \texttt{stdcall} function on 32-bit Windows, but can be used on WIN64 (where \texttt{stdcall} is unified with the C calling convention).

\end{quote}


一个典型的例子就是标准C库函数\texttt{qsort}，定义为：




\begin{lstlisting}
void qsort(void *base, size_t nmemb, size_t size,
           int (*compare)(const void*, const void*));
\end{lstlisting}



The \texttt{base} argument is a pointer to an array of length \texttt{nmemb}, with elements of \texttt{size} bytes each. \texttt{compare} is a callback function which takes pointers to two elements \texttt{a} and \texttt{b} and returns an integer less/greater than zero if \texttt{a} should appear before/after \texttt{b} (or zero if any order is permitted).



Now, suppose that we have a 1-d array \texttt{A} of values in Julia that we want to sort using the \texttt{qsort} function (rather than Julia{\textquotesingle}s built-in \texttt{sort} function). Before we consider calling \texttt{qsort} and passing arguments, we need to write a comparison function:




\begin{minted}{jlcon}
julia> function mycompare(a, b)::Cint
           return (a < b) ? -1 : ((a > b) ? +1 : 0)
       end
mycompare (generic function with 1 method)
\end{minted}



\texttt{qsort} expects a comparison function that return a C \texttt{int}, so we annotate the return type to be \texttt{Cint}.



In order to pass this function to C, we obtain its address using the macro \texttt{@cfunction}:




\begin{minted}{jlcon}
julia> mycompare_c = @cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}));
\end{minted}



\hyperlink{11617107520401351255}{\texttt{@cfunction}} 需要三个参数: Julia函数 (\texttt{mycompare}), 返回值类型(\texttt{Cint}), 和一个输入参数类型的值元组, 此处是要排序的\texttt{Cdouble}(\hyperlink{5027751419500983000}{\texttt{Float64}}) 元素的数组.



\texttt{qsort}的最终调用看起来是这样的：




\begin{minted}{jlcon}
julia> A = [1.3, -2.7, 4.4, 3.1]
4-element Array{Float64,1}:
  1.3
 -2.7
  4.4
  3.1

julia> ccall(:qsort, Cvoid, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{Cvoid}),
             A, length(A), sizeof(eltype(A)), mycompare_c)

julia> A
4-element Array{Float64,1}:
 -2.7
  1.3
  3.1
  4.4
\end{minted}



As the example shows, the original Julia array \texttt{A} has now been sorted: \texttt{[-2.7, 1.3, 3.1, 4.4]}. Note that Julia \hyperlink{3709811402862932682}{takes care of converting the array to a \texttt{Ptr\{Cdouble\}}}), computing the size of the element type in bytes, and so on.



For fun, try inserting a \texttt{println({\textquotedbl}mycompare(\$a, \$b){\textquotedbl})} line into \texttt{mycompare}, which will allow you to see the comparisons that \texttt{qsort} is performing (and to verify that it is really calling the Julia function that you passed to it).



\hypertarget{10747596823753409973}{}


\section{Mapping C Types to Julia}



It is critical to exactly match the declared C type with its declaration in Julia. Inconsistencies can cause code that works correctly on one system to fail or produce indeterminate results on a different system.



Note that no C header files are used anywhere in the process of calling C functions: you are responsible for making sure that your Julia types and call signatures accurately reflect those in the C header file.\footnotemark[2]



\hypertarget{15689505875890763631}{}


\subsection{Automatic Type Conversion}



Julia automatically inserts calls to the \hyperlink{16487788729383051927}{\texttt{Base.cconvert}} function to convert each argument to the specified type. For example, the following call:




\begin{minted}{julia}
ccall((:foo, "libfoo"), Cvoid, (Int32, Float64), x, y)
\end{minted}



will behave as if it were written like this:




\begin{minted}{julia}
ccall((:foo, "libfoo"), Cvoid, (Int32, Float64),
      Base.unsafe_convert(Int32, Base.cconvert(Int32, x)),
      Base.unsafe_convert(Float64, Base.cconvert(Float64, y)))
\end{minted}



\hyperlink{16487788729383051927}{\texttt{Base.cconvert}} normally just calls \hyperlink{1846942650946171605}{\texttt{convert}}, but can be defined to return an arbitrary new object more appropriate for passing to C. This should be used to perform all allocations of memory that will be accessed by the C code. For example, this is used to convert an \texttt{Array} of objects (e.g. strings) to an array of pointers.



\hyperlink{6011318385865707029}{\texttt{Base.unsafe\_convert}} handles conversion to \hyperlink{10630331440513004826}{\texttt{Ptr}} types. It is considered unsafe because converting an object to a native pointer can hide the object from the garbage collector, causing it to be freed prematurely.



\hypertarget{11183503169412025304}{}


\subsection{Type Correspondences}



First, let{\textquotesingle}s review some relevant Julia type terminology:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
语法 / 关键字 & 例子 & 描述 \\
\hline
\texttt{mutable struct} & \texttt{BitSet} & \texttt{Leaf Type}：包含 \texttt{type-tag} 的一组相关数据，由 Julia GC 管理，通过 \texttt{object-identity} 来定义。为了保证实例可以被构造，\texttt{Leaf Type} 必须是完整定义的，即不允许使用 \texttt{TypeVars}。 \\
\hline
\texttt{abstract type} & \texttt{Any}, \texttt{AbstractArray\{T, N\}}, \texttt{Complex\{T\}} & \texttt{Super Type}：用于描述一组类型，它不是 \texttt{Leaf-Type}，也无法被实例化。 \\
\hline
\texttt{T\{A\}} & \texttt{Vector\{Int\}} & \texttt{Type Parameter}：某种类型的一种具体化，通常用于分派或存储优化。 \\
\hline
 &  & \texttt{TypeVar}：\texttt{Type parameter} 声明中的 \texttt{T} 是一个 \texttt{TypeVar}，它是类型变量的简称。 \\
\hline
\texttt{primitive type} & \texttt{Int}, \texttt{Float64} & \texttt{Primitive Type}：一种没有成员变量的类型，但是它有大小。It is stored and defined by-value. \\
\hline
\texttt{struct} & \texttt{Pair\{Int, Int\}} & {\textquotedbl}Struct{\textquotedbl} :: A type with all fields defined to be constant. It is defined by-value, and may be stored with a type-tag. \\
\hline
 & \texttt{ComplexF64} (\texttt{isbits}) & {\textquotedbl}Is-Bits{\textquotedbl}   :: A \texttt{primitive type}, or a \texttt{struct} type where all fields are other \texttt{isbits} types. It is defined by-value, and is stored without a type-tag. \\
\hline
\texttt{struct ...; end} & \texttt{nothing} & \texttt{Singleton}：没有成员变量的 \texttt{Leaf Type} 或 \texttt{Struct}。 \\
\hline
\texttt{(...)} or \texttt{tuple(...)} & \texttt{(1, 2, 3)} & {\textquotedbl}Tuple{\textquotedbl} :: an immutable data-structure similar to an anonymous struct type, or a constant array. Represented as either an array or a struct. \\
\hline
\end{tabulary}

\end{table}



\hypertarget{538651652486673311}{}


\subsection{Bits Types}



There are several special types to be aware of, as no other type can be defined to behave the same:



\begin{itemize}
\item \texttt{Float32}

和C语言中的 \texttt{float} 类型完全对应（以及Fortran中的 \texttt{REAL*4} ）


\item \texttt{Float64}

和C语言中的 \texttt{double} 类型完全对应（以及Fortran中的 \texttt{REAL*8} ）


\item \texttt{ComplexF32}

和C语言中的 \texttt{complex float} 类型完全对应（以及Fortran中的 \texttt{COMPLEX*8} ）


\item \texttt{ComplexF64}

和C语言中的 \texttt{complex double} 类型完全对应（以及Fortran中的 \texttt{COMPLEX*16} ）


\item \texttt{Signed}

和C语言中的 \texttt{signed} 类型标识完全对应（以及Fortran中的任意 \texttt{INTEGER} 类型） Julia中任何不是\hyperlink{14154866400772377486}{\texttt{Signed}} 的子类型的类型，都会被认为是unsigned类型。

\end{itemize}


\begin{itemize}
\item \texttt{Ref\{T\}}

和 \texttt{Ptr\{T\}} 行为相同，能通过Julia的GC管理其内存。

\end{itemize}


\begin{itemize}
\item \texttt{Array\{T,N\}}

When an array is passed to C as a \texttt{Ptr\{T\}} argument, it is not reinterpret-cast: Julia requires that the element type of the array matches \texttt{T}, and the address of the first element is passed.

因此，如果一个 \texttt{Array} 中的数据格式不正确，它必须被显式地转换 ，通过类似 \texttt{trunc(Int32, a)} 的函数。

若要将一个数组 \texttt{A} 以不同类型的指针传递，而\emph{不提前转换数据}， （比如，将一个 \texttt{Float64} 数组传给一个处理原生字节的函数时），你 可以将这一参数声明为 \texttt{Ptr\{Cvoid\}} 。

如果一个元素类型为 \texttt{Ptr\{T\}} 的数组作为 \texttt{Ptr\{Ptr\{T\}\}} 类型的参数传递， \hyperlink{16487788729383051927}{\texttt{Base.cconvert}}  将会首先尝试进行 null-terminated copy（即直到下一个元素为null才停止复制），并将每一个元素使用其通过 \hyperlink{16487788729383051927}{\texttt{Base.cconvert}} 转换后的版本替换。 这允许，比如，将一个 \texttt{argv} 的指针数组，其类型为 \texttt{Vector\{String\}} ，传递给一个类型为 \texttt{Ptr\{Ptr\{Cchar\}\}} 的参数。

\end{itemize}


On all systems we currently support, basic C/C++ value types may be translated to Julia types as follows. Every C type also has a corresponding Julia type with the same name, prefixed by C. This can help when writing portable code (and remembering that an \texttt{int} in C is not the same as an \texttt{Int} in Julia).



\textbf{System Independent Types}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
C 类型 & Fortran 类型 & 标准 Julia 别名 & Julia 基本类型 \\
\hline
\texttt{unsigned char} & \texttt{CHARACTER} & \texttt{Cuchar} & \texttt{UInt8} \\
\hline
\texttt{bool} (\_Bool in C99+) &  & \texttt{Cuchar} & \texttt{UInt8} \\
\hline
\texttt{short} & \texttt{INTEGER*2}, \texttt{LOGICAL*2} & \texttt{Cshort} & \texttt{Int16} \\
\hline
\texttt{unsigned short} &  & \texttt{Cushort} & \texttt{UInt16} \\
\hline
\texttt{int}, \texttt{BOOL} (C, typical) & \texttt{INTEGER*4}, \texttt{LOGICAL*4} & \texttt{Cint} & \texttt{Int32} \\
\hline
\texttt{unsigned int} &  & \texttt{Cuint} & \texttt{UInt32} \\
\hline
\texttt{long long} & \texttt{INTEGER*8}, \texttt{LOGICAL*8} & \texttt{Clonglong} & \texttt{Int64} \\
\hline
\texttt{unsigned long long} &  & \texttt{Culonglong} & \texttt{UInt64} \\
\hline
\texttt{intmax\_t} &  & \texttt{Cintmax\_t} & \texttt{Int64} \\
\hline
\texttt{uintmax\_t} &  & \texttt{Cuintmax\_t} & \texttt{UInt64} \\
\hline
\texttt{float} & \texttt{REAL*4i} & \texttt{Cfloat} & \texttt{Float32} \\
\hline
\texttt{double} & \texttt{REAL*8} & \texttt{Cdouble} & \texttt{Float64} \\
\hline
\texttt{complex float} & \texttt{COMPLEX*8} & \texttt{ComplexF32} & \texttt{Complex\{Float32\}} \\
\hline
\texttt{complex double} & \texttt{COMPLEX*16} & \texttt{ComplexF64} & \texttt{Complex\{Float64\}} \\
\hline
\texttt{ptrdiff\_t} &  & \texttt{Cptrdiff\_t} & \texttt{Int} \\
\hline
\texttt{ssize\_t} &  & \texttt{Cssize\_t} & \texttt{Int} \\
\hline
\texttt{size\_t} &  & \texttt{Csize\_t} & \texttt{UInt} \\
\hline
\texttt{void} &  &  & \texttt{Cvoid} \\
\hline
\texttt{void} and \texttt{[[noreturn]]} or \texttt{\_Noreturn} &  &  & \texttt{Union\{\}} \\
\hline
\texttt{void*} &  &  & \texttt{Ptr\{Cvoid\}} \\
\hline
\texttt{T*} (where T represents an appropriately defined type) &  &  & \texttt{Ref\{T\}} \\
\hline
\texttt{char*} (or \texttt{char[]}, e.g. a string) & \texttt{CHARACTER*N} &  & \texttt{Cstring} if NUL-terminated, or \texttt{Ptr\{UInt8\}} if not \\
\hline
\texttt{char**} (or \texttt{*char[]}) &  &  & \texttt{Ptr\{Ptr\{UInt8\}\}} \\
\hline
\texttt{jl\_value\_t*} (any Julia Type) &  &  & \texttt{Any} \\
\hline
\texttt{jl\_value\_t**} (a reference to a Julia Type) &  &  & \texttt{Ref\{Any\}} \\
\hline
\texttt{va\_arg} &  &  & Not supported \\
\hline
\texttt{...} (variadic function specification) &  &  & \texttt{T...} (where \texttt{T} is one of the above types, variadic functions of different argument types are not supported) \\
\hline
\end{tabulary}

\end{table}



The \hyperlink{8632604011862685836}{\texttt{Cstring}} type is essentially a synonym for \texttt{Ptr\{UInt8\}}, except the conversion to \texttt{Cstring} throws an error if the Julia string contains any embedded NUL characters (which would cause the string to be silently truncated if the C routine treats NUL as the terminator).  If you are passing a \texttt{char*} to a C routine that does not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that your Julia string does not contain NUL and want to skip the check, you can use \texttt{Ptr\{UInt8\}} as the argument type. \texttt{Cstring} can also be used as the \hyperlink{14245046751182637566}{\texttt{ccall}} return type, but in that case it obviously does not introduce any extra checks and is only meant to improve readability of the call.



\textbf{System Dependent Types}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
C 类型 & 标准 Julia 别名 & Julia 基本类型 \\
\hline
\texttt{char} & \texttt{Cchar} & \texttt{Int8} (x86, x86\_64), \texttt{UInt8} (powerpc, arm) \\
\hline
\texttt{long} & \texttt{Clong} & \texttt{Int} (UNIX), \texttt{Int32} (Windows) \\
\hline
\texttt{unsigned long} & \texttt{Culong} & \texttt{UInt} (UNIX), \texttt{UInt32} (Windows) \\
\hline
\texttt{wchar\_t} & \texttt{Cwchar\_t} & \texttt{Int32} (UNIX), \texttt{UInt16} (Windows) \\
\hline
\end{tabulary}

\end{table}



\begin{quote}
\textbf{Note}

When calling Fortran, all inputs must be passed by pointers to heap- or stack-allocated values, so all type correspondences above should contain an additional \texttt{Ptr\{..\}} or \texttt{Ref\{..\}} wrapper around their type specification.

\end{quote}


\begin{quote}
\textbf{Warning}

For string arguments (\texttt{char*}) the Julia type should be \texttt{Cstring} (if NUL- terminated data is expected), or either \texttt{Ptr\{Cchar\}} or \texttt{Ptr\{UInt8\}} otherwise (these two pointer types have the same effect), as described above, not \texttt{String}. Similarly, for array arguments (\texttt{T[]} or \texttt{T*}), the Julia type should again be \texttt{Ptr\{T\}}, not \texttt{Vector\{T\}}.

\end{quote}


\begin{quote}
\textbf{Warning}

Julia{\textquotesingle}s \texttt{Char} type is 32 bits, which is not the same as the wide character type (\texttt{wchar\_t} or \texttt{wint\_t}) on all platforms.

\end{quote}


\begin{quote}
\textbf{Warning}

A return type of \texttt{Union\{\}} means the function will not return, i.e., C++11 \texttt{[[noreturn]]} or C11 \texttt{\_Noreturn} (e.g. \texttt{jl\_throw} or \texttt{longjmp}). Do not use this for functions that return no value (\texttt{void}) but do return, use \texttt{Cvoid} instead.

\end{quote}


\begin{quote}
\textbf{Note}

For \texttt{wchar\_t*} arguments, the Julia type should be \hyperlink{510630608879002831}{\texttt{Cwstring}} (if the C routine expects a NUL-terminated string), or \texttt{Ptr\{Cwchar\_t\}} otherwise. Note also that UTF-8 string data in Julia is internally NUL-terminated, so it can be passed to C functions expecting NUL-terminated data without making a copy (but using the \texttt{Cwstring} type will cause an error to be thrown if the string itself contains NUL characters).

\end{quote}


\begin{quote}
\textbf{Note}

C functions that take an argument of type \texttt{char**} can be called by using a \texttt{Ptr\{Ptr\{UInt8\}\}} type within Julia. For example, C functions of the form:


\begin{lstlisting}
int main(int argc, char **argv);
\end{lstlisting}

can be called via the following Julia code:


\begin{minted}{julia}
argv = [ "a.out", "arg1", "arg2" ]
ccall(:main, Int32, (Int32, Ptr{Ptr{UInt8}}), length(argv), argv)
\end{minted}

\end{quote}


\begin{quote}
\textbf{Note}

For Fortran functions taking variable length strings of type \texttt{character(len=*)} the string lengths are provided as \emph{hidden arguments}. Type and position of these arguments in the list are compiler specific, where compiler vendors usually default to using \texttt{Csize\_t} as type and append the hidden arguments at the end of the argument list. While this behaviour is fixed for some compilers (GNU), others \emph{optionally} permit placing hidden arguments directly after the character argument (Intel, PGI). For example, Fortran subroutines of the form


\begin{lstlisting}
subroutine test(str1, str2)
character(len=*) :: str1,str2
\end{lstlisting}

can be called via the following Julia code, where the lengths are appended


\begin{minted}{julia}
str1 = "foo"
str2 = "bar"
ccall(:test, Cvoid, (Ptr{UInt8}, Ptr{UInt8}, Csize_t, Csize_t),
                    str1, str2, sizeof(str1), sizeof(str2))
\end{minted}

\end{quote}


\begin{quote}
\textbf{Warning}

Fortran compilers \emph{may} also add other hidden arguments for pointers, assumed-shape (\texttt{:}) and assumed-size (\texttt{*}) arrays. Such behaviour can be avoided by using \texttt{ISO\_C\_BINDING} and including \texttt{bind(c)} in the definition of the subroutine, which is strongly recommended for interoperable code. In this case there will be no hidden arguments, at the cost of some language features (e.g. only \texttt{character(len=1)} will be permitted to pass strings).

\end{quote}


\begin{quote}
\textbf{Note}

A C function declared to return \texttt{Cvoid} will return the value \texttt{nothing} in Julia.

\end{quote}


\hypertarget{8277927636807308593}{}


\subsection{Struct Type Correspondences}



Composite types such as \texttt{struct} in C or \texttt{TYPE} in Fortran90 (or \texttt{STRUCTURE} / \texttt{RECORD} in some variants of F77), can be mirrored in Julia by creating a \texttt{struct} definition with the same field layout.



When used recursively, \texttt{isbits} types are stored inline. All other types are stored as a pointer to the data. When mirroring a struct used by-value inside another struct in C, it is imperative that you do not attempt to manually copy the fields over, as this will not preserve the correct field alignment. Instead, declare an \texttt{isbits} struct type and use that instead. Unnamed structs are not possible in the translation to Julia.



Packed structs and union declarations are not supported by Julia.



You can get an approximation of a \texttt{union} if you know, a priori, the field that will have the greatest size (potentially including padding). When translating your fields to Julia, declare the Julia field to be only of that type.



Arrays of parameters can be expressed with \texttt{NTuple}.  For example, the struct in C notation written as




\begin{lstlisting}
struct B {
    int A[3];
};

b_a_2 = B.A[2];
\end{lstlisting}



can be written in Julia as




\begin{minted}{julia}
struct B
    A::NTuple{3, Cint}
end

b_a_2 = B.A[3]  # note the difference in indexing (1-based in Julia, 0-based in C)
\end{minted}



Arrays of unknown size (C99-compliant variable length structs specified by \texttt{[]} or \texttt{[0]}) are not directly supported. Often the best way to deal with these is to deal with the byte offsets directly. For example, if a C library declared a proper string type and returned a pointer to it:




\begin{lstlisting}
struct String {
    int strlen;
    char data[];
};
\end{lstlisting}



In Julia, we can access the parts independently to make a copy of that string:




\begin{minted}{julia}
str = from_c::Ptr{Cvoid}
len = unsafe_load(Ptr{Cint}(str))
unsafe_string(str + Core.sizeof(Cint), len)
\end{minted}



\hypertarget{7624173302473303801}{}


\subsection{Type Parameters}



The type arguments to \texttt{ccall} and \texttt{@cfunction} are evaluated statically, when the method containing the usage is defined. They therefore must take the form of a literal tuple, not a variable, and cannot reference local variables.



This may sound like a strange restriction, but remember that since C is not a dynamic language like Julia, its functions can only accept argument types with a statically-known, fixed signature.



However, while the type layout must be known statically to compute the intended C ABI, the static parameters of the function are considered to be part of this static environment. The static parameters of the function may be used as type parameters in the call signature, as long as they don{\textquotesingle}t affect the layout of the type. For example, \texttt{f(x::T) where \{T\} = ccall(:valid, Ptr\{T\}, (Ptr\{T\},), x)} is valid, since \texttt{Ptr} is always a word-size primitive type. But, \texttt{g(x::T) where \{T\} = ccall(:notvalid, T, (T,), x)} is not valid, since the type layout of \texttt{T} is not known statically.



\hypertarget{12802490213714574525}{}


\subsection{SIMD 值}



Note: This feature is currently implemented on 64-bit x86 and AArch64 platforms only.



If a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding Julia type is a homogeneous tuple of \texttt{VecElement} that naturally maps to the SIMD type.  Specifically:



\begin{quote}
\begin{itemize}
\item The tuple must be the same size as the SIMD type. For example, a tuple representing an \texttt{\_\_m128} on x86 must have a size of 16 bytes.


\item The element type of the tuple must be an instance of \texttt{VecElement\{T\}} where \texttt{T} is a primitive type that is 1, 2, 4 or 8 bytes.

\end{itemize}
\end{quote}


For instance, consider this C routine that uses AVX intrinsics:




\begin{lstlisting}
#include <immintrin.h>

__m256 dist( __m256 a, __m256 b ) {
    return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),
                                        _mm256_mul_ps(b, b)));
}
\end{lstlisting}



The following Julia code calls \texttt{dist} using \texttt{ccall}:




\begin{minted}{julia}
const m256 = NTuple{8, VecElement{Float32}}

a = m256(ntuple(i -> VecElement(sin(Float32(i))), 8))
b = m256(ntuple(i -> VecElement(cos(Float32(i))), 8))

function call_dist(a::m256, b::m256)
    ccall((:dist, "libdist"), m256, (m256, m256), a, b)
end

println(call_dist(a,b))
\end{minted}



The host machine must have the requisite SIMD registers.  For example, the code above will not work on hosts without AVX support.



\hypertarget{10794774929021837783}{}


\subsection{内存所有权}



\textbf{malloc/free}



Memory allocation and deallocation of such objects must be handled by calls to the appropriate cleanup routines in the libraries being used, just like in any C program. Do not try to free an object received from a C library with \hyperlink{1633533624062187737}{\texttt{Libc.free}} in Julia, as this may result in the \texttt{free} function being called via the wrong library and cause the process to abort. The reverse (passing an object allocated in Julia to be freed by an external library) is equally invalid.



\hypertarget{13734604265364549635}{}


\subsection{何时使用 T、Ptr\{T\} 以及 Ref\{T\}}



In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared to be of type \texttt{T} inside the \hyperlink{14245046751182637566}{\texttt{ccall}}, as they are passed by value.  For C code accepting pointers, \hyperlink{7936024700322877457}{\texttt{Ref\{T\}}} should generally be used for the types of input arguments, allowing the use of pointers to memory managed by either Julia or C through the implicit call to \hyperlink{16487788729383051927}{\texttt{Base.cconvert}}. In contrast, pointers returned by the C function called should be declared to be of output type \hyperlink{10630331440513004826}{\texttt{Ptr\{T\}}}, reflecting that the memory pointed to is managed by C only. Pointers contained in C structs should be represented as fields of type \texttt{Ptr\{T\}} within the corresponding Julia struct types designed to mimic the internal structure of corresponding C structs.



In Julia code wrapping calls to external Fortran routines, all input arguments should be declared as of type \texttt{Ref\{T\}}, as Fortran passes all variables by pointers to memory locations. The return type should either be \texttt{Cvoid} for Fortran subroutines, or a \texttt{T} for Fortran functions returning the type \texttt{T}.



\hypertarget{6114319820079574946}{}


\section{Mapping C Functions to Julia}



\hypertarget{14464013813592582244}{}


\subsection{\texttt{ccall} / \texttt{@cfunction} argument translation guide}



For translating a C argument list to Julia:



\begin{itemize}
\item \texttt{T}, where \texttt{T} is one of the primitive types: \texttt{char}, \texttt{int}, \texttt{long}, \texttt{short}, \texttt{float}, \texttt{double}, \texttt{complex}, \texttt{enum} or any of their \texttt{typedef} equivalents

\begin{itemize}
\item \texttt{T}, where \texttt{T} is an equivalent Julia Bits Type (per the table above)


\item if \texttt{T} is an \texttt{enum}, the argument type should be equivalent to \texttt{Cint} or \texttt{Cuint}


\item argument value will be copied (passed by value)

\end{itemize}

\item \texttt{struct T} (including typedef to a struct)

\begin{itemize}
\item \texttt{T}, where \texttt{T} is a Julia leaf type


\item argument value will be copied (passed by value)

\end{itemize}

\item \texttt{void*}

\begin{itemize}
\item depends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list


\item this argument may be declared as \texttt{Ptr\{Cvoid\}}, if it really is just an unknown pointer

\end{itemize}

\item \texttt{jl\_value\_t*}

\begin{itemize}
\item \texttt{Any}


\item argument value must be a valid Julia object

\end{itemize}

\item \texttt{jl\_value\_t**}

\begin{itemize}
\item \texttt{Ref\{Any\}}


\item argument value must be a valid Julia object (or \texttt{C\_NULL})

\end{itemize}

\item \texttt{T*}

\begin{itemize}
\item \texttt{Ref\{T\}}, where \texttt{T} is the Julia type corresponding to \texttt{T}


\item argument value will be copied if it is an \texttt{isbits} type otherwise, the value must be a valid Julia object

\end{itemize}

\item \texttt{T (*)(...)} (e.g. a pointer to a function)

\begin{itemize}
\item \texttt{Ptr\{Cvoid\}} (you may need to use \hyperlink{11617107520401351255}{\texttt{@cfunction}} explicitly to create this pointer)

\end{itemize}

\item \texttt{...} (e.g. a vararg)

\begin{itemize}
\item \texttt{T...}, where \texttt{T} is the Julia type


\item currently unsupported by \texttt{@cfunction}

\end{itemize}

\item \texttt{va\_arg}

\begin{itemize}
\item not supported by \texttt{ccall} or \texttt{@cfunction}

\end{itemize}
\end{itemize}


\hypertarget{13507762415394207754}{}


\subsection{\texttt{ccall} / \texttt{@cfunction} return type translation guide}



For translating a C return type to Julia:



\begin{itemize}
\item \texttt{void}

\begin{itemize}
\item \texttt{Cvoid} (this will return the singleton instance \texttt{nothing::Cvoid})

\end{itemize}

\item \texttt{T}, where \texttt{T} is one of the primitive types: \texttt{char}, \texttt{int}, \texttt{long}, \texttt{short}, \texttt{float}, \texttt{double}, \texttt{complex}, \texttt{enum} or any of their \texttt{typedef} equivalents

\begin{itemize}
\item \texttt{T}, where \texttt{T} is an equivalent Julia Bits Type (per the table above)


\item if \texttt{T} is an \texttt{enum}, the argument type should be equivalent to \texttt{Cint} or \texttt{Cuint}


\item argument value will be copied (returned by-value)

\end{itemize}

\item \texttt{struct T} (including typedef to a struct)

\begin{itemize}
\item \texttt{T}, where \texttt{T} is a Julia Leaf Type


\item argument value will be copied (returned by-value)

\end{itemize}

\item \texttt{void*}

\begin{itemize}
\item depends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list


\item this argument may be declared as \texttt{Ptr\{Cvoid\}}, if it really is just an unknown pointer

\end{itemize}

\item \texttt{jl\_value\_t*}

\begin{itemize}
\item \texttt{Any}


\item argument value must be a valid Julia object

\end{itemize}

\item \texttt{jl\_value\_t**}

\begin{itemize}
\item \texttt{Ptr\{Any\}} (\texttt{Ref\{Any\}} is invalid as a return type)


\item argument value must be a valid Julia object (or \texttt{C\_NULL})

\end{itemize}

\item \texttt{T*}

\begin{itemize}
\item If the memory is already owned by Julia, or is an \texttt{isbits} type, and is known to be non-null:

\begin{itemize}
\item \texttt{Ref\{T\}}, where \texttt{T} is the Julia type corresponding to \texttt{T}


\item a return type of \texttt{Ref\{Any\}} is invalid, it should either be \texttt{Any} (corresponding to \texttt{jl\_value\_t*}) or \texttt{Ptr\{Any\}} (corresponding to \texttt{jl\_value\_t**})


\item C \textbf{MUST NOT} modify the memory returned via \texttt{Ref\{T\}} if \texttt{T} is an \texttt{isbits} type

\end{itemize}

\item If the memory is owned by C:

\begin{itemize}
\item \texttt{Ptr\{T\}}, where \texttt{T} is the Julia type corresponding to \texttt{T}

\end{itemize}
\end{itemize}

\item \texttt{T (*)(...)} (e.g. a pointer to a function)

\begin{itemize}
\item \texttt{Ptr\{Cvoid\}} (you may need to use \hyperlink{11617107520401351255}{\texttt{@cfunction}} explicitly to create this pointer)

\end{itemize}
\end{itemize}


\hypertarget{12317000517353378133}{}


\subsection{Passing Pointers for Modifying Inputs}



Because C doesn{\textquotesingle}t support multiple return values, often C functions will take pointers to data that the function will modify. To accomplish this within a \hyperlink{14245046751182637566}{\texttt{ccall}}, you need to first encapsulate the value inside a \hyperlink{7936024700322877457}{\texttt{Ref\{T\}}} of the appropriate type. When you pass this \texttt{Ref} object as an argument, Julia will automatically pass a C pointer to the encapsulated data:




\begin{minted}{julia}
width = Ref{Cint}(0)
range = Ref{Cfloat}(0)
ccall(:foo, Cvoid, (Ref{Cint}, Ref{Cfloat}), width, range)
\end{minted}



Upon return, the contents of \texttt{width} and \texttt{range} can be retrieved (if they were changed by \texttt{foo}) by \texttt{width[]} and \texttt{range[]}; that is, they act like zero-dimensional arrays.



\hypertarget{16047542394965419966}{}


\section{C Wrapper Examples}



Let{\textquotesingle}s start with a simple example of a C wrapper that returns a \texttt{Ptr} type:




\begin{minted}{julia}
mutable struct gsl_permutation
end

# The corresponding C signature is
#     gsl_permutation * gsl_permutation_alloc (size_t n);
function permutation_alloc(n::Integer)
    output_ptr = ccall(
        (:gsl_permutation_alloc, :libgsl), # name of C function and library
        Ptr{gsl_permutation},              # output type
        (Csize_t,),                        # tuple of input types
        n                                  # name of Julia variable to pass in
    )
    if output_ptr == C_NULL # Could not allocate memory
        throw(OutOfMemoryError())
    end
    return output_ptr
end
\end{minted}



The \href{https://www.gnu.org/software/gsl/}{GNU Scientific Library} (here assumed to be accessible through \texttt{:libgsl}) defines an opaque pointer, \texttt{gsl\_permutation *}, as the return type of the C function \texttt{gsl\_permutation\_alloc}. As user code never has to look inside the \texttt{gsl\_permutation} struct, the corresponding Julia wrapper simply needs a new type declaration, \texttt{gsl\_permutation}, that has no internal fields and whose sole purpose is to be placed in the type parameter of a \texttt{Ptr} type.  The return type of the \hyperlink{14245046751182637566}{\texttt{ccall}} is declared as \texttt{Ptr\{gsl\_permutation\}}, since the memory allocated and pointed to by \texttt{output\_ptr} is controlled by C.



The input \texttt{n} is passed by value, and so the function{\textquotesingle}s input signature is simply declared as \texttt{(Csize\_t,)} without any \texttt{Ref} or \texttt{Ptr} necessary. (If the wrapper was calling a Fortran function instead, the corresponding function input signature would instead be \texttt{(Ref\{Csize\_t\},)}, since Fortran variables are passed by pointers.) Furthermore, \texttt{n} can be any type that is convertible to a \texttt{Csize\_t} integer; the \hyperlink{14245046751182637566}{\texttt{ccall}} implicitly calls \hyperlink{16487788729383051927}{\texttt{Base.cconvert(Csize\_t, n)}}.



Here is a second example wrapping the corresponding destructor:




\begin{minted}{julia}
# The corresponding C signature is
#     void gsl_permutation_free (gsl_permutation * p);
function permutation_free(p::Ref{gsl_permutation})
    ccall(
        (:gsl_permutation_free, :libgsl), # name of C function and library
        Cvoid,                             # output type
        (Ref{gsl_permutation},),          # tuple of input types
        p                                 # name of Julia variable to pass in
    )
end
\end{minted}



Here, the input \texttt{p} is declared to be of type \texttt{Ref\{gsl\_permutation\}}, meaning that the memory that \texttt{p} points to may be managed by Julia or by C. A pointer to memory allocated by C should be of type \texttt{Ptr\{gsl\_permutation\}}, but it is convertible using \hyperlink{16487788729383051927}{\texttt{Base.cconvert}} and therefore



Now if you look closely enough at this example, you may notice that it is incorrect, given our explanation above of preferred declaration types. Do you see it? The function we are calling is going to free the memory. This type of operation cannot be given a Julia object (it will crash or cause memory corruption). Therefore, it may be preferable to declare the \texttt{p} type as \texttt{Ptr\{gsl\_permutation \}}, to make it harder for the user to mistakenly pass another sort of object there than one obtained via \texttt{gsl\_permutation\_alloc}.



If the C wrapper never expects the user to pass pointers to memory managed by Julia, then using \texttt{p::Ptr\{gsl\_permutation\}} for the method signature of the wrapper and similarly in the \hyperlink{14245046751182637566}{\texttt{ccall}} is also acceptable.



Here is a third example passing Julia arrays:




\begin{minted}{julia}
# The corresponding C signature is
#    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,
#                                double result_array[])
function sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)
    if nmax < nmin
        throw(DomainError())
    end
    result_array = Vector{Cdouble}(undef, nmax - nmin + 1)
    errorcode = ccall(
        (:gsl_sf_bessel_Jn_array, :libgsl), # name of C function and library
        Cint,                               # output type
        (Cint, Cint, Cdouble, Ref{Cdouble}),# tuple of input types
        nmin, nmax, x, result_array         # names of Julia variables to pass in
    )
    if errorcode != 0
        error("GSL error code $errorcode")
    end
    return result_array
end
\end{minted}



The C function wrapped returns an integer error code; the results of the actual evaluation of the Bessel J function populate the Julia array \texttt{result\_array}. This variable is declared as a \texttt{Ref\{Cdouble\}}, since its memory is allocated and managed by Julia. The implicit call to \hyperlink{16487788729383051927}{\texttt{Base.cconvert(Ref\{Cdouble\}, result\_array)}} unpacks the Julia pointer to a Julia array data structure into a form understandable by C.



\hypertarget{17069829158327603815}{}


\section{Fortran Wrapper Example}



The following example utilizes ccall to call a function in a common Fortran library (libBLAS) to computes a dot product. Notice that the argument mapping is a bit different here than above, as we need to map from Julia to Fortran.  On every argument type, we specify \texttt{Ref} or \texttt{Ptr}. This mangling convention may be specific to your fortran compiler and operating system, and is likely undocumented. However, wrapping each in a \texttt{Ref} (or \texttt{Ptr}, where equivalent) is a frequent requirement of Fortran compiler implementations:




\begin{minted}{julia}
function compute_dot(DX::Vector{Float64}, DY::Vector{Float64})
    @assert length(DX) == length(DY)
    n = length(DX)
    incx = incy = 1
    product = ccall((:ddot_, "libLAPACK"),
                    Float64,
                    (Ref{Int32}, Ptr{Float64}, Ref{Int32}, Ptr{Float64}, Ref{Int32}),
                    n, DX, incx, DY, incy)
    return product
end
\end{minted}



\hypertarget{6047327473342163880}{}


\section{垃圾回收安全}



When passing data to a \hyperlink{14245046751182637566}{\texttt{ccall}}, it is best to avoid using the \hyperlink{8901246211940014300}{\texttt{pointer}} function. Instead define a convert method and pass the variables directly to the \hyperlink{14245046751182637566}{\texttt{ccall}}. \hyperlink{14245046751182637566}{\texttt{ccall}} automatically arranges that all of its arguments will be preserved from garbage collection until the call returns. If a C API will store a reference to memory allocated by Julia, after the \hyperlink{14245046751182637566}{\texttt{ccall}} returns, you must ensure that the object remains visible to the garbage collector. The suggested way to do this is to make a global variable of type \texttt{Array\{Ref,1\}} to hold these values, until the C library notifies you that it is finished with them.



Whenever you have created a pointer to Julia data, you must ensure the original data exists until you have finished using the pointer. Many methods in Julia such as \hyperlink{13744149973765810952}{\texttt{unsafe\_load}} and \hyperlink{2825695355940841177}{\texttt{String}} make copies of data instead of taking ownership of the buffer, so that it is safe to free (or alter) the original data without affecting Julia. A notable exception is \hyperlink{14566494858943689253}{\texttt{unsafe\_wrap}} which, for performance reasons, shares (or can be told to take ownership of) the underlying buffer.



The garbage collector does not guarantee any order of finalization. That is, if \texttt{a} contained a reference to \texttt{b} and both \texttt{a} and \texttt{b} are due for garbage collection, there is no guarantee that \texttt{b} would be finalized after \texttt{a}. If proper finalization of \texttt{a} depends on \texttt{b} being valid, it must be handled in other ways.



\hypertarget{14397309909238125480}{}


\section{Non-constant Function Specifications}



A \texttt{(name, library)} function specification must be a constant expression. However, it is possible to use computed values as function names by staging through \hyperlink{7507639810592563424}{\texttt{eval}} as follows:




\begin{lstlisting}
@eval ccall(($(string("a", "b")), "lib"), ...
\end{lstlisting}



This expression constructs a name using \texttt{string}, then substitutes this name into a new \hyperlink{14245046751182637566}{\texttt{ccall}} expression, which is then evaluated. Keep in mind that \texttt{eval} only operates at the top level, so within this expression local variables will not be available (unless their values are substituted with \texttt{\$}). For this reason, \texttt{eval} is typically only used to form top-level definitions, for example when wrapping libraries that contain many similar functions. A similar example can be constructed for \hyperlink{11617107520401351255}{\texttt{@cfunction}}.



However, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep reading. The next section discusses how to use indirect calls to efficiently achieve a similar effect.



\hypertarget{18148794268039727850}{}


\section{非直接调用}



The first argument to \hyperlink{14245046751182637566}{\texttt{ccall}} can also be an expression evaluated at run time. In this case, the expression must evaluate to a \texttt{Ptr}, which will be used as the address of the native function to call. This behavior occurs when the first \hyperlink{14245046751182637566}{\texttt{ccall}} argument contains references to non-constants, such as local variables, function arguments, or non-constant globals.



For example, you might look up the function via \texttt{dlsym}, then cache it in a shared reference for that session. For example:




\begin{minted}{julia}
macro dlsym(func, lib)
    z = Ref{Ptr{Cvoid}}(C_NULL)
    quote
        let zlocal = $z[]
            if zlocal == C_NULL
                zlocal = dlsym($(esc(lib))::Ptr{Cvoid}, $(esc(func)))::Ptr{Cvoid}
                $z[] = $zlocal
            end
            zlocal
        end
    end
end

mylibvar = Libdl.dlopen("mylib")
ccall(@dlsym("myfunc", mylibvar), Cvoid, ())
\end{minted}



\hypertarget{11059323548475736008}{}


\section{Closure cfunctions}



The first argument to \hyperlink{11617107520401351255}{\texttt{@cfunction}} can be marked with a \texttt{\$}, in which case the return value will instead be a \texttt{struct CFunction} which closes over the argument. You must ensure that this return object is kept alive until all uses of it are done. The contents and code at the cfunction pointer will be erased via a \hyperlink{4805357059330171046}{\texttt{finalizer}} when this reference is dropped and atexit. This is not usually needed, since this functionality is not present in C, but can be useful for dealing with ill-designed APIs which don{\textquotesingle}t provide a separate closure environment parameter.




\begin{minted}{julia}
function qsort(a::Vector{T}, cmp) where T
    isbits(T) || throw(ArgumentError("this method can only qsort isbits arrays"))
    callback = @cfunction $cmp Cint (Ref{T}, Ref{T})
    # Here, `callback` isa Base.CFunction, which will be converted to Ptr{Cvoid}
    # (and protected against finalization) by the ccall
    ccall(:qsort, Cvoid, (Ptr{T}, Csize_t, Csize_t, Ptr{Cvoid}),
        a, length(a), Base.elsize(a), callback)
    # We could instead use:
    #    GC.@preserve callback begin
    #        use(Base.unsafe_convert(Ptr{Cvoid}, callback))
    #    end
    # if we needed to use it outside of a `ccall`
    return a
end
\end{minted}



\begin{quote}
\textbf{Note}

Closure \hyperlink{11617107520401351255}{\texttt{@cfunction}} rely on LLVM trampolines, which are not available on all platforms (for example ARM and PowerPC).

\end{quote}


\hypertarget{10600174375111035081}{}


\section{关闭库}



It is sometimes useful to close (unload) a library so that it can be reloaded. For instance, when developing C code for use with Julia, one may need to compile, call the C code from Julia, then close the library, make an edit, recompile, and load in the new changes. One can either restart Julia or use the \texttt{Libdl} functions to manage the library explicitly, such as:




\begin{minted}{julia}
lib = Libdl.dlopen("./my_lib.so") # Open the library explicitly.
sym = Libdl.dlsym(lib, :my_fcn)   # Get a symbol for the function to call.
ccall(sym, ...) # Use the pointer `sym` instead of the (symbol, library) tuple (remaining arguments are the
same).  Libdl.dlclose(lib) # Close the library explicitly.
\end{minted}



Note that when using \texttt{ccall} with the tuple input (e.g., \texttt{ccall((:my\_fcn, {\textquotedbl}./my\_lib.so{\textquotedbl}), ...)}), the library is opened implicitly and it may not be explicitly closed.



\hypertarget{14242265699396110950}{}


\section{调用规约}



The second argument to \hyperlink{14245046751182637566}{\texttt{ccall}} can optionally be a calling convention specifier (immediately preceding return type). Without any specifier, the platform-default C calling convention is used. Other supported conventions are: \texttt{stdcall}, \texttt{cdecl}, \texttt{fastcall}, and \texttt{thiscall} (no-op on 64-bit Windows). For example (from \texttt{base/libc.jl}) we see the same \texttt{gethostname}\hyperlink{14245046751182637566}{\texttt{ccall}} as above, but with the correct signature for Windows:




\begin{minted}{julia}
hn = Vector{UInt8}(undef, 256)
err = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))
\end{minted}



请参阅 \href{http://llvm.org/docs/LangRef.html\#calling-conventions}{LLVM Language Reference} 来获得更多信息。



There is one additional special calling convention \hyperlink{12406828992589210838}{\texttt{llvmcall}}, which allows inserting calls to LLVM intrinsics directly. This can be especially useful when targeting unusual platforms such as GPGPUs. For example, for \href{http://llvm.org/docs/NVPTXUsage.html}{CUDA}, we need to be able to read the thread index:




\begin{minted}{julia}
ccall("llvm.nvvm.read.ptx.sreg.tid.x", llvmcall, Int32, ())
\end{minted}



As with any \texttt{ccall}, it is essential to get the argument signature exactly correct. Also, note that there is no compatibility layer that ensures the intrinsic makes sense and works on the current target, unlike the equivalent Julia functions exposed by \texttt{Core.Intrinsics}.



\hypertarget{6755654760318927882}{}


\section{访问全局变量}



Global variables exported by native libraries can be accessed by name using the \hyperlink{2746947069730856184}{\texttt{cglobal}} function. The arguments to \hyperlink{2746947069730856184}{\texttt{cglobal}} are a symbol specification identical to that used by \hyperlink{14245046751182637566}{\texttt{ccall}}, and a type describing the value stored in the variable:




\begin{minted}{jlcon}
julia> cglobal((:errno, :libc), Int32)
Ptr{Int32} @0x00007f418d0816b8
\end{minted}



The result is a pointer giving the address of the value. The value can be manipulated through this pointer using \hyperlink{13744149973765810952}{\texttt{unsafe\_load}} and \hyperlink{4579672834750013041}{\texttt{unsafe\_store!}}.



\begin{quote}
\textbf{Note}

This \texttt{errno} symbol may not be found in a library named {\textquotedbl}libc{\textquotedbl}, as this is an implementation detail of your system compiler. Typically standard library symbols should be accessed just by name, allowing the compiler to fill in the correct one. Also, however, the \texttt{errno} symbol shown in this example is special in most compilers, and so the value seen here is probably not what you expect or want. Compiling the equivalent code in C on any multi-threaded-capable system would typically actually call a different function (via macro preprocessor overloading), and may give a different result than the legacy value printed here.

\end{quote}


\hypertarget{14428977823562595292}{}


\section{Accessing Data through a Pointer}



The following methods are described as {\textquotedbl}unsafe{\textquotedbl} because a bad pointer or type declaration can cause Julia to terminate abruptly.



Given a \texttt{Ptr\{T\}}, the contents of type \texttt{T} can generally be copied from the referenced memory into a Julia object using \texttt{unsafe\_load(ptr, [index])}. The index argument is optional (default is 1), and follows the Julia-convention of 1-based indexing. This function is intentionally similar to the behavior of \hyperlink{13720608614876840481}{\texttt{getindex}} and \hyperlink{1309244355901386657}{\texttt{setindex!}} (e.g. \texttt{[]} access syntax).



The return value will be a new object initialized to contain a copy of the contents of the referenced memory. The referenced memory can safely be freed or released.



If \texttt{T} is \texttt{Any}, then the memory is assumed to contain a reference to a Julia object (a \texttt{jl\_value\_t*}), the result will be a reference to this object, and the object will not be copied. You must be careful in this case to ensure that the object was always visible to the garbage collector (pointers do not count, but the new reference does) to ensure the memory is not prematurely freed. Note that if the object was not originally allocated by Julia, the new object will never be finalized by Julia{\textquotesingle}s garbage collector.  If the \texttt{Ptr} itself is actually a \texttt{jl\_value\_t*}, it can be converted back to a Julia object reference by \hyperlink{10812596548944930674}{\texttt{unsafe\_pointer\_to\_objref(ptr)}}. (Julia values \texttt{v} can be converted to \texttt{jl\_value\_t*} pointers, as \texttt{Ptr\{Cvoid\}}, by calling \hyperlink{9366554937543398846}{\texttt{pointer\_from\_objref(v)}}.)



The reverse operation (writing data to a \texttt{Ptr\{T\}}), can be performed using \hyperlink{4579672834750013041}{\texttt{unsafe\_store!(ptr, value, [index])}}. Currently, this is only supported for primitive types or other pointer-free (\texttt{isbits}) immutable struct types.



Any operation that throws an error is probably currently unimplemented and should be posted as a bug so that it can be resolved.



If the pointer of interest is a plain-data array (primitive type or immutable struct), the function \hyperlink{14566494858943689253}{\texttt{unsafe\_wrap(Array, ptr,dims, own = false)}} may be more useful. The final parameter should be true if Julia should {\textquotedbl}take ownership{\textquotedbl} of the underlying buffer and call \texttt{free(ptr)} when the returned \texttt{Array} object is finalized.  If the \texttt{own} parameter is omitted or false, the caller must ensure the buffer remains in existence until all access is complete.



Arithmetic on the \texttt{Ptr} type in Julia (e.g. using \texttt{+}) does not behave the same as C{\textquotesingle}s pointer arithmetic. Adding an integer to a \texttt{Ptr} in Julia always moves the pointer by some number of \emph{bytes}, not elements. This way, the address values obtained from pointer arithmetic do not depend on the element types of pointers.



\hypertarget{11710684987427742051}{}


\section{线程安全}



Some C libraries execute their callbacks from a different thread, and since Julia isn{\textquotesingle}t thread-safe you{\textquotesingle}ll need to take some extra precautions. In particular, you{\textquotesingle}ll need to set up a two-layered system: the C callback should only \emph{schedule} (via Julia{\textquotesingle}s event loop) the execution of your {\textquotedbl}real{\textquotedbl} callback. To do this, create an \hyperlink{6110056827764884232}{\texttt{AsyncCondition}} object and \hyperlink{13761789780433862250}{\texttt{wait}} on it:




\begin{minted}{julia}
cond = Base.AsyncCondition()
wait(cond)
\end{minted}



传递给 C 的回调应该只通过 \hyperlink{14245046751182637566}{\texttt{ccall}} 将 \texttt{cond.handle} 作为参数传递给 \texttt{:uv\_async\_send} 并调用，注意避免任何内存分配操作或与 Julia 运行时的其他交互。



注意，事件可能会合并，因此对 \texttt{uv\_async\_send} 的多个调用可能会导致对该条件的单个唤醒通知。



\hypertarget{9551685449391366384}{}


\section{关于 Callbacks 的更多内容}



关于如何传递 callback 到 C 库的更多细节，请参考此\href{https://julialang.org/blog/2013/05/callback}{博客}。



\hypertarget{4039606750368114245}{}


\section{C++}



如需要直接易用的C++接口，即直接用Julia写封装代码，请参考 \href{https://github.com/Keno/Cxx.jl}{Cxx}。如需封装C++库的工具，即用C++写封装/胶水代码，请参考\href{https://github.com/JuliaInterop/CxxWrap.jl}{CxxWrap}。



\footnotetext[1]{Non-library function calls in both C and Julia can be inlined and thus may have even less overhead than calls to shared library functions. The point above is that the cost of actually doing foreign function call is about the same as doing a call in either native language.

}


\footnotetext[2]{The \href{https://github.com/ihnorton/Clang.jl}{Clang package} can be used to auto-generate Julia code from a C header file.

}


\hypertarget{4348488381006315694}{}


\chapter{处理操作系统差异}



当编写跨平台的应用或库时，通常需要考虑到操作系统之间的差异。变量 \texttt{Sys.KERNEL} 可以用于这些场合。在 \texttt{Sys} 模块中有一些函数将会使这些事情更加简单：\texttt{isunix}、 \texttt{islinux}、\texttt{isapple}、\texttt{isbsd}、\texttt{isfreebsd} 以及 \texttt{iswindows}。这些函数可以按如下方式使用：




\begin{minted}{julia}
if Sys.iswindows()
    windows_specific_thing(a)
end
\end{minted}



注意，\texttt{islinux}、\texttt{isapple} 和 \texttt{isfreebsd} 是 \texttt{isunix} 完全互斥的子集。另外，有一个宏 \texttt{@static} 可以使用这些函数有条件地隐藏无效代码，如以下示例所示。



简单例子：




\begin{lstlisting}
ccall((@static Sys.iswindows() ? :_fopen : :fopen), ...)
\end{lstlisting}



复杂例子：




\begin{minted}{julia}
@static if Sys.islinux()
    linux_specific_thing(a)
else
    generic_thing(a)
end
\end{minted}



在链式嵌套的条件表达式中（包括 \texttt{if}/\texttt{elseif}/\texttt{end}），\texttt{@static} 必须在每一层都调用（括号是可选的，但是为了可读性，建议添加）。




\begin{minted}{julia}
@static Sys.iswindows() ? :a : (@static Sys.isapple() ? :b : :c)
\end{minted}



\hypertarget{4919662572867023119}{}


\chapter{环境变量}



Julia 可以配置许多环境变量，一种常见的方式是直接配置操作系统环境变量，另一种更便携的方式是在 Julia 中配置。假设你要将环境变量 \texttt{JULIA\_EDITOR} 设置为 \texttt{vim}，可以直接在 REPL 中输入 \texttt{ENV[{\textquotedbl}JULIA\_EDITOR{\textquotedbl}] = {\textquotedbl}vim{\textquotedbl}}（请根据具体情况对此进行修改），也可以将其添加到用户主目录中的配置文件 \texttt{{\textasciitilde}/.julia/config/startup.jl}，这样做会使其永久生效。环境变量的当前值是通过执行 \texttt{ENV[{\textquotedbl}JULIA\_EDITOR{\textquotedbl}]} 来确定的。



The environment variables that Julia uses generally start with \texttt{JULIA}. If \hyperlink{11698106121547091928}{\texttt{InteractiveUtils.versioninfo}} is called with the keyword \texttt{verbose=true}, then the output will list any defined environment variables relevant for Julia, including those which include \texttt{JULIA} in their names.



\begin{quote}
\textbf{Note}

Some variables, such as \texttt{JULIA\_NUM\_THREADS} and \texttt{JULIA\_PROJECT}, need to be set before Julia starts, therefore adding these to \texttt{{\textasciitilde}/.julia/config/startup.jl} is too late in the startup process. In Bash, environment variables can either be set manually by running, e.g., \texttt{export JULIA\_NUM\_THREADS=4} before starting Julia, or by adding the same command to \texttt{{\textasciitilde}/.bashrc} or \texttt{{\textasciitilde}/.bash\_profile} to set the variable each time Bash is started.

\end{quote}


\hypertarget{10129404461588265763}{}


\section{文件位置}



\hypertarget{11878722049876551255}{}


\subsection{\texttt{JULIA\_BINDIR}}



包含 Julia 可执行文件的目录的绝对路径，它会设置全局变量 \hyperlink{11034333937761980027}{\texttt{Sys.BINDIR}}。\texttt{\$JULIA\_BINDIR} 如果没有设置，那么 Julia 会在运行时确定 \texttt{Sys.BINDIR} 的值。



在默认情况下，可执行文件是指：




\begin{lstlisting}
$JULIA_BINDIR/julia
$JULIA_BINDIR/julia-debug
\end{lstlisting}



全局变量 \texttt{Base.DATAROOTDIR} 是一个从 \texttt{Sys.BINDIR} 到 Julia 数据目录的相对路径。




\begin{lstlisting}
$JULIA_BINDIR/$DATAROOTDIR/julia/base
\end{lstlisting}



上述路径是 Julia 最初搜索源文件的路径（通过 \texttt{Base.find\_source\_file()}）。



同样，全局变量 \texttt{Base.SYSCONFDIR} 是一个到配置文件目录的相对路径。在默认情况下，Julia 会在下列文件中搜索 \texttt{startup.jl} 文件（通过 \texttt{Base.load\_julia\_startup()}）




\begin{lstlisting}
$JULIA_BINDIR/$SYSCONFDIR/julia/startup.jl
$JULIA_BINDIR/../etc/julia/startup.jl
\end{lstlisting}



例如，一个 Linux 安装包的 Julia 可执行文件位于 \texttt{/bin/julia}，\texttt{DATAROOTDIR} 为 \texttt{../share}，\texttt{SYSCONFDIR} 为 \texttt{../etc}，\texttt{JULIA\_BINDIR} 会被设置为 \texttt{/bin}，会有一个源文件搜索路径：




\begin{lstlisting}
/share/julia/base
\end{lstlisting}



和一个全局配置文件搜索路径：




\begin{lstlisting}
/etc/julia/startup.jl
\end{lstlisting}



\hypertarget{4954349069727209817}{}


\subsection{\texttt{JULIA\_PROJECT}}



A directory path that indicates which project should be the initial active project. Setting this environment variable has the same effect as specifying the \texttt{--project} start-up option, but \texttt{--project} has higher precedence. If the variable is set to \texttt{@.} then Julia tries to find a project directory that contains \texttt{Project.toml} or \texttt{JuliaProject.toml} file from the current directory and its parents. See also the chapter on \href{@ref}{Code Loading}.



\begin{quote}
\textbf{Note}

\texttt{JULIA\_PROJECT} must be defined before starting julia; defining it in \texttt{startup.jl} is too late in the startup process.

\end{quote}


\hypertarget{1363234541366705734}{}


\subsection{\texttt{JULIA\_LOAD\_PATH}}



The \texttt{JULIA\_LOAD\_PATH} environment variable is used to populate the global Julia \hyperlink{17914149694871263675}{\texttt{LOAD\_PATH}} variable, which determines which packages can be loaded via \texttt{import} and \texttt{using} (see \href{@ref}{Code Loading}).



Unlike the shell \texttt{PATH} variable, empty entries in \texttt{JULIA\_LOAD\_PATH} are expanded to the default value of \texttt{LOAD\_PATH}, \texttt{[{\textquotedbl}@{\textquotedbl}, {\textquotedbl}@v\#.\#{\textquotedbl}, {\textquotedbl}@stdlib{\textquotedbl}]} when populating \texttt{LOAD\_PATH}. This allows easy appending, prepending, etc. of the load path value in shell scripts regardless of whether \texttt{JULIA\_LOAD\_PATH} is already set or not. For example, to prepend the directory \texttt{/foo/bar} to \texttt{LOAD\_PATH} just do




\begin{lstlisting}
export JULIA_LOAD_PATH="/foo/bar:$JULIA_LOAD_PATH"
\end{lstlisting}



If the \texttt{JULIA\_LOAD\_PATH} environment variable is already set, its old value will be prepended with \texttt{/foo/bar}. On the other hand, if \texttt{JULIA\_LOAD\_PATH} is not set, then it will be set to \texttt{/foo/bar:} which will expand to a \texttt{LOAD\_PATH} value of \texttt{[{\textquotedbl}/foo/bar{\textquotedbl}, {\textquotedbl}@{\textquotedbl}, {\textquotedbl}@v\#.\#{\textquotedbl}, {\textquotedbl}@stdlib{\textquotedbl}]}. If \texttt{JULIA\_LOAD\_PATH} is set to the empty string, it expands to an empty \texttt{LOAD\_PATH} array. In other words, the empty string is interpreted as a zero-element array, not a one-element array of the empty string. This behavior was chosen so that it would be possible to set an empty load path via the environment variable. If you want the default load path, either unset the environment variable or if it must have a value, set it to the string \texttt{:}.



\hypertarget{7415777056556214668}{}


\subsection{\texttt{JULIA\_DEPOT\_PATH}}



The \texttt{JULIA\_DEPOT\_PATH} environment variable is used to populate the global Julia \hyperlink{15271486679944781836}{\texttt{DEPOT\_PATH}} variable, which controls where the package manager, as well as Julia{\textquotesingle}s code loading mechanisms, look for package registries, installed packages, named environments, repo clones, cached compiled package images, configuration files, and the default location of the REPL{\textquotesingle}s history file.



Unlike the shell \texttt{PATH} variable but similar to \texttt{JULIA\_LOAD\_PATH}, empty entries in \texttt{JULIA\_DEPOT\_PATH} are expanded to the default value of \texttt{DEPOT\_PATH}. This allows easy appending, prepending, etc. of the depot path value in shell scripts regardless of whether \texttt{JULIA\_DEPOT\_PATH} is already set or not. For example, to prepend the directory \texttt{/foo/bar} to \texttt{DEPOT\_PATH} just do




\begin{lstlisting}
export JULIA_DEPOT_PATH="/foo/bar:$JULIA_DEPOT_PATH"
\end{lstlisting}



If the \texttt{JULIA\_DEPOT\_PATH} environment variable is already set, its old value will be prepended with \texttt{/foo/bar}. On the other hand, if \texttt{JULIA\_DEPOT\_PATH} is not set, then it will be set to \texttt{/foo/bar:} which will have the effect of prepending \texttt{/foo/bar} to the default depot path. If \texttt{JULIA\_DEPOT\_PATH} is set to the empty string, it expands to an empty \texttt{DEPOT\_PATH} array. In other words, the empty string is interpreted as a zero-element array, not a one-element array of the empty string. This behavior was chosen so that it would be possible to set an empty depot path via the environment variable. If you want the default depot path, either unset the environment variable or if it must have a value, set it to the string \texttt{:}.



\hypertarget{7464422147684280847}{}


\subsection{\texttt{JULIA\_HISTORY}}



REPL 历史文件中 \texttt{REPL.find\_hist\_file()} 的绝对路径。如果没有设置 \texttt{\$JULIA\_HISTORY}，那么 \texttt{REPL.find\_hist\_file()} 默认为




\begin{lstlisting}
$(DEPOT_PATH[1])/logs/repl_history.jl
\end{lstlisting}



\hypertarget{3466341700032254278}{}


\section{外部应用}



\hypertarget{12177211249965413749}{}


\subsection{\texttt{JULIA\_SHELL}}



Julia 用来执行外部命令的 shell 的绝对路径（通过 \texttt{Base.repl\_cmd()}）。默认为环境变量 \texttt{\$SHELL}，如果 \texttt{\$SHELL} 未设置，则为 \texttt{/bin/sh}。



\begin{quote}
\textbf{Note}

在 Windows 上，此环境变量将被忽略，并且外部命令会直接被执行。

\end{quote}


\hypertarget{327473439132778011}{}


\subsection{\texttt{JULIA\_EDITOR}}



\texttt{InteractiveUtils.editor()} 的返回值–编辑器，例如，\hyperlink{10268751953828531961}{\texttt{InteractiveUtils.edit}}，会启动偏好编辑器，比如 \texttt{vim}。



\texttt{\$JULIA\_EDITOR} 优先于 \texttt{\$VISUAL}，而后者优先于 \texttt{\$EDITOR}。如果这些环境变量都没有设置，那么在 Windows 和 OS X 上会设置为 \texttt{open}，或者 \texttt{/etc/alternatives/editor}（如果存在的话），否则为 \texttt{emacs}。



\hypertarget{5963067566394654848}{}


\section{并行}



\hypertarget{9501730119086472793}{}


\subsection{\texttt{JULIA\_CPU\_THREADS}}



改写全局变量 \hyperlink{5072616208401232599}{\texttt{Base.Sys.CPU\_THREADS}}，逻辑 CPU 核心数。



\hypertarget{17625390316676574932}{}


\subsection{\texttt{JULIA\_WORKER\_TIMEOUT}}



一个 \hyperlink{5027751419500983000}{\texttt{Float64}} 值，用来确定 \texttt{Distributed.worker\_timeout()} 的值（默认：\texttt{60.0}）。此函数提供 worker 进程在死亡之前等待 master 进程建立连接的秒数。



\hypertarget{7328254851646027731}{}


\subsection{\texttt{JULIA\_NUM\_THREADS}}



一个无符号 64 位整数（\texttt{uint64\_t}），用来设置 Julia 可用线程的最大数。如果 \texttt{\$JULIA\_NUM\_THREADS} 超过可用的物理 CPU 核心数，那么线程数设置为核心数。如果 \texttt{\$JULIA\_NUM\_THREADS} 不是正数或没有设置，或者无法通过系统调用确定 CPU 核心数，那么线程数就会被设置为 \texttt{1}。



\begin{quote}
\textbf{Note}

\texttt{JULIA\_NUM\_THREADS} 必须在启动 julia 前定义；在启动过程中于 \texttt{startup.jl} 中定义它为时已晚。

\end{quote}


\begin{quote}
\textbf{Julia 1.5}

In Julia 1.5 and above the number of threads can also be specified on startup using the \texttt{-t}/\texttt{--threads} command line argument.

\end{quote}


\hypertarget{10532418503410947704}{}


\subsection{\texttt{JULIA\_THREAD\_SLEEP\_THRESHOLD}}



如果被设置为字符串，并且以大小写敏感的子字符串 \texttt{{\textquotedbl}infinite{\textquotedbl}} 开头，那么z自旋线程从不睡眠。否则，\texttt{\$JULIA\_THREAD\_SLEEP\_THRESHOLD} 被解释为一个无符号 64 位整数（\texttt{uint64\_t}），并且提供以纳秒为单位的自旋线程睡眠的时间量。



\hypertarget{12794875033848178110}{}


\subsection{\texttt{JULIA\_EXCLUSIVE}}



如果设置为 \texttt{0} 以外的任何值，那么 Julia 的线程策略与在专用计算机上一致：主线程在 proc 0 上且线程间是关联的。否则，Julia 让操作系统处理线程策略。



\hypertarget{16378430867132816632}{}


\section{REPL 格式化输出}



决定 REPL 应当如何格式化输出的环境变量。通常，这些变量应当被设置为 \href{http://ascii-table.com/ansi-escape-sequences.php}{ANSI 终端转义序列}。Julia 提供了具有相同功能的高级接口；请参阅 \hyperlink{10670790884919535588}{Julia REPL} 章节。



\hypertarget{13891100922495428417}{}


\subsection{\texttt{JULIA\_ERROR\_COLOR}}



\texttt{Base.error\_color()}（默认值：亮红，\texttt{{\textquotedbl}{\textbackslash}033[91m{\textquotedbl}}），errors 在终端中的格式。



\hypertarget{17711733982596187514}{}


\subsection{\texttt{JULIA\_WARN\_COLOR}}



\texttt{Base.warn\_color()}（默认值：黄，\texttt{{\textquotedbl}{\textbackslash}033[93m{\textquotedbl}}），warnings 在终端中的格式。



\hypertarget{10994657891761481518}{}


\subsection{\texttt{JULIA\_INFO\_COLOR}}



\texttt{Base.info\_color()}（默认值：青，\texttt{{\textquotedbl}{\textbackslash}033[36m{\textquotedbl}}），info 在终端中的格式。



\hypertarget{7277467062996316804}{}


\subsection{\texttt{JULIA\_INPUT\_COLOR}}



\texttt{Base.input\_color()}（默认值：标准，\texttt{{\textquotedbl}{\textbackslash}033[0m{\textquotedbl}}），在终端中，输入应有的格式。



\hypertarget{11974933399373427924}{}


\subsection{\texttt{JULIA\_ANSWER\_COLOR}}



\texttt{Base.answer\_color()}（默认值：标准，\texttt{{\textquotedbl}{\textbackslash}033[0m{\textquotedbl}}），在终端中，输出应有的格式。



\hypertarget{1071250415559095053}{}


\subsection{\texttt{JULIA\_STACKFRAME\_LINEINFO\_COLOR}}



\texttt{Base.stackframe\_lineinfo\_color()}（默认值：粗体，\texttt{{\textquotedbl}{\textbackslash}033[1m{\textquotedbl}}），栈跟踪时行信息在终端中的格式。



\hypertarget{15357004504591912181}{}


\subsection{\texttt{JULIA\_STACKFRAME\_FUNCTION\_COLOR}}



\texttt{Base.stackframe\_function\_color()}（默认值：粗体，\texttt{{\textquotedbl}{\textbackslash}033[1m{\textquotedbl}}），栈跟踪期间函数调用在终端中的形式。



\hypertarget{14262570954781492291}{}


\section{调试和性能分析}



\hypertarget{8362221794188602098}{}


\subsection{\texttt{JULIA\_DEBUG}}



Enable debug logging for a file or module, see \href{@ref Logging}{\texttt{Logging}} for more information.



\hypertarget{17935900017233878037}{}


\subsection{\texttt{JULIA\_GC\_ALLOC\_POOL}, \texttt{JULIA\_GC\_ALLOC\_OTHER}, \texttt{JULIA\_GC\_ALLOC\_PRINT}}



这些环境变量取值为字符串，可以以字符 \texttt{‘r’} 开头，后接一个由三个带符号 64 位整数（\texttt{int64\_t}）组成的、以冒号分割的列表的插值字符串。这个整数的三元组 \texttt{a:b:c} 代表算术序列 \texttt{a}, \texttt{a + b}, \texttt{a + 2*b}, ... \texttt{c}。



\begin{itemize}
\item 如果是第 \texttt{n} 次调用 \texttt{jl\_gc\_pool\_alloc()}，并且 \texttt{n}   属于 \texttt{\$JULIA\_GC\_ALLOC\_POOL} 代表的算术序列，   那么垃圾回收是强制的。


\item 如果是第 \texttt{n} 次调用 \texttt{maybe\_collect()}，并且 \texttt{n} 属于   \texttt{\$JULIA\_GC\_ALLOC\_OTHER} 代表的算术序列，那么垃圾   回收是强制的。


\item 如果是第 \texttt{n} 次调用 \texttt{jl\_gc\_alloc()}，并且 \texttt{n} 属于   \texttt{\$JULIA\_GC\_ALLOC\_PRINT} 代表的算术序列，那么   调用 \texttt{jl\_gc\_pool\_alloc()} 和 \texttt{maybe\_collect()} 的次数会   被打印。

\end{itemize}


如果这些环境变量的值以字符 \texttt{‘r{\textquotesingle}} 开头，那么垃圾回收事件间的间隔是随机的。



\begin{quote}
\textbf{Note}

这些环境变量生效要求 Julia 在编译时带有垃圾收集调试支持（也就是，在构建配置中将 \texttt{WITH\_GC\_DEBUG\_ENV} 设置为 \texttt{1}）。

\end{quote}


\hypertarget{15291982466110123243}{}


\subsection{\texttt{JULIA\_GC\_NO\_GENERATIONAL}}



如果设置为 \texttt{0} 以外的任何值，那么 Julia 的垃圾收集器将从不执行「快速扫描」内存。



\begin{quote}
\textbf{Note}

此环境变量生效要求 Julia 在编译时带有垃圾收集调试支持（也就是，在构建配置中将 \texttt{WITH\_GC\_DEBUG\_ENV} 设置为 \texttt{1}）。

\end{quote}


\hypertarget{4439082668862420182}{}


\subsection{\texttt{JULIA\_GC\_WAIT\_FOR\_DEBUGGER}}



如果设置为 \texttt{0} 以外的任何值，Julia 的垃圾收集器每当出现严重错误时将等待调试器连接而不是中止。



\begin{quote}
\textbf{Note}

此环境变量生效要求 Julia 在编译时带有垃圾收集调试支持（也就是，在构建配置中将 \texttt{WITH\_GC\_DEBUG\_ENV} 设置为 \texttt{1}）。

\end{quote}


\hypertarget{1100661411174026998}{}


\subsection{\texttt{ENABLE\_JITPROFILING}}



如果设置为 \texttt{0} 以外的任何值，那么编译器将为即时（JIT）性能分析创建并注册一个事件监听器。



\begin{quote}
\textbf{Note}

此变量生效要求 Julia 编译时带有 JIT 性能分析支持，请使用

\begin{itemize}
\item 英特尔的 \href{https://software.intel.com/en-us/intel-vtune-amplifier-xe}{VTune™ Amplifier}（在构建配置中将 \texttt{USE\_INTEL\_JITEVENTS} 设置为 \texttt{1}），或


\item \href{http://oprofile.sourceforge.net/news/}{OProfile}（在构建配置中将 \texttt{USE\_OPROFILE\_JITEVENTS} 设置为 \texttt{1}）。

\end{itemize}
\end{quote}


\hypertarget{12744946110825549407}{}


\subsection{\texttt{JULIA\_LLVM\_ARGS}}



传递给 LLVM 后端的参数。



\hypertarget{12804520762715277004}{}


\chapter{嵌入 Julia}



正如我们在 \hyperlink{4974579121496702029}{调用 C 和 Fortran 代码} 中看到的, Julia 有着简单高效的方法来调用 C 编写的函数。但有时恰恰相反，我们需要在 C 中调用 Julia 的函数。这可以将 Julia 代码集成到一个更大的 C/C++ 项目而无需在 C/C++ 中重写所有内容。Julia 有一个 C API 来实现这一目标。几乎所有编程语言都能以某种方式来调用 C 语言的函数，因此 Julia 的 C API 也就能够进行更多语言的桥接。(例如在 Python 或是 C\# 中调用 Julia ).



\hypertarget{10185907435024062430}{}


\section{高级别嵌入}



\textbf{Note}: 本节包含可运行在类 Unix 系统上的、使用 C 编写的嵌入式 Julia 代码。Windows 平台请参阅下一节。



我们从一个简单的 C 程序开始初始化 Julia 并调用一些 Julia 代码：




\begin{lstlisting}
#include <julia.h>
JULIA_DEFINE_FAST_TLS() // only define this once, in an executable (not in a shared library) if you want fast code.

int main(int argc, char *argv[])
{
    /* required: setup the Julia context */
    jl_init();

    /* run Julia commands */
    jl_eval_string("print(sqrt(2.0))");

    /* strongly recommended: notify Julia that the
         program is about to terminate. this allows
         Julia time to cleanup pending write requests
         and run all finalizers
    */
    jl_atexit_hook(0);
    return 0;
}
\end{lstlisting}



为构建这个程序，你必须将 Julia 头文件的路径放入 include 路径并链接 \texttt{libjulia} 。例如 Julia 被安装到 \texttt{\$JULIA\_DIR}，则可以用 \texttt{gcc} 来编译上面的测试程序 \texttt{test.c}：




\begin{lstlisting}
gcc -o test -fPIC -I$JULIA_DIR/include/julia -L$JULIA_DIR/lib -Wl,-rpath,$JULIA_DIR/lib test.c -ljulia
\end{lstlisting}



或者查看 Julia 源代码目录 \texttt{test/embedding/} 文件夹下的 \texttt{embedding.c} 文件。 文件 \texttt{ui/repl.c} 则是另一个简单示例，用于设置链接 \texttt{libjulia} 时 \texttt{jl\_options} 的选项 。



在调用任何其他 Julia C 函数之前第一件必须要做的事是初始化 Julia，通过调用 \texttt{jl\_init} 尝试自动确定 Julia 的安装位置来实现。如果需要自定义位置或指定要加载的系统映像，请改用 \texttt{jl\_init\_with\_image}。



测试程序中的第二个语句通过调用 \texttt{jl\_eval\_string} 来执行 Julia 语句。



在程序结束之前，强烈建议调用 \texttt{jl\_atexit\_hook}。上面的示例程序在 \texttt{main} 返回之前进行了调用。



\begin{quote}
\textbf{Note}

现在，动态链接 \texttt{libjulia} 的共享库需要传递选项 \texttt{RTLD\_GLOBAL} 。比如在 Python 中像这样调用：


\begin{lstlisting}
>>> julia=CDLL('./libjulia.dylib',RTLD_GLOBAL)
>>> julia.jl_init.argtypes = []
>>> julia.jl_init()
250593296
\end{lstlisting}

\end{quote}


\begin{quote}
\textbf{Note}

如果 Julia 程序需要访问 主可执行文件 中的符号，那么除了下面描述的由 \texttt{julia-config.jl} 生成的标记之外，可能还需要在 Linux 上的编译时添加 \texttt{-Wl,--export-dynamic} 链接器标志。编译共享库时则不必要。

\end{quote}


\hypertarget{122745226345289239}{}


\subsection{使用 julia-config 自动确定构建参数}



\texttt{julia-config.jl} 创建脚本是为了帮助确定使用嵌入的 Julia 程序所需的构建参数。此脚本使用由其调用的特定 Julia 分发的构建参数和系统配置来导出嵌入程序的必要编译器标志以与该分发交互。此脚本位于 Julia 的 share 目录中。



\hypertarget{18305016561534437319}{}


\subsubsection{例子}




\begin{lstlisting}
#include <julia.h>

int main(int argc, char *argv[])
{
    jl_init();
    (void)jl_eval_string("println(sqrt(2.0))");
    jl_atexit_hook(0);
    return 0;
}
\end{lstlisting}



\hypertarget{15399362667106734470}{}


\subsubsection{在命令行中}



命令行脚本简单用法：假设 \texttt{julia-config.jl} 位于 \texttt{/usr/local/julia/share/julia}，它可以直接在命令行上调用，并采用 3 个标志的任意组合：




\begin{lstlisting}
/usr/local/julia/share/julia/julia-config.jl
Usage: julia-config [--cflags|--ldflags|--ldlibs]
\end{lstlisting}



如果上面的示例源代码保存为文件 \texttt{embed\_example.c}，则以下命令将其编译为 Linux 和 Windows 上运行的程序（MSYS2 环境），或者如果在 OS/X 上，则用 \texttt{clang} 替换 \texttt{gcc}。：




\begin{lstlisting}
/usr/local/julia/share/julia/julia-config.jl --cflags --ldflags --ldlibs | xargs gcc embed_example.c
\end{lstlisting}



\hypertarget{9935040774481087943}{}


\subsubsection{在 Makefiles 中使用}



但通常来说，嵌入的项目会比上面更复杂，因此一般会提供 makefile 支持。由于使用了 \textbf{shell} 宏扩展，我们就假设用 GNU make 。 另外，尽管很多时候 \texttt{julia-config.jl} 会在目录 \texttt{/usr/local} 中出现多次，不过也未必如此，但 Julia 也定位 \texttt{julia-config.jl}，并且可以使用 makefile 来利用它。上面的示例程序使用 Makefile 来扩展。：




\begin{lstlisting}
JL_SHARE = $(shell julia -e 'print(joinpath(Sys.BINDIR, Base.DATAROOTDIR, "julia"))')
CFLAGS += $(shell $(JL_SHARE)/julia-config.jl --cflags)
CXXFLAGS += $(shell $(JL_SHARE)/julia-config.jl --cflags)
LDFLAGS += $(shell $(JL_SHARE)/julia-config.jl --ldflags)
LDLIBS += $(shell $(JL_SHARE)/julia-config.jl --ldlibs)

all: embed_example
\end{lstlisting}



现在构建的命令就只需要简简单单的\texttt{make}了。



\hypertarget{9091699375369199363}{}


\section{在 Windows 使用 Visual Studio 进行高级别嵌入}



If the \texttt{JULIA\_DIR} environment variable hasn{\textquotesingle}t been setup, add it using the System panel before starting Visual Studio. The \texttt{bin} folder under JULIA\_DIR should be on the system PATH.



We start by opening Visual Studio and creating a new Console Application project. To the {\textquotesingle}stdafx.h{\textquotesingle} header file, add the following lines at the end:




\begin{lstlisting}
#include <julia.h>
\end{lstlisting}



Then, replace the main() function in the project with this code:




\begin{lstlisting}
int main(int argc, char *argv[])
{
    /* required: setup the Julia context */
    jl_init();

    /* run Julia commands */
    jl_eval_string("print(sqrt(2.0))");

    /* strongly recommended: notify Julia that the
         program is about to terminate. this allows
         Julia time to cleanup pending write requests
         and run all finalizers
    */
    jl_atexit_hook(0);
    return 0;
}
\end{lstlisting}



The next step is to set up the project to find the Julia include files and the libraries. It{\textquotesingle}s important to know whether the Julia installation is 32- or 64-bits. Remove any platform configuration that doesn{\textquotesingle}t correspond to the Julia installation before proceeding.



Using the project Properties dialog, go to \texttt{C/C++} | \texttt{General} and add \texttt{\$(JULIA\_DIR){\textbackslash}include{\textbackslash}julia{\textbackslash}} to the Additional Include Directories property. Then, go to the \texttt{Linker} | \texttt{General} section and add \texttt{\$(JULIA\_DIR){\textbackslash}lib} to the Additional Library Directories property. Finally, under \texttt{Linker} | \texttt{Input}, add \texttt{libjulia.dll.a;libopenlibm.dll.a;} to the list of libraries.



At this point, the project should build and run.



\hypertarget{4573294506139022977}{}


\section{转换类型}



真正的应用程序不仅仅要执行表达式，还要返回表达式的值给宿主程序。\texttt{jl\_eval\_string} 返回 一个 \texttt{jl\_value\_t*}，它是指向堆分配的 Julia 对象的指针。存储像 \hyperlink{5027751419500983000}{\texttt{Float64}} 这些简单数据类型叫做 \texttt{装箱}，然后提取存储的基础类型数据叫 \texttt{拆箱}。我们改进的示例程序在 Julia 中计算 2 的平方根，并在 C 中读取回结果，如下所示：




\begin{lstlisting}
jl_value_t *ret = jl_eval_string("sqrt(2.0)");

if (jl_typeis(ret, jl_float64_type)) {
    double ret_unboxed = jl_unbox_float64(ret);
    printf("sqrt(2.0) in C: %e \n", ret_unboxed);
}
else {
    printf("ERROR: unexpected return type from sqrt(::Float64)\n");
}
\end{lstlisting}



为了检查 \texttt{ret} 是否为特定的 Julia 类型，我们可以使用 \texttt{jl\_isa}，\texttt{jl\_typeis} 或 \texttt{jl\_is\_...} 函数。通过输入 \texttt{typeof(sqrt(2.0))}到 Julia shell，我们可以看到返回类型是 \hyperlink{5027751419500983000}{\texttt{Float64}}（在C中是 \texttt{double} 类型）。要将装箱的 Julia 值转换为 C 的double，上面的代码片段使用了 \texttt{jl\_unbox\_float64}函数。



相应的, 用 \texttt{jl\_box\_...} 函数是另一种转换的方式。




\begin{lstlisting}
jl_value_t *a = jl_box_float64(3.0);
jl_value_t *b = jl_box_float32(3.0f);
jl_value_t *c = jl_box_int32(3);
\end{lstlisting}



正如我们将在下面看到的那样，装箱需要在调用 Julia 函数时使用特定参数。



\hypertarget{15001488547709567560}{}


\section{调用 Julia 函数}



虽然 \texttt{jl\_eval\_string} 允许 C 获取 Julia 表达式的结果，但它不允许将在 C 中计算的参数传递给 Julia。因此需要使用 \texttt{jl\_call} 来直接调用Julia函数：




\begin{lstlisting}
jl_function_t *func = jl_get_function(jl_base_module, "sqrt");
jl_value_t *argument = jl_box_float64(2.0);
jl_value_t *ret = jl_call1(func, argument);
\end{lstlisting}



在第一步中，通过调用 \texttt{jl\_get\_function} 检索出 Julia 函数 \texttt{sqrt} 的句柄(handle)。 传递给 \texttt{jl\_get\_function} 的第一个参数是 指向 定义\texttt{sqrt}所在的 \texttt{Base} 模块 的指针。 然后，double 值通过 \texttt{jl\_box\_float64} 被装箱。 最后，使用 \texttt{jl\_call1} 调用该函数。也有 \texttt{jl\_call0}，\texttt{jl\_call2}和\texttt{jl\_call3} 函数，方便地处理不同数量的参数。 要传递更多参数，使用 \texttt{jl\_call}：




\begin{lstlisting}
jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs)
\end{lstlisting}



它的第二个参数 \texttt{args} 是 \texttt{jl\_value\_t*} 类型的数组，\texttt{nargs} 是参数的个数 



\hypertarget{3779983102705119396}{}


\section{内存管理}



正如我们所见，Julia 对象在 C 中表示为指针。这就出现了 谁来负责释放这些对象的问题。



通常，Julia 对象由垃圾收集器（GC）释放，但 GC 不会自动就懂我们正C中保留对Julia值的引用。这意味着 GC 会在你的掌控之外释放对象，从而使指针无效。



The GC can only run when Julia objects are allocated. Calls like \texttt{jl\_box\_float64} perform allocation, and allocation might also happen at any point in running Julia code. However, it is generally safe to use pointers in between \texttt{jl\_...} calls. But in order to make sure that values can survive \texttt{jl\_...} calls, we have to tell Julia that we still hold a reference to Julia \href{https://www.cs.purdue.edu/homes/hosking/690M/p611-fenichel.pdf}{root} values, a process called {\textquotedbl}GC rooting{\textquotedbl}. Rooting a value will ensure that the garbage collector does not accidentally identify this value as unused and free the memory backing that value. This can be done using the \texttt{JL\_GC\_PUSH} macros:




\begin{lstlisting}
jl_value_t *ret = jl_eval_string("sqrt(2.0)");
JL_GC_PUSH1(&ret);
// Do something with ret
JL_GC_POP();
\end{lstlisting}



The \texttt{JL\_GC\_POP} call releases the references established by the previous \texttt{JL\_GC\_PUSH}. Note that \texttt{JL\_GC\_PUSH} stores references on the C stack, so it must be exactly paired with a \texttt{JL\_GC\_POP} before the scope is exited. That is, before the function returns, or control flow otherwise leaves the block in which the \texttt{JL\_GC\_PUSH} was invoked.



Several Julia values can be pushed at once using the \texttt{JL\_GC\_PUSH2} , \texttt{JL\_GC\_PUSH3} , \texttt{JL\_GC\_PUSH4} , \texttt{JL\_GC\_PUSH5} , and \texttt{JL\_GC\_PUSH6} macros. To push an array of Julia values one can use the \texttt{JL\_GC\_PUSHARGS} macro, which can be used as follows:




\begin{lstlisting}
jl_value_t **args;
JL_GC_PUSHARGS(args, 2); // args can now hold 2 `jl_value_t*` objects
args[0] = some_value;
args[1] = some_other_value;
// Do something with args (e.g. call jl_... functions)
JL_GC_POP();
\end{lstlisting}



Each scope must have only one call to \texttt{JL\_GC\_PUSH*}. Hence, if all variables cannot be pushed once by a single call to \texttt{JL\_GC\_PUSH*}, or if there are more than 6 variables to be pushed and using an array of arguments is not an option, then one can use inner blocks:




\begin{lstlisting}
jl_value_t *ret1 = jl_eval_string("sqrt(2.0)");
JL_GC_PUSH1(&ret1);
jl_value_t *ret2 = 0;
{
    jl_function_t *func = jl_get_function(jl_base_module, "exp");
    ret2 = jl_call1(func, ret1);
    JL_GC_PUSH1(&ret2);
    // Do something with ret2.
    JL_GC_POP();    // This pops ret2.
}
JL_GC_POP();    // This pops ret1.
\end{lstlisting}



If it is required to hold the pointer to a variable between functions (or block scopes), then it is not possible to use \texttt{JL\_GC\_PUSH*}. In this case, it is necessary to create and keep a reference to the variable in the Julia global scope. One simple way to accomplish this is to use a global \texttt{IdDict} that will hold the references, avoiding deallocation by the GC. However, this method will only work properly with mutable types.




\begin{lstlisting}
// This functions shall be executed only once, during the initialization.
jl_value_t* refs = jl_eval_string("refs = IdDict()");
jl_function_t* setindex = jl_get_function(jl_base_module, "setindex!");

...

// `var` is the variable we want to protect between function calls.
jl_value_t* var = 0;

...

// `var` is a `Vector{Float64}`, which is mutable.
var = jl_eval_string("[sqrt(2.0); sqrt(4.0); sqrt(6.0)]");

// To protect `var`, add its reference to `refs`.
jl_call3(setindex, refs, var, var);
\end{lstlisting}



If the variable is immutable, then it needs to be wrapped in an equivalent mutable container or, preferably, in a \texttt{RefValue\{Any\}} before it is pushed to \texttt{IdDict}. In this approach, the container has to be created or filled in via C code using, for example, the function \texttt{jl\_new\_struct}. If the container is created by \texttt{jl\_call*}, then you will need to reload the pointer to be used in C code.




\begin{lstlisting}
// This functions shall be executed only once, during the initialization.
jl_value_t* refs = jl_eval_string("refs = IdDict()");
jl_function_t* setindex = jl_get_function(jl_base_module, "setindex!");
jl_datatype_t* reft = (jl_datatype_t*)jl_eval_string("Base.RefValue{Any}");

...

// `var` is the variable we want to protect between function calls.
jl_value_t* var = 0;

...

// `var` is a `Float64`, which is immutable.
var = jl_eval_string("sqrt(2.0)");

// Protect `var` until we add its reference to `refs`.
JL_GC_PUSH1(&var);

// Wrap `var` in `RefValue{Any}` and push to `refs` to protect it.
jl_value_t* rvar = jl_new_struct(reft, var);
JL_GC_POP();

jl_call3(setindex, refs, rvar, rvar);
\end{lstlisting}



The GC can be allowed to deallocate a variable by removing the reference to it from \texttt{refs} using the function \texttt{delete!}, provided that no other reference to the variable is kept anywhere:




\begin{lstlisting}
jl_function_t* delete = jl_get_function(jl_base_module, "delete!");
jl_call2(delete, refs, rvar);
\end{lstlisting}



As an alternative for very simple cases, it is possible to just create a global container of type \texttt{Vector\{Any\}} and fetch the elements from that when necessary, or even to create one global variable per pointer using




\begin{lstlisting}
jl_set_global(jl_main_module, jl_symbol("var"), var);
\end{lstlisting}



\hypertarget{16854094057405745675}{}


\subsection{Updating fields of GC-managed objects}



The garbage collector operates under the assumption that it is aware of every old-generation object pointing to a young-generation one. Any time a pointer is updated breaking that assumption, it must be signaled to the collector with the \texttt{jl\_gc\_wb} (write barrier) function like so:




\begin{lstlisting}
jl_value_t *parent = some_old_value, *child = some_young_value;
((some_specific_type*)parent)->field = child;
jl_gc_wb(parent, child);
\end{lstlisting}



通常情况下不可能在运行时预测 值是否是旧的，因此 写屏障 必须被插入在所有显式存储之后。一个需要注意的例外是如果 \texttt{parent} 对象刚分配，垃圾收集之后并不执行。请记住大多数 \texttt{jl\_...} 函数有时候都会执行垃圾收集。



直接更新数据时，对于指针数组来说 写屏障 也是必需的 例如：




\begin{lstlisting}
jl_array_t *some_array = ...; // e.g. a Vector{Any}
void **data = (void**)jl_array_data(some_array);
jl_value_t *some_value = ...;
data[0] = some_value;
jl_gc_wb(some_array, some_value);
\end{lstlisting}



\hypertarget{13611710259554554355}{}


\subsection{控制垃圾收集器}



有一些函数能够控制GC。在正常使用情况下这些不是必要的。




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
函数 & 描述 \\
\hline
\texttt{jl\_gc\_collect()} & 强制执行 GC \\
\hline
\texttt{jl\_gc\_enable(0)} & 禁用 GC， 返回前一个状态作为 int 类型 \\
\hline
\texttt{jl\_gc\_enable(1)} & 启用 GC， 返回前一个状态作为 int 类型 \\
\hline
\texttt{jl\_gc\_is\_enabled()} & 返回当前状态作为 int 类型 \\
\hline
\end{tabulary}

\end{table}



\hypertarget{12793375650632651595}{}


\section{使用数组}



Julia 和 C 可以不通过复制而共享数组数据。下面一个例子将展示它是如何工作的。



Julia数组用数据类型 \texttt{jl\_array\_t *} 表示。基本上，\texttt{jl\_array\_t} 是一个包含以下内容的结构：



\begin{itemize}
\item 关于数据类型的信息


\item 指向数据块的指针


\item 关于数组长度的信息

\end{itemize}


为了让事情比较简单，我们从一维数组开始，创建一个存有 10 个 FLoat64 类型的数组如下所示：




\begin{lstlisting}
jl_value_t* array_type = jl_apply_array_type((jl_value_t*)jl_float64_type, 1);
jl_array_t* x          = jl_alloc_array_1d(array_type, 10);
\end{lstlisting}



或者，如果您已经分配了数组，则可以生成一个简易的包装器来包裹其数据：




\begin{lstlisting}
double *existingArray = (double*)malloc(sizeof(double)*10);
jl_array_t *x = jl_ptr_to_array_1d(array_type, existingArray, 10, 0);
\end{lstlisting}



最后一个参数是一个布尔值，表示 Julia 是否应该获取数据的所有权。 如果这个参数 不为零，当数组不再被引用时，GC 会在数据的指针上调用 \texttt{free} 。



为了访问 x 的数据，我们可以使用 \texttt{jl\_array\_data}：




\begin{lstlisting}
double *xData = (double*)jl_array_data(x);
\end{lstlisting}



现在我们可以填充这个数组：




\begin{lstlisting}
for(size_t i=0; i<jl_array_len(x); i++)
    xData[i] = i;
\end{lstlisting}



现在让我们调用一个对 \texttt{x} 就地操作的 Julia 函数：




\begin{lstlisting}
jl_function_t *func = jl_get_function(jl_base_module, "reverse!");
jl_call1(func, (jl_value_t*)x);
\end{lstlisting}



通过打印数组，可以验证 \texttt{x} 的元素现在是否已被逆置 (reversed)。



\hypertarget{10421624901695308393}{}


\subsection{获取返回的数组}



如果 Julia 函数返回一个数组，\texttt{jl\_eval\_string} 和 \texttt{jl\_call} 的返回值可以被强制转换为\texttt{jl\_array\_t *}：




\begin{lstlisting}
jl_function_t *func  = jl_get_function(jl_base_module, "reverse");
jl_array_t *y = (jl_array_t*)jl_call1(func, (jl_value_t*)x);
\end{lstlisting}



现在使用 \texttt{jl\_array\_data} 可以像前面一样访问 \texttt{y} 的内容。一如既往地，一定要在使用数组的时候确保 持有使用数组的引用。



\hypertarget{14703069974979105074}{}


\subsection{多维数组}



Julia的多维数组以 列序优先 存储在内存中。这是一些 创建一个2D数组并访问其属性 的代码：




\begin{lstlisting}
// Create 2D array of float64 type
jl_value_t *array_type = jl_apply_array_type(jl_float64_type, 2);
jl_array_t *x  = jl_alloc_array_2d(array_type, 10, 5);

// Get array pointer
double *p = (double*)jl_array_data(x);
// Get number of dimensions
int ndims = jl_array_ndims(x);
// Get the size of the i-th dim
size_t size0 = jl_array_dim(x,0);
size_t size1 = jl_array_dim(x,1);

// Fill array with data
for(size_t i=0; i<size1; i++)
    for(size_t j=0; j<size0; j++)
        p[j + size0*i] = i + j;
\end{lstlisting}



请注意，虽然 Julia 的数组使用基于 1 的索引，但C API 中使用基于 0 的索引（例如 在调用\texttt{jl\_array\_dim}）以便用C代码的习惯来阅读。



\hypertarget{4029112619480312893}{}


\section{异常}



Julia 代码可以抛出异常。比如：




\begin{lstlisting}
jl_eval_string("this_function_does_not_exist()");
\end{lstlisting}



这个调用似乎什么都没做。但可以检查异常是否抛出：




\begin{lstlisting}
if (jl_exception_occurred())
    printf("%s \n", jl_typeof_str(jl_exception_occurred()));
\end{lstlisting}



如果您使用 支持异常的语言的 Julia C API（例如Python，C＃，C ++），使用 检查是否有异常的函数 将每个调用 包装到 \texttt{libjulia} 中是有意义的，然后异常在宿主语言中重新抛出。



\hypertarget{3345506826925468977}{}


\subsection{抛出 Julia 异常}



在编写 Julia 可调用函数时，可能需要验证参数 并抛出异常表示错误。 典型的类型检查像这样：




\begin{lstlisting}
if (!jl_typeis(val, jl_float64_type)) {
    jl_type_error(function_name, (jl_value_t*)jl_float64_type, val);
}
\end{lstlisting}



可以使用以下函数 引发一般异常：




\begin{lstlisting}
void jl_error(const char *str);
void jl_errorf(const char *fmt, ...);
\end{lstlisting}



\texttt{jl\_error}采用 C 字符串，而 \texttt{jl\_errorf} 像 \texttt{printf} 一样调用:




\begin{lstlisting}
jl_errorf("argument x = %d is too large", x);
\end{lstlisting}



在这个例子中假定 \texttt{x} 是一个 int 值。



\hypertarget{15996691828014685993}{}


\chapter{代码加载}



\begin{quote}
\textbf{Note}

这一章包含了加载包的技术细节。如果要安装包，使用 Julia 的内置包管理器\hyperlink{7626139948888930049}{\texttt{Pkg}}将包加入到你的活跃环境中。如果要使用已经在你的活跃环境中的包，使用 \texttt{import X} 或 \texttt{using X}，正如在\hyperlink{7031478671373133429}{模块}中所描述的那样。

\end{quote}


\hypertarget{5148923403283115982}{}


\section{定义}



Julia加载代码有两种机制：



\begin{itemize}
\item[1. ] \textbf{代码包含：}例如 \texttt{include({\textquotedbl}source.jl{\textquotedbl})}。包含允许你把一个程序拆分为多个源文件。表达式 \texttt{include({\textquotedbl}source.jl{\textquotedbl})} 使得文件 \texttt{source.jl} 的内容在出现 \texttt{include} 调用的模块的全局作用域中执行。如果多次调用 \texttt{include({\textquotedbl}source.jl{\textquotedbl})}，\texttt{source.jl} 就被执行多次。\texttt{source.jl} 的包含路径解释为相对于出现 \texttt{include} 调用的文件路径。重定位源文件子树因此变得简单。在 REPL 中，包含路径为当前工作目录，即 \hyperlink{16313884780490629439}{\texttt{pwd()}}。


\item[2. ] \textbf{加载包：}例如 \texttt{import X} 或 \texttt{using X}。\texttt{import} 通过加载包（一个独立的，可重用的 Julia 代码集合，包含在一个模块中），并导入模块内部的名称 \texttt{X}，使得模块 \texttt{X} 可用。 如果在同一个 Julia 会话中，多次导入包 \texttt{X}，那么后续导入模块为第一次导入模块的引用。但请注意，\texttt{import X} 可以在不同的上下文中加载不同的包：\texttt{X} 可以引用主工程中名为 \texttt{X} 的一个包，但它在各个依赖中可以引用不同的、名称同为 \texttt{X} 的包。更多机制说明如下。

\end{itemize}


代码包含是非常直接和简单的：其在调用者的上下文中解释运行给定的源文件。包加载是建立在代码包含之上的，它具有不同的\hyperlink{16725527896995457152}{用途}。本章的其余部分将重点介绍程序包加载的行为和机制。



一个 \emph{包（package）} 就是一个源码树，其标准布局中提供了其他 Julia 项目可以复用的功能。包可以使用 \texttt{import X} 或 \texttt{using X} 语句加载，名为 \texttt{X} 的模块在加载包代码时生成，并在包含该 import 语句的模块中可用。\texttt{import X} 中 \texttt{X} 的含义与上下文有关：程序加载哪个 \texttt{X} 包取决于 import 语句出现的位置。因此，处理 \texttt{import X} 分为两步：首先，确定在此上下文中是\textbf{哪个}包被定义为 \texttt{X}；其次，确定到\textbf{哪里}找特定的 \texttt{X} 包。



这些问题可通过查询各项目文件（\texttt{Project.toml} 或 \texttt{JuliaProject.toml}）、清单文件（\texttt{Manifest.toml} 或 \texttt{JuliaManifest.toml}），或是源文件的文件夹列在\hyperlink{17914149694871263675}{\texttt{LOAD\_PATH}} 中的项目环境解决。



\hypertarget{6907225830267322072}{}


\section{包的联合}



大多数时候，一个包可以通过它的名字唯一确定。但有时在一个项目中，可能需要使用两个有着相同名字的不同的包。尽管你可以通过重命名其中一个包来解决这个问题，但在一个大型的、共享的代码库中被迫做这件事可能是有高度破坏性的。相反，Julia的包加载机制允许相同的包名在一个应用的不同部分指向不同的包。



Julia 支持联合的包管理，这意味着多个独立的部分可以维护公有包、私有包以及包的注册表，并且项目可以依赖于一系列来自不同注册表的公有包和私有包。您也可以使用一组通用工具和工作流（workflow）来安装和管理来自各种注册表的包。Julia 附带的 \texttt{Pkg} 软件包管理器允许安装和管理项目的依赖项，它会帮助创建并操作项目文件（其描述了项目所依赖的其他项目）和清单文件（其为项目完整依赖库的确切版本的快照）。



联合管理的一个可能后果是没有包命名的中央权限。不同组织可以使用相同的名称来引用不相关的包。这并不是没有可能的，因为这些组织可能没有协作，甚至不知道彼此。由于缺乏中央命名权限，单个项目可能最终依赖着具有相同名称的不同包。Julia 的包加载机制不要求包名称是全局唯一的，即使在单个项目的依赖关系图中也是如此。相反，包由\href{https://en.wikipedia.org/wiki/Universally\_unique\_identifier}{通用唯一标识符} （UUID）进行标识，它在每个包创建时进行分配。通常，您不必直接使用这些有点麻烦的 128 位标识符，因为 \texttt{Pkg} 将负责生成和跟踪它们。但是，这些 UUID 为问题\emph{「\texttt{X} 所指的包是什么？」}提供了确定的答案



由于去中心化的命名问题有些抽象，因此可以通过具体情境来理解问题。假设你正在开发一个名为 \texttt{App} 的应用程序，它使用两个包：\texttt{Pub} 和 \texttt{Priv}。\texttt{Priv} 是你创建的私有包，而 \texttt{Pub} 是你使用但不控制的公共包。当你创建 \texttt{Priv} 时，没有名为 \texttt{Priv} 的公共包。然而，随后一个名为 \texttt{Priv} 的不相关软件包发布并变得流行起来，而且 \texttt{Pub} 包已经开始使用它了。因此，当你下次升级 \texttt{Pub} 以获取最新的错误修复和特性时，\texttt{App} 将依赖于两个名为 \texttt{Priv} 的不同包——尽管你除了升级之外什么都没做。\texttt{App} 直接依赖于你的私有 \texttt{Priv} 包，以及通过 \texttt{Pub} 在新的公共 \texttt{Priv} 包上的间接依赖。由于这两个 \texttt{Priv} 包是不同的，但是 \texttt{App} 继续正常工作依赖于他们两者，因此表达式 \texttt{import Priv} 必须引用不同的 \texttt{Priv} 包，具体取决于它是出现在 \texttt{App} 的代码中还是出现在 \texttt{Pub} 的代码中。为了处理这种情况，Julia 的包加载机制通过 UUID 区分两个 \texttt{Priv} 包并根据它（调用 \texttt{import} 的模块）的上下文选择正确的包。这种区分的工作原理取决于环境，如以下各节所述。



\hypertarget{3001628692617530434}{}


\section{环境（Environments）}



\textbf{环境}决定了 \texttt{import X} 和 \texttt{using X} 语句在不同的代码上下文中的含义以及什么文件会被加载。Julia 有两类环境（environment）：



\begin{itemize}
\item[1. ] \textbf{A project environment} is a directory with a project file and an optional manifest file, and forms an \emph{explicit environment}. The project file determines what the names and identities of the direct dependencies of a project are. The manifest file, if present, gives a complete dependency graph, including all direct and indirect dependencies, exact versions of each dependency, and sufficient information to locate and load the correct version.


\item[2. ] \textbf{包目录（package directory）}是包含一组包的源码树子目录的目录，并形成一个\emph{隐式环境}。如果 \texttt{X} 是包目录的子目录并且存在 \texttt{X/src/X.jl}，那么程序包 \texttt{X} 在包目录环境中可用，而 \texttt{X/src/X.jl} 是加载它使用的源文件。

\end{itemize}


这些环境可以混合并用来创建\textbf{堆栈环境（stacked environment）}：是一组有序的项目环境和包目录，重叠为一个复合环境。然后，结合优先级规则和可见性规则，确定哪些包是可用的以及从哪里加载它们。例如，Julia 的负载路径是一个堆栈环境。



这些环境各有不同的用途：



\begin{itemize}
\item 项目环境提供\textbf{可迁移性}。通过将项目环境以及项目源代码的其余部分存放到版本控制（例如一个 git 存储库），您可以重现项目的确切状态和所有依赖项。特别是，清单文件会记录每个依赖项的确切版本，而依赖项由其源码树的加密哈希值标识；这使得 \texttt{Pkg} 可以检索出正确的版本，并确保你正在运行准确的已记录的所有依赖项的代码。


\item 当不需要完全仔细跟踪的项目环境时，包目录更\textbf{方便}。当你想要把一组包放在某处，并且希望能够直接使用它们而不必为之创建项目环境时，包目录是很实用的。


\item 堆栈环境允许向基本环境\textbf{添加}工具。您可以将包含开发工具在内的环境堆到堆栈环境的末尾，使它们在 REPL 和脚本中可用，但在包内部不可用。

\end{itemize}


从更高层次上，每个环境在概念上定义了三个映射：roots、graph 和 paths。当解析 \texttt{import X} 的含义时，roots 和 graph 映射用于确定 \texttt{X} 的身份，同时 paths 映射用于定位 \texttt{X} 的源代码。这三个映射的具体作用是：



\begin{itemize}
\item \textbf{roots:} \texttt{name::Symbol} ⟶ \texttt{uuid::UUID}

环境的 roots 映射将包名称分配给UUID，以获取环境可用于主项目的所有顶级依赖项（即可以在 \texttt{Main} 中加载的那些依赖项）。当 Julia 在主项目中遇到 \texttt{import X} 时，它会将 \texttt{X} 的标识作为 \texttt{roots[:X]}。


\item \textbf{graph:} \texttt{context::UUID} ⟶ \texttt{name::Symbol} ⟶ \texttt{uuid::UUID}

环境的 graph 是一个多级映射，它为每个 \texttt{context} UUID 分配一个从名称到 UUID 的映射——类似于 roots 映射，但专一于那个 \texttt{context}。当 Julia 在 UUID 为 \texttt{context} 的包代码中运行到 \texttt{import X} 时，它会将 \texttt{X} 的标识看作为 \texttt{graph[context][:X]}。正是因为如此，\texttt{import X} 可以根据 \texttt{context} 引用不同的包。


\item \textbf{paths:} \texttt{uuid::UUID} × \texttt{name::Symbol} ⟶ \texttt{path::String}

paths 映射会为每个包分配 UUID-name 对，即该包的入口点源文件的位置。在 \texttt{import X} 中，\texttt{X} 的标识已经通过 roots 或 graph 解析为 UUID（取决于它是从主项目还是从依赖项加载），Julia 确定要加载哪个文件来获取 \texttt{X} 是通过在环境中查找 \texttt{paths[uuid,:X]}。要包含此文件应该定义一个名为 \texttt{X} 的模块。一旦加载了此包，任何解析为相同的 \texttt{uuid} 的后续导入只会创建一个到同一个已加载的包模块的绑定。

\end{itemize}


每种环境都以不同的方式定义这三种映射，详见以下各节。



\begin{quote}
\textbf{Note}

为了清楚地说明，本章中的示例包括 roots、graph 和 paths 的完整数据结构。但是，为了提高效率，Julia 的包加载代码并没有显式地创建它们。相反，加载一个给定包只会简单地计算所需的结构。

\end{quote}


\hypertarget{2089876833496138047}{}


\subsection{项目环境（Project environments）}



项目环境由包含名为 \texttt{Project.toml} 的项目文件的目录以及名为 \texttt{Manifest.toml} 的清单文件（可选）确定。这些文件也可以命名为 \texttt{JuliaProject.toml} 和 \texttt{JuliaManifest.toml}，此时 \texttt{Project.toml} 和 \texttt{Manifest.toml} 被忽略——这允许项目与可能需要名为 \texttt{Project.toml} 和 \texttt{Manifest.toml} 文件的其他重要工具共存。但是对于纯 Julia 项目，名称 \texttt{Project.toml} 和 \texttt{Manifest.toml} 是首选。



项目环境的 roots、graph 和 paths 映射定义如下：



\textbf{roots 映射} 在环境中由其项目文件的内容决定，特别是它的顶级 \texttt{name} 和 \texttt{uuid} 条目及其 \texttt{[deps]} 部分（全部是可选的）。考虑以下一个假想的应用程序 \texttt{App} 的示例项目文件，如先前所述：




\begin{lstlisting}
name = "App"
uuid = "8f986787-14fe-4607-ba5d-fbff2944afa9"

[deps]
Priv = "ba13f791-ae1d-465a-978b-69c3ad90f72b"
Pub  = "c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"
\end{lstlisting}



如果将它表示为 Julia 字典，那么这个项目文件意味着以下 roots 映射：




\begin{minted}{julia}
roots = Dict(
    :App  => UUID("8f986787-14fe-4607-ba5d-fbff2944afa9"),
    :Priv => UUID("ba13f791-ae1d-465a-978b-69c3ad90f72b"),
    :Pub  => UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"),
)
\end{minted}



基于这个 root 映射，在 \texttt{App} 的代码中，语句 \texttt{import Priv} 将使 Julia 查找 \texttt{roots[:Priv]}，这将得到 \texttt{ba13f791-ae1d-465a-978b-69c3ad90f72b}，也就是要在这一部分加载的 \texttt{Priv} 包的 UUID。当主应用程序解释运行到 \texttt{import Priv} 时，此 UUID 标识了要加载和使用的 \texttt{Priv} 包。



\textbf{依赖图（dependency graph）} 在项目环境中其清单文件的内容决定，如果其存在。如果没有清单文件，则 graph 为空。清单文件包含项目的直接或间接依赖项的节（stanza）。对于每个依赖项，该文件列出该包的 UUID 以及源码树的哈希值或源代码的显式路径。考虑以下 \texttt{App} 的示例清单文件：




\begin{lstlisting}
[[Priv]] # 私有的那个
deps = ["Pub", "Zebra"]
uuid = "ba13f791-ae1d-465a-978b-69c3ad90f72b"
path = "deps/Priv"

[[Priv]] # 公共的那个
uuid = "2d15fe94-a1f7-436c-a4d8-07a9a496e01c"
git-tree-sha1 = "1bf63d3be994fe83456a03b874b409cfd59a6373"
version = "0.1.5"

[[Pub]]
uuid = "c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"
git-tree-sha1 = "9ebd50e2b0dd1e110e842df3b433cb5869b0dd38"
version = "2.1.4"

  [Pub.deps]
  Priv = "2d15fe94-a1f7-436c-a4d8-07a9a496e01c"
  Zebra = "f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"

[[Zebra]]
uuid = "f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"
git-tree-sha1 = "e808e36a5d7173974b90a15a353b564f3494092f"
version = "3.4.2"
\end{lstlisting}



这个清单文件描述了 \texttt{App} 项目可能的完整依赖关系图：



\begin{itemize}
\item 应用程序使用两个名为 \texttt{Priv} 的不同包，一个作为根依赖项的私有包，以及一个通过 \texttt{Pub} 作为间接依赖项的公共包。它们通过不同 UUID 来区分，并且有不同的依赖项：

\begin{itemize}
\item 私有的 \texttt{Priv} 依赖于 \texttt{Pub} 和 \texttt{Zebra} 包。


\item 公有的 \texttt{Priv} 没有依赖关系。

\end{itemize}

\item 该应用程序还依赖于 \texttt{Pub} 包，而后者依赖于公有的 \texttt{Priv} 以及私有的 \texttt{Priv} 包所依赖的那个 \texttt{Zebra} 包。

\end{itemize}


此依赖图以字典表示后如下所示：




\begin{minted}{julia}
graph = Dict(
    # Priv——私有的那个:
    UUID("ba13f791-ae1d-465a-978b-69c3ad90f72b") => Dict(
        :Pub   => UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"),
        :Zebra => UUID("f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"),
    ),
    # Priv——公共的那个:
    UUID("2d15fe94-a1f7-436c-a4d8-07a9a496e01c") => Dict(),
    # Pub:
    UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1") => Dict(
        :Priv  => UUID("2d15fe94-a1f7-436c-a4d8-07a9a496e01c"),
        :Zebra => UUID("f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"),
    ),
    # Zebra:
    UUID("f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62") => Dict(),
)
\end{minted}



给定这个依赖图，当 Julia 看到 \texttt{Pub} 包中的 \texttt{import Priv} ——它有 UUID\texttt{c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1} 时，它会查找：




\begin{minted}{julia}
graph[UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1")][:Priv]
\end{minted}



会得到 \texttt{2d15fe94-a1f7-436c-a4d8-07a9a496e01c}，这意味着 \texttt{Pub} 包中的内容，\texttt{import Priv} 指代的是公有的 \texttt{Priv} 内容，而非应用程序直接依赖的私有包。这也是为何 \texttt{Priv} 在主项目中可指代不同的包，而不像其在某个依赖包中另有含义。在包生态中，该特性允许重名的出现。



如果在 \texttt{App} 主代码库中 \texttt{import Zebra} 会如何？因为\texttt{Zebra} 不存在于项目文件，即使它 \emph{确实} 存在于清单文件中，其导入会是失败的。此外，\texttt{import Zebra} 这个行为若发生在公有的 \texttt{Priv} 包——UUID 为 \texttt{2d15fe94-a1f7-436c-a4d8-07a9a496e01c} 的包中，同样会失败。因为公有的 \texttt{Priv} 包未在清单文件中声明依赖，故而无法加载包。仅有在清单文件：\texttt{Pub} 包和一个 \texttt{Priv} 包中作为显式依赖的包可用于加载 \texttt{Zebra}。



项目环境的 \textbf{路径映射} 从 manifest 文件中提取得到。而包的路径 \texttt{uuid} 和名称 \texttt{X} 则 (循序) 依据这些规则确定。



\begin{itemize}
\item[1. ] 如果目录中的项目文件与要求的 \texttt{uuid} 以及名称 \texttt{X} 匹配，那么可能出现以下情况的一种：

\end{itemize}


\begin{itemize}
\item 若该文件具有顶层 \texttt{路径} 入口，则 \texttt{uuid} 会被映射到该路径，文件的执行与包含项目文件的目录相关。


\item 此外，\texttt{uuid} 依照包含项目文件的目录，映射至与\texttt{src/X.jl}。

\end{itemize}


\begin{itemize}
\item[2. ] 若非上述情况，且项目文件具有对应的清单文件，且该清单文件包含匹配 \texttt{uuid} 的节（stanza），那么：

\end{itemize}


\begin{itemize}
\item 若其具有一个 \texttt{路径} 入口，则使用该路径（与包含清单文件的目录相关）。


\item 若其具有一个 \texttt{git-tree-sha1} 入口，计算一个确定的 \texttt{uuid} 与 \texttt{git-tree-sha1} 函数——我们把这个函数称为 \texttt{slug}——并在每个 Julia \texttt{DEPOT\_PATH} 的全局序列中的目录查询名为 \texttt{packages/X/\$slug} 的目录。使用存在的第一个此类目录。

\end{itemize}


若某些结果成功，源码入口点的路径会是这些结果中的某个，结果的相对路径+\texttt{src/X.jl}；否则，\texttt{uuid} 不存在路径映射。当加载 \texttt{X} 时，如果没找到源码路径，查找即告失败，用户可能会被提示安装适当的包版本或采取其他纠正措施（例如，将 \texttt{X} 声明为某种依赖性）。



在上述样例清单文件中，为找到首个 \texttt{Priv} 包的路径——该包 UUID 为 \texttt{ba13f791-ae1d-465a-978b-69c3ad90f72b}——Julia 寻找其在清单中的节（stanza）。发现其有 路径\texttt{入口，查看}App\texttt{项目目录中相关的}deps/Priv\texttt{——不妨设}App\texttt{代码在}/home/me/projects/App\texttt{中—则 Julia 发现}/home/me/projects/App/deps/Priv\texttt{存在，并因此从中加载}Priv`。



另一方面，如果Julia加载的是带有\emph{other} \texttt{Priv} 包——即UUID为\texttt{2d15fe94-a1f7-436c-a4d8-07a9a496e01c}——它在清单中找到了它的节，请注意它\emph{没有}\texttt{path}条目，但是它有一个\texttt{git-tree-sha1} 条目。然后计算这个\texttt{slug} 的UUID/SHA-1对，具体是\texttt{HDkrT}（这个计算的确切细节并不重要，但它是始终一致的和确定的）。这意味着这个\texttt{Priv}包的路径\texttt{packages/Priv/HDkrT/src/Priv.jl}将在其中一个包仓库中。假设\texttt{DEPOT\_PATH} 的内容是\texttt{[{\textquotedbl}/home/me/.julia{\textquotedbl}, {\textquotedbl}/usr/local/julia{\textquotedbl}]}，Julia将根据下面的路径来查看它们是否存在：



\begin{itemize}
\item[1. ] \texttt{/home/me/.julia/packages/Priv/HDkrT}


\item[2. ] \texttt{/usr/local/julia/packages/Priv/HDkrT}

\end{itemize}


Julia使用以上路径信息在仓库里依次查找 \texttt{packages/Priv/HDKrT/src/Priv.jl}文件，并从第一个查找到的文件中加载公共的 \texttt{Priv}包。



这是我们的示例App项目环境的可能路径映射的表示，  如上面Manifest 中所提供的依赖关系图， 在 搜索本地文件系统后：




\begin{minted}{julia}
paths = Dict(
    # Priv – the private one:
    (UUID("ba13f791-ae1d-465a-978b-69c3ad90f72b"), :Priv) =>
        # relative entry-point inside `App` repo:
        "/home/me/projects/App/deps/Priv/src/Priv.jl",
    # Priv – the public one:
    (UUID("2d15fe94-a1f7-436c-a4d8-07a9a496e01c"), :Priv) =>
        # package installed in the system depot:
        "/usr/local/julia/packages/Priv/HDkr/src/Priv.jl",
    # Pub:
    (UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"), :Pub) =>
        # package installed in the user depot:
        "/home/me/.julia/packages/Pub/oKpw/src/Pub.jl",
    # Zebra:
    (UUID("f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"), :Zebra) =>
        # package installed in the system depot:
        "/usr/local/julia/packages/Zebra/me9k/src/Zebra.jl",
)
\end{minted}



这个例子包含三种不同类型的包位置信息(第一个和第三个是默认加载路径的一部分)



\begin{itemize}
\item[1. ] 私有 \texttt{Priv} 包 {\textquotedbl}\href{https://stackoverflow.com/a/35109534}{vendored}{\textquotedbl}包括在\texttt{App}仓库中。


\item[2. ] 公共 \texttt{Priv} 与 \texttt{Zebra} 包位于系统仓库，系统管理员在此对相关包进行实时安装与管理。这些包允许系统上的所有用户使用。


\item[3. ] \texttt{Pub} 包位于用户仓库，用户实时安装的包都储存在此。 这些包仅限原安装用户使用。

\end{itemize}


\hypertarget{9048837682653155362}{}


\subsection{包目录}



包目录提供了一种更简单的环境，但不能处理名称冲突。在包目录中， 顶层包集合是“类似”包的子目录集合。“X”包存在于包目录中的条件，是目录包含下列“入口点”文件之一：



\begin{itemize}
\item \texttt{X.jl}


\item \texttt{X/src/X.jl}


\item \texttt{X.jl/src/X.jl}

\end{itemize}


包目录中的包可以导入哪些依赖项，取决于该包是否含有项目文件：



\begin{itemize}
\item 如果它有一个项目文件，那么它只能导入那些在项目文件的\texttt{[deps]} 部分中已标识的包。


\item 如果没有项目文件，它可以导入任何顶层包，即与在\texttt{Main} 或者 REPL中可加载的包相同。

\end{itemize}


\textbf{根图}是根据包目录的所有内容而形成的一个列表，包含所有已存在的包。 此外，一个UUID 将被赋予给每一个条目，例如对一个在文件夹\texttt{X}中找到的包



\begin{itemize}
\item[1. ] 如果\texttt{X/Project.toml}文件存在并且有一个\texttt{uuid} 条目，那么这个 \texttt{uuid}就是上述所要赋予的值。


\item[2. ] 如果\texttt{X/Project.toml}文件存在，但\emph{没有}包含一个顶层UUID条目, 该\texttt{uuid}将是一个虚构的UUID，是对\texttt{X/Project.toml}文件所在的规范（真实的）路径信息进行哈希处理而生成。


\item[3. ] 否则（如果\texttt{Project.toml}文件不存在）， \texttt{uuid}将是一个全零值 \href{https://en.wikipedia.org/wiki/Universally\_unique\_identifier\#Nil\_UUID}{nil UUID}。

\end{itemize}


项目目录的\textbf{依赖关系图}是根据每个包的子目录中其项目文件的存在与否以及内容而形成。规则是：



\begin{itemize}
\item 如果包子目录没有项目文件，则在该图中忽略它， 其代码中的import语句按顶层处理，与main项目和REPL相同。


\item 如果包子目录有一个项目文件，那么图条目的UUID是项目文件的\texttt{[deps]}映射， 如果该信息项不存在，则视为空。

\end{itemize}


作为一个例子，假设包目录具有以下结构和内容：




\begin{lstlisting}
Aardvark/
    src/Aardvark.jl:
        import Bobcat
        import Cobra

Bobcat/
    Project.toml:
        [deps]
        Cobra = "4725e24d-f727-424b-bca0-c4307a3456fa"
        Dingo = "7a7925be-828c-4418-bbeb-bac8dfc843bc"

    src/Bobcat.jl:
        import Cobra
        import Dingo

Cobra/
    Project.toml:
        uuid = "4725e24d-f727-424b-bca0-c4307a3456fa"
        [deps]
        Dingo = "7a7925be-828c-4418-bbeb-bac8dfc843bc"

    src/Cobra.jl:
        import Dingo

Dingo/
    Project.toml:
        uuid = "7a7925be-828c-4418-bbeb-bac8dfc843bc"

    src/Dingo.jl:
        # no imports
\end{lstlisting}



下面是相应的根结构，表示为字典：




\begin{minted}{julia}
roots = Dict(
    :Aardvark => UUID("00000000-0000-0000-0000-000000000000"), # no project file, nil UUID
    :Bobcat   => UUID("85ad11c7-31f6-5d08-84db-0a4914d4cadf"), # dummy UUID based on path
    :Cobra    => UUID("4725e24d-f727-424b-bca0-c4307a3456fa"), # UUID from project file
    :Dingo    => UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc"), # UUID from project file
)
\end{minted}



下面是对应的图结构，表示为字典：




\begin{minted}{julia}
graph = Dict(
    # Bobcat:
    UUID("85ad11c7-31f6-5d08-84db-0a4914d4cadf") => Dict(
        :Cobra => UUID("4725e24d-f727-424b-bca0-c4307a3456fa"),
        :Dingo => UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc"),
    ),
    # Cobra:
    UUID("4725e24d-f727-424b-bca0-c4307a3456fa") => Dict(
        :Dingo => UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc"),
    ),
    # Dingo:
    UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc") => Dict(),
)
\end{minted}



需要注意的一些概括性规则：



\begin{itemize}
\item[1. ] 缺少项目文件的包能依赖于任何顶层依赖项， 并且由于包目录中的每个包在顶层依赖中可用，因此它可以导入在环境中的所有包。


\item[2. ] 含有项目文件的包不能依赖于缺少项目文件的包。 因为有项目文件的包只能加载那些在\texttt{graph}中的包，而没有项目文件的包不会出现在\texttt{graph}。


\item[3. ] 具有项目文件但没有明确UUID的包只能被由没有项目文件的包所依赖， since dummy UUIDs assigned to these packages are strictly internal.

\end{itemize}


，因为赋予给这些包的虚构UUID全是项目内部的。



Observe the following specific instances of these rules in our example: 请注意以下我们例子中的规则具体实例：



\begin{itemize}
\item \texttt{Aardvark} 包可以导入\texttt{Bobcat}、\texttt{Cobra} 或\texttt{Dingo}中的所有包；它确实导入\texttt{Bobcat} and \texttt{Cobra}包.


\item \texttt{Bobcat} 包能导入\texttt{Cobra}与\texttt{Dingo}包。因为它们都有带有UUID的项目文件，并在\texttt{Bobcat}包的\texttt{[deps]}信息项声明为依赖项。


\item \texttt{Bobcat}包不能依赖于\texttt{Aardvark}包，因为\texttt{Aardvark}包缺少项目文件。


\item \texttt{Cobra}包能导入\texttt{Dingo}包。因为\texttt{Dingo}包有项目文件和UUID，并在\texttt{Cobra}的\texttt{[deps]} 信息项中声明为依赖项。


\item \texttt{Cobra}包不能依赖\texttt{Aardvark}或\texttt{Bobcat}包， 因为两者都没有真实的UUID。


\item \texttt{Dingo}包不能导入任何包，因为它的项目文件中缺少\texttt{[deps]}信息项。

\end{itemize}


包目录中的\textbf{路径映射}很简单: 它将子目录名映射到相应的入口点路径。换句话说，如果指向我们示例项目目录的路径是\texttt{/home/me/animals}，那么\texttt{路径}映射可以用此字典表示：




\begin{minted}{julia}
paths = Dict(
    (UUID("00000000-0000-0000-0000-000000000000"), :Aardvark) =>
        "/home/me/AnimalPackages/Aardvark/src/Aardvark.jl",
    (UUID("85ad11c7-31f6-5d08-84db-0a4914d4cadf"), :Bobcat) =>
        "/home/me/AnimalPackages/Bobcat/src/Bobcat.jl",
    (UUID("4725e24d-f727-424b-bca0-c4307a3456fa"), :Cobra) =>
        "/home/me/AnimalPackages/Cobra/src/Cobra.jl",
    (UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc"), :Dingo) =>
        "/home/me/AnimalPackages/Dingo/src/Dingo.jl",
)
\end{minted}



根据定义，包目录环境中的所有包都是具有预期入口点文件的子目录，因此它们的\texttt{路径} 映射条目始终具有此格式。



\hypertarget{14356834175019870606}{}


\subsection{环境堆栈}



第三种也是最后一种环境是通过覆盖其中的几个环境来组合其他环境，使每个环境中的包在单个组合环境中可用。这些复合环境称为\emph{环境堆栈}。Julia的\texttt{LOAD\_PATH}全局定义一个环境堆栈——Julia进程在其中运行的环境。如果希望Julia进程只能访问一个项目或包目录中的包，请将其设置为\texttt{LOAD\_PATH}中的唯一条目。然而，访问一些您喜爱的工具（标准库、探查器、调试器、个人实用程序等）通常是非常有用的，即使它们不是您正在处理的项目的依赖项。通过将包含这些工具的环境添加到加载路径，您可以立即在顶层代码中访问它们，而无需将它们添加到项目中。



组合环境堆栈组件中根、图和路径的数据结构的机制很简单：它们被作为字典进行合并， 在发生键冲突时，优先使用前面的条目而不是后面的条目。换言之，如果我们有\texttt{stack = [env₁, env₂, …]}，那么我们有：




\begin{minted}{julia}
roots = reduce(merge, reverse([roots₁, roots₂, …]))
graph = reduce(merge, reverse([graph₁, graph₂, …]))
paths = reduce(merge, reverse([paths₁, paths₂, …]))
\end{minted}



带下标的 \texttt{rootsᵢ}, \texttt{graphᵢ} and \texttt{pathsᵢ}变量对应于在\texttt{stack}中包含的下标环境变量\texttt{envᵢ}。 使用\texttt{reverse} 是因为当参数字典中的键之间发生冲突时，使\texttt{merge} 倾向于使用最后一个参数，而不是第一个参数。这种设计有几个值得注意的特点：



\begin{itemize}
\item[1. ] \emph{主环境}——即堆栈中的第一个环境，被准确地嵌入到堆栈环境中。堆栈中第一个环境的完整依赖关系图是必然被完整包括在含有所有相同版本的依赖项的堆栈环境中。


\item[2. ] 非主环境中的包能最终使用与其依赖项不兼容的版本，即使它们自己的环境是完全兼容。这种情况可能发生，当它们的一个依赖项被堆栈（通过图或路径，或两者）中某个早期环境中的版本所覆盖。

\end{itemize}


由于主环境通常是您正在处理的项目所在的环境，而堆栈中稍后的环境包含其他工具， 因此这是正确的权衡：最好改进您的开发工具，但保持项目能工作。当这种不兼容发生时，你通常要将开发工具升级到与主项目兼容的版本。



\hypertarget{16711373200664757596}{}


\section{总结}



在软件包系统中，联邦软件包管理和精确的软件可复制性是困难但有价值的目标。结合起来，这些目标导致了一个比大多数动态语言更加复杂的包加载机制，但它也产生了通常与静态语言相关的可伸缩性和可复制性。通常，Julia用户应该能够使用内置的包管理器来管理他们的项目，而无需精确理解这些交互细节。通过调用\texttt{Pkg.add({\textquotedbl}X{\textquotedbl})}添加\texttt{X}包到对应的项目，并清晰显示相关文件，选择\texttt{Pkg.activate({\textquotedbl}Y{\textquotedbl})}后, 可调用\texttt{import X} 即可加载\texttt{X}包，而无需作过多考虑。



\hypertarget{9798162676380759856}{}


\chapter{性能分析}



\texttt{Profile} 模块提供了一些工具来帮助开发者提高其代码的性能。在使用时，它运行代码并进行测量，并生成输出，该输出帮助你了解在每行（或几行）上花费了多少时间。最常见的用法是识别性能「瓶颈」并将其作为优化目标。



\texttt{Profile} 实现了所谓的「抽样」或\href{https://en.wikipedia.org/wiki/Profiling\_(computer\_programming)}{统计分析器}。它通过在执行任何任务期间定期进行回溯来工作。每次回溯捕获当前运行的函数和行号，以及导致该行执行的完整函数调用链，因此是当前执行状态的「快照」。



如果大部分运行时间都花在执行特定代码行上，则此行会在所有回溯的集合中频繁出现。换句话说，执行给定行的「成本」——或实际上，调用及包含此行的函数序列的成本——与它在所有回溯的集合中的出现频率成正比。



抽样分析器不提供完整的逐行覆盖功能，因为回溯是间隔发生的（默认情况下，该时间间隔在 Unix 上是 1 ms，而在 Windows 上是 10 ms，但实际调度受操作系统负载的影响）。此外，正如下文中进一步讨论的，因为样本是在所有执行点的稀疏子集处收集的，所以抽样分析器收集的数据会受到统计噪声的影响。



尽管有这些限制，但抽样分析器仍然有很大的优势：



\begin{itemize}
\item You do not have to make any modifications to your code to take timing measurements.


\item 它可以分析 Julia 的核心代码，甚至（可选）可以分析 C 和 Fortran 库。


\item 通过「偶尔」运行，它只有很少的性能开销；代码在性能分析时能以接近本机的速度运行。

\end{itemize}


出于这些原因，建议你在考虑任何替代方案前尝试使用内置的抽样分析器。



\hypertarget{17553054695497272357}{}


\section{基本用法}



让我们使用一个简单的测试用例：




\begin{minted}{jlcon}
julia> function myfunc()
           A = rand(200, 200, 400)
           maximum(A)
       end
\end{minted}



最好先至少运行一次你想要分析的代码（除非你想要分析 Julia 的 JIT 编译器）：




\begin{minted}{jlcon}
julia> myfunc() # run once to force compilation
\end{minted}



现在我们准备分析这个函数：




\begin{minted}{jlcon}
julia> using Profile

julia> @profile myfunc()
\end{minted}



To see the profiling results, there are several graphical browsers. One {\textquotedbl}family{\textquotedbl} of visualizers is based on \href{https://github.com/timholy/FlameGraphs.jl}{FlameGraphs.jl}, with each family member providing a different user interface:



\begin{itemize}
\item \href{https://junolab.org/}{Juno} is a full IDE with built-in support for profile visualization


\item \href{https://github.com/timholy/ProfileView.jl}{ProfileView.jl} is a stand-alone visualizer based on GTK


\item \href{https://github.com/davidanthoff/ProfileVega.jl}{ProfileVega.jl} uses VegaLight and integrates well with Jupyter notebooks


\item \href{https://github.com/tkluck/StatProfilerHTML.jl}{StatProfilerHTML} produces HTML and presents some additional summaries, and also integrates well with Jupyter notebooks


\item \href{https://github.com/timholy/ProfileSVG.jl}{ProfileSVG} renders SVG

\end{itemize}


An entirely independent approach to profile visualization is \href{https://github.com/vchuravy/PProf.jl}{PProf.jl}, which uses the external \texttt{pprof} tool.



Here, though, we{\textquotesingle}ll use the text-based display that comes with the standard library:




\begin{minted}{jlcon}
julia> Profile.print()
80 ./event.jl:73; (::Base.REPL.##1#2{Base.REPL.REPLBackend})()
 80 ./REPL.jl:97; macro expansion
  80 ./REPL.jl:66; eval_user_input(::Any, ::Base.REPL.REPLBackend)
   80 ./boot.jl:235; eval(::Module, ::Any)
    80 ./<missing>:?; anonymous
     80 ./profile.jl:23; macro expansion
      52 ./REPL[1]:2; myfunc()
       38 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type{B...
        38 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr{F...
       14 ./random.jl:278; rand
        14 ./random.jl:277; rand
         14 ./random.jl:366; rand
          14 ./random.jl:369; rand
      28 ./REPL[1]:3; myfunc()
       28 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinear,...
        3  ./reduce.jl:426; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...
        25 ./reduce.jl:428; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...
\end{minted}



显示结果中的每行表示代码中的特定点（行数）。缩进用来标明嵌套的函数调用序列，其中缩进更多的行在调用序列中更深。在每一行中，第一个「字段」是在\emph{这一行或由这一行执行的任何函数}中获取的回溯（样本）数量。第二个字段是文件名和行数，第三个字段是函数名。请注意，具体的行号可能会随着 Julia 代码的改变而改变；如果你想跟上，最好自己运行这个示例。



在此例中，我们可以看到顶层的调用函数位于文件 \texttt{event.jl} 中。这是启动 Julia 时运行 REPL 的函数。如果你查看 \texttt{REPL.jl} 的第 97 行，你会看到这是调用函数 \texttt{eval\_user\_input()} 的地方。这是对你在 REPL 上的输入进行求值的函数，因为我们正以交互方式运行，所以当我们输入 \texttt{@profile myfunc()} 时会调用这些函数。下一行反映了 \hyperlink{9691715859147716436}{\texttt{@profile}} 所采取的操作。



第一行显示在 \texttt{event.jl} 的第 73 行获取了 80 次回溯，但这并不是说此行本身「昂贵」：第三行表明所有这些 80 次回溯实际上它调用的 \texttt{eval\_user\_input} 中触发的，以此类推。为了找出实际占用时间的操作，我们需要深入了解调用链。



此输出中第一个「重要」的行是这行：




\begin{lstlisting}
52 ./REPL[1]:2; myfunc()
\end{lstlisting}



\texttt{REPL} 指的是我们在 REPL 中定义了 \texttt{myfunc}，而不是把它放在文件中；如果我们使用文件，这将显示文件名。\texttt{[1]} 表示函数 \texttt{myfunc} 是在当前 REPL 会话中第一个进行求值的表达式。\texttt{myfunc()} 的第 2 行包含对 \texttt{rand} 的调用，（80 次中）有 52 次回溯发生在该行。在此之下，你可以看到在 \texttt{dSFMT.jl} 中对 \texttt{dsfmt\_fill\_array\_close\_open!} 的调用。



更进一步，你会看到：




\begin{lstlisting}
28 ./REPL[1]:3; myfunc()
\end{lstlisting}



\texttt{myfunc} 的第 3 行包含对 \texttt{maximum} 的调用，（80 次中）有 28 次回溯发生在这里。在此之下，你可以看到对于这种类型的输入数据，\texttt{maximum} 函数中执行的耗时操作在 \texttt{base/reduce.jl} 中的具体位置。



总的来说，我们可以暂时得出结论，生成随机数的成本大概是找到最大元素的两倍。通过收集更多样本，我们可以增加对此结果的信心：




\begin{minted}{jlcon}
julia> @profile (for i = 1:100; myfunc(); end)

julia> Profile.print()
[....]
 3821 ./REPL[1]:2; myfunc()
  3511 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type...
   3511 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr...
  310  ./random.jl:278; rand
   [....]
 2893 ./REPL[1]:3; myfunc()
  2893 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinea...
   [....]
\end{minted}



一般来说，如果你在某行上收集到 \texttt{N} 个样本，那你可以预期其有 \texttt{sqrt(N)} 的不确定性（忽略其它噪音源，比如计算机在其它任务上的繁忙程度）。这个规则的主要例外是垃圾收集，它很少运行但往往成本高昂。（因为 Julia 的垃圾收集器是用 C 语言编写的，此类事件可使用下文描述的 \texttt{C=true} 输出模式来检测，或者使用 \href{https://github.com/timholy/ProfileView.jl}{ProfileView.jl} 来检测。）



这展示了默认的「树」形转储；另一种选择是「扁平」形转储，它会累积与其嵌套无关的计数：




\begin{minted}{jlcon}
julia> Profile.print(format=:flat)
 Count File          Line Function
  6714 ./<missing>     -1 anonymous
  6714 ./REPL.jl       66 eval_user_input(::Any, ::Base.REPL.REPLBackend)
  6714 ./REPL.jl       97 macro expansion
  3821 ./REPL[1]        2 myfunc()
  2893 ./REPL[1]        3 myfunc()
  6714 ./REPL[7]        1 macro expansion
  6714 ./boot.jl      235 eval(::Module, ::Any)
  3511 ./dSFMT.jl      84 dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_s...
  6714 ./event.jl      73 (::Base.REPL.##1#2{Base.REPL.REPLBackend})()
  6714 ./profile.jl    23 macro expansion
  3511 ./random.jl    431 rand!(::MersenneTwister, ::Array{Float64,3}, ::In...
   310 ./random.jl    277 rand
   310 ./random.jl    278 rand
   310 ./random.jl    366 rand
   310 ./random.jl    369 rand
  2893 ./reduce.jl    270 _mapreduce(::Base.#identity, ::Base.#scalarmax, :...
     5 ./reduce.jl    420 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
   253 ./reduce.jl    426 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
  2592 ./reduce.jl    428 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
    43 ./reduce.jl    429 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
\end{minted}



如果你的代码有递归，那么可能令人困惑的就是「子」函数中的行的累积计数可以多于总回溯次数。考虑以下函数定义：




\begin{minted}{julia}
dumbsum(n::Integer) = n == 1 ? 1 : 1 + dumbsum(n-1)
dumbsum3() = dumbsum(3)
\end{minted}



如果你要分析 \texttt{dumbsum3}，并在执行 \texttt{dumbsum(1)} 时执行了回溯，那么该回溯将如下所示：




\begin{minted}{julia}
dumbsum3
    dumbsum(3)
        dumbsum(2)
            dumbsum(1)
\end{minted}



因此，即使父函数只获得 1 个计数，这个子函数也会获得 3 个计数。「树」形表示使这更清晰，因此（以及其它原因）可能是查看结果的最实用方法。



\hypertarget{11920246320852784321}{}


\section{结果累积和清空}



\hyperlink{9691715859147716436}{\texttt{@profile}} 的结果会累积在一个缓冲区中；如果你在 \hyperlink{9691715859147716436}{\texttt{@profile}} 下运行多端代码，那么 \hyperlink{2955792207246042270}{\texttt{Profile.print()}} 会显示合并的结果。这可能非常有用，但有时你会想重新开始，这可通过 \hyperlink{15414823368700214048}{\texttt{Profile.clear()}}。



\hypertarget{3561003529463300631}{}


\section{用于控制性能分析结果显示的选项}



\hyperlink{2955792207246042270}{\texttt{Profile.print}} 还有一些未曾描述的选项。让我们看看完整的声明：




\begin{minted}{julia}
function print(io::IO = stdout, data = fetch(); kwargs...)
\end{minted}



我们先讨论两个位置参数，然后讨论关键字参数：



\begin{itemize}
\item \texttt{io}——允许你将结果保存到缓冲区，例如一个文件，但默认是打印到 \texttt{stdout}（控制台）。


\item \texttt{data}——包含你要分析的数据；默认情况下，它是从 \hyperlink{3578108280181558112}{\texttt{Profile.fetch()}} 中获取的，该函数从预先分配的缓冲区中拉出回溯。例如，如果你要分析性能分析器，可以说：


\begin{minted}{julia}
data = copy(Profile.fetch())
Profile.clear()
@profile Profile.print(stdout, data) # Prints the previous results
Profile.print()                      # Prints results from Profile.print()
\end{minted}

\end{itemize}


关键字参数可以是以下参数的任意组合：



\begin{itemize}
\item \texttt{format}——上文已经介绍，确定是使用（默认值，\texttt{:tree}）还是不使用（\texttt{:flat}）缩进来表示其树形结构。


\item \texttt{C}——如果为 \texttt{true}，则显示 C 和 Fortran 代码中的回溯（通常它们被排除在外）。请尝试用 \texttt{Profile.print(C = true)} 运行介绍性示例。这对于判断是 Julia 代码还是 C 代码导致了性能瓶颈非常有帮助；设置 \texttt{C = true} 也可提高嵌套的可解释性，代价是更长的性能分析转储。


\item \texttt{combine}——某些代码行包含多个操作；例如，\texttt{s += A[i]} 包含一个数组引用（\texttt{A[i]}）和一个求和操作。这些操作在所生成的机器代码中对应不同的行，因此回溯期间可能会在此行中捕获两个或以上地址。\texttt{combine = true} 把它们混合在一起，可能你通常想要这样，但使用 \texttt{combine = false}，你可为每个唯一的指令指针单独生成输出。


\item \texttt{maxdepth}——限制 \texttt{:tree} 格式中深度大于 \texttt{maxdepth} 的帧。


\item   * \texttt{sortedby}——控制 \texttt{:flat} 格式中的次序。为 \texttt{:filefuncline}（默认值）时按源代码行排序，而为 \texttt{:count} 时按收集的样本数排序。


\item \texttt{noisefloor}——限制低于样本的启发式噪音下限的帧（只适用于格式 \texttt{:tree}）。尝试此选项的建议值是 2.0（默认值是 0）。此参数会隐藏 \texttt{n <= noisefloor * √N} 的样本，其中 \texttt{n} 是该行上的样本数，\texttt{N} 是被调用者的样本数。


\item \texttt{mincount}——限制出现次数少于 \texttt{mincount} 的帧。

\end{itemize}


文件/函数名有时会被（用 \texttt{...}）截断，缩进也有可能在开头用 \texttt{+n} 截断，其中 \texttt{n} 是在空间充足的情况下应该插入的额外空格数。如果你想要深层嵌套代码的完整性能分析，保存到文件并在 \hyperlink{13454403377667762339}{\texttt{IOContext}} 中使用宽的 \texttt{displaysize} 通常是个好主意：




\begin{minted}{julia}
open("/tmp/prof.txt", "w") do s
    Profile.print(IOContext(s, :displaysize => (24, 500)))
end
\end{minted}



\hypertarget{5894887495287635363}{}


\section{配置}



\hyperlink{9691715859147716436}{\texttt{@profile}} 只是累积回溯，在你调用 \hyperlink{2955792207246042270}{\texttt{Profile.print()}} 时才会进行性能分析。对于长时间运行的计算，完全有可能把用于存储回溯的预分配缓冲区填满。如果发生这种情况，回溯会停止，但你的计算会继续。因此，你也许会丢失一些重要的性能分析数据（当发生这种情况时，你会受到警告）。



你可通过以下方式获取和配置相关参数：




\begin{minted}{julia}
Profile.init() # returns the current settings
Profile.init(n = 10^7, delay = 0.01)
\end{minted}



\texttt{n} 是能够存储的指令指针总数，默认值为 \texttt{10{\textasciicircum}6}。如果通常的回溯是 20 个指令指针，那么可以收集 50000 次回溯，这意味着统计不确定性少于 1\%。这对于大多数应用来说可能已经足够了。



因此，你更可能需要修改 \texttt{delay}，它以秒为单位，设置在快照之间 Julia 用于执行所请求计算的时长。长时间运行的工作可能不需要经常回溯。默认设置为 \texttt{delay = 0.001}。当然，你可以减少和增加 delay；但是，一旦 delay 接近执行一次回溯所需的时间（在作者的笔记本上约为 30 微妙），性能分析的开销就会增加。



\hypertarget{15664789060024554869}{}


\chapter{内存分配分析}



减少内存分配是提高性能的最常用技术之一。内存分配总量可以用 \hyperlink{8029752041511656628}{\texttt{@time}} 和 \hyperlink{5377755456008435782}{\texttt{@allocated}}，触发内存分配的特定行通常可以通过这些行产生的垃圾分配成本从性能分析中推断出来。但是，直接测量每行代码的内存分配总量有时会更高效。



为了逐行测量内存分配，启动 Julia 时请使用命令行选项 \texttt{--track-allocation=<setting>}，该选项的可选值有 \texttt{none}（默认值，不测量内存分配）、\texttt{user}（测量除 Julia core 代码之外的所有代码的内存分配）或 \texttt{all}（测量 Julia 代码中每一行的内存分配）。这会为每行已编译的代码测量内存。在退出 Julia 时，累积的结果将写入到文本文件中，此文本文件名称为该文件名称后加 \texttt{.mem}，并与源文件位于同一目录下。该文件的每行列出内存分配的总字节数。\href{https://github.com/JuliaCI/Coverage.jl}{\texttt{Coverage} 包}包括了一些基本分析工具，例如，按照内存分配的字节数对行进行排序的工具。



在解释结果时，有一些需要注意的细节。在 \texttt{user} 设定下，直接从 REPL 调用的任何函数的第一行都将会显示内存分配，这是由发生在 REPL 代码本身的事件造成的。更重要的是，JIT 编译也会添加内存分配计数，因为 Julia 的编译器大部分是用 Julia 编写的（并且编译通常需要内存分配）。建议的分析过程是先通过执行待分析的所有命令来强制编译，然后调用 \hyperlink{12697816172521511938}{\texttt{Profile.clear\_malloc\_data()}} 来重置所有内存计数器。最后，执行所需的命令并退出 Julia 以触发 \texttt{.mem} 文件的生成。



\hypertarget{7694373006850867155}{}


\chapter{外部性能分析}



Julia 目前支持的外部性能分析工具有 \texttt{Intel VTune}、\texttt{OProfile} 和 \texttt{perf}。



根据你所选择的工具，编译时请在 \texttt{Make.user} 中将 \texttt{USE\_INTEL\_JITEVENTS}、\texttt{USE\_OPROFILE\_JITEVENTS} 和 \texttt{USE\_PERF\_JITEVENTS} 设置为 1。多个上述编译标志是支持的。



在运行 Julia 前，请将环境变量 \texttt{ENABLE\_JITPROFILING} 设置为 1。



现在，你可以通过多种方式使用这些工具！例如，可以使用 \texttt{OProfile} 来尝试做个简单的记录：




\begin{lstlisting}
>ENABLE_JITPROFILING=1 sudo operf -Vdebug ./julia test/fastmath.jl
>opreport -l `which ./julia`
\end{lstlisting}



Or similary with \texttt{perf} :




\begin{lstlisting}
$ ENABLE_JITPROFILING=1 perf record -o /tmp/perf.data --call-graph dwarf ./julia /test/fastmath.jl
$ perf report --call-graph -G
\end{lstlisting}



你可以测量关于程序的更多有趣数据，若要获得详尽的列表，请阅读 \href{http://www.brendangregg.com/perf.html}{Linux perf 示例页面}。



请记住，perf 会为每次执行保存一个 \texttt{perf.data} 文件，即使对于小程序，它也可能变得非常大。此外，perf LLVM 模块会将调试对象保存在 \texttt{{\textasciitilde}/.debug/jit} 中，记得经常清理该文件夹。



\hypertarget{5468549229850022418}{}


\chapter{栈跟踪}



\texttt{StackTraces} 模块提供了简单的栈跟踪功能，这些栈跟踪信息既可读又易于编程使用。



\hypertarget{18224694583461024319}{}


\section{查看栈跟踪}



获取栈跟踪信息的主要函数是 \hyperlink{11964270650763140298}{\texttt{stacktrace}}：




\begin{minted}{jlcon}
6-element Array{Base.StackTraces.StackFrame,1}:
 top-level scope
 eval at boot.jl:317 [inlined]
 eval(::Module, ::Expr) at REPL.jl:5
 eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85
 macro expansion at REPL.jl:116 [inlined]
 (::getfield(REPL, Symbol("##28#29")){REPL.REPLBackend})() at event.jl:92
\end{minted}



调用 \hyperlink{11964270650763140298}{\texttt{stacktrace()}} 会返回一个 \hyperlink{16824886840215699957}{\texttt{StackTraces.StackFrame}} 数组。为了使用方便，可以用 \hyperlink{12289172590874430030}{\texttt{StackTraces.StackTrace}} 来代替 \texttt{Vector\{StackFrame\}}。下面例子中 \texttt{[...]} 的意思是这部分输出的内容可能会根据代码的实际执行情况而定。




\begin{minted}{jlcon}
julia> example() = stacktrace()
example (generic function with 1 method)

julia> example()
7-element Array{Base.StackTraces.StackFrame,1}:
 example() at REPL[1]:1
 top-level scope
 eval at boot.jl:317 [inlined]
[...]

julia> @noinline child() = stacktrace()
child (generic function with 1 method)

julia> @noinline parent() = child()
parent (generic function with 1 method)

julia> grandparent() = parent()
grandparent (generic function with 1 method)

julia> grandparent()
9-element Array{Base.StackTraces.StackFrame,1}:
 child() at REPL[3]:1
 parent() at REPL[4]:1
 grandparent() at REPL[5]:1
[...]
\end{minted}



注意，在调用 \hyperlink{11964270650763140298}{\texttt{stacktrace()}} 的时，通常会出现 \texttt{eval at boot.jl} 这帧。 当从 REPL 里调用 \hyperlink{11964270650763140298}{\texttt{stacktrace()}} 的时候，还会显示 \texttt{REPL.jl} 里的一些额外帧，就像下面一样：




\begin{minted}{jlcon}
julia> example() = stacktrace()
example (generic function with 1 method)

julia> example()
7-element Array{Base.StackTraces.StackFrame,1}:
 example() at REPL[1]:1
 top-level scope
 eval at boot.jl:317 [inlined]
 eval(::Module, ::Expr) at REPL.jl:5
 eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85
 macro expansion at REPL.jl:116 [inlined]
 (::getfield(REPL, Symbol("##28#29")){REPL.REPLBackend})() at event.jl:92
\end{minted}



\hypertarget{17184729199221037868}{}


\section{抽取有用信息}



每个 \hyperlink{16824886840215699957}{\texttt{StackTraces.StackFrame}} 都会包含函数名，文件名，代码行数，lambda 信息，一个用于确认此帧是否被内联的标帜，一个用于确认函数是否为 C 函数的标帜（在默认的情况下 C 函数不会出现在栈跟踪信息中）以及一个用整数表示的指针，它是由 \hyperlink{6187626674327343338}{\texttt{backtrace}} 返回的：




\begin{minted}{jlcon}
julia> frame = stacktrace()[3]
eval(::Module, ::Expr) at REPL.jl:5

julia> frame.func
:eval

julia> frame.file
Symbol("~/julia/usr/share/julia/stdlib/v0.7/REPL/src/REPL.jl")

julia> frame.line
5

julia> top_frame.linfo
MethodInstance for eval(::Module, ::Expr)

julia> top_frame.inlined
false

julia> top_frame.from_c
false
\end{minted}




\begin{minted}{jlcon}
julia> top_frame.pointer
0x00007f92d6293171
\end{minted}



这使得我们可以通过编程的方式将栈跟踪信息用于打印日志，处理错误以及其它更多用途。



\hypertarget{6556726272179975372}{}


\section{错误处理}



能够轻松地获取当前调用栈的状态信息在许多场景下都很有用，但最直接的应用是错误处理和调试。




\begin{minted}{jlcon}
julia> @noinline bad_function() = undeclared_variable
bad_function (generic function with 1 method)

julia> @noinline example() = try
           bad_function()
       catch
           stacktrace()
       end
example (generic function with 1 method)

julia> example()
7-element Array{Base.StackTraces.StackFrame,1}:
 example() at REPL[2]:4
 top-level scope
 eval at boot.jl:317 [inlined]
[...]
\end{minted}



你可能已经注意到了，上述例子中第一个栈帧指向了 \hyperlink{11964270650763140298}{\texttt{stacktrace}} 被调用的第 4 行，而不是 \texttt{bad\_function} 被调用的第 2 行，且完全没有出现 \texttt{bad\_function} 的栈帧。这是也是可以理解的，因为 \hyperlink{11964270650763140298}{\texttt{stacktrace}} 是在 \texttt{catch} 的上下文中被调用的。虽然在这个例子中很容易查找到错误的真正源头，但在复杂的情况下查找错误源并不是一件容易的事。



为了补救，我们可以将 \hyperlink{98342946516168163}{\texttt{catch\_backtrace}} 的输出传递给 \hyperlink{11964270650763140298}{\texttt{stacktrace}}。\hyperlink{98342946516168163}{\texttt{catch\_backtrace}} 会返回最近发生异常的上下文中的栈信息，而不是返回当前上下文中的调用栈信息。




\begin{minted}{jlcon}
julia> @noinline bad_function() = undeclared_variable
bad_function (generic function with 1 method)

julia> @noinline example() = try
           bad_function()
       catch
           stacktrace(catch_backtrace())
       end
example (generic function with 1 method)

julia> example()
8-element Array{Base.StackTraces.StackFrame,1}:
 bad_function() at REPL[1]:1
 example() at REPL[2]:2
[...]
\end{minted}



可以看到，现在栈跟踪会显示正确的行号以及之前缺失的栈帧。




\begin{minted}{jlcon}
julia> @noinline child() = error("Whoops!")
child (generic function with 1 method)

julia> @noinline parent() = child()
parent (generic function with 1 method)

julia> @noinline function grandparent()
           try
               parent()
           catch err
               println("ERROR: ", err.msg)
               stacktrace(catch_backtrace())
           end
       end
grandparent (generic function with 1 method)

julia> grandparent()
ERROR: Whoops!
10-element Array{Base.StackTraces.StackFrame,1}:
 error at error.jl:33 [inlined]
 child() at REPL[1]:1
 parent() at REPL[2]:1
 grandparent() at REPL[3]:3
[...]
\end{minted}



\hypertarget{11791934492396691703}{}


\section{异常栈与\texttt{catch\_stack}}



\begin{quote}
\textbf{Julia 1.1}

异常栈需要 Julia 1.1 及以上版本。

\end{quote}


在处理一个异常时，后续的异常同样可能被抛出。观察这些异常对定位问题的源头极有帮助。Julia runtime 支持将每个异常发生后推入一个内部的\emph{异常栈}。当代码正常退出一个\texttt{catch}语句，可认为所有被推入栈中的异常在相应的\texttt{try}语句中被成功处理并已从栈中移除。



存放当前异常的栈可通过测试函数 \hyperlink{5950075931444385711}{\texttt{Base.catch\_stack}} 获取，例如




\begin{minted}{jlcon}
julia> try
           error("(A) The root cause")
       catch
           try
               error("(B) An exception while handling the exception")
           catch
               for (exc, bt) in Base.catch_stack()
                   showerror(stdout, exc, bt)
                   println()
               end
           end
       end
(A) The root cause
Stacktrace:
 [1] error(::String) at error.jl:33
 [2] top-level scope at REPL[7]:2
 [3] eval(::Module, ::Any) at boot.jl:319
 [4] eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85
 [5] macro expansion at REPL.jl:117 [inlined]
 [6] (::getfield(REPL, Symbol("##26#27")){REPL.REPLBackend})() at task.jl:259
(B) An exception while handling the exception
Stacktrace:
 [1] error(::String) at error.jl:33
 [2] top-level scope at REPL[7]:5
 [3] eval(::Module, ::Any) at boot.jl:319
 [4] eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85
 [5] macro expansion at REPL.jl:117 [inlined]
 [6] (::getfield(REPL, Symbol("##26#27")){REPL.REPLBackend})() at task.jl:259
\end{minted}



在本例中，根源异常（A）排在栈头，其后放置着延伸异常（B)。 在正常退出（例如，不抛出新异常）两个 catch 块后，所有异常都被移除出栈，无法访问。



异常栈被存放于发生异常的 \texttt{Task} 处。当某个任务失败，出现意料外的异常时，\texttt{catch\_stack(task)} 可能会被用于观察该任务的异常栈。



\hypertarget{9581632785664784530}{}


\section{\texttt{stacktrace} 与 \texttt{backtrace} 的比较}



调用 \hyperlink{6187626674327343338}{\texttt{backtrace}} 会返回一个 \texttt{Union\{Ptr\{Nothing\}, Base.InterpreterIP\}} 的数组，可以将其传给 \hyperlink{11964270650763140298}{\texttt{stacktrace}} 函数进行转化：




\begin{minted}{jlcon}
julia> trace = backtrace()
18-element Array{Union{Ptr{Nothing}, Base.InterpreterIP},1}:
 Ptr{Nothing} @0x00007fd8734c6209
 Ptr{Nothing} @0x00007fd87362b342
 Ptr{Nothing} @0x00007fd87362c136
 Ptr{Nothing} @0x00007fd87362c986
 Ptr{Nothing} @0x00007fd87362d089
 Base.InterpreterIP(CodeInfo(:(begin
      Core.SSAValue(0) = backtrace()
      trace = Core.SSAValue(0)
      return Core.SSAValue(0)
  end)), 0x0000000000000000)
 Ptr{Nothing} @0x00007fd87362e4cf
[...]

julia> stacktrace(trace)
6-element Array{Base.StackTraces.StackFrame,1}:
 top-level scope
 eval at boot.jl:317 [inlined]
 eval(::Module, ::Expr) at REPL.jl:5
 eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85
 macro expansion at REPL.jl:116 [inlined]
 (::getfield(REPL, Symbol("##28#29")){REPL.REPLBackend})() at event.jl:92
\end{minted}



需要注意的是，\hyperlink{6187626674327343338}{\texttt{backtrace}} 返回的向量有 18 个元素，而 \hyperlink{11964270650763140298}{\texttt{stacktrace}} 返回的向量只包含6 个元素。这是因为 \hyperlink{11964270650763140298}{\texttt{stacktrace}} 在默认情况下会移除所有底层 C 函数的栈信息。如果你想显示 C 函数调用的栈帧，可以这样做：




\begin{minted}{jlcon}
julia> stacktrace(trace, true)
21-element Array{Base.StackTraces.StackFrame,1}:
 jl_apply_generic at gf.c:2167
 do_call at interpreter.c:324
 eval_value at interpreter.c:416
 eval_body at interpreter.c:559
 jl_interpret_toplevel_thunk_callback at interpreter.c:798
 top-level scope
 jl_interpret_toplevel_thunk at interpreter.c:807
 jl_toplevel_eval_flex at toplevel.c:856
 jl_toplevel_eval_in at builtins.c:624
 eval at boot.jl:317 [inlined]
 eval(::Module, ::Expr) at REPL.jl:5
 jl_apply_generic at gf.c:2167
 eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85
 jl_apply_generic at gf.c:2167
 macro expansion at REPL.jl:116 [inlined]
 (::getfield(REPL, Symbol("##28#29")){REPL.REPLBackend})() at event.jl:92
 jl_fptr_trampoline at gf.c:1838
 jl_apply_generic at gf.c:2167
 jl_apply at julia.h:1540 [inlined]
 start_task at task.c:268
 ip:0xffffffffffffffff
\end{minted}



\hyperlink{6187626674327343338}{\texttt{backtrace}} 返回的单个指针可以通过 \hyperlink{1451426077045795515}{\texttt{StackTraces.lookup}} 来转化成一组 \hyperlink{16824886840215699957}{\texttt{StackTraces.StackFrame}}：




\begin{minted}{jlcon}
julia> pointer = backtrace()[1];

julia> frame = StackTraces.lookup(pointer)
1-element Array{Base.StackTraces.StackFrame,1}:
 jl_apply_generic at gf.c:2167

julia> println("The top frame is from $(frame[1].func)!")
The top frame is from jl_apply_generic!
\end{minted}



\hypertarget{3908315974291496321}{}


\chapter{性能建议}



下面几节简要地介绍了一些使 Julia 代码运行得尽可能快的技巧。



\hypertarget{14492220707033250800}{}


\section{避免全局变量}



全局变量的值和类型随时都会发生变化， 这使编译器难以优化使用全局变量的代码。 变量应该是局部的，或者尽可能作为参数传递给函数。



任何注重性能或者需要测试性能的代码都应该被放置在函数之中。



我们发现全局变量经常是常量，将它们声明为常量可大幅提升性能。




\begin{minted}{julia}
const DEFAULT_VAL = 0
\end{minted}



对于非常量的全局变量可以通过在使用的时候标注它们的类型来优化。




\begin{minted}{julia}
global x = rand(1000)

function loop_over_global()
    s = 0.0
    for i in x::Vector{Float64}
        s += i
    end
    return s
end
\end{minted}



一个更好的编程风格是将变量作为参数传给函数。这样可以使得代码更易复用，以及清晰的展示函数的输入和输出。



\begin{quote}
\textbf{Note}

All code in the REPL is evaluated in global scope, so a variable defined and assigned at top level will be a \textbf{global} variable. Variables defined at top level scope inside modules are also global.

\end{quote}


在下面的REPL会话中：




\begin{minted}{jlcon}
julia> x = 1.0
\end{minted}



等价于：




\begin{minted}{jlcon}
julia> global x = 1.0
\end{minted}



因此，所有上文关于性能问题的讨论都适用于它们。



\hypertarget{1547856480373223464}{}


\section{使用 \texttt{@time}评估性能以及注意内存分配}



\hyperlink{8029752041511656628}{\texttt{@time}} 宏是一个有用的性能评估工具。这里我们将重复上面全局变量的例子，但是这次移除类型声明：




\begin{minted}{jlcon}
julia> x = rand(1000);

julia> function sum_global()
           s = 0.0
           for i in x
               s += i
           end
           return s
       end;

julia> @time sum_global()
  0.017705 seconds (15.28 k allocations: 694.484 KiB)
496.84883432553846

julia> @time sum_global()
  0.000140 seconds (3.49 k allocations: 70.313 KiB)
496.84883432553846
\end{minted}



在第一次调用函数(\texttt{@time sum\_global()})的时候，它会被编译。如果你这次会话中还没有使用过\hyperlink{8029752041511656628}{\texttt{@time}}，这时也会编译计时需要的相关函数。你不必认真对待这次运行的结果。接下来看第二次运行，除了运行的耗时以外，它还表明了分配了大量的内存。我们这里仅仅是计算了一个64位浮点向量元素和，因此这里应该没有申请内存的必要（至少不用在\texttt{@time}报告的堆上申请内存）。



未被预料的内存分配往往说明你的代码中存在一些问题，这些问题常常是由于类型的稳定性或者创建了太多临时的小数组。因此，除了分配内存本身，这也很可能说明你所写的函数远没有生成性能良好的代码。认真对待这些现象，遵循接下来的建议。



如果你换成将\texttt{x}作为参数传给函数，就可以避免内存的分配（这里报告的内存分配是由于在全局作用域中运行\texttt{@time}导致的），而且在第一次运行之后运行速度也会得到显著的提高。




\begin{minted}{jlcon}
julia> x = rand(1000);

julia> function sum_arg(x)
           s = 0.0
           for i in x
               s += i
           end
           return s
       end;

julia> @time sum_arg(x)
  0.007701 seconds (821 allocations: 43.059 KiB)
496.84883432553846

julia> @time sum_arg(x)
  0.000006 seconds (5 allocations: 176 bytes)
496.84883432553846
\end{minted}



这里出现的5个内存分配是由于在全局作用域中运行\texttt{@time}宏导致的。如果我们在函数内运行时间测试，我们将发现事实上并没有发生任何内存分配。




\begin{minted}{jlcon}
julia> time_sum(x) = @time sum_arg(x);

julia> time_sum(x)
  0.000001 seconds
496.84883432553846
\end{minted}



In some situations, your function may need to allocate memory as part of its operation, and this can complicate the simple picture above. In such cases, consider using one of the \hyperlink{11178925956438684264}{tools} below to diagnose problems, or write a version of your function that separates allocation from its algorithmic aspects (see \href{@ref}{Pre-allocating outputs}).



\begin{quote}
\textbf{Note}

For more serious benchmarking, consider the \href{https://github.com/JuliaCI/BenchmarkTools.jl}{BenchmarkTools.jl} package which among other things evaluates the function multiple times in order to reduce noise.

\end{quote}


\hypertarget{14350444000650775715}{}


\section{Tools}



Julia and its package ecosystem includes tools that may help you diagnose problems and improve the performance of your code:



\begin{itemize}
\item \href{@ref}{Profiling} allows you to measure the performance of your running code and identify lines that serve as bottlenecks. For complex projects, the \href{https://github.com/timholy/ProfileView.jl}{ProfileView} package can help you visualize your profiling results.


\item The \href{https://github.com/JunoLab/Traceur.jl}{Traceur} package can help you find common performance problems in your code.


\item Unexpectedly-large memory allocations–as reported by \hyperlink{8029752041511656628}{\texttt{@time}}, \hyperlink{5377755456008435782}{\texttt{@allocated}}, or the profiler (through calls to the garbage-collection routines)–hint that there might be issues with your code. If you don{\textquotesingle}t see another reason for the allocations, suspect a type problem.  You can also start Julia with the \texttt{--track-allocation=user} option and examine the resulting \texttt{*.mem} files to see information about where those allocations occur. See \href{@ref}{Memory allocation analysis}.


\item \texttt{@code\_warntype} generates a representation of your code that can be helpful in finding expressions that result in type uncertainty. See \hyperlink{8092893264277772840}{\texttt{@code\_warntype}} below.

\end{itemize}


\hypertarget{12159424404022697469}{}


\section{Avoid containers with abstract type parameters}



When working with parameterized types, including arrays, it is best to avoid parameterizing with abstract types where possible.



Consider the following:




\begin{minted}{jlcon}
julia> a = Real[]
Real[]

julia> push!(a, 1); push!(a, 2.0); push!(a, π)
3-element Array{Real,1}:
 1
 2.0
 π = 3.1415926535897...
\end{minted}



因为\texttt{a}是一个抽象类型\hyperlink{6175959395021454412}{\texttt{Real}}的数组，它必须能容纳任何一个\texttt{Real}值。因为\texttt{Real}对象可以有任意的大小和结构，\texttt{a}必须用指针的数组来表示，以便能独立地为\texttt{Real}对象进行内存分配。但是如果我们只允许同样类型的数，比如\hyperlink{5027751419500983000}{\texttt{Float64}}，才能存在\texttt{a}中，它们就能被更有效率地存储：




\begin{minted}{jlcon}
julia> a = Float64[]
Float64[]

julia> push!(a, 1); push!(a, 2.0); push!(a,  π)
3-element Array{Float64,1}:
 1.0
 2.0
 3.141592653589793
\end{minted}



把数字赋值给\texttt{a}会即时将数字转换成\texttt{Float64}并且\texttt{a}会按照64位浮点数值的连续的块来储存，这就能高效地处理。



也请参见在\hyperlink{5603543911318150609}{参数类型}下的讨论。



\hypertarget{11271598028486730305}{}


\section{类型声明}



在有可选类型声明的语言中，添加声明是使代码运行更快的原则性方法。在Julia中\emph{并不是}这种情况。在Julia中，编译器都知道所有的函数参数，局部变量和表达式的类型。但是，有一些特殊的情况下声明是有帮助的。



\hypertarget{17004910976199348766}{}


\subsection{避免有抽象类型的字段}



类型能在不指定其字段的类型的情况下被声明：




\begin{minted}{jlcon}
julia> struct MyAmbiguousType
           a
       end
\end{minted}



这就允许\texttt{a}可以是任意类型。这经常很有用，但是有个缺点：对于类型\texttt{MyAmbiguousType}的对象，编译器不能够生成高性能的代码。原因是编译器使用对象的类型，而非值，来确定如何构建代码。不幸的是，几乎没有信息可以从类型\texttt{MyAmbiguousType}的对象中推导出来：




\begin{minted}{jlcon}
julia> b = MyAmbiguousType("Hello")
MyAmbiguousType("Hello")

julia> c = MyAmbiguousType(17)
MyAmbiguousType(17)

julia> typeof(b)
MyAmbiguousType

julia> typeof(c)
MyAmbiguousType
\end{minted}



\texttt{b} 和 \texttt{c} 的值具有相同类型，但它们在内存中的数据的底层表示十分不同。即使你只在字段 \texttt{a} 中存储数值，\hyperlink{6609065134969660118}{\texttt{UInt8}} 的内存表示与 \hyperlink{5027751419500983000}{\texttt{Float64}} 也是不同的，这也意味着 CPU 需要使用两种不同的指令来处理它们。因为该类型中不提供所需的信息，所以必须在运行时进行这些判断。而这会降低性能。



通过声明 \texttt{a} 的类型，你能够做得更好。这里我们关注 \texttt{a} 可能是几种类型中任意一种的情况，在这种情况下，自然的一个解决方法是使用参数。例如：




\begin{minted}{jlcon}
julia> mutable struct MyType{T<:AbstractFloat}
           a::T
       end
\end{minted}



比下面这种更好




\begin{minted}{jlcon}
julia> mutable struct MyStillAmbiguousType
           a::AbstractFloat
       end
\end{minted}



因为第一种通过包装对象的类型指定了 \texttt{a} 的类型。 例如：




\begin{minted}{jlcon}
julia> m = MyType(3.2)
MyType{Float64}(3.2)

julia> t = MyStillAmbiguousType(3.2)
MyStillAmbiguousType(3.2)

julia> typeof(m)
MyType{Float64}

julia> typeof(t)
MyStillAmbiguousType
\end{minted}



字段 \texttt{a} 的类型可以很容易地通过 \texttt{m} 的类型确定，而不是通过 \texttt{t} 的类型确定。事实上，在 \texttt{t} 中是可以改变字段 \texttt{a} 的类型的：




\begin{minted}{jlcon}
julia> typeof(t.a)
Float64

julia> t.a = 4.5f0
4.5f0

julia> typeof(t.a)
Float32
\end{minted}



反之，一旦 \texttt{m} 被构建出来，\texttt{m.a} 的类型就不能够更改了。




\begin{minted}{jlcon}
julia> m.a = 4.5f0
4.5f0

julia> typeof(m.a)
Float64
\end{minted}



\texttt{m.a} 的类型是通过 \texttt{m} 的类型得知这一事实加上它的类型不能改变在函数中改变这一事实，这两者使得对于像 \texttt{m} 这样的对象编译器可以生成高度优化后的代码，但是对 \texttt{t} 这样的对象却不可以。 当然，如果我们将 \texttt{m} 构造成一个具体类型，那么这两者都可以。我们可以通过明确地使用一个抽象类型去构建它来破坏这一点：




\begin{minted}{jlcon}
julia> m = MyType{AbstractFloat}(3.2)
MyType{AbstractFloat}(3.2)

julia> typeof(m.a)
Float64

julia> m.a = 4.5f0
4.5f0

julia> typeof(m.a)
Float32
\end{minted}



对于一个实际的目的来说，这样的对象表现起来和那些 \texttt{MyStillAmbiguousType} 的对象一模一样。



比较为一个简单函数生成的代码的绝对数量是十分有指导意义的，




\begin{minted}{julia}
func(m::MyType) = m.a+1
\end{minted}



使用




\begin{minted}{julia}
code_llvm(func, Tuple{MyType{Float64}})
code_llvm(func, Tuple{MyType{AbstractFloat}})
\end{minted}



由于长度的原因，代码的结果没有在这里显示出来，但是你可能会希望自己去验证这一点。因为在第一种情况中，类型被完全指定了，在运行时，编译器不需要生成任何代码来决定类型。这就带来了更短和更快的代码。



\hypertarget{1665323452340421493}{}


\subsection{避免使用带抽象容器的字段}



上面的做法同样也适用于容器的类型：




\begin{minted}{jlcon}
julia> struct MySimpleContainer{A<:AbstractVector}
           a::A
       end

julia> struct MyAmbiguousContainer{T}
           a::AbstractVector{T}
       end
\end{minted}



例如:




\begin{minted}{jlcon}
julia> c = MySimpleContainer(1:3);

julia> typeof(c)
MySimpleContainer{UnitRange{Int64}}

julia> c = MySimpleContainer([1:3;]);

julia> typeof(c)
MySimpleContainer{Array{Int64,1}}

julia> b = MyAmbiguousContainer(1:3);

julia> typeof(b)
MyAmbiguousContainer{Int64}

julia> b = MyAmbiguousContainer([1:3;]);

julia> typeof(b)
MyAmbiguousContainer{Int64}
\end{minted}



对于 \texttt{MySimpleContainer} 来说，它被它的类型和参数完全确定了，因此编译器能够生成优化过的代码。在大多数实例中，这点能够实现。



尽管编译器现在可以将它的工作做得非常好，但是还是有\textbf{你}可能希望你的代码能够能够根据 \texttt{a} 的\textbf{元素类型}做不同的事情的时候。通常达成这个目的最好的方式是将你的具体操作 (here, \texttt{foo}) 打包到一个独立的函数中。




\begin{minted}{jlcon}
julia> function sumfoo(c::MySimpleContainer)
           s = 0
           for x in c.a
               s += foo(x)
           end
           s
       end
sumfoo (generic function with 1 method)

julia> foo(x::Integer) = x
foo (generic function with 1 method)

julia> foo(x::AbstractFloat) = round(x)
foo (generic function with 2 methods)
\end{minted}



这使事情变得简单，同时也允许编译器在所有情况下生成经过优化的代码。



但是，在某些情况下，你可能需要声明外部函数的不同版本，这可能是为了不同的元素类型，也可能是为了 \texttt{MySimpleContainer} 中的字段 \texttt{a} 所具有的不同 \texttt{AbstractVector} 类型。你可以这样做：




\begin{minted}{jlcon}
julia> function myfunc(c::MySimpleContainer{<:AbstractArray{<:Integer}})
           return c.a[1]+1
       end
myfunc (generic function with 1 method)

julia> function myfunc(c::MySimpleContainer{<:AbstractArray{<:AbstractFloat}})
           return c.a[1]+2
       end
myfunc (generic function with 2 methods)

julia> function myfunc(c::MySimpleContainer{Vector{T}}) where T <: Integer
           return c.a[1]+3
       end
myfunc (generic function with 3 methods)
\end{minted}




\begin{minted}{jlcon}
julia> myfunc(MySimpleContainer(1:3))
2

julia> myfunc(MySimpleContainer(1.0:3))
3.0

julia> myfunc(MySimpleContainer([1:3;]))
4
\end{minted}



\hypertarget{18349216047452588444}{}


\subsection{对从无类型位置获取的值进行类型注释}



使用可能包含任何类型的值的数据结构（如类型为 \texttt{Array\{Any\}} 的数组）经常是很方便的。但是，如果你正在使用这些数据结构之一，并且恰巧知道某个元素的类型，那么让编译器也知道这一点会有所帮助：




\begin{minted}{julia}
function foo(a::Array{Any,1})
    x = a[1]::Int32
    b = x+1
    ...
end
\end{minted}



在这里，我们恰巧知道 \texttt{a} 的第一个元素是个 \hyperlink{10103694114785108551}{\texttt{Int32}}。留下这样的注释还有另外的好处，它将在该值不是预期类型时引发运行时错误，而这可能会更早地捕获某些错误。



在没有确切知道 \texttt{a[1]} 的类型的情况下，\texttt{x} 可以通过 \texttt{x = convert(Int32, a[1])::Int32} 来声明。使用 \hyperlink{1846942650946171605}{\texttt{convert}} 函数则允许 \texttt{a[1]} 是可转换为 \texttt{Int32} 的任何对象（比如 \texttt{UInt8}），从而通过放松类型限制来提高代码的通用性。请注意，\texttt{convert} 本身在此上下文中需要类型注释才能实现类型稳定性。这是因为除非该函数所有参数的类型都已知，否则编译器无法推导出该函数返回值的类型，即使其为 \texttt{convert}。



如果类型注释中的类型是在运行时构造的，那么类型注释不会增强（并且实际上可能会降低）性能。这是因为编译器无法使用该类型注释来专门化代码，而类型检查本身又需要时间。例如，在以下代码中：




\begin{minted}{julia}
function nr(a, prec)
    ctype = prec == 32 ? Float32 : Float64
    b = Complex{ctype}(a)
    c = (b + 1.0f0)::Complex{ctype}
    abs(c)
end
\end{minted}



the annotation of \texttt{c} harms performance. To write performant code involving types constructed at run-time, use the \hyperlink{17509985600836810807}{function-barrier technique} discussed below, and ensure that the constructed type appears among the argument types of the kernel function so that the kernel operations are properly specialized by the compiler. For example, in the above snippet, as soon as \texttt{b} is constructed, it can be passed to another function \texttt{k}, the kernel. If, for example, function \texttt{k} declares \texttt{b} as an argument of type \texttt{Complex\{T\}}, where \texttt{T} is a type parameter, then a type annotation appearing in an assignment statement within \texttt{k} of the form:




\begin{minted}{julia}
c = (b + 1.0f0)::Complex{T}
\end{minted}



不会降低性能（但也不会提高），因为编译器可以在编译 \texttt{k} 时确定 \texttt{c} 的类型。



\hypertarget{13987935381679254535}{}


\subsection{Be aware of when Julia avoids specializing}



As a heuristic, Julia avoids automatically specializing on argument type parameters in three specific cases: \texttt{Type}, \texttt{Function}, and \texttt{Vararg}. Julia will always specialize when the argument is used within the method, but not if the argument is just passed through to another function. This usually has no performance impact at runtime and \hyperlink{14494557220692677892}{improves compiler performance}. If you find it does have a performance impact at runtime in your case, you can trigger specialization by adding a type parameter to the method declaration. Here are some examples:



This will not specialize:




\begin{minted}{julia}
function f_type(t)  # or t::Type
    x = ones(t, 10)
    return sum(map(sin, x))
end
\end{minted}



but this will:




\begin{minted}{julia}
function g_type(t::Type{T}) where T
    x = ones(T, 10)
    return sum(map(sin, x))
end
\end{minted}



These will not specialize:




\begin{minted}{julia}
f_func(f, num) = ntuple(f, div(num, 2))
g_func(g::Function, num) = ntuple(g, div(num, 2))
\end{minted}



but this will:




\begin{minted}{julia}
h_func(h::H, num) where {H} = ntuple(h, div(num, 2))
\end{minted}



This will not specialize:




\begin{minted}{julia}
f_vararg(x::Int...) = tuple(x...)
\end{minted}



but this will:




\begin{minted}{julia}
g_vararg(x::Vararg{Int, N}) where {N} = tuple(x...)
\end{minted}



One only needs to introduce a single type parameter to force specialization, even if the other types are unconstrained. For example, this will also specialize, and is useful when the arguments are not all of the same type:




\begin{minted}{julia}
h_vararg(x::Vararg{Any, N}) where {N} = tuple(x...)
\end{minted}



Note that \hyperlink{6823997547688846780}{\texttt{@code\_typed}} and friends will always show you specialized code, even if Julia would not normally specialize that method call. You need to check the \hyperlink{5484310955311811443}{method internals} if you want to see whether specializations are generated when argument types are changed, i.e., if \texttt{(@which f(...)).specializations} contains specializations for the argument in question.



\hypertarget{5154687489987486672}{}


\section{将函数拆分为多个定义}



将一个函数写成许多小的定义能让编译器直接调用最适合的代码，甚至能够直接将它内联。



这是一个真的该被写成许多小的定义的\textbf{复合函数}的例子：




\begin{minted}{julia}
using LinearAlgebra

function mynorm(A)
    if isa(A, Vector)
        return sqrt(real(dot(A,A)))
    elseif isa(A, Matrix)
        return maximum(svdvals(A))
    else
        error("mynorm: invalid argument")
    end
end
\end{minted}



这可以更简洁有效地写成：




\begin{minted}{julia}
norm(x::Vector) = sqrt(real(dot(x, x)))
norm(A::Matrix) = maximum(svdvals(A))
\end{minted}



然而，应该注意的是，编译器会十分高效地优化掉编写得如同 \texttt{mynorm} 例子的代码中的死分支。



\hypertarget{11831339210471490014}{}


\section{编写「类型稳定的」函数}



如果可能，确保函数总是返回相同类型的值是有好处的。考虑以下定义：




\begin{minted}{julia}
pos(x) = x < 0 ? 0 : x
\end{minted}



虽然这看起来挺合法的，但问题是 \texttt{0} 是一个（\texttt{Int} 类型的）整数而 \texttt{x} 可能是任何类型。于是，根据 \texttt{x} 的值，此函数可能返回两种类型中任何一种的值。这种行为是允许的，并且在某些情况下可能是合乎需要的。但它可以很容易地以如下方式修复：




\begin{minted}{julia}
pos(x) = x < 0 ? zero(x) : x
\end{minted}



还有 \hyperlink{2310843180104103470}{\texttt{oneunit}} 函数，以及更通用的 \hyperlink{374166931194490566}{\texttt{oftype(x, y)}} 函数，它返回被转换为 \texttt{x} 的类型的 \texttt{y}。



\hypertarget{6976604449962643011}{}


\section{避免更改变量类型}



类似的「类型稳定性」问题存在于在函数内重复使用的变量：




\begin{minted}{julia}
function foo()
    x = 1
    for i = 1:10
        x /= rand()
    end
    return x
end
\end{minted}



局部变量 \texttt{x} 一开始是整数，在一次循环迭代后变为浮点数（\hyperlink{4103478871488785445}{\texttt{/}} 运算符的结果）。这使得编译器更难优化循环体。有几种可能的解决方法：



\begin{itemize}
\item 使用 \texttt{x = 1.0} 初始化 \texttt{x}


\item Declare the type of \texttt{x} explicitly as \texttt{x::Float64 = 1}


\item Use an explicit conversion by \texttt{x = oneunit(Float64)}


\item 使用第一个循环迭代初始化，即 \texttt{x = 1 / rand()}，接着循环 \texttt{for i = 2:10}

\end{itemize}


\hypertarget{16258602729394793584}{}


\section{Separate kernel functions (aka, function barriers)}



许多函数遵循这一模式：先执行一些设置工作，再通过多次迭代来执行核心计算。如果可行，将这些核心计算放在单独的函数中是个好主意。例如，以下做作的函数返回一个数组，其类型是随机选择的。




\begin{minted}{jlcon}
julia> function strange_twos(n)
           a = Vector{rand(Bool) ? Int64 : Float64}(undef, n)
           for i = 1:n
               a[i] = 2
           end
           return a
       end;

julia> strange_twos(3)
3-element Array{Float64,1}:
 2.0
 2.0
 2.0
\end{minted}



这应该写作：




\begin{minted}{jlcon}
julia> function fill_twos!(a)
           for i = eachindex(a)
               a[i] = 2
           end
       end;

julia> function strange_twos(n)
           a = Vector{rand(Bool) ? Int64 : Float64}(undef, n)
           fill_twos!(a)
           return a
       end;

julia> strange_twos(3)
3-element Array{Float64,1}:
 2.0
 2.0
 2.0
\end{minted}



Julia 的编译器会在函数边界处针对参数类型特化代码，因此在原始的实现中循环期间无法得知 \texttt{a} 的类型（因为它是随即选择的）。于是，第二个版本通常更快，因为对于不同类型的 \texttt{a}，内层循环都可被重新编译为 \texttt{fill\_twos!} 的一部分。



第二种形式通常是更好的风格，并且可以带来更多的代码的重复利用。



这个模式在 Julia Base 的几个地方中有使用。相关的例子，请参阅 \href{https://github.com/JuliaLang/julia/blob/40fe264f4ffaa29b749bcf42239a89abdcbba846/base/abstractarray.jl\#L1205-L1206}{\texttt{abstractarray.jl}} 中的 \texttt{vcat} 和 \texttt{hcat}，或者 \hyperlink{5162290739791026948}{\texttt{fill!}} 函数，我们可使用该函数而不是编写自己的 \texttt{fill\_twos!}。



诸如 \texttt{strange\_twos} 的函数会在处理具有不确定类型的数据时出现，例如从可能包含整数、浮点数、字符串或其它内容的输入文件中加载的数据。



\hypertarget{13298146121388666827}{}


\section{Types with values-as-parameters}



比方说你想创建一个每个维度大小都是3的 \texttt{N} 维数组。这种数组可以这样创建：




\begin{minted}{jlcon}
julia> A = fill(5.0, (3, 3))
3×3 Array{Float64,2}:
 5.0  5.0  5.0
 5.0  5.0  5.0
 5.0  5.0  5.0
\end{minted}



这个方法工作得很好：编译器可以识别出来 \texttt{A} 是一个 \texttt{Array\{Float64,2\}} 因为它知道填充值 (\texttt{5.0::Float64}) 的类型和维度 (\texttt{(3, 3)::NTuple\{2,Int\}}).



但是现在打比方说你想写一个函数，在任何一个维度下，它都创建一个 3×3×... 的数组；你可能会心动地写下一个函数




\begin{minted}{jlcon}
julia> function array3(fillval, N)
           fill(fillval, ntuple(d->3, N))
       end
array3 (generic function with 1 method)

julia> array3(5.0, 2)
3×3 Array{Float64,2}:
 5.0  5.0  5.0
 5.0  5.0  5.0
 5.0  5.0  5.0
\end{minted}



这确实有用，但是（你可以自己使用 \texttt{@code\_warntype array3(5.0, 2)} 来验证）问题是输出地类型不能被推断出来：参数 \texttt{N} 是一个 \texttt{Int} 类型的\textbf{值}，而且类型推断不会（也不能）提前预测它的值。这意味着使用这个函数的结果的代码在每次获取 \texttt{A} 时都不得不保守地检查其类型；这样的代码将会是非常缓慢的。



Now, one very good way to solve such problems is by using the \hyperlink{17509985600836810807}{function-barrier technique}. However, in some cases you might want to eliminate the type-instability altogether. In such cases, one approach is to pass the dimensionality as a parameter, for example through \texttt{Val\{T\}()} (see \href{@ref}{{\textquotedbl}Value types{\textquotedbl}}):




\begin{minted}{jlcon}
julia> function array3(fillval, ::Val{N}) where N
           fill(fillval, ntuple(d->3, Val(N)))
       end
array3 (generic function with 1 method)

julia> array3(5.0, Val(2))
3×3 Array{Float64,2}:
 5.0  5.0  5.0
 5.0  5.0  5.0
 5.0  5.0  5.0
\end{minted}



Julia has a specialized version of \texttt{ntuple} that accepts a \texttt{Val\{::Int\}} instance as the second parameter; by passing \texttt{N} as a type-parameter, you make its {\textquotedbl}value{\textquotedbl} known to the compiler. Consequently, this version of \texttt{array3} allows the compiler to predict the return type.



However, making use of such techniques can be surprisingly subtle. For example, it would be of no help if you called \texttt{array3} from a function like this:




\begin{minted}{julia}
function call_array3(fillval, n)
    A = array3(fillval, Val(n))
end
\end{minted}



Here, you{\textquotesingle}ve created the same problem all over again: the compiler can{\textquotesingle}t guess what \texttt{n} is, so it doesn{\textquotesingle}t know the \emph{type} of \texttt{Val(n)}. Attempting to use \texttt{Val}, but doing so incorrectly, can easily make performance \emph{worse} in many situations. (Only in situations where you{\textquotesingle}re effectively combining \texttt{Val} with the function-barrier trick, to make the kernel function more efficient, should code like the above be used.)



一个正确使用 \texttt{Val} 的例子是这样的：




\begin{minted}{julia}
function filter3(A::AbstractArray{T,N}) where {T,N}
    kernel = array3(1, Val(N))
    filter(A, kernel)
end
\end{minted}



In this example, \texttt{N} is passed as a parameter, so its {\textquotedbl}value{\textquotedbl} is known to the compiler. Essentially, \texttt{Val(T)} works only when \texttt{T} is either hard-coded/literal (\texttt{Val(3)}) or already specified in the type-domain.



\hypertarget{5410118045861360063}{}


\section{The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)}



Once one learns to appreciate multiple dispatch, there{\textquotesingle}s an understandable tendency to go overboard and try to use it for everything. For example, you might imagine using it to store information, e.g.




\begin{lstlisting}
struct Car{Make, Model}
    year::Int
    ...more fields...
end
\end{lstlisting}



and then dispatch on objects like \texttt{Car\{:Honda,:Accord\}(year, args...)}.



This might be worthwhile when either of the following are true:



\begin{itemize}
\item You require CPU-intensive processing on each \texttt{Car}, and it becomes vastly more efficient if you know the \texttt{Make} and \texttt{Model} at compile time and the total number of different \texttt{Make} or \texttt{Model} that will be used is not too large.


\item You have homogenous lists of the same type of \texttt{Car} to process, so that you can store them all in an \texttt{Array\{Car\{:Honda,:Accord\},N\}}.

\end{itemize}


When the latter holds, a function processing such a homogenous array can be productively specialized: Julia knows the type of each element in advance (all objects in the container have the same concrete type), so Julia can {\textquotedbl}look up{\textquotedbl} the correct method calls when the function is being compiled (obviating the need to check at run-time) and thereby emit efficient code for processing the whole list.



When these do not hold, then it{\textquotesingle}s likely that you{\textquotesingle}ll get no benefit; worse, the resulting {\textquotedbl}combinatorial explosion of types{\textquotedbl} will be counterproductive. If \texttt{items[i+1]} has a different type than \texttt{item[i]}, Julia has to look up the type at run-time, search for the appropriate method in method tables, decide (via type intersection) which one matches, determine whether it has been JIT-compiled yet (and do so if not), and then make the call. In essence, you{\textquotesingle}re asking the full type- system and JIT-compilation machinery to basically execute the equivalent of a switch statement or dictionary lookup in your own code.



Some run-time benchmarks comparing (1) type dispatch, (2) dictionary lookup, and (3) a {\textquotedbl}switch{\textquotedbl} statement can be found \href{https://groups.google.com/forum/\#!msg/julia-users/jUMu9A3QKQQ/qjgVWr7vAwAJ}{on the mailing list}.



Perhaps even worse than the run-time impact is the compile-time impact: Julia will compile specialized functions for each different \texttt{Car\{Make, Model\}}; if you have hundreds or thousands of such types, then every function that accepts such an object as a parameter (from a custom \texttt{get\_year} function you might write yourself, to the generic \texttt{push!} function in Julia Base) will have hundreds or thousands of variants compiled for it. Each of these increases the size of the cache of compiled code, the length of internal lists of methods, etc. Excess enthusiasm for values-as-parameters can easily waste enormous resources.



\hypertarget{16800011477786249644}{}


\section{Access arrays in memory order, along columns}



Julia 中的多维数组以列主序存储。这意味着数组一次堆叠一列。这可使用 \texttt{vec} 函数或语法 \texttt{[:]} 来验证，如下所示（请注意，数组的顺序是 \texttt{[1 3 2 4]}，而不是 \texttt{[1 2 3 4]}）：




\begin{minted}{jlcon}
julia> x = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> x[:]
4-element Array{Int64,1}:
 1
 3
 2
 4
\end{minted}



This convention for ordering arrays is common in many languages like Fortran, Matlab, and R (to name a few). The alternative to column-major ordering is row-major ordering, which is the convention adopted by C and Python (\texttt{numpy}) among other languages. Remembering the ordering of arrays can have significant performance effects when looping over arrays. A rule of thumb to keep in mind is that with column-major arrays, the first index changes most rapidly. Essentially this means that looping will be faster if the inner-most loop index is the first to appear in a slice expression. Keep in mind that indexing an array with \texttt{:} is an implicit loop that iteratively accesses all elements within a particular dimension; it can be faster to extract columns than rows, for example.



考虑以下人为示例。假设我们想编写一个接收 \hyperlink{10571362059486397014}{\texttt{Vector}} 并返回方阵 \hyperlink{5448927444601277512}{\texttt{Matrix}} 的函数，所返回方阵的行或列都用输入向量的副本填充。并假设用这些副本填充的是行还是列并不重要（也许可以很容易地相应调整剩余代码）。我们至少可以想到四种方式（除了建议的调用内置函数 \hyperlink{15426606278434194584}{\texttt{repeat}}）：




\begin{minted}{julia}
function copy_cols(x::Vector{T}) where T
    inds = axes(x, 1)
    out = similar(Array{T}, inds, inds)
    for i = inds
        out[:, i] = x
    end
    return out
end

function copy_rows(x::Vector{T}) where T
    inds = axes(x, 1)
    out = similar(Array{T}, inds, inds)
    for i = inds
        out[i, :] = x
    end
    return out
end

function copy_col_row(x::Vector{T}) where T
    inds = axes(x, 1)
    out = similar(Array{T}, inds, inds)
    for col = inds, row = inds
        out[row, col] = x[row]
    end
    return out
end

function copy_row_col(x::Vector{T}) where T
    inds = axes(x, 1)
    out = similar(Array{T}, inds, inds)
    for row = inds, col = inds
        out[row, col] = x[col]
    end
    return out
end
\end{minted}



现在，我们使用相同的 \texttt{10000} 乘 \texttt{1} 的随机输入向量来对这些函数计时。




\begin{minted}{jlcon}
julia> x = randn(10000);

julia> fmt(f) = println(rpad(string(f)*": ", 14, ' '), @elapsed f(x))

julia> map(fmt, [copy_cols, copy_rows, copy_col_row, copy_row_col]);
copy_cols:    0.331706323
copy_rows:    1.799009911
copy_col_row: 0.415630047
copy_row_col: 1.721531501
\end{minted}



请注意，\texttt{copy\_cols} 比 \texttt{copy\_rows} 快得多。这与预料的一致，因为 \texttt{copy\_cols} 尊重 \texttt{Matrix} 基于列的内存布局。另外，\texttt{copy\_col\_row} 比 \texttt{copy\_row\_col} 快得多，因为它遵循我们的经验法则，即切片表达式中出现的第一个元素应该与最内层循环耦合。



\hypertarget{2586641269833759347}{}


\section{输出预分配}



如果函数返回 \texttt{Array} 或其它复杂类型，则可能需要分配内存。不幸的是，内存分配及其反面垃圾收集通常是很大的瓶颈。



有时，你可以通过预分配输出结果来避免在每个函数调用上分配内存的需要。作为一个简单的例子，比较




\begin{minted}{jlcon}
julia> function xinc(x)
           return [x, x+1, x+2]
       end;

julia> function loopinc()
           y = 0
           for i = 1:10^7
               ret = xinc(i)
               y += ret[2]
           end
           return y
       end;
\end{minted}



和




\begin{minted}{jlcon}
julia> function xinc!(ret::AbstractVector{T}, x::T) where T
           ret[1] = x
           ret[2] = x+1
           ret[3] = x+2
           nothing
       end;

julia> function loopinc_prealloc()
           ret = Vector{Int}(undef, 3)
           y = 0
           for i = 1:10^7
               xinc!(ret, i)
               y += ret[2]
           end
           return y
       end;
\end{minted}



计时结果：




\begin{minted}{jlcon}
julia> @time loopinc()
  0.529894 seconds (40.00 M allocations: 1.490 GiB, 12.14% gc time)
50000015000000

julia> @time loopinc_prealloc()
  0.030850 seconds (6 allocations: 288 bytes)
50000015000000
\end{minted}



预分配还有其它优点，例如允许调用者在算法中控制「输出」类型。在上述例子中，我们如果需要，可以传递 \texttt{SubArray} 而不是 \hyperlink{15492651498431872487}{\texttt{Array}}。



极端情况下，预分配可能会使你的代码更丑陋，所以可能需要做性能测试和一些判断。但是，对于「向量化」（逐元素）函数，方便的语法 \texttt{x .= f.(y)} 可用于具有融合循环的 in-place 操作且无需临时数组（请参阅\hyperlink{17801130558550430478}{向量化函数的点语法}）。



\hypertarget{12965993905966303435}{}


\section{点语法：融合向量化操作}



Julia 有特殊的\hyperlink{17801130558550430478}{点语法}，它可以将任何标量函数转换为「向量化」函数调用，将任何运算符转换为「向量化」运算符，其具有的特殊性质是嵌套「点调用」是\emph{融合的}：它们在语法层级被组合为单个循环，无需分配临时数组。如果你使用 \texttt{.=} 和类似的赋值运算符，则结果也可以 in-place 存储在预分配的数组（参见上文）。



在线性代数的上下文中，这意味着即使诸如 \texttt{vector + vector} 和 \texttt{vector * scalar} 之类的运算，使用 \texttt{vector .+ vector} 和 \texttt{vector .* scalar} 来替代也可能是有利的，因为生成的循环可与周围的计算融合。例如，考虑两个函数：




\begin{minted}{jlcon}
julia> f(x) = 3x.^2 + 4x + 7x.^3;

julia> fdot(x) = @. 3x^2 + 4x + 7x^3 # equivalent to 3 .* x.^2 .+ 4 .* x .+ 7 .* x.^3;
\end{minted}



\texttt{f} 和 \texttt{fdot} 都做相同的计算。但是，\texttt{fdot}（在 \hyperlink{16688502228717894452}{\texttt{@.}} 宏的帮助下定义）在作用于数组时明显更快：




\begin{minted}{jlcon}
julia> x = rand(10^6);

julia> @time f(x);
  0.019049 seconds (16 allocations: 45.777 MiB, 18.59% gc time)

julia> @time fdot(x);
  0.002790 seconds (6 allocations: 7.630 MiB)

julia> @time f.(x);
  0.002626 seconds (8 allocations: 7.630 MiB)
\end{minted}



That is, \texttt{fdot(x)} is ten times faster and allocates 1/6 the memory of \texttt{f(x)}, because each \texttt{*} and \texttt{+} operation in \texttt{f(x)} allocates a new temporary array and executes in a separate loop. (Of course, if you just do \texttt{f.(x)} then it is as fast as \texttt{fdot(x)} in this example, but in many contexts it is more convenient to just sprinkle some dots in your expressions rather than defining a separate function for each vectorized operation.)



\hypertarget{16479954806149442392}{}


\section{Consider using views for slices}



In Julia, an array {\textquotedbl}slice{\textquotedbl} expression like \texttt{array[1:5, :]} creates a copy of that data (except on the left-hand side of an assignment, where \texttt{array[1:5, :] = ...} assigns in-place to that portion of \texttt{array}). If you are doing many operations on the slice, this can be good for performance because it is more efficient to work with a smaller contiguous copy than it would be to index into the original array. On the other hand, if you are just doing a few simple operations on the slice, the cost of the allocation and copy operations can be substantial.



An alternative is to create a {\textquotedbl}view{\textquotedbl} of the array, which is an array object (a \texttt{SubArray}) that actually references the data of the original array in-place, without making a copy. (If you write to a view, it modifies the original array{\textquotesingle}s data as well.) This can be done for individual slices by calling \hyperlink{4861450464669906845}{\texttt{view}}, or more simply for a whole expression or block of code by putting \hyperlink{4544474300423667148}{\texttt{@views}} in front of that expression. For example:




\begin{minted}{jlcon}
julia> fcopy(x) = sum(x[2:end-1]);

julia> @views fview(x) = sum(x[2:end-1]);

julia> x = rand(10^6);

julia> @time fcopy(x);
  0.003051 seconds (7 allocations: 7.630 MB)

julia> @time fview(x);
  0.001020 seconds (6 allocations: 224 bytes)
\end{minted}



请注意，该函数的 \texttt{fview} 版本提速了 3 倍且减少了内存分配。



\hypertarget{12328390677917528950}{}


\section{复制数据不总是坏的}



数组被连续地存储在内存中，这使其可被 CPU 向量化，并且会由于缓存减少内存访问。这与建议以列序优先方式访问数组的原因相同（请参见上文）。由于不按顺序访问内存，无规律的访问方式和不连续的视图可能会大大减慢数组上的计算速度。



在对无规律访问的数据进行操作前，将其复制到连续的数组中可能带来巨大的加速，正如下例所示。其中，矩阵和向量在相乘前会访问其 800,000 个已被随机混洗的索引处的值。将视图复制到普通数组会加速乘法，即使考虑了复制操作的成本。




\begin{minted}{jlcon}
julia> using Random

julia> x = randn(1_000_000);

julia> inds = shuffle(1:1_000_000)[1:800000];

julia> A = randn(50, 1_000_000);

julia> xtmp = zeros(800_000);

julia> Atmp = zeros(50, 800_000);

julia> @time sum(view(A, :, inds) * view(x, inds))
  0.412156 seconds (14 allocations: 960 bytes)
-4256.759568345458

julia> @time begin
           copyto!(xtmp, view(x, inds))
           copyto!(Atmp, view(A, :, inds))
           sum(Atmp * xtmp)
       end
  0.285923 seconds (14 allocations: 960 bytes)
-4256.759568345134
\end{minted}



倘若副本本身的内存足够大，那么将视图复制到数组的成本可能远远超过在连续数组上执行矩阵乘法所带来的加速。



\hypertarget{5580481875828136728}{}


\section{避免 I/0 中的字符串插值}



将数据写入到文件（或其他 I/0 设备）中时，生成额外的中间字符串会带来开销。请不要写成这样：




\begin{minted}{julia}
println(file, "$a $b")
\end{minted}



请写成这样：




\begin{minted}{julia}
println(file, a, " ", b)
\end{minted}



第一个版本的代码生成一个字符串，然后将其写入到文件中，而第二个版本直接将值写入到文件中。另请注意，在某些情况下，字符串插值可能更难阅读。请考虑：




\begin{minted}{julia}
println(file, "$(f(a))$(f(b))")
\end{minted}



与：




\begin{minted}{julia}
println(file, f(a), f(b))
\end{minted}



\hypertarget{612858988935113727}{}


\section{并发执行时优化网络 I/O}



当并发地执行一个远程函数时：




\begin{minted}{julia}
using Distributed

responses = Vector{Any}(undef, nworkers())
@sync begin
    for (idx, pid) in enumerate(workers())
        @async responses[idx] = remotecall_fetch(foo, pid, args...)
    end
end
\end{minted}



会快于：




\begin{minted}{julia}
using Distributed

refs = Vector{Any}(undef, nworkers())
for (idx, pid) in enumerate(workers())
    refs[idx] = @spawnat pid foo(args...)
end
responses = [fetch(r) for r in refs]
\end{minted}



第一种方式导致每个worker一次网络往返，而第二种方式是两次网络调用：一次 \hyperlink{11231712027010946923}{\texttt{@spawnat}} 一次\hyperlink{11007884648860062495}{\texttt{fetch}} （甚至是 \hyperlink{13761789780433862250}{\texttt{wait}}）。 \hyperlink{11007884648860062495}{\texttt{fetch}} 和\hyperlink{13761789780433862250}{\texttt{wait}} 都是同步执行，会导致较差的性能。



\hypertarget{1574945516556538959}{}


\section{修复过期警告}



过期的函数在内部会执行查找，以便仅打印一次相关警告。 这种额外查找可能会显著影响性能，因此应根据警告建议修复掉过期函数的所有使用。



\hypertarget{3670078412083548982}{}


\section{小技巧}



有一些小的注意事项可能会帮助改善循环性能。



\begin{itemize}
\item 避免使用不必要的数组。比如，使用 \texttt{x+y+z} 而不是 \hyperlink{8666686648688281595}{\texttt{sum([x,y,z])}}。


\item 对于复数 \texttt{z}，使用 \hyperlink{15686257922156163743}{\texttt{abs2(z)}} 而不是 \hyperlink{462277561264792021}{\texttt{abs(z){\textasciicircum}2}}。一般的， 对于复数参数，用 \hyperlink{15686257922156163743}{\texttt{abs2}} 代替\hyperlink{9614495866226399167}{\texttt{abs}}。


\item 对于直接截断的整除，使用 \hyperlink{8020976424566491334}{\texttt{div(x,y)}} 而不是 \hyperlink{1728363361565303194}{\texttt{trunc(x/y)}}，使用\hyperlink{15067916827074788527}{\texttt{fld(x,y)}} 而不是 \hyperlink{11115257331910840693}{\texttt{floor(x/y)}}，使用 \hyperlink{7922388465305816555}{\texttt{cld(x,y)}} 而不是 \hyperlink{10519509038312853061}{\texttt{ceil(x/y)}}。

\end{itemize}


\hypertarget{3688250407374776658}{}


\section{性能标注}



有时，你可以通过承诺某些程序性质来启用更好的优化。



\begin{itemize}
\item 使用 \hyperlink{9619263577270933060}{\texttt{@inbounds}} 来取消表达式中的数组边界检查。使用前请再三确定，如果下标越界，可能会发生崩溃或潜在的故障。


\item 使用 \hyperlink{8577961464469068114}{\texttt{@fastmath}} 来允许对于实数是正确的、但是对于 IEEE 数字会导致差异的浮点数优化。使用时请多多小心，因为这可能改变数值结果。这对应于 clang 的 \texttt{-ffast-math} 选项。


\item 在 \texttt{for} 循环前编写 \hyperlink{8155428559748374852}{\texttt{@simd}} 来承诺迭代是相互独立且可以重新排序的。请注意，在许多情况下，Julia 可以在没有 \texttt{@simd} 宏的情况下自动向量化代码；只有在这种转换原本是非法的情况下才有用，包括允许浮点数重新结合和忽略相互依赖的内存访问（\texttt{@simd ivdep}）等情况。此外，在断言 \texttt{@simd} 时要十分小心，因为错误地标注一个具有相互依赖的迭代的循环可能导致意外结果。尤其要注意的是，某些 \texttt{AbstractArray} 子类型的 \texttt{setindex!} 本质上依赖于迭代顺序。\textbf{此功能是实验性的}，在 Julia 未来的版本中可能会更改或消失。

\end{itemize}


The common idiom of using 1:n to index into an AbstractArray is not safe if the Array uses unconventional indexing, and may cause a segmentation fault if bounds checking is turned off. Use \texttt{LinearIndices(x)} or \texttt{eachindex(x)} instead (see also \hyperlink{1238988360302116626}{Arrays with custom indices}).



\begin{quote}
\textbf{Note}

虽然 \texttt{@simd} 需要直接放在最内层 \texttt{for} 循环前面，但 \texttt{@inbounds} 和 \texttt{@fastmath} 都可作用于单个表达式或在嵌套代码块中出现的所有表达式，例如，可使用 \texttt{@inbounds begin} 或 \texttt{@inbounds for ...}。

\end{quote}


下面是一个具有 \texttt{@inbounds} 和 \texttt{@simd} 标记的例子（我们这里使用 \texttt{@noinline} 来防止因优化器过于智能而破坏我们的基准测试）：




\begin{minted}{julia}
@noinline function inner(x, y)
    s = zero(eltype(x))
    for i=eachindex(x)
        @inbounds s += x[i]*y[i]
    end
    return s
end

@noinline function innersimd(x, y)
    s = zero(eltype(x))
    @simd for i = eachindex(x)
        @inbounds s += x[i] * y[i]
    end
    return s
end

function timeit(n, reps)
    x = rand(Float32, n)
    y = rand(Float32, n)
    s = zero(Float64)
    time = @elapsed for j in 1:reps
        s += inner(x, y)
    end
    println("GFlop/sec        = ", 2n*reps / time*1E-9)
    time = @elapsed for j in 1:reps
        s += innersimd(x, y)
    end
    println("GFlop/sec (SIMD) = ", 2n*reps / time*1E-9)
end

timeit(1000, 1000)
\end{minted}



在配备 2.4GHz Intel Core i5 处理器的计算机上，其结果为：




\begin{lstlisting}
GFlop/sec        = 1.9467069505224963
GFlop/sec (SIMD) = 17.578554163920018
\end{lstlisting}



（\texttt{GFlop/sec} 用来测试性能，数值越大越好。）



下面是一个具有三种标记的例子。此程序首先计算一个一维数组的有限差分，然后计算结果的 L2 范数：




\begin{minted}{julia}
function init!(u::Vector)
    n = length(u)
    dx = 1.0 / (n-1)
    @fastmath @inbounds @simd for i in 1:n # 通过断言 `u` 是一个 `Vector`，我们可以假定它具有 1-based 索引
        u[i] = sin(2pi*dx*i)
    end
end

function deriv!(u::Vector, du)
    n = length(u)
    dx = 1.0 / (n-1)
    @fastmath @inbounds du[1] = (u[2] - u[1]) / dx
    @fastmath @inbounds @simd for i in 2:n-1
        du[i] = (u[i+1] - u[i-1]) / (2*dx)
    end
    @fastmath @inbounds du[n] = (u[n] - u[n-1]) / dx
end

function mynorm(u::Vector)
    n = length(u)
    T = eltype(u)
    s = zero(T)
    @fastmath @inbounds @simd for i in 1:n
        s += u[i]^2
    end
    @fastmath @inbounds return sqrt(s)
end

function main()
    n = 2000
    u = Vector{Float64}(undef, n)
    init!(u)
    du = similar(u)

    deriv!(u, du)
    nu = mynorm(du)

    @time for i in 1:10^6
        deriv!(u, du)
        nu = mynorm(du)
    end

    println(nu)
end

main()
\end{minted}



在配备 2.7 GHz Intel Core i7 处理器的计算机上，其结果为：




\begin{lstlisting}
$ julia wave.jl;
  1.207814709 seconds
4.443986180758249

$ julia --math-mode=ieee wave.jl;
  4.487083643 seconds
4.443986180758249
\end{lstlisting}



在这里，选项 \texttt{--math-mode=ieee} 禁用 \texttt{@fastmath} 宏，好让我们可以比较结果。



在这种情况下，\texttt{@fastmath} 加速了大约 3.7 倍。这非常大——通常来说，加速会更小。（在这个特定的例子中，基准测试的工作集足够小，可以放在该处理器的 L1 缓存中，因此内存访问延迟不起作用，计算时间主要由 CPU 使用率决定。在许多现实世界的程序中，情况并非如此。）此外，在这种情况下，此优化不会改变计算结果——通常来说，结果会略有不同。在某些情况下，尤其是数值不稳定的算法，计算结果可能会差很多。



标注 \texttt{@fastmath} 会重新排列浮点数表达式，例如更改求值顺序，或者假设某些特殊情况（如 inf、nan）不出现。在这种情况中（以及在这个特定的计算机上），主要区别是函数 \texttt{deriv} 中的表达式 \texttt{1 / (2*dx)} 会被提升出循环（即在循环外计算），就像编写了 \texttt{idx = 1 / (2*dx)}，然后，在循环中，表达式 \texttt{... / (2*dx)} 变为 \texttt{... * idx}，后者计算起来快得多。当然，编译器实际上采用的优化以及由此产生的加速都在很大程度上取决于硬件。你可以使用 Julia 的 \hyperlink{2534314152947301270}{\texttt{code\_native}} 函数来检查所生成代码的更改。



请注意，\texttt{@fastmath} 也假设了在计算中不会出现 \texttt{NaN}，这可能导致意想不到的行为：




\begin{minted}{jlcon}
julia> f(x) = isnan(x);

julia> f(NaN)
true

julia> f_fast(x) = @fastmath isnan(x);

julia> f_fast(NaN)
false
\end{minted}



\hypertarget{12370344689233780157}{}


\section{Treat Subnormal Numbers as Zeros}



Subnormal numbers, formerly called \href{https://en.wikipedia.org/wiki/Denormal\_number}{denormal numbers}, are useful in many contexts, but incur a performance penalty on some hardware. A call \hyperlink{2845950135157372113}{\texttt{set\_zero\_subnormals(true)}} grants permission for floating-point operations to treat subnormal inputs or outputs as zeros, which may improve performance on some hardware. A call \hyperlink{2845950135157372113}{\texttt{set\_zero\_subnormals(false)}} enforces strict IEEE behavior for subnormal numbers.



Below is an example where subnormals noticeably impact performance on some hardware:




\begin{minted}{julia}
function timestep(b::Vector{T}, a::Vector{T}, Δt::T) where T
    @assert length(a)==length(b)
    n = length(b)
    b[1] = 1                            # Boundary condition
    for i=2:n-1
        b[i] = a[i] + (a[i-1] - T(2)*a[i] + a[i+1]) * Δt
    end
    b[n] = 0                            # Boundary condition
end

function heatflow(a::Vector{T}, nstep::Integer) where T
    b = similar(a)
    for t=1:div(nstep,2)                # Assume nstep is even
        timestep(b,a,T(0.1))
        timestep(a,b,T(0.1))
    end
end

heatflow(zeros(Float32,10),2)           # Force compilation
for trial=1:6
    a = zeros(Float32,1000)
    set_zero_subnormals(iseven(trial))  # Odd trials use strict IEEE arithmetic
    @time heatflow(a,1000)
end
\end{minted}



This gives an output similar to




\begin{lstlisting}
  0.002202 seconds (1 allocation: 4.063 KiB)
  0.001502 seconds (1 allocation: 4.063 KiB)
  0.002139 seconds (1 allocation: 4.063 KiB)
  0.001454 seconds (1 allocation: 4.063 KiB)
  0.002115 seconds (1 allocation: 4.063 KiB)
  0.001455 seconds (1 allocation: 4.063 KiB)
\end{lstlisting}



Note how each even iteration is significantly faster.



This example generates many subnormal numbers because the values in \texttt{a} become an exponentially decreasing curve, which slowly flattens out over time.



Treating subnormals as zeros should be used with caution, because doing so breaks some identities, such as \texttt{x-y == 0} implies \texttt{x == y}:




\begin{minted}{jlcon}
julia> x = 3f-38; y = 2f-38;

julia> set_zero_subnormals(true); (x - y, x == y)
(0.0f0, false)

julia> set_zero_subnormals(false); (x - y, x == y)
(1.0000001f-38, false)
\end{minted}



In some applications, an alternative to zeroing subnormal numbers is to inject a tiny bit of noise.  For example, instead of initializing \texttt{a} with zeros, initialize it with:




\begin{minted}{julia}
a = rand(Float32,1000) * 1.f-9
\end{minted}



\hypertarget{7082991166860772411}{}


\section{\texttt{@code\_warntype}}



宏 \hyperlink{8092893264277772840}{\texttt{@code\_warntype}}（或其函数变体 \hyperlink{5565852192659724503}{\texttt{code\_warntype}}）有时可以帮助诊断类型相关的问题。这是一个例子：




\begin{minted}{jlcon}
julia> @noinline pos(x) = x < 0 ? 0 : x;

julia> function f(x)
           y = pos(x)
           return sin(y*x + 1)
       end;

julia> @code_warntype f(3.2)
Variables
  #self#::Core.Compiler.Const(f, false)
  x::Float64
  y::UNION{FLOAT64, INT64}

Body::Float64
1 ─      (y = Main.pos(x))
│   %2 = (y * x)::Float64
│   %3 = (%2 + 1)::Float64
│   %4 = Main.sin(%3)::Float64
└──      return %4
\end{minted}



Interpreting the output of \hyperlink{8092893264277772840}{\texttt{@code\_warntype}}, like that of its cousins \hyperlink{1376948972689074219}{\texttt{@code\_lowered}}, \hyperlink{6823997547688846780}{\texttt{@code\_typed}}, \hyperlink{18039596607712979441}{\texttt{@code\_llvm}}, and \hyperlink{2629340111434042067}{\texttt{@code\_native}}, takes a little practice. Your code is being presented in form that has been heavily digested on its way to generating compiled machine code. Most of the expressions are annotated by a type, indicated by the \texttt{::T} (where \texttt{T} might be \hyperlink{5027751419500983000}{\texttt{Float64}}, for example). The most important characteristic of \hyperlink{8092893264277772840}{\texttt{@code\_warntype}} is that non-concrete types are displayed in red; since this document is written in Markdown, which has no color, in this document, red text is denoted by uppercase.



在顶部，该函数类型推导后的返回类型显示为 \texttt{Body::Float64}。下一行以 Julia 的 SSA IR 形式表示了 \texttt{f} 的主体。被数字标记的方块表示代码中（通过 \texttt{goto}）跳转的目标。查看主体，你会看到首先调用了 \texttt{pos}，其返回值经类型推导为 \texttt{Union} 类型 \texttt{UNION\{FLOAT64, INT64\}} 并以大写字母显示，因为它是非具体类型。这意味着我们无法根据输入类型知道 \texttt{pos} 的确切返回类型。但是，无论 \texttt{y} 是 \texttt{Float64} 还是 \texttt{Int64}，\texttt{y*x} 的结果都是 \texttt{Float64}。最终的结果是 \texttt{f(x::Float64)} 在其输出中不会是类型不稳定的，即使有些中间计算是类型不稳定的。



如何使用这些信息取决于你。显然，最好将 \texttt{pos} 修改为类型稳定的：如果这样做，\texttt{f} 中的所有变量都是具体的，其性能将是最佳的。但是，在某些情况下，这种\emph{短暂的}类型不稳定性可能无关紧要：例如，如果 \texttt{pos} 从不单独使用，那么 \texttt{f} 的输出（对于 \hyperlink{5027751419500983000}{\texttt{Float64}} 输入）是类型稳定的这一事实将保护之后的代码免受类型不稳定性的传播影响。这与类型不稳定性难以或不可能修复的情况密切相关。在这些情况下，上面的建议（例如，添加类型注释并/或分解函数）是你控制类型不稳定性的「损害」的最佳工具。另请注意，即使是 Julia Base 也有类型不稳定的函数。例如，函数 \hyperlink{13752961745140943082}{\texttt{findfirst}} 如果找到键则返回数组索引，如果没有找到键则返回 \texttt{nothing}，这是明显的类型不稳定性。为了更易于找到可能很重要的类型不稳定性，包含 \texttt{missing} 或 \texttt{nothing} 的 \texttt{Union} 会用黄色着重显示，而不是用红色。



以下示例可以帮助你解释被标记为包含非叶类型的表达式：



\begin{itemize}
\item 函数体以 \texttt{Body::UNION\{T1,T2\})} 开头

\begin{itemize}
\item 解释：函数具有不稳定返回类型


\item 建议：使返回值类型稳定，即使你必须对其进行类型注释

\end{itemize}

\item \texttt{invoke Main.g(\%\%x::Int64)::UNION\{FLOAT64, INT64\}}

\begin{itemize}
\item 解释：调用类型不稳定的函数 \texttt{g}。


\item 建议：修改该函数，或在必要时对其返回值进行类型注释

\end{itemize}

\item \texttt{invoke Base.getindex(\%\%x::Array\{Any,1\}, 1::Int64)::ANY}

\begin{itemize}
\item 解释：访问缺乏类型信息的数组的元素


\item 建议：使用具有更佳定义的类型的数组，或在必要时对访问的单个元素进行类型注释

\end{itemize}

\item \texttt{Base.getfield(\%\%x, :(:data))::ARRAY\{FLOAT64,N\} WHERE N}

\begin{itemize}
\item 解释：获取值为非叶类型的字段。在这种情况下，\texttt{ArrayContainer} 具有字段 \texttt{data::Array\{T\}}。但是 \texttt{Array} 也需要维度 \texttt{N} 来成为具体类型。


\item 建议：使用类似于 \texttt{Array\{T,3\}} 或 \texttt{Array\{T,N\}} 的具体类型，其中的 \texttt{N} 现在是 \texttt{ArrayContainer} 的参数

\end{itemize}
\end{itemize}


\hypertarget{16106323250273012356}{}


\section{被捕获变量的性能}



请考虑以下定义内部函数的示例：




\begin{minted}{julia}
function abmult(r::Int)
    if r < 0
        r = -r
    end
    f = x -> x * r
    return f
end
\end{minted}



函数 \texttt{abmult} 返回一个函数 \texttt{f}，它将其参数乘以 \texttt{r} 的绝对值。赋值给 \texttt{f} 的函数称为「闭包」。内部函数还被语言用于 \texttt{do} 代码块和生成器表达式。



这种代码风格为语言带来了性能挑战。解析器在将其转换为较低级别的指令时，基本上通过将内部函数提取到单独的代码块来重新组织上述代码。「被捕获的」变量，比如 \texttt{r}，被内部函数共享，且包含它们的作用域会被提取到内部函数和外部函数皆可访问的堆分配「box」中，这是因为语言指定内部作用域中的 \texttt{r} 必须与外部作用域中的 \texttt{r} 相同，就算在外部作用域（或另一个内部函数）修改 \texttt{r} 后也需如此。



前一段的讨论中提到了「解析器」，也就是，包含 \texttt{abmult} 的模块被首次加载时发生的编译前期，而不是首次调用它的编译后期。解析器不「知道」\texttt{Int} 是固定类型，也不知道语句 \texttt{r = -r} 将一个 \texttt{Int} 转换为另一个 \texttt{Int}。类型推断的魔力在编译后期生效。



因此，解析器不知道 \texttt{r} 具有固定类型（\texttt{Int}）。一旦内部函数被创建，\texttt{r} 的值也不会改变（因此也不需要 box）。因此，解析器向包含具有抽象类型（比如 \texttt{Any}）的对象的 box 发出代码，这对于每次出现的 \texttt{r} 都需要运行时类型分派。这可以通过在上述函数中使用 \texttt{@code\_warntype} 来验证。装箱和运行时的类型分派都有可能导致性能损失。



如果捕获的变量用于代码的性能关键部分，那么以下提示有助于确保它们的使用具有高效性。首先，如果已经知道被捕获的变量不会改变类型，则可以使用类型注释来显式声明类型（在变量上，而不是在右侧）：




\begin{minted}{julia}
function abmult2(r0::Int)
    r::Int = r0
    if r < 0
        r = -r
    end
    f = x -> x * r
    return f
end
\end{minted}



类型注释部分恢复由于捕获而导致的丢失性能，因为解析器可以将具体类型与 box 中的对象相关联。更进一步，如果被捕获的变量不再需要 box（因为它不会在闭包创建后被重新分配），就可以用 \texttt{let} 代码块表示，如下所示。




\begin{minted}{julia}
function abmult3(r::Int)
    if r < 0
        r = -r
    end
    f = let r = r
            x -> x * r
    end
    return f
end
\end{minted}



\texttt{let} 代码块创建了一个新的变量 \texttt{r}，它的作用域只是内部函数。第二种技术在捕获变量存在时完全恢复了语言性能。请注意，这是编译器的一个快速发展的方面，未来的版本可能不需要依靠这种程度的程序员注释来获得性能。与此同时，一些用户提供的包（如 \href{https://github.com/c42f/FastClosures.jl}{FastClosures}）会自动插入像在 \texttt{abmult3} 中那样的 \texttt{let} 语句。



\hypertarget{17337125735077390471}{}


\chapter{Checking for equality with a singleton}



When checking if a value is equal to some singleton it can be better for performance to check for identicality (\texttt{===}) instead of equality (\texttt{==}). The same advice applies to using \texttt{!==} over \texttt{!=}. These type of checks frequently occur e.g. when implementing the iteration protocol and checking if \texttt{nothing} is returned from \hyperlink{1722534687975587846}{\texttt{iterate}}.



\hypertarget{14117620934191882930}{}


\chapter{工作流程建议}



这里是高效使用 Julia 的一些建议。



\hypertarget{1742408234615272902}{}


\section{基于 REPL 的工作流程}



正如在 \hyperlink{10670790884919535588}{Julia REPL} 中演示的那样，Julia 的 REPL 为高效的交互式工作流程提供了丰富的功能。这里是一些可能进一步提升你在命令行下的体验的建议。



\hypertarget{11122328157249839079}{}


\subsection{一个基本的编辑器 / REPL 工作流程}



最基本的 Julia 工作流程是将一个文本编辑器配合 \texttt{julia} 的命令行使用。一般会包含下面一些步骤：



\begin{itemize}
\item \textbf{把还在开发中的代码放到一个临时的模块中。}新建一个文件，例如 \texttt{Tmp.jl}，并放到模块中。


\begin{minted}{julia}
module Tmp
export say_hello

say_hello() = println("Hello!")

# your other definitions here

end
\end{minted}


\item \textbf{把测试代码放到另一个文件中。}新建另一个文件，例如 \texttt{tst.jl}，开头为


\begin{minted}{julia}
include("Tmp.jl")
import .Tmp
# using .Tmp # we can use `using` to bring the exported symbols in `Tmp` into our namespace

Tmp.say_hello()
# say_hello()

# your other test code here
\end{minted}

并把测试作为 \texttt{Tmp} 的内容。或者，你可以把测试文件的内容打包到一个模块中，例如


\begin{minted}{julia}
module Tst
    include("Tmp.jl")
    import .Tmp
    #using .Tmp

    Tmp.say_hello()
    # say_hello()

    # your other test code here
end
\end{minted}

优点是你的测试代码现在包含在一个模块中，并且不会在 \texttt{Main} 的全局作用域中引入新定义，这样更加整洁。


\item 使用 \texttt{include({\textquotedbl}tst.jl{\textquotedbl})} 来在 Julia REPL 中 \texttt{include} \texttt{tst.jl} 文件。


\item \textbf{打肥皂，冲洗，重复。}（译者注：此为英语幽默，被称为\href{https://en.wikipedia.org/wiki/Lather,\_rinse,\_repeat）描述洗头发的过程}{“洗发算法”}在 \texttt{julia} REPL 中摸索不同的想法，把好的想法存入 \texttt{tst.jl}。要在 \texttt{tst.jl} 被更改后执行它，只需再次 \texttt{include} 它。

\end{itemize}


\hypertarget{173246562791795014}{}


\section{基于浏览器的工作流程}



也可以通过 \href{https://github.com/JuliaLang/IJulia.jl}{IJulia} 在浏览器中与 Julia REPL 进行交互，请到该库的主页查看详细用法。



\hypertarget{940613295112476490}{}


\section{Revise-based workflows}



Whether you{\textquotesingle}re at the REPL or in IJulia, you can typically improve your development experience with \href{https://github.com/timholy/Revise.jl}{Revise}. It is common to configure Revise to start whenever julia is started, as per the instructions in the \href{https://timholy.github.io/Revise.jl/stable/}{Revise documentation}. Once configured, Revise will track changes to files in any loaded modules, and to any files loaded in to the REPL with \texttt{includet} (but not with plain \texttt{include}); you can then edit the files and the changes take effect without restarting your julia session. A standard workflow is similar to the REPL-based workflow above, with the following modifications:



\begin{itemize}
\item[1. ] Put your code in a module somewhere on your load path. There are several options for achieving this, of which two recommended choices are:

a. For long-term projects, use    \href{https://github.com/invenia/PkgTemplates.jl}{PkgTemplates}:

\texttt{julia    using PkgTemplates    t = Template()    generate({\textquotedbl}MyPkg{\textquotedbl}, t)}    This will create a blank package, \texttt{{\textquotedbl}MyPkg{\textquotedbl}}, in your \texttt{.julia/dev} directory.    Note that PkgTemplates allows you to control many different options    through its \texttt{Template} constructor.

In step 2 below, edit \texttt{MyPkg/src/MyPkg.jl} to change the source code, and    \texttt{MyPkg/test/runtests.jl} for the tests.

b. For {\textquotedbl}throw-away{\textquotedbl} projects, you can avoid any need for cleanup    by doing your work in your temporary directory (e.g., \texttt{/tmp}).

Navigate to your temporary directory and launch Julia, then do the following:

\texttt{julia    pkg> generate MyPkg              \# type ] to enter pkg mode    julia> push!(LOAD\_PATH, pwd())   \# hit backspace to exit pkg mode}    If you restart your Julia session you{\textquotesingle}ll have to re-issue that command    modifying \texttt{LOAD\_PATH}.

In step 2 below, edit \texttt{MyPkg/src/MyPkg.jl} to change the source code, and create any    test file of your choosing.


\item[2. ] Develop your package

\emph{Before} loading any code, make sure you{\textquotesingle}re running Revise: say \texttt{using Revise} or follow its documentation on configuring it to run automatically.

Then navigate to the directory containing your test file (here assumed to be \texttt{{\textquotedbl}runtests.jl{\textquotedbl}}) and do the following:


\begin{minted}{julia}
julia> using MyPkg

julia> include("runtests.jl")
\end{minted}

You can iteratively modify the code in MyPkg in your editor and re-run the tests with \texttt{include({\textquotedbl}runtests.jl{\textquotedbl})}.  You generally should not need to restart your Julia session to see the changes take effect (subject to a few limitations, see https://timholy.github.io/Revise.jl/stable/limitations/).

\end{itemize}


\hypertarget{8293020885235442145}{}


\chapter{代码风格指南}



接下来的部分将介绍如何写出具有 Julia 风格的代码。当然，这些规则并不是绝对的，它们只是一些建议，以便更好地帮助你熟悉这门语言，以及在不同的代码设计中做出选择。



\hypertarget{14598192216141137141}{}


\section{写函数，而不是仅仅写脚本}



一开始解决问题的时候，直接从最外层一步步写代码的确很便捷，但你应该尽早地将代码组织成函数。函数有更强的复用性和可测试性，并且能更清楚地让人知道哪些步骤做完了，以及每一步骤的输入输出分别是什么。此外，由于 Julia 编译器特殊的工作方式，写在函数中的代码往往要比最外层的代码运行地快得多。



此外值得一提的是，函数应当接受参数，而不是直接使用全局变量进行操作（\hyperlink{4355513108985533054}{\texttt{pi}} 等常数除外）。



\hypertarget{14766885101141675893}{}


\section{类型不要写得过于具体}



代码应该写得尽可能通用。例如，下面这段代码:




\begin{minted}{julia}
Complex{Float64}(x)
\end{minted}



更好的写法是写成下面的通用函数：




\begin{minted}{julia}
complex(float(x))
\end{minted}



第二个版本会把 \texttt{x} 转换成合适的类型，而不是某个写死的类型。



这种代码风格与函数的参数尤其相关。例如，当一个参数可以是任何整型时，不要将它的类型声明为 \texttt{Int} 或 \hyperlink{10103694114785108551}{\texttt{Int32}}，而要使用抽象类型（abstract type）\hyperlink{8469131683393450448}{\texttt{Integer}} 来表示。事实上，除非确实需要将其与其它的方法定义区分开，很多情况下你可以干脆完全省略掉参数的类型，因为如果你的操作中有不支持某种参数类型的操作的话，反正都会抛出 \hyperlink{68769522931907606}{\texttt{MethodError}} 的。这也称作 \href{https://zh.wikipedia.org/wiki/\%E9\%B8\%AD\%E5\%AD\%90\%E7\%B1\%BB\%E5\%9E\%8B}{鸭子类型}）。



例如，考虑这样的一个叫做 \texttt{addone} 的函数，其返回值为它的参数加 1 ：




\begin{minted}{julia}
addone(x::Int) = x + 1                 # works only for Int
addone(x::Integer) = x + oneunit(x)    # any integer type
addone(x::Number) = x + oneunit(x)     # any numeric type
addone(x) = x + oneunit(x)             # any type supporting + and oneunit
\end{minted}



最后一种定义可以处理所有支持 \hyperlink{2310843180104103470}{\texttt{oneunit}} （返回和 \texttt{x} 相同类型的 1，以避免不需要的类型提升（type promotion））以及 \hyperlink{3677358729494553841}{\texttt{+}} 函数的类型。这里的关键点在于，\textbf{只}定义通用的 \texttt{addone(x) = x + oneunit(x)} 并\textbf{不会}带来性能上的损失，因为 Julia 会在需要的时候自动编译特定的版本。比如说，当第一次调用 \texttt{addone(12)} 时，Julia 会自动编译一个特定的 \texttt{addone} 函数，它接受一个 \texttt{x::Int} 的参数，并把调用的 \texttt{oneunit} 替换为内连的值 \texttt{1}。因此，上述的前三种 \texttt{addone} 的定义对于第四种来说是完全多余的。



\hypertarget{14005859971102001375}{}


\section{让调用者处理多余的参数多样性}



如下的代码：




\begin{minted}{julia}
function foo(x, y)
    x = Int(x); y = Int(y)
    ...
end
foo(x, y)
\end{minted}



请写成这样：




\begin{minted}{julia}
function foo(x::Int, y::Int)
    ...
end
foo(Int(x), Int(y))
\end{minted}



这种风格更好，因为 \texttt{foo} 函数其实不需要接受所有类型的数，而只需要接受 \texttt{Int}。



这里的关键在于，如果一个函数需要处理的是整数，强制让调用者来决定非整数如何被转换（比如说向下还是向上取整）会更好。同时，把类型声明得具体一些的话可以为以后的方法定义留有更多的空间。



\hypertarget{1684346418186777370}{}


\section{Append \texttt{!} to names of functions that modify their arguments}



如下的代码：




\begin{minted}{julia}
function double(a::AbstractArray{<:Number})
    for i = firstindex(a):lastindex(a)
        a[i] *= 2
    end
    return a
end
\end{minted}



请写成这样：




\begin{minted}{julia}
function double!(a::AbstractArray{<:Number})
    for i = firstindex(a):lastindex(a)
        a[i] *= 2
    end
    return a
end
\end{minted}



Julia 的 Base 模块中的函数都遵循了这种规范，且包含很多例子：有的函数同时有拷贝和修改的形式（比如 \hyperlink{8473525809131227606}{\texttt{sort}} 和 \hyperlink{12296873681374954808}{\texttt{sort!}}），还有一些只有修改（比如 \hyperlink{18026893834387542681}{\texttt{push!}}，\hyperlink{14467641005327674015}{\texttt{pop!}} 和 \hyperlink{13785507599688955371}{\texttt{splice!}}）。为了方便起见，这类函数通常也会把修改后的数组作为返回值。



\hypertarget{14194687290331521644}{}


\section{避免使用奇怪的 \texttt{Union} 类型}



使用 \texttt{Union\{Function,AbstractString\}} 这样的类型的时候通常意味着设计还不够清晰。



\hypertarget{6548025962580232135}{}


\section{避免复杂的容器类型}



像下面这样构造数组通常没有什么好处：




\begin{minted}{julia}
a = Vector{Union{Int,AbstractString,Tuple,Array}}(undef, n)
\end{minted}



这种情况下，\texttt{Vector\{Any\}(undef, n)}更合适些。此外，相比将所有可能的类型都打包在一起，直接在使用时标注具体的数据类型（比如：\texttt{a[i]::Int}）对编译器来说更有用。



\hypertarget{17294992054689205687}{}


\section{使用和 Julia \texttt{base/} 文件夹中的代码一致的命名习惯}



\begin{itemize}
\item module 和 type 的名字使用大写开头的驼峰命名法：\texttt{module SparseArrays}，\texttt{struct UnitRange}。


\item 函数名使用小写字母，且当可读时可以将多个单词拼在一起。必要的时候，可以使用下划线作为单词分隔符。下划线也被用于指明概念的组合（比如 \hyperlink{14909184572421937971}{\texttt{remotecall\_fetch}} 作为 \texttt{fetch(remotecall(...))} 的一个更高效的实现）或者变化。


\item 虽然简洁性很重要，但避免使用缩写（用 \hyperlink{16333903346703258373}{\texttt{indexin}} 而不是 \texttt{indxin}），因为这会让记住单词有没有被缩写或如何被缩写变得十分困难。

\end{itemize}


如果一个函数名需要多个单词，请考虑这个函数是否代表了超过一个概念，是不是分成几个更小的部分更好。



\hypertarget{527161729759687978}{}


\section{使用与 Julia Base 中的函数类似的参数顺序}



一般来说，Base 库使用以下的函数参数顺序（如适用）：



\begin{itemize}
\item[1.  ] \textbf{函数参数}. 函数的第一个参数可以接受 \texttt{Function} 类型，以便使用 \hyperlink{16455129305818705265}{\texttt{do}} blocks 来传递多行匿名函数。


\item[2.  ] \textbf{I/O stream}. 函数的第一个参数可以接受 \texttt{IO} 对象，以便将函数传递给 \hyperlink{6652981552509545835}{\texttt{sprint}} 之类的函数，例如 \texttt{sprint(show, x)}。


\item[3.  ] \textbf{在输入参数的内容会被更改的情况下}. 比如，在 \hyperlink{5162290739791026948}{\texttt{fill!(x, v)}} 中，\texttt{x} 是要被修改的对象，所以放在要被插入 \texttt{x} 中的值前面。


\item[4.  ] \textbf{Type}. 把类型作为参数传入函数通常意味着返回值也会是同样的类型。 在 \hyperlink{14207407853646164654}{\texttt{parse(Int, {\textquotedbl}1{\textquotedbl})}} 中，类型在需要解析的字符串之前。 还有很多类似的将类型作为函数第一个参数的例子，但是同时也需要注意到例如 \hyperlink{8104134490906192097}{\texttt{read(io, String)}} 这样的函数中，会把 \texttt{IO} 参数放在类型的更前面，这样还是保持着这里描述的顺序。


\item[5.  ] \textbf{在输入参数的内容不会被更改的情况下}. 比如在 \texttt{fill!(x, v)} 中的\textbf{不}被修改的 \texttt{v}，会放在 \texttt{x} 之后传入。


\item[6.  ] \textbf{Key}. 对于关联集合来说，指的是键值对的键。 对于其它有索引的集合来说，指的是索引。


\item[7.  ] \textbf{Value}. 对于关联集合来说，指的是键值对的值。 In cases like \hyperlink{5162290739791026948}{\texttt{fill!(x, v)}}, this is \texttt{v}.


\item[8.  ] \textbf{Everything else}. 任何的其它参数。


\item[9.  ] \textbf{Varargs}. 指的是在函数调用时可以被无限列在后面的参数。 比如在 \texttt{Matrix\{T\}(uninitialized, dims)} 中，维数（dims）可以作为 \hyperlink{17462354060312563026}{\texttt{Tuple}} 被传入（如 \texttt{Matrix\{T\}(uninitialized, (1,2))}），也可以作为可变参数（\hyperlink{5941806424098279588}{\texttt{Vararg}}，如 \texttt{Matrix\{T\}(uninitialized, 1, 2)}。


\item[10. ] \textbf{Keyword arguments}. 在 Julia 中，关键字参数本来就不得不定义在函数定义的最后，列在这里仅仅是为了完整性。

\end{itemize}


大多数函数并不会接受上述所有种类的参数，这些数字仅仅是表示当适用时的优先权。



当然，在一些情况下有例外。例如，\hyperlink{1846942650946171605}{\texttt{convert}} 函数总是把类型作为第一个参数。\hyperlink{1309244355901386657}{\texttt{setindex!}} 函数的值参数在索引参数之前，这样可以让索引作为可变参数传入。



设计 API 时，尽可能秉承着这种一般顺序会让函数的使用者有一种更一致的体验。



\hypertarget{16340212137156679332}{}


\section{不要过度使用 try-catch}



比起依赖于捕获错误，更好的是避免错误。



\hypertarget{15308468417216899816}{}


\section{不要给条件语句加括号}



Julia 不要求在 \texttt{if} 和 \texttt{while} 后的条件两边加括号。使用如下写法：




\begin{minted}{julia}
if a == b
\end{minted}



而不是:




\begin{minted}{julia}
if (a == b)
\end{minted}



\hypertarget{13344988799401234550}{}


\section{不要过度使用 \texttt{...}}



拼接函数参数是会上瘾的。请用简单的 \texttt{[a; b]} 来代替 \texttt{[a..., b...]}，因为前者已经是被拼接的数组了。\hyperlink{6278865767444641812}{\texttt{collect(a)}} 也比 \texttt{[a...]} 更好，但因为 \texttt{a} 已经是一个可迭代的变量了，通常不把它转换成数组就直接使用甚至更好。



\hypertarget{13140702923511466392}{}


\section{不要使用不必要的静态参数}



如下的函数签名：




\begin{minted}{julia}
foo(x::T) where {T<:Real} = ...
\end{minted}



应当被写作：




\begin{minted}{julia}
foo(x::Real) = ...
\end{minted}



尤其是当 \texttt{T} 没有被用在函数体中时格外有意义。即使 \texttt{T} 被用到了，通常也可以被替换为 \hyperlink{13440452181855594120}{\texttt{typeof(x)}}，后者不会导致性能上的差别。注意这并不是针对静态参数的一般警告，而仅仅是针对那些不必要的情况。



同样需要注意的是，容器类型在函数调用中可能明确地需要类型参数。详情参见\hyperlink{11695962945306703148}{避免使用带抽象容器的字段}。



\hypertarget{14321901677948654689}{}


\section{避免判断变量是实例还是类型的混乱}



如下的一组定义容易令人困惑：




\begin{minted}{julia}
foo(::Type{MyType}) = ...
foo(::MyType) = foo(MyType)
\end{minted}



请决定问题里的概念应当是 \texttt{MyType} 还是 \texttt{MyType()}，然后坚持使用其一。



默认使用实例是比较受推崇的风格，然后只在为了解决一些问题必要时添加涉及到 \texttt{Type\{MyType\}} 的方法。



如果一个类型实际上是个枚举，它应该被定义成一个单一的类型（理想的情况是不可变结构或原始类型），把枚举值作为它的实例。构造器和转换器可以检查那些值是否有效。这种设计比把枚举做成抽象类型，并把“值”做成子类型来得更受推崇。



\hypertarget{678667303123676019}{}


\section{不要过度使用宏}



请注意有的宏实际上可以被写成一个函数。



在宏内部调用 \hyperlink{7507639810592563424}{\texttt{eval}} 是一个特别危险的警告标志，它意味着这个宏仅在被最外层调用时起作用。如果这样的宏被写成函数，它会自然地访问得到它所需要的运行时值。



\hypertarget{9477312169098625763}{}


\section{不要把不安全的操作暴露在接口层}



如果你有一个使用本地指针的类型：




\begin{minted}{julia}
mutable struct NativeType
    p::Ptr{UInt8}
    ...
end
\end{minted}



不要定义类似如下的函数：




\begin{minted}{julia}
getindex(x::NativeType, i) = unsafe_load(x.p, i)
\end{minted}



这里的问题在于，这个类型的用户可能会在意识不到这个操作不安全的情况下写出 \texttt{x[i]}，然后容易遇到内存错误。



在这样的函数中，可以加上对操作的检查来确保安全，或者可以在名字的某处加上 \texttt{unsafe} 来警告调用者。



\hypertarget{11547972187147924005}{}


\section{不要重载基础容器类型的方法}



有时可能会想要写这样的定义：




\begin{minted}{julia}
show(io::IO, v::Vector{MyType}) = ...
\end{minted}



这样可以提供对特定的某种新元素类型的向量的自定义显示。这种做法虽然很诱人，但应当被避免。这里的问题在于用户会想着一个像 \texttt{Vector()} 这样熟知的类型以某种方式表现，但过度自定义的行为会让使用变得更难。



\hypertarget{16979726342714314714}{}


\section{避免类型盗版}



“类型盗版”（type piracy）指的是扩展或是重定义 Base 或其它包中的并不是你所定义的类型的方法。在某些情况下，你可以几乎毫无副作用地逃避类型盗版。但在极端情况下，你甚至会让 Julia 崩溃（比如说你的方法扩展或重定义造成了对 \texttt{ccall} 传入了无效的输入）。类型盗版也让代码推导变得更复杂，且可能会引入难以预料和诊断的不兼容性。



例如，你也许想在一个模块中定义符号上的乘法：




\begin{minted}{julia}
module A
import Base.*
*(x::Symbol, y::Symbol) = Symbol(x,y)
end
\end{minted}



这里的问题时现在其它用到 \texttt{Base.*} 的模块同样会看到这个定义。由于 \texttt{Symbol} 是定义在 Base 里再被其它模块所使用的，这可能不可预料地改变无关代码的行为。这里有几种替代的方式，包括使用一个不同的函数名称，或是把 \texttt{Symbol} 给包在另一个你自己定义的类型中。



有时候，耦合的包可能会使用类型盗版，以此来从定义分隔特性，尤其是当那些包是一些合作的作者设计的时候，且那些定义是可重用的时候。例如，一个包可能提供一些对处理色彩有用的类型，另一个包可能为那些类型定义色彩空间之间转换的方法。再举一个例子，一个包可能是一些 C 代码的简易包装，另一个包可能就“盗版”来实现一些更高级别的、对 Julia 友好的 API。



\hypertarget{11741910651274288820}{}


\section{注意类型相等}



通常会用 \hyperlink{7066325108767373297}{\texttt{isa}} 和 \hyperlink{6254591906563366276}{\texttt{<:}} 来对类型进行测试，而不会用到 \texttt{==}。检测类型的相等通常只对和一个已知的具体类型比较有意义（例如 \texttt{T == Float64}），或者你\textbf{真的真的}知道自己在做什么。



\hypertarget{20919813611265277}{}


\section{不要写 \texttt{x->f(x)}}



因为调用高阶函数时经常会用到匿名函数，很容易认为这是合理甚至必要的。但任何函数都可以被直接传递，并不需要被“包{\textquotedbl}在一个匿名函数中。比如 \texttt{map(x->f(x), a)} 应当被写成 \hyperlink{11483231213869150535}{\texttt{map(f, a)}}。



\hypertarget{12032676153757060243}{}


\section{尽可能避免使用浮点数作为通用代码的字面量}



当写处理数字，且可以处理多种不同数字类型的参数的通用代码时，请使用对参数影响（通过类型提升）尽可能少的类型的字面量。



例如，




\begin{minted}{jlcon}
julia> f(x) = 2.0 * x
f (generic function with 1 method)

julia> f(1//2)
1.0

julia> f(1/2)
1.0

julia> f(1)
2.0
\end{minted}



而应当被写作：




\begin{minted}{jlcon}
julia> g(x) = 2 * x
g (generic function with 1 method)

julia> g(1//2)
1//1

julia> g(1/2)
1.0

julia> g(1)
2
\end{minted}



如你所见，使用了 \texttt{Int} 字面量的第二个版本保留了输入参数的类型，而第一个版本没有。这是因为例如 \texttt{promote\_type(Int, Float64) == Float64}，且做乘法时会需要类型提升。类似地，\hyperlink{8304566144531167610}{\texttt{Rational}} 字面量比 \hyperlink{5027751419500983000}{\texttt{Float64}} 字面量对类型有着更小的破坏性，但比 \texttt{Int} 大。




\begin{minted}{jlcon}
julia> h(x) = 2//1 * x
h (generic function with 1 method)

julia> h(1//2)
1//1

julia> h(1/2)
1.0

julia> h(1)
2//1
\end{minted}



所以，可能时尽量使用 \texttt{Int} 字面量，对非整数字面量使用 \texttt{Rational\{Int\}}，这样可以让代码变得更容易使用。



\hypertarget{17031291324185486008}{}


\chapter{常见问题}



\hypertarget{13603481244956250670}{}


\section{General}



\hypertarget{4693498942886852861}{}


\subsection{Is Julia named after someone or something?}



No.



\hypertarget{5072634749249852737}{}


\subsection{Why don{\textquotesingle}t you compile Matlab/Python/R/… code to Julia?}



Since many people are familiar with the syntax of other dynamic languages, and lots of code has already been written in those languages, it is natural to wonder why we didn{\textquotesingle}t just plug a Matlab or Python front-end into a Julia back-end (or “transpile” code to Julia) in order to get all the performance benefits of Julia without requiring programmers to learn a new language.  Simple, right?



The basic issue is that there is \emph{nothing special about Julia{\textquotesingle}s compiler}: we use a commonplace compiler (LLVM) with no “secret sauce” that other language developers don{\textquotesingle}t know about.  Indeed, Julia{\textquotesingle}s compiler is in many ways much simpler than those of other dynamic languages (e.g. PyPy or LuaJIT).   Julia{\textquotesingle}s performance advantage derives almost entirely from its front-end: its language semantics allow a \hyperlink{818954303942149020}{well-written Julia program} to \emph{give more opportunities to the compiler} to generate efficient code and memory layouts.  If you tried to compile Matlab or Python code to Julia, our compiler would be limited by the semantics of Matlab or Python to producing code no better than that of existing compilers for those languages (and probably worse).  The key role of semantics is also why several existing Python compilers (like Numba and Pythran) only attempt to optimize a small subset of the language (e.g. operations on Numpy arrays and scalars), and for this subset they are already doing at least as well as we could for the same semantics.  The people working on those projects are incredibly smart and have accomplished amazing things, but retrofitting a compiler onto a language that was designed to be interpreted is a very difficult problem.



Julia{\textquotesingle}s advantage is that good performance is not limited to a small subset of “built-in” types and operations, and one can write high-level type-generic code that works on arbitrary user-defined types while remaining fast and memory-efficient.  Types in languages like Python simply don{\textquotesingle}t provide enough information to the compiler for similar capabilities, so as soon as you used those languages as a Julia front-end you would be stuck.



For similar reasons, automated translation to Julia would also typically generate unreadable, slow, non-idiomatic code that would not be a good starting point for a native Julia port from another language.



On the other hand, language \emph{interoperability} is extremely useful: we want to exploit existing high-quality code in other languages from Julia (and vice versa)!  The best way to enable this is not a transpiler, but rather via easy inter-language calling facilities.  We have worked hard on this, from the built-in \texttt{ccall} intrinsic (to call C and Fortran libraries) to \href{https://github.com/JuliaInterop}{JuliaInterop} packages that connect Julia to Python, Matlab, C++, and more.



\hypertarget{4239210502811614787}{}


\section{会话和 REPL}



\hypertarget{503979811911045199}{}


\subsection{如何从内存中删除某个对象？}



Julia 没有类似于 MATLAB 的 \texttt{clear} 函数，某个名称一旦定义在 Julia 的会话中（准确地说，在 \texttt{Main} 模块中），它就会一直存在下去。



如果关心内存用量，一个对象总能被一个占用更少内存的对象替换掉。例如，如果 \texttt{A} 是一个不再需要的 GB 量级的数组，可以使用 \texttt{A = nothing} 来释放内存。该内存将在下一次垃圾回收器运行时被释放，也可以使用 \hyperlink{16287035550645122381}{\texttt{gc()}} 强制进行垃圾回收。另外，试图使用 \texttt{A} 很可能导致错误，因为大部分方法（method）在 \texttt{Nothing} 类型上没有定义。



\hypertarget{191104846954255908}{}


\subsection{如何在会话中修改某个类型的声明？}



也许你定义了某个类型，后来发现需要向其中增加一个新的域。如果在 REPL 中尝试这样做，会得到一个错误：




\begin{lstlisting}
ERROR: invalid redefinition of constant MyType
\end{lstlisting}



模块 \texttt{Main} 中的类型不能重新定义。



尽管这在开发新代码时会造成不便，但是这个问题仍然有一个不错的解决办法：可以用重新定义的模块替换原有的模块，把所有新代码封装在一个模块里，这样就能重新定义类型和常量了。虽说不能将类型名称导入到 \texttt{Main} 模块中再去重新定义，但是可以用模块名来改变作用范围。换言之，开发时的工作流可能类似这样：




\begin{minted}{julia}
include("mynewcode.jl") # this defines a module MyModule
obj1 = MyModule.ObjConstructor(a, b)
obj2 = MyModule.somefunction(obj1)
# Got an error. Change something in "mynewcode.jl"
include("mynewcode.jl") # reload the module
obj1 = MyModule.ObjConstructor(a, b) # old objects are no longer valid, must reconstruct
obj2 = MyModule.somefunction(obj1) # this time it worked!
obj3 = MyModule.someotherfunction(obj2, c)
...
\end{minted}



\hypertarget{11224408082580741592}{}


\section{脚本}



\hypertarget{14939284717840791757}{}


\subsection{该如何检查当前文件是否正在以主脚本运行？}



当一个文件通过使用 \texttt{julia file.jl} 来当做主脚本运行时，有人也希望激活另外的功能例如命令行参数操作。确定文件是以这个方式运行的一个方法是检查 \texttt{abspath(PROGRAM\_FILE) == @\_\_FILE\_\_} 是不是 \texttt{true}。



\hypertarget{5414221961728470242}{}


\subsection{How do I catch CTRL-C in a script?}



通过 \texttt{julia file.jl} 方式运行的 Julia 脚本，在你尝试按 CTRL-C (SIGINT) 中止它时，并不会抛出 \hyperlink{11255134339055983338}{\texttt{InterruptException}}。如果希望在脚本终止之后运行一些代码，请使用 \hyperlink{17479944696971324992}{\texttt{atexit}}，注意：脚本的中止不一定是由 CTRL-C 导致的。 另外你也可以通过 \texttt{julia -e {\textquotesingle}include(popfirst!(ARGS)){\textquotesingle} file.jl} 命令运行脚本，然后可以通过 \hyperlink{16338536928035025961}{\texttt{try}} 捕获 \texttt{InterruptException}。



\hypertarget{15272704088350857853}{}


\subsection{怎样通过 \texttt{\#!/usr/bin/env} 传递参数给 \texttt{julia}？}



通过类似 \texttt{\#!/usr/bin/env julia --startup-file=no} 的方式，使用 shebang 传递选项给 Julia 的方法，可能在像 Linux 这样的平台上无法正常工作。这是因为各平台上 shebang 的参数解析是平台相关的，并且尚未标准化。 在类 Unix 的环境中，可以通过以 \texttt{bash} 脚本作为可执行脚本的开头，并使用 \texttt{exec} 代替给 \texttt{julia} 传递选项的过程，来可靠的为 \texttt{julia} 传递选项。




\begin{minted}{julia}
#!/bin/bash
#=
exec julia --color=yes --startup-file=no "${BASH_SOURCE[0]}" "$@"
=#

@show ARGS  # put any Julia code here
\end{minted}



在以上例子中，位于 \texttt{\#=} 和 \texttt{=\#} 之间的代码可以当作一个 \texttt{bash} 脚本。 因为这些代码放在 Julia 的多行注释中，所以 Julia 会忽略它们。 在 \texttt{=\#} 之后的 Julia 代码会被 \texttt{bash} 忽略，J因为当文件解析到 \texttt{exec} 语句时会停止解析，开始执行命令。



\begin{quote}
\textbf{Note}

In order to \hyperlink{15294909856889946817}{catch CTRL-C} in the script you can use


\begin{minted}{julia}
#!/bin/bash
#=
exec julia --color=yes --startup-file=no -e 'include(popfirst!(ARGS))' \
    "${BASH_SOURCE[0]}" "$@"
=#

@show ARGS  # put any Julia code here
\end{minted}

instead. Note that with this strategy \hyperlink{9054270179006636705}{\texttt{PROGRAM\_FILE}} will not be set.

\end{quote}


\hypertarget{5727276226756196747}{}


\section{函数}



\hypertarget{7382572299104431822}{}


\subsection{向函数传递了参数 \texttt{x}，在函数中做了修改，但是在函数外变量 \texttt{x} 的值还是没有变。为什么？}



假设函数被如此调用：




\begin{minted}{jlcon}
julia> x = 10
10

julia> function change_value!(y)
           y = 17
       end
change_value! (generic function with 1 method)

julia> change_value!(x)
17

julia> x # x is unchanged!
10
\end{minted}



在 Julia 中，通过将 \texttt{x} 作为参数传递给函数，不能改变变量 \texttt{x} 的绑定。在上例中，调用 \texttt{change\_value!(x)} 时，\texttt{y} 是一个新建变量，初始时与 \texttt{x} 的值绑定，即 \texttt{10}。然后 \texttt{y} 与常量 \texttt{17} 重新绑定，此时变量外作用域中的 \texttt{x} 并没有变动。



However, if \texttt{x} is bound to an object of type \texttt{Array} (or any other \emph{mutable} type). From within the function, you cannot {\textquotedbl}unbind{\textquotedbl} \texttt{x} from this Array, but you \emph{can} change its content. For example:




\begin{minted}{jlcon}
julia> x = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia> function change_array!(A)
           A[1] = 5
       end
change_array! (generic function with 1 method)

julia> change_array!(x)
5

julia> x
3-element Array{Int64,1}:
 5
 2
 3
\end{minted}



这里我们新建了一个函数 \texttt{chang\_array!}，它把 \texttt{5} 赋值给传入的数组（在调用处与 \texttt{x} 绑定，在函数中与 \texttt{A} 绑定）的第一个元素。注意，在函数调用之后，\texttt{x} 依旧与同一个数组绑定，但是数组的内容变化了：变量 \texttt{A} 和 \texttt{x} 是不同的绑定，引用同一个可变的 \texttt{Array} 对象。



\hypertarget{10749355378766657270}{}


\subsection{函数内部能否使用 \texttt{using} 或 \texttt{import}？}



不可以，不能在函数内部使用 \texttt{using} 或 \texttt{import} 语句。如果你希望导入一个模块，但只在特定的一个或一组函数中使用它的符号，有以下两种方式：



\begin{itemize}
\item[1. ] 使用 \texttt{import}：


\begin{minted}{julia}
import Foo
function bar(...)
    # ... refer to Foo symbols via Foo.baz ...
end
\end{minted}

这会加载 \texttt{Foo} 模块，同时定义一个变量 \texttt{Foo} 引用该模块，但并不会 将其他任何符号从该模块中导入当前的命名空间。 \texttt{Foo} 等符号可以由限定的名称 \texttt{Foo.bar} 等引用。


\item[2. ] 将函数封装到模块中：


\begin{minted}{julia}
module Bar
export bar
using Foo
function bar(...)
    # ... refer to Foo.baz as simply baz ....
end
end
using Bar
\end{minted}

这会从 \texttt{Foo} 中导入所有符号，但仅限于 \texttt{Bar} 模块内。

\end{itemize}


\hypertarget{425348862563535930}{}


\subsection{运算符 \texttt{...} 有何作用？}



\hypertarget{6176809975782961444}{}


\subsection{\texttt{...} 运算符的两个用法：slurping 和 splatting}



很多 Julia 的新手会对运算符 \texttt{...} 的用法感到困惑。让 \texttt{...} 用法如此困惑的部分原因是根据上下文它有两种不同的含义。



\hypertarget{7095517523544633865}{}


\subsection{\texttt{...} 在函数定义中将多个参数组合成一个参数}



在函数定义的上下文中，\texttt{...}运算符用来将多个不同的参数组合成单个参数。\texttt{...}运算符的这种将多个不同参数组合成单个参数的用法称为slurping：




\begin{minted}{jlcon}
julia> function printargs(args...)
           println(typeof(args))
           for (i, arg) in enumerate(args)
               println("Arg #$i = $arg")
           end
       end
printargs (generic function with 1 method)

julia> printargs(1, 2, 3)
Tuple{Int64,Int64,Int64}
Arg #1 = 1
Arg #2 = 2
Arg #3 = 3
\end{minted}



如果Julia是一个使用ASCII字符更加自由的语言的话，slurping运算符可能会写作\texttt{<-...}而非\texttt{...}。



\hypertarget{4752115827323838494}{}


\subsection{\texttt{...}在函数调用中将一个参数分解成多个不同参数}



与在定义函数时表示将多个不同参数组合成一个参数的\texttt{...}运算符用法相对，当用在函数调用的上下文中\texttt{...}运算符也用来将单个的函数参数分成多个不同的参数。\texttt{...}函数的这个用法叫做splatting：




\begin{minted}{jlcon}
julia> function threeargs(a, b, c)
           println("a = $a::$(typeof(a))")
           println("b = $b::$(typeof(b))")
           println("c = $c::$(typeof(c))")
       end
threeargs (generic function with 1 method)

julia> x = [1, 2, 3]
3-element Array{Int64,1}:
 1
 2
 3

julia> threeargs(x...)
a = 1::Int64
b = 2::Int64
c = 3::Int64
\end{minted}



如果Julia是一个使用ASCII字符更加自由的语言的话，splatting运算符可能会写作\texttt{...->}而非\texttt{...}。



\hypertarget{18313029058103158138}{}


\subsection{赋值语句的返回值是什么？}



\texttt{=}运算符始终返回右侧的值，所以：




\begin{minted}{jlcon}
julia> function threeint()
           x::Int = 3.0
           x # returns variable x
       end
threeint (generic function with 1 method)

julia> function threefloat()
           x::Int = 3.0 # returns 3.0
       end
threefloat (generic function with 1 method)

julia> threeint()
3

julia> threefloat()
3.0
\end{minted}



相似地：




\begin{minted}{jlcon}
julia> function threetup()
           x, y = [3, 3]
           x, y # returns a tuple
       end
threetup (generic function with 1 method)

julia> function threearr()
           x, y = [3, 3] # returns an array
       end
threearr (generic function with 1 method)

julia> threetup()
(3, 3)

julia> threearr()
2-element Array{Int64,1}:
 3
 3
\end{minted}



\hypertarget{5608144491570256308}{}


\section{类型，类型声明和构造函数}



\hypertarget{11170875837665758023}{}


\subsection{何谓“类型稳定”？}



这意味着输出的类型可以由输入的类型预测出来。特别地，这意味着输出的类型不会因输入的\emph{值}的不同而变化。以下代码\emph{不是}类型稳定的：




\begin{minted}{jlcon}
julia> function unstable(flag::Bool)
           if flag
               return 1
           else
               return 1.0
           end
       end
unstable (generic function with 1 method)
\end{minted}



It returns either an \texttt{Int} or a \hyperlink{5027751419500983000}{\texttt{Float64}} depending on the value of its argument. Since Julia can{\textquotesingle}t predict the return type of this function at compile-time, any computation that uses it must be able to cope with values of both types, which makes it hard to produce fast machine code.



\hypertarget{6904365807459053438}{}


\subsection{为何 Julia 对某个看似合理的操作返回 \texttt{DomainError}？}



某些运算在数学上有意义，但会产生错误：




\begin{minted}{jlcon}
julia> sqrt(-2.0)
ERROR: DomainError with -2.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
[...]
\end{minted}



这一行为是为了保证类型稳定而带来的不便。对于 \hyperlink{4551113327515323898}{\texttt{sqrt}}，许多用户会希望 \texttt{sqrt(2.0)} 产生一个实数，如果得到了复数 \texttt{1.4142135623730951 + 0.0im} 则会不高兴。也可以编写 \hyperlink{4551113327515323898}{\texttt{sqrt}} 函数，只有当传递一个负数时才切换到复值输出，但结果将不是\hyperlink{5872221809740029239}{类型稳定}的，而且 \hyperlink{4551113327515323898}{\texttt{sqrt}} 函数的性能会很差。



在这样那样的情况下，若你想得到希望的结果，你可以选择一个\emph{输入类型}，它可以使根据你的想法接受一个\emph{输出类型}，从而结果可以这样表示：




\begin{minted}{jlcon}
julia> sqrt(-2.0+0im)
0.0 + 1.4142135623730951im
\end{minted}



\hypertarget{11272547309716265284}{}


\subsection{How can I constrain or compute type parameters?}



The parameters of a \href{@ref Parametric-Types}{parametric type} can hold either types or bits values, and the type itself chooses how it makes use of these parameters. For example, \texttt{Array\{Float64, 2\}} is parameterized by the type \texttt{Float64} to express its element type and the integer value \texttt{2} to express its number of dimensions.  When defining your own parametric type, you can use subtype constraints to declare that a certain parameter must be a subtype (\hyperlink{6254591906563366276}{\texttt{<:}}) of some abstract type or a previous type parameter.  There is not, however, a dedicated syntax to declare that a parameter must be a \emph{value} of a given type — that is, you cannot directly declare that a dimensionality-like parameter \hyperlink{7066325108767373297}{\texttt{isa}} \texttt{Int} within the \texttt{struct} definition, for example.  Similarly, you cannot do computations (including simple things like addition or subtraction) on type parameters.  Instead, these sorts of constraints and relationships may be expressed through additional type parameters that are computed and enforced within the type{\textquotesingle}s \hyperlink{1489967485005487723}{constructors}.



As an example, consider




\begin{minted}{julia}
struct ConstrainedType{T,N,N+1} # NOTE: INVALID SYNTAX
    A::Array{T,N}
    B::Array{T,N+1}
end
\end{minted}



where the user would like to enforce that the third type parameter is always the second plus one. This can be implemented with an explicit type parameter that is checked by an \hyperlink{5052047505447273614}{inner constructor method} (where it can be combined with other checks):




\begin{minted}{julia}
struct ConstrainedType{T,N,M}
    A::Array{T,N}
    B::Array{T,M}
    function ConstrainedType(A::Array{T,N}, B::Array{T,M}) where {T,N,M}
        N + 1 == M || throw(ArgumentError("second argument should have one more axis" ))
        new{T,N,M}(A, B)
    end
end
\end{minted}



This check is usually \emph{costless}, as the compiler can elide the check for valid concrete types. If the second argument is also computed, it may be advantageous to provide an \hyperlink{1408947822788665444}{outer constructor method} that performs this calculation:




\begin{minted}{julia}
ConstrainedType(A) = ConstrainedType(A, compute_B(A))
\end{minted}



\hypertarget{3408319939041447292}{}


\subsection{Why does Julia use native machine integer arithmetic?}



Julia使用机器算法进行整数计算。这意味着\texttt{Int}的范围是有界的，值在范围的两端循环，也就是说整数的加法，减法和乘法会出现上溢或者下溢，导致出现某些从开始就令人不安的结果：




\begin{minted}{jlcon}
julia> typemax(Int)
9223372036854775807

julia> ans+1
-9223372036854775808

julia> -ans
-9223372036854775808

julia> 2*ans
0
\end{minted}



无疑，这与数学上的整数的行为很不一样，并且你会想对于高阶编程语言来说把这个暴露给用户难称完美。然而，对于效率优先和透明度优先的数值计算来说，其他的备选方案可谓更糟。



一个备选方案是去检查每个整数运算是否溢出，如果溢出则将结果提升到更大的整数类型比如\hyperlink{8012327724714767060}{\texttt{Int128}}或者\hyperlink{423405808990690832}{\texttt{BigInt}}。 不幸的是，这会给所有的整数操作（比如让循环计数器自增）带来巨大的额外开销 — 这需要生成代码去在算法指令后进行运行溢出检测，并生成分支去处理潜在的溢出。更糟糕的是，这会让涉及整数的所有运算变得类型不稳定。如同上面提到的，对于高效生成高效的代码\hyperlink{5872221809740029239}{类型稳定很重要}。如果不指望整数运算的结果是整数，就无法想C和Fortran编译器一样生成快速简单的代码。



这个方法有个变体可以避免类型不稳定的出现，这个变体是将类型\texttt{Int}和\hyperlink{423405808990690832}{\texttt{BigInt}}合并成单个混合整数类型，当结果不再满足机器整数的大小时会内部自动切换表示。虽然表面上在Julia代码层面解决了类型不稳定，但是这个只是通过将所有的困难硬塞给实现混合整数类型的C代码而掩盖了这个问题。这个方法\emph{可能}有用，甚至在很多情况下速度很快，但是它有很多缺点。一个缺点是整数和整数数组的内存上的表示不再与C、Fortran和其他使用原生机器整数的怨言所使用的自然表示一样。所以，为了与那些语言协作，我们无论如何最终都需要引入原生整数类型。任何整数的无界表示都不会占用固定的比特数，所以无法使用固定大小的槽来内联地存储在数组中 — 大的整数值通常需要单独的堆分配的存储。并且无论使用的混合整数实现多么智能，总会存在性能陷阱 — 无法预期的性能下降的情况。复杂的表示，与C和Fortran协作能力的缺乏，无法在不使用另外的堆存储的情况下表示整数数组，和无法预测的性能特性让即使是最智能化的混合整数实现对于高性能数值计算来说也是个很差的选择。



除了使用混合整数和提升到BigInt，另一个备选方案是使用饱和整数算法，此时最大整数值加一个数时值保持不变，最小整数值减一个数时也是同样的。这就是Matlab™的做法：




\begin{lstlisting}
>> int64(9223372036854775807)

ans =

  9223372036854775807

>> int64(9223372036854775807) + 1

ans =

  9223372036854775807

>> int64(-9223372036854775808)

ans =

 -9223372036854775808

>> int64(-9223372036854775808) - 1

ans =

 -9223372036854775808
\end{lstlisting}



乍一看，这个似乎足够合理，因为9223372036854775807比-9223372036854775808更接近于9223372036854775808并且整数还是以固定大小的自然方式表示的，这与C和Fortran相兼容。但是饱和整数算法是很有问题的。首先最明显的问题是这并不是机器整数算法的工作方式，所以实现饱和整数算法需要生成指令，在每个机器整数运算后检查上溢或者下溢并正确地讲这些结果用\hyperlink{3613894539247233488}{\texttt{typemin(Int)}}或者\hyperlink{17760305803764597758}{\texttt{typemax(Int)}}取代。单单这个就将整数运算从单语句的快速的指令扩展成六个指令，还可能包括分支。哎呦喂{\textasciitilde}{\textasciitilde}但是还有更糟的 — 饱和整数算法并不满足结合律。考虑下列的Matlab计算：




\begin{lstlisting}
>> n = int64(2)^62
4611686018427387904

>> n + (n - 1)
9223372036854775807

>> (n + n) - 1
9223372036854775806
\end{lstlisting}



这就让写很多基础整数算法变得困难因为很多常用技术都是基于有溢出的机器加法\emph{是}满足结合律这一事实的。考虑一下在Julia中求整数值\texttt{lo}和\texttt{hi}之间的中点值，使用表达式\texttt{(lo + hi) >>> 1}:




\begin{minted}{jlcon}
julia> n = 2^62
4611686018427387904

julia> (n + 2n) >>> 1
6917529027641081856
\end{minted}



看到了吗？没有任何问题。那就是2{\textasciicircum}62和2{\textasciicircum}63之间的正确地中点值，虽然\texttt{n + 2n}的值是 -4611686018427387904。现在使用Matlab试一下：




\begin{lstlisting}
>> (n + 2*n)/2

ans =

  4611686018427387904
\end{lstlisting}



哎呦喂。在Matlab中添加\texttt{>>>}运算符没有任何作用，因为在将\texttt{n}与\texttt{2n}相加时已经破坏了能计算出正确地中点值的必要信息，已经出现饱和。



没有结合性不但对于不能依靠像这样的技术的程序员是不幸的，并且让几乎所有的希望优化整数算法的编译器铩羽而归。例如，因为Julia中的整数使用平常的机器整数算法，LLVM就可以自由地激进地优化像\texttt{f(k) = 5k-1}这样的简单地小函数。这个函数的机器码如下所示：




\begin{minted}{jlcon}
julia> code_native(f, Tuple{Int})
  .text
Filename: none
  pushq %rbp
  movq  %rsp, %rbp
Source line: 1
  leaq  -1(%rdi,%rdi,4), %rax
  popq  %rbp
  retq
  nopl  (%rax,%rax)
\end{minted}



这个函数的实际函数体只是一个简单地\texttt{leap}指令，可以立马计算整数乘法与加法。当\texttt{f}内联在其他函数中的时候这个更加有益：




\begin{minted}{jlcon}
julia> function g(k, n)
           for i = 1:n
               k = f(k)
           end
           return k
       end
g (generic function with 1 methods)

julia> code_native(g, Tuple{Int,Int})
  .text
Filename: none
  pushq %rbp
  movq  %rsp, %rbp
Source line: 2
  testq %rsi, %rsi
  jle L26
  nopl  (%rax)
Source line: 3
L16:
  leaq  -1(%rdi,%rdi,4), %rdi
Source line: 2
  decq  %rsi
  jne L16
Source line: 5
L26:
  movq  %rdi, %rax
  popq  %rbp
  retq
  nop
\end{minted}



因为\texttt{f}的调用内联化，循环体就只是简单地\texttt{leap}指令。接着，考虑一下如果循环迭代的次数固定的时候会发生什么：




\begin{minted}{jlcon}
julia> function g(k)
           for i = 1:10
               k = f(k)
           end
           return k
       end
g (generic function with 2 methods)

julia> code_native(g,(Int,))
  .text
Filename: none
  pushq %rbp
  movq  %rsp, %rbp
Source line: 3
  imulq $9765625, %rdi, %rax    # imm = 0x9502F9
  addq  $-2441406, %rax         # imm = 0xFFDABF42
Source line: 5
  popq  %rbp
  retq
  nopw  %cs:(%rax,%rax)
\end{minted}



因为编译器知道整数加法和乘法是满足结合律的并且乘法可以在加法上使用分配律 — 两者在饱和算法中都不成立 — 所以编译器就可以把整个循环优化到只有一个乘法和一个加法。饱和算法完全无法使用这种优化，因为在每个循环迭代中结合律和分配律都会失效导致不同的失效位置会得到不同的结果。编译器可以展开循环，但是不能代数上将多个操作简化到更少的等效操作。



让整数算法静默溢出的最合理的备用方案是所有地方都使用检查算法，当加法、减法和乘法溢出，产生不正确的值时引发错误。在\href{http://danluu.com/integer-overflow/}{blog post}中，Dan Luu分析了这个方案，发现这个方案理论上的性能微不足道，但是最终仍然会消耗大量的性能因为编译器（LLVM和GCC）无法在加法溢出检测处优雅地进行优化。如果未来有所进步我们会考虑在Julia中默认设置为检查整数算法，但是现在，我们需要和溢出可能共同相处。



In the meantime, overflow-safe integer operations can be achieved through the use of external libraries such as \href{https://github.com/JeffreySarnoff/SaferIntegers.jl}{SaferIntegers.jl}. Note that, as stated previously, the use of these libraries significantly increases the execution time of code using the checked integer types. However, for limited usage, this is far less of an issue than if it were used for all integer operations. You can follow the status of the discussion \href{https://github.com/JuliaLang/julia/issues/855}{here}.



\hypertarget{15127813284498705272}{}


\subsection{在远程执行中\texttt{UndefVarError}的可能原因有哪些？}



如同这个错误表述的，远程结点上的\texttt{UndefVarError}的直接原因是变量名的绑定并不存在。让我们探索一下一些可能的原因。




\begin{minted}{jlcon}
julia> module Foo
           foo() = remotecall_fetch(x->x, 2, "Hello")
       end

julia> Foo.foo()
ERROR: On worker 2:
UndefVarError: Foo not defined
Stacktrace:
[...]
\end{minted}



闭包\texttt{x->x}中有\texttt{Foo}的引用，因为\texttt{Foo}在节点2上不存在，所以\texttt{UndefVarError}被扔出。



在模块中而非\texttt{Main}中的全局变量不会在远程节点上按值序列化。只传递了一个引用。新建全局绑定的函数（除了\texttt{Main}中）可能会导致之后扔出\texttt{UndefVarError}。




\begin{minted}{jlcon}
julia> @everywhere module Foo
           function foo()
               global gvar = "Hello"
               remotecall_fetch(()->gvar, 2)
           end
       end

julia> Foo.foo()
ERROR: On worker 2:
UndefVarError: gvar not defined
Stacktrace:
[...]
\end{minted}



在上面的例子中，\texttt{@everywhere module Foo}在所有节点上定义了\texttt{Foo}。但是调用\texttt{Foo.foo()}在本地节点上新建了新的全局绑定\texttt{gvar}，但是节点2中并没有找到这个绑定，这会导致\texttt{UndefVarError}错误。



注意着并不适用于在模块\texttt{Main}下新建的全局变量。模块\texttt{Main}下的全局变量会被序列化并且在远程节点的\texttt{Main}下新建新的绑定。




\begin{minted}{jlcon}
julia> gvar_self = "Node1"
"Node1"

julia> remotecall_fetch(()->gvar_self, 2)
"Node1"

julia> remotecall_fetch(varinfo, 2)
name          size summary
––––––––– –––––––– –––––––
Base               Module
Core               Module
Main               Module
gvar_self 13 bytes String
\end{minted}



这并不适用于\texttt{函数}或者\texttt{结构体}声明。但是绑定到全局变量的匿名函数被序列化，如下例所示。




\begin{minted}{jlcon}
julia> bar() = 1
bar (generic function with 1 method)

julia> remotecall_fetch(bar, 2)
ERROR: On worker 2:
UndefVarError: #bar not defined
[...]

julia> anon_bar  = ()->1
(::#21) (generic function with 1 method)

julia> remotecall_fetch(anon_bar, 2)
1
\end{minted}



\hypertarget{6739766638073943445}{}


\subsection{为什么 Julia 使用 \texttt{*} 进行字符串拼接？而不是使用 \texttt{+} 或其他符号？}



使用 \texttt{+}  的\hyperlink{12933998460683957945}{主要依据}是：字符串拼接是不可交换的操作，而 \texttt{+} 通常是一个具有可交换性的操作符。Julia 社区也意识到其他语言使用了不同的操作符，一些用户也可能不熟悉 \texttt{*} 包含的特定代数性值。



注意：你也可以用 \texttt{string(...)} 来拼接字符串和其他能转换成字符串的值； 类似的 \texttt{repeat} 函数可以用于替代用于重复字符串的 \texttt{{\textasciicircum}} 操作符。 \hyperlink{4452850363638134205}{字符串插值语法}在构造字符串时也很常用。



\hypertarget{16669380183019264286}{}


\section{包和模块}



\hypertarget{18070754917834956483}{}


\subsection{{\textquotedbl}using{\textquotedbl}和{\textquotedbl}import{\textquotedbl}的区别是什么？}



只有一个区别，并且在表面上（语法层面）这个区别看来很小。\texttt{using}和\texttt{import}的区别是使用\texttt{using}时你需要写\texttt{function Foo.bar(..}来用一个新方法来扩展模块Foo的函数bar，但是使用\texttt{import Foo.bar}时，你只需要写\texttt{function bar(...}，会自动扩展模块Foo的函数bar。



这个区别足够重要以至于提供不同的语法的原因是你不希望意外地扩展一个你根本不知道其存在的函数，因为这很容易造成bug。对于使用像字符串后者整数这样的常用类型的方法最有可能出现这个问题，因为你和其他模块都可能定义了方法来处理这样的常用类型。如果你使用\texttt{import}，你会用你自己的新实现覆盖别的函数的\texttt{bar(s::AbstractString)}实现，这会导致做的事情天差地别（并且破坏模块Foo中其他的依赖于调用bar的函数的所有/大部分的将来的使用）。



\hypertarget{16234869582973036611}{}


\section{空值与缺失值}



\hypertarget{7783935872990633567}{}


\subsection{在Julia中{\textquotedbl}null{\textquotedbl}，{\textquotedbl}空{\textquotedbl}或者{\textquotedbl}缺失{\textquotedbl}是怎么工作的?}



不像其它很多语言（例如 C 和 Java），Julia 对象默认不能为{\textquotedbl}null{\textquotedbl}。当一个引用（变量，对象域，或者数组元素）没有被初始化，访问它会立即扔出一个错误。这种情况可以使用函数 \hyperlink{11212950246505288748}{\texttt{isdefined}} 或者 \hyperlink{976355747478401147}{\texttt{isassigned}} 检测到。



一些函数只为了其副作用使用，并不需要返回一个值。在这些情况下，约定的是返回 \texttt{nothing} 这个值，这只是 \texttt{Nothing} 类型的一个单例对象。这是一个没有域的一般类型；除了这个约定之外没有任何特殊点，REPL 不会为它打印任何东西。有些语言结构不会有值，也产生 \texttt{nothing}，例如 \texttt{if false; end}。



对于类型\texttt{T}的值\texttt{x}只会有时存在的情况，\texttt{Union\{T,Nothing\}}类型可以用作函数参数，对象域和数组元素的类型，与其他语言中的\href{https://en.wikipedia.org/wiki/Nullable\_type}{\texttt{Nullable}, \texttt{Option} or \texttt{Maybe}}相等。如果值本身可以是\texttt{nothing}(显然当\texttt{T}是\texttt{Any}时），\texttt{Union\{Some\{T\}, Nothing\}}类型更加准确因为\texttt{x == nothing}表示值的缺失，\texttt{x == Some(nothing)}表示与\texttt{nothing}相等的值的存在。\hyperlink{12366229165852827603}{\texttt{something}}函数允许使用默认值的展开的\texttt{Some}对象，而非\texttt{nothing}参数。注意在使用\texttt{Union\{T,Nothing\}}参数或者域时编译器能够生成高效的代码。



在统计环境下表示缺失的数据（R 中的 \texttt{NA} 或者 SQL 中的 \texttt{NULL}）请使用 \hyperlink{14596725676261444434}{\texttt{missing}} 对象。请参照\hyperlink{5842114294087241506}{\texttt{缺失值}}章节来获取详细信息。



In some languages, the empty tuple (\texttt{()}) is considered the canonical form of nothingness. However, in julia it is best thought of as just a regular tuple that happens to contain zero values.



空（或者{\textquotedbl}底层{\textquotedbl}）类型，写作\texttt{Union\{\}}（空的union类型）是没有值和子类型（除了自己）的类型。通常你没有必要用这个类型。



\hypertarget{12500994751877938228}{}


\section{内存}



\hypertarget{2527646600001256276}{}


\subsection{为什么当\texttt{x}和\texttt{y}都是数组时\texttt{x += y}还会申请内存？}



在 Julia 中，\texttt{x += y} 在语法分析中会用 \texttt{x = x + y} 代替。对于数组，结果就是它会申请一个新数组来存储结果，而非把结果存在 \texttt{x} 同一位置的内存上。



这个行为可能会让一些人吃惊，但是这个结果是经过深思熟虑的。主要原因是Julia中的不可变对象，这些对象一旦新建就不能改变他们的值。实际上，数字是不可变对象，语句\texttt{x = 5; x += 1}不会改变\texttt{5}的意义，改变的是与\texttt{x}绑定的值。对于不可变对象，改变其值的唯一方法是重新赋值。



为了稍微详细一点，考虑下列的函数：




\begin{minted}{julia}
function power_by_squaring(x, n::Int)
    ispow2(n) || error("此实现只适用于2的幂")
    while n >= 2
        x *= x
        n >>= 1
    end
    x
end
\end{minted}



在\texttt{x = 5; y = power\_by\_squaring(x, 4)}调用后，你可以得到期望的结果\texttt{x == 5 \&\& y == 625}。然而，现在假设当\texttt{*=}与矩阵一起使用时会改变左边的值，这会有两个问题：



\begin{itemize}
\item 对于普通的方阵，\texttt{A = A*B} 不能在没有临时存储的情况下实现：\texttt{A[1,1]} 会被计算并且在被右边使用完之前存储在左边。


\item 假设你愿意申请一个计算的临时存储（这会消除 \texttt{*=}就地计算的大部分要点）；如果你利用了\texttt{x}的可变性， 这个函数会对于可变和不可变的输入有不同的行为。特别地， 对于不可变的\texttt{x}，在调用后（通常）你会得到\texttt{y != x}，而对可变的\texttt{x}，你会有\texttt{y == x}。

\end{itemize}


因为支持范用计算被认为比能使用其他方法完成的潜在的性能优化（比如使用显式循环）更加重要，所以像\texttt{+=}和\texttt{*=}运算符以绑定新值的方式工作。



\hypertarget{11478691918903630142}{}


\section{异步 IO 与并发同步写入}



\hypertarget{6102848140854273508}{}


\subsection{为什么对于同一个流的并发写入会导致相互混合的输出？}



虽然流式 I/O 的 API 是同步的，底层的实现是完全异步的。



思考一下下面的输出：




\begin{minted}{jlcon}
julia> @sync for i in 1:3
           @async write(stdout, string(i), " Foo ", " Bar ")
       end
123 Foo  Foo  Foo  Bar  Bar  Bar
\end{minted}



这是因为，虽然\texttt{write}调用是同步的，每个参数的写入在等待那一部分I/O完成时会生成其他的Tasks。



\texttt{print}和\texttt{println}在调用中会{\textquotedbl}锁定{\textquotedbl}该流。因此把上例中的\texttt{write}改成\texttt{println}会导致：




\begin{minted}{jlcon}
julia> @sync for i in 1:3
           @async println(stdout, string(i), " Foo ", " Bar ")
       end
1 Foo  Bar
2 Foo  Bar
3 Foo  Bar
\end{minted}



你可以使用\texttt{ReentrantLock}来锁定你的写入，就像这样：




\begin{minted}{jlcon}
julia> l = ReentrantLock();

julia> @sync for i in 1:3
           @async begin
               lock(l)
               try
                   write(stdout, string(i), " Foo ", " Bar ")
               finally
                   unlock(l)
               end
           end
       end
1 Foo  Bar 2 Foo  Bar 3 Foo  Bar
\end{minted}



\hypertarget{11524621654961197830}{}


\section{数组}



\hypertarget{8539259979709593447}{}


\subsection{零维数组和标量之间的有什么差别？}



零维数组是\texttt{Array\{T,0\}}形式的数组，它与标量的行为相似，但是有很多重要的不同。这值得一提，因为这是使用数组的范用定义来解释也符合逻辑的特殊情况，虽然最开始看起来有些非直觉。下面一行定义了一个零维数组：




\begin{lstlisting}
julia> A = zeros()
0-dimensional Array{Float64,0}:
0.0
\end{lstlisting}



在这个例子中，\texttt{A}是一个含有一个元素的可变容器，这个元素可以通过\texttt{A[] = 1.0}来设置，通过\texttt{A[]}来读取。所有的零维数组都有同样的大小（\texttt{size(A) == ()}）和长度（\texttt{length(A) == 1}）。特别地，零维数组不是空数组。如果你觉得这个非直觉，这里有些想法可以帮助理解Julia的这个定义。



\begin{itemize}
\item 类比的话，零维数组是{\textquotedbl}点{\textquotedbl}，向量是{\textquotedbl}线{\textquotedbl}而矩阵 是{\textquotedbl}面{\textquotedbl}。就像线没有面积一样（但是也能代表事物的一个集合）, 点没有长度和任意一个维度（但是也能表示一个事物）。


\item 我们定义\texttt{prod(())}为1，一个数组中的所有的元素个数是 大小的乘积。零维数组的大小为\texttt{()}，所以 它的长度为\texttt{1}。


\item 零维数组原生没有任何你可以索引的维度 – 它们仅仅是\texttt{A[]}。我们可以给它们应用同样的{\textquotedbl}trailing one{\textquotedbl}规则， as for all other array dimensionalities, so you can indeed index them as \texttt{A[1]}, \texttt{A[1,1]}, etc; see \hyperlink{16741454967402507490}{Omitted and extra indices}.

\end{itemize}


理解它与普通的标量之间的区别也很重要。标量不是一个可变的容器（尽管它们是可迭代的，可以定义像\texttt{length}，\texttt{getindex}这样的东西，\emph{例如}\texttt{1[] == 1}）。特别地，如果\texttt{x = 0.0}是以一个标量来定义，尝试通过\texttt{x[] = 1.0}来改变它的值会报错。标量\texttt{x}能够通过\texttt{fill(x)}转化成包含它的零维数组，并且相对地，一个零维数组\texttt{a}可以通过\texttt{a[]}转化成其包含的标量。另外一个区别是标量可以参与到线性代数运算中，比如\texttt{2 * rand(2,2)}，但是零维数组的相似操作\texttt{fill(2) * rand(2,2)}会报错。



\hypertarget{2217516185420134366}{}


\subsection{Why are my Julia benchmarks for linear algebra operations different from other languages?}



You may find that simple benchmarks of linear algebra building blocks like




\begin{minted}{julia}
using BenchmarkTools
A = randn(1000, 1000)
B = randn(1000, 1000)
@btime $A \ $B
@btime $A * $B
\end{minted}



can be different when compared to other languages like Matlab or R.



Since operations like this are very thin wrappers over the relevant BLAS functions, the reason for the discrepancy is very likely to be



\begin{itemize}
\item[1. ] the BLAS library each language is using,


\item[2. ] the number of concurrent threads.

\end{itemize}


Julia compiles and uses its own copy of OpenBLAS, with threads currently capped at \texttt{8} (or the number of your cores).



Modifying OpenBLAS settings or compiling Julia with a different BLAS library, eg \href{https://software.intel.com/en-us/mkl}{Intel MKL}, may provide performance improvements. You can use \href{https://github.com/JuliaComputing/MKL.jl}{MKL.jl}, a package that makes Julia{\textquotesingle}s linear algebra use Intel MKL BLAS and LAPACK instead of OpenBLAS, or search the discussion forum for suggestions on how to set this up manually. Note that Intel MKL cannot be bundled with Julia, as it is not open source.



\hypertarget{13975497382718262394}{}


\section{Julia 版本发布}



\hypertarget{15044504752514653644}{}


\subsection{Do I want to use the Stable, LTS, or nightly version of Julia?}



The Stable version of Julia is the latest released version of Julia, this is the version most people will want to run. It has the latest features, including improved performance. The Stable version of Julia is versioned according to \href{https://semver.org/}{SemVer} as v1.x.y. A new minor release of Julia corresponding to a new Stable version is made approximately every 4-5 months after a few weeks of testing as a release candidate. Unlike the LTS version the a Stable version will not normally recieve bugfixes after another Stable version of Julia has been released. However, upgrading to the next Stable release will always be possible as each release of Julia v1.x will continue to run code written for earlier versions.



You may prefer the LTS (Long Term Support) version of Julia if you are looking for a very stable code base. The current LTS version of Julia is versioned according to SemVer as v1.0.x; this branch will continue to recieve bugfixes until a new LTS branch is chosen, at which point the v1.0.x series will no longer recieved regular bug fixes and all but the most conservative users will be advised to upgrade to the new LTS version series. As a package developer, you may prefer to develop for the LTS version, to maximize the number of users who can use your package. As per SemVer, code written for v1.0 will continue to work for all future LTS and Stable versions. In general, even if targetting the LTS, one can develop and run code in the latest Stable version, to take advantage of the improved performance; so long as one avoids using new features (such as added library functions or new methods).



You may prefer the nightly version of Julia if you want to take advantage of the latest updates to the language, and don{\textquotesingle}t mind if the version available today occasionally doesn{\textquotesingle}t actually work. As the name implies, releases to the nightly version are made roughly every night (depending on build infrastructure stability). In general nightly released are fairly safe to use—your code will not catch on fire. However, they may be occasional regressions and or issues that will not be found until more thorough pre-release testing. You may wish to test against the nightly version to ensure that such regressions that affect your use case are caught before a release is made.



Finally, you may also consider building Julia from source for yourself. This option is mainly for those individuals who are comfortable at the command line, or interested in learning. If this describes you, you may also be interested in reading our \href{https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md}{guidelines for contributing}.



可以在\href{https://julialang.org/downloads/}{https://julialang.org/downloads/}的下载页面上找到每种下载类型的链接。 请注意，并非所有版本的Julia都适用于所有平台。



\hypertarget{8132004312407744699}{}


\chapter{与其他语言的显著差异}



\hypertarget{17394269940611152566}{}


\section{与 MATLAB 的显著差异}



虽然 MATLAB 用户可能会发现 Julia 的语法很熟悉，但 Julia 不是 MATLAB 的克隆。 它们之间存在重大的语法和功能差异。 以下是一些可能会使习惯于 MATLAB 的 Julia 用户感到困扰的显著差异：



\begin{itemize}
\item Julia 数组使用方括号 \texttt{A[i,j]} 进行索引。


\item Julia 的数组在赋值给另一个变量时不发生复制。执行 \texttt{A = B} 后，改变 \texttt{B} 中元素也会修改 \texttt{A}。


\item Julia 的值在向函数传递时不发生复制。如果某个函数修改了数组，这一修改对调用者是可见的。


\item Julia 不会在赋值语句中自动增长数组。 而在 MATLAB 中 \texttt{a(4) = 3.2} 可以创建数组 \texttt{a = [0 0 0 3.2]}，而 \texttt{a(5) = 7} 可以将它增长为 \texttt{a = [0 0 0 3.2 7]}。如果 \texttt{a} 的长度小于 5 或者这个语句是第一次使用标识符 \texttt{a}，则相应的 Julia 语句 \texttt{a[5] = 7} 会抛出错误。Julia 使用 \hyperlink{18026893834387542681}{\texttt{push!}} 和 \hyperlink{2587432243763606566}{\texttt{append!}} 来增长 \texttt{Vector}，它们比 MATLAB 的 \texttt{a(end+1) = val} 更高效。


\item 虚数单位 \texttt{sqrt(-1)} 在 Julia 中表示为 \hyperlink{15097910740298861288}{\texttt{im}}，而不是在 MATLAB 中的 \texttt{i} 或 \texttt{j}。


\item 在 Julia 中，没有小数点的数字字面量（例如 \texttt{42}）会创建整数而不是浮点数。也支持任意大整数字面量。因此，某些操作（如 \texttt{2{\textasciicircum}-1}）将抛出 domain error，因为结果不是整数（有关的详细信息，请参阅\hyperlink{1677964623674152967}{常见问题中有关 domain errors 的条目}）。 point numbers. As a result, some operations can throw a domain error if they expect a float; for example, \texttt{julia> a = -1; 2{\textasciicircum}a} throws a domain error, as the result is not an integer (see \hyperlink{1677964623674152967}{the FAQ entry on domain errors} for details).


\item 在 Julia 中，能返回多个值并将其赋值为元组，例如 \texttt{(a, b) = (1, 2)} 或 \texttt{a, b = 1, 2}。 在 Julia 中不存在 MATLAB 的 \texttt{nargout}，它通常在 MATLAB 中用于根据返回值的数量执行可选工作。取而代之的是，用户可以使用可选参数和关键字参数来实现类似的功能。


\item Julia 拥有真正的一维数组。列向量的大小为 \texttt{N}，而不是 \texttt{Nx1}。例如，\hyperlink{7668863842145012694}{\texttt{rand(N)}} 创建一个一维数组。


\item 在 Julia 中，\texttt{[x,y,z]} 将始终构造一个包含\texttt{x}、\texttt{y} 和 \texttt{z} 的 3 元数组。

\begin{itemize}
\item 要在第一个维度（「垂直列」）中连接元素，请使用 \hyperlink{14691815416955507876}{\texttt{vcat(x,y,z)}} 或用分号分隔（\texttt{[x; y; z]}）。


\item 要在第二个维度（「水平行」）中连接元素，请使用 \hyperlink{8862791894748483563}{\texttt{hcat(x,y,z)}} 或用空格分隔（\texttt{[x y z]}）。


\item 要构造分块矩阵（在前两个维度中连接元素），请使用 \hyperlink{16279083053557795116}{\texttt{hvcat}} 或组合空格和分号（\texttt{[a b; c d]}）。

\end{itemize}

\item 在 Julia 中，\texttt{a:b} 和 \texttt{a:b:c} 构造 \texttt{AbstractRange} 对象。使用 \hyperlink{6278865767444641812}{\texttt{collect(a:b)}} 构造一个类似 MATLAB 中完整的向量。通常，不需要调用 \texttt{collect}。在大多数情况下，\texttt{AbstractRange} 对象将像普通数组一样运行，但效率更高，因为它是懒惰求值。这种创建专用对象而不是完整数组的模式经常被使用，并且也可以在诸如 \hyperlink{737600656772861535}{\texttt{range}} 之类的函数中看到，或者在诸如 \texttt{enumerate} 和 \texttt{zip} 之类的迭代器中看到。特殊对象大多可以像正常数组一样使用。


\item Julia 中的函数返回其最后一个表达式或 \texttt{return} 关键字的值而无需在函数定义中列出要返回的变量的名称（有关详细信息，请参阅 \hyperlink{16317991580998959177}{return 关键字}）。


\item Julia 脚本可以包含任意数量的函数，并且在加载文件时，所有定义都将在外部可见。可以从当前工作目录之外的文件加载函数定义。


\item 在 Julia 中，例如 \hyperlink{8666686648688281595}{\texttt{sum}}、\hyperlink{13484084847910116333}{\texttt{prod}} 和 \hyperlink{7839419811914289844}{\texttt{max}} 的归约操作会作用到数组的每一个元素上，当调用时只有一个函数，例如 \texttt{sum(A)}，即使 \texttt{A} 并不只有一个维度。


\item 在 Julia 中，调用无参数的函数时必须使用小括号，例如 \hyperlink{7668863842145012694}{\texttt{rand()}}。


\item Julia 不鼓励使用分号来结束语句。语句的结果不会自动打印（除了在 REPL 中），并且代码的一行不必使用分号结尾。\hyperlink{783803254548423222}{\texttt{println}} 或者 \hyperlink{13954719910189591998}{\texttt{@printf}} 能用来打印特定输出。


\item 在 Julia 中，如果 \texttt{A} 和 \texttt{B} 是数组，像 \texttt{A == B} 这样的逻辑比较运算符不会返回布尔值数组。相反地，请使用 \texttt{A .== B}。对于其他的像是 \hyperlink{702782232449268329}{\texttt{<}}、\hyperlink{8677991761303191103}{\texttt{>}} 的布尔运算符同理。


\item 在 Julia 中，运算符\hyperlink{1494761116451616317}{\texttt{\&}}、\hyperlink{9633687763646488853}{\texttt{|}} 和 \hyperlink{7071880015536674935}{\texttt{\unicodeveebar{}}}（\hyperlink{7071880015536674935}{\texttt{xor}}）进行按位操作，分别与MATLAB中的\texttt{and}、\texttt{or} 和 \texttt{xor} 等价，并且优先级与 Python 的按位运算符相似（不像 C）。他们可以对标量运算或者数组中逐元素运算，可以用来合并逻辑数组，但是注意运算顺序的区别：括号可能是必要的（例如，选择 \texttt{A} 中等于 1 或 2 的元素可使用 \texttt{(A .== 1) .| (A .== 2)}）。


\item 在 Julia 中，集合的元素可以使用 splat 运算符 \texttt{...} 来作为参数传递给函数，如 \texttt{xs=[1,2]; f(xs...)}。


\item Julia 的 \hyperlink{6661056220970412040}{\texttt{svd}} 将奇异值作为向量而非密集对角矩阵返回。


\item 在 Julia 中，\texttt{...} 不用于延续代码行。不同的是，Julia 中不完整的表达式会自动延续到下一行。


\item 在 Julia 和 MATLAB 中，变量 \texttt{ans} 被设置为交互式会话中提交的最后一个表达式的值。在 Julia 中与 MATLAB 不同的是，当 Julia 代码以非交互式模式运行时并不会设置 \texttt{ans}。


\item Julia 的 \texttt{struct} 不支持在运行时动态地添加字段，这与 MATLAB 的 \texttt{class} 不同。如需支持，请使用 \hyperlink{3089397136845322041}{\texttt{Dict}}。


\item 在 Julia 中，每个模块有自身的全局作用域/命名空间，而在 MATLAB 中只有一个全局作用域。


\item 在 MATLAB 中，删除不需要的值的惯用方法是使用逻辑索引，如表达式 \texttt{x(x>3)} 或语句 \texttt{x(x>3) = []} 来 in-place 修改 \texttt{x}。相比之下，Julia 提供了更高阶的函数 \hyperlink{11445961893478569145}{\texttt{filter}} 和 \hyperlink{3384092630307389071}{\texttt{filter!}}，允许用户编写 \texttt{filter(z->z>3, x)} 和 \texttt{filter!(z->z>3, x)} 来代替相应直译 \texttt{x[x.>3]} 和 \texttt{x = x[x.>3]}。使用 \hyperlink{3384092630307389071}{\texttt{filter!}} 可以减少临时数组的使用。


\item 类似于提取（或「解引用」）元胞数组的所有元素的操作，例如 MATLAB 中的 \texttt{vertcat(A\{:\})}，在 Julia 中是使用 splat 运算符编写的，例如 \texttt{vcat(A...)}。


\item In Julia, the \texttt{adjoint} function performs conjugate transposition; in MATLAB, \texttt{adjoint} provides the {\textquotedbl}adjugate{\textquotedbl} or classical adjoint, which is the transpose of the matrix of cofactors.

\end{itemize}


\hypertarget{8033006673941157229}{}


\section{与 R 的显著差异}



Julia 的目标之一是为数据分析和统计编程提供高效的语言。对于从 R 转到 Julia 的用户来说，这是一些显著差异：



\begin{itemize}
\item Julia 的单引号封闭字符，而不是字符串。


\item Julia 可以通过索引字符串来创建子字符串。在 R 中，在创建子字符串之前必须将字符串转换为字符向量。


\item 在 Julia 中，与 Python 相同但与 R 不同的是，字符串可由三重引号 \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl} ... {\textquotedbl}{\textquotedbl}{\textquotedbl}} 创建。此语法对于构造包含换行符的字符串很方便。


\item 在 Julia 中，可变参数使用 splat 运算符 \texttt{...} 指定，该运算符总是跟在具体变量的名称后面，与 R 的不同，R 的 \texttt{...} 可以单独出现。


\item 在 Julia 中，模数是 \texttt{mod(a, b)}，而不是 \texttt{a \%\% b}。Julia 中的 \texttt{\%} 是余数运算符。


\item 在 Julia 中，并非所有数据结构都支持逻辑索引。此外，Julia 中的逻辑索引只支持长度等于被索引对象的向量。例如：

\begin{itemize}
\item 在 R 中，\texttt{c(1, 2, 3, 4)[c(TRUE, FALSE)]} 等价于 \texttt{c(1, 3)}。


\item 在 R 中，\texttt{c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]} 等价于 \texttt{c(1, 3)}。


\item 在 Julia 中，\texttt{[1, 2, 3, 4][[true, false]]} 抛出 \hyperlink{9731558909100893938}{\texttt{BoundsError}}。


\item 在 Julia 中，\texttt{[1, 2, 3, 4][[true, false, true, false]]} 产生 \texttt{[1, 3]}。

\end{itemize}

\item 与许多语言一样，Julia 并不总是允许对不同长度的向量进行操作，与 R 不同，R 中的向量只需要共享一个公共的索引范围。例如，\texttt{c(1, 2, 3, 4) + c(1, 2)} 是有效的 R，但等价的 \texttt{[1, 2, 3, 4] + [1, 2]} 在 Julia 中会抛出一个错误。


\item 在逗号不改变代码含义时，Julia 允许使用可选的尾随括号。在索引数组时，这可能在 R 用户间造成混淆。例如，R 中的 \texttt{x[1,]} 将返回矩阵的第一行；但是，在 Julia 中，引号被忽略，于是 \texttt{x[1,] == x[1]}，并且将返回第一个元素。要提取一行，请务必使用 \texttt{:}，如 \texttt{x[1,:]}。


\item Julia 的 \hyperlink{11483231213869150535}{\texttt{map}} 首先接受函数，然后是该函数的参数，这与 R 中的 \texttt{lapply(<structure>, function, ...)} 不同。类似地，R 中的 \texttt{apply(X, MARGIN, FUN, ...)} 等价于 Julia 的 \hyperlink{8678396932318499078}{\texttt{mapslices}}，其中函数是第一个参数。


\item R 中的多变量 apply，如 \texttt{mapply(choose, 11:13, 1:3)}，在 Julia 中可以编写成 \texttt{broadcast(binomial, 11:13, 1:3)}。等价地，Julia 提供了更短的点语法来向量化函数 \texttt{binomial.(11:13, 1:3)}。


\item Julia 使用 \texttt{end} 来表示条件块（如 \texttt{if}）、循环块（如 \texttt{while}/\texttt{for}）和函数的结束。为了代替单行 \texttt{if ( cond ) statement}，Julia 允许形式为 \texttt{if cond; statement; end}、\texttt{cond \&\& statement} 和 \texttt{!cond || statement} 的语句。后两种语法中的赋值语句必须显式地包含在括号中，例如 \texttt{cond \&\& (x = value)}，这是因为运算符的优先级。


\item 在 Julia 中，\texttt{<-}, \texttt{<<-} 和 \texttt{->} 不是赋值运算符。


\item Julia 的 \texttt{->} 创建一个匿名函数。


\item Julia 使用括号构造向量。Julia 的 \texttt{[1, 2, 3]} 等价于 R 的 \texttt{c(1, 2, 3)}。


\item Julia 的 \hyperlink{7592762607639177347}{\texttt{*}} 运算符可以执行矩阵乘法，这与 R 不同。如果 \texttt{A} 和 \texttt{B} 都是矩阵，那么 \texttt{A * B} 在 Julia 中表示矩阵乘法，等价于 R 的 \texttt{A \%*\% B}。在 R 中，相同的符号将执行逐元素（Hadamard）乘积。要在 Julia 中使用逐元素乘法运算，你需要编写 \texttt{A .* B}。


\item Julia 使用 \texttt{transpose} 函数来执行矩阵转置，使用 \texttt{{\textquotesingle}} 运算符或 \texttt{adjoint} 函数来执行共轭转置。因此，Julia 的 \texttt{transpose(A)} 等价于 R 的 \texttt{t(A)}。另外，Julia 中的非递归转置由 \texttt{permutedims} 函数提供。


\item Julia 在编写 \texttt{if} 语句或 \texttt{for}/\texttt{while} 循环时不需要括号：请使用 \texttt{for i in [1, 2, 3]} 代替 \texttt{for (int i=1; i <= 3; i++)}，以及 \texttt{if i == 1} 代替 \texttt{if (i == 1)}


\item Julia 不把数字 \texttt{0} 和 \texttt{1} 视为布尔值。在 Julia 中不能编写 \texttt{if (1)}，因为 \texttt{if} 语句只接受布尔值。相反，可以编写 \texttt{if true}、\texttt{if Bool(1)} 或 \texttt{if 1==1}。


\item Julia 不提供 \texttt{nrow} 和 \texttt{ncol}。相反，请使用 \texttt{size(M, 1)} 代替 \texttt{nrow(M)} 以及 \texttt{size(M, 2)} 代替 \texttt{ncol(M)}


\item Julia 仔细区分了标量、向量和矩阵。在 R 中，\texttt{1} 和 \texttt{c(1)} 是相同的。在 Julia 中，它们不能互换地使用。


\item Julia 的 \hyperlink{17079356950356685026}{\texttt{diag}} 和 \hyperlink{18133091318829836689}{\texttt{diagm}} 与 R 的不同。


\item Julia 赋值操作的左侧不能为函数调用的结果：你不能编写 \texttt{diag(M) = fill(1, n)}。


\item Julia 不鼓励使用函数填充主命名空间。Julia 的大多数统计功能都可在 \href{https://github.com/JuliaStats}{JuliaStats 组织}的\href{https://pkg.julialang.org/}{包}中找到。例如：

\begin{itemize}
\item 与概率分布相关的函数由 \href{https://github.com/JuliaStats/Distributions.jl}{Distributions 包}提供。


\item \href{https://github.com/JuliaData/DataFrames.jl}{DataFrames 包}提供数据帧。


\item 广义线性模型由 \href{https://github.com/JuliaStats/GLM.jl}{GLM 包}提供。

\end{itemize}

\item Julia 提供了元组和真正的哈希表，但不提供 R 风格的列表。在返回多个项时，通常应使用元组或具名元组：请使用 \texttt{(1, 2)} 或 \texttt{(a=1, b=2)} 代替 \texttt{list(a = 1, b = 2)}。


\item Julia 鼓励用户编写自己的类型，它比 R 中的 S3 或 S4 对象更容易使用。Julia 的多重派发系统意味着 \texttt{table(x::TypeA)} 和 \texttt{table(x::TypeB)} 类似于 R 的 \texttt{table.TypeA(x)} 和 \texttt{table.TypeB(x)}。


\item Julia 的值在向函数传递时不发生复制。如果某个函数修改了数组，这一修改对调用者是可见的。这与 R 非常不同，允许新函数更高效地操作大型数据结构。


\item 在 Julia 中，向量和矩阵使用 \hyperlink{8862791894748483563}{\texttt{hcat}}、\hyperlink{14691815416955507876}{\texttt{vcat}} 和 \hyperlink{16279083053557795116}{\texttt{hvcat}} 拼接，而不是像在 R 中那样使用 \texttt{c}、\texttt{rbind} 和 \texttt{cbind}。


\item 在 Julia 中，像 \texttt{a:b} 这样的 range 不是 R 中的向量简写，而是一个专门的 \texttt{AbstractRange} 对象，该对象用于没有高内存开销地进行迭代。要将 range 转换为 vector，请使用 \hyperlink{6278865767444641812}{\texttt{collect(a:b)}}。


\item Julia 的 \hyperlink{7839419811914289844}{\texttt{max}} 和 \hyperlink{7458766354532817148}{\texttt{min}} 分别等价于 R 中的 \texttt{pmax} 和 \texttt{pmin}，但两者的参数都需要具有相同的维度。虽然 \hyperlink{14719513931696680717}{\texttt{maximum}} 和 \hyperlink{13126064576294034099}{\texttt{minimum}} 代替了 R 中的 \texttt{max} 和 \texttt{min}，但它们之间有重大区别。


\item Julia 的 \hyperlink{8666686648688281595}{\texttt{sum}}、\hyperlink{13484084847910116333}{\texttt{prod}}、\hyperlink{14719513931696680717}{\texttt{maximum}} 和 \hyperlink{13126064576294034099}{\texttt{minimum}} 与它们在 R 中的对应物不同。它们都接受一个可选的关键字参数 \texttt{dims}，它表示执行操作的维度。例如，在 Julia 中令 \texttt{A = [1 2; 3 4]}，在 R 中令 \texttt{B <- rbind(c(1,2),c(3,4))} 是与之相同的矩阵。然后 \texttt{sum(A)} 得到与 \texttt{sum(B)} 相同的结果，但 \texttt{sum(A, dims=1)} 是一个包含每一列总和的行向量，\texttt{sum(A, dims=2)} 是一个包含每一行总和的列向量。这与 R 的行为形成了对比，在 R 中，单独的 \texttt{colSums(B)} 和 \texttt{rowSums(B)} 提供了这些功能。如果 \texttt{dims} 关键字参数是向量，则它指定执行求和的所有维度，并同时保持待求和数组的维数，例如 \texttt{sum(A, dims=(1,2)) == hcat(10)}。应该注意的是，没有针对第二个参数的错误检查。


\item Julia 具有一些可以改变其参数的函数。例如，它具有 \hyperlink{8473525809131227606}{\texttt{sort}} 和 \hyperlink{12296873681374954808}{\texttt{sort!}}。


\item 在 R 中，高性能需要向量化。在 Julia 中，这几乎恰恰相反：性能最高的代码通常通过去向量化的循环来实现。


\item Julia 是立即求值的，不支持 R 风格的惰性求值。对于大多数用户来说，这意味着很少有未引用的表达式或列名。


\item Julia 不支持 \texttt{NULL} 类型。最接近的等价物是 \hyperlink{9331422207248206047}{\texttt{nothing}}，但它的行为类似于标量值而不是列表。请使用 \texttt{x === nothing} 代替 \texttt{is.null(x)}。


\item 在 Julia 中，缺失值由 \hyperlink{14596725676261444434}{\texttt{missing}} 表示，而不是由 \texttt{NA} 表示。请使用 \hyperlink{3452327148507948899}{\texttt{ismissing(x)}}（或者在向量上使用逐元素操作 \texttt{ismissing.(x)}）代替 \texttt{isna(x)}。通常使用 \hyperlink{2012470681884771400}{\texttt{skipmissing}} 代替 \texttt{na.rm=TRUE}（尽管在某些特定情况下函数接受 \texttt{skipmissing} 参数）。


\item Julia 缺少 R 中的 \texttt{assign} 或 \texttt{get} 的等价物。


\item 在 Julia 中，\texttt{return} 不需要括号。


\item 在 R 中，删除不需要的值的惯用方法是使用逻辑索引，如表达式 \texttt{x[x>3]} 或语句 \texttt{x = x[x>3]} 来 in-place 修改 \texttt{x}。相比之下，Julia 提供了更高阶的函数 \hyperlink{11445961893478569145}{\texttt{filter}} 和 \hyperlink{3384092630307389071}{\texttt{filter!}}，允许用户编写 \texttt{filter(z->z>3, x)} 和 \texttt{filter!(z->z>3, x)} 来代替相应直译 \texttt{x[x.>3]} 和 \texttt{x = x[x.>3]}。使用 \hyperlink{3384092630307389071}{\texttt{filter!}} 可以减少临时数组的使用。

\end{itemize}


\hypertarget{13471211736636773349}{}


\section{与 Python 的显著差异}



\begin{itemize}
\item Julia 的 \texttt{for}、\texttt{if}、\texttt{while}等代码块由\texttt{end}关键字终止。缩进级别并不像在 Python 中那么重要。 is not significant as it is in Python. Unlike Python, Julia has no \texttt{pass} keyword.


\item Strings are denoted by double quotation marks (\texttt{{\textquotedbl}text{\textquotedbl}}) in Julia (with three double quotation marks for multi-line strings), whereas in Python they can be denoted either by single (\texttt{{\textquotesingle}text{\textquotesingle}}) or double quotation marks (\texttt{{\textquotedbl}text{\textquotedbl}}). Single quotation marks are used for characters in Julia (\texttt{{\textquotesingle}c{\textquotesingle}}).


\item String concatenation is done with \texttt{*} in Julia, not \texttt{+} like in Python. Analogously, string repetition is done with \texttt{{\textasciicircum}}, not \texttt{*}. Implicit string concatenation of string literals like in Python (e.g. \texttt{{\textquotesingle}ab{\textquotesingle} {\textquotesingle}cd{\textquotesingle} == {\textquotesingle}abcd{\textquotesingle}}) is not done in Julia.


\item Python Lists—flexible but slow—correspond to the Julia \texttt{Vector\{Any\}} type or more generally \texttt{Vector\{T\}} where \texttt{T} is some non-concrete element type. {\textquotedbl}Fast{\textquotedbl} arrays like Numpy arrays that store elements in-place (i.e., \texttt{dtype} is \texttt{np.float64}, \texttt{[({\textquotesingle}f1{\textquotesingle}, np.uint64), ({\textquotesingle}f2{\textquotesingle}, np.int32)]}, etc.) can be represented by \texttt{Array\{T\}} where \texttt{T} is a concrete, immutable element type. This includes built-in types like \texttt{Float64}, \texttt{Int32}, \texttt{Int64} but also more complex types like \texttt{Tuple\{UInt64,Float64\}} and many user-defined types as well.


\item 在 Julia 中，数组、字符串等的索引从 1 开始，而不是从 0 开始。


\item Julia 的切片索引包含最后一个元素，这与 Python 不同。Julia 中的 \texttt{a[2:3]} 就是 Python 中的 \texttt{a[1:3]}。


\item Julia 不支持负数索引。特别地，列表或数组的最后一个元素在 Julia 中使用 \texttt{end} 索引，而不像在 Python 中使用 \texttt{-1}。


\item Julia requires \texttt{end} for indexing until the last element. \texttt{x[1:]} in Python is equivalent to \texttt{x[2:end]} in Julia.


\item Julia{\textquotesingle}s range indexing has the format of \texttt{x[start:step:stop]}, whereas Python{\textquotesingle}s format is \texttt{x[start:(stop+1):step]}. Hence, \texttt{x[0:10:2]} in Python is equivalent to \texttt{x[1:2:10]} in Julia. Similarly, \texttt{x[::-1]} in Python, which refers to the reversed array, is equivalent to \texttt{x[end:-1:1]} in Julia.


\item In Julia, indexing a matrix with arrays like \texttt{X[[1,2], [1,3]]} refers to a sub-matrix that contains the intersections of the first and second rows with the first and third columns. In Python, \texttt{X[[1,2], [1,3]]} refers to a vector that contains the values of cell \texttt{[1,1]} and \texttt{[2,3]} in the matrix. \texttt{X[[1,2], [1,3]]} in Julia is equivalent with \texttt{X[np.ix\_([0,1],[0,2])]} in Python. \texttt{X[[0,1], [0,2]]} in Python is equivalent with \texttt{X[[CartesianIndex(1,1), CartesianIndex(2,3)]]} in Julia.


\item Julia 没有用来续行的语法：如果在行的末尾，到目前为止的输入是一个完整的表达式，则认为其已经结束；否则，认为输入继续。强制表达式继续的一种方式是将其包含在括号中。


\item 默认情况下，Julia 数组是列优先的（Fortran 顺序），而 NumPy 数组是行优先（C 顺序）。为了在循环数组时获得最佳性能，循环顺序应该在 Julia 中相对于 NumPy 反转（请参阅 \hyperlink{818954303942149020}{Performance Tips} 中的对应章节）。

be reversed in Julia relative to NumPy (see \hyperlink{11239800376478112527}{relevant section of Performance Tips}).


\item Julia 的更新运算符（例如 \texttt{+=}，\texttt{-=}，···）是 \emph{not in-place}，而 Numpy 的是。这意味着 \texttt{A = [1, 1]; B = A; B += [3, 3]} 不会改变 \texttt{A} 中的值，而将名称 \texttt{B} 重新绑定到右侧表达式 \texttt{B = B + 3} 的结果，这是一个新的数组。对于 in-place 操作，使用 \texttt{B .+= 3}（另请参阅 \hyperlink{15967322336376951940}{dot operators}）、显式的循环或者 \texttt{InplaceOps.jl}。


\item 每次调用方法时，Julia 都会计算函数参数的默认值，不像在 Python 中，默认值只会在函数定义时被计算一次。例如，每次无输入参数调用时，函数\texttt{f(x=rand()) = x}都返回一个新的随机数在另一方面，函数 \texttt{g(x=[1,2]) = push!(x,3)} 在每次以 \texttt{g()} 调用时返回 \texttt{[1,2,3]}。


\item 在 Julia 中，\texttt{\%} 是余数运算符，而在 Python 中是模运算符。


\item In Julia, the commonly used \texttt{Int} type corresponds to the machine integer type (\texttt{Int32} or \texttt{Int64}), unlike in Python, where \texttt{int} is an arbitrary length integer. This means in Julia the \texttt{Int} type will overflow, such that \texttt{2{\textasciicircum}64 == 0}. If you need larger values use another appropriate type, such as \texttt{Int128}, \hyperlink{423405808990690832}{\texttt{BigInt}} or a floating point type like \texttt{Float64}.


\item The imaginary unit \texttt{sqrt(-1)} is represented in Julia as \texttt{im}, not \texttt{j} as in Python.


\item In Julia, the exponentiation operator is \texttt{{\textasciicircum}}, not \texttt{**} as in Python.


\item Julia uses \texttt{nothing} of type \texttt{Nothing} to represent a null value, whereas Python uses \texttt{None} of type \texttt{NoneType}.


\item In Julia, the standard operators over a matrix type are matrix operations, whereas, in Python, the standard operators are element-wise operations. When both \texttt{A} and \texttt{B} are matrices, \texttt{A * B} in Julia performs matrix multiplication, not element-wise multiplication as in Python. \texttt{A * B} in Julia is equivalent with \texttt{A @ B} in Python, whereas \texttt{A * B} in Python is equivalent with \texttt{A .* B} in Julia.


\item The adjoint operator \texttt{{\textquotesingle}} in Julia returns an adjoint of a vector (a lazy representation of row vector), whereas the transpose operator \texttt{.T} over a vector in Python returns the original vector (non-op).


\item In Julia, a function may contain multiple concrete implementations (called \emph{Methods}), selected via multiple dispatch, whereas functions in Python have a single implementation (no polymorphism).


\item There are no classes in Julia. Instead they are structures (mutable or immutable), containing data but no methods.


\item Calling a method of a class in Python (\texttt{a = MyClass(x), x.func(y)}) corresponds to a function call in Julia, e.g. \texttt{a = MyStruct(x), func(x::MyStruct, y)}. In general, multiple dispatch is more flexible and powerful than the Python class system.


\item Julia structures may have exactly one abstract supertype, whereas Python classes can inherit from one or more (abstract or concrete) superclasses.


\item The logical Julia program structure (Packages and Modules) is independent of the file strucutre (\texttt{include} for additional files), whereas the Python code structure is defined by directories (Packages) and files (Modules).


\item The ternary operator \texttt{x > 0 ? 1 : -1} in Julia corresponds to conditional expression in Python \texttt{1 if x > 0 else -1}.


\item In Julia the \texttt{@} symbol refers to a macro, whereas in Python it refers to a decorator.


\item Exception handling in Julia is done using \texttt{try} — \texttt{catch} — \texttt{finally}, instead of \texttt{try} — \texttt{except} — \texttt{finally}. In contrast to Python, it is not recommended to use exception handling as part of the normal workflow in Julia due to performance reasons.


\item In Julia loops are fast, there is no need to write {\textquotedbl}vectorized{\textquotedbl} code for performance reasons.


\item Be careful with non-constant global variables in Julia, especially in tight loops. Since you can write close-to-metal code in Julia (unlike Python), the effect of globals can be drastic (see \hyperlink{818954303942149020}{Performance Tips}).


\item In Python, the majority of values can be used in logical contexts (e.g. \texttt{if {\textquotedbl}a{\textquotedbl}:} means the following block is executed, and \texttt{if {\textquotedbl}{\textquotedbl}:} means it is not). In Julia, you need explicit conversion to \texttt{Bool} (e.g. \texttt{if {\textquotedbl}a{\textquotedbl}} throws an exception). If you want to test for a non-empty string in Julia, you would explicitly write \texttt{if !isempty({\textquotedbl}{\textquotedbl})}.


\item In Julia, a new local scope is introduced by most code blocks, including loops and \texttt{try} — \texttt{catch} — \texttt{finally}. Note that comprehensions (list, generator, etc.) introduce a new local scope both in Python and Julia, whereas \texttt{if} blocks do not introduce a new local scope in both languages.

\end{itemize}


\hypertarget{17929505884596702354}{}


\section{与 C/C++ 的显著差异}



\begin{itemize}
\item Julia 的数组由方括号索引，方括号中可以包含不止一个维度 \texttt{A[i,j]}。这样的语法不仅仅是像 C/C++ 中那样对指针或者地址引用的语法糖，参见关于数组构造的语法的 Julia 文档（依版本不同有所变动）。


\item 在 Julia 中，数组、字符串等的索引从 1 开始，而不是从 0 开始。


\item Julia 的数组在赋值给另一个变量时不发生复制。执行 \texttt{A = B} 后，改变 \texttt{B} 中元素也会修改 \texttt{A}。像 \texttt{+=} 这样的更新运算符不会以 in-place 的方式执行，而是相当于 \texttt{A = A + B}，将左侧绑定到右侧表达式的计算结果上。


\item Julia 的数组是列优先的（Fortran 顺序），而 C/C++ 的数组默认是行优先的。要使数组上的循环性能最优，在 Julia 中循环的顺序应该与 C/C++ 相反（参见 \hyperlink{818954303942149020}{性能建议}）。

reversed in Julia relative to C/C++ (see \hyperlink{11239800376478112527}{relevant section of Performance Tips}).


\item Julia 的值在赋值或向函数传递时不发生复制。如果某个函数修改了数组，这一修改对调用者是可见的。


\item 在 Julia 中，空格是有意义的，这与 C/C++ 不同，所以向 Julia 程序中添加或删除空格时必须谨慎。


\item 在 Julia 中，没有小数点的数值字面量（如 \texttt{42}）生成有符号整数，类型为 \texttt{Int}，但如果字面量太长，超过了机器字长，则会被自动提升为容量更大的类型，例如 \texttt{Int64}（如果 \texttt{Int} 是 \texttt{Int32}）、\texttt{Int128}，或者任意精度的 \texttt{BigInt} 类型。不存在诸如 \texttt{L}, \texttt{LL}, \texttt{U}, \texttt{UL}, \texttt{ULL} 这样的数值字面量后缀指示无符号和/或有符号与无符号。十进制字面量始终是有符号的，十六进制字面量（像 C/C++ 一样由 \texttt{0x} 开头）是无符号的。另外，十六进制字面量与 C/C++/Java 不同，也与 Julia 中的十进制字面量不同，它们的类型取决于字面量的\textbf{长度}，包括开头的 0。例如，\texttt{0x0} 和 \texttt{0x00} 的类型是 \hyperlink{6609065134969660118}{\texttt{UInt8}}，\texttt{0x000} 和 \texttt{0x0000} 的类型是 \hyperlink{7018610346698168012}{\texttt{UInt16}}。同理，字面量的长度在 5-8 之间，类型为 \texttt{UInt32}；在 9-16 之间，类型为 \texttt{UInt64}；在 17-32 之间，类型为 \texttt{UInt128}。当定义十六进制掩码时，就需要将这一问题考虑在内，比如 \texttt{{\textasciitilde}0xf == 0xf0} 与 \texttt{{\textasciitilde}0x000f == 0xfff0} 完全不同。64 位 \texttt{Float64} 和 32 位 \hyperlink{8101639384272933082}{\texttt{Float32}} 的字面量分别表示为 \texttt{1.0} 和 \texttt{1.0f0}。浮点字面量在无法被精确表示时舍入（且不会提升为 \texttt{BigFloat} 类型）。浮点字面量在行为上与 C/C++ 更接近。八进制（前缀为 \texttt{0o}）和二进制（前缀为 \texttt{0b}）也被视为无符号的。


\item 字符串字面量可用 \texttt{{\textquotedbl}} 或 \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}} 分隔，用 \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}} 分隔的字面量可以包含 \texttt{{\textquotedbl}} 字符而无需像 \texttt{{\textquotedbl}{\textbackslash}{\textquotedbl}{\textquotedbl}} 这样来引用它。字符串字面量可以包含插入其中的其他变量或表达式，由 \texttt{\$variablename} 或 \texttt{\$(expression)} 表示，它在该函数所处的上下文中计算变量名或表达式。


\item \texttt{//} 表示 \hyperlink{8304566144531167610}{\texttt{Rational}} 数，而非单行注释（其在 Julia 中是 \texttt{\#}）


\item \texttt{\#=} 表示多行注释的开头，\texttt{=\#} 结束之。


\item Julia 中的函数返回其最后一个表达式或 \texttt{return} 关键字的值。可以从函数中返回多个值并将其作为元组赋值，如 \texttt{(a, b) = myfunction()} 或 \texttt{a, b = myfunction()}，而不必像在 C/C++ 中那样必须传递指向值的指针（即 \texttt{a = myfunction(\&b)}）。


\item Julia 不要求使用分号来结束语句。表达式的结果不会自动打印（除了在交互式提示符中，即 REPL），且代码行不需要以分号结尾。\hyperlink{783803254548423222}{\texttt{println}} 或 \hyperlink{13954719910189591998}{\texttt{@printf}} 可用于打印特定输出。在 REPL 中，\texttt{;} 可用于抑制输出。\texttt{;} 在 \texttt{[ ]} 中也有不同的含义，需要注意。\texttt{;} 可用于在单行中分隔表达式，但在许多情况下不是绝对必要的，更经常是为了可读性。


\item 在 Julia 中，运算符 \hyperlink{7071880015536674935}{\texttt{\unicodeveebar{}}}（\hyperlink{7071880015536674935}{\texttt{xor}}）执行按位 XOR 操作，即 C/C++ 中的 \hyperlink{462277561264792021}{\texttt{{\textasciicircum}}}。此外，按位运算符不具有与 C/C++ 相同的优先级，所以可能需要括号。


\item Julia 的 \hyperlink{462277561264792021}{\texttt{{\textasciicircum}}} 是取幂（pow），而非 C/C++ 中的按位 XOR（在 Julia 中请使用 \hyperlink{7071880015536674935}{\texttt{\unicodeveebar{}}} 或 \texttt{xor}） \href{@ref}{ }, in Julia)


\item Julia 中有两个右移运算符，\texttt{>>} 和 \texttt{>>>}。\texttt{>>>} 执行逻辑移位，\texttt{>>} 总是执行算术移位（译注：此处原文为「\texttt{>>>} performs an arithmetic shift, \texttt{>>} always performs a logical shift」，疑误），与 C/C++ 不同，C/C++ 中的 \texttt{>>} 的含义依赖于被移位的值的类型。


\item Julia 的 \texttt{->} 创建一个匿名函数，它并不通过指针访问成员。


\item Julia 在编写 \texttt{if} 语句或 \texttt{for}/\texttt{while} 循环时不需要括号：请使用 \texttt{for i in [1, 2, 3]} 代替 \texttt{for (int i=1; i <= 3; i++)}，以及 \texttt{if i == 1} 代替 \texttt{if (i == 1)}


\item Julia 不把数字 \texttt{0} 和 \texttt{1} 视为布尔值。在 Julia 中不能编写 \texttt{if (1)}，因为 \texttt{if} 语句只接受布尔值。相反，可以编写 \texttt{if true}、\texttt{if Bool(1)} 或 \texttt{if 1==1}。


\item Julia 使用 \texttt{end} 来表示条件块（如 \texttt{if}）、循环块（如 \texttt{while}/\texttt{for}）和函数的结束。为了代替单行 \texttt{if ( cond ) statement}，Julia 允许形式为 \texttt{if cond; statement; end}、\texttt{cond \&\& statement} 和 \texttt{!cond || statement} 的语句。后两种语法中的赋值语句必须显式地包含在括号中，例如 \texttt{cond \&\& (x = value)}，这是因为运算符的优先级。


\item Julia 没有用来续行的语法：如果在行的末尾，到目前为止的输入是一个完整的表达式，则认为其已经结束；否则，认为输入继续。强制表达式继续的一种方式是将其包含在括号中。


\item Julia 宏对已解析的表达式进行操作，而非程序的文本，这允许它们执行复杂的 Julia 代码转换。宏名称以 \texttt{@} 字符开头，具有类似函数的语法 \texttt{@mymacro(arg1, arg2, arg3)} 和类似语句的语法 \texttt{@mymacro arg1 arg2 arg3}。两种形式的语法可以相互转换；如果宏出现在另一个表达式中，则类似函数的形式尤其有用，并且它通常是最清晰的。类似语句的形式通常用于标注块，如在分布式 \texttt{for} 结构中：\texttt{@distributed for i in 1:n; \#= body =\#; end}。如果宏结构的结尾不那么清晰，请使用类似函数的形式。


\item Julia 有一个枚举类型，使用宏 \texttt{@enum(name, value1, value2, ...)} 来表示，例如：\texttt{@enum(Fruit, banana=1, apple, pear)}。


\item 按照惯例，修改其参数的函数在名称的末尾有个 \texttt{!}，例如 \texttt{push!}。


\item 在 C++ 中，默认情况下，你具有静态分派，即为了支持动态派发，你需要将函数标注为 virtual 函数。另一方面，Julia 中的每个方法都是「virtual」（尽管它更通用，因为方法是在每个参数类型上派发的，而不仅仅是 \texttt{this}，并且使用的是最具体的声明规则）。

\end{itemize}


\hypertarget{14324149948761873740}{}


\section{Noteworthy differences from Common Lisp}



\begin{itemize}
\item Julia uses 1-based indexing for arrays by default, and it can also handle arbitrary \hyperlink{1238988360302116626}{index offsets}.


\item Functions and variables share the same namespace (“Lisp-1”).


\item There is a \hyperlink{14946515604348703614}{\texttt{Pair}} type, but it is not meant to be used as a \texttt{COMMON-LISP:CONS}. Various iterable collections can be used interchangeably in most parts of the language (eg splatting, tuples, etc). \texttt{Tuple}s are the closest to Common Lisp lists for \emph{short} collections of heterogeneous elements. Use \texttt{NamedTuple}s in place of alists. For larger collections of homogeneous types, \texttt{Array}s and \texttt{Dict}s should be used.


\item The typical Julia workflow for prototyping also uses continuous manipulation of the image, implemented with the \href{https://github.com/timholy/Revise.jl}{Revise.jl} package.


\item Bignums are supported, but conversion is not automatic; ordinary integers \hyperlink{17610230595270045080}{overflow}.


\item Modules (namespaces) can be hierarchical. \hyperlink{16252475688663093021}{\texttt{import}} and \hyperlink{169458112978175560}{\texttt{using}} have a dual role: they load the code and make it available in the namespace. \texttt{import} for only the module name is possible (roughly equivalent to \texttt{ASDF:LOAD-OP}). Slot names don{\textquotesingle}t need to be exported separately. Global variables can{\textquotesingle}t be assigned to from outside the module (except with \texttt{eval(mod, :(var = val))} as an escape hatch).


\item Macros start with \texttt{@}, and are not as seamlessly integrated into the language as Common Lisp; consequently, macro usage is not as widespread as in the latter. A form of hygiene for \href{@ref Metaprogramming}{macros} is supported by the language. Because of the different surface syntax, there is no equivalent to \texttt{COMMON-LISP:\&BODY}.


\item \emph{All} functions are generic and use multiple dispatch. Argument lists don{\textquotesingle}t have to follow the same template, which leads to a powerful idiom (see \hyperlink{16455129305818705265}{\texttt{do}}). Optional and keyword arguments are handled differently. Method ambiguities are not resolved like in the Common Lisp Object System, necessitating the definition of a more specific method for the intersection.


\item Symbols do not belong to any package, and do not contain any values \emph{per se}. \texttt{M.var} evaluates the symbol \texttt{var} in the module \texttt{M}.


\item A functional programming style is fully supported by the language, including closures, but isn{\textquotesingle}t always the idiomatic solution for Julia. Some \hyperlink{627547588659365489}{workarounds} may be necessary for performance when modifying captured variables.

\end{itemize}


\hypertarget{9161019699686356187}{}


\chapter{Unicode 输入表}



在 Julia REPL 或其它编辑器中，可以像输入 LaTeX 符号一样，用 tab补全下表列出的 Unicode 字符。在 REPL 中，可以先按 \texttt{?} 进入帮助模式，然后将 Unicode 字符复制粘贴进去，一般在文档开头就会写输入方式。



\begin{quote}
\textbf{Warning}

此表第二列可能会缺失一些字符，对某些字符的显示效果也可能会与在 Julia REPL 中不一致。如果发生了这种状况，强烈建议用户检查一下浏览器或 REPL 的字体设置，目前已知很多字体都有显示问题。

\end{quote}



\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
Code point(s) & Character(s) & Tab completion sequence(s) & Unicode name(s) \\
\hline
U+000A1 & ¡ & {\textbackslash}exclamdown & Inverted Exclamation Mark \\
\hline
U+000A3 & £ & {\textbackslash}sterling & Pound Sign \\
\hline
U+000A5 & ¥ & {\textbackslash}yen & Yen Sign \\
\hline
U+000A6 & ¦ & {\textbackslash}brokenbar & Broken Bar / Broken Vertical Bar \\
\hline
U+000A7 & § & {\textbackslash}S & Section Sign \\
\hline
U+000A9 & © & {\textbackslash}copyright, {\textbackslash}:copyright: & Copyright Sign \\
\hline
U+000AA & ª & {\textbackslash}ordfeminine & Feminine Ordinal Indicator \\
\hline
U+000AC & ¬ & {\textbackslash}neg & Not Sign \\
\hline
U+000AE & ® & {\textbackslash}circledR, {\textbackslash}:registered: & Registered Sign / Registered Trade Mark Sign \\
\hline
U+000AF & ¯ & {\textbackslash}highminus & Macron / Spacing Macron \\
\hline
U+000B0 & ° & {\textbackslash}degree & Degree Sign \\
\hline
U+000B1 & ± & {\textbackslash}pm & Plus-Minus Sign / Plus-Or-Minus Sign \\
\hline
U+000B2 & ² & {\textbackslash}{\textasciicircum}2 & Superscript Two / Superscript Digit Two \\
\hline
U+000B3 & ³ & {\textbackslash}{\textasciicircum}3 & Superscript Three / Superscript Digit Three \\
\hline
U+000B6 & ¶ & {\textbackslash}P & Pilcrow Sign / Paragraph Sign \\
\hline
U+000B7 & · & {\textbackslash}cdotp & Middle Dot \\
\hline
U+000B9 & ¹ & {\textbackslash}{\textasciicircum}1 & Superscript One / Superscript Digit One \\
\hline
U+000BA & º & {\textbackslash}ordmasculine & Masculine Ordinal Indicator \\
\hline
U+000BC & ¼ & {\textbackslash}1/4 & Vulgar Fraction One Quarter / Fraction One Quarter \\
\hline
U+000BD & ½ & {\textbackslash}1/2 & Vulgar Fraction One Half / Fraction One Half \\
\hline
U+000BE & ¾ & {\textbackslash}3/4 & Vulgar Fraction Three Quarters / Fraction Three Quarters \\
\hline
U+000BF & ¿ & {\textbackslash}questiondown & Inverted Question Mark \\
\hline
U+000C5 & Å & {\textbackslash}AA & Latin Capital Letter A With Ring Above / Latin Capital Letter A Ring \\
\hline
U+000C6 & Æ & {\textbackslash}AE & Latin Capital Letter Ae / Latin Capital Letter A E \\
\hline
U+000D0 & Ð & {\textbackslash}DH & Latin Capital Letter Eth \\
\hline
U+000D7 & × & {\textbackslash}times & Multiplication Sign \\
\hline
U+000D8 & Ø & {\textbackslash}O & Latin Capital Letter O With Stroke / Latin Capital Letter O Slash \\
\hline
U+000DE & Þ & {\textbackslash}TH & Latin Capital Letter Thorn \\
\hline
U+000DF & ß & {\textbackslash}ss & Latin Small Letter Sharp S \\
\hline
U+000E5 & å & {\textbackslash}aa & Latin Small Letter A With Ring Above / Latin Small Letter A Ring \\
\hline
U+000E6 & æ & {\textbackslash}ae & Latin Small Letter Ae / Latin Small Letter A E \\
\hline
U+000F0 & ð & {\textbackslash}eth, {\textbackslash}dh & Latin Small Letter Eth \\
\hline
U+000F7 & ÷ & {\textbackslash}div & Division Sign \\
\hline
U+000F8 & ø & {\textbackslash}o & Latin Small Letter O With Stroke / Latin Small Letter O Slash \\
\hline
U+000FE & þ & {\textbackslash}th & Latin Small Letter Thorn \\
\hline
U+00110 & Đ & {\textbackslash}DJ & Latin Capital Letter D With Stroke / Latin Capital Letter D Bar \\
\hline
U+00111 & đ & {\textbackslash}dj & Latin Small Letter D With Stroke / Latin Small Letter D Bar \\
\hline
U+00127 & ħ & {\textbackslash}hbar & Latin Small Letter H With Stroke / Latin Small Letter H Bar \\
\hline
U+00131 & ı & {\textbackslash}imath & Latin Small Letter Dotless I \\
\hline
U+00141 & Ł & {\textbackslash}L & Latin Capital Letter L With Stroke / Latin Capital Letter L Slash \\
\hline
U+00142 & ł & {\textbackslash}l & Latin Small Letter L With Stroke / Latin Small Letter L Slash \\
\hline
U+0014A & Ŋ & {\textbackslash}NG & Latin Capital Letter Eng \\
\hline
U+0014B & ŋ & {\textbackslash}ng & Latin Small Letter Eng \\
\hline
U+00152 & Œ & {\textbackslash}OE & Latin Capital Ligature Oe / Latin Capital Letter O E \\
\hline
U+00153 & œ & {\textbackslash}oe & Latin Small Ligature Oe / Latin Small Letter O E \\
\hline
U+00195 & ƕ & {\textbackslash}hvlig & Latin Small Letter Hv / Latin Small Letter H V \\
\hline
U+0019E & ƞ & {\textbackslash}nrleg & Latin Small Letter N With Long Right Leg \\
\hline
U+001B5 & Ƶ & {\textbackslash}Zbar & Latin Capital Letter Z With Stroke / Latin Capital Letter Z Bar \\
\hline
U+001C2 & ǂ & {\textbackslash}doublepipe & Latin Letter Alveolar Click / Latin Letter Pipe Double Bar \\
\hline
U+00237 & ȷ & {\textbackslash}jmath & Latin Small Letter Dotless J \\
\hline
U+00250 & ɐ & {\textbackslash}trna & Latin Small Letter Turned A \\
\hline
U+00252 & ɒ & {\textbackslash}trnsa & Latin Small Letter Turned Alpha / Latin Small Letter Turned Script A \\
\hline
U+00254 & ɔ & {\textbackslash}openo & Latin Small Letter Open O \\
\hline
U+00256 & ɖ & {\textbackslash}rtld & Latin Small Letter D With Tail / Latin Small Letter D Retroflex Hook \\
\hline
U+00259 & ə & {\textbackslash}schwa & Latin Small Letter Schwa \\
\hline
U+00263 & ɣ & {\textbackslash}pgamma & Latin Small Letter Gamma \\
\hline
U+00264 & ɤ & {\textbackslash}pbgam & Latin Small Letter Rams Horn / Latin Small Letter Baby Gamma \\
\hline
U+00265 & ɥ & {\textbackslash}trnh & Latin Small Letter Turned H \\
\hline
U+0026C & ɬ & {\textbackslash}btdl & Latin Small Letter L With Belt / Latin Small Letter L Belt \\
\hline
U+0026D & ɭ & {\textbackslash}rtll & Latin Small Letter L With Retroflex Hook / Latin Small Letter L Retroflex Hook \\
\hline
U+0026F & ɯ & {\textbackslash}trnm & Latin Small Letter Turned M \\
\hline
U+00270 & ɰ & {\textbackslash}trnmlr & Latin Small Letter Turned M With Long Leg \\
\hline
U+00271 & ɱ & {\textbackslash}ltlmr & Latin Small Letter M With Hook / Latin Small Letter M Hook \\
\hline
U+00272 & ɲ & {\textbackslash}ltln & Latin Small Letter N With Left Hook / Latin Small Letter N Hook \\
\hline
U+00273 & ɳ & {\textbackslash}rtln & Latin Small Letter N With Retroflex Hook / Latin Small Letter N Retroflex Hook \\
\hline
U+00277 & ɷ & {\textbackslash}clomeg & Latin Small Letter Closed Omega \\
\hline
U+00278 & ɸ & {\textbackslash}ltphi & Latin Small Letter Phi \\
\hline
U+00279 & ɹ & {\textbackslash}trnr & Latin Small Letter Turned R \\
\hline
U+0027A & ɺ & {\textbackslash}trnrl & Latin Small Letter Turned R With Long Leg \\
\hline
U+0027B & ɻ & {\textbackslash}rttrnr & Latin Small Letter Turned R With Hook / Latin Small Letter Turned R Hook \\
\hline
U+0027C & ɼ & {\textbackslash}rl & Latin Small Letter R With Long Leg \\
\hline
U+0027D & ɽ & {\textbackslash}rtlr & Latin Small Letter R With Tail / Latin Small Letter R Hook \\
\hline
U+0027E & ɾ & {\textbackslash}fhr & Latin Small Letter R With Fishhook / Latin Small Letter Fishhook R \\
\hline
U+00282 & ʂ & {\textbackslash}rtls & Latin Small Letter S With Hook / Latin Small Letter S Hook \\
\hline
U+00283 & ʃ & {\textbackslash}esh & Latin Small Letter Esh \\
\hline
U+00287 & ʇ & {\textbackslash}trnt & Latin Small Letter Turned T \\
\hline
U+00288 & ʈ & {\textbackslash}rtlt & Latin Small Letter T With Retroflex Hook / Latin Small Letter T Retroflex Hook \\
\hline
U+0028A & ʊ & {\textbackslash}pupsil & Latin Small Letter Upsilon \\
\hline
U+0028B & ʋ & {\textbackslash}pscrv & Latin Small Letter V With Hook / Latin Small Letter Script V \\
\hline
U+0028C & ʌ & {\textbackslash}invv & Latin Small Letter Turned V \\
\hline
U+0028D & ʍ & {\textbackslash}invw & Latin Small Letter Turned W \\
\hline
U+0028E & ʎ & {\textbackslash}trny & Latin Small Letter Turned Y \\
\hline
U+00290 & ʐ & {\textbackslash}rtlz & Latin Small Letter Z With Retroflex Hook / Latin Small Letter Z Retroflex Hook \\
\hline
U+00292 & ʒ & {\textbackslash}yogh & Latin Small Letter Ezh / Latin Small Letter Yogh \\
\hline
U+00294 & ʔ & {\textbackslash}glst & Latin Letter Glottal Stop \\
\hline
U+00295 & ʕ & {\textbackslash}reglst & Latin Letter Pharyngeal Voiced Fricative / Latin Letter Reversed Glottal Stop \\
\hline
U+00296 & ʖ & {\textbackslash}inglst & Latin Letter Inverted Glottal Stop \\
\hline
U+0029E & ʞ & {\textbackslash}turnk & Latin Small Letter Turned K \\
\hline
U+002A4 & ʤ & {\textbackslash}dyogh & Latin Small Letter Dezh Digraph / Latin Small Letter D Yogh \\
\hline
U+002A7 & ʧ & {\textbackslash}tesh & Latin Small Letter Tesh Digraph / Latin Small Letter T Esh \\
\hline
U+002B0 & ʰ & {\textbackslash}{\textasciicircum}h & Modifier Letter Small H \\
\hline
U+002B2 & ʲ & {\textbackslash}{\textasciicircum}j & Modifier Letter Small J \\
\hline
U+002B3 & ʳ & {\textbackslash}{\textasciicircum}r & Modifier Letter Small R \\
\hline
U+002B7 & ʷ & {\textbackslash}{\textasciicircum}w & Modifier Letter Small W \\
\hline
U+002B8 & ʸ & {\textbackslash}{\textasciicircum}y & Modifier Letter Small Y \\
\hline
U+002BC & ʼ & {\textbackslash}rasp & Modifier Letter Apostrophe \\
\hline
U+002C8 & ˈ & {\textbackslash}verts & Modifier Letter Vertical Line \\
\hline
U+002CC & ˌ & {\textbackslash}verti & Modifier Letter Low Vertical Line \\
\hline
U+002D0 & ː & {\textbackslash}lmrk & Modifier Letter Triangular Colon \\
\hline
U+002D1 & ˑ & {\textbackslash}hlmrk & Modifier Letter Half Triangular Colon \\
\hline
U+002D2 & ˒ & {\textbackslash}sbrhr & Modifier Letter Centred Right Half Ring / Modifier Letter Centered Right Half Ring \\
\hline
U+002D3 & ˓ & {\textbackslash}sblhr & Modifier Letter Centred Left Half Ring / Modifier Letter Centered Left Half Ring \\
\hline
U+002D4 & ˔ & {\textbackslash}rais & Modifier Letter Up Tack \\
\hline
U+002D5 & ˕ & {\textbackslash}low & Modifier Letter Down Tack \\
\hline
U+002D8 & ˘ & {\textbackslash}u & Breve / Spacing Breve \\
\hline
U+002DC & ˜ & {\textbackslash}tildelow & Small Tilde / Spacing Tilde \\
\hline
U+002E1 & ˡ & {\textbackslash}{\textasciicircum}l & Modifier Letter Small L \\
\hline
U+002E2 & ˢ & {\textbackslash}{\textasciicircum}s & Modifier Letter Small S \\
\hline
U+002E3 & ˣ & {\textbackslash}{\textasciicircum}x & Modifier Letter Small X \\
\hline
U+00300 &  ̀  & {\textbackslash}grave & Combining Grave Accent / Non-Spacing Grave \\
\hline
U+00301 &  ́  & {\textbackslash}acute & Combining Acute Accent / Non-Spacing Acute \\
\hline
U+00302 &  ̂  & {\textbackslash}hat & Combining Circumflex Accent / Non-Spacing Circumflex \\
\hline
U+00303 &  ̃  & {\textbackslash}tilde & Combining Tilde / Non-Spacing Tilde \\
\hline
U+00304 &  ̄  & {\textbackslash}bar & Combining Macron / Non-Spacing Macron \\
\hline
U+00305 &  ̅  & {\textbackslash}overbar & Combining Overline / Non-Spacing Overscore \\
\hline
U+00306 &  ̆  & {\textbackslash}breve & Combining Breve / Non-Spacing Breve \\
\hline
U+00307 &  ̇  & {\textbackslash}dot & Combining Dot Above / Non-Spacing Dot Above \\
\hline
U+00308 &  ̈  & {\textbackslash}ddot & Combining Diaeresis / Non-Spacing Diaeresis \\
\hline
U+00309 &  ̉  & {\textbackslash}ovhook & Combining Hook Above / Non-Spacing Hook Above \\
\hline
U+0030A &  ̊  & {\textbackslash}ocirc & Combining Ring Above / Non-Spacing Ring Above \\
\hline
U+0030B &  ̋  & {\textbackslash}H & Combining Double Acute Accent / Non-Spacing Double Acute \\
\hline
U+0030C &  ̌  & {\textbackslash}check & Combining Caron / Non-Spacing Hacek \\
\hline
U+00310 &  ̐  & {\textbackslash}candra & Combining Candrabindu / Non-Spacing Candrabindu \\
\hline
U+00312 &  ̒  & {\textbackslash}oturnedcomma & Combining Turned Comma Above / Non-Spacing Turned Comma Above \\
\hline
U+00315 &  ̕  & {\textbackslash}ocommatopright & Combining Comma Above Right / Non-Spacing Comma Above Right \\
\hline
U+0031A &  ̚  & {\textbackslash}droang & Combining Left Angle Above / Non-Spacing Left Angle Above \\
\hline
U+00321 &  ̡  & {\textbackslash}palh & Combining Palatalized Hook Below / Non-Spacing Palatalized Hook Below \\
\hline
U+00322 &  ̢  & {\textbackslash}rh & Combining Retroflex Hook Below / Non-Spacing Retroflex Hook Below \\
\hline
U+00327 &  ̧  & {\textbackslash}c & Combining Cedilla / Non-Spacing Cedilla \\
\hline
U+00328 &  ̨  & {\textbackslash}k & Combining Ogonek / Non-Spacing Ogonek \\
\hline
U+0032A &  ̪  & {\textbackslash}sbbrg & Combining Bridge Below / Non-Spacing Bridge Below \\
\hline
U+00330 &  ̰  & {\textbackslash}wideutilde & Combining Tilde Below / Non-Spacing Tilde Below \\
\hline
U+00332 &  ̲  & {\textbackslash}underbar & Combining Low Line / Non-Spacing Underscore \\
\hline
U+00336 &  ̶  & {\textbackslash}strike, {\textbackslash}sout & Combining Long Stroke Overlay / Non-Spacing Long Bar Overlay \\
\hline
U+00338 &  ̸  & {\textbackslash}not & Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay \\
\hline
U+0034D &  ͍  & {\textbackslash}underleftrightarrow & Combining Left Right Arrow Below \\
\hline
U+00391 & Α & {\textbackslash}Alpha & Greek Capital Letter Alpha \\
\hline
U+00392 & Β & {\textbackslash}Beta & Greek Capital Letter Beta \\
\hline
U+00393 & Γ & {\textbackslash}Gamma & Greek Capital Letter Gamma \\
\hline
U+00394 & Δ & {\textbackslash}Delta & Greek Capital Letter Delta \\
\hline
U+00395 & Ε & {\textbackslash}Epsilon & Greek Capital Letter Epsilon \\
\hline
U+00396 & Ζ & {\textbackslash}Zeta & Greek Capital Letter Zeta \\
\hline
U+00397 & Η & {\textbackslash}Eta & Greek Capital Letter Eta \\
\hline
U+00398 & Θ & {\textbackslash}Theta & Greek Capital Letter Theta \\
\hline
U+00399 & Ι & {\textbackslash}Iota & Greek Capital Letter Iota \\
\hline
U+0039A & Κ & {\textbackslash}Kappa & Greek Capital Letter Kappa \\
\hline
U+0039B & Λ & {\textbackslash}Lambda & Greek Capital Letter Lamda / Greek Capital Letter Lambda \\
\hline
U+0039C & Μ & {\textbackslash}upMu & Greek Capital Letter Mu \\
\hline
U+0039D & Ν & {\textbackslash}upNu & Greek Capital Letter Nu \\
\hline
U+0039E & Ξ & {\textbackslash}Xi & Greek Capital Letter Xi \\
\hline
U+0039F & Ο & {\textbackslash}upOmicron & Greek Capital Letter Omicron \\
\hline
U+003A0 & Π & {\textbackslash}Pi & Greek Capital Letter Pi \\
\hline
U+003A1 & Ρ & {\textbackslash}Rho & Greek Capital Letter Rho \\
\hline
U+003A3 & Σ & {\textbackslash}Sigma & Greek Capital Letter Sigma \\
\hline
U+003A4 & Τ & {\textbackslash}Tau & Greek Capital Letter Tau \\
\hline
U+003A5 & Υ & {\textbackslash}Upsilon & Greek Capital Letter Upsilon \\
\hline
U+003A6 & Φ & {\textbackslash}Phi & Greek Capital Letter Phi \\
\hline
U+003A7 & Χ & {\textbackslash}Chi & Greek Capital Letter Chi \\
\hline
U+003A8 & Ψ & {\textbackslash}Psi & Greek Capital Letter Psi \\
\hline
U+003A9 & Ω & {\textbackslash}Omega & Greek Capital Letter Omega \\
\hline
U+003B1 & α & {\textbackslash}alpha & Greek Small Letter Alpha \\
\hline
U+003B2 & β & {\textbackslash}beta & Greek Small Letter Beta \\
\hline
U+003B3 & γ & {\textbackslash}gamma & Greek Small Letter Gamma \\
\hline
U+003B4 & δ & {\textbackslash}delta & Greek Small Letter Delta \\
\hline
U+003B5 & ε & {\textbackslash}upepsilon, {\textbackslash}varepsilon & Greek Small Letter Epsilon \\
\hline
U+003B6 & ζ & {\textbackslash}zeta & Greek Small Letter Zeta \\
\hline
U+003B7 & η & {\textbackslash}eta & Greek Small Letter Eta \\
\hline
U+003B8 & θ & {\textbackslash}theta & Greek Small Letter Theta \\
\hline
U+003B9 & ι & {\textbackslash}iota & Greek Small Letter Iota \\
\hline
U+003BA & κ & {\textbackslash}kappa & Greek Small Letter Kappa \\
\hline
U+003BB & λ & {\textbackslash}lambda & Greek Small Letter Lamda / Greek Small Letter Lambda \\
\hline
U+003BC & μ & {\textbackslash}mu & Greek Small Letter Mu \\
\hline
U+003BD & ν & {\textbackslash}nu & Greek Small Letter Nu \\
\hline
U+003BE & ξ & {\textbackslash}xi & Greek Small Letter Xi \\
\hline
U+003BF & ο & {\textbackslash}upomicron & Greek Small Letter Omicron \\
\hline
U+003C0 & π & {\textbackslash}pi & Greek Small Letter Pi \\
\hline
U+003C1 & ρ & {\textbackslash}rho & Greek Small Letter Rho \\
\hline
U+003C2 & ς & {\textbackslash}varsigma & Greek Small Letter Final Sigma \\
\hline
U+003C3 & σ & {\textbackslash}sigma & Greek Small Letter Sigma \\
\hline
U+003C4 & τ & {\textbackslash}tau & Greek Small Letter Tau \\
\hline
U+003C5 & υ & {\textbackslash}upsilon & Greek Small Letter Upsilon \\
\hline
U+003C6 & φ & {\textbackslash}varphi & Greek Small Letter Phi \\
\hline
U+003C7 & χ & {\textbackslash}chi & Greek Small Letter Chi \\
\hline
U+003C8 & ψ & {\textbackslash}psi & Greek Small Letter Psi \\
\hline
U+003C9 & ω & {\textbackslash}omega & Greek Small Letter Omega \\
\hline
U+003D0 & ϐ & {\textbackslash}upvarbeta & Greek Beta Symbol / Greek Small Letter Curled Beta \\
\hline
U+003D1 & ϑ & {\textbackslash}vartheta & Greek Theta Symbol / Greek Small Letter Script Theta \\
\hline
U+003D5 & ϕ & {\textbackslash}phi & Greek Phi Symbol / Greek Small Letter Script Phi \\
\hline
U+003D6 & ϖ & {\textbackslash}varpi & Greek Pi Symbol / Greek Small Letter Omega Pi \\
\hline
U+003D8 & Ϙ & {\textbackslash}upoldKoppa & Greek Letter Archaic Koppa \\
\hline
U+003D9 & ϙ & {\textbackslash}upoldkoppa & Greek Small Letter Archaic Koppa \\
\hline
U+003DA & Ϛ & {\textbackslash}Stigma & Greek Letter Stigma / Greek Capital Letter Stigma \\
\hline
U+003DB & ϛ & {\textbackslash}upstigma & Greek Small Letter Stigma \\
\hline
U+003DC & Ϝ & {\textbackslash}Digamma & Greek Letter Digamma / Greek Capital Letter Digamma \\
\hline
U+003DD & ϝ & {\textbackslash}digamma & Greek Small Letter Digamma \\
\hline
U+003DE & Ϟ & {\textbackslash}Koppa & Greek Letter Koppa / Greek Capital Letter Koppa \\
\hline
U+003DF & ϟ & {\textbackslash}upkoppa & Greek Small Letter Koppa \\
\hline
U+003E0 & Ϡ & {\textbackslash}Sampi & Greek Letter Sampi / Greek Capital Letter Sampi \\
\hline
U+003E1 & ϡ & {\textbackslash}upsampi & Greek Small Letter Sampi \\
\hline
U+003F0 & ϰ & {\textbackslash}varkappa & Greek Kappa Symbol / Greek Small Letter Script Kappa \\
\hline
U+003F1 & ϱ & {\textbackslash}varrho & Greek Rho Symbol / Greek Small Letter Tailed Rho \\
\hline
U+003F4 & ϴ & {\textbackslash}varTheta & Greek Capital Theta Symbol \\
\hline
U+003F5 & ϵ & {\textbackslash}epsilon & Greek Lunate Epsilon Symbol \\
\hline
U+003F6 & ϶ & {\textbackslash}backepsilon & Greek Reversed Lunate Epsilon Symbol \\
\hline
U+01D2C & ᴬ & {\textbackslash}{\textasciicircum}A & Modifier Letter Capital A \\
\hline
U+01D2E & ᴮ & {\textbackslash}{\textasciicircum}B & Modifier Letter Capital B \\
\hline
U+01D30 & ᴰ & {\textbackslash}{\textasciicircum}D & Modifier Letter Capital D \\
\hline
U+01D31 & ᴱ & {\textbackslash}{\textasciicircum}E & Modifier Letter Capital E \\
\hline
U+01D33 & ᴳ & {\textbackslash}{\textasciicircum}G & Modifier Letter Capital G \\
\hline
U+01D34 & ᴴ & {\textbackslash}{\textasciicircum}H & Modifier Letter Capital H \\
\hline
U+01D35 & ᴵ & {\textbackslash}{\textasciicircum}I & Modifier Letter Capital I \\
\hline
U+01D36 & ᴶ & {\textbackslash}{\textasciicircum}J & Modifier Letter Capital J \\
\hline
U+01D37 & ᴷ & {\textbackslash}{\textasciicircum}K & Modifier Letter Capital K \\
\hline
U+01D38 & ᴸ & {\textbackslash}{\textasciicircum}L & Modifier Letter Capital L \\
\hline
U+01D39 & ᴹ & {\textbackslash}{\textasciicircum}M & Modifier Letter Capital M \\
\hline
U+01D3A & ᴺ & {\textbackslash}{\textasciicircum}N & Modifier Letter Capital N \\
\hline
U+01D3C & ᴼ & {\textbackslash}{\textasciicircum}O & Modifier Letter Capital O \\
\hline
U+01D3E & ᴾ & {\textbackslash}{\textasciicircum}P & Modifier Letter Capital P \\
\hline
U+01D3F & ᴿ & {\textbackslash}{\textasciicircum}R & Modifier Letter Capital R \\
\hline
U+01D40 & ᵀ & {\textbackslash}{\textasciicircum}T & Modifier Letter Capital T \\
\hline
U+01D41 & ᵁ & {\textbackslash}{\textasciicircum}U & Modifier Letter Capital U \\
\hline
U+01D42 & ᵂ & {\textbackslash}{\textasciicircum}W & Modifier Letter Capital W \\
\hline
U+01D43 & ᵃ & {\textbackslash}{\textasciicircum}a & Modifier Letter Small A \\
\hline
U+01D45 & ᵅ & {\textbackslash}{\textasciicircum}alpha & Modifier Letter Small Alpha \\
\hline
U+01D47 & ᵇ & {\textbackslash}{\textasciicircum}b & Modifier Letter Small B \\
\hline
U+01D48 & ᵈ & {\textbackslash}{\textasciicircum}d & Modifier Letter Small D \\
\hline
U+01D49 & ᵉ & {\textbackslash}{\textasciicircum}e & Modifier Letter Small E \\
\hline
U+01D4B & ᵋ & {\textbackslash}{\textasciicircum}epsilon & Modifier Letter Small Open E \\
\hline
U+01D4D & ᵍ & {\textbackslash}{\textasciicircum}g & Modifier Letter Small G \\
\hline
U+01D4F & ᵏ & {\textbackslash}{\textasciicircum}k & Modifier Letter Small K \\
\hline
U+01D50 & ᵐ & {\textbackslash}{\textasciicircum}m & Modifier Letter Small M \\
\hline
U+01D52 & ᵒ & {\textbackslash}{\textasciicircum}o & Modifier Letter Small O \\
\hline
U+01D56 & ᵖ & {\textbackslash}{\textasciicircum}p & Modifier Letter Small P \\
\hline
U+01D57 & ᵗ & {\textbackslash}{\textasciicircum}t & Modifier Letter Small T \\
\hline
U+01D58 & ᵘ & {\textbackslash}{\textasciicircum}u & Modifier Letter Small U \\
\hline
U+01D5B & ᵛ & {\textbackslash}{\textasciicircum}v & Modifier Letter Small V \\
\hline
U+01D5D & ᵝ & {\textbackslash}{\textasciicircum}beta & Modifier Letter Small Beta \\
\hline
U+01D5E & ᵞ & {\textbackslash}{\textasciicircum}gamma & Modifier Letter Small Greek Gamma \\
\hline
U+01D5F & ᵟ & {\textbackslash}{\textasciicircum}delta & Modifier Letter Small Delta \\
\hline
U+01D60 & ᵠ & {\textbackslash}{\textasciicircum}phi & Modifier Letter Small Greek Phi \\
\hline
U+01D61 & ᵡ & {\textbackslash}{\textasciicircum}chi & Modifier Letter Small Chi \\
\hline
U+01D62 & ᵢ & {\textbackslash}\_i & Latin Subscript Small Letter I \\
\hline
U+01D63 & ᵣ & {\textbackslash}\_r & Latin Subscript Small Letter R \\
\hline
U+01D64 & ᵤ & {\textbackslash}\_u & Latin Subscript Small Letter U \\
\hline
U+01D65 & ᵥ & {\textbackslash}\_v & Latin Subscript Small Letter V \\
\hline
U+01D66 & ᵦ & {\textbackslash}\_beta & Greek Subscript Small Letter Beta \\
\hline
U+01D67 & ᵧ & {\textbackslash}\_gamma & Greek Subscript Small Letter Gamma \\
\hline
U+01D68 & ᵨ & {\textbackslash}\_rho & Greek Subscript Small Letter Rho \\
\hline
U+01D69 & ᵩ & {\textbackslash}\_phi & Greek Subscript Small Letter Phi \\
\hline
U+01D6A & ᵪ & {\textbackslash}\_chi & Greek Subscript Small Letter Chi \\
\hline
U+01D9C & ᶜ & {\textbackslash}{\textasciicircum}c & Modifier Letter Small C \\
\hline
U+01DA0 & ᶠ & {\textbackslash}{\textasciicircum}f & Modifier Letter Small F \\
\hline
U+01DA5 & ᶥ & {\textbackslash}{\textasciicircum}iota & Modifier Letter Small Iota \\
\hline
U+01DB2 & ᶲ & {\textbackslash}{\textasciicircum}Phi & Modifier Letter Small Phi \\
\hline
U+01DBB & ᶻ & {\textbackslash}{\textasciicircum}z & Modifier Letter Small Z \\
\hline
U+01DBF & ᶿ & {\textbackslash}{\textasciicircum}theta & Modifier Letter Small Theta \\
\hline
U+02002 &   & {\textbackslash}enspace & En Space \\
\hline
U+02003 &   & {\textbackslash}quad & Em Space \\
\hline
U+02005 &   & {\textbackslash}thickspace & Four-Per-Em Space \\
\hline
U+02009 &   & {\textbackslash}thinspace & Thin Space \\
\hline
U+0200A &   & {\textbackslash}hspace & Hair Space \\
\hline
U+02013 & – & {\textbackslash}endash & En Dash \\
\hline
U+02014 & — & {\textbackslash}emdash & Em Dash \\
\hline
U+02016 & ‖ & {\textbackslash}Vert & Double Vertical Line / Double Vertical Bar \\
\hline
U+02018 & ‘ & {\textbackslash}lq & Left Single Quotation Mark / Single Turned Comma Quotation Mark \\
\hline
U+02019 & ’ & {\textbackslash}rq & Right Single Quotation Mark / Single Comma Quotation Mark \\
\hline
U+0201B & ‛ & {\textbackslash}reapos & Single High-Reversed-9 Quotation Mark / Single Reversed Comma Quotation Mark \\
\hline
U+0201C & “ & {\textbackslash}quotedblleft & Left Double Quotation Mark / Double Turned Comma Quotation Mark \\
\hline
U+0201D & ” & {\textbackslash}quotedblright & Right Double Quotation Mark / Double Comma Quotation Mark \\
\hline
U+02020 & † & {\textbackslash}dagger & Dagger \\
\hline
U+02021 & ‡ & {\textbackslash}ddagger & Double Dagger \\
\hline
U+02022 & • & {\textbackslash}bullet & Bullet \\
\hline
U+02026 & … & {\textbackslash}dots, {\textbackslash}ldots & Horizontal Ellipsis \\
\hline
U+02030 & ‰ & {\textbackslash}perthousand & Per Mille Sign \\
\hline
U+02031 & ‱ & {\textbackslash}pertenthousand & Per Ten Thousand Sign \\
\hline
U+02032 & ′ & {\textbackslash}prime & Prime \\
\hline
U+02033 & ″ & {\textbackslash}pprime & Double Prime \\
\hline
U+02034 & ‴ & {\textbackslash}ppprime & Triple Prime \\
\hline
U+02035 & ‵ & {\textbackslash}backprime & Reversed Prime \\
\hline
U+02036 & ‶ & {\textbackslash}backpprime & Reversed Double Prime \\
\hline
U+02037 & ‷ & {\textbackslash}backppprime & Reversed Triple Prime \\
\hline
U+02039 & ‹ & {\textbackslash}guilsinglleft & Single Left-Pointing Angle Quotation Mark / Left Pointing Single Guillemet \\
\hline
U+0203A & › & {\textbackslash}guilsinglright & Single Right-Pointing Angle Quotation Mark / Right Pointing Single Guillemet \\
\hline
U+0203C & ‼ & {\textbackslash}:bangbang: & Double Exclamation Mark \\
\hline
U+02040 & ⁀ & {\textbackslash}tieconcat & Character Tie \\
\hline
U+02049 & ⁉ & {\textbackslash}:interrobang: & Exclamation Question Mark \\
\hline
U+02057 & ⁗ & {\textbackslash}pppprime & Quadruple Prime \\
\hline
U+0205D & ⁝ & {\textbackslash}tricolon & Tricolon \\
\hline
U+02060 & ⁠ & {\textbackslash}nolinebreak & Word Joiner \\
\hline
U+02070 & ⁰ & {\textbackslash}{\textasciicircum}0 & Superscript Zero / Superscript Digit Zero \\
\hline
U+02071 & ⁱ & {\textbackslash}{\textasciicircum}i & Superscript Latin Small Letter I \\
\hline
U+02074 & ⁴ & {\textbackslash}{\textasciicircum}4 & Superscript Four / Superscript Digit Four \\
\hline
U+02075 & ⁵ & {\textbackslash}{\textasciicircum}5 & Superscript Five / Superscript Digit Five \\
\hline
U+02076 & ⁶ & {\textbackslash}{\textasciicircum}6 & Superscript Six / Superscript Digit Six \\
\hline
U+02077 & ⁷ & {\textbackslash}{\textasciicircum}7 & Superscript Seven / Superscript Digit Seven \\
\hline
U+02078 & ⁸ & {\textbackslash}{\textasciicircum}8 & Superscript Eight / Superscript Digit Eight \\
\hline
U+02079 & ⁹ & {\textbackslash}{\textasciicircum}9 & Superscript Nine / Superscript Digit Nine \\
\hline
U+0207A & ⁺ & {\textbackslash}{\textasciicircum}+ & Superscript Plus Sign \\
\hline
U+0207B & ⁻ & {\textbackslash}{\textasciicircum}- & Superscript Minus / Superscript Hyphen-Minus \\
\hline
U+0207C & ⁼ & {\textbackslash}{\textasciicircum}= & Superscript Equals Sign \\
\hline
U+0207D & ⁽ & {\textbackslash}{\textasciicircum}( & Superscript Left Parenthesis / Superscript Opening Parenthesis \\
\hline
U+0207E & ⁾ & {\textbackslash}{\textasciicircum}) & Superscript Right Parenthesis / Superscript Closing Parenthesis \\
\hline
U+0207F & ⁿ & {\textbackslash}{\textasciicircum}n & Superscript Latin Small Letter N \\
\hline
U+02080 & ₀ & {\textbackslash}\_0 & Subscript Zero / Subscript Digit Zero \\
\hline
U+02081 & ₁ & {\textbackslash}\_1 & Subscript One / Subscript Digit One \\
\hline
U+02082 & ₂ & {\textbackslash}\_2 & Subscript Two / Subscript Digit Two \\
\hline
U+02083 & ₃ & {\textbackslash}\_3 & Subscript Three / Subscript Digit Three \\
\hline
U+02084 & ₄ & {\textbackslash}\_4 & Subscript Four / Subscript Digit Four \\
\hline
U+02085 & ₅ & {\textbackslash}\_5 & Subscript Five / Subscript Digit Five \\
\hline
U+02086 & ₆ & {\textbackslash}\_6 & Subscript Six / Subscript Digit Six \\
\hline
U+02087 & ₇ & {\textbackslash}\_7 & Subscript Seven / Subscript Digit Seven \\
\hline
U+02088 & ₈ & {\textbackslash}\_8 & Subscript Eight / Subscript Digit Eight \\
\hline
U+02089 & ₉ & {\textbackslash}\_9 & Subscript Nine / Subscript Digit Nine \\
\hline
U+0208A & ₊ & {\textbackslash}\_+ & Subscript Plus Sign \\
\hline
U+0208B & ₋ & {\textbackslash}\_- & Subscript Minus / Subscript Hyphen-Minus \\
\hline
U+0208C & ₌ & {\textbackslash}\_= & Subscript Equals Sign \\
\hline
U+0208D & ₍ & {\textbackslash}\_( & Subscript Left Parenthesis / Subscript Opening Parenthesis \\
\hline
U+0208E & ₎ & {\textbackslash}\_) & Subscript Right Parenthesis / Subscript Closing Parenthesis \\
\hline
U+02090 & ₐ & {\textbackslash}\_a & Latin Subscript Small Letter A \\
\hline
U+02091 & ₑ & {\textbackslash}\_e & Latin Subscript Small Letter E \\
\hline
U+02092 & ₒ & {\textbackslash}\_o & Latin Subscript Small Letter O \\
\hline
U+02093 & ₓ & {\textbackslash}\_x & Latin Subscript Small Letter X \\
\hline
U+02094 & ₔ & {\textbackslash}\_schwa & Latin Subscript Small Letter Schwa \\
\hline
U+02095 & ₕ & {\textbackslash}\_h & Latin Subscript Small Letter H \\
\hline
U+02096 & ₖ & {\textbackslash}\_k & Latin Subscript Small Letter K \\
\hline
U+02097 & ₗ & {\textbackslash}\_l & Latin Subscript Small Letter L \\
\hline
U+02098 & ₘ & {\textbackslash}\_m & Latin Subscript Small Letter M \\
\hline
U+02099 & ₙ & {\textbackslash}\_n & Latin Subscript Small Letter N \\
\hline
U+0209A & ₚ & {\textbackslash}\_p & Latin Subscript Small Letter P \\
\hline
U+0209B & ₛ & {\textbackslash}\_s & Latin Subscript Small Letter S \\
\hline
U+0209C & ₜ & {\textbackslash}\_t & Latin Subscript Small Letter T \\
\hline
U+020A7 & ₧ & {\textbackslash}pes & Peseta Sign \\
\hline
U+020AC & € & {\textbackslash}euro & Euro Sign \\
\hline
U+020D0 &  ⃐  & {\textbackslash}leftharpoonaccent & Combining Left Harpoon Above / Non-Spacing Left Harpoon Above \\
\hline
U+020D1 &  ⃑  & {\textbackslash}rightharpoonaccent & Combining Right Harpoon Above / Non-Spacing Right Harpoon Above \\
\hline
U+020D2 &  ⃒  & {\textbackslash}vertoverlay & Combining Long Vertical Line Overlay / Non-Spacing Long Vertical Bar Overlay \\
\hline
U+020D6 &  ⃖  & {\textbackslash}overleftarrow & Combining Left Arrow Above / Non-Spacing Left Arrow Above \\
\hline
U+020D7 &  ⃗  & {\textbackslash}vec & Combining Right Arrow Above / Non-Spacing Right Arrow Above \\
\hline
U+020DB &  ⃛  & {\textbackslash}dddot & Combining Three Dots Above / Non-Spacing Three Dots Above \\
\hline
U+020DC &  ⃜  & {\textbackslash}ddddot & Combining Four Dots Above / Non-Spacing Four Dots Above \\
\hline
U+020DD &  ⃝  & {\textbackslash}enclosecircle & Combining Enclosing Circle / Enclosing Circle \\
\hline
U+020DE &  ⃞  & {\textbackslash}enclosesquare & Combining Enclosing Square / Enclosing Square \\
\hline
U+020DF &  ⃟  & {\textbackslash}enclosediamond & Combining Enclosing Diamond / Enclosing Diamond \\
\hline
U+020E1 &  ⃡  & {\textbackslash}overleftrightarrow & Combining Left Right Arrow Above / Non-Spacing Left Right Arrow Above \\
\hline
U+020E4 &  ⃤  & {\textbackslash}enclosetriangle & Combining Enclosing Upward Pointing Triangle \\
\hline
U+020E7 &  ⃧  & {\textbackslash}annuity & Combining Annuity Symbol \\
\hline
U+020E8 &  ⃨  & {\textbackslash}threeunderdot & Combining Triple Underdot \\
\hline
U+020E9 &  ⃩  & {\textbackslash}widebridgeabove & Combining Wide Bridge Above \\
\hline
U+020EC &  ⃬  & {\textbackslash}underrightharpoondown & Combining Rightwards Harpoon With Barb Downwards \\
\hline
U+020ED &  ⃭  & {\textbackslash}underleftharpoondown & Combining Leftwards Harpoon With Barb Downwards \\
\hline
U+020EE &  ⃮  & {\textbackslash}underleftarrow & Combining Left Arrow Below \\
\hline
U+020EF &  ⃯  & {\textbackslash}underrightarrow & Combining Right Arrow Below \\
\hline
U+020F0 &  ⃰  & {\textbackslash}asteraccent & Combining Asterisk Above \\
\hline
U+02102 & ℂ & {\textbackslash}bbC & Double-Struck Capital C / Double-Struck C \\
\hline
U+02107 & ℇ & {\textbackslash}eulermascheroni & Euler Constant / Eulers \\
\hline
U+0210A & ℊ & {\textbackslash}scrg & Script Small G \\
\hline
U+0210B & ℋ & {\textbackslash}scrH & Script Capital H / Script H \\
\hline
U+0210C & ℌ & {\textbackslash}frakH & Black-Letter Capital H / Black-Letter H \\
\hline
U+0210D & ℍ & {\textbackslash}bbH & Double-Struck Capital H / Double-Struck H \\
\hline
U+0210E & ℎ & {\textbackslash}planck & Planck Constant \\
\hline
U+0210F & ℏ & {\textbackslash}hslash & Planck Constant Over Two Pi / Planck Constant Over 2 Pi \\
\hline
U+02110 & ℐ & {\textbackslash}scrI & Script Capital I / Script I \\
\hline
U+02111 & ℑ & {\textbackslash}Im & Black-Letter Capital I / Black-Letter I \\
\hline
U+02112 & ℒ & {\textbackslash}scrL & Script Capital L / Script L \\
\hline
U+02113 & ℓ & {\textbackslash}ell & Script Small L \\
\hline
U+02115 & ℕ & {\textbackslash}bbN & Double-Struck Capital N / Double-Struck N \\
\hline
U+02116 & № & {\textbackslash}numero & Numero Sign / Numero \\
\hline
U+02118 & ℘ & {\textbackslash}wp & Script Capital P / Script P \\
\hline
U+02119 & ℙ & {\textbackslash}bbP & Double-Struck Capital P / Double-Struck P \\
\hline
U+0211A & ℚ & {\textbackslash}bbQ & Double-Struck Capital Q / Double-Struck Q \\
\hline
U+0211B & ℛ & {\textbackslash}scrR & Script Capital R / Script R \\
\hline
U+0211C & ℜ & {\textbackslash}Re & Black-Letter Capital R / Black-Letter R \\
\hline
U+0211D & ℝ & {\textbackslash}bbR & Double-Struck Capital R / Double-Struck R \\
\hline
U+0211E & ℞ & {\textbackslash}xrat & Prescription Take \\
\hline
U+02122 & ™ & {\textbackslash}trademark, {\textbackslash}:tm: & Trade Mark Sign / Trademark \\
\hline
U+02124 & ℤ & {\textbackslash}bbZ & Double-Struck Capital Z / Double-Struck Z \\
\hline
U+02126 & Ω & {\textbackslash}ohm & Ohm Sign / Ohm \\
\hline
U+02127 & ℧ & {\textbackslash}mho & Inverted Ohm Sign / Mho \\
\hline
U+02128 & ℨ & {\textbackslash}frakZ & Black-Letter Capital Z / Black-Letter Z \\
\hline
U+02129 & ℩ & {\textbackslash}turnediota & Turned Greek Small Letter Iota \\
\hline
U+0212B & Å & {\textbackslash}Angstrom & Angstrom Sign / Angstrom Unit \\
\hline
U+0212C & ℬ & {\textbackslash}scrB & Script Capital B / Script B \\
\hline
U+0212D & ℭ & {\textbackslash}frakC & Black-Letter Capital C / Black-Letter C \\
\hline
U+0212F & ℯ & {\textbackslash}scre, {\textbackslash}euler & Script Small E \\
\hline
U+02130 & ℰ & {\textbackslash}scrE & Script Capital E / Script E \\
\hline
U+02131 & ℱ & {\textbackslash}scrF & Script Capital F / Script F \\
\hline
U+02132 & Ⅎ & {\textbackslash}Finv & Turned Capital F / Turned F \\
\hline
U+02133 & ℳ & {\textbackslash}scrM & Script Capital M / Script M \\
\hline
U+02134 & ℴ & {\textbackslash}scro & Script Small O \\
\hline
U+02135 & ℵ & {\textbackslash}aleph & Alef Symbol / First Transfinite Cardinal \\
\hline
U+02136 & ℶ & {\textbackslash}beth & Bet Symbol / Second Transfinite Cardinal \\
\hline
U+02137 & ℷ & {\textbackslash}gimel & Gimel Symbol / Third Transfinite Cardinal \\
\hline
U+02138 & ℸ & {\textbackslash}daleth & Dalet Symbol / Fourth Transfinite Cardinal \\
\hline
U+02139 & ℹ & {\textbackslash}:information\_source: & Information Source \\
\hline
U+0213C & ℼ & {\textbackslash}bbpi & Double-Struck Small Pi \\
\hline
U+0213D & ℽ & {\textbackslash}bbgamma & Double-Struck Small Gamma \\
\hline
U+0213E & ℾ & {\textbackslash}bbGamma & Double-Struck Capital Gamma \\
\hline
U+0213F & ℿ & {\textbackslash}bbPi & Double-Struck Capital Pi \\
\hline
U+02140 & ⅀ & {\textbackslash}bbsum & Double-Struck N-Ary Summation \\
\hline
U+02141 & ⅁ & {\textbackslash}Game & Turned Sans-Serif Capital G \\
\hline
U+02142 & ⅂ & {\textbackslash}sansLturned & Turned Sans-Serif Capital L \\
\hline
U+02143 & ⅃ & {\textbackslash}sansLmirrored & Reversed Sans-Serif Capital L \\
\hline
U+02144 & ⅄ & {\textbackslash}Yup & Turned Sans-Serif Capital Y \\
\hline
U+02145 & ⅅ & {\textbackslash}bbiD & Double-Struck Italic Capital D \\
\hline
U+02146 & ⅆ & {\textbackslash}bbid & Double-Struck Italic Small D \\
\hline
U+02147 & ⅇ & {\textbackslash}bbie & Double-Struck Italic Small E \\
\hline
U+02148 & ⅈ & {\textbackslash}bbii & Double-Struck Italic Small I \\
\hline
U+02149 & ⅉ & {\textbackslash}bbij & Double-Struck Italic Small J \\
\hline
U+0214A & ⅊ & {\textbackslash}PropertyLine & Property Line \\
\hline
U+0214B & ⅋ & {\textbackslash}upand & Turned Ampersand \\
\hline
U+02150 & ⅐ & {\textbackslash}1/7 & Vulgar Fraction One Seventh \\
\hline
U+02151 & ⅑ & {\textbackslash}1/9 & Vulgar Fraction One Ninth \\
\hline
U+02152 & ⅒ & {\textbackslash}1/10 & Vulgar Fraction One Tenth \\
\hline
U+02153 & ⅓ & {\textbackslash}1/3 & Vulgar Fraction One Third / Fraction One Third \\
\hline
U+02154 & ⅔ & {\textbackslash}2/3 & Vulgar Fraction Two Thirds / Fraction Two Thirds \\
\hline
U+02155 & ⅕ & {\textbackslash}1/5 & Vulgar Fraction One Fifth / Fraction One Fifth \\
\hline
U+02156 & ⅖ & {\textbackslash}2/5 & Vulgar Fraction Two Fifths / Fraction Two Fifths \\
\hline
U+02157 & ⅗ & {\textbackslash}3/5 & Vulgar Fraction Three Fifths / Fraction Three Fifths \\
\hline
U+02158 & ⅘ & {\textbackslash}4/5 & Vulgar Fraction Four Fifths / Fraction Four Fifths \\
\hline
U+02159 & ⅙ & {\textbackslash}1/6 & Vulgar Fraction One Sixth / Fraction One Sixth \\
\hline
U+0215A & ⅚ & {\textbackslash}5/6 & Vulgar Fraction Five Sixths / Fraction Five Sixths \\
\hline
U+0215B & ⅛ & {\textbackslash}1/8 & Vulgar Fraction One Eighth / Fraction One Eighth \\
\hline
U+0215C & ⅜ & {\textbackslash}3/8 & Vulgar Fraction Three Eighths / Fraction Three Eighths \\
\hline
U+0215D & ⅝ & {\textbackslash}5/8 & Vulgar Fraction Five Eighths / Fraction Five Eighths \\
\hline
U+0215E & ⅞ & {\textbackslash}7/8 & Vulgar Fraction Seven Eighths / Fraction Seven Eighths \\
\hline
U+0215F & ⅟ & {\textbackslash}1/ & Fraction Numerator One \\
\hline
U+02189 & ↉ & {\textbackslash}0/3 & Vulgar Fraction Zero Thirds \\
\hline
U+02190 & ← & {\textbackslash}leftarrow & Leftwards Arrow / Left Arrow \\
\hline
U+02191 & ↑ & {\textbackslash}uparrow & Upwards Arrow / Up Arrow \\
\hline
U+02192 & → & {\textbackslash}to, {\textbackslash}rightarrow & Rightwards Arrow / Right Arrow \\
\hline
U+02193 & ↓ & {\textbackslash}downarrow & Downwards Arrow / Down Arrow \\
\hline
U+02194 & ↔ & {\textbackslash}leftrightarrow, {\textbackslash}:left\_right\_arrow: & Left Right Arrow \\
\hline
U+02195 & ↕ & {\textbackslash}updownarrow, {\textbackslash}:arrow\_up\_down: & Up Down Arrow \\
\hline
U+02196 & ↖ & {\textbackslash}nwarrow, {\textbackslash}:arrow\_upper\_left: & North West Arrow / Upper Left Arrow \\
\hline
U+02197 & ↗ & {\textbackslash}nearrow, {\textbackslash}:arrow\_upper\_right: & North East Arrow / Upper Right Arrow \\
\hline
U+02198 & ↘ & {\textbackslash}searrow, {\textbackslash}:arrow\_lower\_right: & South East Arrow / Lower Right Arrow \\
\hline
U+02199 & ↙ & {\textbackslash}swarrow, {\textbackslash}:arrow\_lower\_left: & South West Arrow / Lower Left Arrow \\
\hline
U+0219A & ↚ & {\textbackslash}nleftarrow & Leftwards Arrow With Stroke / Left Arrow With Stroke \\
\hline
U+0219B & ↛ & {\textbackslash}nrightarrow & Rightwards Arrow With Stroke / Right Arrow With Stroke \\
\hline
U+0219C & ↜ & {\textbackslash}leftwavearrow & Leftwards Wave Arrow / Left Wave Arrow \\
\hline
U+0219D & ↝ & {\textbackslash}rightwavearrow & Rightwards Wave Arrow / Right Wave Arrow \\
\hline
U+0219E & ↞ & {\textbackslash}twoheadleftarrow & Leftwards Two Headed Arrow / Left Two Headed Arrow \\
\hline
U+0219F & ↟ & {\textbackslash}twoheaduparrow & Upwards Two Headed Arrow / Up Two Headed Arrow \\
\hline
U+021A0 & ↠ & {\textbackslash}twoheadrightarrow & Rightwards Two Headed Arrow / Right Two Headed Arrow \\
\hline
U+021A1 & ↡ & {\textbackslash}twoheaddownarrow & Downwards Two Headed Arrow / Down Two Headed Arrow \\
\hline
U+021A2 & ↢ & {\textbackslash}leftarrowtail & Leftwards Arrow With Tail / Left Arrow With Tail \\
\hline
U+021A3 & ↣ & {\textbackslash}rightarrowtail & Rightwards Arrow With Tail / Right Arrow With Tail \\
\hline
U+021A4 & ↤ & {\textbackslash}mapsfrom & Leftwards Arrow From Bar / Left Arrow From Bar \\
\hline
U+021A5 & ↥ & {\textbackslash}mapsup & Upwards Arrow From Bar / Up Arrow From Bar \\
\hline
U+021A6 & ↦ & {\textbackslash}mapsto & Rightwards Arrow From Bar / Right Arrow From Bar \\
\hline
U+021A7 & ↧ & {\textbackslash}mapsdown & Downwards Arrow From Bar / Down Arrow From Bar \\
\hline
U+021A8 & ↨ & {\textbackslash}updownarrowbar & Up Down Arrow With Base \\
\hline
U+021A9 & ↩ & {\textbackslash}hookleftarrow, {\textbackslash}:leftwards\_arrow\_with\_hook: & Leftwards Arrow With Hook / Left Arrow With Hook \\
\hline
U+021AA & ↪ & {\textbackslash}hookrightarrow, {\textbackslash}:arrow\_right\_hook: & Rightwards Arrow With Hook / Right Arrow With Hook \\
\hline
U+021AB & ↫ & {\textbackslash}looparrowleft & Leftwards Arrow With Loop / Left Arrow With Loop \\
\hline
U+021AC & ↬ & {\textbackslash}looparrowright & Rightwards Arrow With Loop / Right Arrow With Loop \\
\hline
U+021AD & ↭ & {\textbackslash}leftrightsquigarrow & Left Right Wave Arrow \\
\hline
U+021AE & ↮ & {\textbackslash}nleftrightarrow & Left Right Arrow With Stroke \\
\hline
U+021AF & ↯ & {\textbackslash}downzigzagarrow & Downwards Zigzag Arrow / Down Zigzag Arrow \\
\hline
U+021B0 & ↰ & {\textbackslash}Lsh & Upwards Arrow With Tip Leftwards / Up Arrow With Tip Left \\
\hline
U+021B1 & ↱ & {\textbackslash}Rsh & Upwards Arrow With Tip Rightwards / Up Arrow With Tip Right \\
\hline
U+021B2 & ↲ & {\textbackslash}Ldsh & Downwards Arrow With Tip Leftwards / Down Arrow With Tip Left \\
\hline
U+021B3 & ↳ & {\textbackslash}Rdsh & Downwards Arrow With Tip Rightwards / Down Arrow With Tip Right \\
\hline
U+021B4 & ↴ & {\textbackslash}linefeed & Rightwards Arrow With Corner Downwards / Right Arrow With Corner Down \\
\hline
U+021B5 & ↵ & {\textbackslash}carriagereturn & Downwards Arrow With Corner Leftwards / Down Arrow With Corner Left \\
\hline
U+021B6 & ↶ & {\textbackslash}curvearrowleft & Anticlockwise Top Semicircle Arrow \\
\hline
U+021B7 & ↷ & {\textbackslash}curvearrowright & Clockwise Top Semicircle Arrow \\
\hline
U+021B8 & ↸ & {\textbackslash}barovernorthwestarrow & North West Arrow To Long Bar / Upper Left Arrow To Long Bar \\
\hline
U+021B9 & ↹ & {\textbackslash}barleftarrowrightarrowbar & Leftwards Arrow To Bar Over Rightwards Arrow To Bar / Left Arrow To Bar Over Right Arrow To Bar \\
\hline
U+021BA & ↺ & {\textbackslash}circlearrowleft & Anticlockwise Open Circle Arrow \\
\hline
U+021BB & ↻ & {\textbackslash}circlearrowright & Clockwise Open Circle Arrow \\
\hline
U+021BC & ↼ & {\textbackslash}leftharpoonup & Leftwards Harpoon With Barb Upwards / Left Harpoon With Barb Up \\
\hline
U+021BD & ↽ & {\textbackslash}leftharpoondown & Leftwards Harpoon With Barb Downwards / Left Harpoon With Barb Down \\
\hline
U+021BE & ↾ & {\textbackslash}upharpoonright & Upwards Harpoon With Barb Rightwards / Up Harpoon With Barb Right \\
\hline
U+021BF & ↿ & {\textbackslash}upharpoonleft & Upwards Harpoon With Barb Leftwards / Up Harpoon With Barb Left \\
\hline
U+021C0 & ⇀ & {\textbackslash}rightharpoonup & Rightwards Harpoon With Barb Upwards / Right Harpoon With Barb Up \\
\hline
U+021C1 & ⇁ & {\textbackslash}rightharpoondown & Rightwards Harpoon With Barb Downwards / Right Harpoon With Barb Down \\
\hline
U+021C2 & ⇂ & {\textbackslash}downharpoonright & Downwards Harpoon With Barb Rightwards / Down Harpoon With Barb Right \\
\hline
U+021C3 & ⇃ & {\textbackslash}downharpoonleft & Downwards Harpoon With Barb Leftwards / Down Harpoon With Barb Left \\
\hline
U+021C4 & ⇄ & {\textbackslash}rightleftarrows & Rightwards Arrow Over Leftwards Arrow / Right Arrow Over Left Arrow \\
\hline
U+021C5 & ⇅ & {\textbackslash}dblarrowupdown & Upwards Arrow Leftwards Of Downwards Arrow / Up Arrow Left Of Down Arrow \\
\hline
U+021C6 & ⇆ & {\textbackslash}leftrightarrows & Leftwards Arrow Over Rightwards Arrow / Left Arrow Over Right Arrow \\
\hline
U+021C7 & ⇇ & {\textbackslash}leftleftarrows & Leftwards Paired Arrows / Left Paired Arrows \\
\hline
U+021C8 & ⇈ & {\textbackslash}upuparrows & Upwards Paired Arrows / Up Paired Arrows \\
\hline
U+021C9 & ⇉ & {\textbackslash}rightrightarrows & Rightwards Paired Arrows / Right Paired Arrows \\
\hline
U+021CA & ⇊ & {\textbackslash}downdownarrows & Downwards Paired Arrows / Down Paired Arrows \\
\hline
U+021CB & ⇋ & {\textbackslash}leftrightharpoons & Leftwards Harpoon Over Rightwards Harpoon / Left Harpoon Over Right Harpoon \\
\hline
U+021CC & ⇌ & {\textbackslash}rightleftharpoons & Rightwards Harpoon Over Leftwards Harpoon / Right Harpoon Over Left Harpoon \\
\hline
U+021CD & ⇍ & {\textbackslash}nLeftarrow & Leftwards Double Arrow With Stroke / Left Double Arrow With Stroke \\
\hline
U+021CE & ⇎ & {\textbackslash}nLeftrightarrow & Left Right Double Arrow With Stroke \\
\hline
U+021CF & ⇏ & {\textbackslash}nRightarrow & Rightwards Double Arrow With Stroke / Right Double Arrow With Stroke \\
\hline
U+021D0 & ⇐ & {\textbackslash}Leftarrow & Leftwards Double Arrow / Left Double Arrow \\
\hline
U+021D1 & ⇑ & {\textbackslash}Uparrow & Upwards Double Arrow / Up Double Arrow \\
\hline
U+021D2 & ⇒ & {\textbackslash}Rightarrow & Rightwards Double Arrow / Right Double Arrow \\
\hline
U+021D3 & ⇓ & {\textbackslash}Downarrow & Downwards Double Arrow / Down Double Arrow \\
\hline
U+021D4 & ⇔ & {\textbackslash}Leftrightarrow & Left Right Double Arrow \\
\hline
U+021D5 & ⇕ & {\textbackslash}Updownarrow & Up Down Double Arrow \\
\hline
U+021D6 & ⇖ & {\textbackslash}Nwarrow & North West Double Arrow / Upper Left Double Arrow \\
\hline
U+021D7 & ⇗ & {\textbackslash}Nearrow & North East Double Arrow / Upper Right Double Arrow \\
\hline
U+021D8 & ⇘ & {\textbackslash}Searrow & South East Double Arrow / Lower Right Double Arrow \\
\hline
U+021D9 & ⇙ & {\textbackslash}Swarrow & South West Double Arrow / Lower Left Double Arrow \\
\hline
U+021DA & ⇚ & {\textbackslash}Lleftarrow & Leftwards Triple Arrow / Left Triple Arrow \\
\hline
U+021DB & ⇛ & {\textbackslash}Rrightarrow & Rightwards Triple Arrow / Right Triple Arrow \\
\hline
U+021DC & ⇜ & {\textbackslash}leftsquigarrow & Leftwards Squiggle Arrow / Left Squiggle Arrow \\
\hline
U+021DD & ⇝ & {\textbackslash}rightsquigarrow & Rightwards Squiggle Arrow / Right Squiggle Arrow \\
\hline
U+021DE & ⇞ & {\textbackslash}nHuparrow & Upwards Arrow With Double Stroke / Up Arrow With Double Stroke \\
\hline
U+021DF & ⇟ & {\textbackslash}nHdownarrow & Downwards Arrow With Double Stroke / Down Arrow With Double Stroke \\
\hline
U+021E0 & ⇠ & {\textbackslash}leftdasharrow & Leftwards Dashed Arrow / Left Dashed Arrow \\
\hline
U+021E1 & ⇡ & {\textbackslash}updasharrow & Upwards Dashed Arrow / Up Dashed Arrow \\
\hline
U+021E2 & ⇢ & {\textbackslash}rightdasharrow & Rightwards Dashed Arrow / Right Dashed Arrow \\
\hline
U+021E3 & ⇣ & {\textbackslash}downdasharrow & Downwards Dashed Arrow / Down Dashed Arrow \\
\hline
U+021E4 & ⇤ & {\textbackslash}barleftarrow & Leftwards Arrow To Bar / Left Arrow To Bar \\
\hline
U+021E5 & ⇥ & {\textbackslash}rightarrowbar & Rightwards Arrow To Bar / Right Arrow To Bar \\
\hline
U+021E6 & ⇦ & {\textbackslash}leftwhitearrow & Leftwards White Arrow / White Left Arrow \\
\hline
U+021E7 & ⇧ & {\textbackslash}upwhitearrow & Upwards White Arrow / White Up Arrow \\
\hline
U+021E8 & ⇨ & {\textbackslash}rightwhitearrow & Rightwards White Arrow / White Right Arrow \\
\hline
U+021E9 & ⇩ & {\textbackslash}downwhitearrow & Downwards White Arrow / White Down Arrow \\
\hline
U+021EA & ⇪ & {\textbackslash}whitearrowupfrombar & Upwards White Arrow From Bar / White Up Arrow From Bar \\
\hline
U+021F4 & ⇴ & {\textbackslash}circleonrightarrow & Right Arrow With Small Circle \\
\hline
U+021F5 & ⇵ & {\textbackslash}DownArrowUpArrow & Downwards Arrow Leftwards Of Upwards Arrow \\
\hline
U+021F6 & ⇶ & {\textbackslash}rightthreearrows & Three Rightwards Arrows \\
\hline
U+021F7 & ⇷ & {\textbackslash}nvleftarrow & Leftwards Arrow With Vertical Stroke \\
\hline
U+021F8 & ⇸ & {\textbackslash}nvrightarrow & Rightwards Arrow With Vertical Stroke \\
\hline
U+021F9 & ⇹ & {\textbackslash}nvleftrightarrow & Left Right Arrow With Vertical Stroke \\
\hline
U+021FA & ⇺ & {\textbackslash}nVleftarrow & Leftwards Arrow With Double Vertical Stroke \\
\hline
U+021FB & ⇻ & {\textbackslash}nVrightarrow & Rightwards Arrow With Double Vertical Stroke \\
\hline
U+021FC & ⇼ & {\textbackslash}nVleftrightarrow & Left Right Arrow With Double Vertical Stroke \\
\hline
U+021FD & ⇽ & {\textbackslash}leftarrowtriangle & Leftwards Open-Headed Arrow \\
\hline
U+021FE & ⇾ & {\textbackslash}rightarrowtriangle & Rightwards Open-Headed Arrow \\
\hline
U+021FF & ⇿ & {\textbackslash}leftrightarrowtriangle & Left Right Open-Headed Arrow \\
\hline
U+02200 & ∀ & {\textbackslash}forall & For All \\
\hline
U+02201 & ∁ & {\textbackslash}complement & Complement \\
\hline
U+02202 & ∂ & {\textbackslash}partial & Partial Differential \\
\hline
U+02203 & ∃ & {\textbackslash}exists & There Exists \\
\hline
U+02204 & ∄ & {\textbackslash}nexists & There Does Not Exist \\
\hline
U+02205 & ∅ & {\textbackslash}varnothing, {\textbackslash}emptyset & Empty Set \\
\hline
U+02206 & ∆ & {\textbackslash}increment & Increment \\
\hline
U+02207 & ∇ & {\textbackslash}del, {\textbackslash}nabla & Nabla \\
\hline
U+02208 & ∈ & {\textbackslash}in & Element Of \\
\hline
U+02209 & ∉ & {\textbackslash}notin & Not An Element Of \\
\hline
U+0220A & ∊ & {\textbackslash}smallin & Small Element Of \\
\hline
U+0220B & ∋ & {\textbackslash}ni & Contains As Member \\
\hline
U+0220C & ∌ & {\textbackslash}nni & Does Not Contain As Member \\
\hline
U+0220D & ∍ & {\textbackslash}smallni & Small Contains As Member \\
\hline
U+0220E & ∎ & {\textbackslash}QED & End Of Proof \\
\hline
U+0220F & ∏ & {\textbackslash}prod & N-Ary Product \\
\hline
U+02210 & ∐ & {\textbackslash}coprod & N-Ary Coproduct \\
\hline
U+02211 & ∑ & {\textbackslash}sum & N-Ary Summation \\
\hline
U+02212 & − & {\textbackslash}minus & Minus Sign \\
\hline
U+02213 & ∓ & {\textbackslash}mp & Minus-Or-Plus Sign \\
\hline
U+02214 & ∔ & {\textbackslash}dotplus & Dot Plus \\
\hline
U+02216 & ∖ & {\textbackslash}setminus & Set Minus \\
\hline
U+02217 & ∗ & {\textbackslash}ast & Asterisk Operator \\
\hline
U+02218 & ∘ & {\textbackslash}circ & Ring Operator \\
\hline
U+02219 & ∙ & {\textbackslash}vysmblkcircle & Bullet Operator \\
\hline
U+0221A & √ & {\textbackslash}surd, {\textbackslash}sqrt & Square Root \\
\hline
U+0221B & ∛ & {\textbackslash}cbrt & Cube Root \\
\hline
U+0221C & ∜ & {\textbackslash}fourthroot & Fourth Root \\
\hline
U+0221D & ∝ & {\textbackslash}propto & Proportional To \\
\hline
U+0221E & ∞ & {\textbackslash}infty & Infinity \\
\hline
U+0221F & ∟ & {\textbackslash}rightangle & Right Angle \\
\hline
U+02220 & ∠ & {\textbackslash}angle & Angle \\
\hline
U+02221 & ∡ & {\textbackslash}measuredangle & Measured Angle \\
\hline
U+02222 & ∢ & {\textbackslash}sphericalangle & Spherical Angle \\
\hline
U+02223 & ∣ & {\textbackslash}mid & Divides \\
\hline
U+02224 & ∤ & {\textbackslash}nmid & Does Not Divide \\
\hline
U+02225 & ∥ & {\textbackslash}parallel & Parallel To \\
\hline
U+02226 & ∦ & {\textbackslash}nparallel & Not Parallel To \\
\hline
U+02227 & ∧ & {\textbackslash}wedge & Logical And \\
\hline
U+02228 & ∨ & {\textbackslash}vee & Logical Or \\
\hline
U+02229 & ∩ & {\textbackslash}cap & Intersection \\
\hline
U+0222A & ∪ & {\textbackslash}cup & Union \\
\hline
U+0222B & ∫ & {\textbackslash}int & Integral \\
\hline
U+0222C & ∬ & {\textbackslash}iint & Double Integral \\
\hline
U+0222D & ∭ & {\textbackslash}iiint & Triple Integral \\
\hline
U+0222E & ∮ & {\textbackslash}oint & Contour Integral \\
\hline
U+0222F & ∯ & {\textbackslash}oiint & Surface Integral \\
\hline
U+02230 & ∰ & {\textbackslash}oiiint & Volume Integral \\
\hline
U+02231 & ∱ & {\textbackslash}clwintegral & Clockwise Integral \\
\hline
U+02232 & ∲ & {\textbackslash}varointclockwise & Clockwise Contour Integral \\
\hline
U+02233 & ∳ & {\textbackslash}ointctrclockwise & Anticlockwise Contour Integral \\
\hline
U+02234 & ∴ & {\textbackslash}therefore & Therefore \\
\hline
U+02235 & ∵ & {\textbackslash}because & Because \\
\hline
U+02237 & ∷ & {\textbackslash}Colon & Proportion \\
\hline
U+02238 & ∸ & {\textbackslash}dotminus & Dot Minus \\
\hline
U+0223A & ∺ & {\textbackslash}dotsminusdots & Geometric Proportion \\
\hline
U+0223B & ∻ & {\textbackslash}kernelcontraction & Homothetic \\
\hline
U+0223C & ∼ & {\textbackslash}sim & Tilde Operator \\
\hline
U+0223D & ∽ & {\textbackslash}backsim & Reversed Tilde \\
\hline
U+0223E & ∾ & {\textbackslash}lazysinv & Inverted Lazy S \\
\hline
U+0223F & ∿ & {\textbackslash}sinewave & Sine Wave \\
\hline
U+02240 & ≀ & {\textbackslash}wr & Wreath Product \\
\hline
U+02241 & ≁ & {\textbackslash}nsim & Not Tilde \\
\hline
U+02242 & ≂ & {\textbackslash}eqsim & Minus Tilde \\
\hline
U+02242 + U+00338 & ≂̸ & {\textbackslash}neqsim & Minus Tilde + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay \\
\hline
U+02243 & ≃ & {\textbackslash}simeq & Asymptotically Equal To \\
\hline
U+02244 & ≄ & {\textbackslash}nsime & Not Asymptotically Equal To \\
\hline
U+02245 & ≅ & {\textbackslash}cong & Approximately Equal To \\
\hline
U+02246 & ≆ & {\textbackslash}approxnotequal & Approximately But Not Actually Equal To \\
\hline
U+02247 & ≇ & {\textbackslash}ncong & Neither Approximately Nor Actually Equal To \\
\hline
U+02248 & ≈ & {\textbackslash}approx & Almost Equal To \\
\hline
U+02249 & ≉ & {\textbackslash}napprox & Not Almost Equal To \\
\hline
U+0224A & ≊ & {\textbackslash}approxeq & Almost Equal Or Equal To \\
\hline
U+0224B & ≋ & {\textbackslash}tildetrpl & Triple Tilde \\
\hline
U+0224C & ≌ & {\textbackslash}allequal & All Equal To \\
\hline
U+0224D & ≍ & {\textbackslash}asymp & Equivalent To \\
\hline
U+0224E & ≎ & {\textbackslash}Bumpeq & Geometrically Equivalent To \\
\hline
U+0224E + U+00338 & ≎̸ & {\textbackslash}nBumpeq & Geometrically Equivalent To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay \\
\hline
U+0224F & ≏ & {\textbackslash}bumpeq & Difference Between \\
\hline
U+0224F + U+00338 & ≏̸ & {\textbackslash}nbumpeq & Difference Between + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay \\
\hline
U+02250 & ≐ & {\textbackslash}doteq & Approaches The Limit \\
\hline
U+02251 & ≑ & {\textbackslash}Doteq & Geometrically Equal To \\
\hline
U+02252 & ≒ & {\textbackslash}fallingdotseq & Approximately Equal To Or The Image Of \\
\hline
U+02253 & ≓ & {\textbackslash}risingdotseq & Image Of Or Approximately Equal To \\
\hline
U+02254 & ≔ & {\textbackslash}coloneq & Colon Equals / Colon Equal \\
\hline
U+02255 & ≕ & {\textbackslash}eqcolon & Equals Colon / Equal Colon \\
\hline
U+02256 & ≖ & {\textbackslash}eqcirc & Ring In Equal To \\
\hline
U+02257 & ≗ & {\textbackslash}circeq & Ring Equal To \\
\hline
U+02258 & ≘ & {\textbackslash}arceq & Corresponds To \\
\hline
U+02259 & ≙ & {\textbackslash}wedgeq & Estimates \\
\hline
U+0225A & ≚ & {\textbackslash}veeeq & Equiangular To \\
\hline
U+0225B & ≛ & {\textbackslash}starequal & Star Equals \\
\hline
U+0225C & ≜ & {\textbackslash}triangleq & Delta Equal To \\
\hline
U+0225D & ≝ & {\textbackslash}eqdef & Equal To By Definition \\
\hline
U+0225E & ≞ & {\textbackslash}measeq & Measured By \\
\hline
U+0225F & ≟ & {\textbackslash}questeq & Questioned Equal To \\
\hline
U+02260 & ≠ & {\textbackslash}ne & Not Equal To \\
\hline
U+02261 & ≡ & {\textbackslash}equiv & Identical To \\
\hline
U+02262 & ≢ & {\textbackslash}nequiv & Not Identical To \\
\hline
U+02263 & ≣ & {\textbackslash}Equiv & Strictly Equivalent To \\
\hline
U+02264 & ≤ & {\textbackslash}le, {\textbackslash}leq & Less-Than Or Equal To / Less Than Or Equal To \\
\hline
U+02265 & ≥ & {\textbackslash}ge, {\textbackslash}geq & Greater-Than Or Equal To / Greater Than Or Equal To \\
\hline
U+02266 & ≦ & {\textbackslash}leqq & Less-Than Over Equal To / Less Than Over Equal To \\
\hline
U+02267 & ≧ & {\textbackslash}geqq & Greater-Than Over Equal To / Greater Than Over Equal To \\
\hline
U+02268 & ≨ & {\textbackslash}lneqq & Less-Than But Not Equal To / Less Than But Not Equal To \\
\hline
U+02268 + U+0FE00 & ≨︀ & {\textbackslash}lvertneqq & Less-Than But Not Equal To / Less Than But Not Equal To + Variation Selector-1 \\
\hline
U+02269 & ≩ & {\textbackslash}gneqq & Greater-Than But Not Equal To / Greater Than But Not Equal To \\
\hline
U+02269 + U+0FE00 & ≩︀ & {\textbackslash}gvertneqq & Greater-Than But Not Equal To / Greater Than But Not Equal To + Variation Selector-1 \\
\hline
U+0226A & ≪ & {\textbackslash}ll & Much Less-Than / Much Less Than \\
\hline
U+0226A + U+00338 & ≪̸ & {\textbackslash}NotLessLess & Much Less-Than / Much Less Than + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay \\
\hline
U+0226B & ≫ & {\textbackslash}gg & Much Greater-Than / Much Greater Than \\
\hline
U+0226B + U+00338 & ≫̸ & {\textbackslash}NotGreaterGreater & Much Greater-Than / Much Greater Than + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay \\
\hline
U+0226C & ≬ & {\textbackslash}between & Between \\
\hline
U+0226D & ≭ & {\textbackslash}nasymp & Not Equivalent To \\
\hline
U+0226E & ≮ & {\textbackslash}nless & Not Less-Than / Not Less Than \\
\hline
U+0226F & ≯ & {\textbackslash}ngtr & Not Greater-Than / Not Greater Than \\
\hline
U+02270 & ≰ & {\textbackslash}nleq & Neither Less-Than Nor Equal To / Neither Less Than Nor Equal To \\
\hline
U+02271 & ≱ & {\textbackslash}ngeq & Neither Greater-Than Nor Equal To / Neither Greater Than Nor Equal To \\
\hline
U+02272 & ≲ & {\textbackslash}lesssim & Less-Than Or Equivalent To / Less Than Or Equivalent To \\
\hline
U+02273 & ≳ & {\textbackslash}gtrsim & Greater-Than Or Equivalent To / Greater Than Or Equivalent To \\
\hline
U+02274 & ≴ & {\textbackslash}nlesssim & Neither Less-Than Nor Equivalent To / Neither Less Than Nor Equivalent To \\
\hline
U+02275 & ≵ & {\textbackslash}ngtrsim & Neither Greater-Than Nor Equivalent To / Neither Greater Than Nor Equivalent To \\
\hline
U+02276 & ≶ & {\textbackslash}lessgtr & Less-Than Or Greater-Than / Less Than Or Greater Than \\
\hline
U+02277 & ≷ & {\textbackslash}gtrless & Greater-Than Or Less-Than / Greater Than Or Less Than \\
\hline
U+02278 & ≸ & {\textbackslash}notlessgreater & Neither Less-Than Nor Greater-Than / Neither Less Than Nor Greater Than \\
\hline
U+02279 & ≹ & {\textbackslash}notgreaterless & Neither Greater-Than Nor Less-Than / Neither Greater Than Nor Less Than \\
\hline
U+0227A & ≺ & {\textbackslash}prec & Precedes \\
\hline
U+0227B & ≻ & {\textbackslash}succ & Succeeds \\
\hline
U+0227C & ≼ & {\textbackslash}preccurlyeq & Precedes Or Equal To \\
\hline
U+0227D & ≽ & {\textbackslash}succcurlyeq & Succeeds Or Equal To \\
\hline
U+0227E & ≾ & {\textbackslash}precsim & Precedes Or Equivalent To \\
\hline
U+0227E + U+00338 & ≾̸ & {\textbackslash}nprecsim & Precedes Or Equivalent To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay \\
\hline
U+0227F & ≿ & {\textbackslash}succsim & Succeeds Or Equivalent To \\
\hline
U+0227F + U+00338 & ≿̸ & {\textbackslash}nsuccsim & Succeeds Or Equivalent To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay \\
\hline
U+02280 & ⊀ & {\textbackslash}nprec & Does Not Precede \\
\hline
U+02281 & ⊁ & {\textbackslash}nsucc & Does Not Succeed \\
\hline
U+02282 & ⊂ & {\textbackslash}subset & Subset Of \\
\hline
U+02283 & ⊃ & {\textbackslash}supset & Superset Of \\
\hline
U+02284 & ⊄ & {\textbackslash}nsubset & Not A Subset Of \\
\hline
U+02285 & ⊅ & {\textbackslash}nsupset & Not A Superset Of \\
\hline
U+02286 & ⊆ & {\textbackslash}subseteq & Subset Of Or Equal To \\
\hline
U+02287 & ⊇ & {\textbackslash}supseteq & Superset Of Or Equal To \\
\hline
U+02288 & ⊈ & {\textbackslash}nsubseteq & Neither A Subset Of Nor Equal To \\
\hline
U+02289 & ⊉ & {\textbackslash}nsupseteq & Neither A Superset Of Nor Equal To \\
\hline
U+0228A & ⊊ & {\textbackslash}subsetneq & Subset Of With Not Equal To / Subset Of Or Not Equal To \\
\hline
U+0228A + U+0FE00 & ⊊︀ & {\textbackslash}varsubsetneqq & Subset Of With Not Equal To / Subset Of Or Not Equal To + Variation Selector-1 \\
\hline
U+0228B & ⊋ & {\textbackslash}supsetneq & Superset Of With Not Equal To / Superset Of Or Not Equal To \\
\hline
U+0228B + U+0FE00 & ⊋︀ & {\textbackslash}varsupsetneq & Superset Of With Not Equal To / Superset Of Or Not Equal To + Variation Selector-1 \\
\hline
U+0228D & ⊍ & {\textbackslash}cupdot & Multiset Multiplication \\
\hline
U+0228E & ⊎ & {\textbackslash}uplus & Multiset Union \\
\hline
U+0228F & ⊏ & {\textbackslash}sqsubset & Square Image Of \\
\hline
U+0228F + U+00338 & ⊏̸ & {\textbackslash}NotSquareSubset & Square Image Of + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay \\
\hline
U+02290 & ⊐ & {\textbackslash}sqsupset & Square Original Of \\
\hline
U+02290 + U+00338 & ⊐̸ & {\textbackslash}NotSquareSuperset & Square Original Of + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay \\
\hline
U+02291 & ⊑ & {\textbackslash}sqsubseteq & Square Image Of Or Equal To \\
\hline
U+02292 & ⊒ & {\textbackslash}sqsupseteq & Square Original Of Or Equal To \\
\hline
U+02293 & ⊓ & {\textbackslash}sqcap & Square Cap \\
\hline
U+02294 & ⊔ & {\textbackslash}sqcup & Square Cup \\
\hline
U+02295 & ⊕ & {\textbackslash}oplus & Circled Plus \\
\hline
U+02296 & ⊖ & {\textbackslash}ominus & Circled Minus \\
\hline
U+02297 & ⊗ & {\textbackslash}otimes & Circled Times \\
\hline
U+02298 & ⊘ & {\textbackslash}oslash & Circled Division Slash \\
\hline
U+02299 & ⊙ & {\textbackslash}odot & Circled Dot Operator \\
\hline
U+0229A & ⊚ & {\textbackslash}circledcirc & Circled Ring Operator \\
\hline
U+0229B & ⊛ & {\textbackslash}circledast & Circled Asterisk Operator \\
\hline
U+0229C & ⊜ & {\textbackslash}circledequal & Circled Equals \\
\hline
U+0229D & ⊝ & {\textbackslash}circleddash & Circled Dash \\
\hline
U+0229E & ⊞ & {\textbackslash}boxplus & Squared Plus \\
\hline
U+0229F & ⊟ & {\textbackslash}boxminus & Squared Minus \\
\hline
U+022A0 & ⊠ & {\textbackslash}boxtimes & Squared Times \\
\hline
U+022A1 & ⊡ & {\textbackslash}boxdot & Squared Dot Operator \\
\hline
U+022A2 & ⊢ & {\textbackslash}vdash & Right Tack \\
\hline
U+022A3 & ⊣ & {\textbackslash}dashv & Left Tack \\
\hline
U+022A4 & ⊤ & {\textbackslash}top & Down Tack \\
\hline
U+022A5 & ⊥ & {\textbackslash}bot & Up Tack \\
\hline
U+022A7 & ⊧ & {\textbackslash}models & Models \\
\hline
U+022A8 & ⊨ & {\textbackslash}vDash & True \\
\hline
U+022A9 & ⊩ & {\textbackslash}Vdash & Forces \\
\hline
U+022AA & ⊪ & {\textbackslash}Vvdash & Triple Vertical Bar Right Turnstile \\
\hline
U+022AB & ⊫ & {\textbackslash}VDash & Double Vertical Bar Double Right Turnstile \\
\hline
U+022AC & ⊬ & {\textbackslash}nvdash & Does Not Prove \\
\hline
U+022AD & ⊭ & {\textbackslash}nvDash & Not True \\
\hline
U+022AE & ⊮ & {\textbackslash}nVdash & Does Not Force \\
\hline
U+022AF & ⊯ & {\textbackslash}nVDash & Negated Double Vertical Bar Double Right Turnstile \\
\hline
U+022B0 & ⊰ & {\textbackslash}prurel & Precedes Under Relation \\
\hline
U+022B1 & ⊱ & {\textbackslash}scurel & Succeeds Under Relation \\
\hline
U+022B2 & ⊲ & {\textbackslash}vartriangleleft & Normal Subgroup Of \\
\hline
U+022B3 & ⊳ & {\textbackslash}vartriangleright & Contains As Normal Subgroup \\
\hline
U+022B4 & ⊴ & {\textbackslash}trianglelefteq & Normal Subgroup Of Or Equal To \\
\hline
U+022B5 & ⊵ & {\textbackslash}trianglerighteq & Contains As Normal Subgroup Or Equal To \\
\hline
U+022B6 & ⊶ & {\textbackslash}original & Original Of \\
\hline
U+022B7 & ⊷ & {\textbackslash}image & Image Of \\
\hline
U+022B8 & ⊸ & {\textbackslash}multimap & Multimap \\
\hline
U+022B9 & ⊹ & {\textbackslash}hermitconjmatrix & Hermitian Conjugate Matrix \\
\hline
U+022BA & ⊺ & {\textbackslash}intercal & Intercalate \\
\hline
U+022BB & ⊻ & {\textbackslash}veebar, {\textbackslash}xor & Xor \\
\hline
U+022BC & ⊼ & {\textbackslash}barwedge & Nand \\
\hline
U+022BD & ⊽ & {\textbackslash}barvee & Nor \\
\hline
U+022BE & ⊾ & {\textbackslash}rightanglearc & Right Angle With Arc \\
\hline
U+022BF & ⊿ & {\textbackslash}varlrtriangle & Right Triangle \\
\hline
U+022C0 & ⋀ & {\textbackslash}bigwedge & N-Ary Logical And \\
\hline
U+022C1 & ⋁ & {\textbackslash}bigvee & N-Ary Logical Or \\
\hline
U+022C2 & ⋂ & {\textbackslash}bigcap & N-Ary Intersection \\
\hline
U+022C3 & ⋃ & {\textbackslash}bigcup & N-Ary Union \\
\hline
U+022C4 & ⋄ & {\textbackslash}diamond & Diamond Operator \\
\hline
U+022C5 & ⋅ & {\textbackslash}cdot & Dot Operator \\
\hline
U+022C6 & ⋆ & {\textbackslash}star & Star Operator \\
\hline
U+022C7 & ⋇ & {\textbackslash}divideontimes & Division Times \\
\hline
U+022C8 & ⋈ & {\textbackslash}bowtie & Bowtie \\
\hline
U+022C9 & ⋉ & {\textbackslash}ltimes & Left Normal Factor Semidirect Product \\
\hline
U+022CA & ⋊ & {\textbackslash}rtimes & Right Normal Factor Semidirect Product \\
\hline
U+022CB & ⋋ & {\textbackslash}leftthreetimes & Left Semidirect Product \\
\hline
U+022CC & ⋌ & {\textbackslash}rightthreetimes & Right Semidirect Product \\
\hline
U+022CD & ⋍ & {\textbackslash}backsimeq & Reversed Tilde Equals \\
\hline
U+022CE & ⋎ & {\textbackslash}curlyvee & Curly Logical Or \\
\hline
U+022CF & ⋏ & {\textbackslash}curlywedge & Curly Logical And \\
\hline
U+022D0 & ⋐ & {\textbackslash}Subset & Double Subset \\
\hline
U+022D1 & ⋑ & {\textbackslash}Supset & Double Superset \\
\hline
U+022D2 & ⋒ & {\textbackslash}Cap & Double Intersection \\
\hline
U+022D3 & ⋓ & {\textbackslash}Cup & Double Union \\
\hline
U+022D4 & ⋔ & {\textbackslash}pitchfork & Pitchfork \\
\hline
U+022D5 & ⋕ & {\textbackslash}equalparallel & Equal And Parallel To \\
\hline
U+022D6 & ⋖ & {\textbackslash}lessdot & Less-Than With Dot / Less Than With Dot \\
\hline
U+022D7 & ⋗ & {\textbackslash}gtrdot & Greater-Than With Dot / Greater Than With Dot \\
\hline
U+022D8 & ⋘ & {\textbackslash}verymuchless & Very Much Less-Than / Very Much Less Than \\
\hline
U+022D9 & ⋙ & {\textbackslash}ggg & Very Much Greater-Than / Very Much Greater Than \\
\hline
U+022DA & ⋚ & {\textbackslash}lesseqgtr & Less-Than Equal To Or Greater-Than / Less Than Equal To Or Greater Than \\
\hline
U+022DB & ⋛ & {\textbackslash}gtreqless & Greater-Than Equal To Or Less-Than / Greater Than Equal To Or Less Than \\
\hline
U+022DC & ⋜ & {\textbackslash}eqless & Equal To Or Less-Than / Equal To Or Less Than \\
\hline
U+022DD & ⋝ & {\textbackslash}eqgtr & Equal To Or Greater-Than / Equal To Or Greater Than \\
\hline
U+022DE & ⋞ & {\textbackslash}curlyeqprec & Equal To Or Precedes \\
\hline
U+022DF & ⋟ & {\textbackslash}curlyeqsucc & Equal To Or Succeeds \\
\hline
U+022E0 & ⋠ & {\textbackslash}npreccurlyeq & Does Not Precede Or Equal \\
\hline
U+022E1 & ⋡ & {\textbackslash}nsucccurlyeq & Does Not Succeed Or Equal \\
\hline
U+022E2 & ⋢ & {\textbackslash}nsqsubseteq & Not Square Image Of Or Equal To \\
\hline
U+022E3 & ⋣ & {\textbackslash}nsqsupseteq & Not Square Original Of Or Equal To \\
\hline
U+022E4 & ⋤ & {\textbackslash}sqsubsetneq & Square Image Of Or Not Equal To \\
\hline
U+022E5 & ⋥ & {\textbackslash}sqspne & Square Original Of Or Not Equal To \\
\hline
U+022E6 & ⋦ & {\textbackslash}lnsim & Less-Than But Not Equivalent To / Less Than But Not Equivalent To \\
\hline
U+022E7 & ⋧ & {\textbackslash}gnsim & Greater-Than But Not Equivalent To / Greater Than But Not Equivalent To \\
\hline
U+022E8 & ⋨ & {\textbackslash}precnsim & Precedes But Not Equivalent To \\
\hline
U+022E9 & ⋩ & {\textbackslash}succnsim & Succeeds But Not Equivalent To \\
\hline
U+022EA & ⋪ & {\textbackslash}ntriangleleft & Not Normal Subgroup Of \\
\hline
U+022EB & ⋫ & {\textbackslash}ntriangleright & Does Not Contain As Normal Subgroup \\
\hline
U+022EC & ⋬ & {\textbackslash}ntrianglelefteq & Not Normal Subgroup Of Or Equal To \\
\hline
U+022ED & ⋭ & {\textbackslash}ntrianglerighteq & Does Not Contain As Normal Subgroup Or Equal \\
\hline
U+022EE & ⋮ & {\textbackslash}vdots & Vertical Ellipsis \\
\hline
U+022EF & ⋯ & {\textbackslash}cdots & Midline Horizontal Ellipsis \\
\hline
U+022F0 & ⋰ & {\textbackslash}adots & Up Right Diagonal Ellipsis \\
\hline
U+022F1 & ⋱ & {\textbackslash}ddots & Down Right Diagonal Ellipsis \\
\hline
U+022F2 & ⋲ & {\textbackslash}disin & Element Of With Long Horizontal Stroke \\
\hline
U+022F3 & ⋳ & {\textbackslash}varisins & Element Of With Vertical Bar At End Of Horizontal Stroke \\
\hline
U+022F4 & ⋴ & {\textbackslash}isins & Small Element Of With Vertical Bar At End Of Horizontal Stroke \\
\hline
U+022F5 & ⋵ & {\textbackslash}isindot & Element Of With Dot Above \\
\hline
U+022F6 & ⋶ & {\textbackslash}varisinobar & Element Of With Overbar \\
\hline
U+022F7 & ⋷ & {\textbackslash}isinobar & Small Element Of With Overbar \\
\hline
U+022F8 & ⋸ & {\textbackslash}isinvb & Element Of With Underbar \\
\hline
U+022F9 & ⋹ & {\textbackslash}isinE & Element Of With Two Horizontal Strokes \\
\hline
U+022FA & ⋺ & {\textbackslash}nisd & Contains With Long Horizontal Stroke \\
\hline
U+022FB & ⋻ & {\textbackslash}varnis & Contains With Vertical Bar At End Of Horizontal Stroke \\
\hline
U+022FC & ⋼ & {\textbackslash}nis & Small Contains With Vertical Bar At End Of Horizontal Stroke \\
\hline
U+022FD & ⋽ & {\textbackslash}varniobar & Contains With Overbar \\
\hline
U+022FE & ⋾ & {\textbackslash}niobar & Small Contains With Overbar \\
\hline
U+022FF & ⋿ & {\textbackslash}bagmember & Z Notation Bag Membership \\
\hline
U+02300 & ⌀ & {\textbackslash}diameter & Diameter Sign \\
\hline
U+02302 & ⌂ & {\textbackslash}house & House \\
\hline
U+02305 & ⌅ & {\textbackslash}varbarwedge & Projective \\
\hline
U+02306 & ⌆ & {\textbackslash}vardoublebarwedge & Perspective \\
\hline
U+02308 & ⌈ & {\textbackslash}lceil & Left Ceiling \\
\hline
U+02309 & ⌉ & {\textbackslash}rceil & Right Ceiling \\
\hline
U+0230A & ⌊ & {\textbackslash}lfloor & Left Floor \\
\hline
U+0230B & ⌋ & {\textbackslash}rfloor & Right Floor \\
\hline
U+02310 & ⌐ & {\textbackslash}invnot & Reversed Not Sign \\
\hline
U+02311 & ⌑ & {\textbackslash}sqlozenge & Square Lozenge \\
\hline
U+02312 & ⌒ & {\textbackslash}profline & Arc \\
\hline
U+02313 & ⌓ & {\textbackslash}profsurf & Segment \\
\hline
U+02315 & ⌕ & {\textbackslash}recorder & Telephone Recorder \\
\hline
U+02317 & ⌗ & {\textbackslash}viewdata & Viewdata Square \\
\hline
U+02319 & ⌙ & {\textbackslash}turnednot & Turned Not Sign \\
\hline
U+0231A & ⌚ & {\textbackslash}:watch: & Watch \\
\hline
U+0231B & ⌛ & {\textbackslash}:hourglass: & Hourglass \\
\hline
U+0231C & ⌜ & {\textbackslash}ulcorner & Top Left Corner \\
\hline
U+0231D & ⌝ & {\textbackslash}urcorner & Top Right Corner \\
\hline
U+0231E & ⌞ & {\textbackslash}llcorner & Bottom Left Corner \\
\hline
U+0231F & ⌟ & {\textbackslash}lrcorner & Bottom Right Corner \\
\hline
U+02322 & ⌢ & {\textbackslash}frown & Frown \\
\hline
U+02323 & ⌣ & {\textbackslash}smile & Smile \\
\hline
U+0232C & ⌬ & {\textbackslash}varhexagonlrbonds & Benzene Ring \\
\hline
U+02332 & ⌲ & {\textbackslash}conictaper & Conical Taper \\
\hline
U+02336 & ⌶ & {\textbackslash}topbot & Apl Functional Symbol I-Beam \\
\hline
U+0233D & ⌽ & {\textbackslash}obar & Apl Functional Symbol Circle Stile \\
\hline
U+0233F & ⌿ & {\textbackslash}notslash & Apl Functional Symbol Slash Bar \\
\hline
U+02340 & ⍀ & {\textbackslash}notbackslash & Apl Functional Symbol Backslash Bar \\
\hline
U+02353 & ⍓ & {\textbackslash}boxupcaret & Apl Functional Symbol Quad Up Caret \\
\hline
U+02370 & ⍰ & {\textbackslash}boxquestion & Apl Functional Symbol Quad Question \\
\hline
U+02394 & ⎔ & {\textbackslash}hexagon & Software-Function Symbol \\
\hline
U+023A3 & ⎣ & {\textbackslash}dlcorn & Left Square Bracket Lower Corner \\
\hline
U+023B0 & ⎰ & {\textbackslash}lmoustache & Upper Left Or Lower Right Curly Bracket Section \\
\hline
U+023B1 & ⎱ & {\textbackslash}rmoustache & Upper Right Or Lower Left Curly Bracket Section \\
\hline
U+023B4 & ⎴ & {\textbackslash}overbracket & Top Square Bracket \\
\hline
U+023B5 & ⎵ & {\textbackslash}underbracket & Bottom Square Bracket \\
\hline
U+023B6 & ⎶ & {\textbackslash}bbrktbrk & Bottom Square Bracket Over Top Square Bracket \\
\hline
U+023B7 & ⎷ & {\textbackslash}sqrtbottom & Radical Symbol Bottom \\
\hline
U+023B8 & ⎸ & {\textbackslash}lvboxline & Left Vertical Box Line \\
\hline
U+023B9 & ⎹ & {\textbackslash}rvboxline & Right Vertical Box Line \\
\hline
U+023CE & ⏎ & {\textbackslash}varcarriagereturn & Return Symbol \\
\hline
U+023DE & ⏞ & {\textbackslash}overbrace & Top Curly Bracket \\
\hline
U+023DF & ⏟ & {\textbackslash}underbrace & Bottom Curly Bracket \\
\hline
U+023E2 & ⏢ & {\textbackslash}trapezium & White Trapezium \\
\hline
U+023E3 & ⏣ & {\textbackslash}benzenr & Benzene Ring With Circle \\
\hline
U+023E4 & ⏤ & {\textbackslash}strns & Straightness \\
\hline
U+023E5 & ⏥ & {\textbackslash}fltns & Flatness \\
\hline
U+023E6 & ⏦ & {\textbackslash}accurrent & Ac Current \\
\hline
U+023E7 & ⏧ & {\textbackslash}elinters & Electrical Intersection \\
\hline
U+023E9 & ⏩ & {\textbackslash}:fast\_forward: & Black Right-Pointing Double Triangle \\
\hline
U+023EA & ⏪ & {\textbackslash}:rewind: & Black Left-Pointing Double Triangle \\
\hline
U+023EB & ⏫ & {\textbackslash}:arrow\_double\_up: & Black Up-Pointing Double Triangle \\
\hline
U+023EC & ⏬ & {\textbackslash}:arrow\_double\_down: & Black Down-Pointing Double Triangle \\
\hline
U+023F0 & ⏰ & {\textbackslash}:alarm\_clock: & Alarm Clock \\
\hline
U+023F3 & ⏳ & {\textbackslash}:hourglass\_flowing\_sand: & Hourglass With Flowing Sand \\
\hline
U+02422 & ␢ & {\textbackslash}blanksymbol & Blank Symbol / Blank \\
\hline
U+02423 & ␣ & {\textbackslash}visiblespace & Open Box \\
\hline
U+024C2 & Ⓜ & {\textbackslash}:m: & Circled Latin Capital Letter M \\
\hline
U+024C8 & Ⓢ & {\textbackslash}circledS & Circled Latin Capital Letter S \\
\hline
U+02506 & ┆ & {\textbackslash}dshfnc & Box Drawings Light Triple Dash Vertical / Forms Light Triple Dash Vertical \\
\hline
U+02519 & ┙ & {\textbackslash}sqfnw & Box Drawings Up Light And Left Heavy / Forms Up Light And Left Heavy \\
\hline
U+02571 & ╱ & {\textbackslash}diagup & Box Drawings Light Diagonal Upper Right To Lower Left / Forms Light Diagonal Upper Right To Lower Left \\
\hline
U+02572 & ╲ & {\textbackslash}diagdown & Box Drawings Light Diagonal Upper Left To Lower Right / Forms Light Diagonal Upper Left To Lower Right \\
\hline
U+02580 & ▀ & {\textbackslash}blockuphalf & Upper Half Block \\
\hline
U+02584 & ▄ & {\textbackslash}blocklowhalf & Lower Half Block \\
\hline
U+02588 & █ & {\textbackslash}blockfull & Full Block \\
\hline
U+0258C & ▌ & {\textbackslash}blocklefthalf & Left Half Block \\
\hline
U+02590 & ▐ & {\textbackslash}blockrighthalf & Right Half Block \\
\hline
U+02591 & ░ & {\textbackslash}blockqtrshaded & Light Shade \\
\hline
U+02592 & ▒ & {\textbackslash}blockhalfshaded & Medium Shade \\
\hline
U+02593 & ▓ & {\textbackslash}blockthreeqtrshaded & Dark Shade \\
\hline
U+025A0 & ■ & {\textbackslash}blacksquare & Black Square \\
\hline
U+025A1 & □ & {\textbackslash}square & White Square \\
\hline
U+025A2 & ▢ & {\textbackslash}squoval & White Square With Rounded Corners \\
\hline
U+025A3 & ▣ & {\textbackslash}blackinwhitesquare & White Square Containing Black Small Square \\
\hline
U+025A4 & ▤ & {\textbackslash}squarehfill & Square With Horizontal Fill \\
\hline
U+025A5 & ▥ & {\textbackslash}squarevfill & Square With Vertical Fill \\
\hline
U+025A6 & ▦ & {\textbackslash}squarehvfill & Square With Orthogonal Crosshatch Fill \\
\hline
U+025A7 & ▧ & {\textbackslash}squarenwsefill & Square With Upper Left To Lower Right Fill \\
\hline
U+025A8 & ▨ & {\textbackslash}squareneswfill & Square With Upper Right To Lower Left Fill \\
\hline
U+025A9 & ▩ & {\textbackslash}squarecrossfill & Square With Diagonal Crosshatch Fill \\
\hline
U+025AA & ▪ & {\textbackslash}smblksquare, {\textbackslash}:black\_small\_square: & Black Small Square \\
\hline
U+025AB & ▫ & {\textbackslash}smwhtsquare, {\textbackslash}:white\_small\_square: & White Small Square \\
\hline
U+025AC & ▬ & {\textbackslash}hrectangleblack & Black Rectangle \\
\hline
U+025AD & ▭ & {\textbackslash}hrectangle & White Rectangle \\
\hline
U+025AE & ▮ & {\textbackslash}vrectangleblack & Black Vertical Rectangle \\
\hline
U+025AF & ▯ & {\textbackslash}vrecto & White Vertical Rectangle \\
\hline
U+025B0 & ▰ & {\textbackslash}parallelogramblack & Black Parallelogram \\
\hline
U+025B1 & ▱ & {\textbackslash}parallelogram & White Parallelogram \\
\hline
U+025B2 & ▲ & {\textbackslash}bigblacktriangleup & Black Up-Pointing Triangle / Black Up Pointing Triangle \\
\hline
U+025B3 & △ & {\textbackslash}bigtriangleup & White Up-Pointing Triangle / White Up Pointing Triangle \\
\hline
U+025B4 & ▴ & {\textbackslash}blacktriangle & Black Up-Pointing Small Triangle / Black Up Pointing Small Triangle \\
\hline
U+025B5 & ▵ & {\textbackslash}vartriangle & White Up-Pointing Small Triangle / White Up Pointing Small Triangle \\
\hline
U+025B6 & ▶ & {\textbackslash}blacktriangleright, {\textbackslash}:arrow\_forward: & Black Right-Pointing Triangle / Black Right Pointing Triangle \\
\hline
U+025B7 & ▷ & {\textbackslash}triangleright & White Right-Pointing Triangle / White Right Pointing Triangle \\
\hline
U+025B8 & ▸ & {\textbackslash}smallblacktriangleright & Black Right-Pointing Small Triangle / Black Right Pointing Small Triangle \\
\hline
U+025B9 & ▹ & {\textbackslash}smalltriangleright & White Right-Pointing Small Triangle / White Right Pointing Small Triangle \\
\hline
U+025BA & ► & {\textbackslash}blackpointerright & Black Right-Pointing Pointer / Black Right Pointing Pointer \\
\hline
U+025BB & ▻ & {\textbackslash}whitepointerright & White Right-Pointing Pointer / White Right Pointing Pointer \\
\hline
U+025BC & ▼ & {\textbackslash}bigblacktriangledown & Black Down-Pointing Triangle / Black Down Pointing Triangle \\
\hline
U+025BD & ▽ & {\textbackslash}bigtriangledown & White Down-Pointing Triangle / White Down Pointing Triangle \\
\hline
U+025BE & ▾ & {\textbackslash}blacktriangledown & Black Down-Pointing Small Triangle / Black Down Pointing Small Triangle \\
\hline
U+025BF & ▿ & {\textbackslash}triangledown & White Down-Pointing Small Triangle / White Down Pointing Small Triangle \\
\hline
U+025C0 & ◀ & {\textbackslash}blacktriangleleft, {\textbackslash}:arrow\_backward: & Black Left-Pointing Triangle / Black Left Pointing Triangle \\
\hline
U+025C1 & ◁ & {\textbackslash}triangleleft & White Left-Pointing Triangle / White Left Pointing Triangle \\
\hline
U+025C2 & ◂ & {\textbackslash}smallblacktriangleleft & Black Left-Pointing Small Triangle / Black Left Pointing Small Triangle \\
\hline
U+025C3 & ◃ & {\textbackslash}smalltriangleleft & White Left-Pointing Small Triangle / White Left Pointing Small Triangle \\
\hline
U+025C4 & ◄ & {\textbackslash}blackpointerleft & Black Left-Pointing Pointer / Black Left Pointing Pointer \\
\hline
U+025C5 & ◅ & {\textbackslash}whitepointerleft & White Left-Pointing Pointer / White Left Pointing Pointer \\
\hline
U+025C6 & ◆ & {\textbackslash}mdlgblkdiamond & Black Diamond \\
\hline
U+025C7 & ◇ & {\textbackslash}mdlgwhtdiamond & White Diamond \\
\hline
U+025C8 & ◈ & {\textbackslash}blackinwhitediamond & White Diamond Containing Black Small Diamond \\
\hline
U+025C9 & ◉ & {\textbackslash}fisheye & Fisheye \\
\hline
U+025CA & ◊ & {\textbackslash}lozenge & Lozenge \\
\hline
U+025CB & ○ & {\textbackslash}bigcirc & White Circle \\
\hline
U+025CC & ◌ & {\textbackslash}dottedcircle & Dotted Circle \\
\hline
U+025CD & ◍ & {\textbackslash}circlevertfill & Circle With Vertical Fill \\
\hline
U+025CE & ◎ & {\textbackslash}bullseye & Bullseye \\
\hline
U+025CF & ● & {\textbackslash}mdlgblkcircle & Black Circle \\
\hline
U+025D0 & ◐ & {\textbackslash}cirfl & Circle With Left Half Black \\
\hline
U+025D1 & ◑ & {\textbackslash}cirfr & Circle With Right Half Black \\
\hline
U+025D2 & ◒ & {\textbackslash}cirfb & Circle With Lower Half Black \\
\hline
U+025D3 & ◓ & {\textbackslash}circletophalfblack & Circle With Upper Half Black \\
\hline
U+025D4 & ◔ & {\textbackslash}circleurquadblack & Circle With Upper Right Quadrant Black \\
\hline
U+025D5 & ◕ & {\textbackslash}blackcircleulquadwhite & Circle With All But Upper Left Quadrant Black \\
\hline
U+025D6 & ◖ & {\textbackslash}blacklefthalfcircle & Left Half Black Circle \\
\hline
U+025D7 & ◗ & {\textbackslash}blackrighthalfcircle & Right Half Black Circle \\
\hline
U+025D8 & ◘ & {\textbackslash}rvbull & Inverse Bullet \\
\hline
U+025D9 & ◙ & {\textbackslash}inversewhitecircle & Inverse White Circle \\
\hline
U+025DA & ◚ & {\textbackslash}invwhiteupperhalfcircle & Upper Half Inverse White Circle \\
\hline
U+025DB & ◛ & {\textbackslash}invwhitelowerhalfcircle & Lower Half Inverse White Circle \\
\hline
U+025DC & ◜ & {\textbackslash}ularc & Upper Left Quadrant Circular Arc \\
\hline
U+025DD & ◝ & {\textbackslash}urarc & Upper Right Quadrant Circular Arc \\
\hline
U+025DE & ◞ & {\textbackslash}lrarc & Lower Right Quadrant Circular Arc \\
\hline
U+025DF & ◟ & {\textbackslash}llarc & Lower Left Quadrant Circular Arc \\
\hline
U+025E0 & ◠ & {\textbackslash}topsemicircle & Upper Half Circle \\
\hline
U+025E1 & ◡ & {\textbackslash}botsemicircle & Lower Half Circle \\
\hline
U+025E2 & ◢ & {\textbackslash}lrblacktriangle & Black Lower Right Triangle \\
\hline
U+025E3 & ◣ & {\textbackslash}llblacktriangle & Black Lower Left Triangle \\
\hline
U+025E4 & ◤ & {\textbackslash}ulblacktriangle & Black Upper Left Triangle \\
\hline
U+025E5 & ◥ & {\textbackslash}urblacktriangle & Black Upper Right Triangle \\
\hline
U+025E6 & ◦ & {\textbackslash}smwhtcircle & White Bullet \\
\hline
U+025E7 & ◧ & {\textbackslash}sqfl & Square With Left Half Black \\
\hline
U+025E8 & ◨ & {\textbackslash}sqfr & Square With Right Half Black \\
\hline
U+025E9 & ◩ & {\textbackslash}squareulblack & Square With Upper Left Diagonal Half Black \\
\hline
U+025EA & ◪ & {\textbackslash}sqfse & Square With Lower Right Diagonal Half Black \\
\hline
U+025EB & ◫ & {\textbackslash}boxbar & White Square With Vertical Bisecting Line \\
\hline
U+025EC & ◬ & {\textbackslash}trianglecdot & White Up-Pointing Triangle With Dot / White Up Pointing Triangle With Dot \\
\hline
U+025ED & ◭ & {\textbackslash}triangleleftblack & Up-Pointing Triangle With Left Half Black / Up Pointing Triangle With Left Half Black \\
\hline
U+025EE & ◮ & {\textbackslash}trianglerightblack & Up-Pointing Triangle With Right Half Black / Up Pointing Triangle With Right Half Black \\
\hline
U+025EF & ◯ & {\textbackslash}lgwhtcircle & Large Circle \\
\hline
U+025F0 & ◰ & {\textbackslash}squareulquad & White Square With Upper Left Quadrant \\
\hline
U+025F1 & ◱ & {\textbackslash}squarellquad & White Square With Lower Left Quadrant \\
\hline
U+025F2 & ◲ & {\textbackslash}squarelrquad & White Square With Lower Right Quadrant \\
\hline
U+025F3 & ◳ & {\textbackslash}squareurquad & White Square With Upper Right Quadrant \\
\hline
U+025F4 & ◴ & {\textbackslash}circleulquad & White Circle With Upper Left Quadrant \\
\hline
U+025F5 & ◵ & {\textbackslash}circlellquad & White Circle With Lower Left Quadrant \\
\hline
U+025F6 & ◶ & {\textbackslash}circlelrquad & White Circle With Lower Right Quadrant \\
\hline
U+025F7 & ◷ & {\textbackslash}circleurquad & White Circle With Upper Right Quadrant \\
\hline
U+025F8 & ◸ & {\textbackslash}ultriangle & Upper Left Triangle \\
\hline
U+025F9 & ◹ & {\textbackslash}urtriangle & Upper Right Triangle \\
\hline
U+025FA & ◺ & {\textbackslash}lltriangle & Lower Left Triangle \\
\hline
U+025FB & ◻ & {\textbackslash}mdwhtsquare, {\textbackslash}:white\_medium\_square: & White Medium Square \\
\hline
U+025FC & ◼ & {\textbackslash}mdblksquare, {\textbackslash}:black\_medium\_square: & Black Medium Square \\
\hline
U+025FD & ◽ & {\textbackslash}mdsmwhtsquare, {\textbackslash}:white\_medium\_small\_square: & White Medium Small Square \\
\hline
U+025FE & ◾ & {\textbackslash}mdsmblksquare, {\textbackslash}:black\_medium\_small\_square: & Black Medium Small Square \\
\hline
U+025FF & ◿ & {\textbackslash}lrtriangle & Lower Right Triangle \\
\hline
U+02600 & ☀ & {\textbackslash}:sunny: & Black Sun With Rays \\
\hline
U+02601 & ☁ & {\textbackslash}:cloud: & Cloud \\
\hline
U+02605 & ★ & {\textbackslash}bigstar & Black Star \\
\hline
U+02606 & ☆ & {\textbackslash}bigwhitestar & White Star \\
\hline
U+02609 & ☉ & {\textbackslash}astrosun & Sun \\
\hline
U+0260E & ☎ & {\textbackslash}:phone: & Black Telephone \\
\hline
U+02611 & ☑ & {\textbackslash}:ballot\_box\_with\_check: & Ballot Box With Check \\
\hline
U+02614 & ☔ & {\textbackslash}:umbrella: & Umbrella With Rain Drops \\
\hline
U+02615 & ☕ & {\textbackslash}:coffee: & Hot Beverage \\
\hline
U+0261D & ☝ & {\textbackslash}:point\_up: & White Up Pointing Index \\
\hline
U+02621 & ☡ & {\textbackslash}danger & Caution Sign \\
\hline
U+0263A & ☺ & {\textbackslash}:relaxed: & White Smiling Face \\
\hline
U+0263B & ☻ & {\textbackslash}blacksmiley & Black Smiling Face \\
\hline
U+0263C & ☼ & {\textbackslash}sun & White Sun With Rays \\
\hline
U+0263D & ☽ & {\textbackslash}rightmoon & First Quarter Moon \\
\hline
U+0263E & ☾ & {\textbackslash}leftmoon & Last Quarter Moon \\
\hline
U+0263F & ☿ & {\textbackslash}mercury & Mercury \\
\hline
U+02640 & ♀ & {\textbackslash}venus, {\textbackslash}female & Female Sign \\
\hline
U+02642 & ♂ & {\textbackslash}male, {\textbackslash}mars & Male Sign \\
\hline
U+02643 & ♃ & {\textbackslash}jupiter & Jupiter \\
\hline
U+02644 & ♄ & {\textbackslash}saturn & Saturn \\
\hline
U+02645 & ♅ & {\textbackslash}uranus & Uranus \\
\hline
U+02646 & ♆ & {\textbackslash}neptune & Neptune \\
\hline
U+02647 & ♇ & {\textbackslash}pluto & Pluto \\
\hline
U+02648 & ♈ & {\textbackslash}aries, {\textbackslash}:aries: & Aries \\
\hline
U+02649 & ♉ & {\textbackslash}taurus, {\textbackslash}:taurus: & Taurus \\
\hline
U+0264A & ♊ & {\textbackslash}gemini, {\textbackslash}:gemini: & Gemini \\
\hline
U+0264B & ♋ & {\textbackslash}cancer, {\textbackslash}:cancer: & Cancer \\
\hline
U+0264C & ♌ & {\textbackslash}leo, {\textbackslash}:leo: & Leo \\
\hline
U+0264D & ♍ & {\textbackslash}virgo, {\textbackslash}:virgo: & Virgo \\
\hline
U+0264E & ♎ & {\textbackslash}libra, {\textbackslash}:libra: & Libra \\
\hline
U+0264F & ♏ & {\textbackslash}scorpio, {\textbackslash}:scorpius: & Scorpius \\
\hline
U+02650 & ♐ & {\textbackslash}sagittarius, {\textbackslash}:sagittarius: & Sagittarius \\
\hline
U+02651 & ♑ & {\textbackslash}capricornus, {\textbackslash}:capricorn: & Capricorn \\
\hline
U+02652 & ♒ & {\textbackslash}aquarius, {\textbackslash}:aquarius: & Aquarius \\
\hline
U+02653 & ♓ & {\textbackslash}pisces, {\textbackslash}:pisces: & Pisces \\
\hline
U+02660 & ♠ & {\textbackslash}spadesuit, {\textbackslash}:spades: & Black Spade Suit \\
\hline
U+02661 & ♡ & {\textbackslash}heartsuit & White Heart Suit \\
\hline
U+02662 & ♢ & {\textbackslash}diamondsuit & White Diamond Suit \\
\hline
U+02663 & ♣ & {\textbackslash}clubsuit, {\textbackslash}:clubs: & Black Club Suit \\
\hline
U+02664 & ♤ & {\textbackslash}varspadesuit & White Spade Suit \\
\hline
U+02665 & ♥ & {\textbackslash}varheartsuit, {\textbackslash}:hearts: & Black Heart Suit \\
\hline
U+02666 & ♦ & {\textbackslash}vardiamondsuit, {\textbackslash}:diamonds: & Black Diamond Suit \\
\hline
U+02667 & ♧ & {\textbackslash}varclubsuit & White Club Suit \\
\hline
U+02668 & ♨ & {\textbackslash}:hotsprings: & Hot Springs \\
\hline
U+02669 & ♩ & {\textbackslash}quarternote & Quarter Note \\
\hline
U+0266A & ♪ & {\textbackslash}eighthnote & Eighth Note \\
\hline
U+0266B & ♫ & {\textbackslash}twonotes & Beamed Eighth Notes / Barred Eighth Notes \\
\hline
U+0266D & ♭ & {\textbackslash}flat & Music Flat Sign / Flat \\
\hline
U+0266E & ♮ & {\textbackslash}natural & Music Natural Sign / Natural \\
\hline
U+0266F & ♯ & {\textbackslash}sharp & Music Sharp Sign / Sharp \\
\hline
U+0267B & ♻ & {\textbackslash}:recycle: & Black Universal Recycling Symbol \\
\hline
U+0267E & ♾ & {\textbackslash}acidfree & Permanent Paper Sign \\
\hline
U+0267F & ♿ & {\textbackslash}:wheelchair: & Wheelchair Symbol \\
\hline
U+02680 & ⚀ & {\textbackslash}dicei & Die Face-1 \\
\hline
U+02681 & ⚁ & {\textbackslash}diceii & Die Face-2 \\
\hline
U+02682 & ⚂ & {\textbackslash}diceiii & Die Face-3 \\
\hline
U+02683 & ⚃ & {\textbackslash}diceiv & Die Face-4 \\
\hline
U+02684 & ⚄ & {\textbackslash}dicev & Die Face-5 \\
\hline
U+02685 & ⚅ & {\textbackslash}dicevi & Die Face-6 \\
\hline
U+02686 & ⚆ & {\textbackslash}circledrightdot & White Circle With Dot Right \\
\hline
U+02687 & ⚇ & {\textbackslash}circledtwodots & White Circle With Two Dots \\
\hline
U+02688 & ⚈ & {\textbackslash}blackcircledrightdot & Black Circle With White Dot Right \\
\hline
U+02689 & ⚉ & {\textbackslash}blackcircledtwodots & Black Circle With Two White Dots \\
\hline
U+02693 & ⚓ & {\textbackslash}:anchor: & Anchor \\
\hline
U+026A0 & ⚠ & {\textbackslash}:warning: & Warning Sign \\
\hline
U+026A1 & ⚡ & {\textbackslash}:zap: & High Voltage Sign \\
\hline
U+026A5 & ⚥ & {\textbackslash}hermaphrodite & Male And Female Sign \\
\hline
U+026AA & ⚪ & {\textbackslash}mdwhtcircle, {\textbackslash}:white\_circle: & Medium White Circle \\
\hline
U+026AB & ⚫ & {\textbackslash}mdblkcircle, {\textbackslash}:black\_circle: & Medium Black Circle \\
\hline
U+026AC & ⚬ & {\textbackslash}mdsmwhtcircle & Medium Small White Circle \\
\hline
U+026B2 & ⚲ & {\textbackslash}neuter & Neuter \\
\hline
U+026BD & ⚽ & {\textbackslash}:soccer: & Soccer Ball \\
\hline
U+026BE & ⚾ & {\textbackslash}:baseball: & Baseball \\
\hline
U+026C4 & ⛄ & {\textbackslash}:snowman: & Snowman Without Snow \\
\hline
U+026C5 & ⛅ & {\textbackslash}:partly\_sunny: & Sun Behind Cloud \\
\hline
U+026CE & ⛎ & {\textbackslash}:ophiuchus: & Ophiuchus \\
\hline
U+026D4 & ⛔ & {\textbackslash}:no\_entry: & No Entry \\
\hline
U+026EA & ⛪ & {\textbackslash}:church: & Church \\
\hline
U+026F2 & ⛲ & {\textbackslash}:fountain: & Fountain \\
\hline
U+026F3 & ⛳ & {\textbackslash}:golf: & Flag In Hole \\
\hline
U+026F5 & ⛵ & {\textbackslash}:boat: & Sailboat \\
\hline
U+026FA & ⛺ & {\textbackslash}:tent: & Tent \\
\hline
U+026FD & ⛽ & {\textbackslash}:fuelpump: & Fuel Pump \\
\hline
U+02702 & ✂ & {\textbackslash}:scissors: & Black Scissors \\
\hline
U+02705 & ✅ & {\textbackslash}:white\_check\_mark: & White Heavy Check Mark \\
\hline
U+02708 & ✈ & {\textbackslash}:airplane: & Airplane \\
\hline
U+02709 & ✉ & {\textbackslash}:email: & Envelope \\
\hline
U+0270A & ✊ & {\textbackslash}:fist: & Raised Fist \\
\hline
U+0270B & ✋ & {\textbackslash}:hand: & Raised Hand \\
\hline
U+0270C & ✌ & {\textbackslash}:v: & Victory Hand \\
\hline
U+0270F & ✏ & {\textbackslash}:pencil2: & Pencil \\
\hline
U+02712 & ✒ & {\textbackslash}:black\_nib: & Black Nib \\
\hline
U+02713 & ✓ & {\textbackslash}checkmark & Check Mark \\
\hline
U+02714 & ✔ & {\textbackslash}:heavy\_check\_mark: & Heavy Check Mark \\
\hline
U+02716 & ✖ & {\textbackslash}:heavy\_multiplication\_x: & Heavy Multiplication X \\
\hline
U+02720 & ✠ & {\textbackslash}maltese & Maltese Cross \\
\hline
U+02728 & ✨ & {\textbackslash}:sparkles: & Sparkles \\
\hline
U+0272A & ✪ & {\textbackslash}circledstar & Circled White Star \\
\hline
U+02733 & ✳ & {\textbackslash}:eight\_spoked\_asterisk: & Eight Spoked Asterisk \\
\hline
U+02734 & ✴ & {\textbackslash}:eight\_pointed\_black\_star: & Eight Pointed Black Star \\
\hline
U+02736 & ✶ & {\textbackslash}varstar & Six Pointed Black Star \\
\hline
U+0273D & ✽ & {\textbackslash}dingasterisk & Heavy Teardrop-Spoked Asterisk \\
\hline
U+02744 & ❄ & {\textbackslash}:snowflake: & Snowflake \\
\hline
U+02747 & ❇ & {\textbackslash}:sparkle: & Sparkle \\
\hline
U+0274C & ❌ & {\textbackslash}:x: & Cross Mark \\
\hline
U+0274E & ❎ & {\textbackslash}:negative\_squared\_cross\_mark: & Negative Squared Cross Mark \\
\hline
U+02753 & ❓ & {\textbackslash}:question: & Black Question Mark Ornament \\
\hline
U+02754 & ❔ & {\textbackslash}:grey\_question: & White Question Mark Ornament \\
\hline
U+02755 & ❕ & {\textbackslash}:grey\_exclamation: & White Exclamation Mark Ornament \\
\hline
U+02757 & ❗ & {\textbackslash}:exclamation: & Heavy Exclamation Mark Symbol \\
\hline
U+02764 & ❤ & {\textbackslash}:heart: & Heavy Black Heart \\
\hline
U+02795 & ➕ & {\textbackslash}:heavy\_plus\_sign: & Heavy Plus Sign \\
\hline
U+02796 & ➖ & {\textbackslash}:heavy\_minus\_sign: & Heavy Minus Sign \\
\hline
U+02797 & ➗ & {\textbackslash}:heavy\_division\_sign: & Heavy Division Sign \\
\hline
U+0279B & ➛ & {\textbackslash}draftingarrow & Drafting Point Rightwards Arrow / Drafting Point Right Arrow \\
\hline
U+027A1 & ➡ & {\textbackslash}:arrow\_right: & Black Rightwards Arrow / Black Right Arrow \\
\hline
U+027B0 & ➰ & {\textbackslash}:curly\_loop: & Curly Loop \\
\hline
U+027BF & ➿ & {\textbackslash}:loop: & Double Curly Loop \\
\hline
U+027C0 & ⟀ & {\textbackslash}threedangle & Three Dimensional Angle \\
\hline
U+027C1 & ⟁ & {\textbackslash}whiteinwhitetriangle & White Triangle Containing Small White Triangle \\
\hline
U+027C2 & ⟂ & {\textbackslash}perp & Perpendicular \\
\hline
U+027C8 & ⟈ & {\textbackslash}bsolhsub & Reverse Solidus Preceding Subset \\
\hline
U+027C9 & ⟉ & {\textbackslash}suphsol & Superset Preceding Solidus \\
\hline
U+027D1 & ⟑ & {\textbackslash}wedgedot & And With Dot \\
\hline
U+027D2 & ⟒ & {\textbackslash}upin & Element Of Opening Upwards \\
\hline
U+027D5 & ⟕ & {\textbackslash}leftouterjoin & Left Outer Join \\
\hline
U+027D6 & ⟖ & {\textbackslash}rightouterjoin & Right Outer Join \\
\hline
U+027D7 & ⟗ & {\textbackslash}fullouterjoin & Full Outer Join \\
\hline
U+027D8 & ⟘ & {\textbackslash}bigbot & Large Up Tack \\
\hline
U+027D9 & ⟙ & {\textbackslash}bigtop & Large Down Tack \\
\hline
U+027E6 & ⟦ & {\textbackslash}llbracket, {\textbackslash}openbracketleft & Mathematical Left White Square Bracket \\
\hline
U+027E7 & ⟧ & {\textbackslash}openbracketright, {\textbackslash}rrbracket & Mathematical Right White Square Bracket \\
\hline
U+027E8 & ⟨ & {\textbackslash}langle & Mathematical Left Angle Bracket \\
\hline
U+027E9 & ⟩ & {\textbackslash}rangle & Mathematical Right Angle Bracket \\
\hline
U+027F0 & ⟰ & {\textbackslash}UUparrow & Upwards Quadruple Arrow \\
\hline
U+027F1 & ⟱ & {\textbackslash}DDownarrow & Downwards Quadruple Arrow \\
\hline
U+027F5 & ⟵ & {\textbackslash}longleftarrow & Long Leftwards Arrow \\
\hline
U+027F6 & ⟶ & {\textbackslash}longrightarrow & Long Rightwards Arrow \\
\hline
U+027F7 & ⟷ & {\textbackslash}longleftrightarrow & Long Left Right Arrow \\
\hline
U+027F8 & ⟸ & {\textbackslash}impliedby, {\textbackslash}Longleftarrow & Long Leftwards Double Arrow \\
\hline
U+027F9 & ⟹ & {\textbackslash}implies, {\textbackslash}Longrightarrow & Long Rightwards Double Arrow \\
\hline
U+027FA & ⟺ & {\textbackslash}Longleftrightarrow, {\textbackslash}iff & Long Left Right Double Arrow \\
\hline
U+027FB & ⟻ & {\textbackslash}longmapsfrom & Long Leftwards Arrow From Bar \\
\hline
U+027FC & ⟼ & {\textbackslash}longmapsto & Long Rightwards Arrow From Bar \\
\hline
U+027FD & ⟽ & {\textbackslash}Longmapsfrom & Long Leftwards Double Arrow From Bar \\
\hline
U+027FE & ⟾ & {\textbackslash}Longmapsto & Long Rightwards Double Arrow From Bar \\
\hline
U+027FF & ⟿ & {\textbackslash}longrightsquigarrow & Long Rightwards Squiggle Arrow \\
\hline
U+02900 & ⤀ & {\textbackslash}nvtwoheadrightarrow & Rightwards Two-Headed Arrow With Vertical Stroke \\
\hline
U+02901 & ⤁ & {\textbackslash}nVtwoheadrightarrow & Rightwards Two-Headed Arrow With Double Vertical Stroke \\
\hline
U+02902 & ⤂ & {\textbackslash}nvLeftarrow & Leftwards Double Arrow With Vertical Stroke \\
\hline
U+02903 & ⤃ & {\textbackslash}nvRightarrow & Rightwards Double Arrow With Vertical Stroke \\
\hline
U+02904 & ⤄ & {\textbackslash}nvLeftrightarrow & Left Right Double Arrow With Vertical Stroke \\
\hline
U+02905 & ⤅ & {\textbackslash}twoheadmapsto & Rightwards Two-Headed Arrow From Bar \\
\hline
U+02906 & ⤆ & {\textbackslash}Mapsfrom & Leftwards Double Arrow From Bar \\
\hline
U+02907 & ⤇ & {\textbackslash}Mapsto & Rightwards Double Arrow From Bar \\
\hline
U+02908 & ⤈ & {\textbackslash}downarrowbarred & Downwards Arrow With Horizontal Stroke \\
\hline
U+02909 & ⤉ & {\textbackslash}uparrowbarred & Upwards Arrow With Horizontal Stroke \\
\hline
U+0290A & ⤊ & {\textbackslash}Uuparrow & Upwards Triple Arrow \\
\hline
U+0290B & ⤋ & {\textbackslash}Ddownarrow & Downwards Triple Arrow \\
\hline
U+0290C & ⤌ & {\textbackslash}leftbkarrow & Leftwards Double Dash Arrow \\
\hline
U+0290D & ⤍ & {\textbackslash}bkarow & Rightwards Double Dash Arrow \\
\hline
U+0290E & ⤎ & {\textbackslash}leftdbkarrow & Leftwards Triple Dash Arrow \\
\hline
U+0290F & ⤏ & {\textbackslash}dbkarow & Rightwards Triple Dash Arrow \\
\hline
U+02910 & ⤐ & {\textbackslash}drbkarrow & Rightwards Two-Headed Triple Dash Arrow \\
\hline
U+02911 & ⤑ & {\textbackslash}rightdotarrow & Rightwards Arrow With Dotted Stem \\
\hline
U+02912 & ⤒ & {\textbackslash}UpArrowBar & Upwards Arrow To Bar \\
\hline
U+02913 & ⤓ & {\textbackslash}DownArrowBar & Downwards Arrow To Bar \\
\hline
U+02914 & ⤔ & {\textbackslash}nvrightarrowtail & Rightwards Arrow With Tail With Vertical Stroke \\
\hline
U+02915 & ⤕ & {\textbackslash}nVrightarrowtail & Rightwards Arrow With Tail With Double Vertical Stroke \\
\hline
U+02916 & ⤖ & {\textbackslash}twoheadrightarrowtail & Rightwards Two-Headed Arrow With Tail \\
\hline
U+02917 & ⤗ & {\textbackslash}nvtwoheadrightarrowtail & Rightwards Two-Headed Arrow With Tail With Vertical Stroke \\
\hline
U+02918 & ⤘ & {\textbackslash}nVtwoheadrightarrowtail & Rightwards Two-Headed Arrow With Tail With Double Vertical Stroke \\
\hline
U+0291D & ⤝ & {\textbackslash}diamondleftarrow & Leftwards Arrow To Black Diamond \\
\hline
U+0291E & ⤞ & {\textbackslash}rightarrowdiamond & Rightwards Arrow To Black Diamond \\
\hline
U+0291F & ⤟ & {\textbackslash}diamondleftarrowbar & Leftwards Arrow From Bar To Black Diamond \\
\hline
U+02920 & ⤠ & {\textbackslash}barrightarrowdiamond & Rightwards Arrow From Bar To Black Diamond \\
\hline
U+02925 & ⤥ & {\textbackslash}hksearow & South East Arrow With Hook \\
\hline
U+02926 & ⤦ & {\textbackslash}hkswarow & South West Arrow With Hook \\
\hline
U+02927 & ⤧ & {\textbackslash}tona & North West Arrow And North East Arrow \\
\hline
U+02928 & ⤨ & {\textbackslash}toea & North East Arrow And South East Arrow \\
\hline
U+02929 & ⤩ & {\textbackslash}tosa & South East Arrow And South West Arrow \\
\hline
U+0292A & ⤪ & {\textbackslash}towa & South West Arrow And North West Arrow \\
\hline
U+0292B & ⤫ & {\textbackslash}rdiagovfdiag & Rising Diagonal Crossing Falling Diagonal \\
\hline
U+0292C & ⤬ & {\textbackslash}fdiagovrdiag & Falling Diagonal Crossing Rising Diagonal \\
\hline
U+0292D & ⤭ & {\textbackslash}seovnearrow & South East Arrow Crossing North East Arrow \\
\hline
U+0292E & ⤮ & {\textbackslash}neovsearrow & North East Arrow Crossing South East Arrow \\
\hline
U+0292F & ⤯ & {\textbackslash}fdiagovnearrow & Falling Diagonal Crossing North East Arrow \\
\hline
U+02930 & ⤰ & {\textbackslash}rdiagovsearrow & Rising Diagonal Crossing South East Arrow \\
\hline
U+02931 & ⤱ & {\textbackslash}neovnwarrow & North East Arrow Crossing North West Arrow \\
\hline
U+02932 & ⤲ & {\textbackslash}nwovnearrow & North West Arrow Crossing North East Arrow \\
\hline
U+02934 & ⤴ & {\textbackslash}:arrow\_heading\_up: & Arrow Pointing Rightwards Then Curving Upwards \\
\hline
U+02935 & ⤵ & {\textbackslash}:arrow\_heading\_down: & Arrow Pointing Rightwards Then Curving Downwards \\
\hline
U+02942 & ⥂ & {\textbackslash}Rlarr & Rightwards Arrow Above Short Leftwards Arrow \\
\hline
U+02944 & ⥄ & {\textbackslash}rLarr & Short Rightwards Arrow Above Leftwards Arrow \\
\hline
U+02945 & ⥅ & {\textbackslash}rightarrowplus & Rightwards Arrow With Plus Below \\
\hline
U+02946 & ⥆ & {\textbackslash}leftarrowplus & Leftwards Arrow With Plus Below \\
\hline
U+02947 & ⥇ & {\textbackslash}rarrx & Rightwards Arrow Through X \\
\hline
U+02948 & ⥈ & {\textbackslash}leftrightarrowcircle & Left Right Arrow Through Small Circle \\
\hline
U+02949 & ⥉ & {\textbackslash}twoheaduparrowcircle & Upwards Two-Headed Arrow From Small Circle \\
\hline
U+0294A & ⥊ & {\textbackslash}leftrightharpoonupdown & Left Barb Up Right Barb Down Harpoon \\
\hline
U+0294B & ⥋ & {\textbackslash}leftrightharpoondownup & Left Barb Down Right Barb Up Harpoon \\
\hline
U+0294C & ⥌ & {\textbackslash}updownharpoonrightleft & Up Barb Right Down Barb Left Harpoon \\
\hline
U+0294D & ⥍ & {\textbackslash}updownharpoonleftright & Up Barb Left Down Barb Right Harpoon \\
\hline
U+0294E & ⥎ & {\textbackslash}LeftRightVector & Left Barb Up Right Barb Up Harpoon \\
\hline
U+0294F & ⥏ & {\textbackslash}RightUpDownVector & Up Barb Right Down Barb Right Harpoon \\
\hline
U+02950 & ⥐ & {\textbackslash}DownLeftRightVector & Left Barb Down Right Barb Down Harpoon \\
\hline
U+02951 & ⥑ & {\textbackslash}LeftUpDownVector & Up Barb Left Down Barb Left Harpoon \\
\hline
U+02952 & ⥒ & {\textbackslash}LeftVectorBar & Leftwards Harpoon With Barb Up To Bar \\
\hline
U+02953 & ⥓ & {\textbackslash}RightVectorBar & Rightwards Harpoon With Barb Up To Bar \\
\hline
U+02954 & ⥔ & {\textbackslash}RightUpVectorBar & Upwards Harpoon With Barb Right To Bar \\
\hline
U+02955 & ⥕ & {\textbackslash}RightDownVectorBar & Downwards Harpoon With Barb Right To Bar \\
\hline
U+02956 & ⥖ & {\textbackslash}DownLeftVectorBar & Leftwards Harpoon With Barb Down To Bar \\
\hline
U+02957 & ⥗ & {\textbackslash}DownRightVectorBar & Rightwards Harpoon With Barb Down To Bar \\
\hline
U+02958 & ⥘ & {\textbackslash}LeftUpVectorBar & Upwards Harpoon With Barb Left To Bar \\
\hline
U+02959 & ⥙ & {\textbackslash}LeftDownVectorBar & Downwards Harpoon With Barb Left To Bar \\
\hline
U+0295A & ⥚ & {\textbackslash}LeftTeeVector & Leftwards Harpoon With Barb Up From Bar \\
\hline
U+0295B & ⥛ & {\textbackslash}RightTeeVector & Rightwards Harpoon With Barb Up From Bar \\
\hline
U+0295C & ⥜ & {\textbackslash}RightUpTeeVector & Upwards Harpoon With Barb Right From Bar \\
\hline
U+0295D & ⥝ & {\textbackslash}RightDownTeeVector & Downwards Harpoon With Barb Right From Bar \\
\hline
U+0295E & ⥞ & {\textbackslash}DownLeftTeeVector & Leftwards Harpoon With Barb Down From Bar \\
\hline
U+0295F & ⥟ & {\textbackslash}DownRightTeeVector & Rightwards Harpoon With Barb Down From Bar \\
\hline
U+02960 & ⥠ & {\textbackslash}LeftUpTeeVector & Upwards Harpoon With Barb Left From Bar \\
\hline
U+02961 & ⥡ & {\textbackslash}LeftDownTeeVector & Downwards Harpoon With Barb Left From Bar \\
\hline
U+02962 & ⥢ & {\textbackslash}leftharpoonsupdown & Leftwards Harpoon With Barb Up Above Leftwards Harpoon With Barb Down \\
\hline
U+02963 & ⥣ & {\textbackslash}upharpoonsleftright & Upwards Harpoon With Barb Left Beside Upwards Harpoon With Barb Right \\
\hline
U+02964 & ⥤ & {\textbackslash}rightharpoonsupdown & Rightwards Harpoon With Barb Up Above Rightwards Harpoon With Barb Down \\
\hline
U+02965 & ⥥ & {\textbackslash}downharpoonsleftright & Downwards Harpoon With Barb Left Beside Downwards Harpoon With Barb Right \\
\hline
U+02966 & ⥦ & {\textbackslash}leftrightharpoonsup & Leftwards Harpoon With Barb Up Above Rightwards Harpoon With Barb Up \\
\hline
U+02967 & ⥧ & {\textbackslash}leftrightharpoonsdown & Leftwards Harpoon With Barb Down Above Rightwards Harpoon With Barb Down \\
\hline
U+02968 & ⥨ & {\textbackslash}rightleftharpoonsup & Rightwards Harpoon With Barb Up Above Leftwards Harpoon With Barb Up \\
\hline
U+02969 & ⥩ & {\textbackslash}rightleftharpoonsdown & Rightwards Harpoon With Barb Down Above Leftwards Harpoon With Barb Down \\
\hline
U+0296A & ⥪ & {\textbackslash}leftharpoonupdash & Leftwards Harpoon With Barb Up Above Long Dash \\
\hline
U+0296B & ⥫ & {\textbackslash}dashleftharpoondown & Leftwards Harpoon With Barb Down Below Long Dash \\
\hline
U+0296C & ⥬ & {\textbackslash}rightharpoonupdash & Rightwards Harpoon With Barb Up Above Long Dash \\
\hline
U+0296D & ⥭ & {\textbackslash}dashrightharpoondown & Rightwards Harpoon With Barb Down Below Long Dash \\
\hline
U+0296E & ⥮ & {\textbackslash}UpEquilibrium & Upwards Harpoon With Barb Left Beside Downwards Harpoon With Barb Right \\
\hline
U+0296F & ⥯ & {\textbackslash}ReverseUpEquilibrium & Downwards Harpoon With Barb Left Beside Upwards Harpoon With Barb Right \\
\hline
U+02970 & ⥰ & {\textbackslash}RoundImplies & Right Double Arrow With Rounded Head \\
\hline
U+02980 & ⦀ & {\textbackslash}Vvert & Triple Vertical Bar Delimiter \\
\hline
U+02986 & ⦆ & {\textbackslash}Elroang & Right White Parenthesis \\
\hline
U+02999 & ⦙ & {\textbackslash}ddfnc & Dotted Fence \\
\hline
U+0299B & ⦛ & {\textbackslash}measuredangleleft & Measured Angle Opening Left \\
\hline
U+0299C & ⦜ & {\textbackslash}Angle & Right Angle Variant With Square \\
\hline
U+0299D & ⦝ & {\textbackslash}rightanglemdot & Measured Right Angle With Dot \\
\hline
U+0299E & ⦞ & {\textbackslash}angles & Angle With S Inside \\
\hline
U+0299F & ⦟ & {\textbackslash}angdnr & Acute Angle \\
\hline
U+029A0 & ⦠ & {\textbackslash}lpargt & Spherical Angle Opening Left \\
\hline
U+029A1 & ⦡ & {\textbackslash}sphericalangleup & Spherical Angle Opening Up \\
\hline
U+029A2 & ⦢ & {\textbackslash}turnangle & Turned Angle \\
\hline
U+029A3 & ⦣ & {\textbackslash}revangle & Reversed Angle \\
\hline
U+029A4 & ⦤ & {\textbackslash}angleubar & Angle With Underbar \\
\hline
U+029A5 & ⦥ & {\textbackslash}revangleubar & Reversed Angle With Underbar \\
\hline
U+029A6 & ⦦ & {\textbackslash}wideangledown & Oblique Angle Opening Up \\
\hline
U+029A7 & ⦧ & {\textbackslash}wideangleup & Oblique Angle Opening Down \\
\hline
U+029A8 & ⦨ & {\textbackslash}measanglerutone & Measured Angle With Open Arm Ending In Arrow Pointing Up And Right \\
\hline
U+029A9 & ⦩ & {\textbackslash}measanglelutonw & Measured Angle With Open Arm Ending In Arrow Pointing Up And Left \\
\hline
U+029AA & ⦪ & {\textbackslash}measanglerdtose & Measured Angle With Open Arm Ending In Arrow Pointing Down And Right \\
\hline
U+029AB & ⦫ & {\textbackslash}measangleldtosw & Measured Angle With Open Arm Ending In Arrow Pointing Down And Left \\
\hline
U+029AC & ⦬ & {\textbackslash}measangleurtone & Measured Angle With Open Arm Ending In Arrow Pointing Right And Up \\
\hline
U+029AD & ⦭ & {\textbackslash}measangleultonw & Measured Angle With Open Arm Ending In Arrow Pointing Left And Up \\
\hline
U+029AE & ⦮ & {\textbackslash}measangledrtose & Measured Angle With Open Arm Ending In Arrow Pointing Right And Down \\
\hline
U+029AF & ⦯ & {\textbackslash}measangledltosw & Measured Angle With Open Arm Ending In Arrow Pointing Left And Down \\
\hline
U+029B0 & ⦰ & {\textbackslash}revemptyset & Reversed Empty Set \\
\hline
U+029B1 & ⦱ & {\textbackslash}emptysetobar & Empty Set With Overbar \\
\hline
U+029B2 & ⦲ & {\textbackslash}emptysetocirc & Empty Set With Small Circle Above \\
\hline
U+029B3 & ⦳ & {\textbackslash}emptysetoarr & Empty Set With Right Arrow Above \\
\hline
U+029B4 & ⦴ & {\textbackslash}emptysetoarrl & Empty Set With Left Arrow Above \\
\hline
U+029B7 & ⦷ & {\textbackslash}circledparallel & Circled Parallel \\
\hline
U+029B8 & ⦸ & {\textbackslash}obslash & Circled Reverse Solidus \\
\hline
U+029BC & ⦼ & {\textbackslash}odotslashdot & Circled Anticlockwise-Rotated Division Sign \\
\hline
U+029BE & ⦾ & {\textbackslash}circledwhitebullet & Circled White Bullet \\
\hline
U+029BF & ⦿ & {\textbackslash}circledbullet & Circled Bullet \\
\hline
U+029C0 & ⧀ & {\textbackslash}olessthan & Circled Less-Than \\
\hline
U+029C1 & ⧁ & {\textbackslash}ogreaterthan & Circled Greater-Than \\
\hline
U+029C4 & ⧄ & {\textbackslash}boxdiag & Squared Rising Diagonal Slash \\
\hline
U+029C5 & ⧅ & {\textbackslash}boxbslash & Squared Falling Diagonal Slash \\
\hline
U+029C6 & ⧆ & {\textbackslash}boxast & Squared Asterisk \\
\hline
U+029C7 & ⧇ & {\textbackslash}boxcircle & Squared Small Circle \\
\hline
U+029CA & ⧊ & {\textbackslash}Lap & Triangle With Dot Above \\
\hline
U+029CB & ⧋ & {\textbackslash}defas & Triangle With Underbar \\
\hline
U+029CF & ⧏ & {\textbackslash}LeftTriangleBar & Left Triangle Beside Vertical Bar \\
\hline
U+029CF + U+00338 & ⧏̸ & {\textbackslash}NotLeftTriangleBar & Left Triangle Beside Vertical Bar + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay \\
\hline
U+029D0 & ⧐ & {\textbackslash}RightTriangleBar & Vertical Bar Beside Right Triangle \\
\hline
U+029D0 + U+00338 & ⧐̸ & {\textbackslash}NotRightTriangleBar & Vertical Bar Beside Right Triangle + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay \\
\hline
U+029DF & ⧟ & {\textbackslash}dualmap & Double-Ended Multimap \\
\hline
U+029E1 & ⧡ & {\textbackslash}lrtriangleeq & Increases As \\
\hline
U+029E2 & ⧢ & {\textbackslash}shuffle & Shuffle Product \\
\hline
U+029E3 & ⧣ & {\textbackslash}eparsl & Equals Sign And Slanted Parallel \\
\hline
U+029E4 & ⧤ & {\textbackslash}smeparsl & Equals Sign And Slanted Parallel With Tilde Above \\
\hline
U+029E5 & ⧥ & {\textbackslash}eqvparsl & Identical To And Slanted Parallel \\
\hline
U+029EB & ⧫ & {\textbackslash}blacklozenge & Black Lozenge \\
\hline
U+029F4 & ⧴ & {\textbackslash}RuleDelayed & Rule-Delayed \\
\hline
U+029F6 & ⧶ & {\textbackslash}dsol & Solidus With Overbar \\
\hline
U+029F7 & ⧷ & {\textbackslash}rsolbar & Reverse Solidus With Horizontal Stroke \\
\hline
U+029FA & ⧺ & {\textbackslash}doubleplus & Double Plus \\
\hline
U+029FB & ⧻ & {\textbackslash}tripleplus & Triple Plus \\
\hline
U+02A00 & ⨀ & {\textbackslash}bigodot & N-Ary Circled Dot Operator \\
\hline
U+02A01 & ⨁ & {\textbackslash}bigoplus & N-Ary Circled Plus Operator \\
\hline
U+02A02 & ⨂ & {\textbackslash}bigotimes & N-Ary Circled Times Operator \\
\hline
U+02A03 & ⨃ & {\textbackslash}bigcupdot & N-Ary Union Operator With Dot \\
\hline
U+02A04 & ⨄ & {\textbackslash}biguplus & N-Ary Union Operator With Plus \\
\hline
U+02A05 & ⨅ & {\textbackslash}bigsqcap & N-Ary Square Intersection Operator \\
\hline
U+02A06 & ⨆ & {\textbackslash}bigsqcup & N-Ary Square Union Operator \\
\hline
U+02A07 & ⨇ & {\textbackslash}conjquant & Two Logical And Operator \\
\hline
U+02A08 & ⨈ & {\textbackslash}disjquant & Two Logical Or Operator \\
\hline
U+02A09 & ⨉ & {\textbackslash}bigtimes & N-Ary Times Operator \\
\hline
U+02A0A & ⨊ & {\textbackslash}modtwosum & Modulo Two Sum \\
\hline
U+02A0B & ⨋ & {\textbackslash}sumint & Summation With Integral \\
\hline
U+02A0C & ⨌ & {\textbackslash}iiiint & Quadruple Integral Operator \\
\hline
U+02A0D & ⨍ & {\textbackslash}intbar & Finite Part Integral \\
\hline
U+02A0E & ⨎ & {\textbackslash}intBar & Integral With Double Stroke \\
\hline
U+02A0F & ⨏ & {\textbackslash}clockoint & Integral Average With Slash \\
\hline
U+02A10 & ⨐ & {\textbackslash}cirfnint & Circulation Function \\
\hline
U+02A11 & ⨑ & {\textbackslash}awint & Anticlockwise Integration \\
\hline
U+02A12 & ⨒ & {\textbackslash}rppolint & Line Integration With Rectangular Path Around Pole \\
\hline
U+02A13 & ⨓ & {\textbackslash}scpolint & Line Integration With Semicircular Path Around Pole \\
\hline
U+02A14 & ⨔ & {\textbackslash}npolint & Line Integration Not Including The Pole \\
\hline
U+02A15 & ⨕ & {\textbackslash}pointint & Integral Around A Point Operator \\
\hline
U+02A16 & ⨖ & {\textbackslash}sqrint & Quaternion Integral Operator \\
\hline
U+02A18 & ⨘ & {\textbackslash}intx & Integral With Times Sign \\
\hline
U+02A19 & ⨙ & {\textbackslash}intcap & Integral With Intersection \\
\hline
U+02A1A & ⨚ & {\textbackslash}intcup & Integral With Union \\
\hline
U+02A1B & ⨛ & {\textbackslash}upint & Integral With Overbar \\
\hline
U+02A1C & ⨜ & {\textbackslash}lowint & Integral With Underbar \\
\hline
U+02A1D & ⨝ & {\textbackslash}Join, {\textbackslash}join & Join \\
\hline
U+02A22 & ⨢ & {\textbackslash}ringplus & Plus Sign With Small Circle Above \\
\hline
U+02A23 & ⨣ & {\textbackslash}plushat & Plus Sign With Circumflex Accent Above \\
\hline
U+02A24 & ⨤ & {\textbackslash}simplus & Plus Sign With Tilde Above \\
\hline
U+02A25 & ⨥ & {\textbackslash}plusdot & Plus Sign With Dot Below \\
\hline
U+02A26 & ⨦ & {\textbackslash}plussim & Plus Sign With Tilde Below \\
\hline
U+02A27 & ⨧ & {\textbackslash}plussubtwo & Plus Sign With Subscript Two \\
\hline
U+02A28 & ⨨ & {\textbackslash}plustrif & Plus Sign With Black Triangle \\
\hline
U+02A29 & ⨩ & {\textbackslash}commaminus & Minus Sign With Comma Above \\
\hline
U+02A2A & ⨪ & {\textbackslash}minusdot & Minus Sign With Dot Below \\
\hline
U+02A2B & ⨫ & {\textbackslash}minusfdots & Minus Sign With Falling Dots \\
\hline
U+02A2C & ⨬ & {\textbackslash}minusrdots & Minus Sign With Rising Dots \\
\hline
U+02A2D & ⨭ & {\textbackslash}opluslhrim & Plus Sign In Left Half Circle \\
\hline
U+02A2E & ⨮ & {\textbackslash}oplusrhrim & Plus Sign In Right Half Circle \\
\hline
U+02A2F & ⨯ & {\textbackslash}Times & Vector Or Cross Product \\
\hline
U+02A30 & ⨰ & {\textbackslash}dottimes & Multiplication Sign With Dot Above \\
\hline
U+02A31 & ⨱ & {\textbackslash}timesbar & Multiplication Sign With Underbar \\
\hline
U+02A32 & ⨲ & {\textbackslash}btimes & Semidirect Product With Bottom Closed \\
\hline
U+02A33 & ⨳ & {\textbackslash}smashtimes & Smash Product \\
\hline
U+02A34 & ⨴ & {\textbackslash}otimeslhrim & Multiplication Sign In Left Half Circle \\
\hline
U+02A35 & ⨵ & {\textbackslash}otimesrhrim & Multiplication Sign In Right Half Circle \\
\hline
U+02A36 & ⨶ & {\textbackslash}otimeshat & Circled Multiplication Sign With Circumflex Accent \\
\hline
U+02A37 & ⨷ & {\textbackslash}Otimes & Multiplication Sign In Double Circle \\
\hline
U+02A38 & ⨸ & {\textbackslash}odiv & Circled Division Sign \\
\hline
U+02A39 & ⨹ & {\textbackslash}triangleplus & Plus Sign In Triangle \\
\hline
U+02A3A & ⨺ & {\textbackslash}triangleminus & Minus Sign In Triangle \\
\hline
U+02A3B & ⨻ & {\textbackslash}triangletimes & Multiplication Sign In Triangle \\
\hline
U+02A3C & ⨼ & {\textbackslash}intprod & Interior Product \\
\hline
U+02A3D & ⨽ & {\textbackslash}intprodr & Righthand Interior Product \\
\hline
U+02A3F & ⨿ & {\textbackslash}amalg & Amalgamation Or Coproduct \\
\hline
U+02A40 & ⩀ & {\textbackslash}capdot & Intersection With Dot \\
\hline
U+02A41 & ⩁ & {\textbackslash}uminus & Union With Minus Sign \\
\hline
U+02A42 & ⩂ & {\textbackslash}barcup & Union With Overbar \\
\hline
U+02A43 & ⩃ & {\textbackslash}barcap & Intersection With Overbar \\
\hline
U+02A44 & ⩄ & {\textbackslash}capwedge & Intersection With Logical And \\
\hline
U+02A45 & ⩅ & {\textbackslash}cupvee & Union With Logical Or \\
\hline
U+02A4A & ⩊ & {\textbackslash}twocups & Union Beside And Joined With Union \\
\hline
U+02A4B & ⩋ & {\textbackslash}twocaps & Intersection Beside And Joined With Intersection \\
\hline
U+02A4C & ⩌ & {\textbackslash}closedvarcup & Closed Union With Serifs \\
\hline
U+02A4D & ⩍ & {\textbackslash}closedvarcap & Closed Intersection With Serifs \\
\hline
U+02A4E & ⩎ & {\textbackslash}Sqcap & Double Square Intersection \\
\hline
U+02A4F & ⩏ & {\textbackslash}Sqcup & Double Square Union \\
\hline
U+02A50 & ⩐ & {\textbackslash}closedvarcupsmashprod & Closed Union With Serifs And Smash Product \\
\hline
U+02A51 & ⩑ & {\textbackslash}wedgeodot & Logical And With Dot Above \\
\hline
U+02A52 & ⩒ & {\textbackslash}veeodot & Logical Or With Dot Above \\
\hline
U+02A53 & ⩓ & {\textbackslash}And & Double Logical And \\
\hline
U+02A54 & ⩔ & {\textbackslash}Or & Double Logical Or \\
\hline
U+02A55 & ⩕ & {\textbackslash}wedgeonwedge & Two Intersecting Logical And \\
\hline
U+02A56 & ⩖ & {\textbackslash}ElOr & Two Intersecting Logical Or \\
\hline
U+02A57 & ⩗ & {\textbackslash}bigslopedvee & Sloping Large Or \\
\hline
U+02A58 & ⩘ & {\textbackslash}bigslopedwedge & Sloping Large And \\
\hline
U+02A5A & ⩚ & {\textbackslash}wedgemidvert & Logical And With Middle Stem \\
\hline
U+02A5B & ⩛ & {\textbackslash}veemidvert & Logical Or With Middle Stem \\
\hline
U+02A5C & ⩜ & {\textbackslash}midbarwedge & Logical And With Horizontal Dash \\
\hline
U+02A5D & ⩝ & {\textbackslash}midbarvee & Logical Or With Horizontal Dash \\
\hline
U+02A5E & ⩞ & {\textbackslash}perspcorrespond & Logical And With Double Overbar \\
\hline
U+02A5F & ⩟ & {\textbackslash}minhat & Logical And With Underbar \\
\hline
U+02A60 & ⩠ & {\textbackslash}wedgedoublebar & Logical And With Double Underbar \\
\hline
U+02A61 & ⩡ & {\textbackslash}varveebar & Small Vee With Underbar \\
\hline
U+02A62 & ⩢ & {\textbackslash}doublebarvee & Logical Or With Double Overbar \\
\hline
U+02A63 & ⩣ & {\textbackslash}veedoublebar & Logical Or With Double Underbar \\
\hline
U+02A66 & ⩦ & {\textbackslash}eqdot & Equals Sign With Dot Below \\
\hline
U+02A67 & ⩧ & {\textbackslash}dotequiv & Identical With Dot Above \\
\hline
U+02A6A & ⩪ & {\textbackslash}dotsim & Tilde Operator With Dot Above \\
\hline
U+02A6B & ⩫ & {\textbackslash}simrdots & Tilde Operator With Rising Dots \\
\hline
U+02A6C & ⩬ & {\textbackslash}simminussim & Similar Minus Similar \\
\hline
U+02A6D & ⩭ & {\textbackslash}congdot & Congruent With Dot Above \\
\hline
U+02A6E & ⩮ & {\textbackslash}asteq & Equals With Asterisk \\
\hline
U+02A6F & ⩯ & {\textbackslash}hatapprox & Almost Equal To With Circumflex Accent \\
\hline
U+02A70 & ⩰ & {\textbackslash}approxeqq & Approximately Equal Or Equal To \\
\hline
U+02A71 & ⩱ & {\textbackslash}eqqplus & Equals Sign Above Plus Sign \\
\hline
U+02A72 & ⩲ & {\textbackslash}pluseqq & Plus Sign Above Equals Sign \\
\hline
U+02A73 & ⩳ & {\textbackslash}eqqsim & Equals Sign Above Tilde Operator \\
\hline
U+02A74 & ⩴ & {\textbackslash}Coloneq & Double Colon Equal \\
\hline
U+02A75 & ⩵ & {\textbackslash}Equal & Two Consecutive Equals Signs \\
\hline
U+02A76 & ⩶ & {\textbackslash}eqeqeq & Three Consecutive Equals Signs \\
\hline
U+02A77 & ⩷ & {\textbackslash}ddotseq & Equals Sign With Two Dots Above And Two Dots Below \\
\hline
U+02A78 & ⩸ & {\textbackslash}equivDD & Equivalent With Four Dots Above \\
\hline
U+02A79 & ⩹ & {\textbackslash}ltcir & Less-Than With Circle Inside \\
\hline
U+02A7A & ⩺ & {\textbackslash}gtcir & Greater-Than With Circle Inside \\
\hline
U+02A7B & ⩻ & {\textbackslash}ltquest & Less-Than With Question Mark Above \\
\hline
U+02A7C & ⩼ & {\textbackslash}gtquest & Greater-Than With Question Mark Above \\
\hline
U+02A7D & ⩽ & {\textbackslash}leqslant & Less-Than Or Slanted Equal To \\
\hline
U+02A7D + U+00338 & ⩽̸ & {\textbackslash}nleqslant & Less-Than Or Slanted Equal To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay \\
\hline
U+02A7E & ⩾ & {\textbackslash}geqslant & Greater-Than Or Slanted Equal To \\
\hline
U+02A7E + U+00338 & ⩾̸ & {\textbackslash}ngeqslant & Greater-Than Or Slanted Equal To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay \\
\hline
U+02A7F & ⩿ & {\textbackslash}lesdot & Less-Than Or Slanted Equal To With Dot Inside \\
\hline
U+02A80 & ⪀ & {\textbackslash}gesdot & Greater-Than Or Slanted Equal To With Dot Inside \\
\hline
U+02A81 & ⪁ & {\textbackslash}lesdoto & Less-Than Or Slanted Equal To With Dot Above \\
\hline
U+02A82 & ⪂ & {\textbackslash}gesdoto & Greater-Than Or Slanted Equal To With Dot Above \\
\hline
U+02A83 & ⪃ & {\textbackslash}lesdotor & Less-Than Or Slanted Equal To With Dot Above Right \\
\hline
U+02A84 & ⪄ & {\textbackslash}gesdotol & Greater-Than Or Slanted Equal To With Dot Above Left \\
\hline
U+02A85 & ⪅ & {\textbackslash}lessapprox & Less-Than Or Approximate \\
\hline
U+02A86 & ⪆ & {\textbackslash}gtrapprox & Greater-Than Or Approximate \\
\hline
U+02A87 & ⪇ & {\textbackslash}lneq & Less-Than And Single-Line Not Equal To \\
\hline
U+02A88 & ⪈ & {\textbackslash}gneq & Greater-Than And Single-Line Not Equal To \\
\hline
U+02A89 & ⪉ & {\textbackslash}lnapprox & Less-Than And Not Approximate \\
\hline
U+02A8A & ⪊ & {\textbackslash}gnapprox & Greater-Than And Not Approximate \\
\hline
U+02A8B & ⪋ & {\textbackslash}lesseqqgtr & Less-Than Above Double-Line Equal Above Greater-Than \\
\hline
U+02A8C & ⪌ & {\textbackslash}gtreqqless & Greater-Than Above Double-Line Equal Above Less-Than \\
\hline
U+02A8D & ⪍ & {\textbackslash}lsime & Less-Than Above Similar Or Equal \\
\hline
U+02A8E & ⪎ & {\textbackslash}gsime & Greater-Than Above Similar Or Equal \\
\hline
U+02A8F & ⪏ & {\textbackslash}lsimg & Less-Than Above Similar Above Greater-Than \\
\hline
U+02A90 & ⪐ & {\textbackslash}gsiml & Greater-Than Above Similar Above Less-Than \\
\hline
U+02A91 & ⪑ & {\textbackslash}lgE & Less-Than Above Greater-Than Above Double-Line Equal \\
\hline
U+02A92 & ⪒ & {\textbackslash}glE & Greater-Than Above Less-Than Above Double-Line Equal \\
\hline
U+02A93 & ⪓ & {\textbackslash}lesges & Less-Than Above Slanted Equal Above Greater-Than Above Slanted Equal \\
\hline
U+02A94 & ⪔ & {\textbackslash}gesles & Greater-Than Above Slanted Equal Above Less-Than Above Slanted Equal \\
\hline
U+02A95 & ⪕ & {\textbackslash}eqslantless & Slanted Equal To Or Less-Than \\
\hline
U+02A96 & ⪖ & {\textbackslash}eqslantgtr & Slanted Equal To Or Greater-Than \\
\hline
U+02A97 & ⪗ & {\textbackslash}elsdot & Slanted Equal To Or Less-Than With Dot Inside \\
\hline
U+02A98 & ⪘ & {\textbackslash}egsdot & Slanted Equal To Or Greater-Than With Dot Inside \\
\hline
U+02A99 & ⪙ & {\textbackslash}eqqless & Double-Line Equal To Or Less-Than \\
\hline
U+02A9A & ⪚ & {\textbackslash}eqqgtr & Double-Line Equal To Or Greater-Than \\
\hline
U+02A9B & ⪛ & {\textbackslash}eqqslantless & Double-Line Slanted Equal To Or Less-Than \\
\hline
U+02A9C & ⪜ & {\textbackslash}eqqslantgtr & Double-Line Slanted Equal To Or Greater-Than \\
\hline
U+02A9D & ⪝ & {\textbackslash}simless & Similar Or Less-Than \\
\hline
U+02A9E & ⪞ & {\textbackslash}simgtr & Similar Or Greater-Than \\
\hline
U+02A9F & ⪟ & {\textbackslash}simlE & Similar Above Less-Than Above Equals Sign \\
\hline
U+02AA0 & ⪠ & {\textbackslash}simgE & Similar Above Greater-Than Above Equals Sign \\
\hline
U+02AA1 & ⪡ & {\textbackslash}NestedLessLess & Double Nested Less-Than \\
\hline
U+02AA1 + U+00338 & ⪡̸ & {\textbackslash}NotNestedLessLess & Double Nested Less-Than + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay \\
\hline
U+02AA2 & ⪢ & {\textbackslash}NestedGreaterGreater & Double Nested Greater-Than \\
\hline
U+02AA2 + U+00338 & ⪢̸ & {\textbackslash}NotNestedGreaterGreater & Double Nested Greater-Than + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay \\
\hline
U+02AA3 & ⪣ & {\textbackslash}partialmeetcontraction & Double Nested Less-Than With Underbar \\
\hline
U+02AA4 & ⪤ & {\textbackslash}glj & Greater-Than Overlapping Less-Than \\
\hline
U+02AA5 & ⪥ & {\textbackslash}gla & Greater-Than Beside Less-Than \\
\hline
U+02AA6 & ⪦ & {\textbackslash}ltcc & Less-Than Closed By Curve \\
\hline
U+02AA7 & ⪧ & {\textbackslash}gtcc & Greater-Than Closed By Curve \\
\hline
U+02AA8 & ⪨ & {\textbackslash}lescc & Less-Than Closed By Curve Above Slanted Equal \\
\hline
U+02AA9 & ⪩ & {\textbackslash}gescc & Greater-Than Closed By Curve Above Slanted Equal \\
\hline
U+02AAA & ⪪ & {\textbackslash}smt & Smaller Than \\
\hline
U+02AAB & ⪫ & {\textbackslash}lat & Larger Than \\
\hline
U+02AAC & ⪬ & {\textbackslash}smte & Smaller Than Or Equal To \\
\hline
U+02AAD & ⪭ & {\textbackslash}late & Larger Than Or Equal To \\
\hline
U+02AAE & ⪮ & {\textbackslash}bumpeqq & Equals Sign With Bumpy Above \\
\hline
U+02AAF & ⪯ & {\textbackslash}preceq & Precedes Above Single-Line Equals Sign \\
\hline
U+02AAF + U+00338 & ⪯̸ & {\textbackslash}npreceq & Precedes Above Single-Line Equals Sign + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay \\
\hline
U+02AB0 & ⪰ & {\textbackslash}succeq & Succeeds Above Single-Line Equals Sign \\
\hline
U+02AB0 + U+00338 & ⪰̸ & {\textbackslash}nsucceq & Succeeds Above Single-Line Equals Sign + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay \\
\hline
U+02AB1 & ⪱ & {\textbackslash}precneq & Precedes Above Single-Line Not Equal To \\
\hline
U+02AB2 & ⪲ & {\textbackslash}succneq & Succeeds Above Single-Line Not Equal To \\
\hline
U+02AB3 & ⪳ & {\textbackslash}preceqq & Precedes Above Equals Sign \\
\hline
U+02AB4 & ⪴ & {\textbackslash}succeqq & Succeeds Above Equals Sign \\
\hline
U+02AB5 & ⪵ & {\textbackslash}precneqq & Precedes Above Not Equal To \\
\hline
U+02AB6 & ⪶ & {\textbackslash}succneqq & Succeeds Above Not Equal To \\
\hline
U+02AB7 & ⪷ & {\textbackslash}precapprox & Precedes Above Almost Equal To \\
\hline
U+02AB8 & ⪸ & {\textbackslash}succapprox & Succeeds Above Almost Equal To \\
\hline
U+02AB9 & ⪹ & {\textbackslash}precnapprox & Precedes Above Not Almost Equal To \\
\hline
U+02ABA & ⪺ & {\textbackslash}succnapprox & Succeeds Above Not Almost Equal To \\
\hline
U+02ABB & ⪻ & {\textbackslash}Prec & Double Precedes \\
\hline
U+02ABC & ⪼ & {\textbackslash}Succ & Double Succeeds \\
\hline
U+02ABD & ⪽ & {\textbackslash}subsetdot & Subset With Dot \\
\hline
U+02ABE & ⪾ & {\textbackslash}supsetdot & Superset With Dot \\
\hline
U+02ABF & ⪿ & {\textbackslash}subsetplus & Subset With Plus Sign Below \\
\hline
U+02AC0 & ⫀ & {\textbackslash}supsetplus & Superset With Plus Sign Below \\
\hline
U+02AC1 & ⫁ & {\textbackslash}submult & Subset With Multiplication Sign Below \\
\hline
U+02AC2 & ⫂ & {\textbackslash}supmult & Superset With Multiplication Sign Below \\
\hline
U+02AC3 & ⫃ & {\textbackslash}subedot & Subset Of Or Equal To With Dot Above \\
\hline
U+02AC4 & ⫄ & {\textbackslash}supedot & Superset Of Or Equal To With Dot Above \\
\hline
U+02AC5 & ⫅ & {\textbackslash}subseteqq & Subset Of Above Equals Sign \\
\hline
U+02AC5 + U+00338 & ⫅̸ & {\textbackslash}nsubseteqq & Subset Of Above Equals Sign + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay \\
\hline
U+02AC6 & ⫆ & {\textbackslash}supseteqq & Superset Of Above Equals Sign \\
\hline
U+02AC6 + U+00338 & ⫆̸ & {\textbackslash}nsupseteqq & Superset Of Above Equals Sign + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay \\
\hline
U+02AC7 & ⫇ & {\textbackslash}subsim & Subset Of Above Tilde Operator \\
\hline
U+02AC8 & ⫈ & {\textbackslash}supsim & Superset Of Above Tilde Operator \\
\hline
U+02AC9 & ⫉ & {\textbackslash}subsetapprox & Subset Of Above Almost Equal To \\
\hline
U+02ACA & ⫊ & {\textbackslash}supsetapprox & Superset Of Above Almost Equal To \\
\hline
U+02ACB & ⫋ & {\textbackslash}subsetneqq & Subset Of Above Not Equal To \\
\hline
U+02ACC & ⫌ & {\textbackslash}supsetneqq & Superset Of Above Not Equal To \\
\hline
U+02ACD & ⫍ & {\textbackslash}lsqhook & Square Left Open Box Operator \\
\hline
U+02ACE & ⫎ & {\textbackslash}rsqhook & Square Right Open Box Operator \\
\hline
U+02ACF & ⫏ & {\textbackslash}csub & Closed Subset \\
\hline
U+02AD0 & ⫐ & {\textbackslash}csup & Closed Superset \\
\hline
U+02AD1 & ⫑ & {\textbackslash}csube & Closed Subset Or Equal To \\
\hline
U+02AD2 & ⫒ & {\textbackslash}csupe & Closed Superset Or Equal To \\
\hline
U+02AD3 & ⫓ & {\textbackslash}subsup & Subset Above Superset \\
\hline
U+02AD4 & ⫔ & {\textbackslash}supsub & Superset Above Subset \\
\hline
U+02AD5 & ⫕ & {\textbackslash}subsub & Subset Above Subset \\
\hline
U+02AD6 & ⫖ & {\textbackslash}supsup & Superset Above Superset \\
\hline
U+02AD7 & ⫗ & {\textbackslash}suphsub & Superset Beside Subset \\
\hline
U+02AD8 & ⫘ & {\textbackslash}supdsub & Superset Beside And Joined By Dash With Subset \\
\hline
U+02AD9 & ⫙ & {\textbackslash}forkv & Element Of Opening Downwards \\
\hline
U+02ADB & ⫛ & {\textbackslash}mlcp & Transversal Intersection \\
\hline
U+02ADC & ⫝̸ & {\textbackslash}forks & Forking \\
\hline
U+02ADD & ⫝ & {\textbackslash}forksnot & Nonforking \\
\hline
U+02AE3 & ⫣ & {\textbackslash}dashV & Double Vertical Bar Left Turnstile \\
\hline
U+02AE4 & ⫤ & {\textbackslash}Dashv & Vertical Bar Double Left Turnstile \\
\hline
U+02AF4 & ⫴ & {\textbackslash}interleave & Triple Vertical Bar Binary Relation \\
\hline
U+02AF6 & ⫶ & {\textbackslash}tdcol & Triple Colon Operator \\
\hline
U+02AF7 & ⫷ & {\textbackslash}lllnest & Triple Nested Less-Than \\
\hline
U+02AF8 & ⫸ & {\textbackslash}gggnest & Triple Nested Greater-Than \\
\hline
U+02AF9 & ⫹ & {\textbackslash}leqqslant & Double-Line Slanted Less-Than Or Equal To \\
\hline
U+02AFA & ⫺ & {\textbackslash}geqqslant & Double-Line Slanted Greater-Than Or Equal To \\
\hline
U+02B05 & ⬅ & {\textbackslash}:arrow\_left: & Leftwards Black Arrow \\
\hline
U+02B06 & ⬆ & {\textbackslash}:arrow\_up: & Upwards Black Arrow \\
\hline
U+02B07 & ⬇ & {\textbackslash}:arrow\_down: & Downwards Black Arrow \\
\hline
U+02B12 & ⬒ & {\textbackslash}squaretopblack & Square With Top Half Black \\
\hline
U+02B13 & ⬓ & {\textbackslash}squarebotblack & Square With Bottom Half Black \\
\hline
U+02B14 & ⬔ & {\textbackslash}squareurblack & Square With Upper Right Diagonal Half Black \\
\hline
U+02B15 & ⬕ & {\textbackslash}squarellblack & Square With Lower Left Diagonal Half Black \\
\hline
U+02B16 & ⬖ & {\textbackslash}diamondleftblack & Diamond With Left Half Black \\
\hline
U+02B17 & ⬗ & {\textbackslash}diamondrightblack & Diamond With Right Half Black \\
\hline
U+02B18 & ⬘ & {\textbackslash}diamondtopblack & Diamond With Top Half Black \\
\hline
U+02B19 & ⬙ & {\textbackslash}diamondbotblack & Diamond With Bottom Half Black \\
\hline
U+02B1A & ⬚ & {\textbackslash}dottedsquare & Dotted Square \\
\hline
U+02B1B & ⬛ & {\textbackslash}lgblksquare, {\textbackslash}:black\_large\_square: & Black Large Square \\
\hline
U+02B1C & ⬜ & {\textbackslash}lgwhtsquare, {\textbackslash}:white\_large\_square: & White Large Square \\
\hline
U+02B1D & ⬝ & {\textbackslash}vysmblksquare & Black Very Small Square \\
\hline
U+02B1E & ⬞ & {\textbackslash}vysmwhtsquare & White Very Small Square \\
\hline
U+02B1F & ⬟ & {\textbackslash}pentagonblack & Black Pentagon \\
\hline
U+02B20 & ⬠ & {\textbackslash}pentagon & White Pentagon \\
\hline
U+02B21 & ⬡ & {\textbackslash}varhexagon & White Hexagon \\
\hline
U+02B22 & ⬢ & {\textbackslash}varhexagonblack & Black Hexagon \\
\hline
U+02B23 & ⬣ & {\textbackslash}hexagonblack & Horizontal Black Hexagon \\
\hline
U+02B24 & ⬤ & {\textbackslash}lgblkcircle & Black Large Circle \\
\hline
U+02B25 & ⬥ & {\textbackslash}mdblkdiamond & Black Medium Diamond \\
\hline
U+02B26 & ⬦ & {\textbackslash}mdwhtdiamond & White Medium Diamond \\
\hline
U+02B27 & ⬧ & {\textbackslash}mdblklozenge & Black Medium Lozenge \\
\hline
U+02B28 & ⬨ & {\textbackslash}mdwhtlozenge & White Medium Lozenge \\
\hline
U+02B29 & ⬩ & {\textbackslash}smblkdiamond & Black Small Diamond \\
\hline
U+02B2A & ⬪ & {\textbackslash}smblklozenge & Black Small Lozenge \\
\hline
U+02B2B & ⬫ & {\textbackslash}smwhtlozenge & White Small Lozenge \\
\hline
U+02B2C & ⬬ & {\textbackslash}blkhorzoval & Black Horizontal Ellipse \\
\hline
U+02B2D & ⬭ & {\textbackslash}whthorzoval & White Horizontal Ellipse \\
\hline
U+02B2E & ⬮ & {\textbackslash}blkvertoval & Black Vertical Ellipse \\
\hline
U+02B2F & ⬯ & {\textbackslash}whtvertoval & White Vertical Ellipse \\
\hline
U+02B30 & ⬰ & {\textbackslash}circleonleftarrow & Left Arrow With Small Circle \\
\hline
U+02B31 & ⬱ & {\textbackslash}leftthreearrows & Three Leftwards Arrows \\
\hline
U+02B32 & ⬲ & {\textbackslash}leftarrowonoplus & Left Arrow With Circled Plus \\
\hline
U+02B33 & ⬳ & {\textbackslash}longleftsquigarrow & Long Leftwards Squiggle Arrow \\
\hline
U+02B34 & ⬴ & {\textbackslash}nvtwoheadleftarrow & Leftwards Two-Headed Arrow With Vertical Stroke \\
\hline
U+02B35 & ⬵ & {\textbackslash}nVtwoheadleftarrow & Leftwards Two-Headed Arrow With Double Vertical Stroke \\
\hline
U+02B36 & ⬶ & {\textbackslash}twoheadmapsfrom & Leftwards Two-Headed Arrow From Bar \\
\hline
U+02B37 & ⬷ & {\textbackslash}twoheadleftdbkarrow & Leftwards Two-Headed Triple Dash Arrow \\
\hline
U+02B38 & ⬸ & {\textbackslash}leftdotarrow & Leftwards Arrow With Dotted Stem \\
\hline
U+02B39 & ⬹ & {\textbackslash}nvleftarrowtail & Leftwards Arrow With Tail With Vertical Stroke \\
\hline
U+02B3A & ⬺ & {\textbackslash}nVleftarrowtail & Leftwards Arrow With Tail With Double Vertical Stroke \\
\hline
U+02B3B & ⬻ & {\textbackslash}twoheadleftarrowtail & Leftwards Two-Headed Arrow With Tail \\
\hline
U+02B3C & ⬼ & {\textbackslash}nvtwoheadleftarrowtail & Leftwards Two-Headed Arrow With Tail With Vertical Stroke \\
\hline
U+02B3D & ⬽ & {\textbackslash}nVtwoheadleftarrowtail & Leftwards Two-Headed Arrow With Tail With Double Vertical Stroke \\
\hline
U+02B3E & ⬾ & {\textbackslash}leftarrowx & Leftwards Arrow Through X \\
\hline
U+02B3F & ⬿ & {\textbackslash}leftcurvedarrow & Wave Arrow Pointing Directly Left \\
\hline
U+02B40 & ⭀ & {\textbackslash}equalleftarrow & Equals Sign Above Leftwards Arrow \\
\hline
U+02B41 & ⭁ & {\textbackslash}bsimilarleftarrow & Reverse Tilde Operator Above Leftwards Arrow \\
\hline
U+02B42 & ⭂ & {\textbackslash}leftarrowbackapprox & Leftwards Arrow Above Reverse Almost Equal To \\
\hline
U+02B43 & ⭃ & {\textbackslash}rightarrowgtr & Rightwards Arrow Through Greater-Than \\
\hline
U+02B44 & ⭄ & {\textbackslash}rightarrowsupset & Rightwards Arrow Through Superset \\
\hline
U+02B45 & ⭅ & {\textbackslash}LLeftarrow & Leftwards Quadruple Arrow \\
\hline
U+02B46 & ⭆ & {\textbackslash}RRightarrow & Rightwards Quadruple Arrow \\
\hline
U+02B47 & ⭇ & {\textbackslash}bsimilarrightarrow & Reverse Tilde Operator Above Rightwards Arrow \\
\hline
U+02B48 & ⭈ & {\textbackslash}rightarrowbackapprox & Rightwards Arrow Above Reverse Almost Equal To \\
\hline
U+02B49 & ⭉ & {\textbackslash}similarleftarrow & Tilde Operator Above Leftwards Arrow \\
\hline
U+02B4A & ⭊ & {\textbackslash}leftarrowapprox & Leftwards Arrow Above Almost Equal To \\
\hline
U+02B4B & ⭋ & {\textbackslash}leftarrowbsimilar & Leftwards Arrow Above Reverse Tilde Operator \\
\hline
U+02B4C & ⭌ & {\textbackslash}rightarrowbsimilar & Rightwards Arrow Above Reverse Tilde Operator \\
\hline
U+02B50 & ⭐ & {\textbackslash}medwhitestar, {\textbackslash}:star: & White Medium Star \\
\hline
U+02B51 & ⭑ & {\textbackslash}medblackstar & Black Small Star \\
\hline
U+02B52 & ⭒ & {\textbackslash}smwhitestar & White Small Star \\
\hline
U+02B53 & ⭓ & {\textbackslash}rightpentagonblack & Black Right-Pointing Pentagon \\
\hline
U+02B54 & ⭔ & {\textbackslash}rightpentagon & White Right-Pointing Pentagon \\
\hline
U+02B55 & ⭕ & {\textbackslash}:o: & Heavy Large Circle \\
\hline
U+02C7C & ⱼ & {\textbackslash}\_j & Latin Subscript Small Letter J \\
\hline
U+02C7D & ⱽ & {\textbackslash}{\textasciicircum}V & Modifier Letter Capital V \\
\hline
U+03012 & 〒 & {\textbackslash}postalmark & Postal Mark \\
\hline
U+03030 & 〰 & {\textbackslash}:wavy\_dash: & Wavy Dash \\
\hline
U+0303D & 〽 & {\textbackslash}:part\_alternation\_mark: & Part Alternation Mark \\
\hline
U+03297 & ㊗ & {\textbackslash}:congratulations: & Circled Ideograph Congratulation \\
\hline
U+03299 & ㊙ & {\textbackslash}:secret: & Circled Ideograph Secret \\
\hline
U+1D400 & 𝐀 & {\textbackslash}bfA & Mathematical Bold Capital A \\
\hline
U+1D401 & 𝐁 & {\textbackslash}bfB & Mathematical Bold Capital B \\
\hline
U+1D402 & 𝐂 & {\textbackslash}bfC & Mathematical Bold Capital C \\
\hline
U+1D403 & 𝐃 & {\textbackslash}bfD & Mathematical Bold Capital D \\
\hline
U+1D404 & 𝐄 & {\textbackslash}bfE & Mathematical Bold Capital E \\
\hline
U+1D405 & 𝐅 & {\textbackslash}bfF & Mathematical Bold Capital F \\
\hline
U+1D406 & 𝐆 & {\textbackslash}bfG & Mathematical Bold Capital G \\
\hline
U+1D407 & 𝐇 & {\textbackslash}bfH & Mathematical Bold Capital H \\
\hline
U+1D408 & 𝐈 & {\textbackslash}bfI & Mathematical Bold Capital I \\
\hline
U+1D409 & 𝐉 & {\textbackslash}bfJ & Mathematical Bold Capital J \\
\hline
U+1D40A & 𝐊 & {\textbackslash}bfK & Mathematical Bold Capital K \\
\hline
U+1D40B & 𝐋 & {\textbackslash}bfL & Mathematical Bold Capital L \\
\hline
U+1D40C & 𝐌 & {\textbackslash}bfM & Mathematical Bold Capital M \\
\hline
U+1D40D & 𝐍 & {\textbackslash}bfN & Mathematical Bold Capital N \\
\hline
U+1D40E & 𝐎 & {\textbackslash}bfO & Mathematical Bold Capital O \\
\hline
U+1D40F & 𝐏 & {\textbackslash}bfP & Mathematical Bold Capital P \\
\hline
U+1D410 & 𝐐 & {\textbackslash}bfQ & Mathematical Bold Capital Q \\
\hline
U+1D411 & 𝐑 & {\textbackslash}bfR & Mathematical Bold Capital R \\
\hline
U+1D412 & 𝐒 & {\textbackslash}bfS & Mathematical Bold Capital S \\
\hline
U+1D413 & 𝐓 & {\textbackslash}bfT & Mathematical Bold Capital T \\
\hline
U+1D414 & 𝐔 & {\textbackslash}bfU & Mathematical Bold Capital U \\
\hline
U+1D415 & 𝐕 & {\textbackslash}bfV & Mathematical Bold Capital V \\
\hline
U+1D416 & 𝐖 & {\textbackslash}bfW & Mathematical Bold Capital W \\
\hline
U+1D417 & 𝐗 & {\textbackslash}bfX & Mathematical Bold Capital X \\
\hline
U+1D418 & 𝐘 & {\textbackslash}bfY & Mathematical Bold Capital Y \\
\hline
U+1D419 & 𝐙 & {\textbackslash}bfZ & Mathematical Bold Capital Z \\
\hline
U+1D41A & 𝐚 & {\textbackslash}bfa & Mathematical Bold Small A \\
\hline
U+1D41B & 𝐛 & {\textbackslash}bfb & Mathematical Bold Small B \\
\hline
U+1D41C & 𝐜 & {\textbackslash}bfc & Mathematical Bold Small C \\
\hline
U+1D41D & 𝐝 & {\textbackslash}bfd & Mathematical Bold Small D \\
\hline
U+1D41E & 𝐞 & {\textbackslash}bfe & Mathematical Bold Small E \\
\hline
U+1D41F & 𝐟 & {\textbackslash}bff & Mathematical Bold Small F \\
\hline
U+1D420 & 𝐠 & {\textbackslash}bfg & Mathematical Bold Small G \\
\hline
U+1D421 & 𝐡 & {\textbackslash}bfh & Mathematical Bold Small H \\
\hline
U+1D422 & 𝐢 & {\textbackslash}bfi & Mathematical Bold Small I \\
\hline
U+1D423 & 𝐣 & {\textbackslash}bfj & Mathematical Bold Small J \\
\hline
U+1D424 & 𝐤 & {\textbackslash}bfk & Mathematical Bold Small K \\
\hline
U+1D425 & 𝐥 & {\textbackslash}bfl & Mathematical Bold Small L \\
\hline
U+1D426 & 𝐦 & {\textbackslash}bfm & Mathematical Bold Small M \\
\hline
U+1D427 & 𝐧 & {\textbackslash}bfn & Mathematical Bold Small N \\
\hline
U+1D428 & 𝐨 & {\textbackslash}bfo & Mathematical Bold Small O \\
\hline
U+1D429 & 𝐩 & {\textbackslash}bfp & Mathematical Bold Small P \\
\hline
U+1D42A & 𝐪 & {\textbackslash}bfq & Mathematical Bold Small Q \\
\hline
U+1D42B & 𝐫 & {\textbackslash}bfr & Mathematical Bold Small R \\
\hline
U+1D42C & 𝐬 & {\textbackslash}bfs & Mathematical Bold Small S \\
\hline
U+1D42D & 𝐭 & {\textbackslash}bft & Mathematical Bold Small T \\
\hline
U+1D42E & 𝐮 & {\textbackslash}bfu & Mathematical Bold Small U \\
\hline
U+1D42F & 𝐯 & {\textbackslash}bfv & Mathematical Bold Small V \\
\hline
U+1D430 & 𝐰 & {\textbackslash}bfw & Mathematical Bold Small W \\
\hline
U+1D431 & 𝐱 & {\textbackslash}bfx & Mathematical Bold Small X \\
\hline
U+1D432 & 𝐲 & {\textbackslash}bfy & Mathematical Bold Small Y \\
\hline
U+1D433 & 𝐳 & {\textbackslash}bfz & Mathematical Bold Small Z \\
\hline
U+1D434 & 𝐴 & {\textbackslash}itA & Mathematical Italic Capital A \\
\hline
U+1D435 & 𝐵 & {\textbackslash}itB & Mathematical Italic Capital B \\
\hline
U+1D436 & 𝐶 & {\textbackslash}itC & Mathematical Italic Capital C \\
\hline
U+1D437 & 𝐷 & {\textbackslash}itD & Mathematical Italic Capital D \\
\hline
U+1D438 & 𝐸 & {\textbackslash}itE & Mathematical Italic Capital E \\
\hline
U+1D439 & 𝐹 & {\textbackslash}itF & Mathematical Italic Capital F \\
\hline
U+1D43A & 𝐺 & {\textbackslash}itG & Mathematical Italic Capital G \\
\hline
U+1D43B & 𝐻 & {\textbackslash}itH & Mathematical Italic Capital H \\
\hline
U+1D43C & 𝐼 & {\textbackslash}itI & Mathematical Italic Capital I \\
\hline
U+1D43D & 𝐽 & {\textbackslash}itJ & Mathematical Italic Capital J \\
\hline
U+1D43E & 𝐾 & {\textbackslash}itK & Mathematical Italic Capital K \\
\hline
U+1D43F & 𝐿 & {\textbackslash}itL & Mathematical Italic Capital L \\
\hline
U+1D440 & 𝑀 & {\textbackslash}itM & Mathematical Italic Capital M \\
\hline
U+1D441 & 𝑁 & {\textbackslash}itN & Mathematical Italic Capital N \\
\hline
U+1D442 & 𝑂 & {\textbackslash}itO & Mathematical Italic Capital O \\
\hline
U+1D443 & 𝑃 & {\textbackslash}itP & Mathematical Italic Capital P \\
\hline
U+1D444 & 𝑄 & {\textbackslash}itQ & Mathematical Italic Capital Q \\
\hline
U+1D445 & 𝑅 & {\textbackslash}itR & Mathematical Italic Capital R \\
\hline
U+1D446 & 𝑆 & {\textbackslash}itS & Mathematical Italic Capital S \\
\hline
U+1D447 & 𝑇 & {\textbackslash}itT & Mathematical Italic Capital T \\
\hline
U+1D448 & 𝑈 & {\textbackslash}itU & Mathematical Italic Capital U \\
\hline
U+1D449 & 𝑉 & {\textbackslash}itV & Mathematical Italic Capital V \\
\hline
U+1D44A & 𝑊 & {\textbackslash}itW & Mathematical Italic Capital W \\
\hline
U+1D44B & 𝑋 & {\textbackslash}itX & Mathematical Italic Capital X \\
\hline
U+1D44C & 𝑌 & {\textbackslash}itY & Mathematical Italic Capital Y \\
\hline
U+1D44D & 𝑍 & {\textbackslash}itZ & Mathematical Italic Capital Z \\
\hline
U+1D44E & 𝑎 & {\textbackslash}ita & Mathematical Italic Small A \\
\hline
U+1D44F & 𝑏 & {\textbackslash}itb & Mathematical Italic Small B \\
\hline
U+1D450 & 𝑐 & {\textbackslash}itc & Mathematical Italic Small C \\
\hline
U+1D451 & 𝑑 & {\textbackslash}itd & Mathematical Italic Small D \\
\hline
U+1D452 & 𝑒 & {\textbackslash}ite & Mathematical Italic Small E \\
\hline
U+1D453 & 𝑓 & {\textbackslash}itf & Mathematical Italic Small F \\
\hline
U+1D454 & 𝑔 & {\textbackslash}itg & Mathematical Italic Small G \\
\hline
U+1D456 & 𝑖 & {\textbackslash}iti & Mathematical Italic Small I \\
\hline
U+1D457 & 𝑗 & {\textbackslash}itj & Mathematical Italic Small J \\
\hline
U+1D458 & 𝑘 & {\textbackslash}itk & Mathematical Italic Small K \\
\hline
U+1D459 & 𝑙 & {\textbackslash}itl & Mathematical Italic Small L \\
\hline
U+1D45A & 𝑚 & {\textbackslash}itm & Mathematical Italic Small M \\
\hline
U+1D45B & 𝑛 & {\textbackslash}itn & Mathematical Italic Small N \\
\hline
U+1D45C & 𝑜 & {\textbackslash}ito & Mathematical Italic Small O \\
\hline
U+1D45D & 𝑝 & {\textbackslash}itp & Mathematical Italic Small P \\
\hline
U+1D45E & 𝑞 & {\textbackslash}itq & Mathematical Italic Small Q \\
\hline
U+1D45F & 𝑟 & {\textbackslash}itr & Mathematical Italic Small R \\
\hline
U+1D460 & 𝑠 & {\textbackslash}its & Mathematical Italic Small S \\
\hline
U+1D461 & 𝑡 & {\textbackslash}itt & Mathematical Italic Small T \\
\hline
U+1D462 & 𝑢 & {\textbackslash}itu & Mathematical Italic Small U \\
\hline
U+1D463 & 𝑣 & {\textbackslash}itv & Mathematical Italic Small V \\
\hline
U+1D464 & 𝑤 & {\textbackslash}itw & Mathematical Italic Small W \\
\hline
U+1D465 & 𝑥 & {\textbackslash}itx & Mathematical Italic Small X \\
\hline
U+1D466 & 𝑦 & {\textbackslash}ity & Mathematical Italic Small Y \\
\hline
U+1D467 & 𝑧 & {\textbackslash}itz & Mathematical Italic Small Z \\
\hline
U+1D468 & 𝑨 & {\textbackslash}biA & Mathematical Bold Italic Capital A \\
\hline
U+1D469 & 𝑩 & {\textbackslash}biB & Mathematical Bold Italic Capital B \\
\hline
U+1D46A & 𝑪 & {\textbackslash}biC & Mathematical Bold Italic Capital C \\
\hline
U+1D46B & 𝑫 & {\textbackslash}biD & Mathematical Bold Italic Capital D \\
\hline
U+1D46C & 𝑬 & {\textbackslash}biE & Mathematical Bold Italic Capital E \\
\hline
U+1D46D & 𝑭 & {\textbackslash}biF & Mathematical Bold Italic Capital F \\
\hline
U+1D46E & 𝑮 & {\textbackslash}biG & Mathematical Bold Italic Capital G \\
\hline
U+1D46F & 𝑯 & {\textbackslash}biH & Mathematical Bold Italic Capital H \\
\hline
U+1D470 & 𝑰 & {\textbackslash}biI & Mathematical Bold Italic Capital I \\
\hline
U+1D471 & 𝑱 & {\textbackslash}biJ & Mathematical Bold Italic Capital J \\
\hline
U+1D472 & 𝑲 & {\textbackslash}biK & Mathematical Bold Italic Capital K \\
\hline
U+1D473 & 𝑳 & {\textbackslash}biL & Mathematical Bold Italic Capital L \\
\hline
U+1D474 & 𝑴 & {\textbackslash}biM & Mathematical Bold Italic Capital M \\
\hline
U+1D475 & 𝑵 & {\textbackslash}biN & Mathematical Bold Italic Capital N \\
\hline
U+1D476 & 𝑶 & {\textbackslash}biO & Mathematical Bold Italic Capital O \\
\hline
U+1D477 & 𝑷 & {\textbackslash}biP & Mathematical Bold Italic Capital P \\
\hline
U+1D478 & 𝑸 & {\textbackslash}biQ & Mathematical Bold Italic Capital Q \\
\hline
U+1D479 & 𝑹 & {\textbackslash}biR & Mathematical Bold Italic Capital R \\
\hline
U+1D47A & 𝑺 & {\textbackslash}biS & Mathematical Bold Italic Capital S \\
\hline
U+1D47B & 𝑻 & {\textbackslash}biT & Mathematical Bold Italic Capital T \\
\hline
U+1D47C & 𝑼 & {\textbackslash}biU & Mathematical Bold Italic Capital U \\
\hline
U+1D47D & 𝑽 & {\textbackslash}biV & Mathematical Bold Italic Capital V \\
\hline
U+1D47E & 𝑾 & {\textbackslash}biW & Mathematical Bold Italic Capital W \\
\hline
U+1D47F & 𝑿 & {\textbackslash}biX & Mathematical Bold Italic Capital X \\
\hline
U+1D480 & 𝒀 & {\textbackslash}biY & Mathematical Bold Italic Capital Y \\
\hline
U+1D481 & 𝒁 & {\textbackslash}biZ & Mathematical Bold Italic Capital Z \\
\hline
U+1D482 & 𝒂 & {\textbackslash}bia & Mathematical Bold Italic Small A \\
\hline
U+1D483 & 𝒃 & {\textbackslash}bib & Mathematical Bold Italic Small B \\
\hline
U+1D484 & 𝒄 & {\textbackslash}bic & Mathematical Bold Italic Small C \\
\hline
U+1D485 & 𝒅 & {\textbackslash}bid & Mathematical Bold Italic Small D \\
\hline
U+1D486 & 𝒆 & {\textbackslash}bie & Mathematical Bold Italic Small E \\
\hline
U+1D487 & 𝒇 & {\textbackslash}bif & Mathematical Bold Italic Small F \\
\hline
U+1D488 & 𝒈 & {\textbackslash}big & Mathematical Bold Italic Small G \\
\hline
U+1D489 & 𝒉 & {\textbackslash}bih & Mathematical Bold Italic Small H \\
\hline
U+1D48A & 𝒊 & {\textbackslash}bii & Mathematical Bold Italic Small I \\
\hline
U+1D48B & 𝒋 & {\textbackslash}bij & Mathematical Bold Italic Small J \\
\hline
U+1D48C & 𝒌 & {\textbackslash}bik & Mathematical Bold Italic Small K \\
\hline
U+1D48D & 𝒍 & {\textbackslash}bil & Mathematical Bold Italic Small L \\
\hline
U+1D48E & 𝒎 & {\textbackslash}bim & Mathematical Bold Italic Small M \\
\hline
U+1D48F & 𝒏 & {\textbackslash}bin & Mathematical Bold Italic Small N \\
\hline
U+1D490 & 𝒐 & {\textbackslash}bio & Mathematical Bold Italic Small O \\
\hline
U+1D491 & 𝒑 & {\textbackslash}bip & Mathematical Bold Italic Small P \\
\hline
U+1D492 & 𝒒 & {\textbackslash}biq & Mathematical Bold Italic Small Q \\
\hline
U+1D493 & 𝒓 & {\textbackslash}bir & Mathematical Bold Italic Small R \\
\hline
U+1D494 & 𝒔 & {\textbackslash}bis & Mathematical Bold Italic Small S \\
\hline
U+1D495 & 𝒕 & {\textbackslash}bit & Mathematical Bold Italic Small T \\
\hline
U+1D496 & 𝒖 & {\textbackslash}biu & Mathematical Bold Italic Small U \\
\hline
U+1D497 & 𝒗 & {\textbackslash}biv & Mathematical Bold Italic Small V \\
\hline
U+1D498 & 𝒘 & {\textbackslash}biw & Mathematical Bold Italic Small W \\
\hline
U+1D499 & 𝒙 & {\textbackslash}bix & Mathematical Bold Italic Small X \\
\hline
U+1D49A & 𝒚 & {\textbackslash}biy & Mathematical Bold Italic Small Y \\
\hline
U+1D49B & 𝒛 & {\textbackslash}biz & Mathematical Bold Italic Small Z \\
\hline
U+1D49C & 𝒜 & {\textbackslash}scrA & Mathematical Script Capital A \\
\hline
U+1D49E & 𝒞 & {\textbackslash}scrC & Mathematical Script Capital C \\
\hline
U+1D49F & 𝒟 & {\textbackslash}scrD & Mathematical Script Capital D \\
\hline
U+1D4A2 & 𝒢 & {\textbackslash}scrG & Mathematical Script Capital G \\
\hline
U+1D4A5 & 𝒥 & {\textbackslash}scrJ & Mathematical Script Capital J \\
\hline
U+1D4A6 & 𝒦 & {\textbackslash}scrK & Mathematical Script Capital K \\
\hline
U+1D4A9 & 𝒩 & {\textbackslash}scrN & Mathematical Script Capital N \\
\hline
U+1D4AA & 𝒪 & {\textbackslash}scrO & Mathematical Script Capital O \\
\hline
U+1D4AB & 𝒫 & {\textbackslash}scrP & Mathematical Script Capital P \\
\hline
U+1D4AC & 𝒬 & {\textbackslash}scrQ & Mathematical Script Capital Q \\
\hline
U+1D4AE & 𝒮 & {\textbackslash}scrS & Mathematical Script Capital S \\
\hline
U+1D4AF & 𝒯 & {\textbackslash}scrT & Mathematical Script Capital T \\
\hline
U+1D4B0 & 𝒰 & {\textbackslash}scrU & Mathematical Script Capital U \\
\hline
U+1D4B1 & 𝒱 & {\textbackslash}scrV & Mathematical Script Capital V \\
\hline
U+1D4B2 & 𝒲 & {\textbackslash}scrW & Mathematical Script Capital W \\
\hline
U+1D4B3 & 𝒳 & {\textbackslash}scrX & Mathematical Script Capital X \\
\hline
U+1D4B4 & 𝒴 & {\textbackslash}scrY & Mathematical Script Capital Y \\
\hline
U+1D4B5 & 𝒵 & {\textbackslash}scrZ & Mathematical Script Capital Z \\
\hline
U+1D4B6 & 𝒶 & {\textbackslash}scra & Mathematical Script Small A \\
\hline
U+1D4B7 & 𝒷 & {\textbackslash}scrb & Mathematical Script Small B \\
\hline
U+1D4B8 & 𝒸 & {\textbackslash}scrc & Mathematical Script Small C \\
\hline
U+1D4B9 & 𝒹 & {\textbackslash}scrd & Mathematical Script Small D \\
\hline
U+1D4BB & 𝒻 & {\textbackslash}scrf & Mathematical Script Small F \\
\hline
U+1D4BD & 𝒽 & {\textbackslash}scrh & Mathematical Script Small H \\
\hline
U+1D4BE & 𝒾 & {\textbackslash}scri & Mathematical Script Small I \\
\hline
U+1D4BF & 𝒿 & {\textbackslash}scrj & Mathematical Script Small J \\
\hline
U+1D4C0 & 𝓀 & {\textbackslash}scrk & Mathematical Script Small K \\
\hline
U+1D4C1 & 𝓁 & {\textbackslash}scrl & Mathematical Script Small L \\
\hline
U+1D4C2 & 𝓂 & {\textbackslash}scrm & Mathematical Script Small M \\
\hline
U+1D4C3 & 𝓃 & {\textbackslash}scrn & Mathematical Script Small N \\
\hline
U+1D4C5 & 𝓅 & {\textbackslash}scrp & Mathematical Script Small P \\
\hline
U+1D4C6 & 𝓆 & {\textbackslash}scrq & Mathematical Script Small Q \\
\hline
U+1D4C7 & 𝓇 & {\textbackslash}scrr & Mathematical Script Small R \\
\hline
U+1D4C8 & 𝓈 & {\textbackslash}scrs & Mathematical Script Small S \\
\hline
U+1D4C9 & 𝓉 & {\textbackslash}scrt & Mathematical Script Small T \\
\hline
U+1D4CA & 𝓊 & {\textbackslash}scru & Mathematical Script Small U \\
\hline
U+1D4CB & 𝓋 & {\textbackslash}scrv & Mathematical Script Small V \\
\hline
U+1D4CC & 𝓌 & {\textbackslash}scrw & Mathematical Script Small W \\
\hline
U+1D4CD & 𝓍 & {\textbackslash}scrx & Mathematical Script Small X \\
\hline
U+1D4CE & 𝓎 & {\textbackslash}scry & Mathematical Script Small Y \\
\hline
U+1D4CF & 𝓏 & {\textbackslash}scrz & Mathematical Script Small Z \\
\hline
U+1D4D0 & 𝓐 & {\textbackslash}bscrA & Mathematical Bold Script Capital A \\
\hline
U+1D4D1 & 𝓑 & {\textbackslash}bscrB & Mathematical Bold Script Capital B \\
\hline
U+1D4D2 & 𝓒 & {\textbackslash}bscrC & Mathematical Bold Script Capital C \\
\hline
U+1D4D3 & 𝓓 & {\textbackslash}bscrD & Mathematical Bold Script Capital D \\
\hline
U+1D4D4 & 𝓔 & {\textbackslash}bscrE & Mathematical Bold Script Capital E \\
\hline
U+1D4D5 & 𝓕 & {\textbackslash}bscrF & Mathematical Bold Script Capital F \\
\hline
U+1D4D6 & 𝓖 & {\textbackslash}bscrG & Mathematical Bold Script Capital G \\
\hline
U+1D4D7 & 𝓗 & {\textbackslash}bscrH & Mathematical Bold Script Capital H \\
\hline
U+1D4D8 & 𝓘 & {\textbackslash}bscrI & Mathematical Bold Script Capital I \\
\hline
U+1D4D9 & 𝓙 & {\textbackslash}bscrJ & Mathematical Bold Script Capital J \\
\hline
U+1D4DA & 𝓚 & {\textbackslash}bscrK & Mathematical Bold Script Capital K \\
\hline
U+1D4DB & 𝓛 & {\textbackslash}bscrL & Mathematical Bold Script Capital L \\
\hline
U+1D4DC & 𝓜 & {\textbackslash}bscrM & Mathematical Bold Script Capital M \\
\hline
U+1D4DD & 𝓝 & {\textbackslash}bscrN & Mathematical Bold Script Capital N \\
\hline
U+1D4DE & 𝓞 & {\textbackslash}bscrO & Mathematical Bold Script Capital O \\
\hline
U+1D4DF & 𝓟 & {\textbackslash}bscrP & Mathematical Bold Script Capital P \\
\hline
U+1D4E0 & 𝓠 & {\textbackslash}bscrQ & Mathematical Bold Script Capital Q \\
\hline
U+1D4E1 & 𝓡 & {\textbackslash}bscrR & Mathematical Bold Script Capital R \\
\hline
U+1D4E2 & 𝓢 & {\textbackslash}bscrS & Mathematical Bold Script Capital S \\
\hline
U+1D4E3 & 𝓣 & {\textbackslash}bscrT & Mathematical Bold Script Capital T \\
\hline
U+1D4E4 & 𝓤 & {\textbackslash}bscrU & Mathematical Bold Script Capital U \\
\hline
U+1D4E5 & 𝓥 & {\textbackslash}bscrV & Mathematical Bold Script Capital V \\
\hline
U+1D4E6 & 𝓦 & {\textbackslash}bscrW & Mathematical Bold Script Capital W \\
\hline
U+1D4E7 & 𝓧 & {\textbackslash}bscrX & Mathematical Bold Script Capital X \\
\hline
U+1D4E8 & 𝓨 & {\textbackslash}bscrY & Mathematical Bold Script Capital Y \\
\hline
U+1D4E9 & 𝓩 & {\textbackslash}bscrZ & Mathematical Bold Script Capital Z \\
\hline
U+1D4EA & 𝓪 & {\textbackslash}bscra & Mathematical Bold Script Small A \\
\hline
U+1D4EB & 𝓫 & {\textbackslash}bscrb & Mathematical Bold Script Small B \\
\hline
U+1D4EC & 𝓬 & {\textbackslash}bscrc & Mathematical Bold Script Small C \\
\hline
U+1D4ED & 𝓭 & {\textbackslash}bscrd & Mathematical Bold Script Small D \\
\hline
U+1D4EE & 𝓮 & {\textbackslash}bscre & Mathematical Bold Script Small E \\
\hline
U+1D4EF & 𝓯 & {\textbackslash}bscrf & Mathematical Bold Script Small F \\
\hline
U+1D4F0 & 𝓰 & {\textbackslash}bscrg & Mathematical Bold Script Small G \\
\hline
U+1D4F1 & 𝓱 & {\textbackslash}bscrh & Mathematical Bold Script Small H \\
\hline
U+1D4F2 & 𝓲 & {\textbackslash}bscri & Mathematical Bold Script Small I \\
\hline
U+1D4F3 & 𝓳 & {\textbackslash}bscrj & Mathematical Bold Script Small J \\
\hline
U+1D4F4 & 𝓴 & {\textbackslash}bscrk & Mathematical Bold Script Small K \\
\hline
U+1D4F5 & 𝓵 & {\textbackslash}bscrl & Mathematical Bold Script Small L \\
\hline
U+1D4F6 & 𝓶 & {\textbackslash}bscrm & Mathematical Bold Script Small M \\
\hline
U+1D4F7 & 𝓷 & {\textbackslash}bscrn & Mathematical Bold Script Small N \\
\hline
U+1D4F8 & 𝓸 & {\textbackslash}bscro & Mathematical Bold Script Small O \\
\hline
U+1D4F9 & 𝓹 & {\textbackslash}bscrp & Mathematical Bold Script Small P \\
\hline
U+1D4FA & 𝓺 & {\textbackslash}bscrq & Mathematical Bold Script Small Q \\
\hline
U+1D4FB & 𝓻 & {\textbackslash}bscrr & Mathematical Bold Script Small R \\
\hline
U+1D4FC & 𝓼 & {\textbackslash}bscrs & Mathematical Bold Script Small S \\
\hline
U+1D4FD & 𝓽 & {\textbackslash}bscrt & Mathematical Bold Script Small T \\
\hline
U+1D4FE & 𝓾 & {\textbackslash}bscru & Mathematical Bold Script Small U \\
\hline
U+1D4FF & 𝓿 & {\textbackslash}bscrv & Mathematical Bold Script Small V \\
\hline
U+1D500 & 𝔀 & {\textbackslash}bscrw & Mathematical Bold Script Small W \\
\hline
U+1D501 & 𝔁 & {\textbackslash}bscrx & Mathematical Bold Script Small X \\
\hline
U+1D502 & 𝔂 & {\textbackslash}bscry & Mathematical Bold Script Small Y \\
\hline
U+1D503 & 𝔃 & {\textbackslash}bscrz & Mathematical Bold Script Small Z \\
\hline
U+1D504 & 𝔄 & {\textbackslash}frakA & Mathematical Fraktur Capital A \\
\hline
U+1D505 & 𝔅 & {\textbackslash}frakB & Mathematical Fraktur Capital B \\
\hline
U+1D507 & 𝔇 & {\textbackslash}frakD & Mathematical Fraktur Capital D \\
\hline
U+1D508 & 𝔈 & {\textbackslash}frakE & Mathematical Fraktur Capital E \\
\hline
U+1D509 & 𝔉 & {\textbackslash}frakF & Mathematical Fraktur Capital F \\
\hline
U+1D50A & 𝔊 & {\textbackslash}frakG & Mathematical Fraktur Capital G \\
\hline
U+1D50D & 𝔍 & {\textbackslash}frakJ & Mathematical Fraktur Capital J \\
\hline
U+1D50E & 𝔎 & {\textbackslash}frakK & Mathematical Fraktur Capital K \\
\hline
U+1D50F & 𝔏 & {\textbackslash}frakL & Mathematical Fraktur Capital L \\
\hline
U+1D510 & 𝔐 & {\textbackslash}frakM & Mathematical Fraktur Capital M \\
\hline
U+1D511 & 𝔑 & {\textbackslash}frakN & Mathematical Fraktur Capital N \\
\hline
U+1D512 & 𝔒 & {\textbackslash}frakO & Mathematical Fraktur Capital O \\
\hline
U+1D513 & 𝔓 & {\textbackslash}frakP & Mathematical Fraktur Capital P \\
\hline
U+1D514 & 𝔔 & {\textbackslash}frakQ & Mathematical Fraktur Capital Q \\
\hline
U+1D516 & 𝔖 & {\textbackslash}frakS & Mathematical Fraktur Capital S \\
\hline
U+1D517 & 𝔗 & {\textbackslash}frakT & Mathematical Fraktur Capital T \\
\hline
U+1D518 & 𝔘 & {\textbackslash}frakU & Mathematical Fraktur Capital U \\
\hline
U+1D519 & 𝔙 & {\textbackslash}frakV & Mathematical Fraktur Capital V \\
\hline
U+1D51A & 𝔚 & {\textbackslash}frakW & Mathematical Fraktur Capital W \\
\hline
U+1D51B & 𝔛 & {\textbackslash}frakX & Mathematical Fraktur Capital X \\
\hline
U+1D51C & 𝔜 & {\textbackslash}frakY & Mathematical Fraktur Capital Y \\
\hline
U+1D51E & 𝔞 & {\textbackslash}fraka & Mathematical Fraktur Small A \\
\hline
U+1D51F & 𝔟 & {\textbackslash}frakb & Mathematical Fraktur Small B \\
\hline
U+1D520 & 𝔠 & {\textbackslash}frakc & Mathematical Fraktur Small C \\
\hline
U+1D521 & 𝔡 & {\textbackslash}frakd & Mathematical Fraktur Small D \\
\hline
U+1D522 & 𝔢 & {\textbackslash}frake & Mathematical Fraktur Small E \\
\hline
U+1D523 & 𝔣 & {\textbackslash}frakf & Mathematical Fraktur Small F \\
\hline
U+1D524 & 𝔤 & {\textbackslash}frakg & Mathematical Fraktur Small G \\
\hline
U+1D525 & 𝔥 & {\textbackslash}frakh & Mathematical Fraktur Small H \\
\hline
U+1D526 & 𝔦 & {\textbackslash}fraki & Mathematical Fraktur Small I \\
\hline
U+1D527 & 𝔧 & {\textbackslash}frakj & Mathematical Fraktur Small J \\
\hline
U+1D528 & 𝔨 & {\textbackslash}frakk & Mathematical Fraktur Small K \\
\hline
U+1D529 & 𝔩 & {\textbackslash}frakl & Mathematical Fraktur Small L \\
\hline
U+1D52A & 𝔪 & {\textbackslash}frakm & Mathematical Fraktur Small M \\
\hline
U+1D52B & 𝔫 & {\textbackslash}frakn & Mathematical Fraktur Small N \\
\hline
U+1D52C & 𝔬 & {\textbackslash}frako & Mathematical Fraktur Small O \\
\hline
U+1D52D & 𝔭 & {\textbackslash}frakp & Mathematical Fraktur Small P \\
\hline
U+1D52E & 𝔮 & {\textbackslash}frakq & Mathematical Fraktur Small Q \\
\hline
U+1D52F & 𝔯 & {\textbackslash}frakr & Mathematical Fraktur Small R \\
\hline
U+1D530 & 𝔰 & {\textbackslash}fraks & Mathematical Fraktur Small S \\
\hline
U+1D531 & 𝔱 & {\textbackslash}frakt & Mathematical Fraktur Small T \\
\hline
U+1D532 & 𝔲 & {\textbackslash}fraku & Mathematical Fraktur Small U \\
\hline
U+1D533 & 𝔳 & {\textbackslash}frakv & Mathematical Fraktur Small V \\
\hline
U+1D534 & 𝔴 & {\textbackslash}frakw & Mathematical Fraktur Small W \\
\hline
U+1D535 & 𝔵 & {\textbackslash}frakx & Mathematical Fraktur Small X \\
\hline
U+1D536 & 𝔶 & {\textbackslash}fraky & Mathematical Fraktur Small Y \\
\hline
U+1D537 & 𝔷 & {\textbackslash}frakz & Mathematical Fraktur Small Z \\
\hline
U+1D538 & 𝔸 & {\textbackslash}bbA & Mathematical Double-Struck Capital A \\
\hline
U+1D539 & 𝔹 & {\textbackslash}bbB & Mathematical Double-Struck Capital B \\
\hline
U+1D53B & 𝔻 & {\textbackslash}bbD & Mathematical Double-Struck Capital D \\
\hline
U+1D53C & 𝔼 & {\textbackslash}bbE & Mathematical Double-Struck Capital E \\
\hline
U+1D53D & 𝔽 & {\textbackslash}bbF & Mathematical Double-Struck Capital F \\
\hline
U+1D53E & 𝔾 & {\textbackslash}bbG & Mathematical Double-Struck Capital G \\
\hline
U+1D540 & 𝕀 & {\textbackslash}bbI & Mathematical Double-Struck Capital I \\
\hline
U+1D541 & 𝕁 & {\textbackslash}bbJ & Mathematical Double-Struck Capital J \\
\hline
U+1D542 & 𝕂 & {\textbackslash}bbK & Mathematical Double-Struck Capital K \\
\hline
U+1D543 & 𝕃 & {\textbackslash}bbL & Mathematical Double-Struck Capital L \\
\hline
U+1D544 & 𝕄 & {\textbackslash}bbM & Mathematical Double-Struck Capital M \\
\hline
U+1D546 & 𝕆 & {\textbackslash}bbO & Mathematical Double-Struck Capital O \\
\hline
U+1D54A & 𝕊 & {\textbackslash}bbS & Mathematical Double-Struck Capital S \\
\hline
U+1D54B & 𝕋 & {\textbackslash}bbT & Mathematical Double-Struck Capital T \\
\hline
U+1D54C & 𝕌 & {\textbackslash}bbU & Mathematical Double-Struck Capital U \\
\hline
U+1D54D & 𝕍 & {\textbackslash}bbV & Mathematical Double-Struck Capital V \\
\hline
U+1D54E & 𝕎 & {\textbackslash}bbW & Mathematical Double-Struck Capital W \\
\hline
U+1D54F & 𝕏 & {\textbackslash}bbX & Mathematical Double-Struck Capital X \\
\hline
U+1D550 & 𝕐 & {\textbackslash}bbY & Mathematical Double-Struck Capital Y \\
\hline
U+1D552 & 𝕒 & {\textbackslash}bba & Mathematical Double-Struck Small A \\
\hline
U+1D553 & 𝕓 & {\textbackslash}bbb & Mathematical Double-Struck Small B \\
\hline
U+1D554 & 𝕔 & {\textbackslash}bbc & Mathematical Double-Struck Small C \\
\hline
U+1D555 & 𝕕 & {\textbackslash}bbd & Mathematical Double-Struck Small D \\
\hline
U+1D556 & 𝕖 & {\textbackslash}bbe & Mathematical Double-Struck Small E \\
\hline
U+1D557 & 𝕗 & {\textbackslash}bbf & Mathematical Double-Struck Small F \\
\hline
U+1D558 & 𝕘 & {\textbackslash}bbg & Mathematical Double-Struck Small G \\
\hline
U+1D559 & 𝕙 & {\textbackslash}bbh & Mathematical Double-Struck Small H \\
\hline
U+1D55A & 𝕚 & {\textbackslash}bbi & Mathematical Double-Struck Small I \\
\hline
U+1D55B & 𝕛 & {\textbackslash}bbj & Mathematical Double-Struck Small J \\
\hline
U+1D55C & 𝕜 & {\textbackslash}bbk & Mathematical Double-Struck Small K \\
\hline
U+1D55D & 𝕝 & {\textbackslash}bbl & Mathematical Double-Struck Small L \\
\hline
U+1D55E & 𝕞 & {\textbackslash}bbm & Mathematical Double-Struck Small M \\
\hline
U+1D55F & 𝕟 & {\textbackslash}bbn & Mathematical Double-Struck Small N \\
\hline
U+1D560 & 𝕠 & {\textbackslash}bbo & Mathematical Double-Struck Small O \\
\hline
U+1D561 & 𝕡 & {\textbackslash}bbp & Mathematical Double-Struck Small P \\
\hline
U+1D562 & 𝕢 & {\textbackslash}bbq & Mathematical Double-Struck Small Q \\
\hline
U+1D563 & 𝕣 & {\textbackslash}bbr & Mathematical Double-Struck Small R \\
\hline
U+1D564 & 𝕤 & {\textbackslash}bbs & Mathematical Double-Struck Small S \\
\hline
U+1D565 & 𝕥 & {\textbackslash}bbt & Mathematical Double-Struck Small T \\
\hline
U+1D566 & 𝕦 & {\textbackslash}bbu & Mathematical Double-Struck Small U \\
\hline
U+1D567 & 𝕧 & {\textbackslash}bbv & Mathematical Double-Struck Small V \\
\hline
U+1D568 & 𝕨 & {\textbackslash}bbw & Mathematical Double-Struck Small W \\
\hline
U+1D569 & 𝕩 & {\textbackslash}bbx & Mathematical Double-Struck Small X \\
\hline
U+1D56A & 𝕪 & {\textbackslash}bby & Mathematical Double-Struck Small Y \\
\hline
U+1D56B & 𝕫 & {\textbackslash}bbz & Mathematical Double-Struck Small Z \\
\hline
U+1D56C & 𝕬 & {\textbackslash}bfrakA & Mathematical Bold Fraktur Capital A \\
\hline
U+1D56D & 𝕭 & {\textbackslash}bfrakB & Mathematical Bold Fraktur Capital B \\
\hline
U+1D56E & 𝕮 & {\textbackslash}bfrakC & Mathematical Bold Fraktur Capital C \\
\hline
U+1D56F & 𝕯 & {\textbackslash}bfrakD & Mathematical Bold Fraktur Capital D \\
\hline
U+1D570 & 𝕰 & {\textbackslash}bfrakE & Mathematical Bold Fraktur Capital E \\
\hline
U+1D571 & 𝕱 & {\textbackslash}bfrakF & Mathematical Bold Fraktur Capital F \\
\hline
U+1D572 & 𝕲 & {\textbackslash}bfrakG & Mathematical Bold Fraktur Capital G \\
\hline
U+1D573 & 𝕳 & {\textbackslash}bfrakH & Mathematical Bold Fraktur Capital H \\
\hline
U+1D574 & 𝕴 & {\textbackslash}bfrakI & Mathematical Bold Fraktur Capital I \\
\hline
U+1D575 & 𝕵 & {\textbackslash}bfrakJ & Mathematical Bold Fraktur Capital J \\
\hline
U+1D576 & 𝕶 & {\textbackslash}bfrakK & Mathematical Bold Fraktur Capital K \\
\hline
U+1D577 & 𝕷 & {\textbackslash}bfrakL & Mathematical Bold Fraktur Capital L \\
\hline
U+1D578 & 𝕸 & {\textbackslash}bfrakM & Mathematical Bold Fraktur Capital M \\
\hline
U+1D579 & 𝕹 & {\textbackslash}bfrakN & Mathematical Bold Fraktur Capital N \\
\hline
U+1D57A & 𝕺 & {\textbackslash}bfrakO & Mathematical Bold Fraktur Capital O \\
\hline
U+1D57B & 𝕻 & {\textbackslash}bfrakP & Mathematical Bold Fraktur Capital P \\
\hline
U+1D57C & 𝕼 & {\textbackslash}bfrakQ & Mathematical Bold Fraktur Capital Q \\
\hline
U+1D57D & 𝕽 & {\textbackslash}bfrakR & Mathematical Bold Fraktur Capital R \\
\hline
U+1D57E & 𝕾 & {\textbackslash}bfrakS & Mathematical Bold Fraktur Capital S \\
\hline
U+1D57F & 𝕿 & {\textbackslash}bfrakT & Mathematical Bold Fraktur Capital T \\
\hline
U+1D580 & 𝖀 & {\textbackslash}bfrakU & Mathematical Bold Fraktur Capital U \\
\hline
U+1D581 & 𝖁 & {\textbackslash}bfrakV & Mathematical Bold Fraktur Capital V \\
\hline
U+1D582 & 𝖂 & {\textbackslash}bfrakW & Mathematical Bold Fraktur Capital W \\
\hline
U+1D583 & 𝖃 & {\textbackslash}bfrakX & Mathematical Bold Fraktur Capital X \\
\hline
U+1D584 & 𝖄 & {\textbackslash}bfrakY & Mathematical Bold Fraktur Capital Y \\
\hline
U+1D585 & 𝖅 & {\textbackslash}bfrakZ & Mathematical Bold Fraktur Capital Z \\
\hline
U+1D586 & 𝖆 & {\textbackslash}bfraka & Mathematical Bold Fraktur Small A \\
\hline
U+1D587 & 𝖇 & {\textbackslash}bfrakb & Mathematical Bold Fraktur Small B \\
\hline
U+1D588 & 𝖈 & {\textbackslash}bfrakc & Mathematical Bold Fraktur Small C \\
\hline
U+1D589 & 𝖉 & {\textbackslash}bfrakd & Mathematical Bold Fraktur Small D \\
\hline
U+1D58A & 𝖊 & {\textbackslash}bfrake & Mathematical Bold Fraktur Small E \\
\hline
U+1D58B & 𝖋 & {\textbackslash}bfrakf & Mathematical Bold Fraktur Small F \\
\hline
U+1D58C & 𝖌 & {\textbackslash}bfrakg & Mathematical Bold Fraktur Small G \\
\hline
U+1D58D & 𝖍 & {\textbackslash}bfrakh & Mathematical Bold Fraktur Small H \\
\hline
U+1D58E & 𝖎 & {\textbackslash}bfraki & Mathematical Bold Fraktur Small I \\
\hline
U+1D58F & 𝖏 & {\textbackslash}bfrakj & Mathematical Bold Fraktur Small J \\
\hline
U+1D590 & 𝖐 & {\textbackslash}bfrakk & Mathematical Bold Fraktur Small K \\
\hline
U+1D591 & 𝖑 & {\textbackslash}bfrakl & Mathematical Bold Fraktur Small L \\
\hline
U+1D592 & 𝖒 & {\textbackslash}bfrakm & Mathematical Bold Fraktur Small M \\
\hline
U+1D593 & 𝖓 & {\textbackslash}bfrakn & Mathematical Bold Fraktur Small N \\
\hline
U+1D594 & 𝖔 & {\textbackslash}bfrako & Mathematical Bold Fraktur Small O \\
\hline
U+1D595 & 𝖕 & {\textbackslash}bfrakp & Mathematical Bold Fraktur Small P \\
\hline
U+1D596 & 𝖖 & {\textbackslash}bfrakq & Mathematical Bold Fraktur Small Q \\
\hline
U+1D597 & 𝖗 & {\textbackslash}bfrakr & Mathematical Bold Fraktur Small R \\
\hline
U+1D598 & 𝖘 & {\textbackslash}bfraks & Mathematical Bold Fraktur Small S \\
\hline
U+1D599 & 𝖙 & {\textbackslash}bfrakt & Mathematical Bold Fraktur Small T \\
\hline
U+1D59A & 𝖚 & {\textbackslash}bfraku & Mathematical Bold Fraktur Small U \\
\hline
U+1D59B & 𝖛 & {\textbackslash}bfrakv & Mathematical Bold Fraktur Small V \\
\hline
U+1D59C & 𝖜 & {\textbackslash}bfrakw & Mathematical Bold Fraktur Small W \\
\hline
U+1D59D & 𝖝 & {\textbackslash}bfrakx & Mathematical Bold Fraktur Small X \\
\hline
U+1D59E & 𝖞 & {\textbackslash}bfraky & Mathematical Bold Fraktur Small Y \\
\hline
U+1D59F & 𝖟 & {\textbackslash}bfrakz & Mathematical Bold Fraktur Small Z \\
\hline
U+1D5A0 & 𝖠 & {\textbackslash}sansA & Mathematical Sans-Serif Capital A \\
\hline
U+1D5A1 & 𝖡 & {\textbackslash}sansB & Mathematical Sans-Serif Capital B \\
\hline
U+1D5A2 & 𝖢 & {\textbackslash}sansC & Mathematical Sans-Serif Capital C \\
\hline
U+1D5A3 & 𝖣 & {\textbackslash}sansD & Mathematical Sans-Serif Capital D \\
\hline
U+1D5A4 & 𝖤 & {\textbackslash}sansE & Mathematical Sans-Serif Capital E \\
\hline
U+1D5A5 & 𝖥 & {\textbackslash}sansF & Mathematical Sans-Serif Capital F \\
\hline
U+1D5A6 & 𝖦 & {\textbackslash}sansG & Mathematical Sans-Serif Capital G \\
\hline
U+1D5A7 & 𝖧 & {\textbackslash}sansH & Mathematical Sans-Serif Capital H \\
\hline
U+1D5A8 & 𝖨 & {\textbackslash}sansI & Mathematical Sans-Serif Capital I \\
\hline
U+1D5A9 & 𝖩 & {\textbackslash}sansJ & Mathematical Sans-Serif Capital J \\
\hline
U+1D5AA & 𝖪 & {\textbackslash}sansK & Mathematical Sans-Serif Capital K \\
\hline
U+1D5AB & 𝖫 & {\textbackslash}sansL & Mathematical Sans-Serif Capital L \\
\hline
U+1D5AC & 𝖬 & {\textbackslash}sansM & Mathematical Sans-Serif Capital M \\
\hline
U+1D5AD & 𝖭 & {\textbackslash}sansN & Mathematical Sans-Serif Capital N \\
\hline
U+1D5AE & 𝖮 & {\textbackslash}sansO & Mathematical Sans-Serif Capital O \\
\hline
U+1D5AF & 𝖯 & {\textbackslash}sansP & Mathematical Sans-Serif Capital P \\
\hline
U+1D5B0 & 𝖰 & {\textbackslash}sansQ & Mathematical Sans-Serif Capital Q \\
\hline
U+1D5B1 & 𝖱 & {\textbackslash}sansR & Mathematical Sans-Serif Capital R \\
\hline
U+1D5B2 & 𝖲 & {\textbackslash}sansS & Mathematical Sans-Serif Capital S \\
\hline
U+1D5B3 & 𝖳 & {\textbackslash}sansT & Mathematical Sans-Serif Capital T \\
\hline
U+1D5B4 & 𝖴 & {\textbackslash}sansU & Mathematical Sans-Serif Capital U \\
\hline
U+1D5B5 & 𝖵 & {\textbackslash}sansV & Mathematical Sans-Serif Capital V \\
\hline
U+1D5B6 & 𝖶 & {\textbackslash}sansW & Mathematical Sans-Serif Capital W \\
\hline
U+1D5B7 & 𝖷 & {\textbackslash}sansX & Mathematical Sans-Serif Capital X \\
\hline
U+1D5B8 & 𝖸 & {\textbackslash}sansY & Mathematical Sans-Serif Capital Y \\
\hline
U+1D5B9 & 𝖹 & {\textbackslash}sansZ & Mathematical Sans-Serif Capital Z \\
\hline
U+1D5BA & 𝖺 & {\textbackslash}sansa & Mathematical Sans-Serif Small A \\
\hline
U+1D5BB & 𝖻 & {\textbackslash}sansb & Mathematical Sans-Serif Small B \\
\hline
U+1D5BC & 𝖼 & {\textbackslash}sansc & Mathematical Sans-Serif Small C \\
\hline
U+1D5BD & 𝖽 & {\textbackslash}sansd & Mathematical Sans-Serif Small D \\
\hline
U+1D5BE & 𝖾 & {\textbackslash}sanse & Mathematical Sans-Serif Small E \\
\hline
U+1D5BF & 𝖿 & {\textbackslash}sansf & Mathematical Sans-Serif Small F \\
\hline
U+1D5C0 & 𝗀 & {\textbackslash}sansg & Mathematical Sans-Serif Small G \\
\hline
U+1D5C1 & 𝗁 & {\textbackslash}sansh & Mathematical Sans-Serif Small H \\
\hline
U+1D5C2 & 𝗂 & {\textbackslash}sansi & Mathematical Sans-Serif Small I \\
\hline
U+1D5C3 & 𝗃 & {\textbackslash}sansj & Mathematical Sans-Serif Small J \\
\hline
U+1D5C4 & 𝗄 & {\textbackslash}sansk & Mathematical Sans-Serif Small K \\
\hline
U+1D5C5 & 𝗅 & {\textbackslash}sansl & Mathematical Sans-Serif Small L \\
\hline
U+1D5C6 & 𝗆 & {\textbackslash}sansm & Mathematical Sans-Serif Small M \\
\hline
U+1D5C7 & 𝗇 & {\textbackslash}sansn & Mathematical Sans-Serif Small N \\
\hline
U+1D5C8 & 𝗈 & {\textbackslash}sanso & Mathematical Sans-Serif Small O \\
\hline
U+1D5C9 & 𝗉 & {\textbackslash}sansp & Mathematical Sans-Serif Small P \\
\hline
U+1D5CA & 𝗊 & {\textbackslash}sansq & Mathematical Sans-Serif Small Q \\
\hline
U+1D5CB & 𝗋 & {\textbackslash}sansr & Mathematical Sans-Serif Small R \\
\hline
U+1D5CC & 𝗌 & {\textbackslash}sanss & Mathematical Sans-Serif Small S \\
\hline
U+1D5CD & 𝗍 & {\textbackslash}sanst & Mathematical Sans-Serif Small T \\
\hline
U+1D5CE & 𝗎 & {\textbackslash}sansu & Mathematical Sans-Serif Small U \\
\hline
U+1D5CF & 𝗏 & {\textbackslash}sansv & Mathematical Sans-Serif Small V \\
\hline
U+1D5D0 & 𝗐 & {\textbackslash}sansw & Mathematical Sans-Serif Small W \\
\hline
U+1D5D1 & 𝗑 & {\textbackslash}sansx & Mathematical Sans-Serif Small X \\
\hline
U+1D5D2 & 𝗒 & {\textbackslash}sansy & Mathematical Sans-Serif Small Y \\
\hline
U+1D5D3 & 𝗓 & {\textbackslash}sansz & Mathematical Sans-Serif Small Z \\
\hline
U+1D5D4 & 𝗔 & {\textbackslash}bsansA & Mathematical Sans-Serif Bold Capital A \\
\hline
U+1D5D5 & 𝗕 & {\textbackslash}bsansB & Mathematical Sans-Serif Bold Capital B \\
\hline
U+1D5D6 & 𝗖 & {\textbackslash}bsansC & Mathematical Sans-Serif Bold Capital C \\
\hline
U+1D5D7 & 𝗗 & {\textbackslash}bsansD & Mathematical Sans-Serif Bold Capital D \\
\hline
U+1D5D8 & 𝗘 & {\textbackslash}bsansE & Mathematical Sans-Serif Bold Capital E \\
\hline
U+1D5D9 & 𝗙 & {\textbackslash}bsansF & Mathematical Sans-Serif Bold Capital F \\
\hline
U+1D5DA & 𝗚 & {\textbackslash}bsansG & Mathematical Sans-Serif Bold Capital G \\
\hline
U+1D5DB & 𝗛 & {\textbackslash}bsansH & Mathematical Sans-Serif Bold Capital H \\
\hline
U+1D5DC & 𝗜 & {\textbackslash}bsansI & Mathematical Sans-Serif Bold Capital I \\
\hline
U+1D5DD & 𝗝 & {\textbackslash}bsansJ & Mathematical Sans-Serif Bold Capital J \\
\hline
U+1D5DE & 𝗞 & {\textbackslash}bsansK & Mathematical Sans-Serif Bold Capital K \\
\hline
U+1D5DF & 𝗟 & {\textbackslash}bsansL & Mathematical Sans-Serif Bold Capital L \\
\hline
U+1D5E0 & 𝗠 & {\textbackslash}bsansM & Mathematical Sans-Serif Bold Capital M \\
\hline
U+1D5E1 & 𝗡 & {\textbackslash}bsansN & Mathematical Sans-Serif Bold Capital N \\
\hline
U+1D5E2 & 𝗢 & {\textbackslash}bsansO & Mathematical Sans-Serif Bold Capital O \\
\hline
U+1D5E3 & 𝗣 & {\textbackslash}bsansP & Mathematical Sans-Serif Bold Capital P \\
\hline
U+1D5E4 & 𝗤 & {\textbackslash}bsansQ & Mathematical Sans-Serif Bold Capital Q \\
\hline
U+1D5E5 & 𝗥 & {\textbackslash}bsansR & Mathematical Sans-Serif Bold Capital R \\
\hline
U+1D5E6 & 𝗦 & {\textbackslash}bsansS & Mathematical Sans-Serif Bold Capital S \\
\hline
U+1D5E7 & 𝗧 & {\textbackslash}bsansT & Mathematical Sans-Serif Bold Capital T \\
\hline
U+1D5E8 & 𝗨 & {\textbackslash}bsansU & Mathematical Sans-Serif Bold Capital U \\
\hline
U+1D5E9 & 𝗩 & {\textbackslash}bsansV & Mathematical Sans-Serif Bold Capital V \\
\hline
U+1D5EA & 𝗪 & {\textbackslash}bsansW & Mathematical Sans-Serif Bold Capital W \\
\hline
U+1D5EB & 𝗫 & {\textbackslash}bsansX & Mathematical Sans-Serif Bold Capital X \\
\hline
U+1D5EC & 𝗬 & {\textbackslash}bsansY & Mathematical Sans-Serif Bold Capital Y \\
\hline
U+1D5ED & 𝗭 & {\textbackslash}bsansZ & Mathematical Sans-Serif Bold Capital Z \\
\hline
U+1D5EE & 𝗮 & {\textbackslash}bsansa & Mathematical Sans-Serif Bold Small A \\
\hline
U+1D5EF & 𝗯 & {\textbackslash}bsansb & Mathematical Sans-Serif Bold Small B \\
\hline
U+1D5F0 & 𝗰 & {\textbackslash}bsansc & Mathematical Sans-Serif Bold Small C \\
\hline
U+1D5F1 & 𝗱 & {\textbackslash}bsansd & Mathematical Sans-Serif Bold Small D \\
\hline
U+1D5F2 & 𝗲 & {\textbackslash}bsanse & Mathematical Sans-Serif Bold Small E \\
\hline
U+1D5F3 & 𝗳 & {\textbackslash}bsansf & Mathematical Sans-Serif Bold Small F \\
\hline
U+1D5F4 & 𝗴 & {\textbackslash}bsansg & Mathematical Sans-Serif Bold Small G \\
\hline
U+1D5F5 & 𝗵 & {\textbackslash}bsansh & Mathematical Sans-Serif Bold Small H \\
\hline
U+1D5F6 & 𝗶 & {\textbackslash}bsansi & Mathematical Sans-Serif Bold Small I \\
\hline
U+1D5F7 & 𝗷 & {\textbackslash}bsansj & Mathematical Sans-Serif Bold Small J \\
\hline
U+1D5F8 & 𝗸 & {\textbackslash}bsansk & Mathematical Sans-Serif Bold Small K \\
\hline
U+1D5F9 & 𝗹 & {\textbackslash}bsansl & Mathematical Sans-Serif Bold Small L \\
\hline
U+1D5FA & 𝗺 & {\textbackslash}bsansm & Mathematical Sans-Serif Bold Small M \\
\hline
U+1D5FB & 𝗻 & {\textbackslash}bsansn & Mathematical Sans-Serif Bold Small N \\
\hline
U+1D5FC & 𝗼 & {\textbackslash}bsanso & Mathematical Sans-Serif Bold Small O \\
\hline
U+1D5FD & 𝗽 & {\textbackslash}bsansp & Mathematical Sans-Serif Bold Small P \\
\hline
U+1D5FE & 𝗾 & {\textbackslash}bsansq & Mathematical Sans-Serif Bold Small Q \\
\hline
U+1D5FF & 𝗿 & {\textbackslash}bsansr & Mathematical Sans-Serif Bold Small R \\
\hline
U+1D600 & 𝘀 & {\textbackslash}bsanss & Mathematical Sans-Serif Bold Small S \\
\hline
U+1D601 & 𝘁 & {\textbackslash}bsanst & Mathematical Sans-Serif Bold Small T \\
\hline
U+1D602 & 𝘂 & {\textbackslash}bsansu & Mathematical Sans-Serif Bold Small U \\
\hline
U+1D603 & 𝘃 & {\textbackslash}bsansv & Mathematical Sans-Serif Bold Small V \\
\hline
U+1D604 & 𝘄 & {\textbackslash}bsansw & Mathematical Sans-Serif Bold Small W \\
\hline
U+1D605 & 𝘅 & {\textbackslash}bsansx & Mathematical Sans-Serif Bold Small X \\
\hline
U+1D606 & 𝘆 & {\textbackslash}bsansy & Mathematical Sans-Serif Bold Small Y \\
\hline
U+1D607 & 𝘇 & {\textbackslash}bsansz & Mathematical Sans-Serif Bold Small Z \\
\hline
U+1D608 & 𝘈 & {\textbackslash}isansA & Mathematical Sans-Serif Italic Capital A \\
\hline
U+1D609 & 𝘉 & {\textbackslash}isansB & Mathematical Sans-Serif Italic Capital B \\
\hline
U+1D60A & 𝘊 & {\textbackslash}isansC & Mathematical Sans-Serif Italic Capital C \\
\hline
U+1D60B & 𝘋 & {\textbackslash}isansD & Mathematical Sans-Serif Italic Capital D \\
\hline
U+1D60C & 𝘌 & {\textbackslash}isansE & Mathematical Sans-Serif Italic Capital E \\
\hline
U+1D60D & 𝘍 & {\textbackslash}isansF & Mathematical Sans-Serif Italic Capital F \\
\hline
U+1D60E & 𝘎 & {\textbackslash}isansG & Mathematical Sans-Serif Italic Capital G \\
\hline
U+1D60F & 𝘏 & {\textbackslash}isansH & Mathematical Sans-Serif Italic Capital H \\
\hline
U+1D610 & 𝘐 & {\textbackslash}isansI & Mathematical Sans-Serif Italic Capital I \\
\hline
U+1D611 & 𝘑 & {\textbackslash}isansJ & Mathematical Sans-Serif Italic Capital J \\
\hline
U+1D612 & 𝘒 & {\textbackslash}isansK & Mathematical Sans-Serif Italic Capital K \\
\hline
U+1D613 & 𝘓 & {\textbackslash}isansL & Mathematical Sans-Serif Italic Capital L \\
\hline
U+1D614 & 𝘔 & {\textbackslash}isansM & Mathematical Sans-Serif Italic Capital M \\
\hline
U+1D615 & 𝘕 & {\textbackslash}isansN & Mathematical Sans-Serif Italic Capital N \\
\hline
U+1D616 & 𝘖 & {\textbackslash}isansO & Mathematical Sans-Serif Italic Capital O \\
\hline
U+1D617 & 𝘗 & {\textbackslash}isansP & Mathematical Sans-Serif Italic Capital P \\
\hline
U+1D618 & 𝘘 & {\textbackslash}isansQ & Mathematical Sans-Serif Italic Capital Q \\
\hline
U+1D619 & 𝘙 & {\textbackslash}isansR & Mathematical Sans-Serif Italic Capital R \\
\hline
U+1D61A & 𝘚 & {\textbackslash}isansS & Mathematical Sans-Serif Italic Capital S \\
\hline
U+1D61B & 𝘛 & {\textbackslash}isansT & Mathematical Sans-Serif Italic Capital T \\
\hline
U+1D61C & 𝘜 & {\textbackslash}isansU & Mathematical Sans-Serif Italic Capital U \\
\hline
U+1D61D & 𝘝 & {\textbackslash}isansV & Mathematical Sans-Serif Italic Capital V \\
\hline
U+1D61E & 𝘞 & {\textbackslash}isansW & Mathematical Sans-Serif Italic Capital W \\
\hline
U+1D61F & 𝘟 & {\textbackslash}isansX & Mathematical Sans-Serif Italic Capital X \\
\hline
U+1D620 & 𝘠 & {\textbackslash}isansY & Mathematical Sans-Serif Italic Capital Y \\
\hline
U+1D621 & 𝘡 & {\textbackslash}isansZ & Mathematical Sans-Serif Italic Capital Z \\
\hline
U+1D622 & 𝘢 & {\textbackslash}isansa & Mathematical Sans-Serif Italic Small A \\
\hline
U+1D623 & 𝘣 & {\textbackslash}isansb & Mathematical Sans-Serif Italic Small B \\
\hline
U+1D624 & 𝘤 & {\textbackslash}isansc & Mathematical Sans-Serif Italic Small C \\
\hline
U+1D625 & 𝘥 & {\textbackslash}isansd & Mathematical Sans-Serif Italic Small D \\
\hline
U+1D626 & 𝘦 & {\textbackslash}isanse & Mathematical Sans-Serif Italic Small E \\
\hline
U+1D627 & 𝘧 & {\textbackslash}isansf & Mathematical Sans-Serif Italic Small F \\
\hline
U+1D628 & 𝘨 & {\textbackslash}isansg & Mathematical Sans-Serif Italic Small G \\
\hline
U+1D629 & 𝘩 & {\textbackslash}isansh & Mathematical Sans-Serif Italic Small H \\
\hline
U+1D62A & 𝘪 & {\textbackslash}isansi & Mathematical Sans-Serif Italic Small I \\
\hline
U+1D62B & 𝘫 & {\textbackslash}isansj & Mathematical Sans-Serif Italic Small J \\
\hline
U+1D62C & 𝘬 & {\textbackslash}isansk & Mathematical Sans-Serif Italic Small K \\
\hline
U+1D62D & 𝘭 & {\textbackslash}isansl & Mathematical Sans-Serif Italic Small L \\
\hline
U+1D62E & 𝘮 & {\textbackslash}isansm & Mathematical Sans-Serif Italic Small M \\
\hline
U+1D62F & 𝘯 & {\textbackslash}isansn & Mathematical Sans-Serif Italic Small N \\
\hline
U+1D630 & 𝘰 & {\textbackslash}isanso & Mathematical Sans-Serif Italic Small O \\
\hline
U+1D631 & 𝘱 & {\textbackslash}isansp & Mathematical Sans-Serif Italic Small P \\
\hline
U+1D632 & 𝘲 & {\textbackslash}isansq & Mathematical Sans-Serif Italic Small Q \\
\hline
U+1D633 & 𝘳 & {\textbackslash}isansr & Mathematical Sans-Serif Italic Small R \\
\hline
U+1D634 & 𝘴 & {\textbackslash}isanss & Mathematical Sans-Serif Italic Small S \\
\hline
U+1D635 & 𝘵 & {\textbackslash}isanst & Mathematical Sans-Serif Italic Small T \\
\hline
U+1D636 & 𝘶 & {\textbackslash}isansu & Mathematical Sans-Serif Italic Small U \\
\hline
U+1D637 & 𝘷 & {\textbackslash}isansv & Mathematical Sans-Serif Italic Small V \\
\hline
U+1D638 & 𝘸 & {\textbackslash}isansw & Mathematical Sans-Serif Italic Small W \\
\hline
U+1D639 & 𝘹 & {\textbackslash}isansx & Mathematical Sans-Serif Italic Small X \\
\hline
U+1D63A & 𝘺 & {\textbackslash}isansy & Mathematical Sans-Serif Italic Small Y \\
\hline
U+1D63B & 𝘻 & {\textbackslash}isansz & Mathematical Sans-Serif Italic Small Z \\
\hline
U+1D63C & 𝘼 & {\textbackslash}bisansA & Mathematical Sans-Serif Bold Italic Capital A \\
\hline
U+1D63D & 𝘽 & {\textbackslash}bisansB & Mathematical Sans-Serif Bold Italic Capital B \\
\hline
U+1D63E & 𝘾 & {\textbackslash}bisansC & Mathematical Sans-Serif Bold Italic Capital C \\
\hline
U+1D63F & 𝘿 & {\textbackslash}bisansD & Mathematical Sans-Serif Bold Italic Capital D \\
\hline
U+1D640 & 𝙀 & {\textbackslash}bisansE & Mathematical Sans-Serif Bold Italic Capital E \\
\hline
U+1D641 & 𝙁 & {\textbackslash}bisansF & Mathematical Sans-Serif Bold Italic Capital F \\
\hline
U+1D642 & 𝙂 & {\textbackslash}bisansG & Mathematical Sans-Serif Bold Italic Capital G \\
\hline
U+1D643 & 𝙃 & {\textbackslash}bisansH & Mathematical Sans-Serif Bold Italic Capital H \\
\hline
U+1D644 & 𝙄 & {\textbackslash}bisansI & Mathematical Sans-Serif Bold Italic Capital I \\
\hline
U+1D645 & 𝙅 & {\textbackslash}bisansJ & Mathematical Sans-Serif Bold Italic Capital J \\
\hline
U+1D646 & 𝙆 & {\textbackslash}bisansK & Mathematical Sans-Serif Bold Italic Capital K \\
\hline
U+1D647 & 𝙇 & {\textbackslash}bisansL & Mathematical Sans-Serif Bold Italic Capital L \\
\hline
U+1D648 & 𝙈 & {\textbackslash}bisansM & Mathematical Sans-Serif Bold Italic Capital M \\
\hline
U+1D649 & 𝙉 & {\textbackslash}bisansN & Mathematical Sans-Serif Bold Italic Capital N \\
\hline
U+1D64A & 𝙊 & {\textbackslash}bisansO & Mathematical Sans-Serif Bold Italic Capital O \\
\hline
U+1D64B & 𝙋 & {\textbackslash}bisansP & Mathematical Sans-Serif Bold Italic Capital P \\
\hline
U+1D64C & 𝙌 & {\textbackslash}bisansQ & Mathematical Sans-Serif Bold Italic Capital Q \\
\hline
U+1D64D & 𝙍 & {\textbackslash}bisansR & Mathematical Sans-Serif Bold Italic Capital R \\
\hline
U+1D64E & 𝙎 & {\textbackslash}bisansS & Mathematical Sans-Serif Bold Italic Capital S \\
\hline
U+1D64F & 𝙏 & {\textbackslash}bisansT & Mathematical Sans-Serif Bold Italic Capital T \\
\hline
U+1D650 & 𝙐 & {\textbackslash}bisansU & Mathematical Sans-Serif Bold Italic Capital U \\
\hline
U+1D651 & 𝙑 & {\textbackslash}bisansV & Mathematical Sans-Serif Bold Italic Capital V \\
\hline
U+1D652 & 𝙒 & {\textbackslash}bisansW & Mathematical Sans-Serif Bold Italic Capital W \\
\hline
U+1D653 & 𝙓 & {\textbackslash}bisansX & Mathematical Sans-Serif Bold Italic Capital X \\
\hline
U+1D654 & 𝙔 & {\textbackslash}bisansY & Mathematical Sans-Serif Bold Italic Capital Y \\
\hline
U+1D655 & 𝙕 & {\textbackslash}bisansZ & Mathematical Sans-Serif Bold Italic Capital Z \\
\hline
U+1D656 & 𝙖 & {\textbackslash}bisansa & Mathematical Sans-Serif Bold Italic Small A \\
\hline
U+1D657 & 𝙗 & {\textbackslash}bisansb & Mathematical Sans-Serif Bold Italic Small B \\
\hline
U+1D658 & 𝙘 & {\textbackslash}bisansc & Mathematical Sans-Serif Bold Italic Small C \\
\hline
U+1D659 & 𝙙 & {\textbackslash}bisansd & Mathematical Sans-Serif Bold Italic Small D \\
\hline
U+1D65A & 𝙚 & {\textbackslash}bisanse & Mathematical Sans-Serif Bold Italic Small E \\
\hline
U+1D65B & 𝙛 & {\textbackslash}bisansf & Mathematical Sans-Serif Bold Italic Small F \\
\hline
U+1D65C & 𝙜 & {\textbackslash}bisansg & Mathematical Sans-Serif Bold Italic Small G \\
\hline
U+1D65D & 𝙝 & {\textbackslash}bisansh & Mathematical Sans-Serif Bold Italic Small H \\
\hline
U+1D65E & 𝙞 & {\textbackslash}bisansi & Mathematical Sans-Serif Bold Italic Small I \\
\hline
U+1D65F & 𝙟 & {\textbackslash}bisansj & Mathematical Sans-Serif Bold Italic Small J \\
\hline
U+1D660 & 𝙠 & {\textbackslash}bisansk & Mathematical Sans-Serif Bold Italic Small K \\
\hline
U+1D661 & 𝙡 & {\textbackslash}bisansl & Mathematical Sans-Serif Bold Italic Small L \\
\hline
U+1D662 & 𝙢 & {\textbackslash}bisansm & Mathematical Sans-Serif Bold Italic Small M \\
\hline
U+1D663 & 𝙣 & {\textbackslash}bisansn & Mathematical Sans-Serif Bold Italic Small N \\
\hline
U+1D664 & 𝙤 & {\textbackslash}bisanso & Mathematical Sans-Serif Bold Italic Small O \\
\hline
U+1D665 & 𝙥 & {\textbackslash}bisansp & Mathematical Sans-Serif Bold Italic Small P \\
\hline
U+1D666 & 𝙦 & {\textbackslash}bisansq & Mathematical Sans-Serif Bold Italic Small Q \\
\hline
U+1D667 & 𝙧 & {\textbackslash}bisansr & Mathematical Sans-Serif Bold Italic Small R \\
\hline
U+1D668 & 𝙨 & {\textbackslash}bisanss & Mathematical Sans-Serif Bold Italic Small S \\
\hline
U+1D669 & 𝙩 & {\textbackslash}bisanst & Mathematical Sans-Serif Bold Italic Small T \\
\hline
U+1D66A & 𝙪 & {\textbackslash}bisansu & Mathematical Sans-Serif Bold Italic Small U \\
\hline
U+1D66B & 𝙫 & {\textbackslash}bisansv & Mathematical Sans-Serif Bold Italic Small V \\
\hline
U+1D66C & 𝙬 & {\textbackslash}bisansw & Mathematical Sans-Serif Bold Italic Small W \\
\hline
U+1D66D & 𝙭 & {\textbackslash}bisansx & Mathematical Sans-Serif Bold Italic Small X \\
\hline
U+1D66E & 𝙮 & {\textbackslash}bisansy & Mathematical Sans-Serif Bold Italic Small Y \\
\hline
U+1D66F & 𝙯 & {\textbackslash}bisansz & Mathematical Sans-Serif Bold Italic Small Z \\
\hline
U+1D670 & 𝙰 & {\textbackslash}ttA & Mathematical Monospace Capital A \\
\hline
U+1D671 & 𝙱 & {\textbackslash}ttB & Mathematical Monospace Capital B \\
\hline
U+1D672 & 𝙲 & {\textbackslash}ttC & Mathematical Monospace Capital C \\
\hline
U+1D673 & 𝙳 & {\textbackslash}ttD & Mathematical Monospace Capital D \\
\hline
U+1D674 & 𝙴 & {\textbackslash}ttE & Mathematical Monospace Capital E \\
\hline
U+1D675 & 𝙵 & {\textbackslash}ttF & Mathematical Monospace Capital F \\
\hline
U+1D676 & 𝙶 & {\textbackslash}ttG & Mathematical Monospace Capital G \\
\hline
U+1D677 & 𝙷 & {\textbackslash}ttH & Mathematical Monospace Capital H \\
\hline
U+1D678 & 𝙸 & {\textbackslash}ttI & Mathematical Monospace Capital I \\
\hline
U+1D679 & 𝙹 & {\textbackslash}ttJ & Mathematical Monospace Capital J \\
\hline
U+1D67A & 𝙺 & {\textbackslash}ttK & Mathematical Monospace Capital K \\
\hline
U+1D67B & 𝙻 & {\textbackslash}ttL & Mathematical Monospace Capital L \\
\hline
U+1D67C & 𝙼 & {\textbackslash}ttM & Mathematical Monospace Capital M \\
\hline
U+1D67D & 𝙽 & {\textbackslash}ttN & Mathematical Monospace Capital N \\
\hline
U+1D67E & 𝙾 & {\textbackslash}ttO & Mathematical Monospace Capital O \\
\hline
U+1D67F & 𝙿 & {\textbackslash}ttP & Mathematical Monospace Capital P \\
\hline
U+1D680 & 𝚀 & {\textbackslash}ttQ & Mathematical Monospace Capital Q \\
\hline
U+1D681 & 𝚁 & {\textbackslash}ttR & Mathematical Monospace Capital R \\
\hline
U+1D682 & 𝚂 & {\textbackslash}ttS & Mathematical Monospace Capital S \\
\hline
U+1D683 & 𝚃 & {\textbackslash}ttT & Mathematical Monospace Capital T \\
\hline
U+1D684 & 𝚄 & {\textbackslash}ttU & Mathematical Monospace Capital U \\
\hline
U+1D685 & 𝚅 & {\textbackslash}ttV & Mathematical Monospace Capital V \\
\hline
U+1D686 & 𝚆 & {\textbackslash}ttW & Mathematical Monospace Capital W \\
\hline
U+1D687 & 𝚇 & {\textbackslash}ttX & Mathematical Monospace Capital X \\
\hline
U+1D688 & 𝚈 & {\textbackslash}ttY & Mathematical Monospace Capital Y \\
\hline
U+1D689 & 𝚉 & {\textbackslash}ttZ & Mathematical Monospace Capital Z \\
\hline
U+1D68A & 𝚊 & {\textbackslash}tta & Mathematical Monospace Small A \\
\hline
U+1D68B & 𝚋 & {\textbackslash}ttb & Mathematical Monospace Small B \\
\hline
U+1D68C & 𝚌 & {\textbackslash}ttc & Mathematical Monospace Small C \\
\hline
U+1D68D & 𝚍 & {\textbackslash}ttd & Mathematical Monospace Small D \\
\hline
U+1D68E & 𝚎 & {\textbackslash}tte & Mathematical Monospace Small E \\
\hline
U+1D68F & 𝚏 & {\textbackslash}ttf & Mathematical Monospace Small F \\
\hline
U+1D690 & 𝚐 & {\textbackslash}ttg & Mathematical Monospace Small G \\
\hline
U+1D691 & 𝚑 & {\textbackslash}tth & Mathematical Monospace Small H \\
\hline
U+1D692 & 𝚒 & {\textbackslash}tti & Mathematical Monospace Small I \\
\hline
U+1D693 & 𝚓 & {\textbackslash}ttj & Mathematical Monospace Small J \\
\hline
U+1D694 & 𝚔 & {\textbackslash}ttk & Mathematical Monospace Small K \\
\hline
U+1D695 & 𝚕 & {\textbackslash}ttl & Mathematical Monospace Small L \\
\hline
U+1D696 & 𝚖 & {\textbackslash}ttm & Mathematical Monospace Small M \\
\hline
U+1D697 & 𝚗 & {\textbackslash}ttn & Mathematical Monospace Small N \\
\hline
U+1D698 & 𝚘 & {\textbackslash}tto & Mathematical Monospace Small O \\
\hline
U+1D699 & 𝚙 & {\textbackslash}ttp & Mathematical Monospace Small P \\
\hline
U+1D69A & 𝚚 & {\textbackslash}ttq & Mathematical Monospace Small Q \\
\hline
U+1D69B & 𝚛 & {\textbackslash}ttr & Mathematical Monospace Small R \\
\hline
U+1D69C & 𝚜 & {\textbackslash}tts & Mathematical Monospace Small S \\
\hline
U+1D69D & 𝚝 & {\textbackslash}ttt & Mathematical Monospace Small T \\
\hline
U+1D69E & 𝚞 & {\textbackslash}ttu & Mathematical Monospace Small U \\
\hline
U+1D69F & 𝚟 & {\textbackslash}ttv & Mathematical Monospace Small V \\
\hline
U+1D6A0 & 𝚠 & {\textbackslash}ttw & Mathematical Monospace Small W \\
\hline
U+1D6A1 & 𝚡 & {\textbackslash}ttx & Mathematical Monospace Small X \\
\hline
U+1D6A2 & 𝚢 & {\textbackslash}tty & Mathematical Monospace Small Y \\
\hline
U+1D6A3 & 𝚣 & {\textbackslash}ttz & Mathematical Monospace Small Z \\
\hline
U+1D6A4 & 𝚤 & {\textbackslash}itimath & Mathematical Italic Small Dotless I \\
\hline
U+1D6A5 & 𝚥 & {\textbackslash}itjmath & Mathematical Italic Small Dotless J \\
\hline
U+1D6A8 & 𝚨 & {\textbackslash}bfAlpha & Mathematical Bold Capital Alpha \\
\hline
U+1D6A9 & 𝚩 & {\textbackslash}bfBeta & Mathematical Bold Capital Beta \\
\hline
U+1D6AA & 𝚪 & {\textbackslash}bfGamma & Mathematical Bold Capital Gamma \\
\hline
U+1D6AB & 𝚫 & {\textbackslash}bfDelta & Mathematical Bold Capital Delta \\
\hline
U+1D6AC & 𝚬 & {\textbackslash}bfEpsilon & Mathematical Bold Capital Epsilon \\
\hline
U+1D6AD & 𝚭 & {\textbackslash}bfZeta & Mathematical Bold Capital Zeta \\
\hline
U+1D6AE & 𝚮 & {\textbackslash}bfEta & Mathematical Bold Capital Eta \\
\hline
U+1D6AF & 𝚯 & {\textbackslash}bfTheta & Mathematical Bold Capital Theta \\
\hline
U+1D6B0 & 𝚰 & {\textbackslash}bfIota & Mathematical Bold Capital Iota \\
\hline
U+1D6B1 & 𝚱 & {\textbackslash}bfKappa & Mathematical Bold Capital Kappa \\
\hline
U+1D6B2 & 𝚲 & {\textbackslash}bfLambda & Mathematical Bold Capital Lamda \\
\hline
U+1D6B3 & 𝚳 & {\textbackslash}bfMu & Mathematical Bold Capital Mu \\
\hline
U+1D6B4 & 𝚴 & {\textbackslash}bfNu & Mathematical Bold Capital Nu \\
\hline
U+1D6B5 & 𝚵 & {\textbackslash}bfXi & Mathematical Bold Capital Xi \\
\hline
U+1D6B6 & 𝚶 & {\textbackslash}bfOmicron & Mathematical Bold Capital Omicron \\
\hline
U+1D6B7 & 𝚷 & {\textbackslash}bfPi & Mathematical Bold Capital Pi \\
\hline
U+1D6B8 & 𝚸 & {\textbackslash}bfRho & Mathematical Bold Capital Rho \\
\hline
U+1D6B9 & 𝚹 & {\textbackslash}bfvarTheta & Mathematical Bold Capital Theta Symbol \\
\hline
U+1D6BA & 𝚺 & {\textbackslash}bfSigma & Mathematical Bold Capital Sigma \\
\hline
U+1D6BB & 𝚻 & {\textbackslash}bfTau & Mathematical Bold Capital Tau \\
\hline
U+1D6BC & 𝚼 & {\textbackslash}bfUpsilon & Mathematical Bold Capital Upsilon \\
\hline
U+1D6BD & 𝚽 & {\textbackslash}bfPhi & Mathematical Bold Capital Phi \\
\hline
U+1D6BE & 𝚾 & {\textbackslash}bfChi & Mathematical Bold Capital Chi \\
\hline
U+1D6BF & 𝚿 & {\textbackslash}bfPsi & Mathematical Bold Capital Psi \\
\hline
U+1D6C0 & 𝛀 & {\textbackslash}bfOmega & Mathematical Bold Capital Omega \\
\hline
U+1D6C1 & 𝛁 & {\textbackslash}bfnabla & Mathematical Bold Nabla \\
\hline
U+1D6C2 & 𝛂 & {\textbackslash}bfalpha & Mathematical Bold Small Alpha \\
\hline
U+1D6C3 & 𝛃 & {\textbackslash}bfbeta & Mathematical Bold Small Beta \\
\hline
U+1D6C4 & 𝛄 & {\textbackslash}bfgamma & Mathematical Bold Small Gamma \\
\hline
U+1D6C5 & 𝛅 & {\textbackslash}bfdelta & Mathematical Bold Small Delta \\
\hline
U+1D6C6 & 𝛆 & {\textbackslash}bfepsilon & Mathematical Bold Small Epsilon \\
\hline
U+1D6C7 & 𝛇 & {\textbackslash}bfzeta & Mathematical Bold Small Zeta \\
\hline
U+1D6C8 & 𝛈 & {\textbackslash}bfeta & Mathematical Bold Small Eta \\
\hline
U+1D6C9 & 𝛉 & {\textbackslash}bftheta & Mathematical Bold Small Theta \\
\hline
U+1D6CA & 𝛊 & {\textbackslash}bfiota & Mathematical Bold Small Iota \\
\hline
U+1D6CB & 𝛋 & {\textbackslash}bfkappa & Mathematical Bold Small Kappa \\
\hline
U+1D6CC & 𝛌 & {\textbackslash}bflambda & Mathematical Bold Small Lamda \\
\hline
U+1D6CD & 𝛍 & {\textbackslash}bfmu & Mathematical Bold Small Mu \\
\hline
U+1D6CE & 𝛎 & {\textbackslash}bfnu & Mathematical Bold Small Nu \\
\hline
U+1D6CF & 𝛏 & {\textbackslash}bfxi & Mathematical Bold Small Xi \\
\hline
U+1D6D0 & 𝛐 & {\textbackslash}bfomicron & Mathematical Bold Small Omicron \\
\hline
U+1D6D1 & 𝛑 & {\textbackslash}bfpi & Mathematical Bold Small Pi \\
\hline
U+1D6D2 & 𝛒 & {\textbackslash}bfrho & Mathematical Bold Small Rho \\
\hline
U+1D6D3 & 𝛓 & {\textbackslash}bfvarsigma & Mathematical Bold Small Final Sigma \\
\hline
U+1D6D4 & 𝛔 & {\textbackslash}bfsigma & Mathematical Bold Small Sigma \\
\hline
U+1D6D5 & 𝛕 & {\textbackslash}bftau & Mathematical Bold Small Tau \\
\hline
U+1D6D6 & 𝛖 & {\textbackslash}bfupsilon & Mathematical Bold Small Upsilon \\
\hline
U+1D6D7 & 𝛗 & {\textbackslash}bfvarphi & Mathematical Bold Small Phi \\
\hline
U+1D6D8 & 𝛘 & {\textbackslash}bfchi & Mathematical Bold Small Chi \\
\hline
U+1D6D9 & 𝛙 & {\textbackslash}bfpsi & Mathematical Bold Small Psi \\
\hline
U+1D6DA & 𝛚 & {\textbackslash}bfomega & Mathematical Bold Small Omega \\
\hline
U+1D6DB & 𝛛 & {\textbackslash}bfpartial & Mathematical Bold Partial Differential \\
\hline
U+1D6DC & 𝛜 & {\textbackslash}bfvarepsilon & Mathematical Bold Epsilon Symbol \\
\hline
U+1D6DD & 𝛝 & {\textbackslash}bfvartheta & Mathematical Bold Theta Symbol \\
\hline
U+1D6DE & 𝛞 & {\textbackslash}bfvarkappa & Mathematical Bold Kappa Symbol \\
\hline
U+1D6DF & 𝛟 & {\textbackslash}bfphi & Mathematical Bold Phi Symbol \\
\hline
U+1D6E0 & 𝛠 & {\textbackslash}bfvarrho & Mathematical Bold Rho Symbol \\
\hline
U+1D6E1 & 𝛡 & {\textbackslash}bfvarpi & Mathematical Bold Pi Symbol \\
\hline
U+1D6E2 & 𝛢 & {\textbackslash}itAlpha & Mathematical Italic Capital Alpha \\
\hline
U+1D6E3 & 𝛣 & {\textbackslash}itBeta & Mathematical Italic Capital Beta \\
\hline
U+1D6E4 & 𝛤 & {\textbackslash}itGamma & Mathematical Italic Capital Gamma \\
\hline
U+1D6E5 & 𝛥 & {\textbackslash}itDelta & Mathematical Italic Capital Delta \\
\hline
U+1D6E6 & 𝛦 & {\textbackslash}itEpsilon & Mathematical Italic Capital Epsilon \\
\hline
U+1D6E7 & 𝛧 & {\textbackslash}itZeta & Mathematical Italic Capital Zeta \\
\hline
U+1D6E8 & 𝛨 & {\textbackslash}itEta & Mathematical Italic Capital Eta \\
\hline
U+1D6E9 & 𝛩 & {\textbackslash}itTheta & Mathematical Italic Capital Theta \\
\hline
U+1D6EA & 𝛪 & {\textbackslash}itIota & Mathematical Italic Capital Iota \\
\hline
U+1D6EB & 𝛫 & {\textbackslash}itKappa & Mathematical Italic Capital Kappa \\
\hline
U+1D6EC & 𝛬 & {\textbackslash}itLambda & Mathematical Italic Capital Lamda \\
\hline
U+1D6ED & 𝛭 & {\textbackslash}itMu & Mathematical Italic Capital Mu \\
\hline
U+1D6EE & 𝛮 & {\textbackslash}itNu & Mathematical Italic Capital Nu \\
\hline
U+1D6EF & 𝛯 & {\textbackslash}itXi & Mathematical Italic Capital Xi \\
\hline
U+1D6F0 & 𝛰 & {\textbackslash}itOmicron & Mathematical Italic Capital Omicron \\
\hline
U+1D6F1 & 𝛱 & {\textbackslash}itPi & Mathematical Italic Capital Pi \\
\hline
U+1D6F2 & 𝛲 & {\textbackslash}itRho & Mathematical Italic Capital Rho \\
\hline
U+1D6F3 & 𝛳 & {\textbackslash}itvarTheta & Mathematical Italic Capital Theta Symbol \\
\hline
U+1D6F4 & 𝛴 & {\textbackslash}itSigma & Mathematical Italic Capital Sigma \\
\hline
U+1D6F5 & 𝛵 & {\textbackslash}itTau & Mathematical Italic Capital Tau \\
\hline
U+1D6F6 & 𝛶 & {\textbackslash}itUpsilon & Mathematical Italic Capital Upsilon \\
\hline
U+1D6F7 & 𝛷 & {\textbackslash}itPhi & Mathematical Italic Capital Phi \\
\hline
U+1D6F8 & 𝛸 & {\textbackslash}itChi & Mathematical Italic Capital Chi \\
\hline
U+1D6F9 & 𝛹 & {\textbackslash}itPsi & Mathematical Italic Capital Psi \\
\hline
U+1D6FA & 𝛺 & {\textbackslash}itOmega & Mathematical Italic Capital Omega \\
\hline
U+1D6FB & 𝛻 & {\textbackslash}itnabla & Mathematical Italic Nabla \\
\hline
U+1D6FC & 𝛼 & {\textbackslash}italpha & Mathematical Italic Small Alpha \\
\hline
U+1D6FD & 𝛽 & {\textbackslash}itbeta & Mathematical Italic Small Beta \\
\hline
U+1D6FE & 𝛾 & {\textbackslash}itgamma & Mathematical Italic Small Gamma \\
\hline
U+1D6FF & 𝛿 & {\textbackslash}itdelta & Mathematical Italic Small Delta \\
\hline
U+1D700 & 𝜀 & {\textbackslash}itepsilon & Mathematical Italic Small Epsilon \\
\hline
U+1D701 & 𝜁 & {\textbackslash}itzeta & Mathematical Italic Small Zeta \\
\hline
U+1D702 & 𝜂 & {\textbackslash}iteta & Mathematical Italic Small Eta \\
\hline
U+1D703 & 𝜃 & {\textbackslash}ittheta & Mathematical Italic Small Theta \\
\hline
U+1D704 & 𝜄 & {\textbackslash}itiota & Mathematical Italic Small Iota \\
\hline
U+1D705 & 𝜅 & {\textbackslash}itkappa & Mathematical Italic Small Kappa \\
\hline
U+1D706 & 𝜆 & {\textbackslash}itlambda & Mathematical Italic Small Lamda \\
\hline
U+1D707 & 𝜇 & {\textbackslash}itmu & Mathematical Italic Small Mu \\
\hline
U+1D708 & 𝜈 & {\textbackslash}itnu & Mathematical Italic Small Nu \\
\hline
U+1D709 & 𝜉 & {\textbackslash}itxi & Mathematical Italic Small Xi \\
\hline
U+1D70A & 𝜊 & {\textbackslash}itomicron & Mathematical Italic Small Omicron \\
\hline
U+1D70B & 𝜋 & {\textbackslash}itpi & Mathematical Italic Small Pi \\
\hline
U+1D70C & 𝜌 & {\textbackslash}itrho & Mathematical Italic Small Rho \\
\hline
U+1D70D & 𝜍 & {\textbackslash}itvarsigma & Mathematical Italic Small Final Sigma \\
\hline
U+1D70E & 𝜎 & {\textbackslash}itsigma & Mathematical Italic Small Sigma \\
\hline
U+1D70F & 𝜏 & {\textbackslash}ittau & Mathematical Italic Small Tau \\
\hline
U+1D710 & 𝜐 & {\textbackslash}itupsilon & Mathematical Italic Small Upsilon \\
\hline
U+1D711 & 𝜑 & {\textbackslash}itphi & Mathematical Italic Small Phi \\
\hline
U+1D712 & 𝜒 & {\textbackslash}itchi & Mathematical Italic Small Chi \\
\hline
U+1D713 & 𝜓 & {\textbackslash}itpsi & Mathematical Italic Small Psi \\
\hline
U+1D714 & 𝜔 & {\textbackslash}itomega & Mathematical Italic Small Omega \\
\hline
U+1D715 & 𝜕 & {\textbackslash}itpartial & Mathematical Italic Partial Differential \\
\hline
U+1D716 & 𝜖 & {\textbackslash}itvarepsilon & Mathematical Italic Epsilon Symbol \\
\hline
U+1D717 & 𝜗 & {\textbackslash}itvartheta & Mathematical Italic Theta Symbol \\
\hline
U+1D718 & 𝜘 & {\textbackslash}itvarkappa & Mathematical Italic Kappa Symbol \\
\hline
U+1D719 & 𝜙 & {\textbackslash}itvarphi & Mathematical Italic Phi Symbol \\
\hline
U+1D71A & 𝜚 & {\textbackslash}itvarrho & Mathematical Italic Rho Symbol \\
\hline
U+1D71B & 𝜛 & {\textbackslash}itvarpi & Mathematical Italic Pi Symbol \\
\hline
U+1D71C & 𝜜 & {\textbackslash}biAlpha & Mathematical Bold Italic Capital Alpha \\
\hline
U+1D71D & 𝜝 & {\textbackslash}biBeta & Mathematical Bold Italic Capital Beta \\
\hline
U+1D71E & 𝜞 & {\textbackslash}biGamma & Mathematical Bold Italic Capital Gamma \\
\hline
U+1D71F & 𝜟 & {\textbackslash}biDelta & Mathematical Bold Italic Capital Delta \\
\hline
U+1D720 & 𝜠 & {\textbackslash}biEpsilon & Mathematical Bold Italic Capital Epsilon \\
\hline
U+1D721 & 𝜡 & {\textbackslash}biZeta & Mathematical Bold Italic Capital Zeta \\
\hline
U+1D722 & 𝜢 & {\textbackslash}biEta & Mathematical Bold Italic Capital Eta \\
\hline
U+1D723 & 𝜣 & {\textbackslash}biTheta & Mathematical Bold Italic Capital Theta \\
\hline
U+1D724 & 𝜤 & {\textbackslash}biIota & Mathematical Bold Italic Capital Iota \\
\hline
U+1D725 & 𝜥 & {\textbackslash}biKappa & Mathematical Bold Italic Capital Kappa \\
\hline
U+1D726 & 𝜦 & {\textbackslash}biLambda & Mathematical Bold Italic Capital Lamda \\
\hline
U+1D727 & 𝜧 & {\textbackslash}biMu & Mathematical Bold Italic Capital Mu \\
\hline
U+1D728 & 𝜨 & {\textbackslash}biNu & Mathematical Bold Italic Capital Nu \\
\hline
U+1D729 & 𝜩 & {\textbackslash}biXi & Mathematical Bold Italic Capital Xi \\
\hline
U+1D72A & 𝜪 & {\textbackslash}biOmicron & Mathematical Bold Italic Capital Omicron \\
\hline
U+1D72B & 𝜫 & {\textbackslash}biPi & Mathematical Bold Italic Capital Pi \\
\hline
U+1D72C & 𝜬 & {\textbackslash}biRho & Mathematical Bold Italic Capital Rho \\
\hline
U+1D72D & 𝜭 & {\textbackslash}bivarTheta & Mathematical Bold Italic Capital Theta Symbol \\
\hline
U+1D72E & 𝜮 & {\textbackslash}biSigma & Mathematical Bold Italic Capital Sigma \\
\hline
U+1D72F & 𝜯 & {\textbackslash}biTau & Mathematical Bold Italic Capital Tau \\
\hline
U+1D730 & 𝜰 & {\textbackslash}biUpsilon & Mathematical Bold Italic Capital Upsilon \\
\hline
U+1D731 & 𝜱 & {\textbackslash}biPhi & Mathematical Bold Italic Capital Phi \\
\hline
U+1D732 & 𝜲 & {\textbackslash}biChi & Mathematical Bold Italic Capital Chi \\
\hline
U+1D733 & 𝜳 & {\textbackslash}biPsi & Mathematical Bold Italic Capital Psi \\
\hline
U+1D734 & 𝜴 & {\textbackslash}biOmega & Mathematical Bold Italic Capital Omega \\
\hline
U+1D735 & 𝜵 & {\textbackslash}binabla & Mathematical Bold Italic Nabla \\
\hline
U+1D736 & 𝜶 & {\textbackslash}bialpha & Mathematical Bold Italic Small Alpha \\
\hline
U+1D737 & 𝜷 & {\textbackslash}bibeta & Mathematical Bold Italic Small Beta \\
\hline
U+1D738 & 𝜸 & {\textbackslash}bigamma & Mathematical Bold Italic Small Gamma \\
\hline
U+1D739 & 𝜹 & {\textbackslash}bidelta & Mathematical Bold Italic Small Delta \\
\hline
U+1D73A & 𝜺 & {\textbackslash}biepsilon & Mathematical Bold Italic Small Epsilon \\
\hline
U+1D73B & 𝜻 & {\textbackslash}bizeta & Mathematical Bold Italic Small Zeta \\
\hline
U+1D73C & 𝜼 & {\textbackslash}bieta & Mathematical Bold Italic Small Eta \\
\hline
U+1D73D & 𝜽 & {\textbackslash}bitheta & Mathematical Bold Italic Small Theta \\
\hline
U+1D73E & 𝜾 & {\textbackslash}biiota & Mathematical Bold Italic Small Iota \\
\hline
U+1D73F & 𝜿 & {\textbackslash}bikappa & Mathematical Bold Italic Small Kappa \\
\hline
U+1D740 & 𝝀 & {\textbackslash}bilambda & Mathematical Bold Italic Small Lamda \\
\hline
U+1D741 & 𝝁 & {\textbackslash}bimu & Mathematical Bold Italic Small Mu \\
\hline
U+1D742 & 𝝂 & {\textbackslash}binu & Mathematical Bold Italic Small Nu \\
\hline
U+1D743 & 𝝃 & {\textbackslash}bixi & Mathematical Bold Italic Small Xi \\
\hline
U+1D744 & 𝝄 & {\textbackslash}biomicron & Mathematical Bold Italic Small Omicron \\
\hline
U+1D745 & 𝝅 & {\textbackslash}bipi & Mathematical Bold Italic Small Pi \\
\hline
U+1D746 & 𝝆 & {\textbackslash}birho & Mathematical Bold Italic Small Rho \\
\hline
U+1D747 & 𝝇 & {\textbackslash}bivarsigma & Mathematical Bold Italic Small Final Sigma \\
\hline
U+1D748 & 𝝈 & {\textbackslash}bisigma & Mathematical Bold Italic Small Sigma \\
\hline
U+1D749 & 𝝉 & {\textbackslash}bitau & Mathematical Bold Italic Small Tau \\
\hline
U+1D74A & 𝝊 & {\textbackslash}biupsilon & Mathematical Bold Italic Small Upsilon \\
\hline
U+1D74B & 𝝋 & {\textbackslash}biphi & Mathematical Bold Italic Small Phi \\
\hline
U+1D74C & 𝝌 & {\textbackslash}bichi & Mathematical Bold Italic Small Chi \\
\hline
U+1D74D & 𝝍 & {\textbackslash}bipsi & Mathematical Bold Italic Small Psi \\
\hline
U+1D74E & 𝝎 & {\textbackslash}biomega & Mathematical Bold Italic Small Omega \\
\hline
U+1D74F & 𝝏 & {\textbackslash}bipartial & Mathematical Bold Italic Partial Differential \\
\hline
U+1D750 & 𝝐 & {\textbackslash}bivarepsilon & Mathematical Bold Italic Epsilon Symbol \\
\hline
U+1D751 & 𝝑 & {\textbackslash}bivartheta & Mathematical Bold Italic Theta Symbol \\
\hline
U+1D752 & 𝝒 & {\textbackslash}bivarkappa & Mathematical Bold Italic Kappa Symbol \\
\hline
U+1D753 & 𝝓 & {\textbackslash}bivarphi & Mathematical Bold Italic Phi Symbol \\
\hline
U+1D754 & 𝝔 & {\textbackslash}bivarrho & Mathematical Bold Italic Rho Symbol \\
\hline
U+1D755 & 𝝕 & {\textbackslash}bivarpi & Mathematical Bold Italic Pi Symbol \\
\hline
U+1D756 & 𝝖 & {\textbackslash}bsansAlpha & Mathematical Sans-Serif Bold Capital Alpha \\
\hline
U+1D757 & 𝝗 & {\textbackslash}bsansBeta & Mathematical Sans-Serif Bold Capital Beta \\
\hline
U+1D758 & 𝝘 & {\textbackslash}bsansGamma & Mathematical Sans-Serif Bold Capital Gamma \\
\hline
U+1D759 & 𝝙 & {\textbackslash}bsansDelta & Mathematical Sans-Serif Bold Capital Delta \\
\hline
U+1D75A & 𝝚 & {\textbackslash}bsansEpsilon & Mathematical Sans-Serif Bold Capital Epsilon \\
\hline
U+1D75B & 𝝛 & {\textbackslash}bsansZeta & Mathematical Sans-Serif Bold Capital Zeta \\
\hline
U+1D75C & 𝝜 & {\textbackslash}bsansEta & Mathematical Sans-Serif Bold Capital Eta \\
\hline
U+1D75D & 𝝝 & {\textbackslash}bsansTheta & Mathematical Sans-Serif Bold Capital Theta \\
\hline
U+1D75E & 𝝞 & {\textbackslash}bsansIota & Mathematical Sans-Serif Bold Capital Iota \\
\hline
U+1D75F & 𝝟 & {\textbackslash}bsansKappa & Mathematical Sans-Serif Bold Capital Kappa \\
\hline
U+1D760 & 𝝠 & {\textbackslash}bsansLambda & Mathematical Sans-Serif Bold Capital Lamda \\
\hline
U+1D761 & 𝝡 & {\textbackslash}bsansMu & Mathematical Sans-Serif Bold Capital Mu \\
\hline
U+1D762 & 𝝢 & {\textbackslash}bsansNu & Mathematical Sans-Serif Bold Capital Nu \\
\hline
U+1D763 & 𝝣 & {\textbackslash}bsansXi & Mathematical Sans-Serif Bold Capital Xi \\
\hline
U+1D764 & 𝝤 & {\textbackslash}bsansOmicron & Mathematical Sans-Serif Bold Capital Omicron \\
\hline
U+1D765 & 𝝥 & {\textbackslash}bsansPi & Mathematical Sans-Serif Bold Capital Pi \\
\hline
U+1D766 & 𝝦 & {\textbackslash}bsansRho & Mathematical Sans-Serif Bold Capital Rho \\
\hline
U+1D767 & 𝝧 & {\textbackslash}bsansvarTheta & Mathematical Sans-Serif Bold Capital Theta Symbol \\
\hline
U+1D768 & 𝝨 & {\textbackslash}bsansSigma & Mathematical Sans-Serif Bold Capital Sigma \\
\hline
U+1D769 & 𝝩 & {\textbackslash}bsansTau & Mathematical Sans-Serif Bold Capital Tau \\
\hline
U+1D76A & 𝝪 & {\textbackslash}bsansUpsilon & Mathematical Sans-Serif Bold Capital Upsilon \\
\hline
U+1D76B & 𝝫 & {\textbackslash}bsansPhi & Mathematical Sans-Serif Bold Capital Phi \\
\hline
U+1D76C & 𝝬 & {\textbackslash}bsansChi & Mathematical Sans-Serif Bold Capital Chi \\
\hline
U+1D76D & 𝝭 & {\textbackslash}bsansPsi & Mathematical Sans-Serif Bold Capital Psi \\
\hline
U+1D76E & 𝝮 & {\textbackslash}bsansOmega & Mathematical Sans-Serif Bold Capital Omega \\
\hline
U+1D76F & 𝝯 & {\textbackslash}bsansnabla & Mathematical Sans-Serif Bold Nabla \\
\hline
U+1D770 & 𝝰 & {\textbackslash}bsansalpha & Mathematical Sans-Serif Bold Small Alpha \\
\hline
U+1D771 & 𝝱 & {\textbackslash}bsansbeta & Mathematical Sans-Serif Bold Small Beta \\
\hline
U+1D772 & 𝝲 & {\textbackslash}bsansgamma & Mathematical Sans-Serif Bold Small Gamma \\
\hline
U+1D773 & 𝝳 & {\textbackslash}bsansdelta & Mathematical Sans-Serif Bold Small Delta \\
\hline
U+1D774 & 𝝴 & {\textbackslash}bsansepsilon & Mathematical Sans-Serif Bold Small Epsilon \\
\hline
U+1D775 & 𝝵 & {\textbackslash}bsanszeta & Mathematical Sans-Serif Bold Small Zeta \\
\hline
U+1D776 & 𝝶 & {\textbackslash}bsanseta & Mathematical Sans-Serif Bold Small Eta \\
\hline
U+1D777 & 𝝷 & {\textbackslash}bsanstheta & Mathematical Sans-Serif Bold Small Theta \\
\hline
U+1D778 & 𝝸 & {\textbackslash}bsansiota & Mathematical Sans-Serif Bold Small Iota \\
\hline
U+1D779 & 𝝹 & {\textbackslash}bsanskappa & Mathematical Sans-Serif Bold Small Kappa \\
\hline
U+1D77A & 𝝺 & {\textbackslash}bsanslambda & Mathematical Sans-Serif Bold Small Lamda \\
\hline
U+1D77B & 𝝻 & {\textbackslash}bsansmu & Mathematical Sans-Serif Bold Small Mu \\
\hline
U+1D77C & 𝝼 & {\textbackslash}bsansnu & Mathematical Sans-Serif Bold Small Nu \\
\hline
U+1D77D & 𝝽 & {\textbackslash}bsansxi & Mathematical Sans-Serif Bold Small Xi \\
\hline
U+1D77E & 𝝾 & {\textbackslash}bsansomicron & Mathematical Sans-Serif Bold Small Omicron \\
\hline
U+1D77F & 𝝿 & {\textbackslash}bsanspi & Mathematical Sans-Serif Bold Small Pi \\
\hline
U+1D780 & 𝞀 & {\textbackslash}bsansrho & Mathematical Sans-Serif Bold Small Rho \\
\hline
U+1D781 & 𝞁 & {\textbackslash}bsansvarsigma & Mathematical Sans-Serif Bold Small Final Sigma \\
\hline
U+1D782 & 𝞂 & {\textbackslash}bsanssigma & Mathematical Sans-Serif Bold Small Sigma \\
\hline
U+1D783 & 𝞃 & {\textbackslash}bsanstau & Mathematical Sans-Serif Bold Small Tau \\
\hline
U+1D784 & 𝞄 & {\textbackslash}bsansupsilon & Mathematical Sans-Serif Bold Small Upsilon \\
\hline
U+1D785 & 𝞅 & {\textbackslash}bsansphi & Mathematical Sans-Serif Bold Small Phi \\
\hline
U+1D786 & 𝞆 & {\textbackslash}bsanschi & Mathematical Sans-Serif Bold Small Chi \\
\hline
U+1D787 & 𝞇 & {\textbackslash}bsanspsi & Mathematical Sans-Serif Bold Small Psi \\
\hline
U+1D788 & 𝞈 & {\textbackslash}bsansomega & Mathematical Sans-Serif Bold Small Omega \\
\hline
U+1D789 & 𝞉 & {\textbackslash}bsanspartial & Mathematical Sans-Serif Bold Partial Differential \\
\hline
U+1D78A & 𝞊 & {\textbackslash}bsansvarepsilon & Mathematical Sans-Serif Bold Epsilon Symbol \\
\hline
U+1D78B & 𝞋 & {\textbackslash}bsansvartheta & Mathematical Sans-Serif Bold Theta Symbol \\
\hline
U+1D78C & 𝞌 & {\textbackslash}bsansvarkappa & Mathematical Sans-Serif Bold Kappa Symbol \\
\hline
U+1D78D & 𝞍 & {\textbackslash}bsansvarphi & Mathematical Sans-Serif Bold Phi Symbol \\
\hline
U+1D78E & 𝞎 & {\textbackslash}bsansvarrho & Mathematical Sans-Serif Bold Rho Symbol \\
\hline
U+1D78F & 𝞏 & {\textbackslash}bsansvarpi & Mathematical Sans-Serif Bold Pi Symbol \\
\hline
U+1D790 & 𝞐 & {\textbackslash}bisansAlpha & Mathematical Sans-Serif Bold Italic Capital Alpha \\
\hline
U+1D791 & 𝞑 & {\textbackslash}bisansBeta & Mathematical Sans-Serif Bold Italic Capital Beta \\
\hline
U+1D792 & 𝞒 & {\textbackslash}bisansGamma & Mathematical Sans-Serif Bold Italic Capital Gamma \\
\hline
U+1D793 & 𝞓 & {\textbackslash}bisansDelta & Mathematical Sans-Serif Bold Italic Capital Delta \\
\hline
U+1D794 & 𝞔 & {\textbackslash}bisansEpsilon & Mathematical Sans-Serif Bold Italic Capital Epsilon \\
\hline
U+1D795 & 𝞕 & {\textbackslash}bisansZeta & Mathematical Sans-Serif Bold Italic Capital Zeta \\
\hline
U+1D796 & 𝞖 & {\textbackslash}bisansEta & Mathematical Sans-Serif Bold Italic Capital Eta \\
\hline
U+1D797 & 𝞗 & {\textbackslash}bisansTheta & Mathematical Sans-Serif Bold Italic Capital Theta \\
\hline
U+1D798 & 𝞘 & {\textbackslash}bisansIota & Mathematical Sans-Serif Bold Italic Capital Iota \\
\hline
U+1D799 & 𝞙 & {\textbackslash}bisansKappa & Mathematical Sans-Serif Bold Italic Capital Kappa \\
\hline
U+1D79A & 𝞚 & {\textbackslash}bisansLambda & Mathematical Sans-Serif Bold Italic Capital Lamda \\
\hline
U+1D79B & 𝞛 & {\textbackslash}bisansMu & Mathematical Sans-Serif Bold Italic Capital Mu \\
\hline
U+1D79C & 𝞜 & {\textbackslash}bisansNu & Mathematical Sans-Serif Bold Italic Capital Nu \\
\hline
U+1D79D & 𝞝 & {\textbackslash}bisansXi & Mathematical Sans-Serif Bold Italic Capital Xi \\
\hline
U+1D79E & 𝞞 & {\textbackslash}bisansOmicron & Mathematical Sans-Serif Bold Italic Capital Omicron \\
\hline
U+1D79F & 𝞟 & {\textbackslash}bisansPi & Mathematical Sans-Serif Bold Italic Capital Pi \\
\hline
U+1D7A0 & 𝞠 & {\textbackslash}bisansRho & Mathematical Sans-Serif Bold Italic Capital Rho \\
\hline
U+1D7A1 & 𝞡 & {\textbackslash}bisansvarTheta & Mathematical Sans-Serif Bold Italic Capital Theta Symbol \\
\hline
U+1D7A2 & 𝞢 & {\textbackslash}bisansSigma & Mathematical Sans-Serif Bold Italic Capital Sigma \\
\hline
U+1D7A3 & 𝞣 & {\textbackslash}bisansTau & Mathematical Sans-Serif Bold Italic Capital Tau \\
\hline
U+1D7A4 & 𝞤 & {\textbackslash}bisansUpsilon & Mathematical Sans-Serif Bold Italic Capital Upsilon \\
\hline
U+1D7A5 & 𝞥 & {\textbackslash}bisansPhi & Mathematical Sans-Serif Bold Italic Capital Phi \\
\hline
U+1D7A6 & 𝞦 & {\textbackslash}bisansChi & Mathematical Sans-Serif Bold Italic Capital Chi \\
\hline
U+1D7A7 & 𝞧 & {\textbackslash}bisansPsi & Mathematical Sans-Serif Bold Italic Capital Psi \\
\hline
U+1D7A8 & 𝞨 & {\textbackslash}bisansOmega & Mathematical Sans-Serif Bold Italic Capital Omega \\
\hline
U+1D7A9 & 𝞩 & {\textbackslash}bisansnabla & Mathematical Sans-Serif Bold Italic Nabla \\
\hline
U+1D7AA & 𝞪 & {\textbackslash}bisansalpha & Mathematical Sans-Serif Bold Italic Small Alpha \\
\hline
U+1D7AB & 𝞫 & {\textbackslash}bisansbeta & Mathematical Sans-Serif Bold Italic Small Beta \\
\hline
U+1D7AC & 𝞬 & {\textbackslash}bisansgamma & Mathematical Sans-Serif Bold Italic Small Gamma \\
\hline
U+1D7AD & 𝞭 & {\textbackslash}bisansdelta & Mathematical Sans-Serif Bold Italic Small Delta \\
\hline
U+1D7AE & 𝞮 & {\textbackslash}bisansepsilon & Mathematical Sans-Serif Bold Italic Small Epsilon \\
\hline
U+1D7AF & 𝞯 & {\textbackslash}bisanszeta & Mathematical Sans-Serif Bold Italic Small Zeta \\
\hline
U+1D7B0 & 𝞰 & {\textbackslash}bisanseta & Mathematical Sans-Serif Bold Italic Small Eta \\
\hline
U+1D7B1 & 𝞱 & {\textbackslash}bisanstheta & Mathematical Sans-Serif Bold Italic Small Theta \\
\hline
U+1D7B2 & 𝞲 & {\textbackslash}bisansiota & Mathematical Sans-Serif Bold Italic Small Iota \\
\hline
U+1D7B3 & 𝞳 & {\textbackslash}bisanskappa & Mathematical Sans-Serif Bold Italic Small Kappa \\
\hline
U+1D7B4 & 𝞴 & {\textbackslash}bisanslambda & Mathematical Sans-Serif Bold Italic Small Lamda \\
\hline
U+1D7B5 & 𝞵 & {\textbackslash}bisansmu & Mathematical Sans-Serif Bold Italic Small Mu \\
\hline
U+1D7B6 & 𝞶 & {\textbackslash}bisansnu & Mathematical Sans-Serif Bold Italic Small Nu \\
\hline
U+1D7B7 & 𝞷 & {\textbackslash}bisansxi & Mathematical Sans-Serif Bold Italic Small Xi \\
\hline
U+1D7B8 & 𝞸 & {\textbackslash}bisansomicron & Mathematical Sans-Serif Bold Italic Small Omicron \\
\hline
U+1D7B9 & 𝞹 & {\textbackslash}bisanspi & Mathematical Sans-Serif Bold Italic Small Pi \\
\hline
U+1D7BA & 𝞺 & {\textbackslash}bisansrho & Mathematical Sans-Serif Bold Italic Small Rho \\
\hline
U+1D7BB & 𝞻 & {\textbackslash}bisansvarsigma & Mathematical Sans-Serif Bold Italic Small Final Sigma \\
\hline
U+1D7BC & 𝞼 & {\textbackslash}bisanssigma & Mathematical Sans-Serif Bold Italic Small Sigma \\
\hline
U+1D7BD & 𝞽 & {\textbackslash}bisanstau & Mathematical Sans-Serif Bold Italic Small Tau \\
\hline
U+1D7BE & 𝞾 & {\textbackslash}bisansupsilon & Mathematical Sans-Serif Bold Italic Small Upsilon \\
\hline
U+1D7BF & 𝞿 & {\textbackslash}bisansphi & Mathematical Sans-Serif Bold Italic Small Phi \\
\hline
U+1D7C0 & 𝟀 & {\textbackslash}bisanschi & Mathematical Sans-Serif Bold Italic Small Chi \\
\hline
U+1D7C1 & 𝟁 & {\textbackslash}bisanspsi & Mathematical Sans-Serif Bold Italic Small Psi \\
\hline
U+1D7C2 & 𝟂 & {\textbackslash}bisansomega & Mathematical Sans-Serif Bold Italic Small Omega \\
\hline
U+1D7C3 & 𝟃 & {\textbackslash}bisanspartial & Mathematical Sans-Serif Bold Italic Partial Differential \\
\hline
U+1D7C4 & 𝟄 & {\textbackslash}bisansvarepsilon & Mathematical Sans-Serif Bold Italic Epsilon Symbol \\
\hline
U+1D7C5 & 𝟅 & {\textbackslash}bisansvartheta & Mathematical Sans-Serif Bold Italic Theta Symbol \\
\hline
U+1D7C6 & 𝟆 & {\textbackslash}bisansvarkappa & Mathematical Sans-Serif Bold Italic Kappa Symbol \\
\hline
U+1D7C7 & 𝟇 & {\textbackslash}bisansvarphi & Mathematical Sans-Serif Bold Italic Phi Symbol \\
\hline
U+1D7C8 & 𝟈 & {\textbackslash}bisansvarrho & Mathematical Sans-Serif Bold Italic Rho Symbol \\
\hline
U+1D7C9 & 𝟉 & {\textbackslash}bisansvarpi & Mathematical Sans-Serif Bold Italic Pi Symbol \\
\hline
U+1D7CA & 𝟊 & {\textbackslash}bfDigamma & Mathematical Bold Capital Digamma \\
\hline
U+1D7CB & 𝟋 & {\textbackslash}bfdigamma & Mathematical Bold Small Digamma \\
\hline
U+1D7CE & 𝟎 & {\textbackslash}bfzero & Mathematical Bold Digit Zero \\
\hline
U+1D7CF & 𝟏 & {\textbackslash}bfone & Mathematical Bold Digit One \\
\hline
U+1D7D0 & 𝟐 & {\textbackslash}bftwo & Mathematical Bold Digit Two \\
\hline
U+1D7D1 & 𝟑 & {\textbackslash}bfthree & Mathematical Bold Digit Three \\
\hline
U+1D7D2 & 𝟒 & {\textbackslash}bffour & Mathematical Bold Digit Four \\
\hline
U+1D7D3 & 𝟓 & {\textbackslash}bffive & Mathematical Bold Digit Five \\
\hline
U+1D7D4 & 𝟔 & {\textbackslash}bfsix & Mathematical Bold Digit Six \\
\hline
U+1D7D5 & 𝟕 & {\textbackslash}bfseven & Mathematical Bold Digit Seven \\
\hline
U+1D7D6 & 𝟖 & {\textbackslash}bfeight & Mathematical Bold Digit Eight \\
\hline
U+1D7D7 & 𝟗 & {\textbackslash}bfnine & Mathematical Bold Digit Nine \\
\hline
U+1D7D8 & 𝟘 & {\textbackslash}bbzero & Mathematical Double-Struck Digit Zero \\
\hline
U+1D7D9 & 𝟙 & {\textbackslash}bbone & Mathematical Double-Struck Digit One \\
\hline
U+1D7DA & 𝟚 & {\textbackslash}bbtwo & Mathematical Double-Struck Digit Two \\
\hline
U+1D7DB & 𝟛 & {\textbackslash}bbthree & Mathematical Double-Struck Digit Three \\
\hline
U+1D7DC & 𝟜 & {\textbackslash}bbfour & Mathematical Double-Struck Digit Four \\
\hline
U+1D7DD & 𝟝 & {\textbackslash}bbfive & Mathematical Double-Struck Digit Five \\
\hline
U+1D7DE & 𝟞 & {\textbackslash}bbsix & Mathematical Double-Struck Digit Six \\
\hline
U+1D7DF & 𝟟 & {\textbackslash}bbseven & Mathematical Double-Struck Digit Seven \\
\hline
U+1D7E0 & 𝟠 & {\textbackslash}bbeight & Mathematical Double-Struck Digit Eight \\
\hline
U+1D7E1 & 𝟡 & {\textbackslash}bbnine & Mathematical Double-Struck Digit Nine \\
\hline
U+1D7E2 & 𝟢 & {\textbackslash}sanszero & Mathematical Sans-Serif Digit Zero \\
\hline
U+1D7E3 & 𝟣 & {\textbackslash}sansone & Mathematical Sans-Serif Digit One \\
\hline
U+1D7E4 & 𝟤 & {\textbackslash}sanstwo & Mathematical Sans-Serif Digit Two \\
\hline
U+1D7E5 & 𝟥 & {\textbackslash}sansthree & Mathematical Sans-Serif Digit Three \\
\hline
U+1D7E6 & 𝟦 & {\textbackslash}sansfour & Mathematical Sans-Serif Digit Four \\
\hline
U+1D7E7 & 𝟧 & {\textbackslash}sansfive & Mathematical Sans-Serif Digit Five \\
\hline
U+1D7E8 & 𝟨 & {\textbackslash}sanssix & Mathematical Sans-Serif Digit Six \\
\hline
U+1D7E9 & 𝟩 & {\textbackslash}sansseven & Mathematical Sans-Serif Digit Seven \\
\hline
U+1D7EA & 𝟪 & {\textbackslash}sanseight & Mathematical Sans-Serif Digit Eight \\
\hline
U+1D7EB & 𝟫 & {\textbackslash}sansnine & Mathematical Sans-Serif Digit Nine \\
\hline
U+1D7EC & 𝟬 & {\textbackslash}bsanszero & Mathematical Sans-Serif Bold Digit Zero \\
\hline
U+1D7ED & 𝟭 & {\textbackslash}bsansone & Mathematical Sans-Serif Bold Digit One \\
\hline
U+1D7EE & 𝟮 & {\textbackslash}bsanstwo & Mathematical Sans-Serif Bold Digit Two \\
\hline
U+1D7EF & 𝟯 & {\textbackslash}bsansthree & Mathematical Sans-Serif Bold Digit Three \\
\hline
U+1D7F0 & 𝟰 & {\textbackslash}bsansfour & Mathematical Sans-Serif Bold Digit Four \\
\hline
U+1D7F1 & 𝟱 & {\textbackslash}bsansfive & Mathematical Sans-Serif Bold Digit Five \\
\hline
U+1D7F2 & 𝟲 & {\textbackslash}bsanssix & Mathematical Sans-Serif Bold Digit Six \\
\hline
U+1D7F3 & 𝟳 & {\textbackslash}bsansseven & Mathematical Sans-Serif Bold Digit Seven \\
\hline
U+1D7F4 & 𝟴 & {\textbackslash}bsanseight & Mathematical Sans-Serif Bold Digit Eight \\
\hline
U+1D7F5 & 𝟵 & {\textbackslash}bsansnine & Mathematical Sans-Serif Bold Digit Nine \\
\hline
U+1D7F6 & 𝟶 & {\textbackslash}ttzero & Mathematical Monospace Digit Zero \\
\hline
U+1D7F7 & 𝟷 & {\textbackslash}ttone & Mathematical Monospace Digit One \\
\hline
U+1D7F8 & 𝟸 & {\textbackslash}tttwo & Mathematical Monospace Digit Two \\
\hline
U+1D7F9 & 𝟹 & {\textbackslash}ttthree & Mathematical Monospace Digit Three \\
\hline
U+1D7FA & 𝟺 & {\textbackslash}ttfour & Mathematical Monospace Digit Four \\
\hline
U+1D7FB & 𝟻 & {\textbackslash}ttfive & Mathematical Monospace Digit Five \\
\hline
U+1D7FC & 𝟼 & {\textbackslash}ttsix & Mathematical Monospace Digit Six \\
\hline
U+1D7FD & 𝟽 & {\textbackslash}ttseven & Mathematical Monospace Digit Seven \\
\hline
U+1D7FE & 𝟾 & {\textbackslash}tteight & Mathematical Monospace Digit Eight \\
\hline
U+1D7FF & 𝟿 & {\textbackslash}ttnine & Mathematical Monospace Digit Nine \\
\hline
U+1F004 & 🀄 & {\textbackslash}:mahjong: & Mahjong Tile Red Dragon \\
\hline
U+1F0CF & 🃏 & {\textbackslash}:black\_joker: & Playing Card Black Joker \\
\hline
U+1F170 & 🅰 & {\textbackslash}:a: & Negative Squared Latin Capital Letter A \\
\hline
U+1F171 & 🅱 & {\textbackslash}:b: & Negative Squared Latin Capital Letter B \\
\hline
U+1F17E & 🅾 & {\textbackslash}:o2: & Negative Squared Latin Capital Letter O \\
\hline
U+1F17F & 🅿 & {\textbackslash}:parking: & Negative Squared Latin Capital Letter P \\
\hline
U+1F18E & 🆎 & {\textbackslash}:ab: & Negative Squared Ab \\
\hline
U+1F191 & 🆑 & {\textbackslash}:cl: & Squared Cl \\
\hline
U+1F192 & 🆒 & {\textbackslash}:cool: & Squared Cool \\
\hline
U+1F193 & 🆓 & {\textbackslash}:free: & Squared Free \\
\hline
U+1F194 & 🆔 & {\textbackslash}:id: & Squared Id \\
\hline
U+1F195 & 🆕 & {\textbackslash}:new: & Squared New \\
\hline
U+1F196 & 🆖 & {\textbackslash}:ng: & Squared Ng \\
\hline
U+1F197 & 🆗 & {\textbackslash}:ok: & Squared Ok \\
\hline
U+1F198 & 🆘 & {\textbackslash}:sos: & Squared Sos \\
\hline
U+1F199 & 🆙 & {\textbackslash}:up: & Squared Up With Exclamation Mark \\
\hline
U+1F19A & 🆚 & {\textbackslash}:vs: & Squared Vs \\
\hline
U+1F201 & 🈁 & {\textbackslash}:koko: & Squared Katakana Koko \\
\hline
U+1F202 & 🈂 & {\textbackslash}:sa: & Squared Katakana Sa \\
\hline
U+1F21A & 🈚 & {\textbackslash}:u7121: & Squared Cjk Unified Ideograph-7121 \\
\hline
U+1F22F & 🈯 & {\textbackslash}:u6307: & Squared Cjk Unified Ideograph-6307 \\
\hline
U+1F232 & 🈲 & {\textbackslash}:u7981: & Squared Cjk Unified Ideograph-7981 \\
\hline
U+1F233 & 🈳 & {\textbackslash}:u7a7a: & Squared Cjk Unified Ideograph-7A7A \\
\hline
U+1F234 & 🈴 & {\textbackslash}:u5408: & Squared Cjk Unified Ideograph-5408 \\
\hline
U+1F235 & 🈵 & {\textbackslash}:u6e80: & Squared Cjk Unified Ideograph-6E80 \\
\hline
U+1F236 & 🈶 & {\textbackslash}:u6709: & Squared Cjk Unified Ideograph-6709 \\
\hline
U+1F237 & 🈷 & {\textbackslash}:u6708: & Squared Cjk Unified Ideograph-6708 \\
\hline
U+1F238 & 🈸 & {\textbackslash}:u7533: & Squared Cjk Unified Ideograph-7533 \\
\hline
U+1F239 & 🈹 & {\textbackslash}:u5272: & Squared Cjk Unified Ideograph-5272 \\
\hline
U+1F23A & 🈺 & {\textbackslash}:u55b6: & Squared Cjk Unified Ideograph-55B6 \\
\hline
U+1F250 & 🉐 & {\textbackslash}:ideograph\_advantage: & Circled Ideograph Advantage \\
\hline
U+1F251 & 🉑 & {\textbackslash}:accept: & Circled Ideograph Accept \\
\hline
U+1F300 & 🌀 & {\textbackslash}:cyclone: & Cyclone \\
\hline
U+1F301 & 🌁 & {\textbackslash}:foggy: & Foggy \\
\hline
U+1F302 & 🌂 & {\textbackslash}:closed\_umbrella: & Closed Umbrella \\
\hline
U+1F303 & 🌃 & {\textbackslash}:night\_with\_stars: & Night With Stars \\
\hline
U+1F304 & 🌄 & {\textbackslash}:sunrise\_over\_mountains: & Sunrise Over Mountains \\
\hline
U+1F305 & 🌅 & {\textbackslash}:sunrise: & Sunrise \\
\hline
U+1F306 & 🌆 & {\textbackslash}:city\_sunset: & Cityscape At Dusk \\
\hline
U+1F307 & 🌇 & {\textbackslash}:city\_sunrise: & Sunset Over Buildings \\
\hline
U+1F308 & 🌈 & {\textbackslash}:rainbow: & Rainbow \\
\hline
U+1F309 & 🌉 & {\textbackslash}:bridge\_at\_night: & Bridge At Night \\
\hline
U+1F30A & 🌊 & {\textbackslash}:ocean: & Water Wave \\
\hline
U+1F30B & 🌋 & {\textbackslash}:volcano: & Volcano \\
\hline
U+1F30C & 🌌 & {\textbackslash}:milky\_way: & Milky Way \\
\hline
U+1F30D & 🌍 & {\textbackslash}:earth\_africa: & Earth Globe Europe-Africa \\
\hline
U+1F30E & 🌎 & {\textbackslash}:earth\_americas: & Earth Globe Americas \\
\hline
U+1F30F & 🌏 & {\textbackslash}:earth\_asia: & Earth Globe Asia-Australia \\
\hline
U+1F310 & 🌐 & {\textbackslash}:globe\_with\_meridians: & Globe With Meridians \\
\hline
U+1F311 & 🌑 & {\textbackslash}:new\_moon: & New Moon Symbol \\
\hline
U+1F312 & 🌒 & {\textbackslash}:waxing\_crescent\_moon: & Waxing Crescent Moon Symbol \\
\hline
U+1F313 & 🌓 & {\textbackslash}:first\_quarter\_moon: & First Quarter Moon Symbol \\
\hline
U+1F314 & 🌔 & {\textbackslash}:moon: & Waxing Gibbous Moon Symbol \\
\hline
U+1F315 & 🌕 & {\textbackslash}:full\_moon: & Full Moon Symbol \\
\hline
U+1F316 & 🌖 & {\textbackslash}:waning\_gibbous\_moon: & Waning Gibbous Moon Symbol \\
\hline
U+1F317 & 🌗 & {\textbackslash}:last\_quarter\_moon: & Last Quarter Moon Symbol \\
\hline
U+1F318 & 🌘 & {\textbackslash}:waning\_crescent\_moon: & Waning Crescent Moon Symbol \\
\hline
U+1F319 & 🌙 & {\textbackslash}:crescent\_moon: & Crescent Moon \\
\hline
U+1F31A & 🌚 & {\textbackslash}:new\_moon\_with\_face: & New Moon With Face \\
\hline
U+1F31B & 🌛 & {\textbackslash}:first\_quarter\_moon\_with\_face: & First Quarter Moon With Face \\
\hline
U+1F31C & 🌜 & {\textbackslash}:last\_quarter\_moon\_with\_face: & Last Quarter Moon With Face \\
\hline
U+1F31D & 🌝 & {\textbackslash}:full\_moon\_with\_face: & Full Moon With Face \\
\hline
U+1F31E & 🌞 & {\textbackslash}:sun\_with\_face: & Sun With Face \\
\hline
U+1F31F & 🌟 & {\textbackslash}:star2: & Glowing Star \\
\hline
U+1F320 & 🌠 & {\textbackslash}:stars: & Shooting Star \\
\hline
U+1F330 & 🌰 & {\textbackslash}:chestnut: & Chestnut \\
\hline
U+1F331 & 🌱 & {\textbackslash}:seedling: & Seedling \\
\hline
U+1F332 & 🌲 & {\textbackslash}:evergreen\_tree: & Evergreen Tree \\
\hline
U+1F333 & 🌳 & {\textbackslash}:deciduous\_tree: & Deciduous Tree \\
\hline
U+1F334 & 🌴 & {\textbackslash}:palm\_tree: & Palm Tree \\
\hline
U+1F335 & 🌵 & {\textbackslash}:cactus: & Cactus \\
\hline
U+1F337 & 🌷 & {\textbackslash}:tulip: & Tulip \\
\hline
U+1F338 & 🌸 & {\textbackslash}:cherry\_blossom: & Cherry Blossom \\
\hline
U+1F339 & 🌹 & {\textbackslash}:rose: & Rose \\
\hline
U+1F33A & 🌺 & {\textbackslash}:hibiscus: & Hibiscus \\
\hline
U+1F33B & 🌻 & {\textbackslash}:sunflower: & Sunflower \\
\hline
U+1F33C & 🌼 & {\textbackslash}:blossom: & Blossom \\
\hline
U+1F33D & 🌽 & {\textbackslash}:corn: & Ear Of Maize \\
\hline
U+1F33E & 🌾 & {\textbackslash}:ear\_of\_rice: & Ear Of Rice \\
\hline
U+1F33F & 🌿 & {\textbackslash}:herb: & Herb \\
\hline
U+1F340 & 🍀 & {\textbackslash}:four\_leaf\_clover: & Four Leaf Clover \\
\hline
U+1F341 & 🍁 & {\textbackslash}:maple\_leaf: & Maple Leaf \\
\hline
U+1F342 & 🍂 & {\textbackslash}:fallen\_leaf: & Fallen Leaf \\
\hline
U+1F343 & 🍃 & {\textbackslash}:leaves: & Leaf Fluttering In Wind \\
\hline
U+1F344 & 🍄 & {\textbackslash}:mushroom: & Mushroom \\
\hline
U+1F345 & 🍅 & {\textbackslash}:tomato: & Tomato \\
\hline
U+1F346 & 🍆 & {\textbackslash}:eggplant: & Aubergine \\
\hline
U+1F347 & 🍇 & {\textbackslash}:grapes: & Grapes \\
\hline
U+1F348 & 🍈 & {\textbackslash}:melon: & Melon \\
\hline
U+1F349 & 🍉 & {\textbackslash}:watermelon: & Watermelon \\
\hline
U+1F34A & 🍊 & {\textbackslash}:tangerine: & Tangerine \\
\hline
U+1F34B & 🍋 & {\textbackslash}:lemon: & Lemon \\
\hline
U+1F34C & 🍌 & {\textbackslash}:banana: & Banana \\
\hline
U+1F34D & 🍍 & {\textbackslash}:pineapple: & Pineapple \\
\hline
U+1F34E & 🍎 & {\textbackslash}:apple: & Red Apple \\
\hline
U+1F34F & 🍏 & {\textbackslash}:green\_apple: & Green Apple \\
\hline
U+1F350 & 🍐 & {\textbackslash}:pear: & Pear \\
\hline
U+1F351 & 🍑 & {\textbackslash}:peach: & Peach \\
\hline
U+1F352 & 🍒 & {\textbackslash}:cherries: & Cherries \\
\hline
U+1F353 & 🍓 & {\textbackslash}:strawberry: & Strawberry \\
\hline
U+1F354 & 🍔 & {\textbackslash}:hamburger: & Hamburger \\
\hline
U+1F355 & 🍕 & {\textbackslash}:pizza: & Slice Of Pizza \\
\hline
U+1F356 & 🍖 & {\textbackslash}:meat\_on\_bone: & Meat On Bone \\
\hline
U+1F357 & 🍗 & {\textbackslash}:poultry\_leg: & Poultry Leg \\
\hline
U+1F358 & 🍘 & {\textbackslash}:rice\_cracker: & Rice Cracker \\
\hline
U+1F359 & 🍙 & {\textbackslash}:rice\_ball: & Rice Ball \\
\hline
U+1F35A & 🍚 & {\textbackslash}:rice: & Cooked Rice \\
\hline
U+1F35B & 🍛 & {\textbackslash}:curry: & Curry And Rice \\
\hline
U+1F35C & 🍜 & {\textbackslash}:ramen: & Steaming Bowl \\
\hline
U+1F35D & 🍝 & {\textbackslash}:spaghetti: & Spaghetti \\
\hline
U+1F35E & 🍞 & {\textbackslash}:bread: & Bread \\
\hline
U+1F35F & 🍟 & {\textbackslash}:fries: & French Fries \\
\hline
U+1F360 & 🍠 & {\textbackslash}:sweet\_potato: & Roasted Sweet Potato \\
\hline
U+1F361 & 🍡 & {\textbackslash}:dango: & Dango \\
\hline
U+1F362 & 🍢 & {\textbackslash}:oden: & Oden \\
\hline
U+1F363 & 🍣 & {\textbackslash}:sushi: & Sushi \\
\hline
U+1F364 & 🍤 & {\textbackslash}:fried\_shrimp: & Fried Shrimp \\
\hline
U+1F365 & 🍥 & {\textbackslash}:fish\_cake: & Fish Cake With Swirl Design \\
\hline
U+1F366 & 🍦 & {\textbackslash}:icecream: & Soft Ice Cream \\
\hline
U+1F367 & 🍧 & {\textbackslash}:shaved\_ice: & Shaved Ice \\
\hline
U+1F368 & 🍨 & {\textbackslash}:ice\_cream: & Ice Cream \\
\hline
U+1F369 & 🍩 & {\textbackslash}:doughnut: & Doughnut \\
\hline
U+1F36A & 🍪 & {\textbackslash}:cookie: & Cookie \\
\hline
U+1F36B & 🍫 & {\textbackslash}:chocolate\_bar: & Chocolate Bar \\
\hline
U+1F36C & 🍬 & {\textbackslash}:candy: & Candy \\
\hline
U+1F36D & 🍭 & {\textbackslash}:lollipop: & Lollipop \\
\hline
U+1F36E & 🍮 & {\textbackslash}:custard: & Custard \\
\hline
U+1F36F & 🍯 & {\textbackslash}:honey\_pot: & Honey Pot \\
\hline
U+1F370 & 🍰 & {\textbackslash}:cake: & Shortcake \\
\hline
U+1F371 & 🍱 & {\textbackslash}:bento: & Bento Box \\
\hline
U+1F372 & 🍲 & {\textbackslash}:stew: & Pot Of Food \\
\hline
U+1F373 & 🍳 & {\textbackslash}:egg: & Cooking \\
\hline
U+1F374 & 🍴 & {\textbackslash}:fork\_and\_knife: & Fork And Knife \\
\hline
U+1F375 & 🍵 & {\textbackslash}:tea: & Teacup Without Handle \\
\hline
U+1F376 & 🍶 & {\textbackslash}:sake: & Sake Bottle And Cup \\
\hline
U+1F377 & 🍷 & {\textbackslash}:wine\_glass: & Wine Glass \\
\hline
U+1F378 & 🍸 & {\textbackslash}:cocktail: & Cocktail Glass \\
\hline
U+1F379 & 🍹 & {\textbackslash}:tropical\_drink: & Tropical Drink \\
\hline
U+1F37A & 🍺 & {\textbackslash}:beer: & Beer Mug \\
\hline
U+1F37B & 🍻 & {\textbackslash}:beers: & Clinking Beer Mugs \\
\hline
U+1F37C & 🍼 & {\textbackslash}:baby\_bottle: & Baby Bottle \\
\hline
U+1F380 & 🎀 & {\textbackslash}:ribbon: & Ribbon \\
\hline
U+1F381 & 🎁 & {\textbackslash}:gift: & Wrapped Present \\
\hline
U+1F382 & 🎂 & {\textbackslash}:birthday: & Birthday Cake \\
\hline
U+1F383 & 🎃 & {\textbackslash}:jack\_o\_lantern: & Jack-O-Lantern \\
\hline
U+1F384 & 🎄 & {\textbackslash}:christmas\_tree: & Christmas Tree \\
\hline
U+1F385 & 🎅 & {\textbackslash}:santa: & Father Christmas \\
\hline
U+1F386 & 🎆 & {\textbackslash}:fireworks: & Fireworks \\
\hline
U+1F387 & 🎇 & {\textbackslash}:sparkler: & Firework Sparkler \\
\hline
U+1F388 & 🎈 & {\textbackslash}:balloon: & Balloon \\
\hline
U+1F389 & 🎉 & {\textbackslash}:tada: & Party Popper \\
\hline
U+1F38A & 🎊 & {\textbackslash}:confetti\_ball: & Confetti Ball \\
\hline
U+1F38B & 🎋 & {\textbackslash}:tanabata\_tree: & Tanabata Tree \\
\hline
U+1F38C & 🎌 & {\textbackslash}:crossed\_flags: & Crossed Flags \\
\hline
U+1F38D & 🎍 & {\textbackslash}:bamboo: & Pine Decoration \\
\hline
U+1F38E & 🎎 & {\textbackslash}:dolls: & Japanese Dolls \\
\hline
U+1F38F & 🎏 & {\textbackslash}:flags: & Carp Streamer \\
\hline
U+1F390 & 🎐 & {\textbackslash}:wind\_chime: & Wind Chime \\
\hline
U+1F391 & 🎑 & {\textbackslash}:rice\_scene: & Moon Viewing Ceremony \\
\hline
U+1F392 & 🎒 & {\textbackslash}:school\_satchel: & School Satchel \\
\hline
U+1F393 & 🎓 & {\textbackslash}:mortar\_board: & Graduation Cap \\
\hline
U+1F3A0 & 🎠 & {\textbackslash}:carousel\_horse: & Carousel Horse \\
\hline
U+1F3A1 & 🎡 & {\textbackslash}:ferris\_wheel: & Ferris Wheel \\
\hline
U+1F3A2 & 🎢 & {\textbackslash}:roller\_coaster: & Roller Coaster \\
\hline
U+1F3A3 & 🎣 & {\textbackslash}:fishing\_pole\_and\_fish: & Fishing Pole And Fish \\
\hline
U+1F3A4 & 🎤 & {\textbackslash}:microphone: & Microphone \\
\hline
U+1F3A5 & 🎥 & {\textbackslash}:movie\_camera: & Movie Camera \\
\hline
U+1F3A6 & 🎦 & {\textbackslash}:cinema: & Cinema \\
\hline
U+1F3A7 & 🎧 & {\textbackslash}:headphones: & Headphone \\
\hline
U+1F3A8 & 🎨 & {\textbackslash}:art: & Artist Palette \\
\hline
U+1F3A9 & 🎩 & {\textbackslash}:tophat: & Top Hat \\
\hline
U+1F3AA & 🎪 & {\textbackslash}:circus\_tent: & Circus Tent \\
\hline
U+1F3AB & 🎫 & {\textbackslash}:ticket: & Ticket \\
\hline
U+1F3AC & 🎬 & {\textbackslash}:clapper: & Clapper Board \\
\hline
U+1F3AD & 🎭 & {\textbackslash}:performing\_arts: & Performing Arts \\
\hline
U+1F3AE & 🎮 & {\textbackslash}:video\_game: & Video Game \\
\hline
U+1F3AF & 🎯 & {\textbackslash}:dart: & Direct Hit \\
\hline
U+1F3B0 & 🎰 & {\textbackslash}:slot\_machine: & Slot Machine \\
\hline
U+1F3B1 & 🎱 & {\textbackslash}:8ball: & Billiards \\
\hline
U+1F3B2 & 🎲 & {\textbackslash}:game\_die: & Game Die \\
\hline
U+1F3B3 & 🎳 & {\textbackslash}:bowling: & Bowling \\
\hline
U+1F3B4 & 🎴 & {\textbackslash}:flower\_playing\_cards: & Flower Playing Cards \\
\hline
U+1F3B5 & 🎵 & {\textbackslash}:musical\_note: & Musical Note \\
\hline
U+1F3B6 & 🎶 & {\textbackslash}:notes: & Multiple Musical Notes \\
\hline
U+1F3B7 & 🎷 & {\textbackslash}:saxophone: & Saxophone \\
\hline
U+1F3B8 & 🎸 & {\textbackslash}:guitar: & Guitar \\
\hline
U+1F3B9 & 🎹 & {\textbackslash}:musical\_keyboard: & Musical Keyboard \\
\hline
U+1F3BA & 🎺 & {\textbackslash}:trumpet: & Trumpet \\
\hline
U+1F3BB & 🎻 & {\textbackslash}:violin: & Violin \\
\hline
U+1F3BC & 🎼 & {\textbackslash}:musical\_score: & Musical Score \\
\hline
U+1F3BD & 🎽 & {\textbackslash}:running\_shirt\_with\_sash: & Running Shirt With Sash \\
\hline
U+1F3BE & 🎾 & {\textbackslash}:tennis: & Tennis Racquet And Ball \\
\hline
U+1F3BF & 🎿 & {\textbackslash}:ski: & Ski And Ski Boot \\
\hline
U+1F3C0 & 🏀 & {\textbackslash}:basketball: & Basketball And Hoop \\
\hline
U+1F3C1 & 🏁 & {\textbackslash}:checkered\_flag: & Chequered Flag \\
\hline
U+1F3C2 & 🏂 & {\textbackslash}:snowboarder: & Snowboarder \\
\hline
U+1F3C3 & 🏃 & {\textbackslash}:runner: & Runner \\
\hline
U+1F3C4 & 🏄 & {\textbackslash}:surfer: & Surfer \\
\hline
U+1F3C6 & 🏆 & {\textbackslash}:trophy: & Trophy \\
\hline
U+1F3C7 & 🏇 & {\textbackslash}:horse\_racing: & Horse Racing \\
\hline
U+1F3C8 & 🏈 & {\textbackslash}:football: & American Football \\
\hline
U+1F3C9 & 🏉 & {\textbackslash}:rugby\_football: & Rugby Football \\
\hline
U+1F3CA & 🏊 & {\textbackslash}:swimmer: & Swimmer \\
\hline
U+1F3E0 & 🏠 & {\textbackslash}:house: & House Building \\
\hline
U+1F3E1 & 🏡 & {\textbackslash}:house\_with\_garden: & House With Garden \\
\hline
U+1F3E2 & 🏢 & {\textbackslash}:office: & Office Building \\
\hline
U+1F3E3 & 🏣 & {\textbackslash}:post\_office: & Japanese Post Office \\
\hline
U+1F3E4 & 🏤 & {\textbackslash}:european\_post\_office: & European Post Office \\
\hline
U+1F3E5 & 🏥 & {\textbackslash}:hospital: & Hospital \\
\hline
U+1F3E6 & 🏦 & {\textbackslash}:bank: & Bank \\
\hline
U+1F3E7 & 🏧 & {\textbackslash}:atm: & Automated Teller Machine \\
\hline
U+1F3E8 & 🏨 & {\textbackslash}:hotel: & Hotel \\
\hline
U+1F3E9 & 🏩 & {\textbackslash}:love\_hotel: & Love Hotel \\
\hline
U+1F3EA & 🏪 & {\textbackslash}:convenience\_store: & Convenience Store \\
\hline
U+1F3EB & 🏫 & {\textbackslash}:school: & School \\
\hline
U+1F3EC & 🏬 & {\textbackslash}:department\_store: & Department Store \\
\hline
U+1F3ED & 🏭 & {\textbackslash}:factory: & Factory \\
\hline
U+1F3EE & 🏮 & {\textbackslash}:izakaya\_lantern: & Izakaya Lantern \\
\hline
U+1F3EF & 🏯 & {\textbackslash}:japanese\_castle: & Japanese Castle \\
\hline
U+1F3F0 & 🏰 & {\textbackslash}:european\_castle: & European Castle \\
\hline
U+1F3FB & 🏻 & {\textbackslash}:skin-tone-2: & Emoji Modifier Fitzpatrick Type-1-2 \\
\hline
U+1F3FC & 🏼 & {\textbackslash}:skin-tone-3: & Emoji Modifier Fitzpatrick Type-3 \\
\hline
U+1F3FD & 🏽 & {\textbackslash}:skin-tone-4: & Emoji Modifier Fitzpatrick Type-4 \\
\hline
U+1F3FE & 🏾 & {\textbackslash}:skin-tone-5: & Emoji Modifier Fitzpatrick Type-5 \\
\hline
U+1F3FF & 🏿 & {\textbackslash}:skin-tone-6: & Emoji Modifier Fitzpatrick Type-6 \\
\hline
U+1F400 & 🐀 & {\textbackslash}:rat: & Rat \\
\hline
U+1F401 & 🐁 & {\textbackslash}:mouse2: & Mouse \\
\hline
U+1F402 & 🐂 & {\textbackslash}:ox: & Ox \\
\hline
U+1F403 & 🐃 & {\textbackslash}:water\_buffalo: & Water Buffalo \\
\hline
U+1F404 & 🐄 & {\textbackslash}:cow2: & Cow \\
\hline
U+1F405 & 🐅 & {\textbackslash}:tiger2: & Tiger \\
\hline
U+1F406 & 🐆 & {\textbackslash}:leopard: & Leopard \\
\hline
U+1F407 & 🐇 & {\textbackslash}:rabbit2: & Rabbit \\
\hline
U+1F408 & 🐈 & {\textbackslash}:cat2: & Cat \\
\hline
U+1F409 & 🐉 & {\textbackslash}:dragon: & Dragon \\
\hline
U+1F40A & 🐊 & {\textbackslash}:crocodile: & Crocodile \\
\hline
U+1F40B & 🐋 & {\textbackslash}:whale2: & Whale \\
\hline
U+1F40C & 🐌 & {\textbackslash}:snail: & Snail \\
\hline
U+1F40D & 🐍 & {\textbackslash}:snake: & Snake \\
\hline
U+1F40E & 🐎 & {\textbackslash}:racehorse: & Horse \\
\hline
U+1F40F & 🐏 & {\textbackslash}:ram: & Ram \\
\hline
U+1F410 & 🐐 & {\textbackslash}:goat: & Goat \\
\hline
U+1F411 & 🐑 & {\textbackslash}:sheep: & Sheep \\
\hline
U+1F412 & 🐒 & {\textbackslash}:monkey: & Monkey \\
\hline
U+1F413 & 🐓 & {\textbackslash}:rooster: & Rooster \\
\hline
U+1F414 & 🐔 & {\textbackslash}:chicken: & Chicken \\
\hline
U+1F415 & 🐕 & {\textbackslash}:dog2: & Dog \\
\hline
U+1F416 & 🐖 & {\textbackslash}:pig2: & Pig \\
\hline
U+1F417 & 🐗 & {\textbackslash}:boar: & Boar \\
\hline
U+1F418 & 🐘 & {\textbackslash}:elephant: & Elephant \\
\hline
U+1F419 & 🐙 & {\textbackslash}:octopus: & Octopus \\
\hline
U+1F41A & 🐚 & {\textbackslash}:shell: & Spiral Shell \\
\hline
U+1F41B & 🐛 & {\textbackslash}:bug: & Bug \\
\hline
U+1F41C & 🐜 & {\textbackslash}:ant: & Ant \\
\hline
U+1F41D & 🐝 & {\textbackslash}:bee: & Honeybee \\
\hline
U+1F41E & 🐞 & {\textbackslash}:beetle: & Lady Beetle \\
\hline
U+1F41F & 🐟 & {\textbackslash}:fish: & Fish \\
\hline
U+1F420 & 🐠 & {\textbackslash}:tropical\_fish: & Tropical Fish \\
\hline
U+1F421 & 🐡 & {\textbackslash}:blowfish: & Blowfish \\
\hline
U+1F422 & 🐢 & {\textbackslash}:turtle: & Turtle \\
\hline
U+1F423 & 🐣 & {\textbackslash}:hatching\_chick: & Hatching Chick \\
\hline
U+1F424 & 🐤 & {\textbackslash}:baby\_chick: & Baby Chick \\
\hline
U+1F425 & 🐥 & {\textbackslash}:hatched\_chick: & Front-Facing Baby Chick \\
\hline
U+1F426 & 🐦 & {\textbackslash}:bird: & Bird \\
\hline
U+1F427 & 🐧 & {\textbackslash}:penguin: & Penguin \\
\hline
U+1F428 & 🐨 & {\textbackslash}:koala: & Koala \\
\hline
U+1F429 & 🐩 & {\textbackslash}:poodle: & Poodle \\
\hline
U+1F42A & 🐪 & {\textbackslash}:dromedary\_camel: & Dromedary Camel \\
\hline
U+1F42B & 🐫 & {\textbackslash}:camel: & Bactrian Camel \\
\hline
U+1F42C & 🐬 & {\textbackslash}:dolphin: & Dolphin \\
\hline
U+1F42D & 🐭 & {\textbackslash}:mouse: & Mouse Face \\
\hline
U+1F42E & 🐮 & {\textbackslash}:cow: & Cow Face \\
\hline
U+1F42F & 🐯 & {\textbackslash}:tiger: & Tiger Face \\
\hline
U+1F430 & 🐰 & {\textbackslash}:rabbit: & Rabbit Face \\
\hline
U+1F431 & 🐱 & {\textbackslash}:cat: & Cat Face \\
\hline
U+1F432 & 🐲 & {\textbackslash}:dragon\_face: & Dragon Face \\
\hline
U+1F433 & 🐳 & {\textbackslash}:whale: & Spouting Whale \\
\hline
U+1F434 & 🐴 & {\textbackslash}:horse: & Horse Face \\
\hline
U+1F435 & 🐵 & {\textbackslash}:monkey\_face: & Monkey Face \\
\hline
U+1F436 & 🐶 & {\textbackslash}:dog: & Dog Face \\
\hline
U+1F437 & 🐷 & {\textbackslash}:pig: & Pig Face \\
\hline
U+1F438 & 🐸 & {\textbackslash}:frog: & Frog Face \\
\hline
U+1F439 & 🐹 & {\textbackslash}:hamster: & Hamster Face \\
\hline
U+1F43A & 🐺 & {\textbackslash}:wolf: & Wolf Face \\
\hline
U+1F43B & 🐻 & {\textbackslash}:bear: & Bear Face \\
\hline
U+1F43C & 🐼 & {\textbackslash}:panda\_face: & Panda Face \\
\hline
U+1F43D & 🐽 & {\textbackslash}:pig\_nose: & Pig Nose \\
\hline
U+1F43E & 🐾 & {\textbackslash}:feet: & Paw Prints \\
\hline
U+1F440 & 👀 & {\textbackslash}:eyes: & Eyes \\
\hline
U+1F442 & 👂 & {\textbackslash}:ear: & Ear \\
\hline
U+1F443 & 👃 & {\textbackslash}:nose: & Nose \\
\hline
U+1F444 & 👄 & {\textbackslash}:lips: & Mouth \\
\hline
U+1F445 & 👅 & {\textbackslash}:tongue: & Tongue \\
\hline
U+1F446 & 👆 & {\textbackslash}:point\_up\_2: & White Up Pointing Backhand Index \\
\hline
U+1F447 & 👇 & {\textbackslash}:point\_down: & White Down Pointing Backhand Index \\
\hline
U+1F448 & 👈 & {\textbackslash}:point\_left: & White Left Pointing Backhand Index \\
\hline
U+1F449 & 👉 & {\textbackslash}:point\_right: & White Right Pointing Backhand Index \\
\hline
U+1F44A & 👊 & {\textbackslash}:facepunch: & Fisted Hand Sign \\
\hline
U+1F44B & 👋 & {\textbackslash}:wave: & Waving Hand Sign \\
\hline
U+1F44C & 👌 & {\textbackslash}:ok\_hand: & Ok Hand Sign \\
\hline
U+1F44D & 👍 & {\textbackslash}:+1: & Thumbs Up Sign \\
\hline
U+1F44E & 👎 & {\textbackslash}:-1: & Thumbs Down Sign \\
\hline
U+1F44F & 👏 & {\textbackslash}:clap: & Clapping Hands Sign \\
\hline
U+1F450 & 👐 & {\textbackslash}:open\_hands: & Open Hands Sign \\
\hline
U+1F451 & 👑 & {\textbackslash}:crown: & Crown \\
\hline
U+1F452 & 👒 & {\textbackslash}:womans\_hat: & Womans Hat \\
\hline
U+1F453 & 👓 & {\textbackslash}:eyeglasses: & Eyeglasses \\
\hline
U+1F454 & 👔 & {\textbackslash}:necktie: & Necktie \\
\hline
U+1F455 & 👕 & {\textbackslash}:shirt: & T-Shirt \\
\hline
U+1F456 & 👖 & {\textbackslash}:jeans: & Jeans \\
\hline
U+1F457 & 👗 & {\textbackslash}:dress: & Dress \\
\hline
U+1F458 & 👘 & {\textbackslash}:kimono: & Kimono \\
\hline
U+1F459 & 👙 & {\textbackslash}:bikini: & Bikini \\
\hline
U+1F45A & 👚 & {\textbackslash}:womans\_clothes: & Womans Clothes \\
\hline
U+1F45B & 👛 & {\textbackslash}:purse: & Purse \\
\hline
U+1F45C & 👜 & {\textbackslash}:handbag: & Handbag \\
\hline
U+1F45D & 👝 & {\textbackslash}:pouch: & Pouch \\
\hline
U+1F45E & 👞 & {\textbackslash}:mans\_shoe: & Mans Shoe \\
\hline
U+1F45F & 👟 & {\textbackslash}:athletic\_shoe: & Athletic Shoe \\
\hline
U+1F460 & 👠 & {\textbackslash}:high\_heel: & High-Heeled Shoe \\
\hline
U+1F461 & 👡 & {\textbackslash}:sandal: & Womans Sandal \\
\hline
U+1F462 & 👢 & {\textbackslash}:boot: & Womans Boots \\
\hline
U+1F463 & 👣 & {\textbackslash}:footprints: & Footprints \\
\hline
U+1F464 & 👤 & {\textbackslash}:bust\_in\_silhouette: & Bust In Silhouette \\
\hline
U+1F465 & 👥 & {\textbackslash}:busts\_in\_silhouette: & Busts In Silhouette \\
\hline
U+1F466 & 👦 & {\textbackslash}:boy: & Boy \\
\hline
U+1F467 & 👧 & {\textbackslash}:girl: & Girl \\
\hline
U+1F468 & 👨 & {\textbackslash}:man: & Man \\
\hline
U+1F469 & 👩 & {\textbackslash}:woman: & Woman \\
\hline
U+1F46A & 👪 & {\textbackslash}:family: & Family \\
\hline
U+1F46B & 👫 & {\textbackslash}:couple: & Man And Woman Holding Hands \\
\hline
U+1F46C & 👬 & {\textbackslash}:two\_men\_holding\_hands: & Two Men Holding Hands \\
\hline
U+1F46D & 👭 & {\textbackslash}:two\_women\_holding\_hands: & Two Women Holding Hands \\
\hline
U+1F46E & 👮 & {\textbackslash}:cop: & Police Officer \\
\hline
U+1F46F & 👯 & {\textbackslash}:dancers: & Woman With Bunny Ears \\
\hline
U+1F470 & 👰 & {\textbackslash}:bride\_with\_veil: & Bride With Veil \\
\hline
U+1F471 & 👱 & {\textbackslash}:person\_with\_blond\_hair: & Person With Blond Hair \\
\hline
U+1F472 & 👲 & {\textbackslash}:man\_with\_gua\_pi\_mao: & Man With Gua Pi Mao \\
\hline
U+1F473 & 👳 & {\textbackslash}:man\_with\_turban: & Man With Turban \\
\hline
U+1F474 & 👴 & {\textbackslash}:older\_man: & Older Man \\
\hline
U+1F475 & 👵 & {\textbackslash}:older\_woman: & Older Woman \\
\hline
U+1F476 & 👶 & {\textbackslash}:baby: & Baby \\
\hline
U+1F477 & 👷 & {\textbackslash}:construction\_worker: & Construction Worker \\
\hline
U+1F478 & 👸 & {\textbackslash}:princess: & Princess \\
\hline
U+1F479 & 👹 & {\textbackslash}:japanese\_ogre: & Japanese Ogre \\
\hline
U+1F47A & 👺 & {\textbackslash}:japanese\_goblin: & Japanese Goblin \\
\hline
U+1F47B & 👻 & {\textbackslash}:ghost: & Ghost \\
\hline
U+1F47C & 👼 & {\textbackslash}:angel: & Baby Angel \\
\hline
U+1F47D & 👽 & {\textbackslash}:alien: & Extraterrestrial Alien \\
\hline
U+1F47E & 👾 & {\textbackslash}:space\_invader: & Alien Monster \\
\hline
U+1F47F & 👿 & {\textbackslash}:imp: & Imp \\
\hline
U+1F480 & 💀 & {\textbackslash}:skull: & Skull \\
\hline
U+1F481 & 💁 & {\textbackslash}:information\_desk\_person: & Information Desk Person \\
\hline
U+1F482 & 💂 & {\textbackslash}:guardsman: & Guardsman \\
\hline
U+1F483 & 💃 & {\textbackslash}:dancer: & Dancer \\
\hline
U+1F484 & 💄 & {\textbackslash}:lipstick: & Lipstick \\
\hline
U+1F485 & 💅 & {\textbackslash}:nail\_care: & Nail Polish \\
\hline
U+1F486 & 💆 & {\textbackslash}:massage: & Face Massage \\
\hline
U+1F487 & 💇 & {\textbackslash}:haircut: & Haircut \\
\hline
U+1F488 & 💈 & {\textbackslash}:barber: & Barber Pole \\
\hline
U+1F489 & 💉 & {\textbackslash}:syringe: & Syringe \\
\hline
U+1F48A & 💊 & {\textbackslash}:pill: & Pill \\
\hline
U+1F48B & 💋 & {\textbackslash}:kiss: & Kiss Mark \\
\hline
U+1F48C & 💌 & {\textbackslash}:love\_letter: & Love Letter \\
\hline
U+1F48D & 💍 & {\textbackslash}:ring: & Ring \\
\hline
U+1F48E & 💎 & {\textbackslash}:gem: & Gem Stone \\
\hline
U+1F48F & 💏 & {\textbackslash}:couplekiss: & Kiss \\
\hline
U+1F490 & 💐 & {\textbackslash}:bouquet: & Bouquet \\
\hline
U+1F491 & 💑 & {\textbackslash}:couple\_with\_heart: & Couple With Heart \\
\hline
U+1F492 & 💒 & {\textbackslash}:wedding: & Wedding \\
\hline
U+1F493 & 💓 & {\textbackslash}:heartbeat: & Beating Heart \\
\hline
U+1F494 & 💔 & {\textbackslash}:broken\_heart: & Broken Heart \\
\hline
U+1F495 & 💕 & {\textbackslash}:two\_hearts: & Two Hearts \\
\hline
U+1F496 & 💖 & {\textbackslash}:sparkling\_heart: & Sparkling Heart \\
\hline
U+1F497 & 💗 & {\textbackslash}:heartpulse: & Growing Heart \\
\hline
U+1F498 & 💘 & {\textbackslash}:cupid: & Heart With Arrow \\
\hline
U+1F499 & 💙 & {\textbackslash}:blue\_heart: & Blue Heart \\
\hline
U+1F49A & 💚 & {\textbackslash}:green\_heart: & Green Heart \\
\hline
U+1F49B & 💛 & {\textbackslash}:yellow\_heart: & Yellow Heart \\
\hline
U+1F49C & 💜 & {\textbackslash}:purple\_heart: & Purple Heart \\
\hline
U+1F49D & 💝 & {\textbackslash}:gift\_heart: & Heart With Ribbon \\
\hline
U+1F49E & 💞 & {\textbackslash}:revolving\_hearts: & Revolving Hearts \\
\hline
U+1F49F & 💟 & {\textbackslash}:heart\_decoration: & Heart Decoration \\
\hline
U+1F4A0 & 💠 & {\textbackslash}:diamond\_shape\_with\_a\_dot\_inside: & Diamond Shape With A Dot Inside \\
\hline
U+1F4A1 & 💡 & {\textbackslash}:bulb: & Electric Light Bulb \\
\hline
U+1F4A2 & 💢 & {\textbackslash}:anger: & Anger Symbol \\
\hline
U+1F4A3 & 💣 & {\textbackslash}:bomb: & Bomb \\
\hline
U+1F4A4 & 💤 & {\textbackslash}:zzz: & Sleeping Symbol \\
\hline
U+1F4A5 & 💥 & {\textbackslash}:boom: & Collision Symbol \\
\hline
U+1F4A6 & 💦 & {\textbackslash}:sweat\_drops: & Splashing Sweat Symbol \\
\hline
U+1F4A7 & 💧 & {\textbackslash}:droplet: & Droplet \\
\hline
U+1F4A8 & 💨 & {\textbackslash}:dash: & Dash Symbol \\
\hline
U+1F4A9 & 💩 & {\textbackslash}:hankey: & Pile Of Poo \\
\hline
U+1F4AA & 💪 & {\textbackslash}:muscle: & Flexed Biceps \\
\hline
U+1F4AB & 💫 & {\textbackslash}:dizzy: & Dizzy Symbol \\
\hline
U+1F4AC & 💬 & {\textbackslash}:speech\_balloon: & Speech Balloon \\
\hline
U+1F4AD & 💭 & {\textbackslash}:thought\_balloon: & Thought Balloon \\
\hline
U+1F4AE & 💮 & {\textbackslash}:white\_flower: & White Flower \\
\hline
U+1F4AF & 💯 & {\textbackslash}:100: & Hundred Points Symbol \\
\hline
U+1F4B0 & 💰 & {\textbackslash}:moneybag: & Money Bag \\
\hline
U+1F4B1 & 💱 & {\textbackslash}:currency\_exchange: & Currency Exchange \\
\hline
U+1F4B2 & 💲 & {\textbackslash}:heavy\_dollar\_sign: & Heavy Dollar Sign \\
\hline
U+1F4B3 & 💳 & {\textbackslash}:credit\_card: & Credit Card \\
\hline
U+1F4B4 & 💴 & {\textbackslash}:yen: & Banknote With Yen Sign \\
\hline
U+1F4B5 & 💵 & {\textbackslash}:dollar: & Banknote With Dollar Sign \\
\hline
U+1F4B6 & 💶 & {\textbackslash}:euro: & Banknote With Euro Sign \\
\hline
U+1F4B7 & 💷 & {\textbackslash}:pound: & Banknote With Pound Sign \\
\hline
U+1F4B8 & 💸 & {\textbackslash}:money\_with\_wings: & Money With Wings \\
\hline
U+1F4B9 & 💹 & {\textbackslash}:chart: & Chart With Upwards Trend And Yen Sign \\
\hline
U+1F4BA & 💺 & {\textbackslash}:seat: & Seat \\
\hline
U+1F4BB & 💻 & {\textbackslash}:computer: & Personal Computer \\
\hline
U+1F4BC & 💼 & {\textbackslash}:briefcase: & Briefcase \\
\hline
U+1F4BD & 💽 & {\textbackslash}:minidisc: & Minidisc \\
\hline
U+1F4BE & 💾 & {\textbackslash}:floppy\_disk: & Floppy Disk \\
\hline
U+1F4BF & 💿 & {\textbackslash}:cd: & Optical Disc \\
\hline
U+1F4C0 & 📀 & {\textbackslash}:dvd: & Dvd \\
\hline
U+1F4C1 & 📁 & {\textbackslash}:file\_folder: & File Folder \\
\hline
U+1F4C2 & 📂 & {\textbackslash}:open\_file\_folder: & Open File Folder \\
\hline
U+1F4C3 & 📃 & {\textbackslash}:page\_with\_curl: & Page With Curl \\
\hline
U+1F4C4 & 📄 & {\textbackslash}:page\_facing\_up: & Page Facing Up \\
\hline
U+1F4C5 & 📅 & {\textbackslash}:date: & Calendar \\
\hline
U+1F4C6 & 📆 & {\textbackslash}:calendar: & Tear-Off Calendar \\
\hline
U+1F4C7 & 📇 & {\textbackslash}:card\_index: & Card Index \\
\hline
U+1F4C8 & 📈 & {\textbackslash}:chart\_with\_upwards\_trend: & Chart With Upwards Trend \\
\hline
U+1F4C9 & 📉 & {\textbackslash}:chart\_with\_downwards\_trend: & Chart With Downwards Trend \\
\hline
U+1F4CA & 📊 & {\textbackslash}:bar\_chart: & Bar Chart \\
\hline
U+1F4CB & 📋 & {\textbackslash}:clipboard: & Clipboard \\
\hline
U+1F4CC & 📌 & {\textbackslash}:pushpin: & Pushpin \\
\hline
U+1F4CD & 📍 & {\textbackslash}:round\_pushpin: & Round Pushpin \\
\hline
U+1F4CE & 📎 & {\textbackslash}:paperclip: & Paperclip \\
\hline
U+1F4CF & 📏 & {\textbackslash}:straight\_ruler: & Straight Ruler \\
\hline
U+1F4D0 & 📐 & {\textbackslash}:triangular\_ruler: & Triangular Ruler \\
\hline
U+1F4D1 & 📑 & {\textbackslash}:bookmark\_tabs: & Bookmark Tabs \\
\hline
U+1F4D2 & 📒 & {\textbackslash}:ledger: & Ledger \\
\hline
U+1F4D3 & 📓 & {\textbackslash}:notebook: & Notebook \\
\hline
U+1F4D4 & 📔 & {\textbackslash}:notebook\_with\_decorative\_cover: & Notebook With Decorative Cover \\
\hline
U+1F4D5 & 📕 & {\textbackslash}:closed\_book: & Closed Book \\
\hline
U+1F4D6 & 📖 & {\textbackslash}:book: & Open Book \\
\hline
U+1F4D7 & 📗 & {\textbackslash}:green\_book: & Green Book \\
\hline
U+1F4D8 & 📘 & {\textbackslash}:blue\_book: & Blue Book \\
\hline
U+1F4D9 & 📙 & {\textbackslash}:orange\_book: & Orange Book \\
\hline
U+1F4DA & 📚 & {\textbackslash}:books: & Books \\
\hline
U+1F4DB & 📛 & {\textbackslash}:name\_badge: & Name Badge \\
\hline
U+1F4DC & 📜 & {\textbackslash}:scroll: & Scroll \\
\hline
U+1F4DD & 📝 & {\textbackslash}:memo: & Memo \\
\hline
U+1F4DE & 📞 & {\textbackslash}:telephone\_receiver: & Telephone Receiver \\
\hline
U+1F4DF & 📟 & {\textbackslash}:pager: & Pager \\
\hline
U+1F4E0 & 📠 & {\textbackslash}:fax: & Fax Machine \\
\hline
U+1F4E1 & 📡 & {\textbackslash}:satellite: & Satellite Antenna \\
\hline
U+1F4E2 & 📢 & {\textbackslash}:loudspeaker: & Public Address Loudspeaker \\
\hline
U+1F4E3 & 📣 & {\textbackslash}:mega: & Cheering Megaphone \\
\hline
U+1F4E4 & 📤 & {\textbackslash}:outbox\_tray: & Outbox Tray \\
\hline
U+1F4E5 & 📥 & {\textbackslash}:inbox\_tray: & Inbox Tray \\
\hline
U+1F4E6 & 📦 & {\textbackslash}:package: & Package \\
\hline
U+1F4E7 & 📧 & {\textbackslash}:e-mail: & E-Mail Symbol \\
\hline
U+1F4E8 & 📨 & {\textbackslash}:incoming\_envelope: & Incoming Envelope \\
\hline
U+1F4E9 & 📩 & {\textbackslash}:envelope\_with\_arrow: & Envelope With Downwards Arrow Above \\
\hline
U+1F4EA & 📪 & {\textbackslash}:mailbox\_closed: & Closed Mailbox With Lowered Flag \\
\hline
U+1F4EB & 📫 & {\textbackslash}:mailbox: & Closed Mailbox With Raised Flag \\
\hline
U+1F4EC & 📬 & {\textbackslash}:mailbox\_with\_mail: & Open Mailbox With Raised Flag \\
\hline
U+1F4ED & 📭 & {\textbackslash}:mailbox\_with\_no\_mail: & Open Mailbox With Lowered Flag \\
\hline
U+1F4EE & 📮 & {\textbackslash}:postbox: & Postbox \\
\hline
U+1F4EF & 📯 & {\textbackslash}:postal\_horn: & Postal Horn \\
\hline
U+1F4F0 & 📰 & {\textbackslash}:newspaper: & Newspaper \\
\hline
U+1F4F1 & 📱 & {\textbackslash}:iphone: & Mobile Phone \\
\hline
U+1F4F2 & 📲 & {\textbackslash}:calling: & Mobile Phone With Rightwards Arrow At Left \\
\hline
U+1F4F3 & 📳 & {\textbackslash}:vibration\_mode: & Vibration Mode \\
\hline
U+1F4F4 & 📴 & {\textbackslash}:mobile\_phone\_off: & Mobile Phone Off \\
\hline
U+1F4F5 & 📵 & {\textbackslash}:no\_mobile\_phones: & No Mobile Phones \\
\hline
U+1F4F6 & 📶 & {\textbackslash}:signal\_strength: & Antenna With Bars \\
\hline
U+1F4F7 & 📷 & {\textbackslash}:camera: & Camera \\
\hline
U+1F4F9 & 📹 & {\textbackslash}:video\_camera: & Video Camera \\
\hline
U+1F4FA & 📺 & {\textbackslash}:tv: & Television \\
\hline
U+1F4FB & 📻 & {\textbackslash}:radio: & Radio \\
\hline
U+1F4FC & 📼 & {\textbackslash}:vhs: & Videocassette \\
\hline
U+1F500 & 🔀 & {\textbackslash}:twisted\_rightwards\_arrows: & Twisted Rightwards Arrows \\
\hline
U+1F501 & 🔁 & {\textbackslash}:repeat: & Clockwise Rightwards And Leftwards Open Circle Arrows \\
\hline
U+1F502 & 🔂 & {\textbackslash}:repeat\_one: & Clockwise Rightwards And Leftwards Open Circle Arrows With Circled One Overlay \\
\hline
U+1F503 & 🔃 & {\textbackslash}:arrows\_clockwise: & Clockwise Downwards And Upwards Open Circle Arrows \\
\hline
U+1F504 & 🔄 & {\textbackslash}:arrows\_counterclockwise: & Anticlockwise Downwards And Upwards Open Circle Arrows \\
\hline
U+1F505 & 🔅 & {\textbackslash}:low\_brightness: & Low Brightness Symbol \\
\hline
U+1F506 & 🔆 & {\textbackslash}:high\_brightness: & High Brightness Symbol \\
\hline
U+1F507 & 🔇 & {\textbackslash}:mute: & Speaker With Cancellation Stroke \\
\hline
U+1F508 & 🔈 & {\textbackslash}:speaker: & Speaker \\
\hline
U+1F509 & 🔉 & {\textbackslash}:sound: & Speaker With One Sound Wave \\
\hline
U+1F50A & 🔊 & {\textbackslash}:loud\_sound: & Speaker With Three Sound Waves \\
\hline
U+1F50B & 🔋 & {\textbackslash}:battery: & Battery \\
\hline
U+1F50C & 🔌 & {\textbackslash}:electric\_plug: & Electric Plug \\
\hline
U+1F50D & 🔍 & {\textbackslash}:mag: & Left-Pointing Magnifying Glass \\
\hline
U+1F50E & 🔎 & {\textbackslash}:mag\_right: & Right-Pointing Magnifying Glass \\
\hline
U+1F50F & 🔏 & {\textbackslash}:lock\_with\_ink\_pen: & Lock With Ink Pen \\
\hline
U+1F510 & 🔐 & {\textbackslash}:closed\_lock\_with\_key: & Closed Lock With Key \\
\hline
U+1F511 & 🔑 & {\textbackslash}:key: & Key \\
\hline
U+1F512 & 🔒 & {\textbackslash}:lock: & Lock \\
\hline
U+1F513 & 🔓 & {\textbackslash}:unlock: & Open Lock \\
\hline
U+1F514 & 🔔 & {\textbackslash}:bell: & Bell \\
\hline
U+1F515 & 🔕 & {\textbackslash}:no\_bell: & Bell With Cancellation Stroke \\
\hline
U+1F516 & 🔖 & {\textbackslash}:bookmark: & Bookmark \\
\hline
U+1F517 & 🔗 & {\textbackslash}:link: & Link Symbol \\
\hline
U+1F518 & 🔘 & {\textbackslash}:radio\_button: & Radio Button \\
\hline
U+1F519 & 🔙 & {\textbackslash}:back: & Back With Leftwards Arrow Above \\
\hline
U+1F51A & 🔚 & {\textbackslash}:end: & End With Leftwards Arrow Above \\
\hline
U+1F51B & 🔛 & {\textbackslash}:on: & On With Exclamation Mark With Left Right Arrow Above \\
\hline
U+1F51C & 🔜 & {\textbackslash}:soon: & Soon With Rightwards Arrow Above \\
\hline
U+1F51D & 🔝 & {\textbackslash}:top: & Top With Upwards Arrow Above \\
\hline
U+1F51E & 🔞 & {\textbackslash}:underage: & No One Under Eighteen Symbol \\
\hline
U+1F51F & 🔟 & {\textbackslash}:keycap\_ten: & Keycap Ten \\
\hline
U+1F520 & 🔠 & {\textbackslash}:capital\_abcd: & Input Symbol For Latin Capital Letters \\
\hline
U+1F521 & 🔡 & {\textbackslash}:abcd: & Input Symbol For Latin Small Letters \\
\hline
U+1F522 & 🔢 & {\textbackslash}:1234: & Input Symbol For Numbers \\
\hline
U+1F523 & 🔣 & {\textbackslash}:symbols: & Input Symbol For Symbols \\
\hline
U+1F524 & 🔤 & {\textbackslash}:abc: & Input Symbol For Latin Letters \\
\hline
U+1F525 & 🔥 & {\textbackslash}:fire: & Fire \\
\hline
U+1F526 & 🔦 & {\textbackslash}:flashlight: & Electric Torch \\
\hline
U+1F527 & 🔧 & {\textbackslash}:wrench: & Wrench \\
\hline
U+1F528 & 🔨 & {\textbackslash}:hammer: & Hammer \\
\hline
U+1F529 & 🔩 & {\textbackslash}:nut\_and\_bolt: & Nut And Bolt \\
\hline
U+1F52A & 🔪 & {\textbackslash}:hocho: & Hocho \\
\hline
U+1F52B & 🔫 & {\textbackslash}:gun: & Pistol \\
\hline
U+1F52C & 🔬 & {\textbackslash}:microscope: & Microscope \\
\hline
U+1F52D & 🔭 & {\textbackslash}:telescope: & Telescope \\
\hline
U+1F52E & 🔮 & {\textbackslash}:crystal\_ball: & Crystal Ball \\
\hline
U+1F52F & 🔯 & {\textbackslash}:six\_pointed\_star: & Six Pointed Star With Middle Dot \\
\hline
U+1F530 & 🔰 & {\textbackslash}:beginner: & Japanese Symbol For Beginner \\
\hline
U+1F531 & 🔱 & {\textbackslash}:trident: & Trident Emblem \\
\hline
U+1F532 & 🔲 & {\textbackslash}:black\_square\_button: & Black Square Button \\
\hline
U+1F533 & 🔳 & {\textbackslash}:white\_square\_button: & White Square Button \\
\hline
U+1F534 & 🔴 & {\textbackslash}:red\_circle: & Large Red Circle \\
\hline
U+1F535 & 🔵 & {\textbackslash}:large\_blue\_circle: & Large Blue Circle \\
\hline
U+1F536 & 🔶 & {\textbackslash}:large\_orange\_diamond: & Large Orange Diamond \\
\hline
U+1F537 & 🔷 & {\textbackslash}:large\_blue\_diamond: & Large Blue Diamond \\
\hline
U+1F538 & 🔸 & {\textbackslash}:small\_orange\_diamond: & Small Orange Diamond \\
\hline
U+1F539 & 🔹 & {\textbackslash}:small\_blue\_diamond: & Small Blue Diamond \\
\hline
U+1F53A & 🔺 & {\textbackslash}:small\_red\_triangle: & Up-Pointing Red Triangle \\
\hline
U+1F53B & 🔻 & {\textbackslash}:small\_red\_triangle\_down: & Down-Pointing Red Triangle \\
\hline
U+1F53C & 🔼 & {\textbackslash}:arrow\_up\_small: & Up-Pointing Small Red Triangle \\
\hline
U+1F53D & 🔽 & {\textbackslash}:arrow\_down\_small: & Down-Pointing Small Red Triangle \\
\hline
U+1F550 & 🕐 & {\textbackslash}:clock1: & Clock Face One Oclock \\
\hline
U+1F551 & 🕑 & {\textbackslash}:clock2: & Clock Face Two Oclock \\
\hline
U+1F552 & 🕒 & {\textbackslash}:clock3: & Clock Face Three Oclock \\
\hline
U+1F553 & 🕓 & {\textbackslash}:clock4: & Clock Face Four Oclock \\
\hline
U+1F554 & 🕔 & {\textbackslash}:clock5: & Clock Face Five Oclock \\
\hline
U+1F555 & 🕕 & {\textbackslash}:clock6: & Clock Face Six Oclock \\
\hline
U+1F556 & 🕖 & {\textbackslash}:clock7: & Clock Face Seven Oclock \\
\hline
U+1F557 & 🕗 & {\textbackslash}:clock8: & Clock Face Eight Oclock \\
\hline
U+1F558 & 🕘 & {\textbackslash}:clock9: & Clock Face Nine Oclock \\
\hline
U+1F559 & 🕙 & {\textbackslash}:clock10: & Clock Face Ten Oclock \\
\hline
U+1F55A & 🕚 & {\textbackslash}:clock11: & Clock Face Eleven Oclock \\
\hline
U+1F55B & 🕛 & {\textbackslash}:clock12: & Clock Face Twelve Oclock \\
\hline
U+1F55C & 🕜 & {\textbackslash}:clock130: & Clock Face One-Thirty \\
\hline
U+1F55D & 🕝 & {\textbackslash}:clock230: & Clock Face Two-Thirty \\
\hline
U+1F55E & 🕞 & {\textbackslash}:clock330: & Clock Face Three-Thirty \\
\hline
U+1F55F & 🕟 & {\textbackslash}:clock430: & Clock Face Four-Thirty \\
\hline
U+1F560 & 🕠 & {\textbackslash}:clock530: & Clock Face Five-Thirty \\
\hline
U+1F561 & 🕡 & {\textbackslash}:clock630: & Clock Face Six-Thirty \\
\hline
U+1F562 & 🕢 & {\textbackslash}:clock730: & Clock Face Seven-Thirty \\
\hline
U+1F563 & 🕣 & {\textbackslash}:clock830: & Clock Face Eight-Thirty \\
\hline
U+1F564 & 🕤 & {\textbackslash}:clock930: & Clock Face Nine-Thirty \\
\hline
U+1F565 & 🕥 & {\textbackslash}:clock1030: & Clock Face Ten-Thirty \\
\hline
U+1F566 & 🕦 & {\textbackslash}:clock1130: & Clock Face Eleven-Thirty \\
\hline
U+1F567 & 🕧 & {\textbackslash}:clock1230: & Clock Face Twelve-Thirty \\
\hline
U+1F5FB & 🗻 & {\textbackslash}:mount\_fuji: & Mount Fuji \\
\hline
U+1F5FC & 🗼 & {\textbackslash}:tokyo\_tower: & Tokyo Tower \\
\hline
U+1F5FD & 🗽 & {\textbackslash}:statue\_of\_liberty: & Statue Of Liberty \\
\hline
U+1F5FE & 🗾 & {\textbackslash}:japan: & Silhouette Of Japan \\
\hline
U+1F5FF & 🗿 & {\textbackslash}:moyai: & Moyai \\
\hline
U+1F600 & 😀 & {\textbackslash}:grinning: & Grinning Face \\
\hline
U+1F601 & 😁 & {\textbackslash}:grin: & Grinning Face With Smiling Eyes \\
\hline
U+1F602 & 😂 & {\textbackslash}:joy: & Face With Tears Of Joy \\
\hline
U+1F603 & 😃 & {\textbackslash}:smiley: & Smiling Face With Open Mouth \\
\hline
U+1F604 & 😄 & {\textbackslash}:smile: & Smiling Face With Open Mouth And Smiling Eyes \\
\hline
U+1F605 & 😅 & {\textbackslash}:sweat\_smile: & Smiling Face With Open Mouth And Cold Sweat \\
\hline
U+1F606 & 😆 & {\textbackslash}:laughing: & Smiling Face With Open Mouth And Tightly-Closed Eyes \\
\hline
U+1F607 & 😇 & {\textbackslash}:innocent: & Smiling Face With Halo \\
\hline
U+1F608 & 😈 & {\textbackslash}:smiling\_imp: & Smiling Face With Horns \\
\hline
U+1F609 & 😉 & {\textbackslash}:wink: & Winking Face \\
\hline
U+1F60A & 😊 & {\textbackslash}:blush: & Smiling Face With Smiling Eyes \\
\hline
U+1F60B & 😋 & {\textbackslash}:yum: & Face Savouring Delicious Food \\
\hline
U+1F60C & 😌 & {\textbackslash}:relieved: & Relieved Face \\
\hline
U+1F60D & 😍 & {\textbackslash}:heart\_eyes: & Smiling Face With Heart-Shaped Eyes \\
\hline
U+1F60E & 😎 & {\textbackslash}:sunglasses: & Smiling Face With Sunglasses \\
\hline
U+1F60F & 😏 & {\textbackslash}:smirk: & Smirking Face \\
\hline
U+1F610 & 😐 & {\textbackslash}:neutral\_face: & Neutral Face \\
\hline
U+1F611 & 😑 & {\textbackslash}:expressionless: & Expressionless Face \\
\hline
U+1F612 & 😒 & {\textbackslash}:unamused: & Unamused Face \\
\hline
U+1F613 & 😓 & {\textbackslash}:sweat: & Face With Cold Sweat \\
\hline
U+1F614 & 😔 & {\textbackslash}:pensive: & Pensive Face \\
\hline
U+1F615 & 😕 & {\textbackslash}:confused: & Confused Face \\
\hline
U+1F616 & 😖 & {\textbackslash}:confounded: & Confounded Face \\
\hline
U+1F617 & 😗 & {\textbackslash}:kissing: & Kissing Face \\
\hline
U+1F618 & 😘 & {\textbackslash}:kissing\_heart: & Face Throwing A Kiss \\
\hline
U+1F619 & 😙 & {\textbackslash}:kissing\_smiling\_eyes: & Kissing Face With Smiling Eyes \\
\hline
U+1F61A & 😚 & {\textbackslash}:kissing\_closed\_eyes: & Kissing Face With Closed Eyes \\
\hline
U+1F61B & 😛 & {\textbackslash}:stuck\_out\_tongue: & Face With Stuck-Out Tongue \\
\hline
U+1F61C & 😜 & {\textbackslash}:stuck\_out\_tongue\_winking\_eye: & Face With Stuck-Out Tongue And Winking Eye \\
\hline
U+1F61D & 😝 & {\textbackslash}:stuck\_out\_tongue\_closed\_eyes: & Face With Stuck-Out Tongue And Tightly-Closed Eyes \\
\hline
U+1F61E & 😞 & {\textbackslash}:disappointed: & Disappointed Face \\
\hline
U+1F61F & 😟 & {\textbackslash}:worried: & Worried Face \\
\hline
U+1F620 & 😠 & {\textbackslash}:angry: & Angry Face \\
\hline
U+1F621 & 😡 & {\textbackslash}:rage: & Pouting Face \\
\hline
U+1F622 & 😢 & {\textbackslash}:cry: & Crying Face \\
\hline
U+1F623 & 😣 & {\textbackslash}:persevere: & Persevering Face \\
\hline
U+1F624 & 😤 & {\textbackslash}:triumph: & Face With Look Of Triumph \\
\hline
U+1F625 & 😥 & {\textbackslash}:disappointed\_relieved: & Disappointed But Relieved Face \\
\hline
U+1F626 & 😦 & {\textbackslash}:frowning: & Frowning Face With Open Mouth \\
\hline
U+1F627 & 😧 & {\textbackslash}:anguished: & Anguished Face \\
\hline
U+1F628 & 😨 & {\textbackslash}:fearful: & Fearful Face \\
\hline
U+1F629 & 😩 & {\textbackslash}:weary: & Weary Face \\
\hline
U+1F62A & 😪 & {\textbackslash}:sleepy: & Sleepy Face \\
\hline
U+1F62B & 😫 & {\textbackslash}:tired\_face: & Tired Face \\
\hline
U+1F62C & 😬 & {\textbackslash}:grimacing: & Grimacing Face \\
\hline
U+1F62D & 😭 & {\textbackslash}:sob: & Loudly Crying Face \\
\hline
U+1F62E & 😮 & {\textbackslash}:open\_mouth: & Face With Open Mouth \\
\hline
U+1F62F & 😯 & {\textbackslash}:hushed: & Hushed Face \\
\hline
U+1F630 & 😰 & {\textbackslash}:cold\_sweat: & Face With Open Mouth And Cold Sweat \\
\hline
U+1F631 & 😱 & {\textbackslash}:scream: & Face Screaming In Fear \\
\hline
U+1F632 & 😲 & {\textbackslash}:astonished: & Astonished Face \\
\hline
U+1F633 & 😳 & {\textbackslash}:flushed: & Flushed Face \\
\hline
U+1F634 & 😴 & {\textbackslash}:sleeping: & Sleeping Face \\
\hline
U+1F635 & 😵 & {\textbackslash}:dizzy\_face: & Dizzy Face \\
\hline
U+1F636 & 😶 & {\textbackslash}:no\_mouth: & Face Without Mouth \\
\hline
U+1F637 & 😷 & {\textbackslash}:mask: & Face With Medical Mask \\
\hline
U+1F638 & 😸 & {\textbackslash}:smile\_cat: & Grinning Cat Face With Smiling Eyes \\
\hline
U+1F639 & 😹 & {\textbackslash}:joy\_cat: & Cat Face With Tears Of Joy \\
\hline
U+1F63A & 😺 & {\textbackslash}:smiley\_cat: & Smiling Cat Face With Open Mouth \\
\hline
U+1F63B & 😻 & {\textbackslash}:heart\_eyes\_cat: & Smiling Cat Face With Heart-Shaped Eyes \\
\hline
U+1F63C & 😼 & {\textbackslash}:smirk\_cat: & Cat Face With Wry Smile \\
\hline
U+1F63D & 😽 & {\textbackslash}:kissing\_cat: & Kissing Cat Face With Closed Eyes \\
\hline
U+1F63E & 😾 & {\textbackslash}:pouting\_cat: & Pouting Cat Face \\
\hline
U+1F63F & 😿 & {\textbackslash}:crying\_cat\_face: & Crying Cat Face \\
\hline
U+1F640 & 🙀 & {\textbackslash}:scream\_cat: & Weary Cat Face \\
\hline
U+1F645 & 🙅 & {\textbackslash}:no\_good: & Face With No Good Gesture \\
\hline
U+1F646 & 🙆 & {\textbackslash}:ok\_woman: & Face With Ok Gesture \\
\hline
U+1F647 & 🙇 & {\textbackslash}:bow: & Person Bowing Deeply \\
\hline
U+1F648 & 🙈 & {\textbackslash}:see\_no\_evil: & See-No-Evil Monkey \\
\hline
U+1F649 & 🙉 & {\textbackslash}:hear\_no\_evil: & Hear-No-Evil Monkey \\
\hline
U+1F64A & 🙊 & {\textbackslash}:speak\_no\_evil: & Speak-No-Evil Monkey \\
\hline
U+1F64B & 🙋 & {\textbackslash}:raising\_hand: & Happy Person Raising One Hand \\
\hline
U+1F64C & 🙌 & {\textbackslash}:raised\_hands: & Person Raising Both Hands In Celebration \\
\hline
U+1F64D & 🙍 & {\textbackslash}:person\_frowning: & Person Frowning \\
\hline
U+1F64E & 🙎 & {\textbackslash}:person\_with\_pouting\_face: & Person With Pouting Face \\
\hline
U+1F64F & 🙏 & {\textbackslash}:pray: & Person With Folded Hands \\
\hline
U+1F680 & 🚀 & {\textbackslash}:rocket: & Rocket \\
\hline
U+1F681 & 🚁 & {\textbackslash}:helicopter: & Helicopter \\
\hline
U+1F682 & 🚂 & {\textbackslash}:steam\_locomotive: & Steam Locomotive \\
\hline
U+1F683 & 🚃 & {\textbackslash}:railway\_car: & Railway Car \\
\hline
U+1F684 & 🚄 & {\textbackslash}:bullettrain\_side: & High-Speed Train \\
\hline
U+1F685 & 🚅 & {\textbackslash}:bullettrain\_front: & High-Speed Train With Bullet Nose \\
\hline
U+1F686 & 🚆 & {\textbackslash}:train2: & Train \\
\hline
U+1F687 & 🚇 & {\textbackslash}:metro: & Metro \\
\hline
U+1F688 & 🚈 & {\textbackslash}:light\_rail: & Light Rail \\
\hline
U+1F689 & 🚉 & {\textbackslash}:station: & Station \\
\hline
U+1F68A & 🚊 & {\textbackslash}:tram: & Tram \\
\hline
U+1F68B & 🚋 & {\textbackslash}:train: & Tram Car \\
\hline
U+1F68C & 🚌 & {\textbackslash}:bus: & Bus \\
\hline
U+1F68D & 🚍 & {\textbackslash}:oncoming\_bus: & Oncoming Bus \\
\hline
U+1F68E & 🚎 & {\textbackslash}:trolleybus: & Trolleybus \\
\hline
U+1F68F & 🚏 & {\textbackslash}:busstop: & Bus Stop \\
\hline
U+1F690 & 🚐 & {\textbackslash}:minibus: & Minibus \\
\hline
U+1F691 & 🚑 & {\textbackslash}:ambulance: & Ambulance \\
\hline
U+1F692 & 🚒 & {\textbackslash}:fire\_engine: & Fire Engine \\
\hline
U+1F693 & 🚓 & {\textbackslash}:police\_car: & Police Car \\
\hline
U+1F694 & 🚔 & {\textbackslash}:oncoming\_police\_car: & Oncoming Police Car \\
\hline
U+1F695 & 🚕 & {\textbackslash}:taxi: & Taxi \\
\hline
U+1F696 & 🚖 & {\textbackslash}:oncoming\_taxi: & Oncoming Taxi \\
\hline
U+1F697 & 🚗 & {\textbackslash}:car: & Automobile \\
\hline
U+1F698 & 🚘 & {\textbackslash}:oncoming\_automobile: & Oncoming Automobile \\
\hline
U+1F699 & 🚙 & {\textbackslash}:blue\_car: & Recreational Vehicle \\
\hline
U+1F69A & 🚚 & {\textbackslash}:truck: & Delivery Truck \\
\hline
U+1F69B & 🚛 & {\textbackslash}:articulated\_lorry: & Articulated Lorry \\
\hline
U+1F69C & 🚜 & {\textbackslash}:tractor: & Tractor \\
\hline
U+1F69D & 🚝 & {\textbackslash}:monorail: & Monorail \\
\hline
U+1F69E & 🚞 & {\textbackslash}:mountain\_railway: & Mountain Railway \\
\hline
U+1F69F & 🚟 & {\textbackslash}:suspension\_railway: & Suspension Railway \\
\hline
U+1F6A0 & 🚠 & {\textbackslash}:mountain\_cableway: & Mountain Cableway \\
\hline
U+1F6A1 & 🚡 & {\textbackslash}:aerial\_tramway: & Aerial Tramway \\
\hline
U+1F6A2 & 🚢 & {\textbackslash}:ship: & Ship \\
\hline
U+1F6A3 & 🚣 & {\textbackslash}:rowboat: & Rowboat \\
\hline
U+1F6A4 & 🚤 & {\textbackslash}:speedboat: & Speedboat \\
\hline
U+1F6A5 & 🚥 & {\textbackslash}:traffic\_light: & Horizontal Traffic Light \\
\hline
U+1F6A6 & 🚦 & {\textbackslash}:vertical\_traffic\_light: & Vertical Traffic Light \\
\hline
U+1F6A7 & 🚧 & {\textbackslash}:construction: & Construction Sign \\
\hline
U+1F6A8 & 🚨 & {\textbackslash}:rotating\_light: & Police Cars Revolving Light \\
\hline
U+1F6A9 & 🚩 & {\textbackslash}:triangular\_flag\_on\_post: & Triangular Flag On Post \\
\hline
U+1F6AA & 🚪 & {\textbackslash}:door: & Door \\
\hline
U+1F6AB & 🚫 & {\textbackslash}:no\_entry\_sign: & No Entry Sign \\
\hline
U+1F6AC & 🚬 & {\textbackslash}:smoking: & Smoking Symbol \\
\hline
U+1F6AD & 🚭 & {\textbackslash}:no\_smoking: & No Smoking Symbol \\
\hline
U+1F6AE & 🚮 & {\textbackslash}:put\_litter\_in\_its\_place: & Put Litter In Its Place Symbol \\
\hline
U+1F6AF & 🚯 & {\textbackslash}:do\_not\_litter: & Do Not Litter Symbol \\
\hline
U+1F6B0 & 🚰 & {\textbackslash}:potable\_water: & Potable Water Symbol \\
\hline
U+1F6B1 & 🚱 & {\textbackslash}:non-potable\_water: & Non-Potable Water Symbol \\
\hline
U+1F6B2 & 🚲 & {\textbackslash}:bike: & Bicycle \\
\hline
U+1F6B3 & 🚳 & {\textbackslash}:no\_bicycles: & No Bicycles \\
\hline
U+1F6B4 & 🚴 & {\textbackslash}:bicyclist: & Bicyclist \\
\hline
U+1F6B5 & 🚵 & {\textbackslash}:mountain\_bicyclist: & Mountain Bicyclist \\
\hline
U+1F6B6 & 🚶 & {\textbackslash}:walking: & Pedestrian \\
\hline
U+1F6B7 & 🚷 & {\textbackslash}:no\_pedestrians: & No Pedestrians \\
\hline
U+1F6B8 & 🚸 & {\textbackslash}:children\_crossing: & Children Crossing \\
\hline
U+1F6B9 & 🚹 & {\textbackslash}:mens: & Mens Symbol \\
\hline
U+1F6BA & 🚺 & {\textbackslash}:womens: & Womens Symbol \\
\hline
U+1F6BB & 🚻 & {\textbackslash}:restroom: & Restroom \\
\hline
U+1F6BC & 🚼 & {\textbackslash}:baby\_symbol: & Baby Symbol \\
\hline
U+1F6BD & 🚽 & {\textbackslash}:toilet: & Toilet \\
\hline
U+1F6BE & 🚾 & {\textbackslash}:wc: & Water Closet \\
\hline
U+1F6BF & 🚿 & {\textbackslash}:shower: & Shower \\
\hline
U+1F6C0 & 🛀 & {\textbackslash}:bath: & Bath \\
\hline
U+1F6C1 & 🛁 & {\textbackslash}:bathtub: & Bathtub \\
\hline
U+1F6C2 & 🛂 & {\textbackslash}:passport\_control: & Passport Control \\
\hline
U+1F6C3 & 🛃 & {\textbackslash}:customs: & Customs \\
\hline
U+1F6C4 & 🛄 & {\textbackslash}:baggage\_claim: & Baggage Claim \\
\hline
U+1F6C5 & 🛅 & {\textbackslash}:left\_luggage: & Left Luggage \\
\hline
\end{tabulary}

\end{table}



\part{Base}


\hypertarget{16478843685103880703}{}


\chapter{基本功能}



\hypertarget{7253998760451691688}{}


\section{介绍}



Julia Base 中包含一系列适用于科学及数值计算的函数和宏，但也可以用于通用编程，其它功能则由 Julia 生态圈中的各种库来提供。函数按主题划分如下：



一些通用的提示：



\begin{itemize}
\item 可以通过 \texttt{Import Module} 导入想要使用的模块，并利用 \texttt{Module.fn(x)} 语句来实现对模块内函数的调用。


\item 此外，\texttt{using Module} 语句会将名为 \texttt{Module} 的模块中的所有可调函数引入当前的命名空间。


\item 按照约定，名字以感叹号（\texttt{!}）结尾的函数会改变其输入参数的内容。 一些函数同时拥有改变参数（例如 \texttt{sort!}）和不改变参数（\texttt{sort}）的版本

\end{itemize}


\hypertarget{10705549471205156223}{}


\section{概览}


\hypertarget{14846984688570889934}{} 
\hyperlink{14846984688570889934}{\texttt{Base.exit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
exit(code=0)
\end{minted}

Stop the program with an exit code. The default exit code is zero, indicating that the program completed successfully. In an interactive session, \texttt{exit()} can be called with the keyboard shortcut \texttt{{\textasciicircum}D}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/initdefs.jl#L21-L27}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17479944696971324992}{} 
\hyperlink{17479944696971324992}{\texttt{Base.atexit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
atexit(f)
\end{minted}

Register a zero-argument function \texttt{f()} to be called at process exit. \texttt{atexit()} hooks are called in last in first out (LIFO) order and run before object finalizers.

Exit hooks are allowed to call \texttt{exit(n)}, in which case Julia will exit with exit code \texttt{n} (instead of the original exit code). If more than one exit hook calls \texttt{exit(n)}, then Julia will exit with the exit code corresponding to the last called exit hook that calls \texttt{exit(n)}. (Because exit hooks are called in LIFO order, {\textquotedbl}last called{\textquotedbl} is equivalent to {\textquotedbl}first registered{\textquotedbl}.)



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/initdefs.jl#L298-L309}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10304111149900708910}{} 
\hyperlink{10304111149900708910}{\texttt{Base.isinteractive}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isinteractive() -> Bool
\end{minted}

Determine whether Julia is running an interactive session.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/initdefs.jl#L35-L39}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16959611366931029689}{} 
\hyperlink{16959611366931029689}{\texttt{Base.summarysize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.summarysize(obj; exclude=Union{...}, chargeall=Union{...}) -> Int
\end{minted}

Compute the amount of memory, in bytes, used by all unique objects reachable from the argument.

\textbf{Keyword Arguments}

\begin{itemize}
\item \texttt{exclude}: specifies the types of objects to exclude from the traversal.


\item \texttt{chargeall}: specifies the types of objects to always charge the size of all of their fields, even if those fields would normally be excluded.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/summarysize.jl#L11-L20}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16690217505788642360}{} 
\hyperlink{16690217505788642360}{\texttt{Base.require}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
require(into::Module, module::Symbol)
\end{minted}

This function is part of the implementation of \hyperlink{169458112978175560}{\texttt{using}} / \hyperlink{16252475688663093021}{\texttt{import}}, if a module is not already defined in \texttt{Main}. It can also be called directly to force reloading a module, regardless of whether it has been loaded before (for example, when interactively developing libraries).

Loads a source file, in the context of the \texttt{Main} module, on every active node, searching standard locations for files. \texttt{require} is considered a top-level operation, so it sets the current \texttt{include} path but does not use it to search for files (see help for \hyperlink{438355891087818425}{\texttt{include}}). This function is typically used to load library code, and is implicitly called by \texttt{using} to load packages.

When searching for files, \texttt{require} first looks for package code in the global array \hyperlink{17914149694871263675}{\texttt{LOAD\_PATH}}. \texttt{require} is case-sensitive on all platforms, including those with case-insensitive filesystems like macOS and Windows.

For more details regarding code loading, see the manual sections on \hyperlink{16725527896995457152}{modules} and \href{@ref code-availability}{parallel computing}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/loading.jl#L865-L885}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15403934372637978246}{} 
\hyperlink{15403934372637978246}{\texttt{Base.compilecache}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.compilecache(module::PkgId)
\end{minted}

Creates a precompiled cache file for a module and all of its dependencies. This can be used to reduce package load times. Cache files are stored in \texttt{DEPOT\_PATH[1]/compiled}. See \href{@ref}{Module initialization and precompilation} for important notes.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/loading.jl#L1222-L1229}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9213488790068613847}{} 
\hyperlink{9213488790068613847}{\texttt{Base.\_\_precompile\_\_}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
__precompile__(isprecompilable::Bool)
\end{minted}

Specify whether the file calling this function is precompilable, defaulting to \texttt{true}. If a module or file is \emph{not} safely precompilable, it should call \texttt{\_\_precompile\_\_(false)} in order to throw an error if Julia attempts to precompile it.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/loading.jl#L845-L851}{\texttt{source}}


\end{adjustwidth}
\hypertarget{438355891087818425}{} 
\hyperlink{438355891087818425}{\texttt{Base.include}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.include([m::Module,] path::AbstractString)
\end{minted}

Evaluate the contents of the input source file in the global scope of module \texttt{m}. Every module (except those defined with \hyperlink{13329108222158426840}{\texttt{baremodule}}) has its own 1-argument definition of \texttt{include}, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to \texttt{include} will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/loading.jl#L1100-L1110}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7507443674556842580}{} 
\hyperlink{7507443674556842580}{\texttt{Base.MainInclude.include}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
include(path::AbstractString)
\end{minted}

Evaluate the contents of the input source file in the global scope of the containing module. Every module (except those defined with \texttt{baremodule}) has its own 1-argument definition of \texttt{include}, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to \texttt{include} will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.

Use \hyperlink{438355891087818425}{\texttt{Base.include}} to evaluate a file into another module.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/client.jl#L461-L473}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2796348696499086186}{} 
\hyperlink{2796348696499086186}{\texttt{Base.include\_string}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
include_string(m::Module, code::AbstractString, filename::AbstractString="string")
\end{minted}

Like \hyperlink{438355891087818425}{\texttt{include}}, except reads code from the given string rather than from a file.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/loading.jl#L1075-L1079}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13423629850785876688}{} 
\hyperlink{13423629850785876688}{\texttt{Base.include\_dependency}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
include_dependency(path::AbstractString)
\end{minted}

In a module, declare that the file specified by \texttt{path} (relative or absolute) is a dependency for precompilation; that is, the module will need to be recompiled if this file changes.

This is only needed if your module depends on a file that is not used via \hyperlink{438355891087818425}{\texttt{include}}. It has no effect outside of compilation.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/loading.jl#L820-L829}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17355831054812136492}{} 
\hyperlink{17355831054812136492}{\texttt{Base.which}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
which(f, types)
\end{minted}

Returns the method of \texttt{f} (a \texttt{Method} object) that would be called for arguments of the given \texttt{types}.

If \texttt{types} is an abstract type, then the method that would be called by \texttt{invoke} is returned.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L1133-L1139}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3025953302266245919}{} 
\hyperlink{3025953302266245919}{\texttt{Base.methods}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
methods(f, [types], [module])
\end{minted}

Return the method table for \texttt{f}.

If \texttt{types} is specified, return an array of methods whose types match. If \texttt{module} is specified, return an array of methods defined in that module. A list of modules can also be specified as an array.

\begin{quote}
\textbf{Julia 1.4}

At least Julia 1.4 is required for specifying a module.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L865-L876}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13133508810150623671}{} 
\hyperlink{13133508810150623671}{\texttt{Base.@show}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@show
\end{minted}

Show an expression and result, returning the result. See also \hyperlink{14071376285304310153}{\texttt{show}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/show.jl#L604-L608}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11288188119698492222}{} 
\hyperlink{11288188119698492222}{\texttt{ans}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ans
\end{minted}

A variable referring to the last computed value, automatically set at the interactive prompt.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1029-L1033}{\texttt{source}}


\end{adjustwidth}

\hypertarget{1461769336029416688}{}


\section{关键字}



This is the list of reserved keywords in Julia: \texttt{baremodule}, \texttt{begin}, \texttt{break}, \texttt{catch}, \texttt{const}, \texttt{continue}, \texttt{do}, \texttt{else}, \texttt{elseif}, \texttt{end}, \texttt{export}, \texttt{false}, \texttt{finally}, \texttt{for}, \texttt{function}, \texttt{global}, \texttt{if}, \texttt{import}, \texttt{let}, \texttt{local}, \texttt{macro}, \texttt{module}, \texttt{quote}, \texttt{return}, \texttt{struct}, \texttt{true}, \texttt{try}, \texttt{using}, \texttt{while}. Those keywords are not allowed to be used as variable names.



The following two-word sequences are reserved: \texttt{abstract type}, \texttt{mutable struct}, \texttt{primitive type}. However, you can create variables with names: \texttt{abstract}, \texttt{mutable}, \texttt{primitive} and \texttt{type}.



Finally, \texttt{where} is parsed as an infix operator for writing parametric method and type definitions. Also \texttt{in} and \texttt{isa} are parsed as infix operators. Creation of a variable named \texttt{where}, \texttt{in} or \texttt{isa} is allowed though.


\hypertarget{16285380181904025577}{} 
\hyperlink{16285380181904025577}{\texttt{module}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
module
\end{minted}

\texttt{module} declares a \hyperlink{6070072550914765640}{\texttt{Module}}, which is a separate global variable workspace. Within a module, you can control which names from other modules are visible (via importing), and specify which of your names are intended to be public (via exporting). Modules allow you to create top-level definitions without worrying about name conflicts when your code is used together with somebody else’s. See the \hyperlink{16725527896995457152}{manual section about modules} for more details.

\textbf{Examples}


\begin{minted}{julia}
module Foo
import Base.show
export MyType, foo

struct MyType
    x
end

bar(x) = 2x
foo(a::MyType) = bar(a.x) + 1
show(io::IO, a::MyType) = print(io, "MyType $(a.x)")
end
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L75-L100}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17583167789241791362}{} 
\hyperlink{17583167789241791362}{\texttt{export}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
export
\end{minted}

\texttt{export} is used within modules to tell Julia which functions should be made available to the user. For example: \texttt{export foo} makes the name \texttt{foo} available when \hyperlink{169458112978175560}{\texttt{using}} the module. See the \hyperlink{16725527896995457152}{manual section about modules} for details.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L49-L56}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16252475688663093021}{} 
\hyperlink{16252475688663093021}{\texttt{import}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
import
\end{minted}

\texttt{import Foo} will load the module or package \texttt{Foo}. Names from the imported \texttt{Foo} module can be accessed with dot syntax (e.g. \texttt{Foo.foo} to access the name \texttt{foo}). See the \hyperlink{16725527896995457152}{manual section about modules} for details.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L39-L46}{\texttt{source}}


\end{adjustwidth}
\hypertarget{169458112978175560}{} 
\hyperlink{169458112978175560}{\texttt{using}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
using
\end{minted}

\texttt{using Foo} will load the module or package \texttt{Foo} and make its \hyperlink{17583167789241791362}{\texttt{export}}ed names available for direct use. Names can also be used via dot syntax (e.g. \texttt{Foo.foo} to access the name \texttt{foo}), whether they are \texttt{export}ed or not. See the \hyperlink{16725527896995457152}{manual section about modules} for details.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L29-L36}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13329108222158426840}{} 
\hyperlink{13329108222158426840}{\texttt{baremodule}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
baremodule
\end{minted}

\texttt{baremodule} declares a module that does not contain \texttt{using Base} or a definition of \hyperlink{7998531662462967836}{\texttt{eval}}. It does still import \texttt{Core}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L126-L131}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5624836169846334627}{} 
\hyperlink{5624836169846334627}{\texttt{function}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
function
\end{minted}

Functions are defined with the \texttt{function} keyword:


\begin{minted}{julia}
function add(a, b)
    return a + b
end
\end{minted}

Or the short form notation:


\begin{minted}{julia}
add(a, b) = a + b
\end{minted}

The use of the \hyperlink{10918908543132060605}{\texttt{return}} keyword is exactly the same as in other languages, but is often optional. A function without an explicit \texttt{return} statement will return the last expression in the function body.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L499-L518}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4625593635027008869}{} 
\hyperlink{4625593635027008869}{\texttt{macro}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
macro
\end{minted}

\texttt{macro} defines a method for inserting generated code into a program. A macro maps a sequence of argument expressions to a returned expression, and the resulting expression is substituted directly into the program at the point where the macro is invoked. Macros are a way to run generated code without calling \hyperlink{7998531662462967836}{\texttt{eval}}, since the generated code instead simply becomes part of the surrounding program. Macro arguments may include expressions, literal values, and symbols.

\textbf{Examples}


\begin{minted}{jlcon}
julia> macro sayhello(name)
           return :( println("Hello, ", $name, "!") )
       end
@sayhello (macro with 1 method)

julia> @sayhello "Charlie"
Hello, Charlie!
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L152-L173}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10918908543132060605}{} 
\hyperlink{10918908543132060605}{\texttt{return}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
return
\end{minted}

\texttt{return x} causes the enclosing function to exit early, passing the given value \texttt{x} back to its caller. \texttt{return} by itself with no value is equivalent to \texttt{return nothing} (see \hyperlink{9331422207248206047}{\texttt{nothing}}).


\begin{minted}{julia}
function compare(a, b)
    a == b && return "equal to"
    a < b ? "less than" : "greater than"
end
\end{minted}

In general you can place a \texttt{return} statement anywhere within a function body, including within deeply nested loops or conditionals, but be careful with \texttt{do} blocks. For example:


\begin{minted}{julia}
function test1(xs)
    for x in xs
        iseven(x) && return 2x
    end
end

function test2(xs)
    map(xs) do x
        iseven(x) && return 2x
        x
    end
end
\end{minted}

In the first example, the return breaks out of \texttt{test1} as soon as it hits an even number, so \texttt{test1([5,6,7])} returns \texttt{12}.

You might expect the second example to behave the same way, but in fact the \texttt{return} there only breaks out of the \emph{inner} function (inside the \texttt{do} block) and gives a value back to \texttt{map}. \texttt{test2([5,6,7])} then returns \texttt{[5,12,7]}.

When used in a top-level expression (i.e. outside any function), \texttt{return} causes the entire current top-level expression to terminate early.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L521-L561}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16455129305818705265}{} 
\hyperlink{16455129305818705265}{\texttt{do}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
do
\end{minted}

Create an anonymous function and pass it as the first argument to a function call. For example:


\begin{minted}{julia}
map(1:10) do x
    2x
end
\end{minted}

is equivalent to \texttt{map(x->2x, 1:10)}.

Use multiple arguments like so:


\begin{minted}{julia}
map(1:10, 11:20) do x, y
    x + y
end
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L758-L780}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2050903905813838256}{} 
\hyperlink{2050903905813838256}{\texttt{begin}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
begin
\end{minted}

\texttt{begin...end} denotes a block of code.


\begin{minted}{julia}
begin
    println("Hello, ")
    println("World!")
end
\end{minted}

Usually \texttt{begin} will not be necessary, since keywords such as \hyperlink{5624836169846334627}{\texttt{function}} and \hyperlink{4956741936243461891}{\texttt{let}} implicitly begin blocks of code. See also \hyperlink{13353096094479374008}{\texttt{;}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L894-L908}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11574363005673055470}{} 
\hyperlink{11574363005673055470}{\texttt{end}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
end
\end{minted}

\texttt{end} marks the conclusion of a block of expressions, for example \hyperlink{16285380181904025577}{\texttt{module}}, \hyperlink{4119979838407461137}{\texttt{struct}}, \hyperlink{15383430693516362700}{\texttt{mutable struct}}, \hyperlink{2050903905813838256}{\texttt{begin}}, \hyperlink{4956741936243461891}{\texttt{let}}, \hyperlink{9105224580875818383}{\texttt{for}} etc. \texttt{end} may also be used when indexing into an array to represent the last index of a dimension.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> A[end, :]
2-element Array{Int64,1}:
 3
 4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L630-L651}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4956741936243461891}{} 
\hyperlink{4956741936243461891}{\texttt{let}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
let
\end{minted}

\texttt{let} statements allocate new variable bindings each time they run. Whereas an assignment modifies an existing value location, \texttt{let} creates new locations. This difference is only detectable in the case of variables that outlive their scope via closures. The \texttt{let} syntax accepts a comma-separated series of assignments and variable names:


\begin{minted}{julia}
let var1 = value1, var2, var3 = value3
    code
end
\end{minted}

The assignments are evaluated in order, with each right-hand side evaluated in the scope before the new variable on the left-hand side has been introduced. Therefore it makes sense to write something like \texttt{let x = x}, since the two \texttt{x} variables are distinct and have separate storage.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L311-L329}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11624168233949720742}{} 
\hyperlink{11624168233949720742}{\texttt{if}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
if/elseif/else
\end{minted}

\texttt{if}/\texttt{elseif}/\texttt{else} performs conditional evaluation, which allows portions of code to be evaluated or not evaluated depending on the value of a boolean expression. Here is the anatomy of the \texttt{if}/\texttt{elseif}/\texttt{else} conditional syntax:


\begin{minted}{julia}
if x < y
    println("x is less than y")
elseif x > y
    println("x is greater than y")
else
    println("x is equal to y")
end
\end{minted}

If the condition expression \texttt{x < y} is true, then the corresponding block is evaluated; otherwise the condition expression \texttt{x > y} is evaluated, and if it is true, the corresponding block is evaluated; if neither expression is true, the \texttt{else} block is evaluated. The \texttt{elseif} and \texttt{else} blocks are optional, and as many \texttt{elseif} blocks as desired can be used.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L564-L585}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9105224580875818383}{} 
\hyperlink{9105224580875818383}{\texttt{for}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
for
\end{minted}

\texttt{for} loops repeatedly evaluate a block of statements while iterating over a sequence of values.

\textbf{Examples}


\begin{minted}{jlcon}
julia> for i in [1, 4, 0]
           println(i)
       end
1
4
0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L588-L603}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15133348314455964692}{} 
\hyperlink{15133348314455964692}{\texttt{while}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
while
\end{minted}

\texttt{while} loops repeatedly evaluate a conditional expression, and continue evaluating the body of the while loop as long as the expression remains true. If the condition expression is false when the while loop is first reached, the body is never evaluated.

\textbf{Examples}


\begin{minted}{jlcon}
julia> i = 1
1

julia> while i < 5
           println(i)
           global i += 1
       end
1
2
3
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L606-L627}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6474422097180568887}{} 
\hyperlink{6474422097180568887}{\texttt{break}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
break
\end{minted}

Break out of a loop immediately.

\textbf{Examples}


\begin{minted}{jlcon}
julia> i = 0
0

julia> while true
           global i += 1
           i > 5 && break
           println(i)
       end
1
2
3
4
5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L716-L737}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8191155978135871388}{} 
\hyperlink{8191155978135871388}{\texttt{continue}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
continue
\end{minted}

Skip the rest of the current loop iteration.

\textbf{Examples}


\begin{minted}{jlcon}
julia> for i = 1:6
           iseven(i) && continue
           println(i)
       end
1
3
5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L740-L755}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16338536928035025961}{} 
\hyperlink{16338536928035025961}{\texttt{try}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
try/catch
\end{minted}

A \texttt{try}/\texttt{catch} statement allows intercepting errors (exceptions) thrown by \hyperlink{16410366672587017456}{\texttt{throw}} so that program execution can continue. For example, the following code attempts to write a file, but warns the user and proceeds instead of terminating execution if the file cannot be written:


\begin{minted}{julia}
try
    open("/danger", "w") do f
        println(f, "Hello")
    end
catch
    @warn "Could not write file."
end
\end{minted}

or, when the file cannot be read into a variable:


\begin{minted}{julia}
lines = try
    open("/danger", "r") do f
        readlines(f)
    end
catch
    @warn "File not found."
end
\end{minted}

The syntax \texttt{catch e} (where \texttt{e} is any variable) assigns the thrown exception object to the given variable within the \texttt{catch} block.

The power of the \texttt{try}/\texttt{catch} construct lies in the ability to unwind a deeply nested computation immediately to a much higher level in the stack of calling functions.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L654-L689}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1444863245857684967}{} 
\hyperlink{1444863245857684967}{\texttt{finally}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
finally
\end{minted}

Run some code when a given block of code exits, regardless of how it exits. For example, here is how we can guarantee that an opened file is closed:


\begin{minted}{julia}
f = open("file")
try
    operate_on_file(f)
finally
    close(f)
end
\end{minted}

When control leaves the \hyperlink{16338536928035025961}{\texttt{try}} block (for example, due to a \hyperlink{10918908543132060605}{\texttt{return}}, or just finishing normally), \hyperlink{5331333469799487255}{\texttt{close(f)}} will be executed. If the \texttt{try} block exits due to an exception, the exception will continue propagating. A \texttt{catch} block may be combined with \texttt{try} and \texttt{finally} as well. In this case the \texttt{finally} block will run after \texttt{catch} has handled the error.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L692-L713}{\texttt{source}}


\end{adjustwidth}
\hypertarget{569926224232766960}{} 
\hyperlink{569926224232766960}{\texttt{quote}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
quote
\end{minted}

\texttt{quote} creates multiple expression objects in a block without using the explicit \hyperlink{17120496304147995299}{\texttt{Expr}} constructor. For example:


\begin{minted}{julia}
ex = quote
    x = 1
    y = 2
    x + y
end
\end{minted}

Unlike the other means of quoting, \texttt{:( ... )}, this form introduces \texttt{QuoteNode} elements to the expression tree, which must be considered when directly manipulating the tree. For other purposes, \texttt{:( ... )} and \texttt{quote .. end} blocks are treated identically.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L332-L348}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4330407494414118784}{} 
\hyperlink{4330407494414118784}{\texttt{local}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
local
\end{minted}

\texttt{local} introduces a new local variable. See the \hyperlink{11957539949537805757}{manual section on variable scoping} for more information.

\textbf{Examples}


\begin{minted}{jlcon}
julia> function foo(n)
           x = 0
           for i = 1:n
               local x # introduce a loop-local x
               x = i
           end
           x
       end
foo (generic function with 1 method)

julia> foo(10)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L176-L197}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15648176341806922625}{} 
\hyperlink{15648176341806922625}{\texttt{global}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
global
\end{minted}

\texttt{global x} makes \texttt{x} in the current scope and its inner scopes refer to the global variable of that name. See the \hyperlink{11957539949537805757}{manual section on variable scoping} for more information.

\textbf{Examples}


\begin{minted}{jlcon}
julia> z = 3
3

julia> function foo()
           global z = 6 # use the z variable defined outside foo
       end
foo (generic function with 1 method)

julia> foo()
6

julia> z
6
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L200-L223}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8421885763632484758}{} 
\hyperlink{8421885763632484758}{\texttt{const}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
const
\end{minted}

\texttt{const} is used to declare global variables whose values will not change. In almost all code (and particularly performance sensitive code) global variables should be declared constant in this way.


\begin{minted}{julia}
const x = 5
\end{minted}

Multiple variables can be declared within a single \texttt{const}:


\begin{minted}{julia}
const y, z = 7, 11
\end{minted}

Note that \texttt{const} only applies to one \texttt{=} operation, therefore \texttt{const x = y = 1} declares \texttt{x} to be constant but not \texttt{y}. On the other hand, \texttt{const x = const y = 1} declares both \texttt{x} and \texttt{y} constant.

Note that {\textquotedbl}constant-ness{\textquotedbl} does not extend into mutable containers; only the association between a variable and its value is constant. If \texttt{x} is an array or dictionary (for example) you can still modify, add, or remove elements.

In some cases changing the value of a \texttt{const} variable gives a warning instead of an error. However, this can produce unpredictable behavior or corrupt the state of your program, and so should be avoided. This feature is intended only for convenience during interactive use.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L467-L496}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4119979838407461137}{} 
\hyperlink{4119979838407461137}{\texttt{struct}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
struct
\end{minted}

The most commonly used kind of type in Julia is a struct, specified as a name and a set of fields.


\begin{minted}{julia}
struct Point
    x
    y
end
\end{minted}

Fields can have type restrictions, which may be parameterized:


\begin{minted}{julia}
struct Point{X}
    x::X
    y::Float64
end
\end{minted}

A struct can also declare an abstract super type via \texttt{<:} syntax:


\begin{minted}{julia}
struct Point <: AbstractPoint
    x
    y
end
\end{minted}

\texttt{struct}s are immutable by default; an instance of one of these types cannot be modified after construction. Use \hyperlink{15383430693516362700}{\texttt{mutable struct}} instead to declare a type whose instances can be modified.

See the manual section on \href{@ref}{Composite Types} for more details, such as how to define constructors.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L911-L948}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15383430693516362700}{} 
\hyperlink{15383430693516362700}{\texttt{mutable struct}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mutable struct
\end{minted}

\texttt{mutable struct} is similar to \hyperlink{4119979838407461137}{\texttt{struct}}, but additionally allows the fields of the type to be set after construction. See the manual section on \href{@ref}{Composite Types} for more information.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L951-L957}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12403756508738429935}{} 
\hyperlink{12403756508738429935}{\texttt{abstract type}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
abstract type
\end{minted}

\texttt{abstract type} declares a type that cannot be instantiated, and serves only as a node in the type graph, thereby describing sets of related concrete types: those concrete types which are their descendants. Abstract types form the conceptual hierarchy which makes Julia’s type system more than just a collection of object implementations. For example:


\begin{minted}{julia}
abstract type Number end
abstract type Real <: Number end
\end{minted}

\hyperlink{1990584313715697055}{\texttt{Number}} has no supertype, whereas \hyperlink{6175959395021454412}{\texttt{Real}} is an abstract subtype of \texttt{Number}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L59-L72}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7972868697479608081}{} 
\hyperlink{7972868697479608081}{\texttt{primitive type}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
primitive type
\end{minted}

\texttt{primitive type} declares a concrete type whose data consists only of a series of bits. Classic examples of primitive types are integers and floating-point values. Some example built-in primitive type declarations:


\begin{minted}{julia}
primitive type Char 32 end
primitive type Bool <: Integer 8 end
\end{minted}

The number after the name indicates how many bits of storage the type requires. Currently, only sizes that are multiples of 8 bits are supported. The \hyperlink{46725311238864537}{\texttt{Bool}} declaration shows how a primitive type can be optionally declared to be a subtype of some supertype.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L134-L149}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7395867868929900722}{} 
\hyperlink{7395867868929900722}{\texttt{where}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
where
\end{minted}

The \texttt{where} keyword creates a type that is an iterated union of other types, over all values of some variable. For example \texttt{Vector\{T\} where T<:Real} includes all \hyperlink{10571362059486397014}{\texttt{Vector}}s where the element type is some kind of \texttt{Real} number.

The variable bound defaults to \hyperlink{15014186392807667022}{\texttt{Any}} if it is omitted:


\begin{minted}{julia}
Vector{T} where T    # short for `where T<:Any`
\end{minted}

Variables can also have lower bounds:


\begin{minted}{julia}
Vector{T} where T>:Int
Vector{T} where Int<:T<:Real
\end{minted}

There is also a concise syntax for nested \texttt{where} expressions. For example, this:


\begin{minted}{julia}
Pair{T, S} where S<:Array{T} where T<:Number
\end{minted}

can be shortened to:


\begin{minted}{julia}
Pair{T, S} where {T<:Number, S<:Array{T}}
\end{minted}

This form is often found on method signatures.

Note that in this form, the variables are listed outermost-first. This matches the order in which variables are substituted when a type is {\textquotedbl}applied{\textquotedbl} to parameter values using the syntax \texttt{T\{p1, p2, ...\}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L970-L1003}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4851239593686894811}{} 
\hyperlink{4851239593686894811}{\texttt{...}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
...
\end{minted}

The {\textquotedbl}splat{\textquotedbl} operator, \texttt{...}, represents a sequence of arguments. \texttt{...} can be used in function definitions, to indicate that the function accepts an arbitrary number of arguments. \texttt{...} can also be used to apply a function to a sequence of arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> add(xs...) = reduce(+, xs)
add (generic function with 1 method)

julia> add(1, 2, 3, 4, 5)
15

julia> add([1, 2, 3]...)
6

julia> add(7, 1:100..., 1000:1100...)
111107
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L783-L805}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13353096094479374008}{} 
\hyperlink{13353096094479374008}{\texttt{;}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
;
\end{minted}

\texttt{;} has a similar role in Julia as in many C-like languages, and is used to delimit the end of the previous statement. \texttt{;} is not necessary after new lines, but can be used to separate statements on a single line or to join statements into a single expression. \texttt{;} is also used to suppress output printing in the REPL and similar interfaces.

\textbf{Examples}


\begin{minted}{julia}
julia> function foo()
           x = "Hello, "; x *= "World!"
           return x
       end
foo (generic function with 1 method)

julia> bar() = (x = "Hello, Mars!"; return x)
bar (generic function with 1 method)

julia> foo();

julia> bar()
"Hello, Mars!"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L808-L832}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6802539926897218580}{} 
\hyperlink{6802539926897218580}{\texttt{=}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
=
\end{minted}

\texttt{=} is the assignment operator.

\begin{itemize}
\item For variable \texttt{a} and expression \texttt{b}, \texttt{a = b} makes \texttt{a} refer to the value of \texttt{b}.


\item For functions \texttt{f(x)}, \texttt{f(x) = x} defines a new function constant \texttt{f}, or adds a new method to \texttt{f} if \texttt{f} is already defined; this usage is equivalent to \texttt{function f(x); x; end}.


\item \texttt{a[i] = v} calls \hyperlink{1309244355901386657}{\texttt{setindex!}}\texttt{(a,v,i)}.


\item \texttt{a.b = c} calls \hyperlink{9055518433069578344}{\texttt{setproperty!}}\texttt{(a,:b,c)}.


\item Inside a function call, \texttt{f(a=b)} passes \texttt{b} as the value of keyword argument \texttt{a}.


\item Inside parentheses with commas, \texttt{(a=1,)} constructs a \hyperlink{3845731488275720657}{\texttt{NamedTuple}}.

\end{itemize}
\textbf{Examples}

Assigning \texttt{a} to \texttt{b} does not create a copy of \texttt{b}; instead use \hyperlink{15665284441316555522}{\texttt{copy}} or \hyperlink{3259459540194502889}{\texttt{deepcopy}}.


\begin{minted}{jlcon}
julia> b = [1]; a = b; b[1] = 2; a
1-element Array{Int64,1}:
 2

julia> b = [1]; a = copy(b); b[1] = 2; a
1-element Array{Int64,1}:
 1

\end{minted}

Collections passed to functions are also not copied. Functions can modify (mutate) the contents of the objects their arguments refer to. (The names of functions which do this are conventionally suffixed with {\textquotesingle}!{\textquotesingle}.)


\begin{minted}{jlcon}
julia> function f!(x); x[:] .+= 1; end
f! (generic function with 1 method)

julia> a = [1]; f!(a); a
1-element Array{Int64,1}:
 2

\end{minted}

Assignment can operate on multiple variables in parallel, taking values from an iterable:


\begin{minted}{jlcon}
julia> a, b = 4, 5
(4, 5)

julia> a, b = 1:3
1:3

julia> a, b
(1, 2)

\end{minted}

Assignment can operate on multiple variables in series, and will return the value of the right-hand-most expression:


\begin{minted}{jlcon}
julia> a = [1]; b = [2]; c = [3]; a = b = c
1-element Array{Int64,1}:
 3

julia> b[1] = 2; a, b, c
([2], [2], [2])

\end{minted}

Assignment at out-of-bounds indices does not grow a collection. If the collection is a \hyperlink{10571362059486397014}{\texttt{Vector}} it can instead be grown with \hyperlink{18026893834387542681}{\texttt{push!}} or \hyperlink{2587432243763606566}{\texttt{append!}}.


\begin{minted}{jlcon}
julia> a = [1, 1]; a[3] = 2
ERROR: BoundsError: attempt to access 2-element Array{Int64,1} at index [3]
[...]

julia> push!(a, 2, 3)
4-element Array{Int64,1}:
 1
 1
 2
 3

\end{minted}

Assigning \texttt{[]} does not eliminate elements from a collection; instead use \hyperlink{3384092630307389071}{\texttt{filter!}}.


\begin{minted}{jlcon}
julia> a = collect(1:3); a[a .<= 1] = []
ERROR: DimensionMismatch("tried to assign 0 elements to 1 destinations")
[...]

julia> filter!(x -> x > 1, a) # in-place & thus more efficient than a = a[a .> 1]
2-element Array{Int64,1}:
 2
 3

\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L226-L308}{\texttt{source}}


\end{adjustwidth}

\hypertarget{128695592908019721}{}


\section{Standard Modules}


\hypertarget{7094459820733568273}{} 
\hyperlink{7094459820733568273}{\texttt{Main}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Main
\end{minted}

\texttt{Main} is the top-level module, and Julia starts with \texttt{Main} set as the current module.  Variables defined at the prompt go in \texttt{Main}, and \texttt{varinfo} lists variables in \texttt{Main}.


\begin{minted}{jlcon}
julia> @__MODULE__
Main
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2335-L2343}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14876339894285762624}{} 
\hyperlink{14876339894285762624}{\texttt{Core}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Core
\end{minted}

\texttt{Core} is the module that contains all identifiers considered {\textquotedbl}built in{\textquotedbl} to the language, i.e. part of the core language and not libraries. Every module implicitly specifies \texttt{using Core}, since you can{\textquotesingle}t do anything without those definitions.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2328-L2332}{\texttt{source}}


\end{adjustwidth}
\hypertarget{464144976511314225}{} 
\hyperlink{464144976511314225}{\texttt{Base}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base
\end{minted}

The base library of Julia. \texttt{Base} is a module that contains basic functionality (the contents of \texttt{base/}). All modules implicitly contain \texttt{using Base}, since this is needed in the vast majority of cases.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2346-L2350}{\texttt{source}}


\end{adjustwidth}

\hypertarget{5508136195995469038}{}


\section{Base Submodules}


\hypertarget{9799306936683713029}{} 
\hyperlink{9799306936683713029}{\texttt{Base.Broadcast}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.Broadcast
\end{minted}

Module containing the broadcasting implementation.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/broadcast.jl#L3-L7}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1765705340642413832}{} 
\hyperlink{1765705340642413832}{\texttt{Base.Docs}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Docs
\end{minted}

The \texttt{Docs} module provides the \texttt{@doc} macro which can be used to set and retrieve documentation metadata for Julia objects.

Please see the manual section on documentation for more information.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/Docs.jl#L3-L11}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12000006282392952693}{} 
\hyperlink{12000006282392952693}{\texttt{Base.Iterators}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}

Methods for working with Iterators.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L3-L5}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3335410005884556492}{} 
\hyperlink{3335410005884556492}{\texttt{Base.Libc}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}

Interface to libc, the C standard library.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L4-L6}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8471843084197669597}{} 
\hyperlink{8471843084197669597}{\texttt{Base.Meta}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}

Convenience functions for metaprogramming.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/meta.jl#L3-L5}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6478309095911256465}{} 
\hyperlink{6478309095911256465}{\texttt{Base.StackTraces}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}

Tools for collecting and manipulating stack traces. Mainly used for building errors.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stacktraces.jl#L3-L5}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4151026031590153569}{} 
\hyperlink{4151026031590153569}{\texttt{Base.Sys}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}

Provide methods for retrieving information about hardware and the operating system.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L4-L6}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3241995235349190465}{} 
\hyperlink{3241995235349190465}{\texttt{Base.Threads}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}

Experimental multithreading support.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/threads.jl#L3-L5}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9832907666069494090}{} 
\hyperlink{9832907666069494090}{\texttt{Base.GC}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.GC
\end{minted}

Module with garbage collection utilities.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/gcutils.jl#L45-L49}{\texttt{source}}


\end{adjustwidth}

\hypertarget{17640924221043151492}{}


\section{All Objects}


\hypertarget{7974744969331231272}{} 
\hyperlink{7974744969331231272}{\texttt{Core.:===}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
===(x,y) -> Bool
≡(x,y) -> Bool
\end{minted}

Determine whether \texttt{x} and \texttt{y} are identical, in the sense that no program could distinguish them. First the types of \texttt{x} and \texttt{y} are compared. If those are identical, mutable objects are compared by address in memory and immutable objects (such as numbers) are compared by contents at the bit level. This function is sometimes called {\textquotedbl}egal{\textquotedbl}. It always returns a \texttt{Bool} value.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1, 2]; b = [1, 2];

julia> a == b
true

julia> a === b
false

julia> a === a
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L196-L219}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7066325108767373297}{} 
\hyperlink{7066325108767373297}{\texttt{Core.isa}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isa(x, type) -> Bool
\end{minted}

Determine whether \texttt{x} is of the given \texttt{type}. Can also be used as an infix operator, e.g. \texttt{x isa type}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isa(1, Int)
true

julia> isa(1, Matrix)
false

julia> isa(1, Char)
false

julia> isa(1, Number)
true

julia> 1 isa Number
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1414-L1437}{\texttt{source}}


\end{adjustwidth}
\hypertarget{269533589463185031}{} 
\hyperlink{269533589463185031}{\texttt{Base.isequal}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isequal(x, y)
\end{minted}

Similar to \hyperlink{15143149452920304570}{\texttt{==}}, except for the treatment of floating point numbers and of missing values. \texttt{isequal} treats all floating-point \texttt{NaN} values as equal to each other, treats \texttt{-0.0} as unequal to \texttt{0.0}, and \hyperlink{14596725676261444434}{\texttt{missing}} as equal to \texttt{missing}. Always returns a \texttt{Bool} value.

\textbf{Implementation}

The default implementation of \texttt{isequal} calls \texttt{==}, so a type that does not involve floating-point values generally only needs to define \texttt{==}.

\texttt{isequal} is the comparison function used by hash tables (\texttt{Dict}). \texttt{isequal(x,y)} must imply that \texttt{hash(x) == hash(y)}.

This typically means that types for which a custom \texttt{==} or \texttt{isequal} method exists must implement a corresponding \texttt{hash} method (and vice versa). Collections typically implement \texttt{isequal} by calling \texttt{isequal} recursively on all contents.

Scalar types generally do not need to implement \texttt{isequal} separate from \texttt{==}, unless they represent floating-point numbers amenable to a more efficient implementation than that provided as a generic fallback (based on \texttt{isnan}, \texttt{signbit}, and \texttt{==}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> isequal([1., NaN], [1., NaN])
true

julia> [1., NaN] == [1., NaN]
false

julia> 0.0 == -0.0
true

julia> isequal(0.0, -0.0)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L85-L122}{\texttt{source}}



\begin{lstlisting}
isequal(x)
\end{lstlisting}

Create a function that compares its argument to \texttt{x} using \hyperlink{269533589463185031}{\texttt{isequal}}, i.e. a function equivalent to \texttt{y -> isequal(y, x)}.

The returned function is of type \texttt{Base.Fix2\{typeof(isequal)\}}, which can be used to implement specialized methods.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L916-L924}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8062916604071842790}{} 
\hyperlink{8062916604071842790}{\texttt{Base.isless}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isless(x, y)
\end{minted}

Test whether \texttt{x} is less than \texttt{y}, according to a fixed total order. \texttt{isless} is not defined on all pairs of values \texttt{(x, y)}. However, if it is defined, it is expected to satisfy the following:

\begin{itemize}
\item If \texttt{isless(x, y)} is defined, then so is \texttt{isless(y, x)} and \texttt{isequal(x, y)}, and exactly one of those three yields \texttt{true}.


\item The relation defined by \texttt{isless} is transitive, i.e., \texttt{isless(x, y) \&\& isless(y, z)} implies \texttt{isless(x, z)}.

\end{itemize}
Values that are normally unordered, such as \texttt{NaN}, are ordered in an arbitrary but consistent fashion. \hyperlink{14596725676261444434}{\texttt{missing}} values are ordered last.

This is the default comparison used by \hyperlink{8473525809131227606}{\texttt{sort}}.

\textbf{Implementation}

Non-numeric types with a total order should implement this function. Numeric types only need to implement it if they have special values such as \texttt{NaN}. Types with a partial order should implement \hyperlink{702782232449268329}{\texttt{<}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L132-L153}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12785896617485598962}{} 
\hyperlink{12785896617485598962}{\texttt{Core.ifelse}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ifelse(condition::Bool, x, y)
\end{minted}

Return \texttt{x} if \texttt{condition} is \texttt{true}, otherwise return \texttt{y}. This differs from \texttt{?} or \texttt{if} in that it is an ordinary function, so all the arguments are evaluated first. In some cases, using \texttt{ifelse} instead of an \texttt{if} statement can eliminate the branch in generated code and provide higher performance in tight loops.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ifelse(1 > 2, 1, 2)
2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L348-L361}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11044636010338290257}{} 
\hyperlink{11044636010338290257}{\texttt{Core.typeassert}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
typeassert(x, type)
\end{minted}

Throw a \hyperlink{2622693721821893139}{\texttt{TypeError}} unless \texttt{x isa type}. The syntax \texttt{x::type} calls this function.

\textbf{Examples}


\begin{minted}{jlcon}
julia> typeassert(2.5, Int)
ERROR: TypeError: in typeassert, expected Int64, got Float64
Stacktrace:
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2227-L2240}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13440452181855594120}{} 
\hyperlink{13440452181855594120}{\texttt{Core.typeof}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
typeof(x)
\end{minted}

Get the concrete type of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = 1//2;

julia> typeof(a)
Rational{Int64}

julia> M = [1 2; 3.5 4];

julia> typeof(M)
Array{Float64,2}
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1667-L1684}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12342862450082530092}{} 
\hyperlink{12342862450082530092}{\texttt{Core.tuple}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tuple(xs...)
\end{minted}

Construct a tuple of the given objects.

\textbf{Examples}


\begin{minted}{jlcon}
julia> tuple(1, 'a', pi)
(1, 'a', π)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1601-L1611}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11196859324054101444}{} 
\hyperlink{11196859324054101444}{\texttt{Base.ntuple}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ntuple(f::Function, n::Integer)
\end{minted}

Create a tuple of length \texttt{n}, computing each element as \texttt{f(i)}, where \texttt{i} is the index of the element.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ntuple(i -> 2*i, 4)
(2, 4, 6, 8)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ntuple.jl#L5-L16}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9461762562299643141}{} 
\hyperlink{9461762562299643141}{\texttt{Base.objectid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
objectid(x)
\end{minted}

Get a hash value for \texttt{x} based on object identity. \texttt{objectid(x)==objectid(y)} if \texttt{x === y}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L307-L311}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13797072367283572032}{} 
\hyperlink{13797072367283572032}{\texttt{Base.hash}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hash(x[, h::UInt])
\end{minted}

Compute an integer hash code such that \texttt{isequal(x,y)} implies \texttt{hash(x)==hash(y)}. The optional second argument \texttt{h} is a hash code to be mixed with the result.

New types should implement the 2-argument form, typically by calling the 2-argument \texttt{hash} method recursively in order to mix hashes of the contents with each other (and with \texttt{h}). Typically, any type that implements \texttt{hash} should also implement its own \texttt{==} (hence \texttt{isequal}) to guarantee the property mentioned above. Types supporting subtraction (operator \texttt{-}) should also implement \hyperlink{18091106262785739128}{\texttt{widen}}, which is required to hash values inside heterogeneous arrays.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/hashing.jl#L5-L17}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4805357059330171046}{} 
\hyperlink{4805357059330171046}{\texttt{Base.finalizer}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
finalizer(f, x)
\end{minted}

Register a function \texttt{f(x)} to be called when there are no program-accessible references to \texttt{x}, and return \texttt{x}. The type of \texttt{x} must be a \texttt{mutable struct}, otherwise the behavior of this function is unpredictable.

\texttt{f} must not cause a task switch, which excludes most I/O operations such as \texttt{println}. \texttt{@schedule println({\textquotedbl}message{\textquotedbl})} or \texttt{ccall(:jl\_, Cvoid, (Any,), {\textquotedbl}message{\textquotedbl})} may be helpful for debugging purposes.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/gcutils.jl#L7-L17}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6584919147438336166}{} 
\hyperlink{6584919147438336166}{\texttt{Base.finalize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
finalize(x)
\end{minted}

Immediately run finalizers registered for object \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/gcutils.jl#L37-L41}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15665284441316555522}{} 
\hyperlink{15665284441316555522}{\texttt{Base.copy}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
copy(x)
\end{minted}

Create a shallow copy of \texttt{x}: the outer structure is copied, but not all internal values. For example, copying an array produces a new array with identically-same elements as the original.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L343-L349}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3259459540194502889}{} 
\hyperlink{3259459540194502889}{\texttt{Base.deepcopy}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
deepcopy(x)
\end{minted}

Create a deep copy of \texttt{x}: everything is copied recursively, resulting in a fully independent object. For example, deep-copying an array produces a new array whose elements are deep copies of the original elements. Calling \texttt{deepcopy} on an object should generally have the same effect as serializing and then deserializing it.

While it isn{\textquotesingle}t normally necessary, user-defined types can override the default \texttt{deepcopy} behavior by defining a specialized version of the function \texttt{deepcopy\_internal(x::T, dict::IdDict)} (which shouldn{\textquotesingle}t otherwise be used), where \texttt{T} is the type to be specialized for, and \texttt{dict} keeps track of objects copied so far within the recursion. Within the definition, \texttt{deepcopy\_internal} should be used in place of \texttt{deepcopy}, and the \texttt{dict} variable should be updated as appropriate before returning.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/deepcopy.jl#L8-L23}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11040282462516403506}{} 
\hyperlink{11040282462516403506}{\texttt{Base.getproperty}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getproperty(value, name::Symbol)
\end{minted}

The syntax \texttt{a.b} calls \texttt{getproperty(a, :b)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> struct MyType
           x
       end

julia> function Base.getproperty(obj::MyType, sym::Symbol)
           if sym === :special
               return obj.x + 1
           else # fallback to getfield
               return getfield(obj, sym)
           end
       end

julia> obj = MyType(1);

julia> obj.special
2

julia> obj.x
1
\end{minted}

See also \hyperlink{9156534253458520177}{\texttt{propertynames}} and \hyperlink{9055518433069578344}{\texttt{setproperty!}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2243-L2273}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9055518433069578344}{} 
\hyperlink{9055518433069578344}{\texttt{Base.setproperty!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
setproperty!(value, name::Symbol, x)
\end{minted}

The syntax \texttt{a.b = c} calls \texttt{setproperty!(a, :b, c)}.

See also \hyperlink{9156534253458520177}{\texttt{propertynames}} and \hyperlink{11040282462516403506}{\texttt{getproperty}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2276-L2283}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9156534253458520177}{} 
\hyperlink{9156534253458520177}{\texttt{Base.propertynames}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
propertynames(x, private=false)
\end{minted}

Get a tuple or a vector of the properties (\texttt{x.property}) of an object \texttt{x}. This is typically the same as \hyperlink{17481253338332315021}{\texttt{fieldnames(typeof(x))}}, but types that overload \hyperlink{11040282462516403506}{\texttt{getproperty}} should generally overload \texttt{propertynames} as well to get the properties of an instance of the type.

\texttt{propertynames(x)} may return only {\textquotedbl}public{\textquotedbl} property names that are part of the documented interface of \texttt{x}.   If you want it to also return {\textquotedbl}private{\textquotedbl} fieldnames intended for internal use, pass \texttt{true} for the optional second argument. REPL tab completion on \texttt{x.} shows only the \texttt{private=false} properties.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L1348-L1360}{\texttt{source}}


\end{adjustwidth}
\hypertarget{754956111730806889}{} 
\hyperlink{754956111730806889}{\texttt{Base.hasproperty}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hasproperty(x, s::Symbol)
\end{minted}

Return a boolean indicating whether the object \texttt{x} has \texttt{s} as one of its own properties.

\begin{quote}
\textbf{Julia 1.2}

This function requires at least Julia 1.2.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L1365-L1372}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13312214354258464709}{} 
\hyperlink{13312214354258464709}{\texttt{Core.getfield}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getfield(value, name::Symbol)
getfield(value, i::Int)
\end{minted}

Extract a field from a composite \texttt{value} by name or position. See also \hyperlink{11040282462516403506}{\texttt{getproperty}} and \hyperlink{17481253338332315021}{\texttt{fieldnames}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = 1//2
1//2

julia> getfield(a, :num)
1

julia> a.num
1

julia> getfield(a, 1)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1614-L1635}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11796708313392299971}{} 
\hyperlink{11796708313392299971}{\texttt{Core.setfield!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
setfield!(value, name::Symbol, x)
\end{minted}

Assign \texttt{x} to a named field in \texttt{value} of composite type. The \texttt{value} must be mutable and \texttt{x} must be a subtype of \texttt{fieldtype(typeof(value), name)}. See also \hyperlink{9055518433069578344}{\texttt{setproperty!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> mutable struct MyMutableStruct
           field::Int
       end

julia> a = MyMutableStruct(1);

julia> setfield!(a, :field, 2);

julia> getfield(a, :field)
2

julia> a = 1//2
1//2

julia> setfield!(a, :num, 3);
ERROR: setfield! immutable struct of type Rational cannot be changed
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1638-L1664}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11212950246505288748}{} 
\hyperlink{11212950246505288748}{\texttt{Core.isdefined}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isdefined(m::Module, s::Symbol)
isdefined(object, s::Symbol)
isdefined(object, index::Int)
\end{minted}

Tests whether a global variable or object field is defined. The arguments can be a module and a symbol or a composite object and field name (as a symbol) or index.

To test whether an array element is defined, use \hyperlink{976355747478401147}{\texttt{isassigned}} instead.

See also \hyperlink{3530198890456603420}{\texttt{@isdefined}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isdefined(Base, :sum)
true

julia> isdefined(Base, :NonExistentMethod)
false

julia> a = 1//2;

julia> isdefined(a, 2)
true

julia> isdefined(a, 3)
false

julia> isdefined(a, :num)
true

julia> isdefined(a, :numerator)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1687-L1721}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3530198890456603420}{} 
\hyperlink{3530198890456603420}{\texttt{Base.@isdefined}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@isdefined s -> Bool
\end{minted}

Tests whether variable \texttt{s} is defined in the current scope.

See also \hyperlink{11212950246505288748}{\texttt{isdefined}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> function f()
           println(@isdefined x)
           x = 3
           println(@isdefined x)
       end
f (generic function with 1 method)

julia> f()
false
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L243-L263}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1846942650946171605}{} 
\hyperlink{1846942650946171605}{\texttt{Base.convert}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
convert(T, x)
\end{minted}

Convert \texttt{x} to a value of type \texttt{T}.

If \texttt{T} is an \hyperlink{8469131683393450448}{\texttt{Integer}} type, an \hyperlink{5399118524830636312}{\texttt{InexactError}} will be raised if \texttt{x} is not representable by \texttt{T}, for example if \texttt{x} is not integer-valued, or is outside the range supported by \texttt{T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> convert(Int, 3.0)
3

julia> convert(Int, 3.5)
ERROR: InexactError: Int64(3.5)
Stacktrace:
[...]
\end{minted}

If \texttt{T} is a \hyperlink{11465394427882483091}{\texttt{AbstractFloat}} or \hyperlink{8304566144531167610}{\texttt{Rational}} type, then it will return the closest value to \texttt{x} representable by \texttt{T}.


\begin{minted}{jlcon}
julia> x = 1/3
0.3333333333333333

julia> convert(Float32, x)
0.33333334f0

julia> convert(Rational{Int32}, x)
1//3

julia> convert(Rational{Int64}, x)
6004799503160661//18014398509481984
\end{minted}

If \texttt{T} is a collection type and \texttt{x} a collection, the result of \texttt{convert(T, x)} may alias all or part of \texttt{x}.


\begin{minted}{jlcon}
julia> x = Int[1, 2, 3];

julia> y = convert(Vector{Int}, x);

julia> y === x
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L119-L166}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1760874576431605095}{} 
\hyperlink{1760874576431605095}{\texttt{Base.promote}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
promote(xs...)
\end{minted}

Convert all arguments to a common type, and return them all (as a tuple). If no arguments can be converted, an error is raised.

\textbf{Examples}


\begin{minted}{jlcon}
julia> promote(Int8(1), Float16(4.5), Float32(4.1))
(1.0f0, 4.5f0, 4.1f0)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/promotion.jl#L242-L253}{\texttt{source}}


\end{adjustwidth}
\hypertarget{374166931194490566}{} 
\hyperlink{374166931194490566}{\texttt{Base.oftype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
oftype(x, y)
\end{minted}

Convert \texttt{y} to the type of \texttt{x} (\texttt{convert(typeof(x), y)}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = 4;

julia> y = 3.;

julia> oftype(x, y)
3

julia> oftype(y, x)
4.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L351-L368}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18091106262785739128}{} 
\hyperlink{18091106262785739128}{\texttt{Base.widen}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
widen(x)
\end{minted}

If \texttt{x} is a type, return a {\textquotedbl}larger{\textquotedbl} type, defined so that arithmetic operations \texttt{+} and \texttt{-} are guaranteed not to overflow nor lose precision for any combination of values that type \texttt{x} can hold.

For fixed-size integer types less than 128 bits, \texttt{widen} will return a type with twice the number of bits.

If \texttt{x} is a value, it is converted to \texttt{widen(typeof(x))}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> widen(Int32)
Int64

julia> widen(1.5f0)
1.5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L786-L806}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18150582836499084779}{} 
\hyperlink{18150582836499084779}{\texttt{Base.identity}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
identity(x)
\end{minted}

The identity function. Returns its argument.

\textbf{Examples}


\begin{minted}{jlcon}
julia> identity("Well, what did you expect?")
"Well, what did you expect?"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L491-L501}{\texttt{source}}


\end{adjustwidth}

\hypertarget{3637915929986814863}{}


\section{Properties of Types}



\hypertarget{12208529669326883573}{}


\subsection{Type relations}


\hypertarget{12192788431675298651}{} 
\hyperlink{12192788431675298651}{\texttt{Base.supertype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
supertype(T::DataType)
\end{minted}

Return the supertype of DataType \texttt{T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> supertype(Int32)
Signed
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L32-L42}{\texttt{source}}


\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Core.Type}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}


\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Core.DataType}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{6254591906563366276}{} 
\hyperlink{6254591906563366276}{\texttt{Core.:<:}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
<:(T1, T2)
\end{minted}

Subtype operator: returns \texttt{true} if and only if all values of type \texttt{T1} are also of type \texttt{T2}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Float64 <: AbstractFloat
true

julia> Vector{Int} <: AbstractArray
true

julia> Matrix{Float64} <: Matrix{AbstractFloat}
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L5-L22}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13074915255343859584}{} 
\hyperlink{13074915255343859584}{\texttt{Base.:>:}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
>:(T1, T2)
\end{minted}

Supertype operator, equivalent to \texttt{T2 <: T1}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L25-L29}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6895589781245489183}{} 
\hyperlink{6895589781245489183}{\texttt{Base.typejoin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
typejoin(T, S)
\end{minted}

Return the closest common ancestor of \texttt{T} and \texttt{S}, i.e. the narrowest type from which they both inherit.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/promotion.jl#L5-L11}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1869272868531275554}{} 
\hyperlink{1869272868531275554}{\texttt{Base.typeintersect}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
typeintersect(T, S)
\end{minted}

Compute a type that contains the intersection of \texttt{T} and \texttt{S}. Usually this will be the smallest such type or one close to it.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L587-L592}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15048881762587391286}{} 
\hyperlink{15048881762587391286}{\texttt{Base.promote\_type}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
promote_type(type1, type2)
\end{minted}

Promotion refers to converting values of mixed types to a single common type. \texttt{promote\_type} represents the default promotion behavior in Julia when operators (usually mathematical) are given arguments of differing types. \texttt{promote\_type} generally tries to return a type which can at least approximate most values of either input type without excessively widening.  Some loss is tolerated; for example, \texttt{promote\_type(Int64, Float64)} returns \hyperlink{5027751419500983000}{\texttt{Float64}} even though strictly, not all \hyperlink{7720564657383125058}{\texttt{Int64}} values can be represented exactly as \texttt{Float64} values.


\begin{minted}{jlcon}
julia> promote_type(Int64, Float64)
Float64

julia> promote_type(Int32, Int64)
Int64

julia> promote_type(Float32, BigInt)
BigFloat

julia> promote_type(Int16, Float16)
Float16

julia> promote_type(Int64, Float16)
Float16

julia> promote_type(Int8, UInt16)
UInt16
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/promotion.jl#L173-L204}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16547112220540026290}{} 
\hyperlink{16547112220540026290}{\texttt{Base.promote\_rule}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
promote_rule(type1, type2)
\end{minted}

Specifies what type should be used by \hyperlink{1760874576431605095}{\texttt{promote}} when given values of types \texttt{type1} and \texttt{type2}. This function should not be called directly, but should have definitions added to it for new types as appropriate.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/promotion.jl#L226-L232}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7941351778625214321}{} 
\hyperlink{7941351778625214321}{\texttt{Base.isdispatchtuple}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isdispatchtuple(T)
\end{minted}

Determine whether type \texttt{T} is a tuple {\textquotedbl}leaf type{\textquotedbl}, meaning it could appear as a type signature in dispatch and has no subtypes (or supertypes) which could appear in a call.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L482-L488}{\texttt{source}}


\end{adjustwidth}

\hypertarget{5044551426260747944}{}


\subsection{Declared structure}



\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Base.ismutable}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{13869545361033105546}{} 
\hyperlink{13869545361033105546}{\texttt{Base.isimmutable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isimmutable(v) -> Bool
\end{minted}

Return \texttt{true} iff value \texttt{v} is immutable.  See \href{@ref}{Mutable Composite Types} for a discussion of immutability. Note that this function works on values, so if you give it a type, it will tell you that a value of \texttt{DataType} is mutable.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isimmutable(1)
true

julia> isimmutable([1,2])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L404-L419}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5418736735412668772}{} 
\hyperlink{5418736735412668772}{\texttt{Base.isabstracttype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isabstracttype(T)
\end{minted}

Determine whether type \texttt{T} was declared as an abstract type (i.e. using the \texttt{abstract} keyword).

\textbf{Examples}


\begin{minted}{jlcon}
julia> isabstracttype(AbstractArray)
true

julia> isabstracttype(Vector)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L532-L546}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4186582503402156523}{} 
\hyperlink{4186582503402156523}{\texttt{Base.isprimitivetype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isprimitivetype(T) -> Bool
\end{minted}

Determine whether type \texttt{T} was declared as a primitive type (i.e. using the \texttt{primitive} keyword).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L437-L442}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1553131089235872077}{} 
\hyperlink{1553131089235872077}{\texttt{Base.issingletontype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.issingletontype(T)
\end{minted}

Determine whether type \texttt{T} has exactly one possible instance; for example, a struct type with no fields.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L554-L559}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16402814804737397668}{} 
\hyperlink{16402814804737397668}{\texttt{Base.isstructtype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isstructtype(T) -> Bool
\end{minted}

Determine whether type \texttt{T} was declared as a struct type (i.e. using the \texttt{struct} or \texttt{mutable struct} keyword).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L422-L427}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1199014503871893996}{} 
\hyperlink{1199014503871893996}{\texttt{Base.nameof}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nameof(t::DataType) -> Symbol
\end{minted}

Get the name of a (potentially \texttt{UnionAll}-wrapped) \texttt{DataType} (without its parent module) as a symbol.

\textbf{Examples}


\begin{minted}{jlcon}
julia> module Foo
           struct S{T}
           end
       end
Foo

julia> nameof(Foo.S{T} where T)
:S
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L192-L209}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17481253338332315021}{} 
\hyperlink{17481253338332315021}{\texttt{Base.fieldnames}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fieldnames(x::DataType)
\end{minted}

Get a tuple with the names of the fields of a \texttt{DataType}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> fieldnames(Rational)
(:num, :den)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L161-L171}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3835503835621011695}{} 
\hyperlink{3835503835621011695}{\texttt{Base.fieldname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fieldname(x::DataType, i::Integer)
\end{minted}

Get the name of field \texttt{i} of a \texttt{DataType}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> fieldname(Rational, 1)
:num

julia> fieldname(Rational, 2)
:den
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L131-L144}{\texttt{source}}


\end{adjustwidth}
\hypertarget{742071551420127681}{} 
\hyperlink{742071551420127681}{\texttt{Base.hasfield}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hasfield(T::Type, name::Symbol)
\end{minted}

Return a boolean indicating whether \texttt{T} has \texttt{name} as one of its own fields.

\begin{quote}
\textbf{Julia 1.2}

This function requires at least Julia 1.2.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L179-L186}{\texttt{source}}


\end{adjustwidth}

\hypertarget{822312099330602815}{}


\subsection{Memory layout}


\hypertarget{10394541563305653720}{} 
\hyperlink{10394541563305653720}{\texttt{Base.sizeof}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sizeof(T::DataType)
sizeof(obj)
\end{minted}

Size, in bytes, of the canonical binary representation of the given \texttt{DataType} \texttt{T}, if any. Size, in bytes, of object \texttt{obj} if it is not \texttt{DataType}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sizeof(Float32)
4

julia> sizeof(ComplexF64)
16

julia> sizeof(1.0)
8

julia> sizeof([1.0:10.0;])
80
\end{minted}

If \texttt{DataType} \texttt{T} does not have a specific size, an error is thrown.


\begin{minted}{jlcon}
julia> sizeof(AbstractArray)
ERROR: Abstract type AbstractArray does not have a definite size.
Stacktrace:
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L420-L450}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14038424001821057774}{} 
\hyperlink{14038424001821057774}{\texttt{Base.isconcretetype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isconcretetype(T)
\end{minted}

Determine whether type \texttt{T} is a concrete type, meaning it could have direct instances (values \texttt{x} such that \texttt{typeof(x) === T}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> isconcretetype(Complex)
false

julia> isconcretetype(Complex{Float32})
true

julia> isconcretetype(Vector{Complex})
true

julia> isconcretetype(Vector{Complex{Float32}})
true

julia> isconcretetype(Union{})
false

julia> isconcretetype(Union{Int,String})
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L503-L529}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12980593021531333073}{} 
\hyperlink{12980593021531333073}{\texttt{Base.isbits}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isbits(x)
\end{minted}

Return \texttt{true} if \texttt{x} is an instance of an \texttt{isbitstype} type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L475-L479}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16222127093346839171}{} 
\hyperlink{16222127093346839171}{\texttt{Base.isbitstype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isbitstype(T)
\end{minted}

Return \texttt{true} if type \texttt{T} is a {\textquotedbl}plain data{\textquotedbl} type, meaning it is immutable and contains no references to other values, only \texttt{primitive} types and other \texttt{isbitstype} types. Typical examples are numeric types such as \hyperlink{6609065134969660118}{\texttt{UInt8}}, \hyperlink{5027751419500983000}{\texttt{Float64}}, and \hyperlink{11302502367029942782}{\texttt{Complex\{Float64\}}}. This category of types is significant since they are valid as type parameters, may not track \hyperlink{11212950246505288748}{\texttt{isdefined}} / \hyperlink{976355747478401147}{\texttt{isassigned}} status, and have a defined layout that is compatible with C.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isbitstype(Complex{Float64})
true

julia> isbitstype(Complex)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L452-L472}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17091563430048909487}{} 
\hyperlink{17091563430048909487}{\texttt{Core.fieldtype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fieldtype(T, name::Symbol | index::Int)
\end{minted}

Determine the declared type of a field (specified by name or index) in a composite DataType \texttt{T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> struct Foo
           x::Int64
           y::String
       end

julia> fieldtype(Foo, :x)
Int64

julia> fieldtype(Foo, 2)
String
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L624-L642}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5798312736605167668}{} 
\hyperlink{5798312736605167668}{\texttt{Base.fieldtypes}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fieldtypes(T::Type)
\end{minted}

The declared types of all fields in a composite DataType \texttt{T} as a tuple.

\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> struct Foo
           x::Int64
           y::String
       end

julia> fieldtypes(Foo)
(Int64, String)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L713-L731}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15325030456619527024}{} 
\hyperlink{15325030456619527024}{\texttt{Base.fieldcount}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fieldcount(t::Type)
\end{minted}

Get the number of fields that an instance of the given type would have. An error is thrown if the type is too abstract to determine this.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L673-L678}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6956980533195055227}{} 
\hyperlink{6956980533195055227}{\texttt{Base.fieldoffset}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fieldoffset(type, i)
\end{minted}

The byte offset of field \texttt{i} of a type relative to the data start. For example, we could use it in the following manner to summarize information about a struct:


\begin{minted}{jlcon}
julia> structinfo(T) = [(fieldoffset(T,i), fieldname(T,i), fieldtype(T,i)) for i = 1:fieldcount(T)];

julia> structinfo(Base.Filesystem.StatStruct)
12-element Array{Tuple{UInt64,Symbol,DataType},1}:
 (0x0000000000000000, :device, UInt64)
 (0x0000000000000008, :inode, UInt64)
 (0x0000000000000010, :mode, UInt64)
 (0x0000000000000018, :nlink, Int64)
 (0x0000000000000020, :uid, UInt64)
 (0x0000000000000028, :gid, UInt64)
 (0x0000000000000030, :rdev, UInt64)
 (0x0000000000000038, :size, Int64)
 (0x0000000000000040, :blksize, Int64)
 (0x0000000000000048, :blocks, Int64)
 (0x0000000000000050, :mtime, Float64)
 (0x0000000000000058, :ctime, Float64)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L597-L621}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10538406441051412404}{} 
\hyperlink{10538406441051412404}{\texttt{Base.datatype\_alignment}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.datatype_alignment(dt::DataType) -> Int
\end{minted}

Memory allocation minimum alignment for instances of this type. Can be called on any \texttt{isconcretetype}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L328-L333}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6424780829184450870}{} 
\hyperlink{6424780829184450870}{\texttt{Base.datatype\_haspadding}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.datatype_haspadding(dt::DataType) -> Bool
\end{minted}

Return whether the fields of instances of this type are packed in memory, with no intervening padding bytes. Can be called on any \texttt{isconcretetype}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L361-L367}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15379950191784462663}{} 
\hyperlink{15379950191784462663}{\texttt{Base.datatype\_pointerfree}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.datatype_pointerfree(dt::DataType) -> Bool
\end{minted}

Return whether instances of this type can contain references to gc-managed memory. Can be called on any \texttt{isconcretetype}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L375-L380}{\texttt{source}}


\end{adjustwidth}

\hypertarget{12923909417161931188}{}


\subsection{Special values}


\hypertarget{3613894539247233488}{} 
\hyperlink{3613894539247233488}{\texttt{Base.typemin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
typemin(T)
\end{minted}

The lowest value representable by the given (real) numeric DataType \texttt{T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> typemin(Float16)
-Inf16

julia> typemin(Float32)
-Inf32
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L619-L632}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17760305803764597758}{} 
\hyperlink{17760305803764597758}{\texttt{Base.typemax}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
typemax(T)
\end{minted}

The highest value representable by the given (real) numeric \texttt{DataType}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> typemax(Int8)
127

julia> typemax(UInt32)
0xffffffff
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L635-L648}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3677946765696158382}{} 
\hyperlink{3677946765696158382}{\texttt{Base.floatmin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
floatmin(T)
\end{minted}

The smallest in absolute value non-subnormal value representable by the given floating-point DataType \texttt{T}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L752-L757}{\texttt{source}}


\end{adjustwidth}
\hypertarget{516655729472223591}{} 
\hyperlink{516655729472223591}{\texttt{Base.floatmax}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
floatmax(T)
\end{minted}

The highest finite value representable by the given floating-point DataType \texttt{T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> floatmax(Float16)
Float16(6.55e4)

julia> floatmax(Float32)
3.4028235f38
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L760-L773}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5283633936957536148}{} 
\hyperlink{5283633936957536148}{\texttt{Base.maxintfloat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
maxintfloat(T=Float64)
\end{minted}

The largest consecutive integer-valued floating-point number that is exactly represented in the given floating-point type \texttt{T} (which defaults to \texttt{Float64}).

That is, \texttt{maxintfloat} returns the smallest positive integer-valued floating-point number \texttt{n} such that \texttt{n+1} is \emph{not} exactly representable in the type \texttt{T}.

When an \texttt{Integer}-type value is needed, use \texttt{Integer(maxintfloat(T))}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/floatfuncs.jl#L19-L29}{\texttt{source}}



\begin{lstlisting}
maxintfloat(T, S)
\end{lstlisting}

The largest consecutive integer representable in the given floating-point type \texttt{T} that also does not exceed the maximum integer representable by the integer type \texttt{S}.  Equivalently, it is the minimum of \texttt{maxintfloat(T)} and \hyperlink{17760305803764597758}{\texttt{typemax(S)}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/floatfuncs.jl#L35-L41}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4564486364601788299}{} 
\hyperlink{4564486364601788299}{\texttt{Base.eps}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eps(::Type{T}) where T<:AbstractFloat
eps()
\end{minted}

Return the \emph{machine epsilon} of the floating point type \texttt{T} (\texttt{T = Float64} by default). This is defined as the gap between 1 and the next largest value representable by \texttt{typeof(one(T))}, and is equivalent to \texttt{eps(one(T))}.  (Since \texttt{eps(T)} is a bound on the \emph{relative error} of \texttt{T}, it is a {\textquotedbl}dimensionless{\textquotedbl} quantity like \hyperlink{11395333326208453101}{\texttt{one}}.)

\textbf{Examples}


\begin{minted}{jlcon}
julia> eps()
2.220446049250313e-16

julia> eps(Float32)
1.1920929f-7

julia> 1.0 + eps()
1.0000000000000002

julia> 1.0 + eps()/2
1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L779-L802}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8678379894267468692}{} 
\hyperlink{8678379894267468692}{\texttt{Base.eps}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eps(x::AbstractFloat)
\end{minted}

Return the \emph{unit in last place} (ulp) of \texttt{x}. This is the distance between consecutive representable floating point values at \texttt{x}. In most cases, if the distance on either side of \texttt{x} is different, then the larger of the two is taken, that is


\begin{lstlisting}
eps(x) == max(x-prevfloat(x), nextfloat(x)-x)
\end{lstlisting}

The exceptions to this rule are the smallest and largest finite values (e.g. \texttt{nextfloat(-Inf)} and \texttt{prevfloat(Inf)} for \hyperlink{5027751419500983000}{\texttt{Float64}}), which round to the smaller of the values.

The rationale for this behavior is that \texttt{eps} bounds the floating point rounding error. Under the default \texttt{RoundNearest} rounding mode, if  \(y\)  is a real number and  \(x\)  is the nearest floating point number to  \(y\) , then

\begin{equation*}
\begin{split}|y-x| \leq \operatorname{eps}(x)/2.\end{split}\end{equation*}
\textbf{Examples}


\begin{minted}{jlcon}
julia> eps(1.0)
2.220446049250313e-16

julia> eps(prevfloat(2.0))
2.220446049250313e-16

julia> eps(2.0)
4.440892098500626e-16

julia> x = prevfloat(Inf)      # largest finite Float64
1.7976931348623157e308

julia> x + eps(x)/2            # rounds up
Inf

julia> x + prevfloat(eps(x)/2) # rounds down
1.7976931348623157e308
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L805-L846}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1621796923312060494}{} 
\hyperlink{1621796923312060494}{\texttt{Base.instances}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
instances(T::Type)
\end{minted}

Return a collection of all instances of the given type, if applicable. Mostly used for enumerated types (see \texttt{@enum}).

\textbf{Example}


\begin{minted}{jlcon}
julia> @enum Color red blue green

julia> instances(Color)
(red, blue, green)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L736-L749}{\texttt{source}}


\end{adjustwidth}

\hypertarget{16613146440678600421}{}


\section{Special Types}


\hypertarget{15014186392807667022}{} 
\hyperlink{15014186392807667022}{\texttt{Core.Any}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Any::DataType
\end{minted}

\texttt{Any} is the union of all types. It has the defining property \texttt{isa(x, Any) == true} for any \texttt{x}. \texttt{Any} therefore describes the entire universe of possible values. For example \texttt{Integer} is a subset of \texttt{Any} that includes \texttt{Int}, \texttt{Int8}, and other integer types.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2077-L2083}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5087820771052303592}{} 
\hyperlink{5087820771052303592}{\texttt{Core.Union}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Union{Types...}
\end{minted}

A type union is an abstract type which includes all instances of any of its argument types. The empty union \hyperlink{17871676717506458499}{\texttt{Union\{\}}} is the bottom type of Julia.

\textbf{Examples}


\begin{minted}{jlcon}
julia> IntOrString = Union{Int,AbstractString}
Union{Int64, AbstractString}

julia> 1 :: IntOrString
1

julia> "Hello!" :: IntOrString
"Hello!"

julia> 1.0 :: IntOrString
ERROR: TypeError: in typeassert, expected Union{Int64, AbstractString}, got Float64
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2101-L2121}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17871676717506458499}{} 
\hyperlink{17871676717506458499}{\texttt{Union\{\}}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Union{}
\end{minted}

\texttt{Union\{\}}, the empty \hyperlink{5087820771052303592}{\texttt{Union}} of types, is the type that has no values. That is, it has the defining property \texttt{isa(x, Union\{\}) == false} for any \texttt{x}. \texttt{Base.Bottom} is defined as its alias and the type of \texttt{Union\{\}} is \texttt{Core.TypeofBottom}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isa(nothing, Union{})
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2086-L2098}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13291956087044414878}{} 
\hyperlink{13291956087044414878}{\texttt{Core.UnionAll}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UnionAll
\end{minted}

A union of types over all values of a type parameter. \texttt{UnionAll} is used to describe parametric types where the values of some parameters are not known.

\textbf{Examples}


\begin{minted}{jlcon}
julia> typeof(Vector)
UnionAll

julia> typeof(Vector{Int})
DataType
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2125-L2139}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17462354060312563026}{} 
\hyperlink{17462354060312563026}{\texttt{Core.Tuple}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Tuple{Types...}
\end{minted}

Tuples are an abstraction of the arguments of a function – without the function itself. The salient aspects of a function{\textquotesingle}s arguments are their order and their types. Therefore a tuple type is similar to a parameterized immutable type where each parameter is the type of one field. Tuple types may have any number of parameters.

Tuple types are covariant in their parameters: \texttt{Tuple\{Int\}} is a subtype of \texttt{Tuple\{Any\}}. Therefore \texttt{Tuple\{Any\}} is considered an abstract type, and tuple types are only concrete if their parameters are. Tuples do not have field names; fields are only accessed by index.

See the manual section on \href{@ref}{Tuple Types}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2189-L2201}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3845731488275720657}{} 
\hyperlink{3845731488275720657}{\texttt{Core.NamedTuple}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
NamedTuple
\end{minted}

\texttt{NamedTuple}s are, as their name suggests, named \hyperlink{17462354060312563026}{\texttt{Tuple}}s. That is, they{\textquotesingle}re a tuple-like collection of values, where each entry has a unique name, represented as a \hyperlink{18332791376992528422}{\texttt{Symbol}}. Like \texttt{Tuple}s, \texttt{NamedTuple}s are immutable; neither the names nor the values can be modified in place after construction.

Accessing the value associated with a name in a named tuple can be done using field access syntax, e.g. \texttt{x.a}, or using \hyperlink{13720608614876840481}{\texttt{getindex}}, e.g. \texttt{x[:a]}. A tuple of the names can be obtained using \hyperlink{6023948435845840069}{\texttt{keys}}, and a tuple of the values can be obtained using \hyperlink{14429101350359443046}{\texttt{values}}.

\begin{quote}
\textbf{Note}

Iteration over \texttt{NamedTuple}s produces the \emph{values} without the names. (See example below.) To iterate over the name-value pairs, use the \hyperlink{15543779110977484852}{\texttt{pairs}} function.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> x = (a=1, b=2)
(a = 1, b = 2)

julia> x.a
1

julia> x[:a]
1

julia> keys(x)
(:a, :b)

julia> values(x)
(1, 2)

julia> collect(x)
2-element Array{Int64,1}:
 1
 2

julia> collect(pairs(x))
2-element Array{Pair{Symbol,Int64},1}:
 :a => 1
 :b => 2
\end{minted}

In a similar fashion as to how one can define keyword arguments programmatically, a named tuple can be created by giving a pair \texttt{name::Symbol => value} or splatting an iterator yielding such pairs after a semicolon inside a tuple literal:


\begin{minted}{jlcon}
julia> (; :a => 1)
(a = 1,)

julia> keys = (:a, :b, :c); values = (1, 2, 3);

julia> (; zip(keys, values)...)
(a = 1, b = 2, c = 3)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/namedtuple.jl#L3-L61}{\texttt{source}}


\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Base.@NamedTuple}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{1312938105781775871}{} 
\hyperlink{1312938105781775871}{\texttt{Base.Val}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Val(c)
\end{minted}

Return \texttt{Val\{c\}()}, which contains no run-time data. Types like this can be used to pass the information between functions through the value \texttt{c}, which must be an \texttt{isbits} value. The intent of this construct is to be able to dispatch on constants directly (at compile time) without having to test the value of the constant at run time.

\textbf{Examples}


\begin{minted}{jlcon}
julia> f(::Val{true}) = "Good"
f (generic function with 1 method)

julia> f(::Val{false}) = "Bad"
f (generic function with 2 methods)

julia> f(Val(true))
"Good"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L675-L694}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5941806424098279588}{} 
\hyperlink{5941806424098279588}{\texttt{Core.Vararg}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Vararg{T,N}
\end{minted}

The last parameter of a tuple type \hyperlink{17462354060312563026}{\texttt{Tuple}} can be the special type \texttt{Vararg}, which denotes any number of trailing elements. The type \texttt{Vararg\{T,N\}} corresponds to exactly \texttt{N} elements of type \texttt{T}. \texttt{Vararg\{T\}} corresponds to zero or more elements of type \texttt{T}. \texttt{Vararg} tuple types are used to represent the arguments accepted by varargs methods (see the section on \href{@ref}{Varargs Functions} in the manual.)

\textbf{Examples}


\begin{minted}{jlcon}
julia> mytupletype = Tuple{AbstractString,Vararg{Int}}
Tuple{AbstractString,Vararg{Int64,N} where N}

julia> isa(("1",), mytupletype)
true

julia> isa(("1",1), mytupletype)
true

julia> isa(("1",1,2), mytupletype)
true

julia> isa(("1",1,2,3.0), mytupletype)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2161-L2186}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13508459519898889544}{} 
\hyperlink{13508459519898889544}{\texttt{Core.Nothing}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Nothing
\end{minted}

A type with no fields that is the type of \hyperlink{9331422207248206047}{\texttt{nothing}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1050-L1054}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15485094872489766212}{} 
\hyperlink{15485094872489766212}{\texttt{Base.isnothing}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isnothing(x)
\end{minted}

Return \texttt{true} if \texttt{x === nothing}, and return \texttt{false} if not.

\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/some.jl#L56-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12733330042100122220}{} 
\hyperlink{12733330042100122220}{\texttt{Base.Some}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Some{T}
\end{minted}

A wrapper type used in \texttt{Union\{Some\{T\}, Nothing\}} to distinguish between the absence of a value (\hyperlink{9331422207248206047}{\texttt{nothing}}) and the presence of a \texttt{nothing} value (i.e. \texttt{Some(nothing)}).

Use \hyperlink{12366229165852827603}{\texttt{something}} to access the value wrapped by a \texttt{Some} object.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/some.jl#L3-L10}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12366229165852827603}{} 
\hyperlink{12366229165852827603}{\texttt{Base.something}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
something(x, y...)
\end{minted}

Return the first value in the arguments which is not equal to \hyperlink{9331422207248206047}{\texttt{nothing}}, if any. Otherwise throw an error. Arguments of type \hyperlink{12733330042100122220}{\texttt{Some}} are unwrapped.

See also \hyperlink{13286612216921584050}{\texttt{coalesce}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> something(nothing, 1)
1

julia> something(Some(1), nothing)
1

julia> something(missing, nothing)
missing

julia> something(nothing, nothing)
ERROR: ArgumentError: No value arguments present
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/some.jl#L68-L91}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12477318268908279491}{} 
\hyperlink{12477318268908279491}{\texttt{Base.Enums.Enum}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Enum{T<:Integer}
\end{minted}

The abstract supertype of all enumerated types defined with \hyperlink{18177775477210803027}{\texttt{@enum}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/Enums.jl#L10-L14}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18177775477210803027}{} 
\hyperlink{18177775477210803027}{\texttt{Base.Enums.@enum}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@enum EnumName[::BaseType] value1[=x] value2[=y]
\end{minted}

Create an \texttt{Enum\{BaseType\}} subtype with name \texttt{EnumName} and enum member values of \texttt{value1} and \texttt{value2} with optional assigned values of \texttt{x} and \texttt{y}, respectively. \texttt{EnumName} can be used just like other types and enum member values as regular values, such as

\textbf{Examples}


\begin{minted}{jlcon}
julia> @enum Fruit apple=1 orange=2 kiwi=3

julia> f(x::Fruit) = "I'm a Fruit with value: $(Int(x))"
f (generic function with 1 method)

julia> f(apple)
"I'm a Fruit with value: 1"

julia> Fruit(1)
apple::Fruit = 1
\end{minted}

Values can also be specified inside a \texttt{begin} block, e.g.


\begin{minted}{julia}
@enum EnumName begin
    value1
    value2
end
\end{minted}

\texttt{BaseType}, which defaults to \hyperlink{10103694114785108551}{\texttt{Int32}}, must be a primitive subtype of \texttt{Integer}. Member values can be converted between the enum type and \texttt{BaseType}. \texttt{read} and \texttt{write} perform these conversions automatically.

To list all the instances of an enum use \texttt{instances}, e.g.


\begin{minted}{jlcon}
julia> instances(Fruit)
(apple, orange, kiwi)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/Enums.jl#L77-L117}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17120496304147995299}{} 
\hyperlink{17120496304147995299}{\texttt{Core.Expr}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Expr(head::Symbol, args...)
\end{minted}

A type representing compound expressions in parsed julia code (ASTs). Each expression consists of a \texttt{head} \texttt{Symbol} identifying which kind of expression it is (e.g. a call, for loop, conditional statement, etc.), and subexpressions (e.g. the arguments of a call). The subexpressions are stored in a \texttt{Vector\{Any\}} field called \texttt{args}.

See the manual chapter on \href{@ref}{Metaprogramming} and the developer documentation \href{@ref}{Julia ASTs}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Expr(:call, :+, 1, 2)
:(1 + 2)

julia> dump(:(a ? b : c))
Expr
  head: Symbol if
  args: Array{Any}((3,))
    1: Symbol a
    2: Symbol b
    3: Symbol c
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L402-L427}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18332791376992528422}{} 
\hyperlink{18332791376992528422}{\texttt{Core.Symbol}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Symbol
\end{minted}

The type of object used to represent identifiers in parsed julia code (ASTs). Also often used as a name or label to identify an entity (e.g. as a dictionary key). \texttt{Symbol}s can be entered using the \texttt{:} quote operator:


\begin{minted}{jlcon}
julia> :name
:name

julia> typeof(:name)
Symbol

julia> x = 42
42

julia> eval(:x)
42
\end{minted}

\texttt{Symbol}s can also be constructed from strings or other values by calling the constructor \texttt{Symbol(x...)}.

\texttt{Symbol}s are immutable and should be compared using \texttt{===}. The implementation re-uses the same object for all \texttt{Symbol}s with the same name, so comparison tends to be efficient (it can just compare pointers).

Unlike strings, \texttt{Symbol}s are {\textquotedbl}atomic{\textquotedbl} or {\textquotedbl}scalar{\textquotedbl} entities that do not support iteration over characters.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1554-L1582}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8149537083915085913}{} 
\hyperlink{8149537083915085913}{\texttt{Core.Symbol}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Symbol(x...) -> Symbol
\end{minted}

Create a \hyperlink{18332791376992528422}{\texttt{Symbol}} by concatenating the string representations of the arguments together.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Symbol("my", "name")
:myname

julia> Symbol("day", 4)
:day4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1585-L1598}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6070072550914765640}{} 
\hyperlink{6070072550914765640}{\texttt{Core.Module}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Module
\end{minted}

A \texttt{Module} is a separate global variable workspace. See \hyperlink{16285380181904025577}{\texttt{module}} and the \hyperlink{16725527896995457152}{manual section about modules} for details.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2321-L2325}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14863412530278606383}{}


\section{Generic Functions}


\hypertarget{2744637612596423318}{} 
\hyperlink{2744637612596423318}{\texttt{Core.Function}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Function
\end{minted}

Abstract type of all functions.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isa(+, Function)
true

julia> typeof(sin)
typeof(sin)

julia> ans <: Function
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1072-L1088}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6562783328134837372}{} 
\hyperlink{6562783328134837372}{\texttt{Base.hasmethod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hasmethod(f, t::Type{<:Tuple}[, kwnames]; world=typemax(UInt)) -> Bool
\end{minted}

Determine whether the given generic function has a method matching the given \texttt{Tuple} of argument types with the upper bound of world age given by \texttt{world}.

If a tuple of keyword argument names \texttt{kwnames} is provided, this also checks whether the method of \texttt{f} matching \texttt{t} has the given keyword argument names. If the matching method accepts a variable number of keyword arguments, e.g. with \texttt{kwargs...}, any names given in \texttt{kwnames} are considered valid. Otherwise the provided names must be a subset of the method{\textquotesingle}s keyword arguments.

See also \hyperlink{366019948759111192}{\texttt{applicable}}.

\begin{quote}
\textbf{Julia 1.2}

Providing keyword argument names requires Julia 1.2 or later.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> hasmethod(length, Tuple{Array})
true

julia> hasmethod(sum, Tuple{Function, Array}, (:dims,))
true

julia> hasmethod(sum, Tuple{Function, Array}, (:apples, :bananas))
false

julia> g(; xs...) = 4;

julia> hasmethod(g, Tuple{}, (:a, :b, :c, :d))  # g accepts arbitrary kwargs
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L1210-L1243}{\texttt{source}}


\end{adjustwidth}
\hypertarget{366019948759111192}{} 
\hyperlink{366019948759111192}{\texttt{Core.applicable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
applicable(f, args...) -> Bool
\end{minted}

Determine whether the given generic function has a method applicable to the given arguments.

See also \hyperlink{6562783328134837372}{\texttt{hasmethod}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> function f(x, y)
           x + y
       end;

julia> applicable(f, 1)
false

julia> applicable(f, 1, 2)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1370-L1389}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14356043600121087376}{} 
\hyperlink{14356043600121087376}{\texttt{Core.invoke}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
invoke(f, argtypes::Type, args...; kwargs...)
\end{minted}

Invoke a method for the given generic function \texttt{f} matching the specified types \texttt{argtypes} on the specified arguments \texttt{args} and passing the keyword arguments \texttt{kwargs}. The arguments \texttt{args} must conform with the specified types in \texttt{argtypes}, i.e. conversion is not automatically performed. This method allows invoking a method other than the most specific matching method, which is useful when the behavior of a more general definition is explicitly needed (often as part of the implementation of a more specific method of the same function).

\textbf{Examples}


\begin{minted}{jlcon}
julia> f(x::Real) = x^2;

julia> f(x::Integer) = 1 + invoke(f, Tuple{Real}, x);

julia> f(2)
5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1392-L1411}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15240876280767285272}{} 
\hyperlink{15240876280767285272}{\texttt{Base.invokelatest}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
invokelatest(f, args...; kwargs...)
\end{minted}

Calls \texttt{f(args...; kwargs...)}, but guarantees that the most recent method of \texttt{f} will be executed.   This is useful in specialized circumstances, e.g. long-running event loops or callback functions that may call obsolete versions of a function \texttt{f}. (The drawback is that \texttt{invokelatest} is somewhat slower than calling \texttt{f} directly, and the type of the result cannot be inferred by the compiler.)



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L700-L709}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13888762393600028594}{} 
\hyperlink{13888762393600028594}{\texttt{new}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
new
\end{minted}

Special function available to inner constructors which created a new object of the type. See the manual section on \hyperlink{5052047505447273614}{Inner Constructor Methods} for more information.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L960-L967}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5135459825603202944}{} 
\hyperlink{5135459825603202944}{\texttt{Base.:|>}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
|>(x, f)
\end{minted}

Applies a function to the preceding argument. This allows for easy function chaining.

\textbf{Examples}


\begin{minted}{jlcon}
julia> [1:5;] |> x->x.^2 |> sum |> inv
0.01818181818181818
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L812-L822}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8400062617555407555}{} 
\hyperlink{8400062617555407555}{\texttt{Base.:∘}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
f ∘ g
\end{minted}

Compose functions: i.e. \texttt{(f ∘ g)(args...)} means \texttt{f(g(args...))}. The \texttt{∘} symbol can be entered in the Julia REPL (and most editors, appropriately configured) by typing \texttt{{\textbackslash}circ<tab>}.

Function composition also works in prefix form: \texttt{∘(f, g)} is the same as \texttt{f ∘ g}. The prefix form supports composition of multiple functions: \texttt{∘(f, g, h) = f ∘ g ∘ h} and splatting \texttt{∘(fs...)} for composing an iterable collection of functions.

\begin{quote}
\textbf{Julia 1.4}

Multiple function composition requires at least Julia 1.4.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> map(uppercase∘first, ["apple", "banana", "carrot"])
3-element Array{Char,1}:
 'A'
 'B'
 'C'

julia> fs = [
           x -> 2x
           x -> x/2
           x -> x-1
           x -> x+1
       ];

julia> ∘(fs...)(3)
3.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L827-L858}{\texttt{source}}


\end{adjustwidth}

\hypertarget{15383903001647696562}{}


\section{Syntax}


\hypertarget{2345597220715550879}{} 
\hyperlink{2345597220715550879}{\texttt{Core.eval}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Core.eval(m::Module, expr)
\end{minted}

Evaluate an expression in the given module and return the result.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/expr.jl#L168-L172}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7507639810592563424}{} 
\hyperlink{7507639810592563424}{\texttt{Base.MainInclude.eval}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eval(expr)
\end{minted}

Evaluate an expression in the global scope of the containing module. Every \texttt{Module} (except those defined with \texttt{baremodule}) has its own 1-argument definition of \texttt{eval}, which evaluates expressions in that module.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/client.jl#L452-L458}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12895501458291832858}{} 
\hyperlink{12895501458291832858}{\texttt{Base.@eval}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@eval [mod,] ex
\end{minted}

Evaluate an expression with values interpolated into it using \texttt{eval}. If two arguments are provided, the first is the module to evaluate in.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L176-L181}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1049904639707765509}{} 
\hyperlink{1049904639707765509}{\texttt{Base.evalfile}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
evalfile(path::AbstractString, args::Vector{String}=String[])
\end{minted}

Load the file using \hyperlink{438355891087818425}{\texttt{include}}, evaluate all expressions, and return the value of the last one.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/loading.jl#L1113-L1118}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17861659594346526773}{} 
\hyperlink{17861659594346526773}{\texttt{Base.esc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
esc(e)
\end{minted}

Only valid in the context of an \hyperlink{17120496304147995299}{\texttt{Expr}} returned from a macro. Prevents the macro hygiene pass from turning embedded variables into gensym variables. See the \hyperlink{5127151953463206825}{Macros} section of the Metaprogramming chapter of the manual for more details and examples.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L469-L475}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9619263577270933060}{} 
\hyperlink{9619263577270933060}{\texttt{Base.@inbounds}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@inbounds(blk)
\end{minted}

Eliminates array bounds checking within expressions.

In the example below the in-range check for referencing element \texttt{i} of array \texttt{A} is skipped to improve performance.


\begin{minted}{julia}
function sum(A::AbstractArray)
    r = zero(eltype(A))
    for i = 1:length(A)
        @inbounds r += A[i]
    end
    return r
end
\end{minted}

\begin{quote}
\textbf{Warning}

Using \texttt{@inbounds} may return incorrect results/crashes/corruption for out-of-bounds indices. The user is responsible for checking it manually. Only use \texttt{@inbounds} when it is certain from the information locally available that all accesses are in bounds.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L526-L550}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5163897958650268335}{} 
\hyperlink{5163897958650268335}{\texttt{Base.@boundscheck}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@boundscheck(blk)
\end{minted}

Annotates the expression \texttt{blk} as a bounds checking block, allowing it to be elided by \hyperlink{9619263577270933060}{\texttt{@inbounds}}.

\begin{quote}
\textbf{Note}

The function in which \texttt{@boundscheck} is written must be inlined into its caller in order for \texttt{@inbounds} to have effect.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> @inline function g(A, i)
           @boundscheck checkbounds(A, i)
           return "accessing ($A)[$i]"
       end;

julia> f1() = return g(1:2, -1);

julia> f2() = @inbounds return g(1:2, -1);

julia> f1()
ERROR: BoundsError: attempt to access 2-element UnitRange{Int64} at index [-1]
Stacktrace:
 [1] throw_boundserror(::UnitRange{Int64}, ::Tuple{Int64}) at ./abstractarray.jl:455
 [2] checkbounds at ./abstractarray.jl:420 [inlined]
 [3] g at ./none:2 [inlined]
 [4] f1() at ./none:1
 [5] top-level scope

julia> f2()
"accessing (1:2)[-1]"
\end{minted}

\begin{quote}
\textbf{Warning}

The \texttt{@boundscheck} annotation allows you, as a library writer, to opt-in to allowing \emph{other code} to remove your bounds checks with \hyperlink{9619263577270933060}{\texttt{@inbounds}}. As noted there, the caller must verify—using information they can access—that their accesses are valid before using \texttt{@inbounds}. For indexing into your \hyperlink{6514416309183787338}{\texttt{AbstractArray}} subclasses, for example, this involves checking the indices against its \hyperlink{17888996102305087038}{\texttt{size}}. Therefore, \texttt{@boundscheck} annotations should only be added to a \hyperlink{13720608614876840481}{\texttt{getindex}} or \hyperlink{1309244355901386657}{\texttt{setindex!}} implementation after you are certain its behavior is correct.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L478-L521}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4942611866585954207}{} 
\hyperlink{4942611866585954207}{\texttt{Base.@propagate\_inbounds}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@propagate_inbounds
\end{minted}

Tells the compiler to inline a function while retaining the caller{\textquotesingle}s inbounds context.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/expr.jl#L239-L243}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18060766522149343036}{} 
\hyperlink{18060766522149343036}{\texttt{Base.@inline}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@inline
\end{minted}

Give a hint to the compiler that this function is worth inlining.

Small functions typically do not need the \texttt{@inline} annotation, as the compiler does it automatically. By using \texttt{@inline} on bigger functions, an extra nudge can be given to the compiler to inline it. This is shown in the following example:


\begin{minted}{julia}
@inline function bigfunction(x)
    #=
        Function Definition
    =#
end
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/expr.jl#L175-L192}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13090632948127397341}{} 
\hyperlink{13090632948127397341}{\texttt{Base.@noinline}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@noinline
\end{minted}

Give a hint to the compiler that it should not inline a function.

Small functions are typically inlined automatically. By using \texttt{@noinline} on small functions, auto-inlining can be prevented. This is shown in the following example:


\begin{minted}{julia}
@noinline function smallfunction(x)
    #=
        Function Definition
    =#
end

If the function is trivial (for example returning a constant) it might get inlined anyway.
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/expr.jl#L197-L215}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5574860636759822935}{} 
\hyperlink{5574860636759822935}{\texttt{Base.@nospecialize}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@nospecialize
\end{minted}

Applied to a function argument name, hints to the compiler that the method should not be specialized for different types of that argument, but instead to use precisely the declared type for each argument. This is only a hint for avoiding excess code generation. Can be applied to an argument within a formal argument list, or in the function body. When applied to an argument, the macro must wrap the entire argument expression. When used in a function body, the macro must occur in statement position and before any code.

When used without arguments, it applies to all arguments of the parent scope. In local scope, this means all arguments of the containing function. In global (top-level) scope, this means all methods subsequently defined in the current module.

Specialization can reset back to the default by using \hyperlink{1495861121913085321}{\texttt{@specialize}}.


\begin{minted}{julia}
function example_function(@nospecialize x)
    ...
end

function example_function(@nospecialize(x = 1), y)
    ...
end

function example_function(x, y, z)
    @nospecialize x y
    ...
end

@nospecialize
f(y) = [x for x in y]
@specialize
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L43-L80}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1495861121913085321}{} 
\hyperlink{1495861121913085321}{\texttt{Base.@specialize}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@specialize
\end{minted}

Reset the specialization hint for an argument back to the default. For details, see \hyperlink{5574860636759822935}{\texttt{@nospecialize}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L92-L97}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3515345868651201289}{} 
\hyperlink{3515345868651201289}{\texttt{Base.gensym}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gensym([tag])
\end{minted}

Generates a symbol which will not conflict with other variable names.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/expr.jl#L5-L9}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1574260997115674041}{} 
\hyperlink{1574260997115674041}{\texttt{Base.@gensym}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@gensym
\end{minted}

Generates a gensym symbol for a variable. For example, \texttt{@gensym x y} is transformed into \texttt{x = gensym({\textquotedbl}x{\textquotedbl}); y = gensym({\textquotedbl}y{\textquotedbl})}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/expr.jl#L18-L23}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17011668714147183228}{} 
\hyperlink{17011668714147183228}{\texttt{var{\textquotedbl}name{\textquotedbl}}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
var
\end{minted}

The syntax \texttt{var{\textquotedbl}\#example\#{\textquotedbl}} refers to a variable named \texttt{Symbol({\textquotedbl}\#example\#{\textquotedbl})}, even though \texttt{\#example\#} is not a valid Julia identifier name.

This can be useful for interoperability with programming languages which have different rules for the construction of valid identifiers. For example, to refer to the \texttt{R} variable \texttt{draw.segments}, you can use \texttt{var{\textquotedbl}draw.segments{\textquotedbl}} in your Julia code.

It is also used to \texttt{show} julia source code which has gone through macro hygiene or otherwise contains variable names which can{\textquotesingle}t be parsed normally.

Note that this syntax requires parser support so it is expanded directly by the parser rather than being implemented as a normal string macro \texttt{@var\_str}.

\begin{quote}
\textbf{Julia 1.3}

This syntax requires at least Julia 1.3.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1006-L1026}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6008882266630078507}{} 
\hyperlink{6008882266630078507}{\texttt{Base.@goto}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@goto name
\end{minted}

\texttt{@goto name} unconditionally jumps to the statement at the location \hyperlink{11932619098205117246}{\texttt{@label name}}.

\texttt{@label} and \texttt{@goto} cannot create jumps to different top-level statements. Attempts cause an error. To still use \texttt{@goto}, enclose the \texttt{@label} and \texttt{@goto} in a block.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L569-L576}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11932619098205117246}{} 
\hyperlink{11932619098205117246}{\texttt{Base.@label}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@label name
\end{minted}

Labels a statement with the symbolic label \texttt{name}. The label marks the end-point of an unconditional jump with \hyperlink{6008882266630078507}{\texttt{@goto name}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L559-L564}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8155428559748374852}{} 
\hyperlink{8155428559748374852}{\texttt{Base.SimdLoop.@simd}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@simd
\end{minted}

Annotate a \texttt{for} loop to allow the compiler to take extra liberties to allow loop re-ordering

\begin{quote}
\textbf{Warning}

This feature is experimental and could change or disappear in future versions of Julia. Incorrect use of the \texttt{@simd} macro may cause unexpected results.

\end{quote}
The object iterated over in a \texttt{@simd for} loop should be a one-dimensional range. By using \texttt{@simd}, you are asserting several properties of the loop:

\begin{itemize}
\item It is safe to execute iterations in arbitrary or overlapping order, with special consideration for reduction variables.


\item Floating-point operations on reduction variables can be reordered, possibly causing different results than without \texttt{@simd}.

\end{itemize}
In many cases, Julia is able to automatically vectorize inner for loops without the use of \texttt{@simd}. Using \texttt{@simd} gives the compiler a little extra leeway to make it possible in more situations. In either case, your inner loop should have the following properties to allow vectorization:

\begin{itemize}
\item The loop must be an innermost loop


\item The loop body must be straight-line code. Therefore, \hyperlink{9619263577270933060}{\texttt{@inbounds}} is   currently needed for all array accesses. The compiler can sometimes turn   short \texttt{\&\&}, \texttt{||}, and \texttt{?:} expressions into straight-line code if it is safe   to evaluate all operands unconditionally. Consider using the \hyperlink{12785896617485598962}{\texttt{ifelse}}   function instead of \texttt{?:} in the loop if it is safe to do so.


\item Accesses must have a stride pattern and cannot be {\textquotedbl}gathers{\textquotedbl} (random-index   reads) or {\textquotedbl}scatters{\textquotedbl} (random-index writes).


\item The stride should be unit stride.

\end{itemize}
\begin{quote}
\textbf{Note}

The \texttt{@simd} does not assert by default that the loop is completely free of loop-carried memory dependencies, which is an assumption that can easily be violated in generic code. If you are writing non-generic code, you can use \texttt{@simd ivdep for ... end} to also assert that:

\end{quote}
\begin{itemize}
\item There exists no loop-carried memory dependencies


\item No iteration ever waits on a previous iteration to make forward progress.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/simdloop.jl#L90-L126}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17097218075487180587}{} 
\hyperlink{17097218075487180587}{\texttt{Base.@polly}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@polly
\end{minted}

Tells the compiler to apply the polyhedral optimizer Polly to a function.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/expr.jl#L252-L256}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11479538870805927749}{} 
\hyperlink{11479538870805927749}{\texttt{Base.@generated}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@generated f
@generated(f)
\end{minted}

\texttt{@generated} is used to annotate a function which will be generated. In the body of the generated function, only types of arguments can be read (not the values). The function returns a quoted expression evaluated when the function is called. The \texttt{@generated} macro should not be used on functions mutating the global scope or depending on mutable elements.

See \href{@ref}{Metaprogramming} for further details.

\textbf{Example:}


\begin{minted}{julia}
julia> @generated function bar(x)
           if x <: Integer
               return :(x ^ 2)
           else
               return :(x)
           end
       end
bar (generic function with 1 method)

julia> bar(4)
16

julia> bar("baz")
"baz"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/expr.jl#L386-L414}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14594515112262961362}{} 
\hyperlink{14594515112262961362}{\texttt{Base.@pure}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@pure ex
@pure(ex)
\end{minted}

\texttt{@pure} gives the compiler a hint for the definition of a pure function, helping for type inference.

A pure function can only depend on immutable information. This also means a \texttt{@pure} function cannot use any global mutable state, including generic functions. Calls to generic functions depend on method tables which are mutable global state. Use with caution, incorrect \texttt{@pure} annotation of a function may introduce hard to identify bugs. Double check for calls to generic functions. This macro is intended for internal compiler use and may be subject to changes.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/expr.jl#L220-L234}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10566386387238732905}{} 
\hyperlink{10566386387238732905}{\texttt{Base.@deprecate}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@deprecate old new [ex=true]
\end{minted}

The first argument \texttt{old} is the signature of the deprecated method, the second one \texttt{new} is the call which replaces it. \texttt{@deprecate} exports \texttt{old} unless the optional third argument is \texttt{false}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> @deprecate old(x) new(x)
old (generic function with 1 method)

julia> @deprecate old(x) new(x) false
old (generic function with 1 method)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/deprecated.jl#L17-L32}{\texttt{source}}


\end{adjustwidth}

\hypertarget{15425524910108036471}{}


\section{Missing Values}


\hypertarget{9306488559141158579}{} 
\hyperlink{9306488559141158579}{\texttt{Base.Missing}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Missing
\end{minted}

A type with no fields whose singleton instance \hyperlink{14596725676261444434}{\texttt{missing}} is used to represent missing values.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L766-L771}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14596725676261444434}{} 
\hyperlink{14596725676261444434}{\texttt{Base.missing}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
missing
\end{minted}

The singleton instance of type \hyperlink{9306488559141158579}{\texttt{Missing}} representing a missing value.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L774-L778}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13286612216921584050}{} 
\hyperlink{13286612216921584050}{\texttt{Base.coalesce}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
coalesce(x, y...)
\end{minted}

Return the first value in the arguments which is not equal to \hyperlink{14596725676261444434}{\texttt{missing}}, if any. Otherwise return \texttt{missing}.

See also \hyperlink{12366229165852827603}{\texttt{something}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> coalesce(missing, 1)
1

julia> coalesce(1, missing)
1

julia> coalesce(nothing, 1)  # returns `nothing`

julia> coalesce(missing, missing)
missing
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/missing.jl#L384-L406}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3452327148507948899}{} 
\hyperlink{3452327148507948899}{\texttt{Base.ismissing}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ismissing(x)
\end{minted}

Indicate whether \texttt{x} is \hyperlink{14596725676261444434}{\texttt{missing}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L781-L785}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2012470681884771400}{} 
\hyperlink{2012470681884771400}{\texttt{Base.skipmissing}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
skipmissing(itr)
\end{minted}

Return an iterator over the elements in \texttt{itr} skipping \hyperlink{14596725676261444434}{\texttt{missing}} values. The returned object can be indexed using indices of \texttt{itr} if the latter is indexable. Indices corresponding to missing values are not valid: they are skipped by \hyperlink{6023948435845840069}{\texttt{keys}} and \hyperlink{4701773772897287974}{\texttt{eachindex}}, and a \texttt{MissingException} is thrown when trying to use them.

Use \hyperlink{6278865767444641812}{\texttt{collect}} to obtain an \texttt{Array} containing the non-\texttt{missing} values in \texttt{itr}. Note that even if \texttt{itr} is a multidimensional array, the result will always be a \texttt{Vector} since it is not possible to remove missings while preserving dimensions of the input.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = skipmissing([1, missing, 2])
Base.SkipMissing{Array{Union{Missing, Int64},1}}(Union{Missing, Int64}[1, missing, 2])

julia> sum(x)
3

julia> x[1]
1

julia> x[2]
ERROR: MissingException: the value at index (2,) is missing
[...]

julia> argmax(x)
3

julia> collect(keys(x))
2-element Array{Int64,1}:
 1
 3

julia> collect(skipmissing([1, missing, 2]))
2-element Array{Int64,1}:
 1
 2

julia> collect(skipmissing([1 missing; 2 missing]))
2-element Array{Int64,1}:
 1
 2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/missing.jl#L183-L229}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1854627539013140402}{} 
\hyperlink{1854627539013140402}{\texttt{Base.nonmissingtype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nonmissingtype(T::Type)
\end{minted}

If \texttt{T} is a union of types containing \texttt{Missing}, return a new type with \texttt{Missing} removed.

\textbf{Examples}


\begin{minted}{jlcon}
julia> nonmissingtype(Union{Int64,Missing})
Int64

julia> nonmissingtype(Any)
Any
\end{minted}

\begin{quote}
\textbf{Julia 1.3}

\end{quote}
This function is exported as of Julia 1.3.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/missing.jl#L21-L38}{\texttt{source}}


\end{adjustwidth}

\hypertarget{16829646620249903859}{}


\section{System}


\hypertarget{18309243184998755104}{} 
\hyperlink{18309243184998755104}{\texttt{Base.run}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
run(command, args...; wait::Bool = true)
\end{minted}

Run a command object, constructed with backticks (see the \href{@ref}{Running External Programs} section in the manual). Throws an error if anything goes wrong, including the process exiting with a non-zero status (when \texttt{wait} is true).

If \texttt{wait} is false, the process runs asynchronously. You can later wait for it and check its exit status by calling \texttt{success} on the returned process object.

When \texttt{wait} is false, the process{\textquotesingle} I/O streams are directed to \texttt{devnull}. When \texttt{wait} is true, I/O streams are shared with the parent process. Use \hyperlink{17710887576380723118}{\texttt{pipeline}} to control I/O redirection.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/process.jl#L423-L436}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13412111234074215621}{} 
\hyperlink{13412111234074215621}{\texttt{Base.devnull}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
devnull
\end{minted}

Used in a stream redirect to discard all data written to it. Essentially equivalent to \texttt{/dev/null} on Unix or \texttt{NUL} on Windows. Usage:


\begin{minted}{julia}
run(pipeline(`cat test.txt`, devnull))
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1036-L1045}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3068527349757478883}{} 
\hyperlink{3068527349757478883}{\texttt{Base.success}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
success(command)
\end{minted}

Run a command object, constructed with backticks (see the \href{@ref}{Running External Programs} section in the manual), and tell whether it was successful (exited with a code of 0). An exception is raised if the process cannot be started.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/process.jl#L489-L495}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15578977278493337913}{} 
\hyperlink{15578977278493337913}{\texttt{Base.process\_running}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
process_running(p::Process)
\end{minted}

Determine whether a process is currently running.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/process.jl#L587-L591}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13017420786720044448}{} 
\hyperlink{13017420786720044448}{\texttt{Base.process\_exited}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
process_exited(p::Process)
\end{minted}

Determine whether a process has exited.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/process.jl#L596-L600}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1615401929219773934}{} 
\hyperlink{1615401929219773934}{\texttt{Base.kill}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
kill(p::Process, signum=Base.SIGTERM)
\end{minted}

Send a signal to a process. The default is to terminate the process. Returns successfully if the process has already exited, but throws an error if killing the process failed for other reasons (e.g. insufficient permissions).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/process.jl#L541-L548}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18437818836884264741}{} 
\hyperlink{18437818836884264741}{\texttt{Base.Sys.set\_process\_title}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.set_process_title(title::AbstractString)
\end{minted}

Set the process title. No-op on some operating systems.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L268-L272}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10090978748613293378}{} 
\hyperlink{10090978748613293378}{\texttt{Base.Sys.get\_process\_title}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.get_process_title()
\end{minted}

Get the process title. On some systems, will always return an empty string.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L256-L260}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14924556434347277048}{} 
\hyperlink{14924556434347277048}{\texttt{Base.ignorestatus}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ignorestatus(command)
\end{minted}

Mark a command object so that running it will not throw an error if the result code is non-zero.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/cmd.jl#L195-L199}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3965292339357216921}{} 
\hyperlink{3965292339357216921}{\texttt{Base.detach}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
detach(command)
\end{minted}

Mark a command object so that it will be run in a new process group, allowing it to outlive the julia process, and not have Ctrl-C interrupts passed to it.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/cmd.jl#L204-L208}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10541952265148699805}{} 
\hyperlink{10541952265148699805}{\texttt{Base.Cmd}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cmd(cmd::Cmd; ignorestatus, detach, windows_verbatim, windows_hide, env, dir)
\end{minted}

Construct a new \texttt{Cmd} object, representing an external program and arguments, from \texttt{cmd}, while changing the settings of the optional keyword arguments:

\begin{itemize}
\item \texttt{ignorestatus::Bool}: If \texttt{true} (defaults to \texttt{false}), then the \texttt{Cmd} will not throw an error if the return code is nonzero.


\item \texttt{detach::Bool}: If \texttt{true} (defaults to \texttt{false}), then the \texttt{Cmd} will be run in a new process group, allowing it to outlive the \texttt{julia} process and not have Ctrl-C passed to it.


\item \texttt{windows\_verbatim::Bool}: If \texttt{true} (defaults to \texttt{false}), then on Windows the \texttt{Cmd} will send a command-line string to the process with no quoting or escaping of arguments, even arguments containing spaces. (On Windows, arguments are sent to a program as a single {\textquotedbl}command-line{\textquotedbl} string, and programs are responsible for parsing it into arguments. By default, empty arguments and arguments with spaces or tabs are quoted with double quotes \texttt{{\textquotedbl}} in the command line, and \texttt{{\textbackslash}} or \texttt{{\textquotedbl}} are preceded by backslashes. \texttt{windows\_verbatim=true} is useful for launching programs that parse their command line in nonstandard ways.) Has no effect on non-Windows systems.


\item \texttt{windows\_hide::Bool}: If \texttt{true} (defaults to \texttt{false}), then on Windows no new console window is displayed when the \texttt{Cmd} is executed. This has no effect if a console is already open or on non-Windows systems.


\item \texttt{env}: Set environment variables to use when running the \texttt{Cmd}. \texttt{env} is either a dictionary mapping strings to strings, an array of strings of the form \texttt{{\textquotedbl}var=val{\textquotedbl}}, an array or tuple of \texttt{{\textquotedbl}var{\textquotedbl}=>val} pairs, or \texttt{nothing}. In order to modify (rather than replace) the existing environment, create \texttt{env} by \texttt{copy(ENV)} and then set \texttt{env[{\textquotedbl}var{\textquotedbl}]=val} as desired.


\item \texttt{dir::AbstractString}: Specify a working directory for the command (instead of the current directory).

\end{itemize}
For any keywords that are not specified, the current settings from \texttt{cmd} are used. Normally, to create a \texttt{Cmd} object in the first place, one uses backticks, e.g.


\begin{lstlisting}
Cmd(`echo "Hello world"`, ignorestatus=true, detach=false)
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/cmd.jl#L39-L73}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14476048880059260855}{} 
\hyperlink{14476048880059260855}{\texttt{Base.setenv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
setenv(command::Cmd, env; dir="")
\end{minted}

Set environment variables to use when running the given \texttt{command}. \texttt{env} is either a dictionary mapping strings to strings, an array of strings of the form \texttt{{\textquotedbl}var=val{\textquotedbl}}, or zero or more \texttt{{\textquotedbl}var{\textquotedbl}=>val} pair arguments. In order to modify (rather than replace) the existing environment, create \texttt{env} by \texttt{copy(ENV)} and then setting \texttt{env[{\textquotedbl}var{\textquotedbl}]=val} as desired, or use \texttt{withenv}.

The \texttt{dir} keyword argument can be used to specify a working directory for the command.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/cmd.jl#L229-L239}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16080922180039851128}{} 
\hyperlink{16080922180039851128}{\texttt{Base.withenv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
withenv(f::Function, kv::Pair...)
\end{minted}

Execute \texttt{f} in an environment that is temporarily modified (not replaced as in \texttt{setenv}) by zero or more \texttt{{\textquotedbl}var{\textquotedbl}=>val} arguments \texttt{kv}. \texttt{withenv} is generally used via the \texttt{withenv(kv...) do ... end} syntax. A value of \texttt{nothing} can be used to temporarily unset an environment variable (if it is set). When \texttt{withenv} returns, the original environment has been restored.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/env.jl#L146-L154}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17710887576380723118}{} 
\hyperlink{17710887576380723118}{\texttt{Base.pipeline}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pipeline(from, to, ...)
\end{minted}

Create a pipeline from a data source to a destination. The source and destination can be commands, I/O streams, strings, or results of other \texttt{pipeline} calls. At least one argument must be a command. Strings refer to filenames. When called with more than two arguments, they are chained together from left to right. For example, \texttt{pipeline(a,b,c)} is equivalent to \texttt{pipeline(pipeline(a,b),c)}. This provides a more concise way to specify multi-stage pipelines.

\textbf{Examples}:


\begin{minted}{julia}
run(pipeline(`ls`, `grep xyz`))
run(pipeline(`ls`, "out.txt"))
run(pipeline("out.txt", `grep xyz`))
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/cmd.jl#L296-L313}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14749518171354514193}{} 
\hyperlink{14749518171354514193}{\texttt{Base.pipeline}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pipeline(command; stdin, stdout, stderr, append=false)
\end{minted}

Redirect I/O to or from the given \texttt{command}. Keyword arguments specify which of the command{\textquotesingle}s streams should be redirected. \texttt{append} controls whether file output appends to the file. This is a more general version of the 2-argument \texttt{pipeline} function. \texttt{pipeline(from, to)} is equivalent to \texttt{pipeline(from, stdout=to)} when \texttt{from} is a command, and to \texttt{pipeline(to, stdin=from)} when \texttt{from} is another kind of data source.

\textbf{Examples}:


\begin{minted}{julia}
run(pipeline(`dothings`, stdout="out.txt", stderr="errs.txt"))
run(pipeline(`update`, stdout="log.txt", append=true))
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/cmd.jl#L261-L276}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1938096715296079780}{} 
\hyperlink{1938096715296079780}{\texttt{Base.Libc.gethostname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gethostname() -> AbstractString
\end{minted}

Get the local machine{\textquotesingle}s host name.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L260-L264}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13507906219795618929}{} 
\hyperlink{13507906219795618929}{\texttt{Base.Libc.getpid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getpid(process) -> Int32
\end{minted}

Get the child process ID, if it still exists.

\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/process.jl#L565-L572}{\texttt{source}}



\begin{lstlisting}
getpid() -> Int32
\end{lstlisting}

Get Julia{\textquotesingle}s process ID.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L251-L255}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2441622941271736623}{} 
\hyperlink{2441622941271736623}{\texttt{Base.Libc.time}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
time()
\end{minted}

Get the system time in seconds since the epoch, with fairly high (typically, microsecond) resolution.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L242-L246}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3638234932564609978}{} 
\hyperlink{3638234932564609978}{\texttt{Base.time\_ns}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
time_ns()
\end{minted}

Get the time in nanoseconds. The time corresponding to 0 is undefined, and wraps every 5.8 years.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/Base.jl#L60-L64}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8029752041511656628}{} 
\hyperlink{8029752041511656628}{\texttt{Base.@time}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@time
\end{minted}

A macro to execute an expression, printing the time it took to execute, the number of allocations, and the total number of bytes its execution caused to be allocated, before returning the value of the expression.

See also \hyperlink{16435014226257034667}{\texttt{@timev}}, \hyperlink{6506376105249440645}{\texttt{@timed}}, \hyperlink{13321256500037064321}{\texttt{@elapsed}}, and \hyperlink{5377755456008435782}{\texttt{@allocated}}.

\begin{quote}
\textbf{Note}

For more serious benchmarking, consider the \texttt{@btime} macro from the BenchmarkTools.jl package which among other things evaluates the function multiple times in order to reduce noise.

\end{quote}

\begin{minted}{jlcon}
julia> @time rand(10^6);
  0.001525 seconds (7 allocations: 7.630 MiB)

julia> @time begin
           sleep(0.3)
           1+1
       end
  0.301395 seconds (8 allocations: 336 bytes)
2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/util.jl#L143-L169}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16435014226257034667}{} 
\hyperlink{16435014226257034667}{\texttt{Base.@timev}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@timev
\end{minted}

This is a verbose version of the \texttt{@time} macro. It first prints the same information as \texttt{@time}, then any non-zero memory allocation counters, and then returns the value of the expression.

See also \hyperlink{8029752041511656628}{\texttt{@time}}, \hyperlink{6506376105249440645}{\texttt{@timed}}, \hyperlink{13321256500037064321}{\texttt{@elapsed}}, and \hyperlink{5377755456008435782}{\texttt{@allocated}}.


\begin{minted}{jlcon}
julia> @timev rand(10^6);
  0.001006 seconds (7 allocations: 7.630 MiB)
elapsed time (ns): 1005567
bytes allocated:   8000256
pool allocs:       6
malloc() calls:    1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/util.jl#L185-L203}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6506376105249440645}{} 
\hyperlink{6506376105249440645}{\texttt{Base.@timed}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@timed
\end{minted}

A macro to execute an expression, and return the value of the expression, elapsed time, total bytes allocated, garbage collection time, and an object with various memory allocation counters.

See also \hyperlink{8029752041511656628}{\texttt{@time}}, \hyperlink{16435014226257034667}{\texttt{@timev}}, \hyperlink{13321256500037064321}{\texttt{@elapsed}}, and \hyperlink{5377755456008435782}{\texttt{@allocated}}.


\begin{minted}{jlcon}
julia> val, t, bytes, gctime, memallocs = @timed rand(10^6);

julia> t
0.006634834

julia> bytes
8000256

julia> gctime
0.0055765

julia> fieldnames(typeof(memallocs))
(:allocd, :malloc, :realloc, :poolalloc, :bigalloc, :freecall, :total_time, :pause, :full_sweep)

julia> memallocs.total_time
5576500
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/util.jl#L274-L302}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13321256500037064321}{} 
\hyperlink{13321256500037064321}{\texttt{Base.@elapsed}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@elapsed
\end{minted}

A macro to evaluate an expression, discarding the resulting value, instead returning the number of seconds it took to execute as a floating-point number.

See also \hyperlink{8029752041511656628}{\texttt{@time}}, \hyperlink{16435014226257034667}{\texttt{@timev}}, \hyperlink{6506376105249440645}{\texttt{@timed}}, and \hyperlink{5377755456008435782}{\texttt{@allocated}}.


\begin{minted}{jlcon}
julia> @elapsed sleep(0.3)
0.301391426
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/util.jl#L216-L229}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5377755456008435782}{} 
\hyperlink{5377755456008435782}{\texttt{Base.@allocated}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@allocated
\end{minted}

A macro to evaluate an expression, discarding the resulting value, instead returning the total number of bytes allocated during evaluation of the expression.

See also \hyperlink{8029752041511656628}{\texttt{@time}}, \hyperlink{16435014226257034667}{\texttt{@timev}}, \hyperlink{6506376105249440645}{\texttt{@timed}}, and \hyperlink{13321256500037064321}{\texttt{@elapsed}}.


\begin{minted}{jlcon}
julia> @allocated rand(10^6)
8000080
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/util.jl#L248-L261}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13502577110353968166}{} 
\hyperlink{13502577110353968166}{\texttt{Base.EnvDict}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
EnvDict() -> EnvDict
\end{minted}

A singleton of this type provides a hash table interface to environment variables.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/env.jl#L59-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{196658496437650743}{} 
\hyperlink{196658496437650743}{\texttt{Base.ENV}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ENV
\end{minted}

Reference to the singleton \texttt{EnvDict}, providing a dictionary interface to system environment variables.

(On Windows, system environment variables are case-insensitive, and \texttt{ENV} correspondingly converts all keys to uppercase for display, iteration, and copying. Portable code should not rely on the ability to distinguish variables by case, and should beware that setting an ostensibly lowercase variable may result in an uppercase \texttt{ENV} key.)



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/env.jl#L66-L76}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10436581591987980463}{} 
\hyperlink{10436581591987980463}{\texttt{Base.Sys.isunix}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.isunix([os])
\end{minted}

Predicate for testing if the OS provides a Unix-like interface. See documentation in \href{@ref}{Handling Operating System Variation}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L288-L293}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2208925609939091556}{} 
\hyperlink{2208925609939091556}{\texttt{Base.Sys.isapple}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.isapple([os])
\end{minted}

Predicate for testing if the OS is a derivative of Apple Macintosh OS X or Darwin. See documentation in \href{@ref}{Handling Operating System Variation}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L395-L400}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17218792417395859538}{} 
\hyperlink{17218792417395859538}{\texttt{Base.Sys.islinux}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.islinux([os])
\end{minted}

Predicate for testing if the OS is a derivative of Linux. See documentation in \href{@ref}{Handling Operating System Variation}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L310-L315}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2887161873276448004}{} 
\hyperlink{2887161873276448004}{\texttt{Base.Sys.isbsd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.isbsd([os])
\end{minted}

Predicate for testing if the OS is a derivative of BSD. See documentation in \href{@ref}{Handling Operating System Variation}.

\begin{quote}
\textbf{Note}

The Darwin kernel descends from BSD, which means that \texttt{Sys.isbsd()} is \texttt{true} on macOS systems. To exclude macOS from a predicate, use \texttt{Sys.isbsd() \&\& !Sys.isapple()}.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L318-L328}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11529071867109632004}{} 
\hyperlink{11529071867109632004}{\texttt{Base.Sys.isfreebsd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.isfreebsd([os])
\end{minted}

Predicate for testing if the OS is a derivative of FreeBSD. See documentation in \href{@ref}{Handling Operating System Variation}.

\begin{quote}
\textbf{Note}

Not to be confused with \texttt{Sys.isbsd()}, which is \texttt{true} on FreeBSD but also on other BSD-based systems. \texttt{Sys.isfreebsd()} refers only to FreeBSD.

\end{quote}
\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L331-L342}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9449644140157558794}{} 
\hyperlink{9449644140157558794}{\texttt{Base.Sys.isopenbsd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.isopenbsd([os])
\end{minted}

Predicate for testing if the OS is a derivative of OpenBSD. See documentation in \href{@ref}{Handling Operating System Variation}.

\begin{quote}
\textbf{Note}

Not to be confused with \texttt{Sys.isbsd()}, which is \texttt{true} on OpenBSD but also on other BSD-based systems. \texttt{Sys.isopenbsd()} refers only to OpenBSD.

\end{quote}
\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L345-L356}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5472156301464507299}{} 
\hyperlink{5472156301464507299}{\texttt{Base.Sys.isnetbsd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.isnetbsd([os])
\end{minted}

Predicate for testing if the OS is a derivative of NetBSD. See documentation in \href{@ref}{Handling Operating System Variation}.

\begin{quote}
\textbf{Note}

Not to be confused with \texttt{Sys.isbsd()}, which is \texttt{true} on NetBSD but also on other BSD-based systems. \texttt{Sys.isnetbsd()} refers only to NetBSD.

\end{quote}
\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L359-L370}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2925171972183731495}{} 
\hyperlink{2925171972183731495}{\texttt{Base.Sys.isdragonfly}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.isdragonfly([os])
\end{minted}

Predicate for testing if the OS is a derivative of DragonFly BSD. See documentation in \href{@ref}{Handling Operating System Variation}.

\begin{quote}
\textbf{Note}

Not to be confused with \texttt{Sys.isbsd()}, which is \texttt{true} on DragonFly but also on other BSD-based systems. \texttt{Sys.isdragonfly()} refers only to DragonFly.

\end{quote}
\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L373-L384}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16249920580734218703}{} 
\hyperlink{16249920580734218703}{\texttt{Base.Sys.iswindows}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.iswindows([os])
\end{minted}

Predicate for testing if the OS is a derivative of Microsoft Windows NT. See documentation in \href{@ref}{Handling Operating System Variation}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L387-L392}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17167896699654870190}{} 
\hyperlink{17167896699654870190}{\texttt{Base.Sys.windows\_version}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.windows_version()
\end{minted}

Return the version number for the Windows NT Kernel as a \texttt{VersionNumber}, i.e. \texttt{v{\textquotedbl}major.minor.build{\textquotedbl}}, or \texttt{v{\textquotedbl}0.0.0{\textquotedbl}} if this is not running on Windows.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L427-L432}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7740760197620822749}{} 
\hyperlink{7740760197620822749}{\texttt{Base.Sys.free\_memory}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.free_memory()
\end{minted}

Get the total free memory in RAM in kilobytes.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L242-L246}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10546193444003448021}{} 
\hyperlink{10546193444003448021}{\texttt{Base.Sys.total\_memory}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.total_memory()
\end{minted}

Get the total memory in RAM (including that which is currently used) in kilobytes.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L249-L253}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15508347639286112437}{} 
\hyperlink{15508347639286112437}{\texttt{Base.@static}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@static
\end{minted}

Partially evaluate an expression at parse time.

For example, \texttt{@static Sys.iswindows() ? foo : bar} will evaluate \texttt{Sys.iswindows()} and insert either \texttt{foo} or \texttt{bar} into the expression. This is useful in cases where a construct would be invalid on other platforms, such as a \texttt{ccall} to a non-existent function. \texttt{@static if Sys.isapple() foo end} and \texttt{@static foo <\&\&,||> bar} are also valid syntax.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/osutils.jl#L3-L13}{\texttt{source}}


\end{adjustwidth}

\hypertarget{12706049637458593234}{}


\section{Versioning}


\hypertarget{16653194174751393225}{} 
\hyperlink{16653194174751393225}{\texttt{Base.VersionNumber}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
VersionNumber
\end{minted}

Version number type which follow the specifications of \href{https://semver.org/}{semantic versioning}, composed of major, minor and patch numeric values, followed by pre-release and build alpha-numeric annotations. See also \hyperlink{8914616188788850763}{\texttt{@v\_str}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> VersionNumber("1.2.3")
v"1.2.3"

julia> VersionNumber("2.0.1-rc1")
v"2.0.1-rc1"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/version.jl#L6-L22}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8914616188788850763}{} 
\hyperlink{8914616188788850763}{\texttt{Base.@v\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@v_str
\end{minted}

String macro used to parse a string to a \hyperlink{16653194174751393225}{\texttt{VersionNumber}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v"1.2.3"
v"1.2.3"

julia> v"2.0.1-rc1"
v"2.0.1-rc1"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/version.jl#L124-L137}{\texttt{source}}


\end{adjustwidth}

\hypertarget{7115517658733019231}{}


\section{Errors}


\hypertarget{17992125292605951734}{} 
\hyperlink{17992125292605951734}{\texttt{Base.error}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
error(message::AbstractString)
\end{minted}

Raise an \texttt{ErrorException} with the given message.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/error.jl#L28-L32}{\texttt{source}}



\begin{lstlisting}
error(msg...)
\end{lstlisting}

Raise an \texttt{ErrorException} with the given message.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/error.jl#L35-L39}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16410366672587017456}{} 
\hyperlink{16410366672587017456}{\texttt{Core.throw}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
throw(e)
\end{minted}

Throw an object as an exception.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/error.jl#L19-L23}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2102349972401293064}{} 
\hyperlink{2102349972401293064}{\texttt{Base.rethrow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rethrow()
\end{minted}

Rethrow the current exception from within a \texttt{catch} block. The rethrown exception will continue propagation as if it had not been caught.

\begin{quote}
\textbf{Note}

The alternative form \texttt{rethrow(e)} allows you to associate an alternative exception object \texttt{e} with the current backtrace. However this misrepresents the program state at the time of the error so you{\textquotesingle}re encouraged to instead throw a new exception using \texttt{throw(e)}. In Julia 1.1 and above, using \texttt{throw(e)} will preserve the root cause exception on the stack, as described in \hyperlink{5950075931444385711}{\texttt{catch\_stack}}.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/error.jl#L45-L58}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6187626674327343338}{} 
\hyperlink{6187626674327343338}{\texttt{Base.backtrace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
backtrace()
\end{minted}

Get a backtrace object for the current program point.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/error.jl#L102-L106}{\texttt{source}}


\end{adjustwidth}
\hypertarget{98342946516168163}{} 
\hyperlink{98342946516168163}{\texttt{Base.catch\_backtrace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
catch_backtrace()
\end{minted}

Get the backtrace of the current exception, for use within \texttt{catch} blocks.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/error.jl#L116-L120}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5950075931444385711}{} 
\hyperlink{5950075931444385711}{\texttt{Base.catch\_stack}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
catch_stack(task=current_task(); [inclue_bt=true])
\end{minted}

Get the stack of exceptions currently being handled. For nested catch blocks there may be more than one current exception in which case the most recently thrown exception is last in the stack. The stack is returned as a Vector of \texttt{(exception,backtrace)} pairs, or a Vector of exceptions if \texttt{include\_bt} is false.

Explicitly passing \texttt{task} will return the current exception stack on an arbitrary task. This is useful for inspecting tasks which have failed due to uncaught exceptions.

\begin{quote}
\textbf{Julia 1.1}

This function is experimental in Julia 1.1 and will likely be renamed in a future release (see https://github.com/JuliaLang/julia/pull/29901).

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/error.jl#L126-L142}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4796942656392369899}{} 
\hyperlink{4796942656392369899}{\texttt{Base.@assert}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@assert cond [text]
\end{minted}

Throw an \hyperlink{11676817432925230066}{\texttt{AssertionError}} if \texttt{cond} is \texttt{false}. Preferred syntax for writing assertions. Message \texttt{text} is optionally displayed upon assertion failure.

\begin{quote}
\textbf{Warning}

An assert might be disabled at various optimization levels. Assert should therefore only be used as a debugging tool and not used for authentication verification (e.g., verifying passwords), nor should side effects needed for the function to work correctly be used inside of asserts.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> @assert iseven(3) "3 is an odd number!"
ERROR: AssertionError: 3 is an odd number!

julia> @assert isodd(3) "What even are numbers?"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/error.jl#L189-L209}{\texttt{source}}


\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Base.Experimental.register\_error\_hint}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}


\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Base.Experimental.show\_error\_hints}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{9721838137887538764}{} 
\hyperlink{9721838137887538764}{\texttt{Core.ArgumentError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ArgumentError(msg)
\end{minted}

The parameters to a function call do not match a valid signature. Argument \texttt{msg} is a descriptive error string.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2029-L2034}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11676817432925230066}{} 
\hyperlink{11676817432925230066}{\texttt{Core.AssertionError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AssertionError([msg])
\end{minted}

The asserted condition did not evaluate to \texttt{true}. Optional argument \texttt{msg} is a descriptive error string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> @assert false "this is not true"
ERROR: AssertionError: this is not true
\end{minted}

\texttt{AssertionError} is usually thrown from \hyperlink{4796942656392369899}{\texttt{@assert}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2045-L2058}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9731558909100893938}{} 
\hyperlink{9731558909100893938}{\texttt{Core.BoundsError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
BoundsError([a],[i])
\end{minted}

An indexing operation into an array, \texttt{a}, tried to access an out-of-bounds element at index \texttt{i}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = fill(1.0, 7);

julia> A[8]
ERROR: BoundsError: attempt to access 7-element Array{Float64,1} at index [8]
Stacktrace:
 [1] getindex(::Array{Float64,1}, ::Int64) at ./array.jl:660
 [2] top-level scope

julia> B = fill(1.0, (2,3));

julia> B[2, 4]
ERROR: BoundsError: attempt to access 2×3 Array{Float64,2} at index [2, 4]
Stacktrace:
 [1] getindex(::Array{Float64,2}, ::Int64, ::Int64) at ./array.jl:661
 [2] top-level scope

julia> B[9]
ERROR: BoundsError: attempt to access 2×3 Array{Float64,2} at index [9]
Stacktrace:
 [1] getindex(::Array{Float64,2}, ::Int64) at ./array.jl:660
 [2] top-level scope
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1191-L1220}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15047752250898038281}{} 
\hyperlink{15047752250898038281}{\texttt{Base.CompositeException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
CompositeException
\end{minted}

Wrap a \texttt{Vector} of exceptions thrown by a \hyperlink{7131243650304654155}{\texttt{Task}} (e.g. generated from a remote worker over a channel or an asynchronously executing local I/O write or a remote worker under \texttt{pmap}) with information about the series of exceptions. For example, if a group of workers are executing several tasks, and multiple workers fail, the resulting \texttt{CompositeException} will contain a {\textquotedbl}bundle{\textquotedbl} of information from each worker indicating where and why the exception(s) occurred.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L28-L35}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13752533629496758140}{} 
\hyperlink{13752533629496758140}{\texttt{Base.DimensionMismatch}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DimensionMismatch([msg])
\end{minted}

The objects called do not have matching dimensionality. Optional argument \texttt{msg} is a descriptive error string.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L5-L10}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4168463413201806292}{} 
\hyperlink{4168463413201806292}{\texttt{Core.DivideError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DivideError()
\end{minted}

Integer division was attempted with a denominator value of 0.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 2/0
Inf

julia> div(2, 0)
ERROR: DivideError: integer division error
Stacktrace:
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1440-L1455}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14085880504701688639}{} 
\hyperlink{14085880504701688639}{\texttt{Core.DomainError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DomainError(val)
DomainError(val, msg)
\end{minted}

The argument \texttt{val} to a function or constructor is outside the valid domain.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sqrt(-1)
ERROR: DomainError with -1.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1238-L1252}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2683611566077490148}{} 
\hyperlink{2683611566077490148}{\texttt{Base.EOFError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
EOFError()
\end{minted}

No more data was available to read from a file or stream.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L5-L9}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12102596058483452470}{} 
\hyperlink{12102596058483452470}{\texttt{Core.ErrorException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ErrorException(msg)
\end{minted}

Generic error type. The error message, in the \texttt{.msg} field, may provide more specific details.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ex = ErrorException("I've done a bad thing");

julia> ex.msg
"I've done a bad thing"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1098-L1110}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5399118524830636312}{} 
\hyperlink{5399118524830636312}{\texttt{Core.InexactError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
InexactError(name::Symbol, T, val)
\end{minted}

Cannot exactly convert \texttt{val} to type \texttt{T} in a method of function \texttt{name}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> convert(Float64, 1+2im)
ERROR: InexactError: Float64(1 + 2im)
Stacktrace:
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1223-L1235}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11255134339055983338}{} 
\hyperlink{11255134339055983338}{\texttt{Core.InterruptException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
InterruptException()
\end{minted}

The process was stopped by a terminal interrupt (CTRL+C).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1363-L1367}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12862287453053981792}{} 
\hyperlink{12862287453053981792}{\texttt{Base.KeyError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
KeyError(key)
\end{minted}

An indexing operation into an \texttt{AbstractDict} (\texttt{Dict}) or \texttt{Set} like object tried to access or delete a non-existent element.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L5-L10}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15548397364092946520}{} 
\hyperlink{15548397364092946520}{\texttt{Core.LoadError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LoadError(file::AbstractString, line::Int, error)
\end{minted}

An error occurred while \hyperlink{438355891087818425}{\texttt{include}}ing, \hyperlink{16690217505788642360}{\texttt{require}}ing, or \hyperlink{169458112978175560}{\texttt{using}} a file. The error specifics should be available in the \texttt{.error} field.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2061-L2066}{\texttt{source}}


\end{adjustwidth}
\hypertarget{68769522931907606}{} 
\hyperlink{68769522931907606}{\texttt{Core.MethodError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
MethodError(f, args)
\end{minted}

A method with the required type signature does not exist in the given generic function. Alternatively, there is no unique most-specific method.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2037-L2042}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16542348944118402477}{} 
\hyperlink{16542348944118402477}{\texttt{Base.MissingException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
MissingException(msg)
\end{minted}

Exception thrown when a \hyperlink{14596725676261444434}{\texttt{missing}} value is encountered in a situation where it is not supported. The error message, in the \texttt{msg} field may provide more specific details.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/missing.jl#L7-L13}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9656432107553099418}{} 
\hyperlink{9656432107553099418}{\texttt{Core.OutOfMemoryError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
OutOfMemoryError()
\end{minted}

An operation allocated too much memory for either the system or the garbage collector to handle properly.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1183-L1188}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5617183776424836760}{} 
\hyperlink{5617183776424836760}{\texttt{Core.ReadOnlyMemoryError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ReadOnlyMemoryError()
\end{minted}

An operation tried to write to memory that is read-only.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1091-L1095}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10461069697702909970}{} 
\hyperlink{10461069697702909970}{\texttt{Core.OverflowError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
OverflowError(msg)
\end{minted}

The result of an expression is too large for the specified type and will cause a wraparound.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1349-L1353}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9812388372329622426}{} 
\hyperlink{9812388372329622426}{\texttt{Base.ProcessFailedException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ProcessFailedException
\end{minted}

Indicates problematic exit status of a process. When running commands or pipelines, this is thrown to indicate a nonzero exit code was returned (i.e. that the invoked process failed).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/process.jl#L499-L505}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10362102427170738683}{} 
\hyperlink{10362102427170738683}{\texttt{Core.StackOverflowError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
StackOverflowError()
\end{minted}

The function call grew beyond the size of the call stack. This usually happens when a call recurses infinitely.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1272-L1277}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16303515589950241655}{} 
\hyperlink{16303515589950241655}{\texttt{Base.SystemError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SystemError(prefix::AbstractString, [errno::Int32])
\end{minted}

A system call failed with an error code (in the \texttt{errno} global variable).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L12-L16}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2622693721821893139}{} 
\hyperlink{2622693721821893139}{\texttt{Core.TypeError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
TypeError(func::Symbol, context::AbstractString, expected::Type, got)
\end{minted}

A type assertion failure, or calling an intrinsic function with an incorrect argument type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1356-L1360}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14325831233857471256}{} 
\hyperlink{14325831233857471256}{\texttt{Core.UndefKeywordError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UndefKeywordError(var::Symbol)
\end{minted}

The required keyword argument \texttt{var} was not assigned in a function call.

\textbf{Examples}


\begin{minted}{jlcon}
julia> function my_func(;my_arg)
           return my_arg + 1
       end
my_func (generic function with 1 method)

julia> my_func()
ERROR: UndefKeywordError: keyword argument my_arg not assigned
Stacktrace:
 [1] my_func() at ./REPL[1]:2
 [2] top-level scope at REPL[2]:1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1328-L1346}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7764749529861419421}{} 
\hyperlink{7764749529861419421}{\texttt{Core.UndefRefError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UndefRefError()
\end{minted}

The item or field is not defined for the given object.

\textbf{Examples}


\begin{minted}{jlcon}
julia> struct MyType
           a::Vector{Int}
           MyType() = new()
       end

julia> A = MyType()
MyType(#undef)

julia> A.a
ERROR: UndefRefError: access to undefined reference
Stacktrace:
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1122-L1142}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4452889246677411554}{} 
\hyperlink{4452889246677411554}{\texttt{Core.UndefVarError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UndefVarError(var::Symbol)
\end{minted}

A symbol in the current scope is not defined.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a
ERROR: UndefVarError: a not defined

julia> a = 1;

julia> a
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1310-L1325}{\texttt{source}}


\end{adjustwidth}
\hypertarget{414193743931514144}{} 
\hyperlink{414193743931514144}{\texttt{Base.StringIndexError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
StringIndexError(str, i)
\end{minted}

An error occurred when trying to access \texttt{str} at index \texttt{i} that is not valid.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/string.jl#L3-L7}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15248096136337910028}{} 
\hyperlink{15248096136337910028}{\texttt{Core.InitError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
InitError(mod::Symbol, error)
\end{minted}

An error occurred when running a module{\textquotesingle}s \texttt{\_\_init\_\_} function. The actual error thrown is available in the \texttt{.error} field.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2069-L2074}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13615447016541985376}{} 
\hyperlink{13615447016541985376}{\texttt{Base.retry}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
retry(f;  delays=ExponentialBackOff(), check=nothing) -> Function
\end{minted}

Return an anonymous function that calls function \texttt{f}.  If an exception arises, \texttt{f} is repeatedly called again, each time \texttt{check} returns \texttt{true}, after waiting the number of seconds specified in \texttt{delays}.  \texttt{check} should input \texttt{delays}{\textquotesingle}s current state and the \texttt{Exception}.

\begin{quote}
\textbf{Julia 1.2}

Before Julia 1.2 this signature was restricted to \texttt{f::Function}.

\end{quote}
\textbf{Examples}


\begin{minted}{julia}
retry(f, delays=fill(5.0, 3))
retry(f, delays=rand(5:10, 2))
retry(f, delays=Base.ExponentialBackOff(n=3, first_delay=5, max_delay=1000))
retry(http_get, check=(s,e)->e.status == "503")(url)
retry(read, check=(s,e)->isa(e, IOError))(io, 128; all=false)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/error.jl#L262-L281}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5330798934113311579}{} 
\hyperlink{5330798934113311579}{\texttt{Base.ExponentialBackOff}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ExponentialBackOff(; n=1, first_delay=0.05, max_delay=10.0, factor=5.0, jitter=0.1)
\end{minted}

A \hyperlink{5027751419500983000}{\texttt{Float64}} iterator of length \texttt{n} whose elements exponentially increase at a rate in the interval \texttt{factor} * (1 ± \texttt{jitter}).  The first element is \texttt{first\_delay} and all elements are clamped to \texttt{max\_delay}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/error.jl#L243-L249}{\texttt{source}}


\end{adjustwidth}

\hypertarget{1591085875948558926}{}


\section{Events}


\hypertarget{16894292126246559716}{} 
\hyperlink{16894292126246559716}{\texttt{Base.Timer}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Timer(callback::Function, delay; interval = 0)
\end{minted}

Create a timer that wakes up tasks waiting for it (by calling \hyperlink{13761789780433862250}{\texttt{wait}} on the timer object) and calls the function \texttt{callback}.

Waiting tasks are woken and the function \texttt{callback} is called after an initial delay of \texttt{delay} seconds, and then repeating with the given \texttt{interval} in seconds. If \texttt{interval} is equal to \texttt{0}, the timer is only triggered once. The function \texttt{callback} is called with a single argument, the timer itself. When the timer is closed (by \hyperlink{5331333469799487255}{\texttt{close}} waiting tasks are woken with an error. Use \hyperlink{12411519405593851135}{\texttt{isopen}} to check whether a timer is still active.

\textbf{Examples}

Here the first number is printed after a delay of two seconds, then the following numbers are printed quickly.


\begin{minted}{jlcon}
julia> begin
           i = 0
           cb(timer) = (global i += 1; println(i))
           t = Timer(cb, 2, interval=0.2)
           wait(t)
           sleep(0.5)
           close(t)
       end
1
2
3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/asyncevent.jl#L218-L247}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11288834678466677845}{} 
\hyperlink{11288834678466677845}{\texttt{Base.Timer}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Timer(delay; interval = 0)
\end{minted}

Create a timer that wakes up tasks waiting for it (by calling \hyperlink{13761789780433862250}{\texttt{wait}} on the timer object).

Waiting tasks are woken after an initial delay of \texttt{delay} seconds, and then repeating with the given \texttt{interval} in seconds. If \texttt{interval} is equal to \texttt{0}, the timer is only triggered once. When the timer is closed (by \hyperlink{5331333469799487255}{\texttt{close}} waiting tasks are woken with an error. Use \hyperlink{12411519405593851135}{\texttt{isopen}} to check whether a timer is still active.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/asyncevent.jl#L55-L64}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6110056827764884232}{} 
\hyperlink{6110056827764884232}{\texttt{Base.AsyncCondition}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AsyncCondition()
\end{minted}

Create a async condition that wakes up tasks waiting for it (by calling \hyperlink{13761789780433862250}{\texttt{wait}} on the object) when notified from C by a call to \texttt{uv\_async\_send}. Waiting tasks are woken with an error when the object is closed (by \hyperlink{5331333469799487255}{\texttt{close}}. Use \hyperlink{12411519405593851135}{\texttt{isopen}} to check whether it is still active.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/asyncevent.jl#L5-L13}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11991658286161618588}{} 
\hyperlink{11991658286161618588}{\texttt{Base.AsyncCondition}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AsyncCondition(callback::Function)
\end{minted}

Create a async condition that calls the given \texttt{callback} function. The \texttt{callback} is passed one argument, the async condition object itself.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/asyncevent.jl#L38-L43}{\texttt{source}}


\end{adjustwidth}

\hypertarget{15814129481708918585}{}


\section{Reflection}


\hypertarget{15855443469905882708}{} 
\hyperlink{15855443469905882708}{\texttt{Base.nameof}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nameof(m::Module) -> Symbol
\end{minted}

Get the name of a \texttt{Module} as a \hyperlink{18332791376992528422}{\texttt{Symbol}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> nameof(Base.Broadcast)
:Broadcast
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L5-L15}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10164029261176394442}{} 
\hyperlink{10164029261176394442}{\texttt{Base.parentmodule}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
parentmodule(m::Module) -> Module
\end{minted}

Get a module{\textquotesingle}s enclosing \texttt{Module}. \texttt{Main} is its own parent.

\textbf{Examples}


\begin{minted}{jlcon}
julia> parentmodule(Main)
Main

julia> parentmodule(Base.Broadcast)
Base
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L18-L31}{\texttt{source}}



\begin{lstlisting}
parentmodule(t::DataType) -> Module
\end{lstlisting}

Determine the module containing the definition of a (potentially \texttt{UnionAll}-wrapped) \texttt{DataType}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> module Foo
           struct Int end
       end
Foo

julia> parentmodule(Int)
Core

julia> parentmodule(Foo.Int)
Foo
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L213-L231}{\texttt{source}}



\begin{lstlisting}
parentmodule(f::Function) -> Module
\end{lstlisting}

Determine the module containing the (first) definition of a generic function.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L1189-L1194}{\texttt{source}}



\begin{lstlisting}
parentmodule(f::Function, types) -> Module
\end{lstlisting}

Determine the module containing a given definition of a generic function.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L1197-L1201}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1055866307163702776}{} 
\hyperlink{1055866307163702776}{\texttt{Base.pathof}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pathof(m::Module)
\end{minted}

Return the path of the \texttt{m.jl} file that was used to \texttt{import} module \texttt{m}, or \texttt{nothing} if \texttt{m} was not imported from a package.

Use \hyperlink{10993431289442855643}{\texttt{dirname}} to get the directory part and \hyperlink{16452154606861459390}{\texttt{basename}} to get the file name part of the path.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/loading.jl#L272-L280}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10679300263900972054}{} 
\hyperlink{10679300263900972054}{\texttt{Base.moduleroot}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
moduleroot(m::Module) -> Module
\end{minted}

Find the root module of a given module. This is the first module in the chain of parent modules of \texttt{m} which is either a registered root module or which is its own parent module.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L34-L40}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8796901235206560169}{} 
\hyperlink{8796901235206560169}{\texttt{Base.@\_\_MODULE\_\_}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@__MODULE__ -> Module
\end{minted}

Get the \texttt{Module} of the toplevel eval, which is the \texttt{Module} code is currently being read from.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L50-L55}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17712571889684451973}{} 
\hyperlink{17712571889684451973}{\texttt{Base.fullname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fullname(m::Module)
\end{minted}

Get the fully-qualified name of a module as a tuple of symbols. For example,

\textbf{Examples}


\begin{minted}{jlcon}
julia> fullname(Base.Iterators)
(:Base, :Iterators)

julia> fullname(Main)
(:Main,)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L60-L73}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6473328671144201991}{} 
\hyperlink{6473328671144201991}{\texttt{Base.names}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
names(x::Module; all::Bool = false, imported::Bool = false)
\end{minted}

Get an array of the names exported by a \texttt{Module}, excluding deprecated names. If \texttt{all} is true, then the list also includes non-exported names defined in the module, deprecated names, and compiler-generated names. If \texttt{imported} is true, then names explicitly imported from other modules are also included.

As a special case, all names defined in \texttt{Main} are considered {\textquotedbl}exported{\textquotedbl}, since it is not idiomatic to explicitly export names from \texttt{Main}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L86-L97}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4268493915558726264}{} 
\hyperlink{4268493915558726264}{\texttt{Core.nfields}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nfields(x) -> Int
\end{minted}

Get the number of fields in the given object.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = 1//2;

julia> nfields(a)
2

julia> b = 1
1

julia> nfields(b)
0

julia> ex = ErrorException("I've done a bad thing");

julia> nfields(ex)
1
\end{minted}

In these examples, \texttt{a} is a \hyperlink{8304566144531167610}{\texttt{Rational}}, which has two fields. \texttt{b} is an \texttt{Int}, which is a primitive bitstype with no fields at all. \texttt{ex} is an \hyperlink{12102596058483452470}{\texttt{ErrorException}}, which has one field.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1280-L1307}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15692280320547071693}{} 
\hyperlink{15692280320547071693}{\texttt{Base.isconst}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isconst(m::Module, s::Symbol) -> Bool
\end{minted}

Determine whether a global is declared \texttt{const} in a given \texttt{Module}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L235-L239}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7261886635035590602}{} 
\hyperlink{7261886635035590602}{\texttt{Base.nameof}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nameof(f::Function) -> Symbol
\end{minted}

Get the name of a generic \texttt{Function} as a symbol. For anonymous functions, this is a compiler-generated name. For explicitly-declared subtypes of \texttt{Function}, it is the name of the function{\textquotesingle}s type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L1167-L1173}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4995931598335689542}{} 
\hyperlink{4995931598335689542}{\texttt{Base.functionloc}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
functionloc(f::Function, types)
\end{minted}

Returns a tuple \texttt{(filename,line)} giving the location of a generic \texttt{Function} definition.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/methodshow.jl#L158-L162}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10700244958032489972}{} 
\hyperlink{10700244958032489972}{\texttt{Base.functionloc}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
functionloc(m::Method)
\end{minted}

Returns a tuple \texttt{(filename,line)} giving the location of a \texttt{Method} definition.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/methodshow.jl#L145-L149}{\texttt{source}}


\end{adjustwidth}

\hypertarget{15339696196009341465}{}


\section{Internals}


\hypertarget{16287035550645122381}{} 
\hyperlink{16287035550645122381}{\texttt{Base.GC.gc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GC.gc([full=true])
\end{minted}

Perform garbage collection. The argument \texttt{full} determines the kind of collection: A full collection (default) sweeps all objects, which makes the next GC scan much slower, while an incremental collection may only sweep so-called young objects.

\begin{quote}
\textbf{Warning}

Excessive use will likely lead to poor performance.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/gcutils.jl#L57-L67}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4235089923765717766}{} 
\hyperlink{4235089923765717766}{\texttt{Base.GC.enable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GC.enable(on::Bool)
\end{minted}

Control whether garbage collection is enabled using a boolean argument (\texttt{true} for enabled, \texttt{false} for disabled). Return previous GC state.

\begin{quote}
\textbf{Warning}

Disabling garbage collection should be used only with caution, as it can cause memory use to grow without bound.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/gcutils.jl#L71-L80}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6484353991353718972}{} 
\hyperlink{6484353991353718972}{\texttt{Base.GC.@preserve}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GC.@preserve x1 x2 ... xn expr
\end{minted}

Temporarily protect the given objects from being garbage collected, even if they would otherwise be unreferenced.

The last argument is the expression during which the object(s) will be preserved. The previous arguments are the objects to preserve.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/gcutils.jl#L83-L91}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16829072478362874105}{} 
\hyperlink{16829072478362874105}{\texttt{Base.GC.safepoint}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GC.safepoint()
\end{minted}

Inserts a point in the program where garbage collection may run. This can be useful in rare cases in multi-threaded programs where some threads are allocating memory (and hence may need to run GC) but other threads are doing only simple operations (no allocation, task switches, or I/O). Calling this function periodically in non-allocating threads allows garbage collection to run.

\begin{quote}
\textbf{Julia 1.4}

This function is available as of Julia 1.4.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/gcutils.jl#L100-L112}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6644553029841096787}{} 
\hyperlink{6644553029841096787}{\texttt{Base.Meta.lower}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lower(m, x)
\end{minted}

Takes the expression \texttt{x} and returns an equivalent expression in lowered form for executing in module \texttt{m}. See also \hyperlink{18235967286596219009}{\texttt{code\_lowered}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/meta.jl#L116-L122}{\texttt{source}}


\end{adjustwidth}
\hypertarget{480381111730976310}{} 
\hyperlink{480381111730976310}{\texttt{Base.Meta.@lower}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@lower [m] x
\end{minted}

Return lowered form of the expression \texttt{x} in module \texttt{m}. By default \texttt{m} is the module in which the macro is called. See also \hyperlink{6644553029841096787}{\texttt{lower}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/meta.jl#L125-L131}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10422957797582368651}{} 
\hyperlink{10422957797582368651}{\texttt{Base.Meta.parse}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
parse(str, start; greedy=true, raise=true, depwarn=true)
\end{minted}

Parse the expression string and return an expression (which could later be passed to eval for execution). \texttt{start} is the index of the first character to start parsing. If \texttt{greedy} is \texttt{true} (default), \texttt{parse} will try to consume as much input as it can; otherwise, it will stop as soon as it has parsed a valid expression. Incomplete but otherwise syntactically valid expressions will return \texttt{Expr(:incomplete, {\textquotedbl}(error message){\textquotedbl})}. If \texttt{raise} is \texttt{true} (default), syntax errors other than incomplete expressions will raise an error. If \texttt{raise} is \texttt{false}, \texttt{parse} will return an expression that will raise an error upon evaluation. If \texttt{depwarn} is \texttt{false}, deprecation warnings will be suppressed.


\begin{minted}{jlcon}
julia> Meta.parse("x = 3, y = 5", 7)
(:(y = 5), 13)

julia> Meta.parse("x = 3, y = 5", 5)
(:((3, y) = 5), 13)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/meta.jl#L152-L171}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13034113286621278549}{} 
\hyperlink{13034113286621278549}{\texttt{Base.Meta.parse}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
parse(str; raise=true, depwarn=true)
\end{minted}

Parse the expression string greedily, returning a single expression. An error is thrown if there are additional characters after the first expression. If \texttt{raise} is \texttt{true} (default), syntax errors will raise an error; otherwise, \texttt{parse} will return an expression that will raise an error upon evaluation.  If \texttt{depwarn} is \texttt{false}, deprecation warnings will be suppressed.


\begin{minted}{jlcon}
julia> Meta.parse("x = 3")
:(x = 3)

julia> Meta.parse("x = ")
:($(Expr(:incomplete, "incomplete: premature end of input")))

julia> Meta.parse("1.0.2")
ERROR: Base.Meta.ParseError("invalid numeric constant \"1.0.\"")
Stacktrace:
[...]

julia> Meta.parse("1.0.2"; raise = false)
:($(Expr(:error, "invalid numeric constant \"1.0.\"")))
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/meta.jl#L189-L213}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6896679243086513948}{} 
\hyperlink{6896679243086513948}{\texttt{Base.Meta.ParseError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ParseError(msg)
\end{minted}

The expression passed to the \hyperlink{10422957797582368651}{\texttt{parse}} function could not be interpreted as a valid Julia expression.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/meta.jl#L142-L147}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10163592186435616882}{} 
\hyperlink{10163592186435616882}{\texttt{Core.QuoteNode}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
QuoteNode
\end{minted}

A quoted piece of code, that does not support interpolation. See the \hyperlink{12992283596689691837}{manual section about QuoteNodes} for details.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2353-L2357}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8018172489611994488}{} 
\hyperlink{8018172489611994488}{\texttt{Base.macroexpand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
macroexpand(m::Module, x; recursive=true)
\end{minted}

Take the expression \texttt{x} and return an equivalent expression with all macros removed (expanded) for executing in module \texttt{m}. The \texttt{recursive} keyword controls whether deeper levels of nested macros are also expanded. This is demonstrated in the example below:


\begin{minted}{jlcon}
julia> module M
           macro m1()
               42
           end
           macro m2()
               :(@m1())
           end
       end
M

julia> macroexpand(M, :(@m2()), recursive=true)
42

julia> macroexpand(M, :(@m2()), recursive=false)
:(#= REPL[16]:6 =# M.@m1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/expr.jl#L81-L105}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14913190777653949565}{} 
\hyperlink{14913190777653949565}{\texttt{Base.@macroexpand}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@macroexpand
\end{minted}

Return equivalent expression with all macros removed (expanded).

There are differences between \texttt{@macroexpand} and \hyperlink{8018172489611994488}{\texttt{macroexpand}}.

\begin{itemize}
\item While \hyperlink{8018172489611994488}{\texttt{macroexpand}} takes a keyword argument \texttt{recursive}, \texttt{@macroexpand}

\end{itemize}
is always recursive. For a non recursive macro version, see \hyperlink{1640589448022397515}{\texttt{@macroexpand1}}.

\begin{itemize}
\item While \hyperlink{8018172489611994488}{\texttt{macroexpand}} has an explicit \texttt{module} argument, \texttt{@macroexpand} always

\end{itemize}
expands with respect to the module in which it is called. This is best seen in the following example:


\begin{minted}{jlcon}
julia> module M
           macro m()
               1
           end
           function f()
               (@macroexpand(@m),
                macroexpand(M, :(@m)),
                macroexpand(Main, :(@m))
               )
           end
       end
M

julia> macro m()
           2
       end
@m (macro with 1 method)

julia> M.f()
(1, 1, 2)
\end{minted}

With \texttt{@macroexpand} the expression expands where \texttt{@macroexpand} appears in the code (module \texttt{M} in the example). With \texttt{macroexpand} the expression expands in the module given as the first argument.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/expr.jl#L114-L151}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1640589448022397515}{} 
\hyperlink{1640589448022397515}{\texttt{Base.@macroexpand1}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@macroexpand1
\end{minted}

Non recursive version of \hyperlink{14913190777653949565}{\texttt{@macroexpand}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/expr.jl#L157-L161}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18235967286596219009}{} 
\hyperlink{18235967286596219009}{\texttt{Base.code\_lowered}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
code_lowered(f, types; generated=true, debuginfo=:default)
\end{minted}

Return an array of the lowered forms (IR) for the methods matching the given generic function and type signature.

If \texttt{generated} is \texttt{false}, the returned \texttt{CodeInfo} instances will correspond to fallback implementations. An error is thrown if no fallback implementation exists. If \texttt{generated} is \texttt{true}, these \texttt{CodeInfo} instances will correspond to the method bodies yielded by expanding the generators.

The keyword debuginfo controls the amount of code metadata present in the output.

Note that an error will be thrown if \texttt{types} are not leaf types when \texttt{generated} is \texttt{true} and any of the corresponding methods are an \texttt{@generated} method.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L779-L794}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14801595959157535515}{} 
\hyperlink{14801595959157535515}{\texttt{Base.code\_typed}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
code_typed(f, types; optimize=true, debuginfo=:default)
\end{minted}

Returns an array of type-inferred lowered form (IR) for the methods matching the given generic function and type signature. The keyword argument \texttt{optimize} controls whether additional optimizations, such as inlining, are also applied. The keyword \texttt{debuginfo} controls the amount of code metadata present in the output, possible options are \texttt{:source} or \texttt{:none}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L1077-L1085}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11532354486541587545}{} 
\hyperlink{11532354486541587545}{\texttt{Base.precompile}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
precompile(f, args::Tuple{Vararg{Any}})
\end{minted}

Compile the given function \texttt{f} for the argument tuple (of types) \texttt{args}, but do not execute it.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L456-L460}{\texttt{source}}


\end{adjustwidth}

\hypertarget{9034456781179297090}{}


\section{Meta}


\hypertarget{11257355729811091611}{} 
\hyperlink{11257355729811091611}{\texttt{Base.Meta.quot}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Meta.quot(ex)::Expr
\end{minted}

Quote expression \texttt{ex} to produce an expression with head \texttt{quote}. This can for instance be used to represent objects of type \texttt{Expr} in the AST. See also the manual section about \hyperlink{12992283596689691837}{QuoteNode}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> eval(Meta.quot(:x))
:x

julia> dump(Meta.quot(:x))
Expr
  head: Symbol quote
  args: Array{Any}((1,))
    1: Symbol x

julia> eval(Meta.quot(:(1+2)))
:(1 + 2)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/meta.jl#L15-L35}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1144697536461438199}{} 
\hyperlink{1144697536461438199}{\texttt{Base.Meta.isexpr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Meta.isexpr(ex, head[, n])::Bool
\end{minted}

Check if \texttt{ex} is an expression with head \texttt{head} and \texttt{n} arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ex = :(f(x))
:(f(x))

julia> Meta.isexpr(ex, :block)
false

julia> Meta.isexpr(ex, :call)
true

julia> Meta.isexpr(ex, [:block, :call]) # multiple possible heads
true

julia> Meta.isexpr(ex, :call, 1)
false

julia> Meta.isexpr(ex, :call, 2)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/meta.jl#L38-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3820669871127402199}{} 
\hyperlink{3820669871127402199}{\texttt{Base.Meta.show\_sexpr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Meta.show_sexpr([io::IO,], ex)
\end{minted}

Show expression \texttt{ex} as a lisp style S-expression.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Meta.show_sexpr(:(f(x, g(y,z))))
(:call, :f, :x, (:call, :g, :y, :z))
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/meta.jl#L68-L78}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14575780034324270910}{}


\chapter{集合和数据结构}



\hypertarget{405296213558195800}{}


\section{迭代}



序列迭代由 \hyperlink{1722534687975587846}{\texttt{iterate}} 实现 广义的 \texttt{for} 循环




\begin{minted}{julia}
for i in iter   # or  "for i = iter"
    # body
end
\end{minted}



被转换成




\begin{minted}{julia}
next = iterate(iter)
while next !== nothing
    (i, state) = next
    # body
    next = iterate(iter, state)
end
\end{minted}



\texttt{state} 对象可以是任何对象，并且对于每个可迭代类型应该选择合适的 \texttt{state} 对象。 请参照 \hyperlink{3897660032678469808}{帮助文档接口的迭代小节} 来获取关于定义一个常见迭代类型的更多细节。


\hypertarget{1722534687975587846}{} 
\hyperlink{1722534687975587846}{\texttt{Base.iterate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
iterate(iter [, state]) -> Union{Nothing, Tuple{Any, Any}}
\end{minted}

Advance the iterator to obtain the next element. If no elements remain, \texttt{nothing} should be returned. Otherwise, a 2-tuple of the next element and the new iteration state should be returned.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L823-L829}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9027264262435687173}{} 
\hyperlink{9027264262435687173}{\texttt{Base.IteratorSize}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IteratorSize(itertype::Type) -> IteratorSize
\end{minted}

Given the type of an iterator, return one of the following values:

\begin{itemize}
\item \texttt{SizeUnknown()} if the length (number of elements) cannot be determined in advance.


\item \texttt{HasLength()} if there is a fixed, finite length.


\item \texttt{HasShape\{N\}()} if there is a known length plus a notion of multidimensional shape (as for an array).  In this case \texttt{N} should give the number of dimensions, and the \hyperlink{7074821531920287868}{\texttt{axes}} function is valid  for the iterator.


\item \texttt{IsInfinite()} if the iterator yields values forever.

\end{itemize}
The default value (for iterators that do not define this function) is \texttt{HasLength()}. This means that most iterators are assumed to implement \hyperlink{9362803119463040896}{\texttt{length}}.

This trait is generally used to select between algorithms that pre-allocate space for their result, and algorithms that resize their result incrementally.


\begin{minted}{jlcon}
julia> Base.IteratorSize(1:5)
Base.HasShape{1}()

julia> Base.IteratorSize((2,3))
Base.HasLength()
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/generator.jl#L64-L89}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14296089798779773392}{} 
\hyperlink{14296089798779773392}{\texttt{Base.IteratorEltype}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IteratorEltype(itertype::Type) -> IteratorEltype
\end{minted}

Given the type of an iterator, return one of the following values:

\begin{itemize}
\item \texttt{EltypeUnknown()} if the type of elements yielded by the iterator is not known in advance.


\item \texttt{HasEltype()} if the element type is known, and \hyperlink{6396209842929672718}{\texttt{eltype}} would return a meaningful value.

\end{itemize}
\texttt{HasEltype()} is the default, since iterators are assumed to implement \hyperlink{6396209842929672718}{\texttt{eltype}}.

This trait is generally used to select between algorithms that pre-allocate a specific type of result, and algorithms that pick a result type based on the types of yielded values.


\begin{minted}{jlcon}
julia> Base.IteratorEltype(1:5)
Base.HasEltype()
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/generator.jl#L104-L122}{\texttt{source}}


\end{adjustwidth}

以下类型均完全实现了上述函数：



\begin{itemize}
\item \hyperlink{13239199982495881110}{\texttt{AbstractRange}}


\item \hyperlink{9165955949298153694}{\texttt{UnitRange}}


\item \texttt{Tuple}


\item \texttt{Number}


\item \hyperlink{6514416309183787338}{\texttt{AbstractArray}}


\item \hyperlink{12699422379073174384}{\texttt{BitSet}}


\item \hyperlink{14088500196255451490}{\texttt{IdDict}}


\item \hyperlink{3089397136845322041}{\texttt{Dict}}


\item \hyperlink{17958922440222792850}{\texttt{WeakKeyDict}}


\item \texttt{EachLine}


\item \texttt{AbstractString}


\item \hyperlink{1143189053501747033}{\texttt{Set}}


\item \hyperlink{14946515604348703614}{\texttt{Pair}}


\item \hyperlink{3845731488275720657}{\texttt{NamedTuple}}

\end{itemize}


\hypertarget{7658593471001121217}{}


\section{构造函数和类型}


\hypertarget{13239199982495881110}{} 
\hyperlink{13239199982495881110}{\texttt{Base.AbstractRange}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractRange{T}
\end{minted}

Supertype for ranges with elements of type \texttt{T}. \hyperlink{9165955949298153694}{\texttt{UnitRange}} and other types are subtypes of this.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/range.jl#L134-L139}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17576963097125092768}{} 
\hyperlink{17576963097125092768}{\texttt{Base.OrdinalRange}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
OrdinalRange{T, S} <: AbstractRange{T}
\end{minted}

Supertype for ordinal ranges with elements of type \texttt{T} with spacing(s) of type \texttt{S}. The steps should be always-exact multiples of \hyperlink{2310843180104103470}{\texttt{oneunit}}, and \texttt{T} should be a {\textquotedbl}discrete{\textquotedbl} type, which cannot have values smaller than \texttt{oneunit}. For example, \texttt{Integer} or \texttt{Date} types would qualify, whereas \texttt{Float64} would not (since this type can represent values smaller than \texttt{oneunit(Float64)}. \hyperlink{9165955949298153694}{\texttt{UnitRange}}, \hyperlink{11698840710736817669}{\texttt{StepRange}}, and other types are subtypes of this.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/range.jl#L149-L159}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15649454524028353659}{} 
\hyperlink{15649454524028353659}{\texttt{Base.AbstractUnitRange}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractUnitRange{T} <: OrdinalRange{T, T}
\end{minted}

Supertype for ranges with a step size of \hyperlink{2310843180104103470}{\texttt{oneunit(T)}} with elements of type \texttt{T}. \hyperlink{9165955949298153694}{\texttt{UnitRange}} and other types are subtypes of this.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/range.jl#L162-L167}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11698840710736817669}{} 
\hyperlink{11698840710736817669}{\texttt{Base.StepRange}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
StepRange{T, S} <: OrdinalRange{T, S}
\end{minted}

Ranges with elements of type \texttt{T} with spacing of type \texttt{S}. The step between each element is constant, and the range is defined in terms of a \texttt{start} and \texttt{stop} of type \texttt{T} and a \texttt{step} of type \texttt{S}. Neither \texttt{T} nor \texttt{S} should be floating point types. The syntax \texttt{a:b:c} with \texttt{b > 1} and \texttt{a}, \texttt{b}, and \texttt{c} all integers creates a \texttt{StepRange}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> collect(StepRange(1, Int8(2), 10))
5-element Array{Int64,1}:
 1
 3
 5
 7
 9

julia> typeof(StepRange(1, Int8(2), 10))
StepRange{Int64,Int8}

julia> typeof(1:3:6)
StepRange{Int64,Int64}
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/range.jl#L170-L195}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9165955949298153694}{} 
\hyperlink{9165955949298153694}{\texttt{Base.UnitRange}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UnitRange{T<:Real}
\end{minted}

A range parameterized by a \texttt{start} and \texttt{stop} of type \texttt{T}, filled with elements spaced by \texttt{1} from \texttt{start} until \texttt{stop} is exceeded. The syntax \texttt{a:b} with \texttt{a} and \texttt{b} both \texttt{Integer}s creates a \texttt{UnitRange}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> collect(UnitRange(2.3, 5.2))
3-element Array{Float64,1}:
 2.3
 3.3
 4.3

julia> typeof(1:10)
UnitRange{Int64}
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/range.jl#L255-L273}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5701362841495158413}{} 
\hyperlink{5701362841495158413}{\texttt{Base.LinRange}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LinRange{T}
\end{minted}

A range with \texttt{len} linearly spaced elements between its \texttt{start} and \texttt{stop}. The size of the spacing is controlled by \texttt{len}, which must be an \texttt{Int}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> LinRange(1.5, 5.5, 9)
9-element LinRange{Float64}:
 1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0,5.5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/range.jl#L357-L370}{\texttt{source}}


\end{adjustwidth}

\hypertarget{1951875669203082477}{}


\section{通用集合}


\hypertarget{16079064795802595318}{} 
\hyperlink{16079064795802595318}{\texttt{Base.isempty}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isempty(collection) -> Bool
\end{minted}

Determine whether a collection is empty (has no elements).

\textbf{Examples}


\begin{minted}{jlcon}
julia> isempty([])
true

julia> isempty([1 2 3])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L722-L735}{\texttt{source}}



\begin{lstlisting}
isempty(condition)
\end{lstlisting}

Return \texttt{true} if no tasks are waiting on the condition, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/condition.jl#L141-L145}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11014622222736498057}{} 
\hyperlink{11014622222736498057}{\texttt{Base.empty!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
empty!(collection) -> collection
\end{minted}

Remove all elements from a \texttt{collection}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = Dict("a" => 1, "b" => 2)
Dict{String,Int64} with 2 entries:
  "b" => 2
  "a" => 1

julia> empty!(A);

julia> A
Dict{String,Int64} with 0 entries
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L245-L262}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9362803119463040896}{} 
\hyperlink{9362803119463040896}{\texttt{Base.length}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
length(collection) -> Integer
\end{minted}

Return the number of elements in the collection.

Use \hyperlink{15780929618270241785}{\texttt{lastindex}} to get the last valid index of an indexable collection.

\textbf{Examples}


\begin{minted}{jlcon}
julia> length(1:5)
5

julia> length([1, 2, 3, 4])
4

julia> length([1 2; 3 4])
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L171-L189}{\texttt{source}}


\end{adjustwidth}

以下类型均完全实现了上述函数：



\begin{itemize}
\item \hyperlink{13239199982495881110}{\texttt{AbstractRange}}


\item \hyperlink{9165955949298153694}{\texttt{UnitRange}}


\item \texttt{Tuple}


\item \texttt{Number}


\item \hyperlink{6514416309183787338}{\texttt{AbstractArray}}


\item \hyperlink{12699422379073174384}{\texttt{BitSet}}


\item \hyperlink{14088500196255451490}{\texttt{IdDict}}


\item \hyperlink{3089397136845322041}{\texttt{Dict}}


\item \hyperlink{17958922440222792850}{\texttt{WeakKeyDict}}


\item \texttt{AbstractString}


\item \hyperlink{1143189053501747033}{\texttt{Set}}


\item \hyperlink{3845731488275720657}{\texttt{NamedTuple}}

\end{itemize}


\hypertarget{2860415058234143628}{}


\section{可迭代集合}


\hypertarget{17277603976666670638}{} 
\hyperlink{17277603976666670638}{\texttt{Base.in}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
in(item, collection) -> Bool
∈(item, collection) -> Bool
∋(collection, item) -> Bool
\end{minted}

Determine whether an item is in the given collection, in the sense that it is \hyperlink{15143149452920304570}{\texttt{==}} to one of the values generated by iterating over the collection. Returns a \texttt{Bool} value, except if \texttt{item} is \hyperlink{14596725676261444434}{\texttt{missing}} or \texttt{collection} contains \texttt{missing} but not \texttt{item}, in which case \texttt{missing} is returned (\href{https://en.wikipedia.org/wiki/Three-valued\_logic}{three-valued logic}, matching the behavior of \hyperlink{14612039032155203548}{\texttt{any}} and \hyperlink{15143149452920304570}{\texttt{==}}).

Some collections follow a slightly different definition. For example, \hyperlink{1143189053501747033}{\texttt{Set}}s check whether the item \hyperlink{269533589463185031}{\texttt{isequal}} to one of the elements. \hyperlink{3089397136845322041}{\texttt{Dict}}s look for \texttt{key=>value} pairs, and the key is compared using \hyperlink{269533589463185031}{\texttt{isequal}}. To test for the presence of a key in a dictionary, use \hyperlink{16178429961779994033}{\texttt{haskey}} or \texttt{k in keys(dict)}. For these collections, the result is always a \texttt{Bool} and never \texttt{missing}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = 1:3:20
1:3:19

julia> 4 in a
true

julia> 5 in a
false

julia> missing in [1, 2]
missing

julia> 1 in [2, missing]
missing

julia> 1 in [1, missing]
true

julia> missing in Set([1, 2])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L1057-L1099}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5662586987512487976}{} 
\hyperlink{5662586987512487976}{\texttt{Base.:∉}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
∉(item, collection) -> Bool
∌(collection, item) -> Bool
\end{minted}

Negation of \texttt{∈} and \texttt{∋}, i.e. checks that \texttt{item} is not in \texttt{collection}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 1 ∉ 2:4
true

julia> 1 ∉ 1:3
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L1102-L1116}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6396209842929672718}{} 
\hyperlink{6396209842929672718}{\texttt{Base.eltype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eltype(type)
\end{minted}

Determine the type of the elements generated by iterating a collection of the given \texttt{type}. For dictionary types, this will be a \texttt{Pair\{KeyType,ValType\}}. The definition \texttt{eltype(x) = eltype(typeof(x))} is provided for convenience so that instances can be passed instead of types. However the form that accepts a type argument should be defined for new types.

\textbf{Examples}


\begin{minted}{jlcon}
julia> eltype(fill(1f0, (2,2)))
Float32

julia> eltype(fill(0x1, (2,2)))
UInt8
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L105-L122}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16333903346703258373}{} 
\hyperlink{16333903346703258373}{\texttt{Base.indexin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
indexin(a, b)
\end{minted}

Return an array containing the first index in \texttt{b} for each value in \texttt{a} that is a member of \texttt{b}. The output array contains \texttt{nothing} wherever \texttt{a} is not a member of \texttt{b}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = ['a', 'b', 'c', 'b', 'd', 'a'];

julia> b = ['a', 'b', 'c'];

julia> indexin(a, b)
6-element Array{Union{Nothing, Int64},1}:
 1
 2
 3
 2
  nothing
 1

julia> indexin(b, a)
3-element Array{Union{Nothing, Int64},1}:
 1
 2
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L2220-L2248}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11470702940123921114}{} 
\hyperlink{11470702940123921114}{\texttt{Base.unique}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unique(itr)
\end{minted}

Return an array containing only the unique elements of collection \texttt{itr}, as determined by \hyperlink{269533589463185031}{\texttt{isequal}}, in the order that the first of each set of equivalent elements originally appears. The element type of the input is preserved.

\textbf{Examples}


\begin{minted}{jlcon}
julia> unique([1, 2, 6, 2])
3-element Array{Int64,1}:
 1
 2
 6

julia> unique(Real[1, 1.0, 2])
2-element Array{Real,1}:
 1
 2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/set.jl#L90-L111}{\texttt{source}}



\begin{lstlisting}
unique(f, itr)
\end{lstlisting}

Returns an array containing one value from \texttt{itr} for each unique value produced by \texttt{f} applied to elements of \texttt{itr}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> unique(x -> x^2, [1, -1, 3, -3, 4])
3-element Array{Int64,1}:
 1
 3
 4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/set.jl#L153-L167}{\texttt{source}}



\begin{lstlisting}
unique(A::AbstractArray; dims::Int)
\end{lstlisting}

Return unique regions of \texttt{A} along dimension \texttt{dims}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = map(isodd, reshape(Vector(1:8), (2,2,2)))
2×2×2 Array{Bool,3}:
[:, :, 1] =
 1  1
 0  0

[:, :, 2] =
 1  1
 0  0

julia> unique(A)
2-element Array{Bool,1}:
 1
 0

julia> unique(A, dims=2)
2×1×2 Array{Bool,3}:
[:, :, 1] =
 1
 0

[:, :, 2] =
 1
 0

julia> unique(A, dims=3)
2×2×1 Array{Bool,3}:
[:, :, 1] =
 1  1
 0  0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L1449-L1487}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13070761997161983625}{} 
\hyperlink{13070761997161983625}{\texttt{Base.unique!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unique!(f, A::AbstractVector)
\end{minted}

Selects one value from \texttt{A} for each unique value produced by \texttt{f} applied to elements of \texttt{A} , then return the modified A.

\begin{quote}
\textbf{Julia 1.1}

This method is available as of Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> unique!(x -> x^2, [1, -1, 3, -3, 4])
3-element Array{Int64,1}:
 1
 3
 4

julia> unique!(n -> n%3, [5, 1, 8, 9, 3, 4, 10, 7, 2, 6])
3-element Array{Int64,1}:
 5
 1
 9

julia> unique!(iseven, [2, 3, 5, 7, 9])
2-element Array{Int64,1}:
 2
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/set.jl#L205-L233}{\texttt{source}}



\begin{lstlisting}
unique!(A::AbstractVector)
\end{lstlisting}

Remove duplicate items as determined by \hyperlink{269533589463185031}{\texttt{isequal}}, then return the modified \texttt{A}. \texttt{unique!} will return the elements of \texttt{A} in the order that they occur. If you do not care about the order of the returned data, then calling \texttt{(sort!(A); unique!(A))} will be much more efficient as long as the elements of \texttt{A} can be sorted.

\textbf{Examples}


\begin{minted}{jlcon}
julia> unique!([1, 1, 1])
1-element Array{Int64,1}:
 1

julia> A = [7, 3, 2, 3, 7, 5];

julia> unique!(A)
4-element Array{Int64,1}:
 7
 3
 2
 5

julia> B = [7, 6, 42, 6, 7, 42];

julia> sort!(B);  # unique! is able to process sorted data much more efficiently.

julia> unique!(B)
3-element Array{Int64,1}:
  6
  7
 42
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/set.jl#L293-L326}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7704267519153156361}{} 
\hyperlink{7704267519153156361}{\texttt{Base.allunique}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
allunique(itr) -> Bool
\end{minted}

Return \texttt{true} if all values from \texttt{itr} are distinct when compared with \hyperlink{269533589463185031}{\texttt{isequal}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1; 2; 3]
3-element Array{Int64,1}:
 1
 2
 3

julia> allunique([a, a])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/set.jl#L347-L363}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12844407765882691496}{} 
\hyperlink{12844407765882691496}{\texttt{Base.reduce}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reduce(op, itr; [init])
\end{minted}

Reduce the given collection \texttt{itr} with the given binary operator \texttt{op}. If provided, the initial value \texttt{init} must be a neutral element for \texttt{op} that will be returned for empty collections. It is unspecified whether \texttt{init} is used for non-empty collections.

For empty collections, providing \texttt{init} will be necessary, except for some special cases (e.g. when \texttt{op} is one of \texttt{+}, \texttt{*}, \texttt{max}, \texttt{min}, \texttt{\&}, \texttt{|}) when Julia can determine the neutral element of \texttt{op}.

Reductions for certain commonly-used operators may have special implementations, and should be used instead: \texttt{maximum(itr)}, \texttt{minimum(itr)}, \texttt{sum(itr)}, \texttt{prod(itr)},  \texttt{any(itr)}, \texttt{all(itr)}.

The associativity of the reduction is implementation dependent. This means that you can{\textquotesingle}t use non-associative operations like \texttt{-} because it is undefined whether \texttt{reduce(-,[1,2,3])} should be evaluated as \texttt{(1-2)-3} or \texttt{1-(2-3)}. Use \hyperlink{3612301023460122482}{\texttt{foldl}} or \hyperlink{4241312416601225037}{\texttt{foldr}} instead for guaranteed left or right associativity.

Some operations accumulate error. Parallelism will be easier if the reduction can be executed in groups. Future versions of Julia might change the algorithm. Note that the elements are not reordered if you use an ordered collection.

\textbf{Examples}


\begin{minted}{jlcon}
julia> reduce(*, [2; 3; 4])
24

julia> reduce(*, [2; 3; 4]; init=-1)
-24
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L415-L447}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3612301023460122482}{} 
\hyperlink{3612301023460122482}{\texttt{Base.foldl}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
foldl(op, itr; [init])
\end{minted}

Like \hyperlink{12844407765882691496}{\texttt{reduce}}, but with guaranteed left associativity. If provided, the keyword argument \texttt{init} will be used exactly once. In general, it will be necessary to provide \texttt{init} to work with empty collections.

\textbf{Examples}


\begin{minted}{jlcon}
julia> foldl(=>, 1:4)
((1 => 2) => 3) => 4

julia> foldl(=>, 1:4; init=0)
(((0 => 1) => 2) => 3) => 4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L159-L174}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4241312416601225037}{} 
\hyperlink{4241312416601225037}{\texttt{Base.foldr}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
foldr(op, itr; [init])
\end{minted}

Like \hyperlink{12844407765882691496}{\texttt{reduce}}, but with guaranteed right associativity. If provided, the keyword argument \texttt{init} will be used exactly once. In general, it will be necessary to provide \texttt{init} to work with empty collections.

\textbf{Examples}


\begin{minted}{jlcon}
julia> foldr(=>, 1:4)
1 => (2 => (3 => 4))

julia> foldr(=>, 1:4; init=0)
1 => (2 => (3 => (4 => 0)))
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L203-L218}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14719513931696680717}{} 
\hyperlink{14719513931696680717}{\texttt{Base.maximum}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
maximum(f, itr)
\end{minted}

Returns the largest result of calling function \texttt{f} on each element of \texttt{itr}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> maximum(length, ["Julion", "Julia", "Jule"])
6
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L604-L614}{\texttt{source}}



\begin{lstlisting}
maximum(itr)
\end{lstlisting}

Returns the largest element in a collection.

\textbf{Examples}


\begin{minted}{jlcon}
julia> maximum(-20.5:10)
9.5

julia> maximum([1,2,3])
3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L630-L643}{\texttt{source}}



\begin{lstlisting}
maximum(A::AbstractArray; dims)
\end{lstlisting}

Compute the maximum value of an array over the given dimensions. See also the \hyperlink{7839419811914289844}{\texttt{max(a,b)}} function to take the maximum of two or more arguments, which can be applied elementwise to arrays via \texttt{max.(a,b)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> maximum(A, dims=1)
1×2 Array{Int64,2}:
 3  4

julia> maximum(A, dims=2)
2×1 Array{Int64,2}:
 2
 4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L451-L474}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8410756622363562035}{} 
\hyperlink{8410756622363562035}{\texttt{Base.maximum!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
maximum!(r, A)
\end{minted}

Compute the maximum value of \texttt{A} over the singleton dimensions of \texttt{r}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> maximum!([1; 1], A)
2-element Array{Int64,1}:
 2
 4

julia> maximum!([1 1], A)
1×2 Array{Int64,2}:
 3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L477-L498}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13126064576294034099}{} 
\hyperlink{13126064576294034099}{\texttt{Base.minimum}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
minimum(f, itr)
\end{minted}

Returns the smallest result of calling function \texttt{f} on each element of \texttt{itr}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> minimum(length, ["Julion", "Julia", "Jule"])
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L617-L627}{\texttt{source}}



\begin{lstlisting}
minimum(itr)
\end{lstlisting}

Returns the smallest element in a collection.

\textbf{Examples}


\begin{minted}{jlcon}
julia> minimum(-20.5:10)
-20.5

julia> minimum([1,2,3])
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L646-L659}{\texttt{source}}



\begin{lstlisting}
minimum(A::AbstractArray; dims)
\end{lstlisting}

Compute the minimum value of an array over the given dimensions. See also the \hyperlink{7458766354532817148}{\texttt{min(a,b)}} function to take the minimum of two or more arguments, which can be applied elementwise to arrays via \texttt{min.(a,b)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> minimum(A, dims=1)
1×2 Array{Int64,2}:
 1  2

julia> minimum(A, dims=2)
2×1 Array{Int64,2}:
 1
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L501-L524}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15755225581375550665}{} 
\hyperlink{15755225581375550665}{\texttt{Base.minimum!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
minimum!(r, A)
\end{minted}

Compute the minimum value of \texttt{A} over the singleton dimensions of \texttt{r}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> minimum!([1; 1], A)
2-element Array{Int64,1}:
 1
 3

julia> minimum!([1 1], A)
1×2 Array{Int64,2}:
 1  2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L527-L548}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5171681020038097298}{} 
\hyperlink{5171681020038097298}{\texttt{Base.extrema}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
extrema(itr) -> Tuple
\end{minted}

Compute both the minimum and maximum element in a single pass, and return them as a 2-tuple.

\textbf{Examples}


\begin{minted}{jlcon}
julia> extrema(2:10)
(2, 10)

julia> extrema([9,pi,4.5])
(3.141592653589793, 9.0)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L437-L450}{\texttt{source}}



\begin{lstlisting}
extrema(f, itr) -> Tuple
\end{lstlisting}

Compute both the minimum and maximum of \texttt{f} applied to each element in \texttt{itr} and return them as a 2-tuple. Only one pass is made over \texttt{itr}.

\begin{quote}
\textbf{Julia 1.2}

This method requires Julia 1.2 or later.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> extrema(sin, 0:π)
(0.0, 0.9092974268256817)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L453-L467}{\texttt{source}}



\begin{lstlisting}
extrema(A::AbstractArray; dims) -> Array{Tuple}
\end{lstlisting}

Compute the minimum and maximum elements of an array over the given dimensions.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = reshape(Vector(1:2:16), (2,2,2))
2×2×2 Array{Int64,3}:
[:, :, 1] =
 1  5
 3  7

[:, :, 2] =
  9  13
 11  15

julia> extrema(A, dims = (1,2))
1×1×2 Array{Tuple{Int64,Int64},3}:
[:, :, 1] =
 (1, 7)

[:, :, 2] =
 (9, 15)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L1562-L1587}{\texttt{source}}



\begin{lstlisting}
extrema(f, A::AbstractArray; dims) -> Array{Tuple}
\end{lstlisting}

Compute the minimum and maximum of \texttt{f} applied to each element in the given dimensions of \texttt{A}.

\begin{quote}
\textbf{Julia 1.2}

This method requires Julia 1.2 or later.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L1590-L1598}{\texttt{source}}


\end{adjustwidth}
\hypertarget{956545262187649384}{} 
\hyperlink{956545262187649384}{\texttt{Base.argmax}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
argmax(itr) -> Integer
\end{minted}

Return the index of the maximum element in a collection. If there are multiple maximal elements, then the first one will be returned.

The collection must not be empty.

\textbf{Examples}


\begin{minted}{jlcon}
julia> argmax([8,0.1,-9,pi])
1

julia> argmax([1,7,7,6])
2

julia> argmax([1,7,7,NaN])
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L2175-L2194}{\texttt{source}}



\begin{lstlisting}
argmax(A; dims) -> indices
\end{lstlisting}

For an array input, return the indices of the maximum elements over the given dimensions. \texttt{NaN} is treated as greater than all other values.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1.0 2; 3 4]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia> argmax(A, dims=1)
1×2 Array{CartesianIndex{2},2}:
 CartesianIndex(2, 1)  CartesianIndex(2, 2)

julia> argmax(A, dims=2)
2×1 Array{CartesianIndex{2},2}:
 CartesianIndex(1, 2)
 CartesianIndex(2, 2)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L859-L881}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3019098764376574337}{} 
\hyperlink{3019098764376574337}{\texttt{Base.argmin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
argmin(itr) -> Integer
\end{minted}

Return the index of the minimum element in a collection. If there are multiple minimal elements, then the first one will be returned.

The collection must not be empty.

\textbf{Examples}


\begin{minted}{jlcon}
julia> argmin([8,0.1,-9,pi])
3

julia> argmin([7,1,1,6])
2

julia> argmin([7,1,1,NaN])
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L2197-L2216}{\texttt{source}}



\begin{lstlisting}
argmin(A; dims) -> indices
\end{lstlisting}

For an array input, return the indices of the minimum elements over the given dimensions. \texttt{NaN} is treated as less than all other values.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1.0 2; 3 4]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia> argmin(A, dims=1)
1×2 Array{CartesianIndex{2},2}:
 CartesianIndex(1, 1)  CartesianIndex(1, 2)

julia> argmin(A, dims=2)
2×1 Array{CartesianIndex{2},2}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L834-L856}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6489526403180080657}{} 
\hyperlink{6489526403180080657}{\texttt{Base.findmax}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findmax(itr) -> (x, index)
\end{minted}

Return the maximum element of the collection \texttt{itr} and its index. If there are multiple maximal elements, then the first one will be returned. If any data element is \texttt{NaN}, this element is returned. The result is in line with \texttt{max}.

The collection must not be empty.

\textbf{Examples}


\begin{minted}{jlcon}
julia> findmax([8,0.1,-9,pi])
(8.0, 1)

julia> findmax([1,7,7,6])
(7, 2)

julia> findmax([1,7,7,NaN])
(NaN, 4)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L2085-L2106}{\texttt{source}}



\begin{lstlisting}
findmax(A; dims) -> (maxval, index)
\end{lstlisting}

For an array input, returns the value and index of the maximum over the given dimensions. \texttt{NaN} is treated as greater than all other values.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1.0 2; 3 4]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia> findmax(A, dims=1)
([3.0 4.0], CartesianIndex{2}[CartesianIndex(2, 1) CartesianIndex(2, 2)])

julia> findmax(A, dims=2)
([2.0; 4.0], CartesianIndex{2}[CartesianIndex(1, 2); CartesianIndex(2, 2)])
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L797-L816}{\texttt{source}}


\end{adjustwidth}
\hypertarget{676075112677273449}{} 
\hyperlink{676075112677273449}{\texttt{Base.findmin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findmin(itr) -> (x, index)
\end{minted}

Return the minimum element of the collection \texttt{itr} and its index. If there are multiple minimal elements, then the first one will be returned. If any data element is \texttt{NaN}, this element is returned. The result is in line with \texttt{min}.

The collection must not be empty.

\textbf{Examples}


\begin{minted}{jlcon}
julia> findmin([8,0.1,-9,pi])
(-9.0, 3)

julia> findmin([7,1,1,6])
(1, 2)

julia> findmin([7,1,1,NaN])
(NaN, 4)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L2130-L2151}{\texttt{source}}



\begin{lstlisting}
findmin(A; dims) -> (minval, index)
\end{lstlisting}

For an array input, returns the value and index of the minimum over the given dimensions. \texttt{NaN} is treated as less than all other values.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1.0 2; 3 4]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia> findmin(A, dims=1)
([1.0 2.0], CartesianIndex{2}[CartesianIndex(1, 1) CartesianIndex(1, 2)])

julia> findmin(A, dims=2)
([1.0; 3.0], CartesianIndex{2}[CartesianIndex(1, 1); CartesianIndex(2, 1)])
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L748-L767}{\texttt{source}}


\end{adjustwidth}
\hypertarget{585571988055972211}{} 
\hyperlink{585571988055972211}{\texttt{Base.findmax!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findmax!(rval, rind, A) -> (maxval, index)
\end{minted}

Find the maximum of \texttt{A} and the corresponding linear index along singleton dimensions of \texttt{rval} and \texttt{rind}, and store the results in \texttt{rval} and \texttt{rind}. \texttt{NaN} is treated as greater than all other values.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L785-L791}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6616116230203866531}{} 
\hyperlink{6616116230203866531}{\texttt{Base.findmin!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findmin!(rval, rind, A) -> (minval, index)
\end{minted}

Find the minimum of \texttt{A} and the corresponding linear index along singleton dimensions of \texttt{rval} and \texttt{rind}, and store the results in \texttt{rval} and \texttt{rind}. \texttt{NaN} is treated as less than all other values.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L736-L742}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8666686648688281595}{} 
\hyperlink{8666686648688281595}{\texttt{Base.sum}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sum(f, itr)
\end{minted}

Sum the results of calling function \texttt{f} on each element of \texttt{itr}.

The return type is \texttt{Int} for signed integers of less than system word size, and \texttt{UInt} for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sum(abs2, [2; 3; 4])
29
\end{minted}

Note the important difference between \texttt{sum(A)} and \texttt{reduce(+, A)} for arrays with small integer eltype:


\begin{minted}{jlcon}
julia> sum(Int8[100, 28])
128

julia> reduce(+, Int8[100, 28])
-128
\end{minted}

In the former case, the integers are widened to system word size and therefore the result is 128. In the latter case, no such widening happens and integer overflow results in -128.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L456-L485}{\texttt{source}}



\begin{lstlisting}
sum(itr)
\end{lstlisting}

Returns the sum of all elements in a collection.

The return type is \texttt{Int} for signed integers of less than system word size, and \texttt{UInt} for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sum(1:20)
210
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L488-L502}{\texttt{source}}



\begin{lstlisting}
sum(A::AbstractArray; dims)
\end{lstlisting}

Sum elements of an array over the given dimensions.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> sum(A, dims=1)
1×2 Array{Int64,2}:
 4  6

julia> sum(A, dims=2)
2×1 Array{Int64,2}:
 3
 7
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L355-L376}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6277092149981507138}{} 
\hyperlink{6277092149981507138}{\texttt{Base.sum!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sum!(r, A)
\end{minted}

Sum elements of \texttt{A} over the singleton dimensions of \texttt{r}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> sum!([1; 1], A)
2-element Array{Int64,1}:
 3
 7

julia> sum!([1 1], A)
1×2 Array{Int64,2}:
 4  6
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L379-L400}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13484084847910116333}{} 
\hyperlink{13484084847910116333}{\texttt{Base.prod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
prod(f, itr)
\end{minted}

Returns the product of \texttt{f} applied to each element of \texttt{itr}.

The return type is \texttt{Int} for signed integers of less than system word size, and \texttt{UInt} for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.

\textbf{Examples}


\begin{minted}{jlcon}
julia> prod(abs2, [2; 3; 4])
576
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L507-L521}{\texttt{source}}



\begin{lstlisting}
prod(itr)
\end{lstlisting}

Returns the product of all elements of a collection.

The return type is \texttt{Int} for signed integers of less than system word size, and \texttt{UInt} for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.

\textbf{Examples}


\begin{minted}{jlcon}
julia> prod(1:20)
2432902008176640000
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L524-L538}{\texttt{source}}



\begin{lstlisting}
prod(A::AbstractArray; dims)
\end{lstlisting}

Multiply elements of an array over the given dimensions.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> prod(A, dims=1)
1×2 Array{Int64,2}:
 3  8

julia> prod(A, dims=2)
2×1 Array{Int64,2}:
  2
 12
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L403-L424}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15969471860599880580}{} 
\hyperlink{15969471860599880580}{\texttt{Base.prod!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
prod!(r, A)
\end{minted}

Multiply elements of \texttt{A} over the singleton dimensions of \texttt{r}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> prod!([1; 1], A)
2-element Array{Int64,1}:
  2
 12

julia> prod!([1 1], A)
1×2 Array{Int64,2}:
 3  8
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L427-L448}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14612039032155203548}{} 
\hyperlink{14612039032155203548}{\texttt{Base.any}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
any(itr) -> Bool
\end{minted}

Test whether any elements of a boolean collection are \texttt{true}, returning \texttt{true} as soon as the first \texttt{true} value in \texttt{itr} is encountered (short-circuiting).

If the input contains \hyperlink{14596725676261444434}{\texttt{missing}} values, return \texttt{missing} if all non-missing values are \texttt{false} (or equivalently, if the input contains no \texttt{true} value), following \href{https://en.wikipedia.org/wiki/Three-valued\_logic}{three-valued logic}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [true,false,false,true]
4-element Array{Bool,1}:
 1
 0
 0
 1

julia> any(a)
true

julia> any((println(i); v) for (i, v) in enumerate(a))
1
true

julia> any([missing, true])
true

julia> any([false, missing])
missing
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L664-L696}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13269987351988461926}{} 
\hyperlink{13269987351988461926}{\texttt{Base.any}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
any(p, itr) -> Bool
\end{minted}

Determine whether predicate \texttt{p} returns \texttt{true} for any elements of \texttt{itr}, returning \texttt{true} as soon as the first item in \texttt{itr} for which \texttt{p} returns \texttt{true} is encountered (short-circuiting).

If the input contains \hyperlink{14596725676261444434}{\texttt{missing}} values, return \texttt{missing} if all non-missing values are \texttt{false} (or equivalently, if the input contains no \texttt{true} value), following \href{https://en.wikipedia.org/wiki/Three-valued\_logic}{three-valued logic}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> any(i->(4<=i<=6), [3,5,7])
true

julia> any(i -> (println(i); i > 3), 1:10)
1
2
3
4
true

julia> any(i -> i > 0, [1, missing])
true

julia> any(i -> i > 0, [-1, missing])
missing

julia> any(i -> i > 0, [-1, 0])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L735-L767}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8281403281900865383}{} 
\hyperlink{8281403281900865383}{\texttt{Base.any!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
any!(r, A)
\end{minted}

Test whether any values in \texttt{A} along the singleton dimensions of \texttt{r} are \texttt{true}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [true false; true false]
2×2 Array{Bool,2}:
 1  0
 1  0

julia> any!([1; 1], A)
2-element Array{Int64,1}:
 1
 1

julia> any!([1 1], A)
1×2 Array{Int64,2}:
 1  0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L623-L645}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7942004983516218646}{} 
\hyperlink{7942004983516218646}{\texttt{Base.all}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
all(itr) -> Bool
\end{minted}

Test whether all elements of a boolean collection are \texttt{true}, returning \texttt{false} as soon as the first \texttt{false} value in \texttt{itr} is encountered (short-circuiting).

If the input contains \hyperlink{14596725676261444434}{\texttt{missing}} values, return \texttt{missing} if all non-missing values are \texttt{true} (or equivalently, if the input contains no \texttt{false} value), following \href{https://en.wikipedia.org/wiki/Three-valued\_logic}{three-valued logic}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [true,false,false,true]
4-element Array{Bool,1}:
 1
 0
 0
 1

julia> all(a)
false

julia> all((println(i); v) for (i, v) in enumerate(a))
1
2
false

julia> all([missing, false])
false

julia> all([true, missing])
missing
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L699-L732}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2312198897330859084}{} 
\hyperlink{2312198897330859084}{\texttt{Base.all}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
all(p, itr) -> Bool
\end{minted}

Determine whether predicate \texttt{p} returns \texttt{true} for all elements of \texttt{itr}, returning \texttt{false} as soon as the first item in \texttt{itr} for which \texttt{p} returns \texttt{false} is encountered (short-circuiting).

If the input contains \hyperlink{14596725676261444434}{\texttt{missing}} values, return \texttt{missing} if all non-missing values are \texttt{true} (or equivalently, if the input contains no \texttt{false} value), following \href{https://en.wikipedia.org/wiki/Three-valued\_logic}{three-valued logic}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> all(i->(4<=i<=6), [4,5,6])
true

julia> all(i -> (println(i); i < 3), 1:10)
1
2
3
false

julia> all(i -> i > 0, [1, missing])
missing

julia> all(i -> i > 0, [-1, missing])
false

julia> all(i -> i > 0, [1, 2])
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L783-L814}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1382810654686121973}{} 
\hyperlink{1382810654686121973}{\texttt{Base.all!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
all!(r, A)
\end{minted}

Test whether all values in \texttt{A} along the singleton dimensions of \texttt{r} are \texttt{true}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [true false; true false]
2×2 Array{Bool,2}:
 1  0
 1  0

julia> all!([1; 1], A)
2-element Array{Int64,1}:
 0
 0

julia> all!([1 1], A)
1×2 Array{Int64,2}:
 1  0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L575-L596}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4123799324867706690}{} 
\hyperlink{4123799324867706690}{\texttt{Base.count}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
count(p, itr) -> Integer
count(itr) -> Integer
\end{minted}

Count the number of elements in \texttt{itr} for which predicate \texttt{p} returns \texttt{true}. If \texttt{p} is omitted, counts the number of \texttt{true} elements in \texttt{itr} (which should be a collection of boolean values).

\textbf{Examples}


\begin{minted}{jlcon}
julia> count(i->(4<=i<=6), [2,3,4,5,6])
3

julia> count([true, false, true, true])
3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L835-L851}{\texttt{source}}



\begin{lstlisting}
count(
    pattern::Union{AbstractString,Regex},
    string::AbstractString;
    overlap::Bool = false,
)
\end{lstlisting}

Return the number of matches for \texttt{pattern} in \texttt{string}. This is equivalent to calling \texttt{length(findall(pattern, string))} but more efficient.

If \texttt{overlap=true}, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from disjoint character ranges.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/regex.jl#L358-L370}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5656508174326485968}{} 
\hyperlink{5656508174326485968}{\texttt{Base.any}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
any(p, itr) -> Bool
\end{minted}

Determine whether predicate \texttt{p} returns \texttt{true} for any elements of \texttt{itr}, returning \texttt{true} as soon as the first item in \texttt{itr} for which \texttt{p} returns \texttt{true} is encountered (short-circuiting).

If the input contains \hyperlink{14596725676261444434}{\texttt{missing}} values, return \texttt{missing} if all non-missing values are \texttt{false} (or equivalently, if the input contains no \texttt{true} value), following \href{https://en.wikipedia.org/wiki/Three-valued\_logic}{three-valued logic}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> any(i->(4<=i<=6), [3,5,7])
true

julia> any(i -> (println(i); i > 3), 1:10)
1
2
3
4
true

julia> any(i -> i > 0, [1, missing])
true

julia> any(i -> i > 0, [-1, missing])
missing

julia> any(i -> i > 0, [-1, 0])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L735-L767}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8835516150928560592}{} 
\hyperlink{8835516150928560592}{\texttt{Base.all}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
all(p, itr) -> Bool
\end{minted}

Determine whether predicate \texttt{p} returns \texttt{true} for all elements of \texttt{itr}, returning \texttt{false} as soon as the first item in \texttt{itr} for which \texttt{p} returns \texttt{false} is encountered (short-circuiting).

If the input contains \hyperlink{14596725676261444434}{\texttt{missing}} values, return \texttt{missing} if all non-missing values are \texttt{true} (or equivalently, if the input contains no \texttt{false} value), following \href{https://en.wikipedia.org/wiki/Three-valued\_logic}{three-valued logic}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> all(i->(4<=i<=6), [4,5,6])
true

julia> all(i -> (println(i); i < 3), 1:10)
1
2
3
false

julia> all(i -> i > 0, [1, missing])
missing

julia> all(i -> i > 0, [-1, missing])
false

julia> all(i -> i > 0, [1, 2])
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L783-L814}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8999415072542722396}{} 
\hyperlink{8999415072542722396}{\texttt{Base.foreach}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
foreach(f, c...) -> Nothing
\end{minted}

Call function \texttt{f} on each element of iterable \texttt{c}. For multiple iterable arguments, \texttt{f} is called elementwise. \texttt{foreach} should be used instead of \texttt{map} when the results of \texttt{f} are not needed, for example in \texttt{foreach(println, array)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = 1:3:7;

julia> foreach(x -> println(x^2), a)
1
16
49
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L1900-L1917}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11483231213869150535}{} 
\hyperlink{11483231213869150535}{\texttt{Base.map}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
map(f, c...) -> collection
\end{minted}

Transform collection \texttt{c} by applying \texttt{f} to each element. For multiple collection arguments, apply \texttt{f} elementwise.

See also: \hyperlink{8678396932318499078}{\texttt{mapslices}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> map(x -> x * 2, [1, 2, 3])
3-element Array{Int64,1}:
 2
 4
 6

julia> map(+, [1, 2, 3], [10, 20, 30])
3-element Array{Int64,1}:
 11
 22
 33
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L2075-L2097}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11037843636480523134}{} 
\hyperlink{11037843636480523134}{\texttt{Base.map!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
map!(function, destination, collection...)
\end{minted}

Like \hyperlink{11483231213869150535}{\texttt{map}}, but stores the result in \texttt{destination} rather than a new collection. \texttt{destination} must be at least as large as the first collection.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = zeros(3);

julia> map!(x -> x * 2, a, [1, 2, 3]);

julia> a
3-element Array{Float64,1}:
 2.0
 4.0
 6.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L2132-L2150}{\texttt{source}}



\begin{lstlisting}
map!(f, values(dict::AbstractDict))
\end{lstlisting}

Modifies \texttt{dict} by transforming each value from \texttt{val} to \texttt{f(val)}. Note that the type of \texttt{dict} cannot be changed: if \texttt{f(val)} is not an instance of the value type of \texttt{dict} then it will be converted to the value type if possible and otherwise raise an error.

\begin{quote}
\textbf{Julia 1.2}

\texttt{map!(f, values(dict::AbstractDict))} requires Julia 1.2 or later.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> d = Dict(:a => 1, :b => 2)
Dict{Symbol,Int64} with 2 entries:
  :a => 1
  :b => 2

julia> map!(v -> v-1, values(d))
Base.ValueIterator for a Dict{Symbol,Int64} with 2 entries. Values:
  0
  1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L709-L731}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10927609949347955937}{} 
\hyperlink{10927609949347955937}{\texttt{Base.mapreduce}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mapreduce(f, op, itrs...; [init])
\end{minted}

Apply function \texttt{f} to each element(s) in \texttt{itrs}, and then reduce the result using the binary function \texttt{op}. If provided, \texttt{init} must be a neutral element for \texttt{op} that will be returned for empty collections. It is unspecified whether \texttt{init} is used for non-empty collections. In general, it will be necessary to provide \texttt{init} to work with empty collections.

\hyperlink{10927609949347955937}{\texttt{mapreduce}} is functionally equivalent to calling \texttt{reduce(op, map(f, itr); init=init)}, but will in general execute faster since no intermediate collection needs to be created. See documentation for \hyperlink{12844407765882691496}{\texttt{reduce}} and \hyperlink{11483231213869150535}{\texttt{map}}.

\begin{quote}
\textbf{Julia 1.2}

\texttt{mapreduce} with multiple iterators requires Julia 1.2 or later.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> mapreduce(x->x^2, +, [1:3;]) # == 1 + 4 + 9
14
\end{minted}

The associativity of the reduction is implementation-dependent. Additionally, some implementations may reuse the return value of \texttt{f} for elements that appear multiple times in \texttt{itr}. Use \hyperlink{14886875186313200647}{\texttt{mapfoldl}} or \hyperlink{14828426243224858846}{\texttt{mapfoldr}} instead for guaranteed left or right associativity and invocation of \texttt{f} for every value.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L256-L282}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14886875186313200647}{} 
\hyperlink{14886875186313200647}{\texttt{Base.mapfoldl}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mapfoldl(f, op, itr; [init])
\end{minted}

Like \hyperlink{10927609949347955937}{\texttt{mapreduce}}, but with guaranteed left associativity, as in \hyperlink{3612301023460122482}{\texttt{foldl}}. If provided, the keyword argument \texttt{init} will be used exactly once. In general, it will be necessary to provide \texttt{init} to work with empty collections.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L150-L156}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14828426243224858846}{} 
\hyperlink{14828426243224858846}{\texttt{Base.mapfoldr}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mapfoldr(f, op, itr; [init])
\end{minted}

Like \hyperlink{10927609949347955937}{\texttt{mapreduce}}, but with guaranteed right associativity, as in \hyperlink{4241312416601225037}{\texttt{foldr}}. If provided, the keyword argument \texttt{init} will be used exactly once. In general, it will be necessary to provide \texttt{init} to work with empty collections.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L193-L199}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10301663699427216331}{} 
\hyperlink{10301663699427216331}{\texttt{Base.first}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
first(coll)
\end{minted}

Get the first element of an iterable collection. Return the start point of an \hyperlink{13239199982495881110}{\texttt{AbstractRange}} even if it is empty.

\textbf{Examples}


\begin{minted}{jlcon}
julia> first(2:2:10)
2

julia> first([1; 2; 3; 4])
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L325-L339}{\texttt{source}}



\begin{minted}{julia}
first(s::AbstractString, n::Integer)
\end{minted}

Get a string consisting of the first \texttt{n} characters of \texttt{s}.


\begin{minted}{jlcon}
julia> first("∀ϵ≠0: ϵ²>0", 0)
""

julia> first("∀ϵ≠0: ϵ²>0", 1)
"∀"

julia> first("∀ϵ≠0: ϵ²>0", 3)
"∀ϵ≠"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L596-L611}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7482613677577278193}{} 
\hyperlink{7482613677577278193}{\texttt{Base.last}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
last(coll)
\end{minted}

Get the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling \hyperlink{15780929618270241785}{\texttt{lastindex}} to get the last index. Return the end point of an \hyperlink{13239199982495881110}{\texttt{AbstractRange}} even if it is empty.

\textbf{Examples}


\begin{minted}{jlcon}
julia> last(1:2:10)
9

julia> last([1; 2; 3; 4])
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L346-L361}{\texttt{source}}



\begin{minted}{julia}
last(s::AbstractString, n::Integer)
\end{minted}

Get a string consisting of the last \texttt{n} characters of \texttt{s}.


\begin{minted}{jlcon}
julia> last("∀ϵ≠0: ϵ²>0", 0)
""

julia> last("∀ϵ≠0: ϵ²>0", 1)
"0"

julia> last("∀ϵ≠0: ϵ²>0", 3)
"²>0"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L614-L629}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12661956456222222367}{} 
\hyperlink{12661956456222222367}{\texttt{Base.front}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
front(x::Tuple)::Tuple
\end{minted}

Return a \texttt{Tuple} consisting of all but the last component of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Base.front((1,2,3))
(1, 2)

julia> Base.front(())
ERROR: ArgumentError: Cannot call front on an empty tuple.
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/tuple.jl#L128-L141}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4601841136652136570}{} 
\hyperlink{4601841136652136570}{\texttt{Base.tail}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tail(x::Tuple)::Tuple
\end{minted}

Return a \texttt{Tuple} consisting of all but the first component of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Base.tail((1,2,3))
(2, 3)

julia> Base.tail(())
ERROR: ArgumentError: Cannot call tail on an empty tuple.
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L191-L204}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6276843274198881822}{} 
\hyperlink{6276843274198881822}{\texttt{Base.step}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
step(r)
\end{minted}

Get the step size of an \hyperlink{13239199982495881110}{\texttt{AbstractRange}} object.

\textbf{Examples}


\begin{minted}{jlcon}
julia> step(1:10)
1

julia> step(1:2:10)
2

julia> step(2.5:0.3:10.9)
0.3

julia> step(range(2.5, stop=10.9, length=85))
0.1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/range.jl#L481-L500}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6278865767444641812}{} 
\hyperlink{6278865767444641812}{\texttt{Base.collect}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
collect(collection)
\end{minted}

Return an \texttt{Array} of all items in a collection or iterator. For dictionaries, returns \texttt{Pair\{KeyType, ValType\}}. If the argument is array-like or is an iterator with the \hyperlink{9027264262435687173}{\texttt{HasShape}} trait, the result will have the same shape and number of dimensions as the argument.

\textbf{Examples}


\begin{minted}{jlcon}
julia> collect(1:2:13)
7-element Array{Int64,1}:
  1
  3
  5
  7
  9
 11
 13
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L582-L602}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3539644528130741625}{} 
\hyperlink{3539644528130741625}{\texttt{Base.collect}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
collect(element_type, collection)
\end{minted}

Return an \texttt{Array} with the given element type of all items in a collection or iterable. The result has the same shape and number of dimensions as \texttt{collection}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> collect(Float64, 1:2:5)
3-element Array{Float64,1}:
 1.0
 3.0
 5.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L547-L561}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11445961893478569145}{} 
\hyperlink{11445961893478569145}{\texttt{Base.filter}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
filter(f, a::AbstractArray)
\end{minted}

Return a copy of \texttt{a}, removing elements for which \texttt{f} is \texttt{false}. The function \texttt{f} is passed one argument.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = 1:10
1:10

julia> filter(isodd, a)
5-element Array{Int64,1}:
 1
 3
 5
 7
 9
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L2350-L2369}{\texttt{source}}



\begin{lstlisting}
filter(f, d::AbstractDict)
\end{lstlisting}

Return a copy of \texttt{d}, removing elements for which \texttt{f} is \texttt{false}. The function \texttt{f} is passed \texttt{key=>value} pairs.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d = Dict(1=>"a", 2=>"b")
Dict{Int64,String} with 2 entries:
  2 => "b"
  1 => "a"

julia> filter(p->isodd(p.first), d)
Dict{Int64,String} with 1 entry:
  1 => "a"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L371-L388}{\texttt{source}}



\begin{lstlisting}
filter(f, itr::SkipMissing{<:AbstractArray})
\end{lstlisting}

Return a vector similar to the array wrapped by the given \texttt{SkipMissing} iterator but with all missing elements and those for which \texttt{f} returns \texttt{false} removed.

\begin{quote}
\textbf{Julia 1.2}

This method requires Julia 1.2 or later.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> x = [1 2; missing 4]
2×2 Array{Union{Missing, Int64},2}:
 1         2
  missing  4

julia> filter(isodd, skipmissing(x))
1-element Array{Int64,1}:
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/missing.jl#L353-L373}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3384092630307389071}{} 
\hyperlink{3384092630307389071}{\texttt{Base.filter!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
filter!(f, a::AbstractVector)
\end{minted}

Update \texttt{a}, removing elements for which \texttt{f} is \texttt{false}. The function \texttt{f} is passed one argument.

\textbf{Examples}


\begin{minted}{jlcon}
julia> filter!(isodd, Vector(1:10))
5-element Array{Int64,1}:
 1
 3
 5
 7
 9
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L2399-L2415}{\texttt{source}}



\begin{lstlisting}
filter!(f, d::AbstractDict)
\end{lstlisting}

Update \texttt{d}, removing elements for which \texttt{f} is \texttt{false}. The function \texttt{f} is passed \texttt{key=>value} pairs.

\textbf{Example}


\begin{minted}{jlcon}
julia> d = Dict(1=>"a", 2=>"b", 3=>"c")
Dict{Int64,String} with 3 entries:
  2 => "b"
  3 => "c"
  1 => "a"

julia> filter!(p->isodd(p.first), d)
Dict{Int64,String} with 2 entries:
  3 => "c"
  1 => "a"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L329-L348}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17608641146794059481}{} 
\hyperlink{17608641146794059481}{\texttt{Base.replace}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
replace(A, old_new::Pair...; [count::Integer])
\end{minted}

Return a copy of collection \texttt{A} where, for each pair \texttt{old=>new} in \texttt{old\_new}, all occurrences of \texttt{old} are replaced by \texttt{new}. Equality is determined using \hyperlink{269533589463185031}{\texttt{isequal}}. If \texttt{count} is specified, then replace at most \texttt{count} occurrences in total.

The element type of the result is chosen using promotion (see \hyperlink{15048881762587391286}{\texttt{promote\_type}}) based on the element type of \texttt{A} and on the types of the \texttt{new} values in pairs. If \texttt{count} is omitted and the element type of \texttt{A} is a \texttt{Union}, the element type of the result will not include singleton types which are replaced with values of a different type: for example, \texttt{Union\{T,Missing\}} will become \texttt{T} if \texttt{missing} is replaced.

See also \hyperlink{5131476008802508952}{\texttt{replace!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> replace([1, 2, 1, 3], 1=>0, 2=>4, count=2)
4-element Array{Int64,1}:
 0
 4
 1
 3

julia> replace([1, missing], missing=>0)
2-element Array{Int64,1}:
 1
 0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/set.jl#L493-L524}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18363712244886975978}{} 
\hyperlink{18363712244886975978}{\texttt{Base.replace}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
replace(new::Function, A; [count::Integer])
\end{minted}

Return a copy of \texttt{A} where each value \texttt{x} in \texttt{A} is replaced by \texttt{new(x)} If \texttt{count} is specified, then replace at most \texttt{count} values in total (replacements being defined as \texttt{new(x) !== x}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> replace(x -> isodd(x) ? 2x : x, [1, 2, 3, 4])
4-element Array{Int64,1}:
 2
 2
 6
 4

julia> replace(Dict(1=>2, 3=>4)) do kv
           first(kv) < 3 ? first(kv)=>3 : kv
       end
Dict{Int64,Int64} with 2 entries:
  3 => 4
  1 => 3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/set.jl#L551-L574}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5131476008802508952}{} 
\hyperlink{5131476008802508952}{\texttt{Base.replace!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
replace!(A, old_new::Pair...; [count::Integer])
\end{minted}

For each pair \texttt{old=>new} in \texttt{old\_new}, replace all occurrences of \texttt{old} in collection \texttt{A} by \texttt{new}. Equality is determined using \hyperlink{269533589463185031}{\texttt{isequal}}. If \texttt{count} is specified, then replace at most \texttt{count} occurrences in total. See also \hyperlink{17608641146794059481}{\texttt{replace}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> replace!([1, 2, 1, 3], 1=>0, 2=>4, count=2)
4-element Array{Int64,1}:
 0
 4
 1
 3

julia> replace!(Set([1, 2, 3]), 1=>0)
Set{Int64} with 3 elements:
  0
  2
  3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/set.jl#L423-L447}{\texttt{source}}



\begin{lstlisting}
replace!(new::Function, A; [count::Integer])
\end{lstlisting}

Replace each element \texttt{x} in collection \texttt{A} by \texttt{new(x)}. If \texttt{count} is specified, then replace at most \texttt{count} values in total (replacements being defined as \texttt{new(x) !== x}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> replace!(x -> isodd(x) ? 2x : x, [1, 2, 3, 4])
4-element Array{Int64,1}:
 2
 2
 6
 4

julia> replace!(Dict(1=>2, 3=>4)) do kv
           first(kv) < 3 ? first(kv)=>3 : kv
       end
Dict{Int64,Int64} with 2 entries:
  3 => 4
  1 => 3

julia> replace!(x->2x, Set([3, 6]))
Set{Int64} with 2 elements:
  6
  12
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/set.jl#L461-L489}{\texttt{source}}


\end{adjustwidth}

\hypertarget{9076050997374125173}{}


\section{可索引集合}


\hypertarget{13720608614876840481}{} 
\hyperlink{13720608614876840481}{\texttt{Base.getindex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getindex(collection, key...)
\end{minted}

Retrieve the value(s) stored at the given key or index within a collection. The syntax \texttt{a[i,j,...]} is converted by the compiler to \texttt{getindex(a, i, j, ...)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = Dict("a" => 1, "b" => 2)
Dict{String,Int64} with 2 entries:
  "b" => 2
  "a" => 1

julia> getindex(A, "a")
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L768-L784}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1309244355901386657}{} 
\hyperlink{1309244355901386657}{\texttt{Base.setindex!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
setindex!(collection, value, key...)
\end{minted}

Store the given value at the given key or index within a collection. The syntax \texttt{a[i,j,...] = x} is converted by the compiler to \texttt{(setindex!(a, x, i, j, ...); x)}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L818-L823}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16943669671291374223}{} 
\hyperlink{16943669671291374223}{\texttt{Base.firstindex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
firstindex(collection) -> Integer
firstindex(collection, d) -> Integer
\end{minted}

Return the first index of \texttt{collection}. If \texttt{d} is given, return the first index of \texttt{collection} along dimension \texttt{d}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> firstindex([1,2,4])
1

julia> firstindex(rand(3,4,5), 2)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L305-L319}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15780929618270241785}{} 
\hyperlink{15780929618270241785}{\texttt{Base.lastindex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lastindex(collection) -> Integer
lastindex(collection, d) -> Integer
\end{minted}

Return the last index of \texttt{collection}. If \texttt{d} is given, return the last index of \texttt{collection} along dimension \texttt{d}.

The syntaxes \texttt{A[end]} and \texttt{A[end, end]} lower to \texttt{A[lastindex(A)]} and \texttt{A[lastindex(A, 1), lastindex(A, 2)]}, respectively.

\textbf{Examples}


\begin{minted}{jlcon}
julia> lastindex([1,2,4])
3

julia> lastindex(rand(3,4,5), 2)
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L284-L301}{\texttt{source}}


\end{adjustwidth}

以下类型均完全实现了上述函数：



\begin{itemize}
\item \hyperlink{15492651498431872487}{\texttt{Array}}


\item \hyperlink{18015155802543401629}{\texttt{BitArray}}


\item \hyperlink{6514416309183787338}{\texttt{AbstractArray}}


\item \texttt{SubArray}

\end{itemize}


以下类型仅实现了部分上述函数：



\begin{itemize}
\item \hyperlink{13239199982495881110}{\texttt{AbstractRange}}


\item \hyperlink{9165955949298153694}{\texttt{UnitRange}}


\item \texttt{Tuple}


\item \texttt{AbstractString}


\item \hyperlink{3089397136845322041}{\texttt{Dict}}


\item \hyperlink{14088500196255451490}{\texttt{IdDict}}


\item \hyperlink{17958922440222792850}{\texttt{WeakKeyDict}}


\item \hyperlink{3845731488275720657}{\texttt{NamedTuple}}

\end{itemize}


\hypertarget{8604172220127987938}{}


\section{字典}



\hyperlink{3089397136845322041}{\texttt{Dict}} 是一个标准字典。其实现利用了 \hyperlink{13797072367283572032}{\texttt{hash}} 作为键的哈希函数和 \hyperlink{269533589463185031}{\texttt{isequal}} 来决定是否相等。对于自定义类型，可以定义这两个函数来重载它们在哈希表内的存储方式。



\hyperlink{14088500196255451490}{\texttt{IdDict}} 是一种特殊的哈希表，在里面键始终是对象标识符。



\hyperlink{17958922440222792850}{\texttt{WeakKeyDict}} 是一个哈希表的实现，里面键是对象的弱引用， 所以即使键在哈希表中被引用也有可能被垃圾回收。 它像 \texttt{Dict} 一样使用 \texttt{hash} 来做哈希和 \texttt{isequal} 来做相等判断， 但是它不会在插入时转换键，这点不像 \texttt{Dict}。



\hyperlink{3089397136845322041}{\texttt{Dict}}s 可以由传递含有 \texttt{=>} 的成对对象给 \hyperlink{3089397136845322041}{\texttt{Dict}} 的构造函数来被创建：\texttt{Dict({\textquotedbl}A{\textquotedbl}=>1, {\textquotedbl}B{\textquotedbl}=>2)}。 这个调用会尝试从键值对中推到类型信息（比如这个例子创造了一个 \texttt{Dict\{String, Int64\}}）。 为了显式指定类型，请使用语法 \texttt{Dict\{KeyType,ValueType\}(...)}。例如：\texttt{Dict\{String,Int32\}({\textquotedbl}A{\textquotedbl}=>1, {\textquotedbl}B{\textquotedbl}=>2)}。



字典也可以用生成器创建。例如：\texttt{Dict(i => f(i) for i = 1:10)}。



对于字典 \texttt{D}，若键 \texttt{x} 的值存在，则语法 \texttt{D[x]} 返回 \texttt{x} 的值；否则抛出一个错误。 \texttt{D[x] = y} 存储键值对 \texttt{x => y} 到 \texttt{D} 中，会覆盖键 \texttt{x} 的已有的值。 多个参数传入\texttt{D[...]} 会被转化成元组； 例如：语法 \texttt{D[x,y]} 等于 \texttt{D[(x,y)]}，也就是说，它指向键为元组 \texttt{(x,y)} 的值。


\hypertarget{6373987858401217649}{} 
\hyperlink{6373987858401217649}{\texttt{Base.AbstractDict}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractDict{K, V}
\end{minted}

Supertype for dictionary-like types with keys of type \texttt{K} and values of type \texttt{V}. \hyperlink{3089397136845322041}{\texttt{Dict}}, \hyperlink{14088500196255451490}{\texttt{IdDict}} and other types are subtypes of this. An \texttt{AbstractDict\{K, V\}} should be an iterator of \texttt{Pair\{K, V\}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L17-L23}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3089397136845322041}{} 
\hyperlink{3089397136845322041}{\texttt{Base.Dict}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Dict([itr])
\end{minted}

\texttt{Dict\{K,V\}()} constructs a hash table with keys of type \texttt{K} and values of type \texttt{V}. Keys are compared with \hyperlink{269533589463185031}{\texttt{isequal}} and hashed with \hyperlink{13797072367283572032}{\texttt{hash}}.

Given a single iterable argument, constructs a \hyperlink{3089397136845322041}{\texttt{Dict}} whose key-value pairs are taken from 2-tuples \texttt{(key,value)} generated by the argument.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dict([("A", 1), ("B", 2)])
Dict{String,Int64} with 2 entries:
  "B" => 2
  "A" => 1
\end{minted}

Alternatively, a sequence of pair arguments may be passed.


\begin{minted}{jlcon}
julia> Dict("A"=>1, "B"=>2)
Dict{String,Int64} with 2 entries:
  "B" => 2
  "A" => 1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L52-L77}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14088500196255451490}{} 
\hyperlink{14088500196255451490}{\texttt{Base.IdDict}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IdDict([itr])
\end{minted}

\texttt{IdDict\{K,V\}()} constructs a hash table using object-id as hash and \texttt{===} as equality with keys of type \texttt{K} and values of type \texttt{V}.

See \hyperlink{3089397136845322041}{\texttt{Dict}} for further help.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L499-L506}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17958922440222792850}{} 
\hyperlink{17958922440222792850}{\texttt{Base.WeakKeyDict}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
WeakKeyDict([itr])
\end{minted}

\texttt{WeakKeyDict()} constructs a hash table where the keys are weak references to objects which may be garbage collected even when referenced in a hash table.

See \hyperlink{3089397136845322041}{\texttt{Dict}} for further help.  Note, unlike \hyperlink{3089397136845322041}{\texttt{Dict}}, \texttt{WeakKeyDict} does not convert keys on insertion.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/weakkeydict.jl#L5-L14}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2867962635551946253}{} 
\hyperlink{2867962635551946253}{\texttt{Base.ImmutableDict}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ImmutableDict
\end{minted}

ImmutableDict is a Dictionary implemented as an immutable linked list, which is optimal for small dictionaries that are constructed over many individual insertions Note that it is not possible to remove a value, although it can be partially overridden and hidden by inserting a new value with the same key


\begin{lstlisting}
ImmutableDict(KV::Pair)
\end{lstlisting}

Create a new entry in the Immutable Dictionary for the key => value pair

\begin{itemize}
\item use \texttt{(key => value) in dict} to see if this particular combination is in the properties set


\item use \texttt{get(dict, key, default)} to retrieve the most recent value for a particular key

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L733-L748}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16178429961779994033}{} 
\hyperlink{16178429961779994033}{\texttt{Base.haskey}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
haskey(collection, key) -> Bool
\end{minted}

Determine whether a collection has a mapping for a given \texttt{key}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> D = Dict('a'=>2, 'b'=>3)
Dict{Char,Int64} with 2 entries:
  'a' => 2
  'b' => 3

julia> haskey(D, 'a')
true

julia> haskey(D, 'c')
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L526-L544}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1600067245044904172}{} 
\hyperlink{1600067245044904172}{\texttt{Base.get}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
get(collection, key, default)
\end{minted}

Return the value stored for the given key, or the given default value if no mapping for the key is present.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d = Dict("a"=>1, "b"=>2);

julia> get(d, "a", 3)
1

julia> get(d, "c", 3)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L480-L496}{\texttt{source}}


\end{adjustwidth}
\hypertarget{282460992333585641}{} 
\hyperlink{282460992333585641}{\texttt{Base.get}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
get(collection, key, default)
\end{minted}

Return the value stored for the given key, or the given default value if no mapping for the key is present.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d = Dict("a"=>1, "b"=>2);

julia> get(d, "a", 3)
1

julia> get(d, "c", 3)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L480-L496}{\texttt{source}}



\begin{lstlisting}
get(f::Function, collection, key)
\end{lstlisting}

Return the value stored for the given key, or if no mapping for the key is present, return \texttt{f()}.  Use \hyperlink{1533836558345014565}{\texttt{get!}} to also store the default value in the dictionary.

This is intended to be called using \texttt{do} block syntax


\begin{minted}{julia}
get(dict, key) do
    # default value calculated here
    time()
end
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L504-L518}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1533836558345014565}{} 
\hyperlink{1533836558345014565}{\texttt{Base.get!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
get!(collection, key, default)
\end{minted}

Return the value stored for the given key, or if no mapping for the key is present, store \texttt{key => default}, and return \texttt{default}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d = Dict("a"=>1, "b"=>2, "c"=>3);

julia> get!(d, "a", 5)
1

julia> get!(d, "d", 4)
4

julia> d
Dict{String,Int64} with 4 entries:
  "c" => 3
  "b" => 2
  "a" => 1
  "d" => 4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L394-L417}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8556034432039635706}{} 
\hyperlink{8556034432039635706}{\texttt{Base.get!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
get!(f::Function, collection, key)
\end{minted}

Return the value stored for the given key, or if no mapping for the key is present, store \texttt{key => f()}, and return \texttt{f()}.

This is intended to be called using \texttt{do} block syntax:


\begin{minted}{julia}
get!(dict, key) do
    # default value calculated here
    time()
end
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L422-L435}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7350451602884809264}{} 
\hyperlink{7350451602884809264}{\texttt{Base.getkey}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getkey(collection, key, default)
\end{minted}

Return the key matching argument \texttt{key} if one exists in \texttt{collection}, otherwise return \texttt{default}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> D = Dict('a'=>2, 'b'=>3)
Dict{Char,Int64} with 2 entries:
  'a' => 2
  'b' => 3

julia> getkey(D, 'a', 1)
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)

julia> getkey(D, 'd', 'a')
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L548-L566}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2012894417553832980}{} 
\hyperlink{2012894417553832980}{\texttt{Base.delete!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
delete!(collection, key)
\end{minted}

Delete the mapping for the given key in a collection, if any, and return the collection.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d = Dict("a"=>1, "b"=>2)
Dict{String,Int64} with 2 entries:
  "b" => 2
  "a" => 1

julia> delete!(d, "b")
Dict{String,Int64} with 1 entry:
  "a" => 1

julia> delete!(d, "b") # d is left unchanged
Dict{String,Int64} with 1 entry:
  "a" => 1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L631-L651}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8214834680518266248}{} 
\hyperlink{8214834680518266248}{\texttt{Base.pop!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pop!(collection, key[, default])
\end{minted}

Delete and return the mapping for \texttt{key} if it exists in \texttt{collection}, otherwise return \texttt{default}, or throw an error if \texttt{default} is not specified.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d = Dict("a"=>1, "b"=>2, "c"=>3);

julia> pop!(d, "a")
1

julia> pop!(d, "d")
ERROR: KeyError: key "d" not found
Stacktrace:
[...]

julia> pop!(d, "e", 4)
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L583-L604}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6023948435845840069}{} 
\hyperlink{6023948435845840069}{\texttt{Base.keys}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
keys(iterator)
\end{minted}

For an iterator or collection that has keys and values (e.g. arrays and dictionaries), return an iterator over the keys.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L67-L72}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14429101350359443046}{} 
\hyperlink{14429101350359443046}{\texttt{Base.values}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
values(iterator)
\end{minted}

For an iterator or collection that has keys and values, return an iterator over the values. This function simply returns its argument by default, since the elements of a general iterator are normally considered its {\textquotedbl}values{\textquotedbl}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d = Dict("a"=>1, "b"=>2);

julia> values(d)
Base.ValueIterator for a Dict{String,Int64} with 2 entries. Values:
  2
  1

julia> values([2])
1-element Array{Int64,1}:
 2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L742-L763}{\texttt{source}}



\begin{lstlisting}
values(a::AbstractDict)
\end{lstlisting}

Return an iterator over all values in a collection. \texttt{collect(values(a))} returns an array of values. When the values are stored internally in a hash table, as is the case for \texttt{Dict}, the order in which they are returned may vary. But \texttt{keys(a)} and \texttt{values(a)} both iterate \texttt{a} and return the elements in the same order.

\textbf{Examples}


\begin{minted}{jlcon}
julia> D = Dict('a'=>2, 'b'=>3)
Dict{Char,Int64} with 2 entries:
  'a' => 2
  'b' => 3

julia> collect(values(D))
2-element Array{Int64,1}:
 2
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L101-L124}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15543779110977484852}{} 
\hyperlink{15543779110977484852}{\texttt{Base.pairs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pairs(collection)
\end{minted}

Return an iterator over \texttt{key => value} pairs for any collection that maps a set of keys to a set of values. This includes arrays, where the keys are the array indices.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L127-L133}{\texttt{source}}



\begin{lstlisting}
pairs(IndexLinear(), A)
pairs(IndexCartesian(), A)
pairs(IndexStyle(A), A)
\end{lstlisting}

An iterator that accesses each element of the array \texttt{A}, returning \texttt{i => x}, where \texttt{i} is the index for the element and \texttt{x = A[i]}. Identical to \texttt{pairs(A)}, except that the style of index can be selected. Also similar to \texttt{enumerate(A)}, except \texttt{i} will be a valid index for \texttt{A}, while \texttt{enumerate} always counts from 1 regardless of the indices of \texttt{A}.

Specifying \hyperlink{1761039776681330940}{\texttt{IndexLinear()}} ensures that \texttt{i} will be an integer; specifying \hyperlink{4052302263500310575}{\texttt{IndexCartesian()}} ensures that \texttt{i} will be a \hyperlink{4571802376991525093}{\texttt{CartesianIndex}}; specifying \texttt{IndexStyle(A)} chooses whichever has been defined as the native indexing style for array \texttt{A}.

Mutation of the bounds of the underlying array will invalidate this iterator.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = ["a" "d"; "b" "e"; "c" "f"];

julia> for (index, value) in pairs(IndexStyle(A), A)
           println("$index $value")
       end
1 a
2 b
3 c
4 d
5 e
6 f

julia> S = view(A, 1:2, :);

julia> for (index, value) in pairs(IndexStyle(S), S)
           println("$index $value")
       end
CartesianIndex(1, 1) a
CartesianIndex(2, 1) b
CartesianIndex(1, 2) d
CartesianIndex(2, 2) e
\end{minted}

See also: \hyperlink{7782790551324367092}{\texttt{IndexStyle}}, \hyperlink{7074821531920287868}{\texttt{axes}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L172-L217}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2980395915971142404}{} 
\hyperlink{2980395915971142404}{\texttt{Base.merge}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
merge(d::AbstractDict, others::AbstractDict...)
\end{minted}

Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. If the same key is present in another collection, the value for that key will be the value it has in the last collection listed.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = Dict("foo" => 0.0, "bar" => 42.0)
Dict{String,Float64} with 2 entries:
  "bar" => 42.0
  "foo" => 0.0

julia> b = Dict("baz" => 17, "bar" => 4711)
Dict{String,Int64} with 2 entries:
  "bar" => 4711
  "baz" => 17

julia> merge(a, b)
Dict{String,Float64} with 3 entries:
  "bar" => 4711.0
  "baz" => 17.0
  "foo" => 0.0

julia> merge(b, a)
Dict{String,Float64} with 3 entries:
  "bar" => 42.0
  "baz" => 17.0
  "foo" => 0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L253-L285}{\texttt{source}}



\begin{lstlisting}
merge(combine, d::AbstractDict, others::AbstractDict...)
\end{lstlisting}

Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. Values with the same key will be combined using the combiner function.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = Dict("foo" => 0.0, "bar" => 42.0)
Dict{String,Float64} with 2 entries:
  "bar" => 42.0
  "foo" => 0.0

julia> b = Dict("baz" => 17, "bar" => 4711)
Dict{String,Int64} with 2 entries:
  "bar" => 4711
  "baz" => 17

julia> merge(+, a, b)
Dict{String,Float64} with 3 entries:
  "bar" => 4753.0
  "baz" => 17.0
  "foo" => 0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L289-L315}{\texttt{source}}



\begin{lstlisting}
merge(a::NamedTuple, bs::NamedTuple...)
\end{lstlisting}

Construct a new named tuple by merging two or more existing ones, in a left-associative manner. Merging proceeds left-to-right, between pairs of named tuples, and so the order of fields present in both the leftmost and rightmost named tuples take the same position as they are found in the leftmost named tuple. However, values are taken from matching fields in the rightmost named tuple that contains that field. Fields present in only the rightmost named tuple of a pair are appended at the end. A fallback is implemented for when only a single named tuple is supplied, with signature \texttt{merge(a::NamedTuple)}.

\begin{quote}
\textbf{Julia 1.1}

Merging 3 or more \texttt{NamedTuple} requires at least Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> merge((a=1, b=2, c=3), (b=4, d=5))
(a = 1, b = 4, c = 3, d = 5)
\end{minted}


\begin{minted}{jlcon}
julia> merge((a=1, b=2), (b=3, c=(d=1,)), (c=(d=2,),))
(a = 1, b = 3, c = (d = 2,))
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/namedtuple.jl#L195-L219}{\texttt{source}}



\begin{lstlisting}
merge(a::NamedTuple, iterable)
\end{lstlisting}

Interpret an iterable of key-value pairs as a named tuple, and perform a merge.


\begin{minted}{jlcon}
julia> merge((a=1, b=2, c=3), [:b=>4, :d=>5])
(a = 1, b = 4, c = 3, d = 5)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/namedtuple.jl#L241-L250}{\texttt{source}}


\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Base.mergewith}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{6445163593036205863}{} 
\hyperlink{6445163593036205863}{\texttt{Base.merge!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
merge!(d::AbstractDict, others::AbstractDict...)
\end{minted}

Update collection with pairs from the other collections. See also \hyperlink{2980395915971142404}{\texttt{merge}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d1 = Dict(1 => 2, 3 => 4);

julia> d2 = Dict(1 => 4, 4 => 5);

julia> merge!(d1, d2);

julia> d1
Dict{Int64,Int64} with 3 entries:
  4 => 5
  3 => 4
  1 => 4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L156-L176}{\texttt{source}}



\begin{lstlisting}
merge!(combine, d::AbstractDict, others::AbstractDict...)
\end{lstlisting}

Update collection with pairs from the other collections. Values with the same key will be combined using the combiner function.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d1 = Dict(1 => 2, 3 => 4);

julia> d2 = Dict(1 => 4, 4 => 5);

julia> merge!(+, d1, d2);

julia> d1
Dict{Int64,Int64} with 3 entries:
  4 => 5
  3 => 4
  1 => 6

julia> merge!(-, d1, d1);

julia> d1
Dict{Int64,Int64} with 3 entries:
  4 => 0
  3 => 0
  1 => 0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L186-L215}{\texttt{source}}


\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Base.mergewith!}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{15797102328828238137}{} 
\hyperlink{15797102328828238137}{\texttt{Base.sizehint!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sizehint!(s, n)
\end{minted}

Suggest that collection \texttt{s} reserve capacity for at least \texttt{n} elements. This can improve performance.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1074-L1078}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7157735428816224008}{} 
\hyperlink{7157735428816224008}{\texttt{Base.keytype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
keytype(T::Type{<:AbstractArray})
keytype(A::AbstractArray)
\end{minted}

Return the key type of an array. This is equal to the \texttt{eltype} of the result of \texttt{keys(...)}, and is provided mainly for compatibility with the dictionary interface.

\textbf{Examples}


\begin{minted}{jlcon}
julia> keytype([1, 2, 3]) == Int
true

julia> keytype([1 2; 3 4])
CartesianIndex{2}
\end{minted}

\begin{quote}
\textbf{Julia 1.2}

For arrays, this function requires at least Julia 1.2.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L104-L123}{\texttt{source}}



\begin{lstlisting}
keytype(type)
\end{lstlisting}

Get the key type of an dictionary type. Behaves similarly to \hyperlink{6396209842929672718}{\texttt{eltype}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> keytype(Dict(Int32(1) => "foo"))
Int32
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L225-L235}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1758642341593311431}{} 
\hyperlink{1758642341593311431}{\texttt{Base.valtype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
valtype(T::Type{<:AbstractArray})
valtype(A::AbstractArray)
\end{minted}

Return the value type of an array. This is identical to \texttt{eltype} and is provided mainly for compatibility with the dictionary interface.

\textbf{Examples}


\begin{minted}{jlcon}
julia> valtype(["one", "two", "three"])
String
\end{minted}

\begin{quote}
\textbf{Julia 1.2}

For arrays, this function requires at least Julia 1.2.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L131-L146}{\texttt{source}}



\begin{lstlisting}
valtype(type)
\end{lstlisting}

Get the value type of an dictionary type. Behaves similarly to \hyperlink{6396209842929672718}{\texttt{eltype}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> valtype(Dict(Int32(1) => "foo"))
String
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L239-L249}{\texttt{source}}


\end{adjustwidth}

以下类型均完全实现了上述函数：



\begin{itemize}
\item \hyperlink{14088500196255451490}{\texttt{IdDict}}


\item \hyperlink{3089397136845322041}{\texttt{Dict}}


\item \hyperlink{17958922440222792850}{\texttt{WeakKeyDict}}

\end{itemize}


以下类型仅实现了部分上述函数：



\begin{itemize}
\item \hyperlink{12699422379073174384}{\texttt{BitSet}}


\item \hyperlink{1143189053501747033}{\texttt{Set}}


\item \hyperlink{13502577110353968166}{\texttt{EnvDict}}


\item \hyperlink{15492651498431872487}{\texttt{Array}}


\item \hyperlink{18015155802543401629}{\texttt{BitArray}}


\item \hyperlink{2867962635551946253}{\texttt{ImmutableDict}}


\item \hyperlink{1741207879021199162}{\texttt{Iterators.Pairs}}

\end{itemize}


\hypertarget{12709358817338877858}{}


\section{类似 Set 的集合}


\hypertarget{10183330636847972356}{} 
\hyperlink{10183330636847972356}{\texttt{Base.AbstractSet}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractSet{T}
\end{minted}

Supertype for set-like types whose elements are of type \texttt{T}. \hyperlink{1143189053501747033}{\texttt{Set}}, \hyperlink{12699422379073174384}{\texttt{BitSet}} and other types are subtypes of this.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L9-L14}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1143189053501747033}{} 
\hyperlink{1143189053501747033}{\texttt{Base.Set}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Set([itr])
\end{minted}

Construct a \hyperlink{1143189053501747033}{\texttt{Set}} of the values generated by the given iterable object, or an empty set. Should be used instead of \hyperlink{12699422379073174384}{\texttt{BitSet}} for sparse integer sets, or for sets of arbitrary objects.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/set.jl#L14-L20}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12699422379073174384}{} 
\hyperlink{12699422379073174384}{\texttt{Base.BitSet}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
BitSet([itr])
\end{minted}

Construct a sorted set of \texttt{Int}s generated by the given iterable object, or an empty set. Implemented as a bit string, and therefore designed for dense integer sets. If the set will be sparse (for example, holding a few very large integers), use \hyperlink{1143189053501747033}{\texttt{Set}} instead.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/bitset.jl#L21-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6278797112644055704}{} 
\hyperlink{6278797112644055704}{\texttt{Base.union}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
union(s, itrs...)
∪(s, itrs...)
\end{minted}

Construct the union of sets. Maintain order with arrays.

\textbf{Examples}


\begin{minted}{jlcon}
julia> union([1, 2], [3, 4])
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> union([1, 2], [2, 4])
3-element Array{Int64,1}:
 1
 2
 4

julia> union([4, 2], 1:2)
3-element Array{Int64,1}:
 4
 2
 1

julia> union(Set([1, 2]), 2:3)
Set{Int64} with 3 elements:
  2
  3
  1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractset.jl#L10-L43}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12706236051336451682}{} 
\hyperlink{12706236051336451682}{\texttt{Base.union!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
union!(s::Union{AbstractSet,AbstractVector}, itrs...)
\end{minted}

Construct the union of passed in sets and overwrite \texttt{s} with the result. Maintain order with arrays.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = Set([1, 3, 4, 5]);

julia> union!(a, 1:2:8);

julia> a
Set{Int64} with 5 elements:
  7
  4
  3
  5
  1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractset.jl#L53-L73}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17029201757338520959}{} 
\hyperlink{17029201757338520959}{\texttt{Base.intersect}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
intersect(s, itrs...)
∩(s, itrs...)
\end{minted}

Construct the intersection of sets. Maintain order with arrays.

\textbf{Examples}


\begin{minted}{jlcon}
julia> intersect([1, 2, 3], [3, 4, 5])
1-element Array{Int64,1}:
 3

julia> intersect([1, 4, 4, 5, 6], [4, 6, 6, 7, 8])
2-element Array{Int64,1}:
 4
 6

julia> intersect(Set([1, 2]), BitSet([2, 3]))
Set{Int64} with 1 element:
  2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractset.jl#L97-L119}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11050652365145191041}{} 
\hyperlink{11050652365145191041}{\texttt{Base.setdiff}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
setdiff(s, itrs...)
\end{minted}

Construct the set of elements in \texttt{s} but not in any of the iterables in \texttt{itrs}. Maintain order with arrays.

\textbf{Examples}


\begin{minted}{jlcon}
julia> setdiff([1,2,3], [3,4,5])
2-element Array{Int64,1}:
 1
 2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractset.jl#L142-L155}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12326722559100879167}{} 
\hyperlink{12326722559100879167}{\texttt{Base.setdiff!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
setdiff!(s, itrs...)
\end{minted}

Remove from set \texttt{s} (in-place) each element of each iterable from \texttt{itrs}. Maintain order with arrays.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = Set([1, 3, 4, 5]);

julia> setdiff!(a, 1:2:6);

julia> a
Set{Int64} with 1 element:
  4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractset.jl#L159-L175}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4317834782250216015}{} 
\hyperlink{4317834782250216015}{\texttt{Base.symdiff}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
symdiff(s, itrs...)
\end{minted}

Construct the symmetric difference of elements in the passed in sets. When \texttt{s} is not an \texttt{AbstractSet}, the order is maintained. Note that in this case the multiplicity of elements matters.

\textbf{Examples}


\begin{minted}{jlcon}
julia> symdiff([1,2,3], [3,4,5], [4,5,6])
3-element Array{Int64,1}:
 1
 2
 6

julia> symdiff([1,2,1], [2, 1, 2])
2-element Array{Int64,1}:
 1
 2

julia> symdiff(unique([1,2,1]), unique([2, 1, 2]))
0-element Array{Int64,1}
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractset.jl#L190-L213}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13446903852078819564}{} 
\hyperlink{13446903852078819564}{\texttt{Base.symdiff!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
symdiff!(s::Union{AbstractSet,AbstractVector}, itrs...)
\end{minted}

Construct the symmetric difference of the passed in sets, and overwrite \texttt{s} with the result. When \texttt{s} is an array, the order is maintained. Note that in this case the multiplicity of elements matters.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractset.jl#L217-L223}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18401946028185283153}{} 
\hyperlink{18401946028185283153}{\texttt{Base.intersect!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
intersect!(s::Union{AbstractSet,AbstractVector}, itrs...)
\end{minted}

Intersect all passed in sets and overwrite \texttt{s} with the result. Maintain order with arrays.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractset.jl#L126-L131}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18158680907243266011}{} 
\hyperlink{18158680907243266011}{\texttt{Base.issubset}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issubset(a, b) -> Bool
⊆(a, b) -> Bool
⊇(b, a) -> Bool
\end{minted}

Determine whether every element of \texttt{a} is also in \texttt{b}, using \hyperlink{17277603976666670638}{\texttt{in}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> issubset([1, 2], [1, 2, 3])
true

julia> [1, 2, 3] ⊆ [1, 2]
false

julia> [1, 2, 3] ⊇ [1, 2]
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractset.jl#L242-L260}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1999401891136155185}{} 
\hyperlink{1999401891136155185}{\texttt{Base.:⊈}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
⊈(a, b) -> Bool
⊉(b, a) -> Bool
\end{minted}

Negation of \texttt{⊆} and \texttt{⊇}, i.e. checks that \texttt{a} is not a subset of \texttt{b}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> (1, 2) ⊈ (2, 3)
true

julia> (1, 2) ⊈ (1, 2, 3)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractset.jl#L324-L338}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8215860421663834339}{} 
\hyperlink{8215860421663834339}{\texttt{Base.:⊊}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
⊊(a, b) -> Bool
⊋(b, a) -> Bool
\end{minted}

Determines if \texttt{a} is a subset of, but not equal to, \texttt{b}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> (1, 2) ⊊ (1, 2, 3)
true

julia> (1, 2) ⊊ (1, 2)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractset.jl#L301-L315}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10250979601085180143}{} 
\hyperlink{10250979601085180143}{\texttt{Base.issetequal}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issetequal(a, b) -> Bool
\end{minted}

Determine whether \texttt{a} and \texttt{b} have the same elements. Equivalent to \texttt{a ⊆ b \&\& b ⊆ a} but more efficient when possible.

\textbf{Examples}


\begin{minted}{jlcon}
julia> issetequal([1, 2], [1, 2, 3])
false

julia> issetequal([1, 2], [2, 1])
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractset.jl#L346-L360}{\texttt{source}}


\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Base.isdisjoint}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}


以下类型均完全实现了上述函数：



\begin{itemize}
\item \hyperlink{12699422379073174384}{\texttt{BitSet}}


\item \hyperlink{1143189053501747033}{\texttt{Set}}

\end{itemize}


以下类型仅实现了部分上述函数：



\begin{itemize}
\item \hyperlink{15492651498431872487}{\texttt{Array}}

\end{itemize}


\hypertarget{9142077600230868636}{}


\section{双端队列}


\hypertarget{18026893834387542681}{} 
\hyperlink{18026893834387542681}{\texttt{Base.push!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
push!(collection, items...) -> collection
\end{minted}

Insert one or more \texttt{items} in \texttt{collection}. If \texttt{collection} is an ordered container, the items are inserted at the end (in the given order).

\textbf{Examples}


\begin{minted}{jlcon}
julia> push!([1, 2, 3], 4, 5, 6)
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6
\end{minted}

If \texttt{collection} is ordered, use \hyperlink{2587432243763606566}{\texttt{append!}} to add all the elements of another collection to it. The result of the preceding example is equivalent to \texttt{append!([1, 2, 3], [4, 5, 6])}. For \texttt{AbstractSet} objects, \hyperlink{12706236051336451682}{\texttt{union!}} can be used instead.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L887-L908}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14467641005327674015}{} 
\hyperlink{14467641005327674015}{\texttt{Base.pop!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pop!(collection) -> item
\end{minted}

Remove an item in \texttt{collection} and return it. If \texttt{collection} is an ordered container, the last item is returned.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A=[1, 2, 3]
3-element Array{Int64,1}:
 1
 2
 3

julia> pop!(A)
3

julia> A
2-element Array{Int64,1}:
 1
 2

julia> S = Set([1, 2])
Set{Int64} with 2 elements:
  2
  1

julia> pop!(S)
2

julia> S
Set{Int64} with 1 element:
  1

julia> pop!(Dict(1=>2))
1 => 2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1086-L1123}{\texttt{source}}



\begin{minted}{julia}
pop!(collection, key[, default])
\end{minted}

Delete and return the mapping for \texttt{key} if it exists in \texttt{collection}, otherwise return \texttt{default}, or throw an error if \texttt{default} is not specified.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d = Dict("a"=>1, "b"=>2, "c"=>3);

julia> pop!(d, "a")
1

julia> pop!(d, "d")
ERROR: KeyError: key "d" not found
Stacktrace:
[...]

julia> pop!(d, "e", 4)
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L583-L604}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13975349246934359471}{} 
\hyperlink{13975349246934359471}{\texttt{Base.pushfirst!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pushfirst!(collection, items...) -> collection
\end{minted}

Insert one or more \texttt{items} at the beginning of \texttt{collection}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> pushfirst!([1, 2, 3, 4], 5, 6)
6-element Array{Int64,1}:
 5
 6
 1
 2
 3
 4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1133-L1149}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6030955907577332369}{} 
\hyperlink{6030955907577332369}{\texttt{Base.popfirst!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
popfirst!(collection) -> item
\end{minted}

Remove the first \texttt{item} from \texttt{collection}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1, 2, 3, 4, 5, 6]
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6

julia> popfirst!(A)
1

julia> A
5-element Array{Int64,1}:
 2
 3
 4
 5
 6
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1157-L1184}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2077968578228414845}{} 
\hyperlink{2077968578228414845}{\texttt{Base.insert!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
insert!(a::Vector, index::Integer, item)
\end{minted}

Insert an \texttt{item} into \texttt{a} at the given \texttt{index}. \texttt{index} is the index of \texttt{item} in the resulting \texttt{a}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> insert!([6, 5, 4, 2, 1], 4, 3)
6-element Array{Int64,1}:
 6
 5
 4
 3
 2
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1194-L1211}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16790471737745785097}{} 
\hyperlink{16790471737745785097}{\texttt{Base.deleteat!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
deleteat!(a::Vector, i::Integer)
\end{minted}

Remove the item at the given \texttt{i} and return the modified \texttt{a}. Subsequent items are shifted to fill the resulting gap.

\textbf{Examples}


\begin{minted}{jlcon}
julia> deleteat!([6, 5, 4, 3, 2, 1], 2)
5-element Array{Int64,1}:
 6
 4
 3
 2
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1221-L1237}{\texttt{source}}



\begin{lstlisting}
deleteat!(a::Vector, inds)
\end{lstlisting}

Remove the items at the indices given by \texttt{inds}, and return the modified \texttt{a}. Subsequent items are shifted to fill the resulting gap.

\texttt{inds} can be either an iterator or a collection of sorted and unique integer indices, or a boolean vector of the same length as \texttt{a} with \texttt{true} indicating entries to delete.

\textbf{Examples}


\begin{minted}{jlcon}
julia> deleteat!([6, 5, 4, 3, 2, 1], 1:2:5)
3-element Array{Int64,1}:
 5
 3
 1

julia> deleteat!([6, 5, 4, 3, 2, 1], [true, false, true, false, true, false])
3-element Array{Int64,1}:
 5
 3
 1

julia> deleteat!([6, 5, 4, 3, 2, 1], (2, 2))
ERROR: ArgumentError: indices must be unique and sorted
Stacktrace:
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1246-L1274}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13785507599688955371}{} 
\hyperlink{13785507599688955371}{\texttt{Base.splice!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
splice!(a::Vector, index::Integer, [replacement]) -> item
\end{minted}

Remove the item at the given index, and return the removed item. Subsequent items are shifted left to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed item.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [6, 5, 4, 3, 2, 1]; splice!(A, 5)
2

julia> A
5-element Array{Int64,1}:
 6
 5
 4
 3
 1

julia> splice!(A, 5, -1)
1

julia> A
5-element Array{Int64,1}:
  6
  5
  4
  3
 -1

julia> splice!(A, 1, [-1, -2, -3])
6

julia> A
7-element Array{Int64,1}:
 -1
 -2
 -3
  5
  4
  3
 -1
\end{minted}

To insert \texttt{replacement} before an index \texttt{n} without removing any items, use \texttt{splice!(collection, n:n-1, replacement)}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1325-L1373}{\texttt{source}}



\begin{lstlisting}
splice!(a::Vector, range, [replacement]) -> items
\end{lstlisting}

Remove items in the specified index range, and return a collection containing the removed items. Subsequent items are shifted left to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed items.

To insert \texttt{replacement} before an index \texttt{n} without removing any items, use \texttt{splice!(collection, n:n-1, replacement)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [-1, -2, -3, 5, 4, 3, -1]; splice!(A, 4:3, 2)
0-element Array{Int64,1}

julia> A
8-element Array{Int64,1}:
 -1
 -2
 -3
  2
  5
  4
  3
 -1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1392-L1420}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10980093798189218206}{} 
\hyperlink{10980093798189218206}{\texttt{Base.resize!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
resize!(a::Vector, n::Integer) -> Vector
\end{minted}

Resize \texttt{a} to contain \texttt{n} elements. If \texttt{n} is smaller than the current collection length, the first \texttt{n} elements will be retained. If \texttt{n} is larger, the new elements are not guaranteed to be initialized.

\textbf{Examples}


\begin{minted}{jlcon}
julia> resize!([6, 5, 4, 3, 2, 1], 3)
3-element Array{Int64,1}:
 6
 5
 4

julia> a = resize!([6, 5, 4, 3, 2, 1], 8);

julia> length(a)
8

julia> a[1:6]
6-element Array{Int64,1}:
 6
 5
 4
 3
 2
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1031-L1060}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2587432243763606566}{} 
\hyperlink{2587432243763606566}{\texttt{Base.append!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
append!(collection, collection2) -> collection.
\end{minted}

For an ordered container \texttt{collection}, add the elements of \texttt{collection2} to the end of it.

\textbf{Examples}


\begin{minted}{jlcon}
julia> append!([1],[2,3])
3-element Array{Int64,1}:
 1
 2
 3

julia> append!([1, 2, 3], [4, 5, 6])
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6
\end{minted}

Use \hyperlink{18026893834387542681}{\texttt{push!}} to add individual items to \texttt{collection} which are not already themselves in another collection. The result of the preceding example is equivalent to \texttt{push!([1, 2, 3], 4, 5, 6)}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L925-L951}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9292529440147652243}{} 
\hyperlink{9292529440147652243}{\texttt{Base.prepend!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
prepend!(a::Vector, items) -> collection
\end{minted}

Insert the elements of \texttt{items} to the beginning of \texttt{a}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> prepend!([3],[1,2])
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L980-L993}{\texttt{source}}


\end{adjustwidth}

以下类型均完全实现了上述函数：



\begin{itemize}
\item \texttt{Vector} (a.k.a. 1-dimensional \hyperlink{15492651498431872487}{\texttt{Array}})


\item \texttt{BitVector} (a.k.a. 1-dimensional \hyperlink{18015155802543401629}{\texttt{BitArray}})

\end{itemize}


\hypertarget{13950347812673143734}{}


\section{集合相关的实用工具}


\hypertarget{14946515604348703614}{} 
\hyperlink{14946515604348703614}{\texttt{Base.Pair}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Pair(x, y)
x => y
\end{minted}

Construct a \texttt{Pair} object with type \texttt{Pair\{typeof(x), typeof(y)\}}. The elements are stored in the fields \texttt{first} and \texttt{second}. They can also be accessed via iteration (but a \texttt{Pair} is treated as a single {\textquotedbl}scalar{\textquotedbl} for broadcasting operations).

See also: \hyperlink{3089397136845322041}{\texttt{Dict}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> p = "foo" => 7
"foo" => 7

julia> typeof(p)
Pair{String,Int64}

julia> p.first
"foo"

julia> for x in p
           println(x)
       end
foo
7
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/pair.jl#L18-L45}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1741207879021199162}{} 
\hyperlink{1741207879021199162}{\texttt{Base.Iterators.Pairs}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Iterators.Pairs(values, keys) <: AbstractDict{eltype(keys), eltype(values)}
\end{minted}

Transforms an indexable container into an Dictionary-view of the same data. Modifying the key-space of the underlying data may invalidate this object.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L160-L165}{\texttt{source}}


\end{adjustwidth}

\hypertarget{2401809609636377775}{}


\chapter{数学相关}



\hypertarget{15714690155437633961}{}


\section{数学运算符}


\hypertarget{8228207173393714756}{} 
\hyperlink{8228207173393714756}{\texttt{Base.:-}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
-(x)
\end{minted}

Unary minus operator.

\textbf{Examples}


\begin{minted}{jlcon}
julia> -1
-1

julia> -(2)
-2

julia> -[1 2; 3 4]
2×2 Array{Int64,2}:
 -1  -2
 -3  -4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1956-L1974}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3677358729494553841}{} 
\hyperlink{3677358729494553841}{\texttt{Base.:+}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dt::Date + t::Time -> DateTime
\end{minted}

The addition of a \texttt{Date} with a \texttt{Time} produces a \texttt{DateTime}. The hour, minute, second, and millisecond parts of the \texttt{Time} are used along with the year, month, and day of the \texttt{Date} to create the new \texttt{DateTime}. Non-zero microseconds or nanoseconds in the \texttt{Time} type will result in an \texttt{InexactError} being thrown.




\begin{lstlisting}
+(x, y...)
\end{lstlisting}

Addition operator. \texttt{x+y+z+...} calls this function with all arguments, i.e. \texttt{+(x, y, z, ...)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 1 + 20 + 4
25

julia> +(1, 20, 4)
25
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1940-L1953}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11135345846828585592}{} 
\hyperlink{11135345846828585592}{\texttt{Base.:-}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
-(x, y)
\end{minted}

Subtraction operator.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 2 - 3
-1

julia> -(2, 4.5)
-2.5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1977-L1990}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7592762607639177347}{} 
\hyperlink{7592762607639177347}{\texttt{Base.:*}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
*(x, y...)
\end{minted}

Multiplication operator. \texttt{x*y*z*...} calls this function with all arguments, i.e. \texttt{*(x, y, z, ...)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 2 * 7 * 8
112

julia> *(2, 7, 8)
112
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1993-L2006}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4103478871488785445}{} 
\hyperlink{4103478871488785445}{\texttt{Base.:/}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
/(x, y)
\end{minted}

Right division operator: multiplication of \texttt{x} by the inverse of \texttt{y} on the right. Gives floating-point results for integer arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 1/2
0.5

julia> 4/2
2.0

julia> 4.5/2
2.25
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2009-L2026}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4639577998029770435}{} 
\hyperlink{4639577998029770435}{\texttt{Base.:{\textbackslash}}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
\(x, y)
\end{minted}

Left division operator: multiplication of \texttt{y} by the inverse of \texttt{x} on the left. Gives floating-point results for integer arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 3 \ 6
2.0

julia> inv(3) * 6
2.0

julia> A = [4 3; 2 1]; x = [5, 6];

julia> A \ x
2-element Array{Float64,1}:
  6.5
 -7.0

julia> inv(A) * x
2-element Array{Float64,1}:
  6.5
 -7.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L536-L562}{\texttt{source}}


\end{adjustwidth}
\hypertarget{462277561264792021}{} 
\hyperlink{462277561264792021}{\texttt{Base.:{\textasciicircum}}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
^(x, y)
\end{minted}

Exponentiation operator. If \texttt{x} is a matrix, computes matrix exponentiation.

If \texttt{y} is an \texttt{Int} literal (e.g. \texttt{2} in \texttt{x{\textasciicircum}2} or \texttt{-3} in \texttt{x{\textasciicircum}-3}), the Julia code \texttt{x{\textasciicircum}y} is transformed by the compiler to \texttt{Base.literal\_pow({\textasciicircum}, x, Val(y))}, to enable compile-time specialization on the value of the exponent. (As a default fallback we have \texttt{Base.literal\_pow({\textasciicircum}, x, Val(y)) = {\textasciicircum}(x,y)}, where usually \texttt{{\textasciicircum} == Base.{\textasciicircum}} unless \texttt{{\textasciicircum}} has been defined in the calling namespace.)


\begin{minted}{jlcon}
julia> 3^5
243

julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> A^3
2×2 Array{Int64,2}:
 37   54
 81  118
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/promotion.jl#L316-L342}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17935587874085983500}{} 
\hyperlink{17935587874085983500}{\texttt{Base.fma}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fma(x, y, z)
\end{minted}

Computes \texttt{x*y+z} without rounding the intermediate result \texttt{x*y}. On some systems this is significantly more expensive than \texttt{x*y+z}. \texttt{fma} is used to improve accuracy in certain algorithms. See \hyperlink{7153024527713262493}{\texttt{muladd}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/floatfuncs.jl#L295-L301}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7153024527713262493}{} 
\hyperlink{7153024527713262493}{\texttt{Base.muladd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
muladd(x, y, z)
\end{minted}

Combined multiply-add: computes \texttt{x*y+z}, but allowing the add and multiply to be merged with each other or with surrounding operations for performance. For example, this may be implemented as an \hyperlink{17935587874085983500}{\texttt{fma}} if the hardware supports it efficiently. The result can be different on different machines and can also be different on the same machine due to constant propagation or other optimizations. See \hyperlink{17935587874085983500}{\texttt{fma}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> muladd(3, 2, 1)
7

julia> 3 * 2 + 1
7
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L1087-L1106}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13336866048543706848}{} 
\hyperlink{13336866048543706848}{\texttt{Base.inv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
inv(x)
\end{minted}

Return the multiplicative inverse of \texttt{x}, such that \texttt{x*inv(x)} or \texttt{inv(x)*x} yields \hyperlink{11395333326208453101}{\texttt{one(x)}} (the multiplicative identity) up to roundoff errors.

If \texttt{x} is a number, this is essentially the same as \texttt{one(x)/x}, but for some types \texttt{inv(x)} may be slightly more efficient.

\textbf{Examples}


\begin{minted}{jlcon}
julia> inv(2)
0.5

julia> inv(1 + 2im)
0.2 - 0.4im

julia> inv(1 + 2im) * (1 + 2im)
1.0 + 0.0im

julia> inv(2//3)
3//2
\end{minted}

\begin{quote}
\textbf{Julia 1.2}

\texttt{inv(::Missing)} requires at least Julia 1.2.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L172-L198}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8020976424566491334}{} 
\hyperlink{8020976424566491334}{\texttt{Base.div}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
div(x, y)
÷(x, y)
\end{minted}

The quotient from Euclidean division. Computes \texttt{x/y}, truncated to an integer.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 9 ÷ 4
2

julia> -5 ÷ 3
-1

julia> 5.0 ÷ 2
2.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L708-L725}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15067916827074788527}{} 
\hyperlink{15067916827074788527}{\texttt{Base.fld}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fld(x, y)
\end{minted}

Largest integer less than or equal to \texttt{x/y}. Equivalent to \texttt{div(x, y, RoundDown)}.

See also: \hyperlink{8020976424566491334}{\texttt{div}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> fld(7.3,5.5)
1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/div.jl#L71-L83}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7922388465305816555}{} 
\hyperlink{7922388465305816555}{\texttt{Base.cld}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cld(x, y)
\end{minted}

Smallest integer larger than or equal to \texttt{x/y}. Equivalent to \texttt{div(x, y, RoundUp)}.

See also: \hyperlink{8020976424566491334}{\texttt{div}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> cld(5.5,2.2)
3.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/div.jl#L86-L98}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2082041235715276573}{} 
\hyperlink{2082041235715276573}{\texttt{Base.mod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mod(x::Integer, r::AbstractUnitRange)
\end{minted}

Find \texttt{y} in the range \texttt{r} such that  \(x ≡ y (mod n)\) , where \texttt{n = length(r)}, i.e. \texttt{y = mod(x - first(r), n) + first(r)}.

See also: \hyperlink{13778479217547823795}{\texttt{mod1}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> mod(0, Base.OneTo(3))
3

julia> mod(3, 0:2)
0
\end{minted}

\begin{quote}
\textbf{Julia 1.3}

This method requires at least Julia 1.3.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/range.jl#L1044-L1063}{\texttt{source}}



\begin{lstlisting}
mod(x, y)
rem(x, y, RoundDown)
\end{lstlisting}

The reduction of \texttt{x} modulo \texttt{y}, or equivalently, the remainder of \texttt{x} after floored division by \texttt{y}, i.e. \texttt{x - y*fld(x,y)} if computed without intermediate rounding.

The result will have the same sign as \texttt{y}, and magnitude less than \texttt{abs(y)} (with some exceptions, see note below).

\begin{quote}
\textbf{Note}

When used with floating point values, the exact result may not be representable by the type, and so rounding error may occur. In particular, if the exact result is very close to \texttt{y}, then it may be rounded to \texttt{y}.

\end{quote}

\begin{minted}{jlcon}
julia> mod(8, 3)
2

julia> mod(9, 3)
0

julia> mod(8.9, 3)
2.9000000000000004

julia> mod(eps(), 3)
2.220446049250313e-16

julia> mod(-eps(), 3)
3.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L187-L219}{\texttt{source}}



\begin{lstlisting}
rem(x::Integer, T::Type{<:Integer}) -> T
mod(x::Integer, T::Type{<:Integer}) -> T
%(x::Integer, T::Type{<:Integer}) -> T
\end{lstlisting}

Find \texttt{y::T} such that \texttt{x} ≡ \texttt{y} (mod n), where n is the number of integers representable in \texttt{T}, and \texttt{y} is an integer in \texttt{[typemin(T),typemax(T)]}. If \texttt{T} can represent any integer (e.g. \texttt{T == BigInt}), then this operation corresponds to a conversion to \texttt{T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 129 % Int8
-127
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L460-L475}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3827563084771191385}{} 
\hyperlink{3827563084771191385}{\texttt{Base.rem}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rem(x, y)
%(x, y)
\end{minted}

Remainder from Euclidean division, returning a value of the same sign as \texttt{x}, and smaller in magnitude than \texttt{y}. This value is always exact.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = 15; y = 4;

julia> x % y
3

julia> x == div(x, y) * y + rem(x, y)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L687-L704}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7552737171387915272}{} 
\hyperlink{7552737171387915272}{\texttt{Base.Math.rem2pi}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rem2pi(x, r::RoundingMode)
\end{minted}

Compute the remainder of \texttt{x} after integer division by \texttt{2π}, with the quotient rounded according to the rounding mode \texttt{r}. In other words, the quantity


\begin{lstlisting}
x - 2π*round(x/(2π),r)
\end{lstlisting}

without any intermediate rounding. This internally uses a high precision approximation of 2π, and so will give a more accurate result than \texttt{rem(x,2π,r)}

\begin{itemize}
\item if \texttt{r == RoundNearest}, then the result is in the interval  \([-π, π]\) . This will generally be the most accurate result. See also \hyperlink{868115654703135309}{\texttt{RoundNearest}}.


\item if \texttt{r == RoundToZero}, then the result is in the interval  \([0, 2π]\)  if \texttt{x} is positive,. or  \([-2π, 0]\)  otherwise. See also \hyperlink{7760059079134067537}{\texttt{RoundToZero}}.


\item if \texttt{r == RoundDown}, then the result is in the interval  \([0, 2π]\) . See also \hyperlink{3648739763580508258}{\texttt{RoundDown}}.


\item if \texttt{r == RoundUp}, then the result is in the interval  \([-2π, 0]\) . See also \hyperlink{874246484265932239}{\texttt{RoundUp}}.

\end{itemize}
\textbf{Examples}


\begin{minted}{jlcon}
julia> rem2pi(7pi/4, RoundNearest)
-0.7853981633974485

julia> rem2pi(7pi/4, RoundDown)
5.497787143782138
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L914-L944}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15322754370885673769}{} 
\hyperlink{15322754370885673769}{\texttt{Base.Math.mod2pi}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mod2pi(x)
\end{minted}

Modulus after division by \texttt{2π}, returning in the range  \([0,2π)\) .

This function computes a floating point representation of the modulus after division by numerically exact \texttt{2π}, and is therefore not exactly the same as \texttt{mod(x,2π)}, which would compute the modulus of \texttt{x} relative to division by the floating-point number \texttt{2π}.

\begin{quote}
\textbf{Note}

Depending on the format of the input value, the closest representable value to 2π may be less than 2π. For example, the expression \texttt{mod2pi(2π)} will not return \texttt{0}, because the intermediate value of \texttt{2*π} is a \texttt{Float64} and \texttt{2*Float64(π) < 2*big(π)}. See \hyperlink{7552737171387915272}{\texttt{rem2pi}} for more refined control of this behavior.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> mod2pi(9*pi/4)
0.7853981633974481
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L1062-L1082}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6106909621813654214}{} 
\hyperlink{6106909621813654214}{\texttt{Base.divrem}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
divrem(x, y, r::RoundingMode=RoundToZero)
\end{minted}

The quotient and remainder from Euclidean division. Equivalent to \texttt{(div(x,y,r), rem(x,y,r))}. Equivalently, with the the default value of \texttt{r}, this call is equivalent to \texttt{(x÷y, x\%y)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> divrem(3,7)
(0, 3)

julia> divrem(7,3)
(2, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/div.jl#L102-L117}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2806360720034558325}{} 
\hyperlink{2806360720034558325}{\texttt{Base.fldmod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fldmod(x, y)
\end{minted}

The floored quotient and modulus after division. A convenience wrapper for \texttt{divrem(x, y, RoundDown)}. Equivalent to \texttt{(fld(x,y), mod(x,y))}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/div.jl#L179-L184}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2046682076337602867}{} 
\hyperlink{2046682076337602867}{\texttt{Base.fld1}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fld1(x, y)
\end{minted}

Flooring division, returning a value consistent with \texttt{mod1(x,y)}

See also: \hyperlink{13778479217547823795}{\texttt{mod1}}, \hyperlink{3908876301745770865}{\texttt{fldmod1}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = 15; y = 4;

julia> fld1(x, y)
4

julia> x == fld(x, y) * y + mod(x, y)
true

julia> x == (fld1(x, y) - 1) * y + mod1(x, y)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L749-L769}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13778479217547823795}{} 
\hyperlink{13778479217547823795}{\texttt{Base.mod1}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mod1(x, y)
\end{minted}

Modulus after flooring division, returning a value \texttt{r} such that \texttt{mod(r, y) == mod(x, y)} in the range  \((0, y]\)  for positive \texttt{y} and in the range  \([y,0)\)  for negative \texttt{y}.

See also: \hyperlink{2046682076337602867}{\texttt{fld1}}, \hyperlink{3908876301745770865}{\texttt{fldmod1}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> mod1(4, 2)
2

julia> mod1(4, 3)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L729-L745}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3908876301745770865}{} 
\hyperlink{3908876301745770865}{\texttt{Base.fldmod1}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fldmod1(x, y)
\end{minted}

Return \texttt{(fld1(x,y), mod1(x,y))}.

See also: \hyperlink{2046682076337602867}{\texttt{fld1}}, \hyperlink{13778479217547823795}{\texttt{mod1}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L776-L782}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17539582191808611917}{} 
\hyperlink{17539582191808611917}{\texttt{Base.://}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
//(num, den)
\end{minted}

Divide two integers or rational numbers, giving a \hyperlink{8304566144531167610}{\texttt{Rational}} result.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 3 // 5
3//5

julia> (3 // 5) // (2 // 1)
3//10
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rational.jl#L36-L49}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6368672003928643787}{} 
\hyperlink{6368672003928643787}{\texttt{Base.rationalize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rationalize([T<:Integer=Int,] x; tol::Real=eps(x))
\end{minted}

Approximate floating point number \texttt{x} as a \hyperlink{8304566144531167610}{\texttt{Rational}} number with components of the given integer type. The result will differ from \texttt{x} by no more than \texttt{tol}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rationalize(5.6)
28//5

julia> a = rationalize(BigInt, 10.3)
103//10

julia> typeof(numerator(a))
BigInt
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rational.jl#L121-L138}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7885506453580572157}{} 
\hyperlink{7885506453580572157}{\texttt{Base.numerator}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
numerator(x)
\end{minted}

Numerator of the rational representation of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> numerator(2//3)
2

julia> numerator(4)
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rational.jl#L201-L214}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12407209279719593434}{} 
\hyperlink{12407209279719593434}{\texttt{Base.denominator}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
denominator(x)
\end{minted}

Denominator of the rational representation of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> denominator(2//3)
3

julia> denominator(4)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rational.jl#L218-L231}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2724916807067930829}{} 
\hyperlink{2724916807067930829}{\texttt{Base.:<<}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
<<(x, n)
\end{minted}

Left bit shift operator, \texttt{x << n}. For \texttt{n >= 0}, the result is \texttt{x} shifted left by \texttt{n} bits, filling with \texttt{0}s. This is equivalent to \texttt{x * 2{\textasciicircum}n}. For \texttt{n < 0}, this is equivalent to \texttt{x >> -n}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Int8(3) << 2
12

julia> bitstring(Int8(3))
"00000011"

julia> bitstring(Int8(12))
"00001100"
\end{minted}

See also \hyperlink{6883264745383491304}{\texttt{>>}}, \hyperlink{16613216773443333487}{\texttt{>>>}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L569-L588}{\texttt{source}}



\begin{lstlisting}
<<(B::BitVector, n) -> BitVector
\end{lstlisting}

Left bit shift operator, \texttt{B << n}. For \texttt{n >= 0}, the result is \texttt{B} with elements shifted \texttt{n} positions backwards, filling with \texttt{false} values. If \texttt{n < 0}, elements are shifted forwards. Equivalent to \texttt{B >> -n}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> B = BitVector([true, false, true, false, false])
5-element BitArray{1}:
 1
 0
 1
 0
 0

julia> B << 1
5-element BitArray{1}:
 0
 1
 0
 0
 0

julia> B << -1
5-element BitArray{1}:
 0
 1
 0
 1
 0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/bitarray.jl#L1311-L1345}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6883264745383491304}{} 
\hyperlink{6883264745383491304}{\texttt{Base.:>>}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
>>(x, n)
\end{minted}

Right bit shift operator, \texttt{x >> n}. For \texttt{n >= 0}, the result is \texttt{x} shifted right by \texttt{n} bits, where \texttt{n >= 0}, filling with \texttt{0}s if \texttt{x >= 0}, \texttt{1}s if \texttt{x < 0}, preserving the sign of \texttt{x}. This is equivalent to \texttt{fld(x, 2{\textasciicircum}n)}. For \texttt{n < 0}, this is equivalent to \texttt{x << -n}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Int8(13) >> 2
3

julia> bitstring(Int8(13))
"00001101"

julia> bitstring(Int8(3))
"00000011"

julia> Int8(-14) >> 2
-4

julia> bitstring(Int8(-14))
"11110010"

julia> bitstring(Int8(-4))
"11111100"
\end{minted}

See also \hyperlink{16613216773443333487}{\texttt{>>>}}, \hyperlink{2724916807067930829}{\texttt{<<}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L604-L633}{\texttt{source}}



\begin{lstlisting}
>>(B::BitVector, n) -> BitVector
\end{lstlisting}

Right bit shift operator, \texttt{B >> n}. For \texttt{n >= 0}, the result is \texttt{B} with elements shifted \texttt{n} positions forward, filling with \texttt{false} values. If \texttt{n < 0}, elements are shifted backwards. Equivalent to \texttt{B << -n}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> B = BitVector([true, false, true, false, false])
5-element BitArray{1}:
 1
 0
 1
 0
 0

julia> B >> 1
5-element BitArray{1}:
 0
 1
 0
 1
 0

julia> B >> -1
5-element BitArray{1}:
 0
 1
 0
 0
 0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/bitarray.jl#L1273-L1307}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16613216773443333487}{} 
\hyperlink{16613216773443333487}{\texttt{Base.:>>>}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
>>>(x, n)
\end{minted}

Unsigned right bit shift operator, \texttt{x >>> n}. For \texttt{n >= 0}, the result is \texttt{x} shifted right by \texttt{n} bits, where \texttt{n >= 0}, filling with \texttt{0}s. For \texttt{n < 0}, this is equivalent to \texttt{x << -n}.

For \hyperlink{4780971278803506664}{\texttt{Unsigned}} integer types, this is equivalent to \hyperlink{6883264745383491304}{\texttt{>>}}. For \hyperlink{14154866400772377486}{\texttt{Signed}} integer types, this is equivalent to \texttt{signed(unsigned(x) >> n)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Int8(-14) >>> 2
60

julia> bitstring(Int8(-14))
"11110010"

julia> bitstring(Int8(60))
"00111100"
\end{minted}

\hyperlink{423405808990690832}{\texttt{BigInt}}s are treated as if having infinite size, so no filling is required and this is equivalent to \hyperlink{6883264745383491304}{\texttt{>>}}.

See also \hyperlink{6883264745383491304}{\texttt{>>}}, \hyperlink{2724916807067930829}{\texttt{<<}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L645-L671}{\texttt{source}}



\begin{lstlisting}
>>>(B::BitVector, n) -> BitVector
\end{lstlisting}

Unsigned right bitshift operator, \texttt{B >>> n}. Equivalent to \texttt{B >> n}. See \hyperlink{6883264745383491304}{\texttt{>>}} for details and examples.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/bitarray.jl#L1348-L1353}{\texttt{source}}


\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Base.bitrotate}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{1027906901078185239}{} 
\hyperlink{1027906901078185239}{\texttt{Base.::}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
(:)(I::CartesianIndex, J::CartesianIndex)
\end{minted}

Construct \hyperlink{16831958174907250244}{\texttt{CartesianIndices}} from two \texttt{CartesianIndex}.

\begin{quote}
\textbf{Julia 1.1}

This method requires at least Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> I = CartesianIndex(2,1);

julia> J = CartesianIndex(3,3);

julia> I:J
2×3 CartesianIndices{2,Tuple{UnitRange{Int64},UnitRange{Int64}}}:
 CartesianIndex(2, 1)  CartesianIndex(2, 2)  CartesianIndex(2, 3)
 CartesianIndex(3, 1)  CartesianIndex(3, 2)  CartesianIndex(3, 3)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L264-L283}{\texttt{source}}



\begin{lstlisting}
(:)(start, [step], stop)
\end{lstlisting}

Range operator. \texttt{a:b} constructs a range from \texttt{a} to \texttt{b} with a step size of 1 (a \hyperlink{9165955949298153694}{\texttt{UnitRange}}) , and \texttt{a:s:b} is similar but uses a step size of \texttt{s} (a \hyperlink{11698840710736817669}{\texttt{StepRange}}).

\texttt{:} is also used in indexing to select whole dimensions  and for \hyperlink{18332791376992528422}{\texttt{Symbol}} literals, as in e.g. \texttt{:hello}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/range.jl#L31-L39}{\texttt{source}}


\end{adjustwidth}
\hypertarget{737600656772861535}{} 
\hyperlink{737600656772861535}{\texttt{Base.range}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
range(start[, stop]; length, stop, step=1)
\end{minted}

Given a starting value, construct a range either by length or from \texttt{start} to \texttt{stop}, optionally with a given step (defaults to 1, a \hyperlink{9165955949298153694}{\texttt{UnitRange}}). One of \texttt{length} or \texttt{stop} is required.  If \texttt{length}, \texttt{stop}, and \texttt{step} are all specified, they must agree.

If \texttt{length} and \texttt{stop} are provided and \texttt{step} is not, the step size will be computed automatically such that there are \texttt{length} linearly spaced elements in the range (a \hyperlink{5701362841495158413}{\texttt{LinRange}}).

If \texttt{step} and \texttt{stop} are provided and \texttt{length} is not, the overall range length will be computed automatically such that the elements are \texttt{step} spaced (a \hyperlink{11698840710736817669}{\texttt{StepRange}}).

\texttt{stop} may be specified as either a positional or keyword argument.

\begin{quote}
\textbf{Julia 1.1}

\texttt{stop} as a positional argument requires at least Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> range(1, length=100)
1:100

julia> range(1, stop=100)
1:100

julia> range(1, step=5, length=100)
1:5:496

julia> range(1, step=5, stop=100)
1:5:96

julia> range(1, 10, length=101)
1.0:0.09:10.0

julia> range(1, 100, step=5)
1:5:96
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/range.jl#L49-L87}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7189994599038205424}{} 
\hyperlink{7189994599038205424}{\texttt{Base.OneTo}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.OneTo(n)
\end{minted}

Define an \texttt{AbstractUnitRange} that behaves like \texttt{1:n}, with the added distinction that the lower limit is guaranteed (by the type system) to be 1.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/range.jl#L302-L308}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6593444000385137506}{} 
\hyperlink{6593444000385137506}{\texttt{Base.StepRangeLen}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
StepRangeLen{T,R,S}(ref::R, step::S, len, [offset=1]) where {T,R,S}
StepRangeLen(       ref::R, step::S, len, [offset=1]) where {  R,S}
\end{minted}

A range \texttt{r} where \texttt{r[i]} produces values of type \texttt{T} (in the second form, \texttt{T} is deduced automatically), parameterized by a \texttt{ref}erence value, a \texttt{step}, and the \texttt{len}gth. By default \texttt{ref} is the starting value \texttt{r[1]}, but alternatively you can supply it as the value of \texttt{r[offset]} for some other index \texttt{1 <= offset <= len}. In conjunction with \texttt{TwicePrecision} this can be used to implement ranges that are free of roundoff error.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/range.jl#L325-L336}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15143149452920304570}{} 
\hyperlink{15143149452920304570}{\texttt{Base.:==}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
==(x, y)
\end{minted}

Generic equality operator. Falls back to \hyperlink{7974744969331231272}{\texttt{===}}. Should be implemented for all types with a notion of equality, based on the abstract value that an instance represents. For example, all numeric types are compared by numeric value, ignoring type. Strings are compared as sequences of characters, ignoring encoding. For collections, \texttt{==} is generally called recursively on all contents, though other properties (like the shape for arrays) may also be taken into account.

This operator follows IEEE semantics for floating-point numbers: \texttt{0.0 == -0.0} and \texttt{NaN != NaN}.

The result is of type \texttt{Bool}, except when one of the operands is \hyperlink{14596725676261444434}{\texttt{missing}}, in which case \texttt{missing} is returned (\href{https://en.wikipedia.org/wiki/Three-valued\_logic}{three-valued logic}). For collections, \texttt{missing} is returned if at least one of the operands contains a \texttt{missing} value and all non-missing values are equal. Use \hyperlink{269533589463185031}{\texttt{isequal}} or \hyperlink{7974744969331231272}{\texttt{===}} to always get a \texttt{Bool} result.

\textbf{Implementation}

New numeric types should implement this function for two arguments of the new type, and handle comparison to other types via promotion rules where possible.

\hyperlink{269533589463185031}{\texttt{isequal}} falls back to \texttt{==}, so new methods of \texttt{==} will be used by the \hyperlink{3089397136845322041}{\texttt{Dict}} type to compare keys. If your type will be used as a dictionary key, it should therefore also implement \hyperlink{13797072367283572032}{\texttt{hash}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L55-L82}{\texttt{source}}



\begin{lstlisting}
==(x)
\end{lstlisting}

Create a function that compares its argument to \texttt{x} using \hyperlink{15143149452920304570}{\texttt{==}}, i.e. a function equivalent to \texttt{y -> y == x}.

The returned function is of type \texttt{Base.Fix2\{typeof(==)\}}, which can be used to implement specialized methods.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L927-L935}{\texttt{source}}



\begin{minted}{julia}
==(a::AbstractString, b::AbstractString) -> Bool
\end{minted}

Test whether two strings are equal character by character (technically, Unicode code point by code point).

\textbf{Examples}


\begin{minted}{jlcon}
julia> "abc" == "abc"
true

julia> "abc" == "αβγ"
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L280-L294}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3046079188653285114}{} 
\hyperlink{3046079188653285114}{\texttt{Base.:!=}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
!=(x, y)
≠(x,y)
\end{minted}

Not-equals comparison operator. Always gives the opposite answer as \hyperlink{15143149452920304570}{\texttt{==}}.

\textbf{Implementation}

New types should generally not implement this, and rely on the fallback definition \texttt{!=(x,y) = !(x==y)} instead.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 3 != 2
true

julia> "foo" ≠ "foo"
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L174-L192}{\texttt{source}}



\begin{lstlisting}
!=(x)
\end{lstlisting}

Create a function that compares its argument to \texttt{x} using \hyperlink{3046079188653285114}{\texttt{!=}}, i.e. a function equivalent to \texttt{y -> y != x}. The returned function is of type \texttt{Base.Fix2\{typeof(!=)\}}, which can be used to implement specialized methods.

\begin{quote}
\textbf{Julia 1.2}

This functionality requires at least Julia 1.2.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L938-L948}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3509174727635606109}{} 
\hyperlink{3509174727635606109}{\texttt{Base.:!==}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
!==(x, y)
≢(x,y)
\end{minted}

Always gives the opposite answer as \hyperlink{7974744969331231272}{\texttt{===}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1, 2]; b = [1, 2];

julia> a ≢ b
true

julia> a ≢ a
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L223-L239}{\texttt{source}}


\end{adjustwidth}
\hypertarget{702782232449268329}{} 
\hyperlink{702782232449268329}{\texttt{Base.:<}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
<(x, y)
\end{minted}

Less-than comparison operator. Falls back to \hyperlink{8062916604071842790}{\texttt{isless}}. Because of the behavior of floating-point NaN values, this operator implements a partial order.

\textbf{Implementation}

New numeric types with a canonical partial order should implement this function for two arguments of the new type. Types with a canonical total order should implement \hyperlink{8062916604071842790}{\texttt{isless}} instead. (x < y) | (x == y)

\textbf{Examples}


\begin{minted}{jlcon}
julia> 'a' < 'b'
true

julia> "abc" < "abd"
true

julia> 5 < 3
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L243-L267}{\texttt{source}}



\begin{lstlisting}
<(x)
\end{lstlisting}

Create a function that compares its argument to \texttt{x} using \hyperlink{702782232449268329}{\texttt{<}}, i.e. a function equivalent to \texttt{y -> y < x}. The returned function is of type \texttt{Base.Fix2\{typeof(<)\}}, which can be used to implement specialized methods.

\begin{quote}
\textbf{Julia 1.2}

This functionality requires at least Julia 1.2.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L990-L1000}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11411050964021316526}{} 
\hyperlink{11411050964021316526}{\texttt{Base.:<=}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
<=(x, y)
≤(x,y)
\end{minted}

Less-than-or-equals comparison operator. Falls back to \texttt{(x < y) | (x == y)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 'a' <= 'b'
true

julia> 7 ≤ 7 ≤ 9
true

julia> "abc" ≤ "abc"
true

julia> 5 <= 3
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L296-L316}{\texttt{source}}



\begin{lstlisting}
<=(x)
\end{lstlisting}

Create a function that compares its argument to \texttt{x} using \hyperlink{11411050964021316526}{\texttt{<=}}, i.e. a function equivalent to \texttt{y -> y <= x}. The returned function is of type \texttt{Base.Fix2\{typeof(<=)\}}, which can be used to implement specialized methods.

\begin{quote}
\textbf{Julia 1.2}

This functionality requires at least Julia 1.2.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L964-L974}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8677991761303191103}{} 
\hyperlink{8677991761303191103}{\texttt{Base.:>}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
>(x, y)
\end{minted}

Greater-than comparison operator. Falls back to \texttt{y < x}.

\textbf{Implementation}

Generally, new types should implement \hyperlink{702782232449268329}{\texttt{<}} instead of this function, and rely on the fallback definition \texttt{>(x, y) = y < x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 'a' > 'b'
false

julia> 7 > 3 > 1
true

julia> "abc" > "abd"
false

julia> 5 > 3
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L270-L293}{\texttt{source}}



\begin{lstlisting}
>(x)
\end{lstlisting}

Create a function that compares its argument to \texttt{x} using \hyperlink{8677991761303191103}{\texttt{>}}, i.e. a function equivalent to \texttt{y -> y > x}. The returned function is of type \texttt{Base.Fix2\{typeof(>)\}}, which can be used to implement specialized methods.

\begin{quote}
\textbf{Julia 1.2}

This functionality requires at least Julia 1.2.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L977-L987}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7019639580556993898}{} 
\hyperlink{7019639580556993898}{\texttt{Base.:>=}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
>=(x, y)
≥(x,y)
\end{minted}

Greater-than-or-equals comparison operator. Falls back to \texttt{y <= x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 'a' >= 'b'
false

julia> 7 ≥ 7 ≥ 3
true

julia> "abc" ≥ "abc"
true

julia> 5 >= 3
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L320-L340}{\texttt{source}}



\begin{lstlisting}
>=(x)
\end{lstlisting}

Create a function that compares its argument to \texttt{x} using \hyperlink{7019639580556993898}{\texttt{>=}}, i.e. a function equivalent to \texttt{y -> y >= x}. The returned function is of type \texttt{Base.Fix2\{typeof(>=)\}}, which can be used to implement specialized methods.

\begin{quote}
\textbf{Julia 1.2}

This functionality requires at least Julia 1.2.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L951-L961}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8951185024259053949}{} 
\hyperlink{8951185024259053949}{\texttt{Base.cmp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cmp(x,y)
\end{minted}

Return -1, 0, or 1 depending on whether \texttt{x} is less than, equal to, or greater than \texttt{y}, respectively. Uses the total order implemented by \texttt{isless}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> cmp(1, 2)
-1

julia> cmp(2, 1)
1

julia> cmp(2+im, 3-im)
ERROR: MethodError: no method matching isless(::Complex{Int64}, ::Complex{Int64})
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L364-L382}{\texttt{source}}



\begin{lstlisting}
cmp(<, x, y)
\end{lstlisting}

Return -1, 0, or 1 depending on whether \texttt{x} is less than, equal to, or greater than \texttt{y}, respectively. The first argument specifies a less-than comparison function to use.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L385-L390}{\texttt{source}}



\begin{minted}{julia}
cmp(a::AbstractString, b::AbstractString) -> Int
\end{minted}

Compare two strings. Return \texttt{0} if both strings have the same length and the character at each index is the same in both strings. Return \texttt{-1} if \texttt{a} is a prefix of \texttt{b}, or if \texttt{a} comes before \texttt{b} in alphabetical order. Return \texttt{1} if \texttt{b} is a prefix of \texttt{a}, or if \texttt{b} comes before \texttt{a} in alphabetical order (technically, lexicographical order by Unicode code points).

\textbf{Examples}


\begin{minted}{jlcon}
julia> cmp("abc", "abc")
0

julia> cmp("ab", "abc")
-1

julia> cmp("abc", "ab")
1

julia> cmp("ab", "ac")
-1

julia> cmp("ac", "ab")
1

julia> cmp("α", "a")
1

julia> cmp("b", "β")
-1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L237-L269}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2433030275488323500}{} 
\hyperlink{2433030275488323500}{\texttt{Base.:{\textasciitilde}}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
~(x)
\end{minted}

Bitwise not.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ~4
-5

julia> ~10
-11

julia> ~true
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L237-L253}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1494761116451616317}{} 
\hyperlink{1494761116451616317}{\texttt{Base.:\&}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
&(x, y)
\end{minted}

Bitwise and. Implements \href{https://en.wikipedia.org/wiki/Three-valued\_logic}{three-valued logic}, returning \hyperlink{14596725676261444434}{\texttt{missing}} if one operand is \texttt{missing} and the other is \texttt{true}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 4 & 10
0

julia> 4 & 12
4

julia> true & missing
missing

julia> false & missing
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L256-L276}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9633687763646488853}{} 
\hyperlink{9633687763646488853}{\texttt{Base.:|}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
|(x, y)
\end{minted}

Bitwise or. Implements \href{https://en.wikipedia.org/wiki/Three-valued\_logic}{three-valued logic}, returning \hyperlink{14596725676261444434}{\texttt{missing}} if one operand is \texttt{missing} and the other is \texttt{false}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 4 | 10
14

julia> 4 | 1
5

julia> true | missing
true

julia> false | missing
missing
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L279-L299}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7071880015536674935}{} 
\hyperlink{7071880015536674935}{\texttt{Base.xor}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}[escapeinside=\#\%]{julia}
xor(x, y)
#\unicodeveebar%(x, y)
\end{minted}

Bitwise exclusive or of \texttt{x} and \texttt{y}. Implements \href{https://en.wikipedia.org/wiki/Three-valued\_logic}{three-valued logic}, returning \hyperlink{14596725676261444434}{\texttt{missing}} if one of the arguments is \texttt{missing}.

The infix operation \texttt{a \unicodeveebar{} b} is a synonym for \texttt{xor(a,b)}, and \texttt{\unicodeveebar{}} can be typed by tab-completing \texttt{{\textbackslash}xor} or \texttt{{\textbackslash}veebar} in the Julia REPL.

\textbf{Examples}


\begin{minted}[escapeinside=\#\%]{jlcon}
julia> xor(true, false)
true

julia> xor(true, true)
false

julia> xor(true, missing)
missing

julia> false #\unicodeveebar% false
false

julia> [true; true; false] .#\unicodeveebar% [true; false; false]
3-element BitArray{1}:
 0
 1
 0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/bool.jl#L43-L74}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4329035214952292986}{} 
\hyperlink{4329035214952292986}{\texttt{Base.:!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
!(x)
\end{minted}

Boolean not. Implements \href{https://en.wikipedia.org/wiki/Three-valued\_logic}{three-valued logic}, returning \hyperlink{14596725676261444434}{\texttt{missing}} if \texttt{x} is \texttt{missing}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> !true
false

julia> !false
true

julia> !missing
missing

julia> .![true false true]
1×3 BitArray{2}:
 0  1  0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/bool.jl#L11-L32}{\texttt{source}}



\begin{lstlisting}
!f::Function
\end{lstlisting}

Predicate function negation: when the argument of \texttt{!} is a function, it returns a function which computes the boolean negation of \texttt{f}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> str = "∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |f(x)-f(y)| < ε"
"∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |f(x)-f(y)| < ε"

julia> filter(isletter, str)
"εδxyδfxfyε"

julia> filter(!isletter, str)
"∀  > 0, ∃  > 0: |-| <  ⇒ |()-()| < "
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L862-L879}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4714012140247170866}{} 
\hyperlink{4714012140247170866}{\texttt{\&\&}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
x && y
\end{minted}

Short-circuiting boolean AND.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L835-L839}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2053797086840563251}{} 
\hyperlink{2053797086840563251}{\texttt{||}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
x || y
\end{minted}

Short-circuiting boolean OR.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L842-L846}{\texttt{source}}


\end{adjustwidth}

\hypertarget{5496173814433638888}{}


\section{数学函数}


\hypertarget{12499503887608197213}{} 
\hyperlink{12499503887608197213}{\texttt{Base.isapprox}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isapprox(x, y; rtol::Real=atol>0 ? 0 : √eps, atol::Real=0, nans::Bool=false, norm::Function)
\end{minted}

Inexact equality comparison: \texttt{true} if \texttt{norm(x-y) <= max(atol, rtol*max(norm(x), norm(y)))}. The default \texttt{atol} is zero and the default \texttt{rtol} depends on the types of \texttt{x} and \texttt{y}. The keyword argument \texttt{nans} determines whether or not NaN values are considered equal (defaults to false).

For real or complex floating-point values, if an \texttt{atol > 0} is not specified, \texttt{rtol} defaults to the square root of \hyperlink{4594213520310841636}{\texttt{eps}} of the type of \texttt{x} or \texttt{y}, whichever is bigger (least precise). This corresponds to requiring equality of about half of the significand digits. Otherwise, e.g. for integer arguments or if an \texttt{atol > 0} is supplied, \texttt{rtol} defaults to zero.

\texttt{x} and \texttt{y} may also be arrays of numbers, in which case \texttt{norm} defaults to the usual \texttt{norm} function in LinearAlgebra, but may be changed by passing a \texttt{norm::Function} keyword argument. (For numbers, \texttt{norm} is the same thing as \texttt{abs}.) When \texttt{x} and \texttt{y} are arrays, if \texttt{norm(x-y)} is not finite (i.e. \texttt{±Inf} or \texttt{NaN}), the comparison falls back to checking whether all elements of \texttt{x} and \texttt{y} are approximately equal component-wise.

The binary operator \texttt{≈} is equivalent to \texttt{isapprox} with the default arguments, and \texttt{x ≉ y} is equivalent to \texttt{!isapprox(x,y)}.

Note that \texttt{x ≈ 0} (i.e., comparing to zero with the default tolerances) is equivalent to \texttt{x == 0} since the default \texttt{atol} is \texttt{0}.  In such cases, you should either supply an appropriate \texttt{atol} (or use \texttt{norm(x) ≤ atol}) or rearrange your code (e.g. use \texttt{x ≈ y} rather than \texttt{x - y ≈ 0}).   It is not possible to pick a nonzero \texttt{atol} automatically because it depends on the overall scaling (the {\textquotedbl}units{\textquotedbl}) of your problem: for example, in \texttt{x - y ≈ 0}, \texttt{atol=1e-9} is an absurdly small tolerance if \texttt{x} is the \href{https://en.wikipedia.org/wiki/Earth\_radius}{radius of the Earth} in meters, but an absurdly large tolerance if \texttt{x} is the \href{https://en.wikipedia.org/wiki/Bohr\_radius}{radius of a Hydrogen atom} in meters.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 0.1 ≈ (0.1 - 1e-10)
true

julia> isapprox(10, 11; atol = 2)
true

julia> isapprox([10.0^9, 1.0], [10.0^9, 2.0])
true

julia> 1e-10 ≈ 0
false

julia> isapprox(1e-10, 0, atol=1e-8)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/floatfuncs.jl#L222-L272}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10540279982054240733}{} 
\hyperlink{10540279982054240733}{\texttt{Base.sin}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sin(x)
\end{minted}

Compute sine of \texttt{x}, where \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L407-L411}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10355926621556840804}{} 
\hyperlink{10355926621556840804}{\texttt{Base.cos}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cos(x)
\end{minted}

Compute cosine of \texttt{x}, where \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L414-L418}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11271016674859747568}{} 
\hyperlink{11271016674859747568}{\texttt{Base.Math.sincos}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sincos(x)
\end{minted}

Simultaneously compute the sine and cosine of \texttt{x}, where the \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L168-L172}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16587188232273592448}{} 
\hyperlink{16587188232273592448}{\texttt{Base.tan}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tan(x)
\end{minted}

Compute tangent of \texttt{x}, where \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L421-L425}{\texttt{source}}


\end{adjustwidth}
\hypertarget{38337471195460170}{} 
\hyperlink{38337471195460170}{\texttt{Base.Math.sind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sind(x)
\end{minted}

Compute sine of \texttt{x}, where \texttt{x} is in degrees. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L1101-L1103}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6437354581891939537}{} 
\hyperlink{6437354581891939537}{\texttt{Base.Math.cosd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cosd(x)
\end{minted}

Compute cosine of \texttt{x}, where \texttt{x} is in degrees. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L1101-L1103}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10125316154174803495}{} 
\hyperlink{10125316154174803495}{\texttt{Base.Math.tand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tand(x)
\end{minted}

Compute tangent of \texttt{x}, where \texttt{x} is in degrees. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L1101-L1103}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16554510911661822298}{} 
\hyperlink{16554510911661822298}{\texttt{Base.Math.sinpi}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sinpi(x)
\end{minted}

Compute  \(\sin(\pi x)\)  more accurately than \texttt{sin(pi*x)}, especially for large \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L746-L750}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2974547424856180253}{} 
\hyperlink{2974547424856180253}{\texttt{Base.Math.cospi}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cospi(x)
\end{minted}

Compute  \(\cos(\pi x)\)  more accurately than \texttt{cos(pi*x)}, especially for large \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L809-L813}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8358213610919564439}{} 
\hyperlink{8358213610919564439}{\texttt{Base.sinh}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sinh(x)
\end{minted}

Compute hyperbolic sine of \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L299-L303}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15935907810641925869}{} 
\hyperlink{15935907810641925869}{\texttt{Base.cosh}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cosh(x)
\end{minted}

Compute hyperbolic cosine of \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L306-L310}{\texttt{source}}


\end{adjustwidth}
\hypertarget{26467867180214017}{} 
\hyperlink{26467867180214017}{\texttt{Base.tanh}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tanh(x)
\end{minted}

Compute hyperbolic tangent of \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L313-L317}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10601878151948439368}{} 
\hyperlink{10601878151948439368}{\texttt{Base.asin}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asin(x)
\end{minted}

Compute the inverse sine of \texttt{x}, where the output is in radians.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L428-L432}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12082560375801220429}{} 
\hyperlink{12082560375801220429}{\texttt{Base.acos}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acos(x)
\end{minted}

Compute the inverse cosine of \texttt{x}, where the output is in radians



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L435-L439}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16445804261034090556}{} 
\hyperlink{16445804261034090556}{\texttt{Base.atan}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
atan(y)
atan(y, x)
\end{minted}

Compute the inverse tangent of \texttt{y} or \texttt{y/x}, respectively.

For one argument, this is the angle in radians between the positive \emph{x}-axis and the point (1, \emph{y}), returning a value in the interval  \([-\pi/2, \pi/2]\) .

For two arguments, this is the angle in radians between the positive \emph{x}-axis and the point (\emph{x}, \emph{y}), returning a value in the interval  \([-\pi, \pi]\) . This corresponds to a standard \href{https://en.wikipedia.org/wiki/Atan2}{\texttt{atan2}} function.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L320-L332}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11304354062744129101}{} 
\hyperlink{11304354062744129101}{\texttt{Base.Math.asind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asind(x)
\end{minted}

Compute the inverse sine of \texttt{x}, where the output is in degrees. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L1111-L1114}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9068426203671659431}{} 
\hyperlink{9068426203671659431}{\texttt{Base.Math.acosd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acosd(x)
\end{minted}

Compute the inverse cosine of \texttt{x}, where the output is in degrees. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L1111-L1114}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16709452940889335182}{} 
\hyperlink{16709452940889335182}{\texttt{Base.Math.atand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
atand(y)
atand(y,x)
\end{minted}

Compute the inverse tangent of \texttt{y} or \texttt{y/x}, respectively, where the output is in degrees.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L1118-L1123}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2348370164701029702}{} 
\hyperlink{2348370164701029702}{\texttt{Base.Math.sec}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sec(x)
\end{minted}

Compute the secant of \texttt{x}, where \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L965-L969}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6870524379126652076}{} 
\hyperlink{6870524379126652076}{\texttt{Base.Math.csc}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
csc(x)
\end{minted}

Compute the cosecant of \texttt{x}, where \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L965-L969}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10310506620597376911}{} 
\hyperlink{10310506620597376911}{\texttt{Base.Math.cot}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cot(x)
\end{minted}

Compute the cotangent of \texttt{x}, where \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L965-L969}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3627927627858191087}{} 
\hyperlink{3627927627858191087}{\texttt{Base.Math.secd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
secd(x)
\end{minted}

Compute the secant of \texttt{x}, where \texttt{x} is in degrees.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L975-L979}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5282241990933081613}{} 
\hyperlink{5282241990933081613}{\texttt{Base.Math.cscd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cscd(x)
\end{minted}

Compute the cosecant of \texttt{x}, where \texttt{x} is in degrees.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L975-L979}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10552388625489786427}{} 
\hyperlink{10552388625489786427}{\texttt{Base.Math.cotd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cotd(x)
\end{minted}

Compute the cotangent of \texttt{x}, where \texttt{x} is in degrees.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L975-L979}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6414678656298972359}{} 
\hyperlink{6414678656298972359}{\texttt{Base.Math.asec}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asec(x)
\end{minted}

Compute the inverse secant of \texttt{x}, where the output is in radians. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L989-L991}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6613609554321971358}{} 
\hyperlink{6613609554321971358}{\texttt{Base.Math.acsc}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acsc(x)
\end{minted}

Compute the inverse cosecant of \texttt{x}, where the output is in radians. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L989-L991}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5496289593528195445}{} 
\hyperlink{5496289593528195445}{\texttt{Base.Math.acot}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acot(x)
\end{minted}

Compute the inverse cotangent of \texttt{x}, where the output is in radians. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L989-L991}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11130798465735678102}{} 
\hyperlink{11130798465735678102}{\texttt{Base.Math.asecd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asecd(x)
\end{minted}

Compute the inverse secant of \texttt{x}, where the output is in degrees. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L1111-L1114}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4156782540452156093}{} 
\hyperlink{4156782540452156093}{\texttt{Base.Math.acscd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acscd(x)
\end{minted}

Compute the inverse cosecant of \texttt{x}, where the output is in degrees. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L1111-L1114}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8127927203221847430}{} 
\hyperlink{8127927203221847430}{\texttt{Base.Math.acotd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acotd(x)
\end{minted}

Compute the inverse cotangent of \texttt{x}, where the output is in degrees. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L1111-L1114}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11032843379178642696}{} 
\hyperlink{11032843379178642696}{\texttt{Base.Math.sech}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sech(x)
\end{minted}

Compute the hyperbolic secant of \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L970-L974}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7622662781941268376}{} 
\hyperlink{7622662781941268376}{\texttt{Base.Math.csch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
csch(x)
\end{minted}

Compute the hyperbolic cosecant of \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L970-L974}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2237100109226086781}{} 
\hyperlink{2237100109226086781}{\texttt{Base.Math.coth}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
coth(x)
\end{minted}

Compute the hyperbolic cotangent of \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L970-L974}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9149326513268706036}{} 
\hyperlink{9149326513268706036}{\texttt{Base.asinh}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asinh(x)
\end{minted}

Compute the inverse hyperbolic sine of \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L335-L339}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18089515813362208379}{} 
\hyperlink{18089515813362208379}{\texttt{Base.acosh}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acosh(x)
\end{minted}

Compute the inverse hyperbolic cosine of \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L442-L446}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13328745702871778622}{} 
\hyperlink{13328745702871778622}{\texttt{Base.atanh}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
atanh(x)
\end{minted}

Compute the inverse hyperbolic tangent of \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L449-L453}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7159979165465243804}{} 
\hyperlink{7159979165465243804}{\texttt{Base.Math.asech}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asech(x)
\end{minted}

Compute the inverse hyperbolic secant of \texttt{x}. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L992-L994}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6612108333331684139}{} 
\hyperlink{6612108333331684139}{\texttt{Base.Math.acsch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acsch(x)
\end{minted}

Compute the inverse hyperbolic cosecant of \texttt{x}. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L992-L994}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7076402848633775115}{} 
\hyperlink{7076402848633775115}{\texttt{Base.Math.acoth}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acoth(x)
\end{minted}

Compute the inverse hyperbolic cotangent of \texttt{x}. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L992-L994}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16625449660258120296}{} 
\hyperlink{16625449660258120296}{\texttt{Base.Math.sinc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sinc(x)
\end{minted}

Compute  \(\sin(\pi x) / (\pi x)\)  if  \(x \neq 0\) , and  \(1\)  if  \(x = 0\) .



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L935-L939}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16278225468798010360}{} 
\hyperlink{16278225468798010360}{\texttt{Base.Math.cosc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cosc(x)
\end{minted}

Compute  \(\cos(\pi x) / x - \sin(\pi x) / (\pi x^2)\)  if  \(x \neq 0\) , and  \(0\)  if  \(x = 0\) . This is the derivative of \texttt{sinc(x)}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L946-L951}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11016541033238436876}{} 
\hyperlink{11016541033238436876}{\texttt{Base.Math.deg2rad}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
deg2rad(x)
\end{minted}

Convert \texttt{x} from degrees to radians.

\textbf{Examples}


\begin{minted}{jlcon}
julia> deg2rad(90)
1.5707963267948966
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L232-L242}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17164560583584594903}{} 
\hyperlink{17164560583584594903}{\texttt{Base.Math.rad2deg}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rad2deg(x)
\end{minted}

Convert \texttt{x} from radians to degrees.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rad2deg(pi)
180.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L219-L229}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18304489571285447949}{} 
\hyperlink{18304489571285447949}{\texttt{Base.Math.hypot}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hypot(x, y)
\end{minted}

Compute the hypotenuse  \(\sqrt{|x|^2+|y|^2}\)  avoiding overflow and underflow.

This code is an implementation of the algorithm described in: An Improved Algorithm for \texttt{hypot(a,b)} by Carlos F. Borges The article is available online at ArXiv at the link   https://arxiv.org/abs/1904.09481

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = Int64(10)^10;

julia> hypot(a, a)
1.4142135623730951e10

julia> √(a^2 + a^2) # a^2 overflows
ERROR: DomainError with -2.914184810805068e18:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
[...]

julia> hypot(3, 4im)
5.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L585-L612}{\texttt{source}}



\begin{lstlisting}
hypot(x...)
\end{lstlisting}

Compute the hypotenuse  \(\sqrt{\sum |x_i|^2}\)  avoiding overflow and underflow.

\textbf{Examples}


\begin{minted}{jlcon}
julia> hypot(-5.7)
5.7

julia> hypot(3, 4im, 12.0)
13.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L675-L688}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17317607370922767936}{} 
\hyperlink{17317607370922767936}{\texttt{Base.log}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
log(x)
\end{minted}

Compute the natural logarithm of \texttt{x}. Throws \hyperlink{14085880504701688639}{\texttt{DomainError}} for negative \hyperlink{6175959395021454412}{\texttt{Real}} arguments. Use complex negative arguments to obtain complex results.

\textbf{Examples}


\begin{minted}{jlcon}
julia> log(2)
0.6931471805599453

julia> log(-3)
ERROR: DomainError with -3.0:
log will only return a complex result if called with a complex argument. Try log(Complex(x)).
Stacktrace:
 [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L456-L474}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10582107494419543982}{} 
\hyperlink{10582107494419543982}{\texttt{Base.log}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
log(b,x)
\end{minted}

Compute the base \texttt{b} logarithm of \texttt{x}. Throws \hyperlink{14085880504701688639}{\texttt{DomainError}} for negative \hyperlink{6175959395021454412}{\texttt{Real}} arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> log(4,8)
1.5

julia> log(4,2)
0.5

julia> log(-2, 3)
ERROR: DomainError with -2.0:
log will only return a complex result if called with a complex argument. Try log(Complex(x)).
Stacktrace:
 [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31
[...]

julia> log(2, -3)
ERROR: DomainError with -3.0:
log will only return a complex result if called with a complex argument. Try log(Complex(x)).
Stacktrace:
 [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31
[...]
\end{minted}

\begin{quote}
\textbf{Note}

If \texttt{b} is a power of 2 or 10, \hyperlink{18341149201477905713}{\texttt{log2}} or \hyperlink{3481560771470480868}{\texttt{log10}} should be used, as these will typically be faster and more accurate. For example,


\begin{minted}{jlcon}
julia> log(100,1000000)
2.9999999999999996

julia> log10(1000000)/2
3.0
\end{minted}

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L251-L291}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18341149201477905713}{} 
\hyperlink{18341149201477905713}{\texttt{Base.log2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
log2(x)
\end{minted}

Compute the logarithm of \texttt{x} to base 2. Throws \hyperlink{14085880504701688639}{\texttt{DomainError}} for negative \hyperlink{6175959395021454412}{\texttt{Real}} arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> log2(4)
2.0

julia> log2(10)
3.321928094887362

julia> log2(-2)
ERROR: DomainError with -2.0:
NaN result for non-NaN input.
Stacktrace:
 [1] nan_dom_err at ./math.jl:325 [inlined]
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L477-L498}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3481560771470480868}{} 
\hyperlink{3481560771470480868}{\texttt{Base.log10}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
log10(x)
\end{minted}

Compute the logarithm of \texttt{x} to base 10. Throws \hyperlink{14085880504701688639}{\texttt{DomainError}} for negative \hyperlink{6175959395021454412}{\texttt{Real}} arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> log10(100)
2.0

julia> log10(2)
0.3010299956639812

julia> log10(-2)
ERROR: DomainError with -2.0:
NaN result for non-NaN input.
Stacktrace:
 [1] nan_dom_err at ./math.jl:325 [inlined]
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L501-L522}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5533050447473188877}{} 
\hyperlink{5533050447473188877}{\texttt{Base.log1p}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
log1p(x)
\end{minted}

Accurate natural logarithm of \texttt{1+x}. Throws \hyperlink{14085880504701688639}{\texttt{DomainError}} for \hyperlink{6175959395021454412}{\texttt{Real}} arguments less than -1.

\textbf{Examples}


\begin{minted}{jlcon}
julia> log1p(-0.5)
-0.6931471805599453

julia> log1p(0)
0.0

julia> log1p(-2)
ERROR: DomainError with -2.0:
log1p will only return a complex result if called with a complex argument. Try log1p(Complex(x)).
Stacktrace:
 [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L525-L546}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12570003490345822061}{} 
\hyperlink{12570003490345822061}{\texttt{Base.Math.frexp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
frexp(val)
\end{minted}

Return \texttt{(x,exp)} such that \texttt{x} has a magnitude in the interval  \([1/2, 1)\)  or 0, and \texttt{val} is equal to  \(x \times 2^{exp}\) .



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L810-L815}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5801729597955756107}{} 
\hyperlink{5801729597955756107}{\texttt{Base.exp}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
exp(x)
\end{minted}

Compute the natural base exponential of \texttt{x}, in other words  \(e^x\) .

\textbf{Examples}


\begin{minted}{jlcon}
julia> exp(1.0)
2.718281828459045
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/exp.jl#L62-L72}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12542609616026627164}{} 
\hyperlink{12542609616026627164}{\texttt{Base.exp2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
exp2(x)
\end{minted}

Compute the base 2 exponential of \texttt{x}, in other words  \(2^x\) .

\textbf{Examples}


\begin{minted}{jlcon}
julia> exp2(5)
32.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L356-L366}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4510833300532946775}{} 
\hyperlink{4510833300532946775}{\texttt{Base.exp10}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
exp10(x)
\end{minted}

Compute the base 10 exponential of \texttt{x}, in other words  \(10^x\) .

\textbf{Examples}


\begin{minted}{jlcon}
julia> exp10(2)
100.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L369-L379}{\texttt{source}}



\begin{lstlisting}
exp10(x)
\end{lstlisting}

Compute  \(10^x\) .

\textbf{Examples}


\begin{minted}{jlcon}
julia> exp10(2)
100.0

julia> exp10(0.2)
1.5848931924611136
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/exp10.jl#L72-L85}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14721177606508229464}{} 
\hyperlink{14721177606508229464}{\texttt{Base.Math.ldexp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ldexp(x, n)
\end{minted}

Compute  \(x \times 2^n\) .

\textbf{Examples}


\begin{minted}{jlcon}
julia> ldexp(5., 2)
20.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L706-L716}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7336011242447784962}{} 
\hyperlink{7336011242447784962}{\texttt{Base.Math.modf}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
modf(x)
\end{minted}

Return a tuple \texttt{(fpart, ipart)} of the fractional and integral parts of a number. Both parts have the same sign as the argument.

\textbf{Examples}


\begin{minted}{jlcon}
julia> modf(3.5)
(0.5, 3.0)

julia> modf(-3.5)
(-0.5, -3.0)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L840-L854}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4939309737829480377}{} 
\hyperlink{4939309737829480377}{\texttt{Base.expm1}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
expm1(x)
\end{minted}

Accurately compute  \(e^x-1\) .



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L342-L346}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12930779325193350739}{} 
\hyperlink{12930779325193350739}{\texttt{Base.round}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
round([T,] x, [r::RoundingMode])
round(x, [r::RoundingMode]; digits::Integer=0, base = 10)
round(x, [r::RoundingMode]; sigdigits::Integer, base = 10)
\end{minted}

Rounds the number \texttt{x}.

Without keyword arguments, \texttt{x} is rounded to an integer value, returning a value of type \texttt{T}, or of the same type of \texttt{x} if no \texttt{T} is provided. An \hyperlink{5399118524830636312}{\texttt{InexactError}} will be thrown if the value is not representable by \texttt{T}, similar to \hyperlink{1846942650946171605}{\texttt{convert}}.

If the \texttt{digits} keyword argument is provided, it rounds to the specified number of digits after the decimal place (or before if negative), in base \texttt{base}.

If the \texttt{sigdigits} keyword argument is provided, it rounds to the specified number of significant digits, in base \texttt{base}.

The \hyperlink{16713322195952720212}{\texttt{RoundingMode}} \texttt{r} controls the direction of the rounding; the default is \hyperlink{868115654703135309}{\texttt{RoundNearest}}, which rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer. Note that \texttt{round} may give incorrect results if the global rounding mode is changed (see \hyperlink{6511778857518292792}{\texttt{rounding}}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> round(1.7)
2.0

julia> round(Int, 1.7)
2

julia> round(1.5)
2.0

julia> round(2.5)
2.0

julia> round(pi; digits=2)
3.14

julia> round(pi; digits=3, base=2)
3.125

julia> round(123.456; sigdigits=2)
120.0

julia> round(357.913; sigdigits=4, base=2)
352.0
\end{minted}

\begin{quote}
\textbf{Note}

Rounding to specified digits in bases other than 2 can be inexact when operating on binary floating point numbers. For example, the \hyperlink{5027751419500983000}{\texttt{Float64}} value represented by \texttt{1.15} is actually \emph{less} than 1.15, yet will be rounded to 1.2.

\chapter{Examples}


\begin{minted}{jlcon}
julia> x = 1.15
1.15

julia> @sprintf "%.20f" x
"1.14999999999999991118"

julia> x < 115//100
true

julia> round(x, digits=1)
1.2
\end{minted}

\end{quote}
\textbf{Extensions}

To extend \texttt{round} to new numeric types, it is typically sufficient to define \texttt{Base.round(x::NewType, r::RoundingMode)}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/floatfuncs.jl#L47-L120}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16713322195952720212}{} 
\hyperlink{16713322195952720212}{\texttt{Base.Rounding.RoundingMode}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RoundingMode
\end{minted}

A type used for controlling the rounding mode of floating point operations (via \hyperlink{6511778857518292792}{\texttt{rounding}}/\hyperlink{12025922235501343815}{\texttt{setrounding}} functions), or as optional arguments for rounding to the nearest integer (via the \hyperlink{12930779325193350739}{\texttt{round}} function).

Currently supported rounding modes are:

\begin{itemize}
\item \hyperlink{868115654703135309}{\texttt{RoundNearest}} (default)


\item \hyperlink{975776970636292472}{\texttt{RoundNearestTiesAway}}


\item \hyperlink{9147917195826641690}{\texttt{RoundNearestTiesUp}}


\item \hyperlink{7760059079134067537}{\texttt{RoundToZero}}


\item \hyperlink{9825765525550990700}{\texttt{RoundFromZero}} (\hyperlink{749816618809421837}{\texttt{BigFloat}} only)


\item \hyperlink{874246484265932239}{\texttt{RoundUp}}


\item \hyperlink{3648739763580508258}{\texttt{RoundDown}}

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L26-L43}{\texttt{source}}


\end{adjustwidth}
\hypertarget{868115654703135309}{} 
\hyperlink{868115654703135309}{\texttt{Base.Rounding.RoundNearest}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RoundNearest
\end{minted}

The default rounding mode. Rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L46-L51}{\texttt{source}}


\end{adjustwidth}
\hypertarget{975776970636292472}{} 
\hyperlink{975776970636292472}{\texttt{Base.Rounding.RoundNearestTiesAway}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RoundNearestTiesAway
\end{minted}

Rounds to nearest integer, with ties rounded away from zero (C/C++ \hyperlink{12930779325193350739}{\texttt{round}} behaviour).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L89-L94}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9147917195826641690}{} 
\hyperlink{9147917195826641690}{\texttt{Base.Rounding.RoundNearestTiesUp}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RoundNearestTiesUp
\end{minted}

Rounds to nearest integer, with ties rounded toward positive infinity (Java/JavaScript \hyperlink{12930779325193350739}{\texttt{round}} behaviour).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L97-L102}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7760059079134067537}{} 
\hyperlink{7760059079134067537}{\texttt{Base.Rounding.RoundToZero}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RoundToZero
\end{minted}

\hyperlink{12930779325193350739}{\texttt{round}} using this rounding mode is an alias for \hyperlink{1728363361565303194}{\texttt{trunc}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L54-L58}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9825765525550990700}{} 
\hyperlink{9825765525550990700}{\texttt{Base.Rounding.RoundFromZero}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RoundFromZero
\end{minted}

Rounds away from zero. This rounding mode may only be used with \texttt{T == BigFloat} inputs to \hyperlink{12930779325193350739}{\texttt{round}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> BigFloat("1.0000000000000001", 5, RoundFromZero)
1.06
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L75-L86}{\texttt{source}}


\end{adjustwidth}
\hypertarget{874246484265932239}{} 
\hyperlink{874246484265932239}{\texttt{Base.Rounding.RoundUp}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RoundUp
\end{minted}

\hyperlink{12930779325193350739}{\texttt{round}} using this rounding mode is an alias for \hyperlink{10519509038312853061}{\texttt{ceil}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L61-L65}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3648739763580508258}{} 
\hyperlink{3648739763580508258}{\texttt{Base.Rounding.RoundDown}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RoundDown
\end{minted}

\hyperlink{12930779325193350739}{\texttt{round}} using this rounding mode is an alias for \hyperlink{11115257331910840693}{\texttt{floor}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L68-L72}{\texttt{source}}


\end{adjustwidth}
\hypertarget{703325969015264809}{} 
\hyperlink{703325969015264809}{\texttt{Base.round}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
round(z::Complex[, RoundingModeReal, [RoundingModeImaginary]])
round(z::Complex[, RoundingModeReal, [RoundingModeImaginary]]; digits=, base=10)
round(z::Complex[, RoundingModeReal, [RoundingModeImaginary]]; sigdigits=, base=10)
\end{minted}

Return the nearest integral value of the same type as the complex-valued \texttt{z} to \texttt{z}, breaking ties using the specified \hyperlink{16713322195952720212}{\texttt{RoundingMode}}s. The first \hyperlink{16713322195952720212}{\texttt{RoundingMode}} is used for rounding the real components while the second is used for rounding the imaginary components.

\textbf{Example}


\begin{minted}{jlcon}
julia> round(3.14 + 4.5im)
3.0 + 4.0im
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/complex.jl#L993-L1008}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10519509038312853061}{} 
\hyperlink{10519509038312853061}{\texttt{Base.ceil}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ceil([T,] x)
ceil(x; digits::Integer= [, base = 10])
ceil(x; sigdigits::Integer= [, base = 10])
\end{minted}

\texttt{ceil(x)} returns the nearest integral value of the same type as \texttt{x} that is greater than or equal to \texttt{x}.

\texttt{ceil(T, x)} converts the result to type \texttt{T}, throwing an \texttt{InexactError} if the value is not representable.

\texttt{digits}, \texttt{sigdigits} and \texttt{base} work as for \hyperlink{12930779325193350739}{\texttt{round}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L516-L528}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11115257331910840693}{} 
\hyperlink{11115257331910840693}{\texttt{Base.floor}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
floor([T,] x)
floor(x; digits::Integer= [, base = 10])
floor(x; sigdigits::Integer= [, base = 10])
\end{minted}

\texttt{floor(x)} returns the nearest integral value of the same type as \texttt{x} that is less than or equal to \texttt{x}.

\texttt{floor(T, x)} converts the result to type \texttt{T}, throwing an \texttt{InexactError} if the value is not representable.

\texttt{digits}, \texttt{sigdigits} and \texttt{base} work as for \hyperlink{12930779325193350739}{\texttt{round}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L501-L513}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1728363361565303194}{} 
\hyperlink{1728363361565303194}{\texttt{Base.trunc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trunc([T,] x)
trunc(x; digits::Integer= [, base = 10])
trunc(x; sigdigits::Integer= [, base = 10])
\end{minted}

\texttt{trunc(x)} returns the nearest integral value of the same type as \texttt{x} whose absolute value is less than or equal to \texttt{x}.

\texttt{trunc(T, x)} converts the result to type \texttt{T}, throwing an \texttt{InexactError} if the value is not representable.

\texttt{digits}, \texttt{sigdigits} and \texttt{base} work as for \hyperlink{12930779325193350739}{\texttt{round}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L486-L498}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6382984648980626356}{} 
\hyperlink{6382984648980626356}{\texttt{Base.unsafe\_trunc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unsafe_trunc(T, x)
\end{minted}

Return the nearest integral value of type \texttt{T} whose absolute value is less than or equal to \texttt{x}. If the value is not representable by \texttt{T}, an arbitrary value will be returned.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L297-L303}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7458766354532817148}{} 
\hyperlink{7458766354532817148}{\texttt{Base.min}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
min(x, y, ...)
\end{minted}

Return the minimum of the arguments. See also the \hyperlink{13126064576294034099}{\texttt{minimum}} function to take the minimum element from a collection.

\textbf{Examples}


\begin{minted}{jlcon}
julia> min(2, 5, 1)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L410-L421}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7839419811914289844}{} 
\hyperlink{7839419811914289844}{\texttt{Base.max}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
max(x, y, ...)
\end{minted}

Return the maximum of the arguments. See also the \hyperlink{14719513931696680717}{\texttt{maximum}} function to take the maximum element from a collection.

\textbf{Examples}


\begin{minted}{jlcon}
julia> max(2, 5, 1)
5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L396-L407}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9004904914922806611}{} 
\hyperlink{9004904914922806611}{\texttt{Base.minmax}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
minmax(x, y)
\end{minted}

Return \texttt{(min(x,y), max(x,y))}. See also: \hyperlink{5171681020038097298}{\texttt{extrema}} that returns \texttt{(minimum(x), maximum(x))}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> minmax('c','b')
('b', 'c')
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L424-L434}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2549437629093220350}{} 
\hyperlink{2549437629093220350}{\texttt{Base.Math.clamp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
clamp(x, lo, hi)
\end{minted}

Return \texttt{x} if \texttt{lo <= x <= hi}. If \texttt{x > hi}, return \texttt{hi}. If \texttt{x < lo}, return \texttt{lo}. Arguments are promoted to a common type.

\textbf{Examples}


\begin{minted}{jlcon}
julia> clamp.([pi, 1.0, big(10.)], 2., 9.)
3-element Array{BigFloat,1}:
 3.141592653589793238462643383279502884197169399375105820974944592307816406286198
 2.0
 9.0

julia> clamp.([11,8,5],10,6) # an example where lo > hi
3-element Array{Int64,1}:
  6
  6
 10
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L44-L64}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15974741233540534893}{} 
\hyperlink{15974741233540534893}{\texttt{Base.Math.clamp!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
clamp!(array::AbstractArray, lo, hi)
\end{minted}

Restrict values in \texttt{array} to the specified range, in-place. See also \hyperlink{2549437629093220350}{\texttt{clamp}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L71-L76}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9614495866226399167}{} 
\hyperlink{9614495866226399167}{\texttt{Base.abs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
abs(x)
\end{minted}

The absolute value of \texttt{x}.

When \texttt{abs} is applied to signed integers, overflow may occur, resulting in the return of a negative value. This overflow occurs only when \texttt{abs} is applied to the minimum representable value of a signed integer. That is, when \texttt{x == typemin(typeof(x))}, \texttt{abs(x) == x < 0}, not \texttt{-x} as might be expected.

\textbf{Examples}


\begin{minted}{jlcon}
julia> abs(-3)
3

julia> abs(1 + im)
1.4142135623730951

julia> abs(typemin(Int64))
-9223372036854775808
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L110-L132}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10885135672778604809}{} 
\hyperlink{10885135672778604809}{\texttt{Base.Checked.checked\_abs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.checked_abs(x)
\end{minted}

Calculates \texttt{abs(x)}, checking for overflow errors where applicable. For example, standard two{\textquotesingle}s complement signed integers (e.g. \texttt{Int}) cannot represent \texttt{abs(typemin(Int))}, thus leading to an overflow.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L105-L113}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13229568824844995103}{} 
\hyperlink{13229568824844995103}{\texttt{Base.Checked.checked\_neg}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.checked_neg(x)
\end{minted}

Calculates \texttt{-x}, checking for overflow errors where applicable. For example, standard two{\textquotesingle}s complement signed integers (e.g. \texttt{Int}) cannot represent \texttt{-typemin(Int)}, thus leading to an overflow.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L77-L85}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2964592337942314373}{} 
\hyperlink{2964592337942314373}{\texttt{Base.Checked.checked\_add}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.checked_add(x, y)
\end{minted}

Calculates \texttt{x+y}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L156-L162}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10268341695343039853}{} 
\hyperlink{10268341695343039853}{\texttt{Base.Checked.checked\_sub}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.checked_sub(x, y)
\end{minted}

Calculates \texttt{x-y}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L213-L219}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4390963153143215118}{} 
\hyperlink{4390963153143215118}{\texttt{Base.Checked.checked\_mul}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.checked_mul(x, y)
\end{minted}

Calculates \texttt{x*y}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L278-L284}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6689390039928836022}{} 
\hyperlink{6689390039928836022}{\texttt{Base.Checked.checked\_div}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.checked_div(x, y)
\end{minted}

Calculates \texttt{div(x,y)}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L307-L313}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12129844323919398781}{} 
\hyperlink{12129844323919398781}{\texttt{Base.Checked.checked\_rem}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.checked_rem(x, y)
\end{minted}

Calculates \texttt{x\%y}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L316-L322}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3745431966407804814}{} 
\hyperlink{3745431966407804814}{\texttt{Base.Checked.checked\_fld}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.checked_fld(x, y)
\end{minted}

Calculates \texttt{fld(x,y)}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L325-L331}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2512435134040972090}{} 
\hyperlink{2512435134040972090}{\texttt{Base.Checked.checked\_mod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.checked_mod(x, y)
\end{minted}

Calculates \texttt{mod(x,y)}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L334-L340}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1863194407625991652}{} 
\hyperlink{1863194407625991652}{\texttt{Base.Checked.checked\_cld}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.checked_cld(x, y)
\end{minted}

Calculates \texttt{cld(x,y)}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L343-L349}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8862869478194651358}{} 
\hyperlink{8862869478194651358}{\texttt{Base.Checked.add\_with\_overflow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.add_with_overflow(x, y) -> (r, f)
\end{minted}

Calculates \texttt{r = x+y}, with the flag \texttt{f} indicating whether overflow has occurred.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L126-L130}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2951243344761333492}{} 
\hyperlink{2951243344761333492}{\texttt{Base.Checked.sub\_with\_overflow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.sub_with_overflow(x, y) -> (r, f)
\end{minted}

Calculates \texttt{r = x-y}, with the flag \texttt{f} indicating whether overflow has occurred.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L188-L192}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9052860252825488939}{} 
\hyperlink{9052860252825488939}{\texttt{Base.Checked.mul\_with\_overflow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.mul_with_overflow(x, y) -> (r, f)
\end{minted}

Calculates \texttt{r = x*y}, with the flag \texttt{f} indicating whether overflow has occurred.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L228-L232}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15686257922156163743}{} 
\hyperlink{15686257922156163743}{\texttt{Base.abs2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
abs2(x)
\end{minted}

Squared absolute value of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> abs2(-3)
9
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L122-L132}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6024566200716053110}{} 
\hyperlink{6024566200716053110}{\texttt{Base.copysign}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
copysign(x, y) -> z
\end{minted}

Return \texttt{z} which has the magnitude of \texttt{x} and the same sign as \texttt{y}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> copysign(1, -2)
-1

julia> copysign(-1, 2)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L151-L164}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14349105033929355161}{} 
\hyperlink{14349105033929355161}{\texttt{Base.sign}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sign(x)
\end{minted}

Return zero if \texttt{x==0} and  \(x/|x|\)  otherwise (i.e., ±1 for real \texttt{x}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L112-L116}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9457038569823603490}{} 
\hyperlink{9457038569823603490}{\texttt{Base.signbit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
signbit(x)
\end{minted}

Returns \texttt{true} if the value of the sign of \texttt{x} is negative, otherwise \texttt{false}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> signbit(-4)
true

julia> signbit(5)
false

julia> signbit(5.5)
false

julia> signbit(-4.1)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L90-L109}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2689022981470151558}{} 
\hyperlink{2689022981470151558}{\texttt{Base.flipsign}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
flipsign(x, y)
\end{minted}

Return \texttt{x} with its sign flipped if \texttt{y} is negative. For example \texttt{abs(x) = flipsign(x,x)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> flipsign(5, 3)
5

julia> flipsign(5, -3)
-5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L135-L148}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4551113327515323898}{} 
\hyperlink{4551113327515323898}{\texttt{Base.sqrt}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sqrt(x)
\end{minted}

Return  \(\sqrt{x}\) . Throws \hyperlink{14085880504701688639}{\texttt{DomainError}} for negative \hyperlink{6175959395021454412}{\texttt{Real}} arguments. Use complex negative arguments instead. The prefix operator \texttt{√} is equivalent to \texttt{sqrt}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sqrt(big(81))
9.0

julia> sqrt(big(-81))
ERROR: DomainError with -81.0:
NaN result for non-NaN input.
Stacktrace:
 [1] sqrt(::BigFloat) at ./mpfr.jl:501
[...]

julia> sqrt(big(complex(-81)))
0.0 + 9.0im
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L561-L582}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13061326033497045577}{} 
\hyperlink{13061326033497045577}{\texttt{Base.isqrt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isqrt(n::Integer)
\end{minted}

Integer square root: the largest integer \texttt{m} such that \texttt{m*m <= n}.


\begin{minted}{jlcon}
julia> isqrt(5)
2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L806-L815}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15104025502404840355}{} 
\hyperlink{15104025502404840355}{\texttt{Base.Math.cbrt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cbrt(x::Real)
\end{minted}

Return the cube root of \texttt{x}, i.e.  \(x^{1/3}\) . Negative values are accepted (returning the negative real root when  \(x < 0\) ).

The prefix operator \texttt{∛} is equivalent to \texttt{cbrt}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> cbrt(big(27))
3.0

julia> cbrt(big(-27))
-3.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/cbrt.jl#L17-L33}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10579540000886584250}{} 
\hyperlink{10579540000886584250}{\texttt{Base.real}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
real(z)
\end{minted}

Return the real part of the complex number \texttt{z}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> real(1 + 3im)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/complex.jl#L52-L62}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13331686588901351068}{} 
\hyperlink{13331686588901351068}{\texttt{Base.imag}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
imag(z)
\end{minted}

Return the imaginary part of the complex number \texttt{z}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> imag(1 + 3im)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/complex.jl#L65-L75}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4559968878634602058}{} 
\hyperlink{4559968878634602058}{\texttt{Base.reim}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reim(z)
\end{minted}

Return both the real and imaginary parts of the complex number \texttt{z}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> reim(1 + 3im)
(1, 3)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/complex.jl#L80-L90}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9940023991150673697}{} 
\hyperlink{9940023991150673697}{\texttt{Base.conj}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
conj(z)
\end{minted}

Compute the complex conjugate of a complex number \texttt{z}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> conj(1 + 3im)
1 - 3im
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/complex.jl#L252-L262}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9465547375318501186}{} 
\hyperlink{9465547375318501186}{\texttt{Base.angle}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
angle(z)
\end{minted}

Compute the phase angle in radians of a complex number \texttt{z}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rad2deg(angle(1 + im))
45.0

julia> rad2deg(angle(1 - im))
-45.0

julia> rad2deg(angle(-1 - im))
-135.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/complex.jl#L544-L560}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4687572676090761946}{} 
\hyperlink{4687572676090761946}{\texttt{Base.cis}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cis(z)
\end{minted}

Return  \(\exp(iz)\) .

\textbf{Examples}


\begin{minted}{jlcon}
julia> cis(π) ≈ -1
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/complex.jl#L527-L537}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7127784108654808529}{} 
\hyperlink{7127784108654808529}{\texttt{Base.binomial}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
binomial(n::Integer, k::Integer)
\end{minted}

The \emph{binomial coefficient}  \(\binom{n}{k}\) , being the coefficient of the  \(k\) th term in the polynomial expansion of  \((1+x)^n\) .

If  \(n\)  is non-negative, then it is the number of ways to choose \texttt{k} out of \texttt{n} items:

\begin{equation*}
\begin{split}\binom{n}{k} = \frac{n!}{k! (n-k)!}\end{split}\end{equation*}
where  \(n!\)  is the \hyperlink{1793920701415589315}{\texttt{factorial}} function.

If  \(n\)  is negative, then it is defined in terms of the identity

\begin{equation*}
\begin{split}\binom{n}{k} = (-1)^k \binom{k-n-1}{k}\end{split}\end{equation*}
\textbf{Examples}


\begin{minted}{jlcon}
julia> binomial(5, 3)
10

julia> factorial(5) ÷ (factorial(5-3) * factorial(3))
10

julia> binomial(-5, 3)
-35
\end{minted}

\textbf{See also}

\begin{itemize}
\item \hyperlink{1793920701415589315}{\texttt{factorial}}

\end{itemize}
\textbf{External links}

\begin{itemize}
\item \href{https://en.wikipedia.org/wiki/Binomial\_coefficient}{Binomial coeffient} on Wikipedia.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L863-L897}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1793920701415589315}{} 
\hyperlink{1793920701415589315}{\texttt{Base.factorial}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
factorial(n::Integer)
\end{minted}

Factorial of \texttt{n}. If \texttt{n} is an \hyperlink{8469131683393450448}{\texttt{Integer}}, the factorial is computed as an integer (promoted to at least 64 bits). Note that this may overflow if \texttt{n} is not small, but you can use \texttt{factorial(big(n))} to compute the result exactly in arbitrary precision.

\textbf{Examples}


\begin{minted}{jlcon}
julia> factorial(6)
720

julia> factorial(21)
ERROR: OverflowError: 21 is too large to look up in the table; consider using `factorial(big(21))` instead
Stacktrace:
[...]

julia> factorial(big(21))
51090942171709440000
\end{minted}

\textbf{See also}

\begin{itemize}
\item \hyperlink{7127784108654808529}{\texttt{binomial}}

\end{itemize}
\textbf{External links}

\begin{itemize}
\item \href{https://en.wikipedia.org/wiki/Factorial}{Factorial} on Wikipedia.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L827-L853}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15906911311436241979}{} 
\hyperlink{15906911311436241979}{\texttt{Base.gcd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gcd(x,y)
\end{minted}

Greatest common (positive) divisor (or zero if \texttt{x} and \texttt{y} are both zero). The arguments may be integer and rational numbers.

\begin{quote}
\textbf{Julia 1.4}

Rational arguments require Julia 1.4 or later.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> gcd(6,9)
3

julia> gcd(6,-9)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L5-L22}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12975400110924105221}{} 
\hyperlink{12975400110924105221}{\texttt{Base.lcm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lcm(x,y)
\end{minted}

Least common (non-negative) multiple. The arguments may be integer and rational numbers.

\begin{quote}
\textbf{Julia 1.4}

Rational arguments require Julia 1.4 or later.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> lcm(2,3)
6

julia> lcm(-2,3)
6
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L56-L73}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18359524628605105681}{} 
\hyperlink{18359524628605105681}{\texttt{Base.gcdx}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gcdx(x,y)
\end{minted}

Computes the greatest common (positive) divisor of \texttt{x} and \texttt{y} and their Bézout coefficients, i.e. the integer coefficients \texttt{u} and \texttt{v} that satisfy  \(ux+vy = d = gcd(x,y)\) .  \(gcdx(x,y)\)  returns  \((d,u,v)\) .

The arguments may be integer and rational numbers.

\begin{quote}
\textbf{Julia 1.4}

Rational arguments require Julia 1.4 or later.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> gcdx(12, 42)
(6, -3, 1)

julia> gcdx(240, 46)
(2, -9, 47)
\end{minted}

\begin{quote}
\textbf{Note}

Bézout coefficients are \emph{not} uniquely defined. \texttt{gcdx} returns the minimal Bézout coefficients that are computed by the extended Euclidean algorithm. (Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.) For signed integers, these coefficients \texttt{u} and \texttt{v} are minimal in the sense that  \(|u| < |y/d|\)  and  \(|v| < |x/d|\) . Furthermore, the signs of \texttt{u} and \texttt{v} are chosen so that \texttt{d} is positive. For unsigned integers, the coefficients \texttt{u} and \texttt{v} might be near their \texttt{typemax}, and the identity then holds only via the unsigned integers{\textquotesingle} modulo arithmetic.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L107-L138}{\texttt{source}}


\end{adjustwidth}
\hypertarget{598817088840034027}{} 
\hyperlink{598817088840034027}{\texttt{Base.ispow2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ispow2(n::Integer) -> Bool
\end{minted}

Test whether \texttt{n} is a power of two.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ispow2(4)
true

julia> ispow2(5)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L335-L348}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14955572944376366290}{} 
\hyperlink{14955572944376366290}{\texttt{Base.nextpow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nextpow(a, x)
\end{minted}

The smallest \texttt{a{\textasciicircum}n} not less than \texttt{x}, where \texttt{n} is a non-negative integer. \texttt{a} must be greater than 1, and \texttt{x} must be greater than 0.

\textbf{Examples}


\begin{minted}{jlcon}
julia> nextpow(2, 7)
8

julia> nextpow(2, 9)
16

julia> nextpow(5, 20)
25

julia> nextpow(4, 16)
16
\end{minted}

See also \hyperlink{488025580584649031}{\texttt{prevpow}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L351-L373}{\texttt{source}}


\end{adjustwidth}
\hypertarget{488025580584649031}{} 
\hyperlink{488025580584649031}{\texttt{Base.prevpow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
prevpow(a, x)
\end{minted}

The largest \texttt{a{\textasciicircum}n} not greater than \texttt{x}, where \texttt{n} is a non-negative integer. \texttt{a} must be greater than 1, and \texttt{x} must not be less than 1.

\textbf{Examples}


\begin{minted}{jlcon}
julia> prevpow(2, 7)
4

julia> prevpow(2, 9)
8

julia> prevpow(5, 20)
5

julia> prevpow(4, 16)
16
\end{minted}

See also \hyperlink{14955572944376366290}{\texttt{nextpow}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L388-L409}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9591900175500358341}{} 
\hyperlink{9591900175500358341}{\texttt{Base.nextprod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nextprod([k_1, k_2,...], n)
\end{minted}

Next integer greater than or equal to \texttt{n} that can be written as  \(\prod k_i^{p_i}\)  for integers  \(p_1\) ,  \(p_2\) , etc.

\textbf{Examples}


\begin{minted}{jlcon}
julia> nextprod([2, 3], 105)
108

julia> 2^2 * 3^3
108
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/combinatorics.jl#L248-L262}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17191792848451148355}{} 
\hyperlink{17191792848451148355}{\texttt{Base.invmod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
invmod(x,m)
\end{minted}

Take the inverse of \texttt{x} modulo \texttt{m}: \texttt{y} such that  \(x y = 1 \pmod m\) , with  \(div(x,y) = 0\) . This is undefined for  \(m = 0\) , or if  \(gcd(x,m) \neq 1\) .

\textbf{Examples}


\begin{minted}{jlcon}
julia> invmod(2,5)
3

julia> invmod(2,3)
2

julia> invmod(5,6)
5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L157-L175}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5886563157147453257}{} 
\hyperlink{5886563157147453257}{\texttt{Base.powermod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
powermod(x::Integer, p::Integer, m)
\end{minted}

Compute  \(x^p \pmod m\) .

\textbf{Examples}


\begin{minted}{jlcon}
julia> powermod(2, 6, 5)
4

julia> mod(2^6, 5)
4

julia> powermod(5, 2, 20)
5

julia> powermod(5, 2, 19)
6

julia> powermod(5, 3, 19)
11
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L284-L306}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7415013084438358060}{} 
\hyperlink{7415013084438358060}{\texttt{Base.ndigits}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ndigits(n::Integer; base::Integer=10, pad::Integer=1)
\end{minted}

Compute the number of digits in integer \texttt{n} written in base \texttt{base} (\texttt{base} must not be in \texttt{[-1, 0, 1]}), optionally padded with zeros to a specified size (the result will never be less than \texttt{pad}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> ndigits(12345)
5

julia> ndigits(1022, base=16)
3

julia> string(1022, base=16)
"3fe"

julia> ndigits(123, pad=5)
5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L543-L564}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4564031682097452426}{} 
\hyperlink{4564031682097452426}{\texttt{Base.widemul}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
widemul(x, y)
\end{minted}

Multiply \texttt{x} and \texttt{y}, giving the result as a larger type.

\textbf{Examples}


\begin{minted}{jlcon}
julia> widemul(Float32(3.), 4.)
12.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L202-L212}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8357888339204308169}{} 
\hyperlink{8357888339204308169}{\texttt{Base.Math.evalpoly}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
evalpoly(x, p)
\end{minted}

Evaluate the polynomial  \(\sum_k p[k] x^{k-1}\)  for the coefficients \texttt{p[1]}, \texttt{p[2]}, ...; that is, the coefficients are given in ascending order by power of \texttt{x}. Loops are unrolled at compile time if the number of coefficients is statically known, i.e. when \texttt{p} is a \texttt{Tuple}. This function generates efficient code using Horner{\textquotesingle}s method if \texttt{x} is real, or using a Goertzel-like \footnotemark[1] algorithm if \texttt{x} is complex.

\footnotetext[1]{Donald Knuth, Art of Computer Programming, Volume 2: Seminumerical Algorithms, Sec. 4.6.4.

}
\begin{quote}
\textbf{Julia 1.4}

This function requires Julia 1.4 or later.

\end{quote}
\textbf{Example}


\begin{minted}{jlcon}
julia> evalpoly(2, (1, 2, 3))
17
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L85-L105}{\texttt{source}}


\end{adjustwidth}
\hypertarget{552638784001429566}{} 
\hyperlink{552638784001429566}{\texttt{Base.Math.@evalpoly}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@evalpoly(z, c...)
\end{minted}

Evaluate the polynomial  \(\sum_k c[k] z^{k-1}\)  for the coefficients \texttt{c[1]}, \texttt{c[2]}, ...; that is, the coefficients are given in ascending order by power of \texttt{z}.  This macro expands to efficient inline code that uses either Horner{\textquotesingle}s method or, for complex \texttt{z}, a more efficient Goertzel-like algorithm.

\textbf{Examples}


\begin{minted}{jlcon}
julia> @evalpoly(3, 1, 0, 1)
10

julia> @evalpoly(2, 1, 0, 1)
5

julia> @evalpoly(2, 1, 1, 1)
7
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L194-L213}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8577961464469068114}{} 
\hyperlink{8577961464469068114}{\texttt{Base.FastMath.@fastmath}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@fastmath expr
\end{minted}

Execute a transformed version of the expression, which calls functions that may violate strict IEEE semantics. This allows the fastest possible operation, but results are undefined – be careful when doing this, as it may change numerical results.

This sets the \href{http://llvm.org/docs/LangRef.html\#fast-math-flags}{LLVM Fast-Math flags}, and corresponds to the \texttt{-ffast-math} option in clang. See \hyperlink{2666116597324353353}{the notes on performance annotations} for more details.

\textbf{Examples}


\begin{minted}{jlcon}
julia> @fastmath 1+2
3

julia> @fastmath(sin(3))
0.1411200080598672
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/fastmath.jl#L129-L149}{\texttt{source}}


\end{adjustwidth}

\hypertarget{15678902192626228911}{}


\section{Customizable binary operators}



Some unicode characters can be used to define new binary operators that support infix notation. For example \texttt{⊗(x,y) = kron(x,y)} defines the \texttt{⊗} (otimes) function to be the Kronecker product, and one can call it as binary operator using infix syntax: \texttt{C = A ⊗ B} as well as with the usual prefix syntax \texttt{C = ⊗(A,B)}.



Other characters that support such extensions include {\textbackslash}odot \texttt{⊙} and {\textbackslash}oplus \texttt{⊕}



The complete list is in the parser code: https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm



Those that are parsed like \texttt{*} (in terms of precedence) include \texttt{* / ÷ \% \& ⋅ ∘ × |{\textbackslash}{\textbackslash}| ∩ ∧ ⊗ ⊘ ⊙ ⊚ ⊛ ⊠ ⊡ ⊓ ∗ ∙ ∤ ⅋ ≀ ⊼ ⋄ ⋆ ⋇ ⋉ ⋊ ⋋ ⋌ ⋏ ⋒ ⟑ ⦸ ⦼ ⦾ ⦿ ⧶ ⧷ ⨇ ⨰ ⨱ ⨲ ⨳ ⨴ ⨵ ⨶ ⨷ ⨸ ⨻ ⨼ ⨽ ⩀ ⩃ ⩄ ⩋ ⩍ ⩎ ⩑ ⩓ ⩕ ⩘ ⩚ ⩜ ⩞ ⩟ ⩠ ⫛ ⊍ ▷ ⨝ ⟕ ⟖ ⟗} and those that are parsed like \texttt{+} include \texttt{+ - |{\textbackslash}|| ⊕ ⊖ ⊞ ⊟ |++| ∪ ∨ ⊔ ± ∓ ∔ ∸ ≏ ⊎ \unicodeveebar{} ⊽ ⋎ ⋓ ⧺ ⧻ ⨈ ⨢ ⨣ ⨤ ⨥ ⨦ ⨧ ⨨ ⨩ ⨪ ⨫ ⨬ ⨭ ⨮ ⨹ ⨺ ⩁ ⩂ ⩅ ⩊ ⩌ ⩏ ⩐ ⩒ ⩔ ⩖ ⩗ ⩛ ⩝ ⩡ ⩢ ⩣} There are many others that are related to arrows, comparisons, and powers.



\hypertarget{856545484690558276}{}


\chapter{Numbers}



\hypertarget{9397501928806461980}{}


\section{标准数值类型}



\hypertarget{1351792297266187673}{}


\subsection{抽象数值类型}


\hypertarget{1990584313715697055}{} 
\hyperlink{1990584313715697055}{\texttt{Core.Number}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Number
\end{minted}

Abstract supertype for all number types.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1458-L1462}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6175959395021454412}{} 
\hyperlink{6175959395021454412}{\texttt{Core.Real}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Real <: Number
\end{minted}

Abstract supertype for all real numbers.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1465-L1469}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11465394427882483091}{} 
\hyperlink{11465394427882483091}{\texttt{Core.AbstractFloat}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractFloat <: Real
\end{minted}

Abstract supertype for all floating point numbers.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1472-L1476}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8469131683393450448}{} 
\hyperlink{8469131683393450448}{\texttt{Core.Integer}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Integer <: Real
\end{minted}

Abstract supertype for all integers.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1479-L1483}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14154866400772377486}{} 
\hyperlink{14154866400772377486}{\texttt{Core.Signed}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Signed <: Integer
\end{minted}

Abstract supertype for all signed integers.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1486-L1490}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4780971278803506664}{} 
\hyperlink{4780971278803506664}{\texttt{Core.Unsigned}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Unsigned <: Integer
\end{minted}

Abstract supertype for all unsigned integers.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1493-L1497}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1075257529074867746}{} 
\hyperlink{1075257529074867746}{\texttt{Base.AbstractIrrational}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractIrrational <: Real
\end{minted}

Number type representing an exact irrational value.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/irrationals.jl#L5-L9}{\texttt{source}}


\end{adjustwidth}

\hypertarget{12287781227840134308}{}


\subsection{具象数值类型}


\hypertarget{2727296760866702904}{} 
\hyperlink{2727296760866702904}{\texttt{Core.Float16}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Float16 <: AbstractFloat
\end{minted}

16-bit floating point number type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1527-L1531}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8101639384272933082}{} 
\hyperlink{8101639384272933082}{\texttt{Core.Float32}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Float32 <: AbstractFloat
\end{minted}

32-bit floating point number type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1527-L1531}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5027751419500983000}{} 
\hyperlink{5027751419500983000}{\texttt{Core.Float64}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Float64 <: AbstractFloat
\end{minted}

64-bit floating point number type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1527-L1531}{\texttt{source}}


\end{adjustwidth}
\hypertarget{749816618809421837}{} 
\hyperlink{749816618809421837}{\texttt{Base.MPFR.BigFloat}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
BigFloat <: AbstractFloat
\end{minted}

Arbitrary precision floating point number type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/mpfr.jl#L86-L90}{\texttt{source}}


\end{adjustwidth}
\hypertarget{46725311238864537}{} 
\hyperlink{46725311238864537}{\texttt{Core.Bool}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Bool <: Integer
\end{minted}

Boolean type, containing the values \texttt{true} and \texttt{false}.

\texttt{Bool} is a kind of number: \texttt{false} is numerically equal to \texttt{0} and \texttt{true} is numerically equal to \texttt{1}. Moreover, \texttt{false} acts as a multiplicative {\textquotedbl}strong zero{\textquotedbl}:


\begin{minted}{jlcon}
julia> false == 0
true

julia> true == 1
true

julia> 0 * NaN
NaN

julia> false * NaN
0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1500-L1522}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5857518405103968275}{} 
\hyperlink{5857518405103968275}{\texttt{Core.Int8}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Int8 <: Signed
\end{minted}

8-bit signed integer type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1538-L1542}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6609065134969660118}{} 
\hyperlink{6609065134969660118}{\texttt{Core.UInt8}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UInt8 <: Unsigned
\end{minted}

8-bit unsigned integer type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1545-L1549}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6667287249103968645}{} 
\hyperlink{6667287249103968645}{\texttt{Core.Int16}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Int16 <: Signed
\end{minted}

16-bit signed integer type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1538-L1542}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7018610346698168012}{} 
\hyperlink{7018610346698168012}{\texttt{Core.UInt16}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UInt16 <: Unsigned
\end{minted}

16-bit unsigned integer type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1545-L1549}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10103694114785108551}{} 
\hyperlink{10103694114785108551}{\texttt{Core.Int32}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Int32 <: Signed
\end{minted}

32-bit signed integer type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1538-L1542}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8690996847580776341}{} 
\hyperlink{8690996847580776341}{\texttt{Core.UInt32}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UInt32 <: Unsigned
\end{minted}

32-bit unsigned integer type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1545-L1549}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7720564657383125058}{} 
\hyperlink{7720564657383125058}{\texttt{Core.Int64}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Int64 <: Signed
\end{minted}

64-bit signed integer type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1538-L1542}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5500998675195555601}{} 
\hyperlink{5500998675195555601}{\texttt{Core.UInt64}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UInt64 <: Unsigned
\end{minted}

64-bit unsigned integer type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1545-L1549}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8012327724714767060}{} 
\hyperlink{8012327724714767060}{\texttt{Core.Int128}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Int128 <: Signed
\end{minted}

128-bit signed integer type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1538-L1542}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14811222188335428522}{} 
\hyperlink{14811222188335428522}{\texttt{Core.UInt128}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UInt128 <: Unsigned
\end{minted}

128-bit unsigned integer type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1545-L1549}{\texttt{source}}


\end{adjustwidth}
\hypertarget{423405808990690832}{} 
\hyperlink{423405808990690832}{\texttt{Base.GMP.BigInt}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
BigInt <: Signed
\end{minted}

Arbitrary precision integer type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/gmp.jl#L45-L49}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11302502367029942782}{} 
\hyperlink{11302502367029942782}{\texttt{Base.Complex}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Complex{T<:Real} <: Number
\end{minted}

Complex number type with real and imaginary part of type \texttt{T}.

\texttt{ComplexF16}, \texttt{ComplexF32} and \texttt{ComplexF64} are aliases for \texttt{Complex\{Float16\}}, \texttt{Complex\{Float32\}} and \texttt{Complex\{Float64\}} respectively.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/complex.jl#L3-L10}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8304566144531167610}{} 
\hyperlink{8304566144531167610}{\texttt{Base.Rational}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Rational{T<:Integer} <: Real
\end{minted}

Rational number type, with numerator and denominator of type \texttt{T}. Rationals are checked for overflow.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rational.jl#L3-L8}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5993828909973077529}{} 
\hyperlink{5993828909973077529}{\texttt{Base.Irrational}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Irrational{sym} <: AbstractIrrational
\end{minted}

Number type representing an exact irrational value denoted by the symbol \texttt{sym}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/irrationals.jl#L12-L17}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14469209681538830551}{}


\section{数据格式}


\hypertarget{17983913084963570964}{} 
\hyperlink{17983913084963570964}{\texttt{Base.digits}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
digits([T<:Integer], n::Integer; base::T = 10, pad::Integer = 1)
\end{minted}

Return an array with element type \texttt{T} (default \texttt{Int}) of the digits of \texttt{n} in the given base, optionally padded with zeros to a specified size. More significant digits are at higher indices, such that \texttt{n == sum([digits[k]*base{\textasciicircum}(k-1) for k=1:length(digits)])}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> digits(10, base = 10)
2-element Array{Int64,1}:
 0
 1

julia> digits(10, base = 2)
4-element Array{Int64,1}:
 0
 1
 0
 1

julia> digits(10, base = 2, pad = 6)
6-element Array{Int64,1}:
 0
 1
 0
 1
 0
 0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L700-L730}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18145156230339025572}{} 
\hyperlink{18145156230339025572}{\texttt{Base.digits!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
digits!(array, n::Integer; base::Integer = 10)
\end{minted}

Fills an array of the digits of \texttt{n} in the given base. More significant digits are at higher indices. If the array length is insufficient, the least significant digits are filled up to the array length. If the array length is excessive, the excess portion is filled with zeros.

\textbf{Examples}


\begin{minted}{jlcon}
julia> digits!([2,2,2,2], 10, base = 2)
4-element Array{Int64,1}:
 0
 1
 0
 1

julia> digits!([2,2,2,2,2,2], 10, base = 2)
6-element Array{Int64,1}:
 0
 1
 0
 1
 0
 0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L746-L771}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9171163989026657457}{} 
\hyperlink{9171163989026657457}{\texttt{Base.bitstring}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
bitstring(n)
\end{minted}

A string giving the literal bit representation of a number.

\textbf{Examples}


\begin{minted}{jlcon}
julia> bitstring(4)
"0000000000000000000000000000000000000000000000000000000000000100"

julia> bitstring(2.2)
"0100000000000001100110011001100110011001100110011001100110011010"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L678-L691}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14207407853646164654}{} 
\hyperlink{14207407853646164654}{\texttt{Base.parse}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
parse(type, str; base)
\end{minted}

Parse a string as a number. For \texttt{Integer} types, a base can be specified (the default is 10). For floating-point types, the string is parsed as a decimal floating-point number.  \texttt{Complex} types are parsed from decimal strings of the form \texttt{{\textquotedbl}R±Iim{\textquotedbl}} as a \texttt{Complex(R,I)} of the requested type; \texttt{{\textquotedbl}i{\textquotedbl}} or \texttt{{\textquotedbl}j{\textquotedbl}} can also be used instead of \texttt{{\textquotedbl}im{\textquotedbl}}, and \texttt{{\textquotedbl}R{\textquotedbl}} or \texttt{{\textquotedbl}Iim{\textquotedbl}} are also permitted. If the string does not contain a valid number, an error is raised.

\begin{quote}
\textbf{Julia 1.1}

\texttt{parse(Bool, str)} requires at least Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> parse(Int, "1234")
1234

julia> parse(Int, "1234", base = 5)
194

julia> parse(Int, "afc", base = 16)
2812

julia> parse(Float64, "1.2e-3")
0.0012

julia> parse(Complex{Float64}, "3.2e-1 + 4.5im")
0.32 + 4.5im
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/parse.jl#L7-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16455869400787770938}{} 
\hyperlink{16455869400787770938}{\texttt{Base.tryparse}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tryparse(type, str; base)
\end{minted}

Like \hyperlink{14207407853646164654}{\texttt{parse}}, but returns either a value of the requested type, or \hyperlink{9331422207248206047}{\texttt{nothing}} if the string does not contain a valid number.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/parse.jl#L226-L231}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2266887946765468938}{} 
\hyperlink{2266887946765468938}{\texttt{Base.big}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
big(x)
\end{minted}

Convert a number to a maximum precision representation (typically \hyperlink{423405808990690832}{\texttt{BigInt}} or \texttt{BigFloat}). See \hyperlink{749816618809421837}{\texttt{BigFloat}} for information about some pitfalls with floating-point numbers.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/gmp.jl#L454-L459}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8153758211648029368}{} 
\hyperlink{8153758211648029368}{\texttt{Base.signed}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
signed(x)
\end{minted}

Convert a number to a signed integer. If the argument is unsigned, it is reinterpreted as signed without checking for overflow.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L161-L166}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5348292453497802071}{} 
\hyperlink{5348292453497802071}{\texttt{Base.unsigned}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unsigned(x) -> Unsigned
\end{minted}

Convert a number to an unsigned integer. If the argument is signed, it is reinterpreted as unsigned without checking for negative values.

\textbf{Examples}


\begin{minted}{jlcon}
julia> unsigned(-2)
0xfffffffffffffffe

julia> unsigned(2)
0x0000000000000002

julia> signed(unsigned(-2))
-2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L140-L157}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6134868769696830446}{} 
\hyperlink{6134868769696830446}{\texttt{Base.float}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
float(x)
\end{minted}

Convert a number or array to a floating point data type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L272-L276}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11312242195671521747}{} 
\hyperlink{11312242195671521747}{\texttt{Base.Math.significand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
significand(x)
\end{minted}

Extract the \texttt{significand(s)} (a.k.a. mantissa), in binary representation, of a floating-point number. If \texttt{x} is a non-zero finite number, then the result will be a number of the same type on the interval  \([1,2)\) . Otherwise \texttt{x} is returned.

\textbf{Examples}


\begin{minted}{jlcon}
julia> significand(15.2)/15.2
0.125

julia> significand(15.2)*8
15.2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L780-L795}{\texttt{source}}


\end{adjustwidth}
\hypertarget{39736318364195845}{} 
\hyperlink{39736318364195845}{\texttt{Base.Math.exponent}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
exponent(x) -> Int
\end{minted}

Get the exponent of a normalized floating-point number.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L761-L765}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16014240202095271744}{} 
\hyperlink{16014240202095271744}{\texttt{Base.complex}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
complex(r, [i])
\end{minted}

Convert real numbers or arrays to complex. \texttt{i} defaults to zero.

\textbf{Examples}


\begin{minted}{jlcon}
julia> complex(7)
7 + 0im

julia> complex([1, 2, 3])
3-element Array{Complex{Int64},1}:
 1 + 0im
 2 + 0im
 3 + 0im
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/complex.jl#L141-L157}{\texttt{source}}


\end{adjustwidth}
\hypertarget{931573217390904193}{} 
\hyperlink{931573217390904193}{\texttt{Base.bswap}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
bswap(n)
\end{minted}

Reverse the byte order of \texttt{n}.

(See also \hyperlink{17463337378549787661}{\texttt{ntoh}} and \hyperlink{17749829108559566344}{\texttt{hton}} to convert between the current native byte order and big-endian order.)

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = bswap(0x10203040)
0x40302010

julia> bswap(a)
0x10203040

julia> string(1, base = 2)
"1"

julia> string(bswap(1), base = 2)
"100000000000000000000000000000000000000000000000000000000"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L303-L324}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7748090932723143403}{} 
\hyperlink{7748090932723143403}{\texttt{Base.hex2bytes}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hex2bytes(s::Union{AbstractString,AbstractVector{UInt8}})
\end{minted}

Given a string or array \texttt{s} of ASCII codes for a sequence of hexadecimal digits, returns a \texttt{Vector\{UInt8\}} of bytes  corresponding to the binary representation: each successive pair of hexadecimal digits in \texttt{s} gives the value of one byte in the return vector.

The length of \texttt{s} must be even, and the returned array has half of the length of \texttt{s}. See also \hyperlink{12258920440597292563}{\texttt{hex2bytes!}} for an in-place version, and \hyperlink{14739363105735559529}{\texttt{bytes2hex}} for the inverse.

\textbf{Examples}


\begin{minted}{jlcon}
julia> s = string(12345, base = 16)
"3039"

julia> hex2bytes(s)
2-element Array{UInt8,1}:
 0x30
 0x39

julia> a = b"01abEF"
6-element Base.CodeUnits{UInt8,String}:
 0x30
 0x31
 0x61
 0x62
 0x45
 0x46

julia> hex2bytes(a)
3-element Array{UInt8,1}:
 0x01
 0xab
 0xef
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L501-L536}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12258920440597292563}{} 
\hyperlink{12258920440597292563}{\texttt{Base.hex2bytes!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hex2bytes!(d::AbstractVector{UInt8}, s::Union{String,AbstractVector{UInt8}})
\end{minted}

Convert an array \texttt{s} of bytes representing a hexadecimal string to its binary representation, similar to \hyperlink{7748090932723143403}{\texttt{hex2bytes}} except that the output is written in-place in \texttt{d}.   The length of \texttt{s} must be exactly twice the length of \texttt{d}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L547-L553}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14739363105735559529}{} 
\hyperlink{14739363105735559529}{\texttt{Base.bytes2hex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
bytes2hex(a::AbstractArray{UInt8}) -> String
bytes2hex(io::IO, a::AbstractArray{UInt8})
\end{minted}

Convert an array \texttt{a} of bytes to its hexadecimal string representation, either returning a \texttt{String} via \texttt{bytes2hex(a)} or writing the string to an \texttt{io} stream via \texttt{bytes2hex(io, a)}.  The hexadecimal characters are all lowercase.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = string(12345, base = 16)
"3039"

julia> b = hex2bytes(a)
2-element Array{UInt8,1}:
 0x30
 0x39

julia> bytes2hex(b)
"3039"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L572-L593}{\texttt{source}}


\end{adjustwidth}

\hypertarget{10637014207943065137}{}


\section{常用数值函数和常量}


\hypertarget{11395333326208453101}{} 
\hyperlink{11395333326208453101}{\texttt{Base.one}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
one(x)
one(T::type)
\end{minted}

Return a multiplicative identity for \texttt{x}: a value such that \texttt{one(x)*x == x*one(x) == x}.  Alternatively \texttt{one(T)} can take a type \texttt{T}, in which case \texttt{one} returns a multiplicative identity for any \texttt{x} of type \texttt{T}.

If possible, \texttt{one(x)} returns a value of the same type as \texttt{x}, and \texttt{one(T)} returns a value of type \texttt{T}.  However, this may not be the case for types representing dimensionful quantities (e.g. time in days), since the multiplicative identity must be dimensionless.  In that case, \texttt{one(x)} should return an identity value of the same precision (and shape, for matrices) as \texttt{x}.

If you want a quantity that is of the same type as \texttt{x}, or of type \texttt{T}, even if \texttt{x} is dimensionful, use \hyperlink{2310843180104103470}{\texttt{oneunit}} instead.

\textbf{Examples}


\begin{minted}{jlcon}
julia> one(3.7)
1.0

julia> one(Int)
1

julia> import Dates; one(Dates.Day(1))
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L244-L275}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2310843180104103470}{} 
\hyperlink{2310843180104103470}{\texttt{Base.oneunit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
oneunit(x::T)
oneunit(T::Type)
\end{minted}

Returns \texttt{T(one(x))}, where \texttt{T} is either the type of the argument or (if a type is passed) the argument.  This differs from \hyperlink{11395333326208453101}{\texttt{one}} for dimensionful quantities: \texttt{one} is dimensionless (a multiplicative identity) while \texttt{oneunit} is dimensionful (of the same type as \texttt{x}, or of type \texttt{T}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> oneunit(3.7)
1.0

julia> import Dates; oneunit(Dates.Day)
1 day
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L281-L298}{\texttt{source}}


\end{adjustwidth}
\hypertarget{240596739242881814}{} 
\hyperlink{240596739242881814}{\texttt{Base.zero}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
zero(x)
\end{minted}

Get the additive identity element for the type of \texttt{x} (\texttt{x} can also specify the type itself).

\textbf{Examples}


\begin{minted}{jlcon}
julia> zero(1)
0

julia> zero(big"2.0")
0.0

julia> zero(rand(2,2))
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L222-L240}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15097910740298861288}{} 
\hyperlink{15097910740298861288}{\texttt{Base.im}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
im
\end{minted}

The imaginary unit.

\textbf{Examples}


\begin{minted}{jlcon}
julia> im * im
-1 + 0im
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/complex.jl#L18-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4355513108985533054}{} 
\hyperlink{4355513108985533054}{\texttt{Base.MathConstants.pi}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
π
pi
\end{minted}

The constant pi.

\textbf{Examples}


\begin{minted}{jlcon}
julia> pi
π = 3.1415926535897...
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/mathconstants.jl#L20-L31}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5995848487717371733}{} 
\hyperlink{5995848487717371733}{\texttt{Base.MathConstants.ℯ}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ℯ
e
\end{minted}

The constant ℯ.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ℯ
ℯ = 2.7182818284590...
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/mathconstants.jl#L34-L45}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8524456009860829844}{} 
\hyperlink{8524456009860829844}{\texttt{Base.MathConstants.catalan}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
catalan
\end{minted}

Catalan{\textquotesingle}s constant.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Base.MathConstants.catalan
catalan = 0.9159655941772...
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/mathconstants.jl#L76-L86}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10414961909538485487}{} 
\hyperlink{10414961909538485487}{\texttt{Base.MathConstants.eulergamma}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
γ
eulergamma
\end{minted}

Euler{\textquotesingle}s constant.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Base.MathConstants.eulergamma
γ = 0.5772156649015...
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/mathconstants.jl#L48-L59}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1981793918228771227}{} 
\hyperlink{1981793918228771227}{\texttt{Base.MathConstants.golden}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
φ
golden
\end{minted}

The golden ratio.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Base.MathConstants.golden
φ = 1.6180339887498...
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/mathconstants.jl#L62-L73}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1907914141659611007}{} 
\hyperlink{1907914141659611007}{\texttt{Base.Inf}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Inf, Inf64
\end{minted}

Positive infinity of type \hyperlink{5027751419500983000}{\texttt{Float64}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L35-L39}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7827423203261078742}{} 
\hyperlink{7827423203261078742}{\texttt{Base.Inf32}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Inf32
\end{minted}

Positive infinity of type \hyperlink{8101639384272933082}{\texttt{Float32}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L19-L23}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7656978911755578336}{} 
\hyperlink{7656978911755578336}{\texttt{Base.Inf16}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Inf16
\end{minted}

Positive infinity of type \hyperlink{2727296760866702904}{\texttt{Float16}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L7-L11}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11449618129446476597}{} 
\hyperlink{11449618129446476597}{\texttt{Base.NaN}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
NaN, NaN64
\end{minted}

A not-a-number value of type \hyperlink{5027751419500983000}{\texttt{Float64}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L43-L47}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3173013683234902743}{} 
\hyperlink{3173013683234902743}{\texttt{Base.NaN32}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
NaN32
\end{minted}

A not-a-number value of type \hyperlink{8101639384272933082}{\texttt{Float32}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L25-L29}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1412633859926300302}{} 
\hyperlink{1412633859926300302}{\texttt{Base.NaN16}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
NaN16
\end{minted}

A not-a-number value of type \hyperlink{2727296760866702904}{\texttt{Float16}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L13-L17}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10864939112775145474}{} 
\hyperlink{10864939112775145474}{\texttt{Base.issubnormal}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issubnormal(f) -> Bool
\end{minted}

Test whether a floating point number is subnormal.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L718-L722}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2906021895910968108}{} 
\hyperlink{2906021895910968108}{\texttt{Base.isfinite}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isfinite(f) -> Bool
\end{minted}

Test whether a number is finite.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isfinite(5)
true

julia> isfinite(NaN32)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L540-L553}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4492113908831448207}{} 
\hyperlink{4492113908831448207}{\texttt{Base.isinf}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isinf(f) -> Bool
\end{minted}

Test whether a number is infinite.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L559-L563}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6770390199496851634}{} 
\hyperlink{6770390199496851634}{\texttt{Base.isnan}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isnan(f) -> Bool
\end{minted}

Test whether a number value is a NaN, an indeterminate value which is neither an infinity nor a finite number ({\textquotedbl}not a number{\textquotedbl}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L530-L535}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17648248624761612718}{} 
\hyperlink{17648248624761612718}{\texttt{Base.iszero}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
iszero(x)
\end{minted}

Return \texttt{true} if \texttt{x == zero(x)}; if \texttt{x} is an array, this checks whether all of the elements of \texttt{x} are zero.

\textbf{Examples}


\begin{minted}{jlcon}
julia> iszero(0.0)
true

julia> iszero([1, 9, 0])
false

julia> iszero([false, 0, 0])
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L22-L39}{\texttt{source}}


\end{adjustwidth}
\hypertarget{253331863485455966}{} 
\hyperlink{253331863485455966}{\texttt{Base.isone}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isone(x)
\end{minted}

Return \texttt{true} if \texttt{x == one(x)}; if \texttt{x} is an array, this checks whether \texttt{x} is an identity matrix.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isone(1.0)
true

julia> isone([1 0; 0 2])
false

julia> isone([1 0; 0 true])
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L42-L59}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8339500090035450608}{} 
\hyperlink{8339500090035450608}{\texttt{Base.nextfloat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nextfloat(x::AbstractFloat, n::Integer)
\end{minted}

The result of \texttt{n} iterative applications of \texttt{nextfloat} to \texttt{x} if \texttt{n >= 0}, or \texttt{-n} applications of \texttt{prevfloat} if \texttt{n < 0}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L603-L608}{\texttt{source}}



\begin{lstlisting}
nextfloat(x::AbstractFloat)
\end{lstlisting}

Return the smallest floating point number \texttt{y} of the same type as \texttt{x} such \texttt{x < y}. If no such \texttt{y} exists (e.g. if \texttt{x} is \texttt{Inf} or \texttt{NaN}), then return \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L647-L652}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14035790731013288499}{} 
\hyperlink{14035790731013288499}{\texttt{Base.prevfloat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
prevfloat(x::AbstractFloat, n::Integer)
\end{minted}

The result of \texttt{n} iterative applications of \texttt{prevfloat} to \texttt{x} if \texttt{n >= 0}, or \texttt{-n} applications of \texttt{nextfloat} if \texttt{n < 0}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L655-L660}{\texttt{source}}



\begin{lstlisting}
prevfloat(x::AbstractFloat)
\end{lstlisting}

Return the largest floating point number \texttt{y} of the same type as \texttt{x} such \texttt{y < x}. If no such \texttt{y} exists (e.g. if \texttt{x} is \texttt{-Inf} or \texttt{NaN}), then return \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L663-L668}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1292047667500506923}{} 
\hyperlink{1292047667500506923}{\texttt{Base.isinteger}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isinteger(x) -> Bool
\end{minted}

Test whether \texttt{x} is numerically equal to some integer.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isinteger(4.0)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L9-L19}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11869977035061433209}{} 
\hyperlink{11869977035061433209}{\texttt{Base.isreal}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isreal(x) -> Bool
\end{minted}

Test whether \texttt{x} or all its elements are numerically equal to some real number including infinities and NaNs. \texttt{isreal(x)} is true if \texttt{isequal(x, real(x))} is true.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isreal(5.)
true

julia> isreal(Inf + 0im)
true

julia> isreal([4.; complex(0,1)])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/complex.jl#L113-L131}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11475816161015002523}{} 
\hyperlink{11475816161015002523}{\texttt{Core.Float32}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Float32(x [, mode::RoundingMode])
\end{minted}

Create a \texttt{Float32} from \texttt{x}. If \texttt{x} is not exactly representable then \texttt{mode} determines how \texttt{x} is rounded.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Float32(1/3, RoundDown)
0.3333333f0

julia> Float32(1/3, RoundUp)
0.33333334f0
\end{minted}

See \hyperlink{16713322195952720212}{\texttt{RoundingMode}} for available rounding modes.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1145-L1161}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5076205197474650253}{} 
\hyperlink{5076205197474650253}{\texttt{Core.Float64}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Float64(x [, mode::RoundingMode])
\end{minted}

Create a \texttt{Float64} from \texttt{x}. If \texttt{x} is not exactly representable then \texttt{mode} determines how \texttt{x} is rounded.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Float64(pi, RoundDown)
3.141592653589793

julia> Float64(pi, RoundUp)
3.1415926535897936
\end{minted}

See \hyperlink{16713322195952720212}{\texttt{RoundingMode}} for available rounding modes.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1164-L1180}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6511778857518292792}{} 
\hyperlink{6511778857518292792}{\texttt{Base.Rounding.rounding}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rounding(T)
\end{minted}

Get the current floating point rounding mode for type \texttt{T}, controlling the rounding of basic arithmetic functions (\hyperlink{3677358729494553841}{\texttt{+}}, \hyperlink{8228207173393714756}{\texttt{-}}, \hyperlink{7592762607639177347}{\texttt{*}}, \hyperlink{4103478871488785445}{\texttt{/}} and \hyperlink{4551113327515323898}{\texttt{sqrt}}) and type conversion.

See \hyperlink{16713322195952720212}{\texttt{RoundingMode}} for available modes.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L143-L151}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12025922235501343815}{} 
\hyperlink{12025922235501343815}{\texttt{Base.Rounding.setrounding}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
setrounding(T, mode)
\end{minted}

Set the rounding mode of floating point type \texttt{T}, controlling the rounding of basic arithmetic functions (\hyperlink{3677358729494553841}{\texttt{+}}, \hyperlink{8228207173393714756}{\texttt{-}}, \hyperlink{7592762607639177347}{\texttt{*}}, \hyperlink{4103478871488785445}{\texttt{/}} and \hyperlink{4551113327515323898}{\texttt{sqrt}}) and type conversion. Other numerical functions may give incorrect or invalid values when using rounding modes other than the default \hyperlink{868115654703135309}{\texttt{RoundNearest}}.

Note that this is currently only supported for \texttt{T == BigFloat}.

\begin{quote}
\textbf{Warning}

This function is not thread-safe. It will affect code running on all threads, but its behavior is undefined if called concurrently with computations that use the setting.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L124-L140}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9774741470027705214}{} 
\hyperlink{9774741470027705214}{\texttt{Base.Rounding.setrounding}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
setrounding(f::Function, T, mode)
\end{minted}

Change the rounding mode of floating point type \texttt{T} for the duration of \texttt{f}. It is logically equivalent to:


\begin{lstlisting}
old = rounding(T)
setrounding(T, mode)
f()
setrounding(T, old)
\end{lstlisting}

See \hyperlink{16713322195952720212}{\texttt{RoundingMode}} for available rounding modes.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L159-L171}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13184231496538414617}{} 
\hyperlink{13184231496538414617}{\texttt{Base.Rounding.get\_zero\_subnormals}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
get_zero_subnormals() -> Bool
\end{minted}

Return \texttt{false} if operations on subnormal floating-point values ({\textquotedbl}denormals{\textquotedbl}) obey rules for IEEE arithmetic, and \texttt{true} if they might be converted to zeros.

\begin{quote}
\textbf{Warning}

This function only affects the current thread.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L237-L246}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2845950135157372113}{} 
\hyperlink{2845950135157372113}{\texttt{Base.Rounding.set\_zero\_subnormals}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
set_zero_subnormals(yes::Bool) -> Bool
\end{minted}

If \texttt{yes} is \texttt{false}, subsequent floating-point operations follow rules for IEEE arithmetic on subnormal values ({\textquotedbl}denormals{\textquotedbl}). Otherwise, floating-point operations are permitted (but not required) to convert subnormal inputs or outputs to zero. Returns \texttt{true} unless \texttt{yes==true} but the hardware does not support zeroing of subnormal numbers.

\texttt{set\_zero\_subnormals(true)} can speed up some computations on some hardware. However, it can break identities such as \texttt{(x-y==0) == (x==y)}.

\begin{quote}
\textbf{Warning}

This function only affects the current thread.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L220-L234}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14839704257524522191}{}


\subsection{整型}


\hypertarget{4179288755987827924}{} 
\hyperlink{4179288755987827924}{\texttt{Base.count\_ones}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
count_ones(x::Integer) -> Integer
\end{minted}

Number of ones in the binary representation of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> count_ones(7)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L329-L339}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7870666257802898093}{} 
\hyperlink{7870666257802898093}{\texttt{Base.count\_zeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
count_zeros(x::Integer) -> Integer
\end{minted}

Number of zeros in the binary representation of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> count_zeros(Int32(2 ^ 16 - 1))
16
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L368-L378}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7979293123371436933}{} 
\hyperlink{7979293123371436933}{\texttt{Base.leading\_zeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
leading_zeros(x::Integer) -> Integer
\end{minted}

Number of zeros leading the binary representation of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> leading_zeros(Int32(1))
31
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L342-L352}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9160604458117919092}{} 
\hyperlink{9160604458117919092}{\texttt{Base.leading\_ones}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
leading_ones(x::Integer) -> Integer
\end{minted}

Number of ones leading the binary representation of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> leading_ones(UInt32(2 ^ 32 - 2))
31
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L381-L391}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4757748081622484794}{} 
\hyperlink{4757748081622484794}{\texttt{Base.trailing\_zeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trailing_zeros(x::Integer) -> Integer
\end{minted}

Number of zeros trailing the binary representation of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> trailing_zeros(2)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L355-L365}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1557366507921404436}{} 
\hyperlink{1557366507921404436}{\texttt{Base.trailing\_ones}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trailing_ones(x::Integer) -> Integer
\end{minted}

Number of ones trailing the binary representation of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> trailing_ones(3)
2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L394-L404}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2288006657111547854}{} 
\hyperlink{2288006657111547854}{\texttt{Base.isodd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isodd(x::Integer) -> Bool
\end{minted}

Return \texttt{true} if \texttt{x} is odd (that is, not divisible by 2), and \texttt{false} otherwise.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isodd(9)
true

julia> isodd(10)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L61-L74}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6755629456808693979}{} 
\hyperlink{6755629456808693979}{\texttt{Base.iseven}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
iseven(x::Integer) -> Bool
\end{minted}

Return \texttt{true} is \texttt{x} is even (that is, divisible by 2), and \texttt{false} otherwise.

\textbf{Examples}


\begin{minted}{jlcon}
julia> iseven(9)
false

julia> iseven(10)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L77-L90}{\texttt{source}}


\end{adjustwidth}
\hypertarget{291660922357493034}{} 
\hyperlink{291660922357493034}{\texttt{Core.@int128\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@int128_str str
@int128_str(str)
\end{minted}

\texttt{@int128\_str} parses a string into a Int128 Throws an \texttt{ArgumentError} if the string is not a valid integer



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L538-L544}{\texttt{source}}


\end{adjustwidth}
\hypertarget{325519564013190561}{} 
\hyperlink{325519564013190561}{\texttt{Core.@uint128\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@uint128_str str
@uint128_str(str)
\end{minted}

\texttt{@uint128\_str} parses a string into a UInt128 Throws an \texttt{ArgumentError} if the string is not a valid integer



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L549-L555}{\texttt{source}}


\end{adjustwidth}

\hypertarget{15006469534325680034}{}


\section{BigFloats and BigInts}



The \hyperlink{749816618809421837}{\texttt{BigFloat}} and \hyperlink{423405808990690832}{\texttt{BigInt}} types implements arbitrary-precision floating point and integer arithmetic, respectively. For \hyperlink{749816618809421837}{\texttt{BigFloat}} the \href{https://www.mpfr.org/}{GNU MPFR library} is used, and for \hyperlink{423405808990690832}{\texttt{BigInt}} the \href{https://gmplib.org}{GNU Multiple Precision Arithmetic Library (GMP)} is used.


\hypertarget{9760529761072602961}{} 
\hyperlink{9760529761072602961}{\texttt{Base.MPFR.BigFloat}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
BigFloat(x::Union{Real, AbstractString} [, rounding::RoundingMode=rounding(BigFloat)]; [precision::Integer=precision(BigFloat)])
\end{minted}

Create an arbitrary precision floating point number from \texttt{x}, with precision \texttt{precision}. The \texttt{rounding} argument specifies the direction in which the result should be rounded if the conversion cannot be done exactly. If not provided, these are set by the current global values.

\texttt{BigFloat(x::Real)} is the same as \texttt{convert(BigFloat,x)}, except if \texttt{x} itself is already \texttt{BigFloat}, in which case it will return a value with the precision set to the current global precision; \texttt{convert} will always return \texttt{x}.

\texttt{BigFloat(x::AbstractString)} is identical to \hyperlink{14207407853646164654}{\texttt{parse}}. This is provided for convenience since decimal literals are converted to \texttt{Float64} when parsed, so \texttt{BigFloat(2.1)} may not yield what you expect.

\begin{quote}
\textbf{Julia 1.1}

\texttt{precision} as a keyword argument requires at least Julia 1.1. In Julia 1.0 \texttt{precision} is the second positional argument (\texttt{BigFloat(x, precision)}).

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> BigFloat(2.1) # 2.1 here is a Float64
2.100000000000000088817841970012523233890533447265625

julia> BigFloat("2.1") # the closest BigFloat to 2.1
2.099999999999999999999999999999999999999999999999999999999999999999999999999986

julia> BigFloat("2.1", RoundUp)
2.100000000000000000000000000000000000000000000000000000000000000000000000000021

julia> BigFloat("2.1", RoundUp, precision=128)
2.100000000000000000000000000000000000007
\end{minted}

\textbf{See also}

\begin{itemize}
\item \hyperlink{4226571565562941917}{\texttt{@big\_str}}


\item \hyperlink{6511778857518292792}{\texttt{rounding}} and \hyperlink{12025922235501343815}{\texttt{setrounding}}


\item \hyperlink{13742359768532654153}{\texttt{precision}} and \hyperlink{3543074496498234209}{\texttt{setprecision}}

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/mpfr.jl#L140-L178}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13742359768532654153}{} 
\hyperlink{13742359768532654153}{\texttt{Base.precision}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
precision(num::AbstractFloat)
\end{minted}

Get the precision of a floating point number, as defined by the effective number of bits in the mantissa.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L578-L583}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6555036846799841969}{} 
\hyperlink{6555036846799841969}{\texttt{Base.precision}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
precision(BigFloat)
\end{minted}

Get the precision (in bits) currently used for \hyperlink{749816618809421837}{\texttt{BigFloat}} arithmetic.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/mpfr.jl#L809-L813}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3543074496498234209}{} 
\hyperlink{3543074496498234209}{\texttt{Base.MPFR.setprecision}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
setprecision([T=BigFloat,] precision::Int)
\end{minted}

Set the precision (in bits) to be used for \texttt{T} arithmetic.

\begin{quote}
\textbf{Warning}

This function is not thread-safe. It will affect code running on all threads, but its behavior is undefined if called concurrently with computations that use the setting.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/mpfr.jl#L816-L826}{\texttt{source}}



\begin{lstlisting}
setprecision(f::Function, [T=BigFloat,] precision::Integer)
\end{lstlisting}

Change the \texttt{T} arithmetic precision (in bits) for the duration of \texttt{f}. It is logically equivalent to:


\begin{lstlisting}
old = precision(BigFloat)
setprecision(BigFloat, precision)
f()
setprecision(BigFloat, old)
\end{lstlisting}

Often used as \texttt{setprecision(T, precision) do ... end}

Note: \texttt{nextfloat()}, \texttt{prevfloat()} do not use the precision mentioned by \texttt{setprecision}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/mpfr.jl#L928-L943}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11702055980905109221}{} 
\hyperlink{11702055980905109221}{\texttt{Base.GMP.BigInt}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
BigInt(x)
\end{minted}

Create an arbitrary precision integer. \texttt{x} may be an \texttt{Int} (or anything that can be converted to an \texttt{Int}). The usual mathematical operators are defined for this type, and results are promoted to a \hyperlink{423405808990690832}{\texttt{BigInt}}.

Instances can be constructed from strings via \hyperlink{14207407853646164654}{\texttt{parse}}, or using the \texttt{big} string literal.

\textbf{Examples}


\begin{minted}{jlcon}
julia> parse(BigInt, "42")
42

julia> big"313"
313
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/gmp.jl#L62-L80}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4226571565562941917}{} 
\hyperlink{4226571565562941917}{\texttt{Core.@big\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@big_str str
@big_str(str)
\end{minted}

Parse a string into a \hyperlink{423405808990690832}{\texttt{BigInt}} or \hyperlink{749816618809421837}{\texttt{BigFloat}}, and throw an \texttt{ArgumentError} if the string is not a valid number. For integers \texttt{\_} is allowed in the string as a separator.

\textbf{Examples}


\begin{minted}{jlcon}
julia> big"123_456"
123456

julia> big"7891.5"
7891.5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L560-L576}{\texttt{source}}


\end{adjustwidth}

\hypertarget{7104946044181754749}{}


\chapter{字符串}


\hypertarget{17842511721012314372}{} 
\hyperlink{17842511721012314372}{\texttt{Core.AbstractChar}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

The \texttt{AbstractChar} type is the supertype of all character implementations in Julia. A character represents a Unicode code point, and can be converted to an integer via the \hyperlink{683489308723658065}{\texttt{codepoint}} function in order to obtain the numerical value of the code point, or constructed from the same integer. These numerical values determine how characters are compared with \texttt{<} and \texttt{==}, for example.  New \texttt{T <: AbstractChar} types should define a \texttt{codepoint(::T)} method and a \texttt{T(::UInt32)} constructor, at minimum.

A given \texttt{AbstractChar} subtype may be capable of representing only a subset of Unicode, in which case conversion from an unsupported \texttt{UInt32} value may throw an error. Conversely, the built-in \hyperlink{3463806064296245385}{\texttt{Char}} type represents a \emph{superset} of Unicode (in order to losslessly encode invalid byte streams), in which case conversion of a non-Unicode value \emph{to} \texttt{UInt32} throws an error. The \hyperlink{9678448882095016755}{\texttt{isvalid}} function can be used to check which codepoints are representable in a given \texttt{AbstractChar} type.

Internally, an \texttt{AbstractChar} type may use a variety of encodings.  Conversion via \texttt{codepoint(char)} will not reveal this encoding because it always returns the Unicode value of the character. \texttt{print(io, c)} of any \texttt{c::AbstractChar} produces an encoding determined by \texttt{io} (UTF-8 for all built-in \texttt{IO} types), via conversion to \texttt{Char} if necessary.

\texttt{write(io, c)}, in contrast, may emit an encoding depending on \texttt{typeof(c)}, and \texttt{read(io, typeof(c))} should read the same encoding as \texttt{write}. New \texttt{AbstractChar} types must provide their own implementations of \texttt{write} and \texttt{read}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/char.jl#L3-L30}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3463806064296245385}{} 
\hyperlink{3463806064296245385}{\texttt{Core.Char}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Char(c::Union{Number,AbstractChar})
\end{minted}

\texttt{Char} is a 32-bit \hyperlink{17842511721012314372}{\texttt{AbstractChar}} type that is the default representation of characters in Julia. \texttt{Char} is the type used for character literals like \texttt{{\textquotesingle}x{\textquotesingle}} and it is also the element type of \hyperlink{2825695355940841177}{\texttt{String}}.

In order to losslessly represent arbitrary byte streams stored in a \texttt{String}, a \texttt{Char} value may store information that cannot be converted to a Unicode codepoint — converting such a \texttt{Char} to \texttt{UInt32} will throw an error. The \hyperlink{9678448882095016755}{\texttt{isvalid(c::Char)}} function can be used to query whether \texttt{c} represents a valid Unicode character.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/char.jl#L33-L45}{\texttt{source}}


\end{adjustwidth}
\hypertarget{683489308723658065}{} 
\hyperlink{683489308723658065}{\texttt{Base.codepoint}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
codepoint(c::AbstractChar) -> Integer
\end{minted}

Return the Unicode codepoint (an unsigned integer) corresponding to the character \texttt{c} (or throw an exception if \texttt{c} does not represent a valid character). For \texttt{Char}, this is a \texttt{UInt32} value, but \texttt{AbstractChar} types that represent only a subset of Unicode may return a different-sized integer (e.g. \texttt{UInt8}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/char.jl#L66-L74}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10635384680993060803}{} 
\hyperlink{10635384680993060803}{\texttt{Base.length}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
length(s::AbstractString) -> Int
length(s::AbstractString, i::Integer, j::Integer) -> Int
\end{minted}

The number of characters in string \texttt{s} from indices \texttt{i} through \texttt{j}. This is computed as the number of code unit indices from \texttt{i} to \texttt{j} which are valid character indices. With only a single string argument, this computes the number of characters in the entire string. With \texttt{i} and \texttt{j} arguments it computes the number of indices between \texttt{i} and \texttt{j} inclusive that are valid indices in the string \texttt{s}. In addition to in-bounds values, \texttt{i} may take the out-of-bounds value \texttt{ncodeunits(s) + 1} and \texttt{j} may take the out-of-bounds value \texttt{0}.

See also: \hyperlink{9678448882095016755}{\texttt{isvalid}}, \hyperlink{1775518749150675445}{\texttt{ncodeunits}}, \hyperlink{15780929618270241785}{\texttt{lastindex}}, \hyperlink{11299403048911786045}{\texttt{thisind}}, \hyperlink{7455293228649070526}{\texttt{nextind}}, \hyperlink{15871508897466976220}{\texttt{prevind}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> length("jμΛIα")
5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L325-L346}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1670208154575640673}{} 
\hyperlink{1670208154575640673}{\texttt{Base.sizeof}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sizeof(str::AbstractString)
\end{minted}

Size, in bytes, of the string \texttt{str}. Equal to the number of code units in \texttt{str} multiplied by the size, in bytes, of one code unit in \texttt{str}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sizeof("")
0

julia> sizeof("∀")
3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L142-L156}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10114608239100313924}{} 
\hyperlink{10114608239100313924}{\texttt{Base.:*}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
*(s::Union{AbstractString, AbstractChar}, t::Union{AbstractString, AbstractChar}...) -> AbstractString
\end{minted}

Concatenate strings and/or characters, producing a \hyperlink{2825695355940841177}{\texttt{String}}. This is equivalent to calling the \hyperlink{7919678712989769360}{\texttt{string}} function on the arguments. Concatenation of built-in string types always produces a value of type \texttt{String} but other string types may choose to return a string of a different type as appropriate.

\textbf{Examples}


\begin{minted}{jlcon}
julia> "Hello " * "world"
"Hello world"

julia> 'j' * "ulia"
"julia"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L214-L230}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5729367935110528960}{} 
\hyperlink{5729367935110528960}{\texttt{Base.:{\textasciicircum}}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
^(s::Union{AbstractString,AbstractChar}, n::Integer)
\end{minted}

Repeat a string or character \texttt{n} times. This can also be written as \texttt{repeat(s, n)}.

See also: \hyperlink{15426606278434194584}{\texttt{repeat}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> "Test "^3
"Test Test Test "
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L667-L679}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7919678712989769360}{} 
\hyperlink{7919678712989769360}{\texttt{Base.string}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
string(n::Integer; base::Integer = 10, pad::Integer = 1)
\end{minted}

Convert an integer \texttt{n} to a string in the given \texttt{base}, optionally specifying a number of digits to pad to.


\begin{minted}{jlcon}
julia> string(5, base = 13, pad = 4)
"0005"

julia> string(13, base = 5, pad = 4)
"0023"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L644-L657}{\texttt{source}}



\begin{lstlisting}
string(xs...)
\end{lstlisting}

Create a string from any values, except \texttt{nothing}, using the \hyperlink{8248717042415202230}{\texttt{print}} function.

\texttt{string} should usually not be defined directly. Instead, define a method \texttt{print(io::IO, x::MyType)}. If \texttt{string(x)} for a certain type needs to be highly efficient, then it may make sense to add a method to \texttt{string} and define \texttt{print(io::IO, x::MyType) = print(io, string(x))} to ensure the functions are consistent.

\textbf{Examples}


\begin{minted}{jlcon}
julia> string("a", 1, true)
"a1true"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/io.jl#L157-L173}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17106633743155423093}{} 
\hyperlink{17106633743155423093}{\texttt{Base.repeat}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
repeat(s::AbstractString, r::Integer)
\end{minted}

Repeat a string \texttt{r} times. This can be written as \texttt{s{\textasciicircum}r}.

See also: \hyperlink{462277561264792021}{\texttt{{\textasciicircum}}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> repeat("ha", 3)
"hahaha"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L652-L664}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12559457455507699304}{} 
\hyperlink{12559457455507699304}{\texttt{Base.repeat}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
repeat(c::AbstractChar, r::Integer) -> String
\end{minted}

Repeat a character \texttt{r} times. This can equivalently be accomplished by calling \hyperlink{462277561264792021}{\texttt{c{\textasciicircum}r}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> repeat('A', 3)
"AAA"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/string.jl#L308-L318}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1022185167898104929}{} 
\hyperlink{1022185167898104929}{\texttt{Base.repr}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
repr(x; context=nothing)
\end{minted}

Create a string from any value using the \hyperlink{14071376285304310153}{\texttt{show}} function. You should not add methods to \texttt{repr}; define a \texttt{show} method instead.

The optional keyword argument \texttt{context} can be set to an \texttt{IO} or \hyperlink{13454403377667762339}{\texttt{IOContext}} object whose attributes are used for the I/O stream passed to \texttt{show}.

Note that \texttt{repr(x)} is usually similar to how the value of \texttt{x} would be entered in Julia.  See also \hyperlink{13076889230390082034}{\texttt{repr(MIME({\textquotedbl}text/plain{\textquotedbl}), x)}} to instead return a {\textquotedbl}pretty-printed{\textquotedbl} version of \texttt{x} designed more for human consumption, equivalent to the REPL display of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> repr(1)
"1"

julia> repr(zeros(3))
"[0.0, 0.0, 0.0]"

julia> repr(big(1/3))
"0.333333333333333314829616256247390992939472198486328125"

julia> repr(big(1/3), context=:compact => true)
"0.333333"

\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/io.jl#L197-L226}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2825695355940841177}{} 
\hyperlink{2825695355940841177}{\texttt{Core.String}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
String(s::AbstractString)
\end{minted}

Convert a string to a contiguous byte array representation encoded as UTF-8 bytes. This representation is often appropriate for passing strings to C.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/string.jl#L62-L67}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2624824381693370630}{} 
\hyperlink{2624824381693370630}{\texttt{Base.SubString}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SubString(s::AbstractString, i::Integer, j::Integer=lastindex(s))
SubString(s::AbstractString, r::UnitRange{<:Integer})
\end{minted}

Like \hyperlink{13720608614876840481}{\texttt{getindex}}, but returns a view into the parent string \texttt{s} within range \texttt{i:j} or \texttt{r} respectively instead of making a copy.

\textbf{Examples}


\begin{minted}{jlcon}
julia> SubString("abc", 1, 2)
"ab"

julia> SubString("abc", 1:2)
"ab"

julia> SubString("abc", 2)
"bc"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/substring.jl#L3-L21}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11147209877072452260}{} 
\hyperlink{11147209877072452260}{\texttt{Base.transcode}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
transcode(T, src)
\end{minted}

Convert string data between Unicode encodings. \texttt{src} is either a \texttt{String} or a \texttt{Vector\{UIntXX\}} of UTF-XX code units, where \texttt{XX} is 8, 16, or 32. \texttt{T} indicates the encoding of the return value: \texttt{String} to return a (UTF-8 encoded) \texttt{String} or \texttt{UIntXX} to return a \texttt{Vector\{UIntXX\}} of UTF-\texttt{XX} data. (The alias \hyperlink{2619479148155454993}{\texttt{Cwchar\_t}} can also be used as the integer type, for converting \texttt{wchar\_t*} strings used by external C libraries.)

The \texttt{transcode} function succeeds as long as the input data can be reasonably represented in the target encoding; it always succeeds for conversions between UTF-XX encodings, even for invalid Unicode data.

Only conversion to/from UTF-8 is currently supported.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L257-L273}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12370128473268209010}{} 
\hyperlink{12370128473268209010}{\texttt{Base.unsafe\_string}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unsafe_string(p::Ptr{UInt8}, [length::Integer])
\end{minted}

Copy a string from the address of a C-style (NUL-terminated) string encoded as UTF-8. (The pointer can be safely freed afterwards.) If \texttt{length} is specified (the length of the data in bytes), the string does not have to be NUL-terminated.

This function is labeled {\textquotedbl}unsafe{\textquotedbl} because it will crash if \texttt{p} is not a valid memory address to data of the requested length.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/string.jl#L41-L50}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1775518749150675445}{} 
\hyperlink{1775518749150675445}{\texttt{Base.ncodeunits}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ncodeunits(s::AbstractString) -> Int
\end{minted}

Return the number of code units in a string. Indices that are in bounds to access this string must satisfy \texttt{1 ≤ i ≤ ncodeunits(s)}. Not all such indices are valid – they may not be the start of a character, but they will return a code unit value when calling \texttt{codeunit(s,i)}.

See also: \hyperlink{16983098119361955361}{\texttt{codeunit}}, \hyperlink{6593895036014271495}{\texttt{checkbounds}}, \hyperlink{10394541563305653720}{\texttt{sizeof}}, \hyperlink{9362803119463040896}{\texttt{length}}, \hyperlink{15780929618270241785}{\texttt{lastindex}}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L45-L55}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16983098119361955361}{} 
\hyperlink{16983098119361955361}{\texttt{Base.codeunit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
codeunit(s::AbstractString) -> Type{<:Union{UInt8, UInt16, UInt32}}
\end{minted}

Return the code unit type of the given string object. For ASCII, Latin-1, or UTF-8 encoded strings, this would be \texttt{UInt8}; for UCS-2 and UTF-16 it would be \texttt{UInt16}; for UTF-32 it would be \texttt{UInt32}. The unit code type need not be limited to these three types, but it{\textquotesingle}s hard to think of widely used string encodings that don{\textquotesingle}t use one of these units. \texttt{codeunit(s)} is the same as \texttt{typeof(codeunit(s,1))} when \texttt{s} is a non-empty string.

See also: \hyperlink{1775518749150675445}{\texttt{ncodeunits}}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L58-L69}{\texttt{source}}



\begin{lstlisting}
codeunit(s::AbstractString, i::Integer) -> Union{UInt8, UInt16, UInt32}
\end{lstlisting}

Return the code unit value in the string \texttt{s} at index \texttt{i}. Note that


\begin{lstlisting}
codeunit(s, i) :: codeunit(s)
\end{lstlisting}

I.e. the value returned by \texttt{codeunit(s, i)} is of the type returned by \texttt{codeunit(s)}.

See also: \hyperlink{1775518749150675445}{\texttt{ncodeunits}}, \hyperlink{6593895036014271495}{\texttt{checkbounds}}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L72-L83}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17283482973786973382}{} 
\hyperlink{17283482973786973382}{\texttt{Base.codeunits}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
codeunits(s::AbstractString)
\end{minted}

Obtain a vector-like object containing the code units of a string. Returns a \texttt{CodeUnits} wrapper by default, but \texttt{codeunits} may optionally be defined for new string types if necessary.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L712-L718}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16934723397501354088}{} 
\hyperlink{16934723397501354088}{\texttt{Base.ascii}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ascii(s::AbstractString)
\end{minted}

Convert a string to \texttt{String} type and check that it contains only ASCII data, otherwise throwing an \texttt{ArgumentError} indicating the position of the first non-ASCII byte.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ascii("abcdeγfgh")
ERROR: ArgumentError: invalid ASCII at index 6 in "abcdeγfgh"
Stacktrace:
[...]

julia> ascii("abcdefgh")
"abcdefgh"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L619-L635}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8320574829780813411}{} 
\hyperlink{8320574829780813411}{\texttt{Base.@r\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@r_str -> Regex
\end{minted}

Construct a regex, such as \texttt{r{\textquotedbl}{\textasciicircum}[a-z]*\${\textquotedbl}}, without interpolation and unescaping (except for quotation mark \texttt{{\textquotedbl}} which still has to be escaped). The regex also accepts one or more flags, listed after the ending quote, to change its behaviour:

\begin{itemize}
\item \texttt{i} enables case-insensitive matching


\item \texttt{m} treats the \texttt{{\textasciicircum}} and \texttt{\$} tokens as matching the start and end of individual lines, as opposed to the whole string.


\item \texttt{s} allows the \texttt{.} modifier to match newlines.


\item \texttt{x} enables {\textquotedbl}comment mode{\textquotedbl}: whitespace is enabled except when escaped with \texttt{{\textbackslash}}, and \texttt{\#} is treated as starting a comment.


\item \texttt{a} disables \texttt{UCP} mode (enables ASCII mode). By default \texttt{{\textbackslash}B}, \texttt{{\textbackslash}b}, \texttt{{\textbackslash}D}, \texttt{{\textbackslash}d}, \texttt{{\textbackslash}S}, \texttt{{\textbackslash}s}, \texttt{{\textbackslash}W}, \texttt{{\textbackslash}w}, etc. match based on Unicode character properties. With this option, these sequences only match ASCII characters.

\end{itemize}
See \texttt{Regex} if interpolation is needed.

\textbf{Examples}


\begin{minted}{jlcon}
julia> match(r"a+.*b+.*?d$"ism, "Goodbye,\nOh, angry,\nBad world\n")
RegexMatch("angry,\nBad world")
\end{minted}

This regex has the first three flags enabled.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/regex.jl#L83-L108}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16275294768422181757}{} 
\hyperlink{16275294768422181757}{\texttt{Base.SubstitutionString}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SubstitutionString(substr)
\end{minted}

Stores the given string \texttt{substr} as a \texttt{SubstitutionString}, for use in regular expression substitutions. Most commonly constructed using the \hyperlink{10479548868515771509}{\texttt{@s\_str}} macro.


\begin{minted}{jlcon}
julia> SubstitutionString("Hello \\g<name>, it's \\1")
s"Hello \\g<name>, it's \\1"

julia> subst = s"Hello \g<name>, it's \1"
s"Hello \\g<name>, it's \\1"

julia> typeof(subst)
SubstitutionString{String}

\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/regex.jl#L385-L403}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10479548868515771509}{} 
\hyperlink{10479548868515771509}{\texttt{Base.@s\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@s_str -> SubstitutionString
\end{minted}

Construct a substitution string, used for regular expression substitutions.  Within the string, sequences of the form \texttt{{\textbackslash}N} refer to the Nth capture group in the regex, and \texttt{{\textbackslash}g<groupname>} refers to a named capture group with name \texttt{groupname}.


\begin{minted}{jlcon}
julia> msg = "#Hello# from Julia";

julia> replace(msg, r"#(.+)# from (?<from>\w+)" => s"FROM: \g<from>; MESSAGE: \1")
"FROM: Julia; MESSAGE: Hello"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/regex.jl#L419-L432}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3530098139758734654}{} 
\hyperlink{3530098139758734654}{\texttt{Base.@raw\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@raw_str -> String
\end{minted}

Create a raw string without interpolation and unescaping. The exception is that quotation marks still must be escaped. Backslashes escape both quotation marks and other backslashes, but only when a sequence of backslashes precedes a quote character. Thus, 2n backslashes followed by a quote encodes n backslashes and the end of the literal while 2n+1 backslashes followed by a quote encodes n backslashes followed by a quote character.

\textbf{Examples}


\begin{minted}{jlcon}
julia> println(raw"\ $x")
\ $x

julia> println(raw"\"")
"

julia> println(raw"\\\"")
\"

julia> println(raw"\\x \\\"")
\\x \"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/io.jl#L499-L523}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5401350878127948144}{} 
\hyperlink{5401350878127948144}{\texttt{Base.@b\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@b_str
\end{minted}

Create an immutable byte (\texttt{UInt8}) vector using string syntax.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = b"12\x01\x02"
4-element Base.CodeUnits{UInt8,String}:
 0x31
 0x32
 0x01
 0x02

julia> v[2]
0x32
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/io.jl#L476-L493}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3198534740077872140}{} 
\hyperlink{3198534740077872140}{\texttt{Base.Docs.@html\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@html_str -> Docs.HTML
\end{minted}

Create an \texttt{HTML} object from a literal string.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/utils.jl#L37-L41}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4530478957610065001}{} 
\hyperlink{4530478957610065001}{\texttt{Base.Docs.@text\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@text_str -> Docs.Text
\end{minted}

Create a \texttt{Text} object from a literal string.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/utils.jl#L78-L82}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9678448882095016755}{} 
\hyperlink{9678448882095016755}{\texttt{Base.isvalid}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isvalid(value) -> Bool
\end{minted}

Returns \texttt{true} if the given value is valid for its type, which currently can be either \texttt{AbstractChar} or \texttt{String} or \texttt{SubString\{String\}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isvalid(Char(0xd800))
false

julia> isvalid(SubString(String(UInt8[0xfe,0x80,0x80,0x80,0x80,0x80]),1,2))
false

julia> isvalid(Char(0xd799))
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L11-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16014659773986219432}{} 
\hyperlink{16014659773986219432}{\texttt{Base.isvalid}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isvalid(T, value) -> Bool
\end{minted}

Returns \texttt{true} if the given value is valid for that type. Types currently can be either \texttt{AbstractChar} or \texttt{String}. Values for \texttt{AbstractChar} can be of type \texttt{AbstractChar} or \hyperlink{8690996847580776341}{\texttt{UInt32}}. Values for \texttt{String} can be of that type, or \texttt{Vector\{UInt8\}} or \texttt{SubString\{String\}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isvalid(Char, 0xd800)
false

julia> isvalid(String, SubString("thisisvalid",1,5))
true

julia> isvalid(Char, 0xd799)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L31-L49}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10276715660934277801}{} 
\hyperlink{10276715660934277801}{\texttt{Base.isvalid}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isvalid(s::AbstractString, i::Integer) -> Bool
\end{minted}

Predicate indicating whether the given index is the start of the encoding of a character in \texttt{s} or not. If \texttt{isvalid(s, i)} is true then \texttt{s[i]} will return the character whose encoding starts at that index, if it{\textquotesingle}s false, then \texttt{s[i]} will raise an invalid index error or a bounds error depending on if \texttt{i} is in bounds. In order for \texttt{isvalid(s, i)} to be an O(1) function, the encoding of \texttt{s} must be \href{https://en.wikipedia.org/wiki/Self-synchronizing\_code}{self-synchronizing} this is a basic assumption of Julia{\textquotesingle}s generic string support.

See also: \hyperlink{13720608614876840481}{\texttt{getindex}}, \hyperlink{1722534687975587846}{\texttt{iterate}}, \hyperlink{11299403048911786045}{\texttt{thisind}}, \hyperlink{7455293228649070526}{\texttt{nextind}}, \hyperlink{15871508897466976220}{\texttt{prevind}}, \hyperlink{9362803119463040896}{\texttt{length}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> str = "αβγdef";

julia> isvalid(str, 1)
true

julia> str[1]
'α': Unicode U+03B1 (category Ll: Letter, lowercase)

julia> isvalid(str, 2)
false

julia> str[2]
ERROR: StringIndexError("αβγdef", 2)
Stacktrace:
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L87-L120}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2695862412477105800}{} 
\hyperlink{2695862412477105800}{\texttt{Base.match}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
match(r::Regex, s::AbstractString[, idx::Integer[, addopts]])
\end{minted}

Search for the first match of the regular expression \texttt{r} in \texttt{s} and return a \texttt{RegexMatch} object containing the match, or nothing if the match failed. The matching substring can be retrieved by accessing \texttt{m.match} and the captured sequences can be retrieved by accessing \texttt{m.captures} The optional \texttt{idx} argument specifies an index at which to start the search.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rx = r"a(.)a"
r"a(.)a"

julia> m = match(rx, "cabac")
RegexMatch("aba", 1="b")

julia> m.captures
1-element Array{Union{Nothing, SubString{String}},1}:
 "b"

julia> m.match
"aba"

julia> match(rx, "cabac", 3) === nothing
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/regex.jl#L245-L271}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2810316550892708557}{} 
\hyperlink{2810316550892708557}{\texttt{Base.eachmatch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eachmatch(r::Regex, s::AbstractString; overlap::Bool=false)
\end{minted}

Search for all matches of a the regular expression \texttt{r} in \texttt{s} and return a iterator over the matches. If overlap is \texttt{true}, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from distinct character ranges.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rx = r"a.a"
r"a.a"

julia> m = eachmatch(rx, "a1a2a3a")
Base.RegexMatchIterator(r"a.a", "a1a2a3a", false)

julia> collect(m)
2-element Array{RegexMatch,1}:
 RegexMatch("a1a")
 RegexMatch("a3a")

julia> collect(eachmatch(rx, "a1a2a3a", overlap = true))
3-element Array{RegexMatch,1}:
 RegexMatch("a1a")
 RegexMatch("a2a")
 RegexMatch("a3a")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/regex.jl#L565-L591}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8569460931372581795}{} 
\hyperlink{8569460931372581795}{\texttt{Base.isless}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isless(a::AbstractString, b::AbstractString) -> Bool
\end{minted}

Test whether string \texttt{a} comes before string \texttt{b} in alphabetical order (technically, in lexicographical order by Unicode code points).

\textbf{Examples}


\begin{minted}{jlcon}
julia> isless("a", "b")
true

julia> isless("β", "α")
false

julia> isless("a", "a")
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L297-L314}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1134770895107848480}{} 
\hyperlink{1134770895107848480}{\texttt{Base.:==}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
==(a::AbstractString, b::AbstractString) -> Bool
\end{minted}

Test whether two strings are equal character by character (technically, Unicode code point by code point).

\textbf{Examples}


\begin{minted}{jlcon}
julia> "abc" == "abc"
true

julia> "abc" == "αβγ"
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L280-L294}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3848352610359377999}{} 
\hyperlink{3848352610359377999}{\texttt{Base.cmp}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cmp(a::AbstractString, b::AbstractString) -> Int
\end{minted}

Compare two strings. Return \texttt{0} if both strings have the same length and the character at each index is the same in both strings. Return \texttt{-1} if \texttt{a} is a prefix of \texttt{b}, or if \texttt{a} comes before \texttt{b} in alphabetical order. Return \texttt{1} if \texttt{b} is a prefix of \texttt{a}, or if \texttt{b} comes before \texttt{a} in alphabetical order (technically, lexicographical order by Unicode code points).

\textbf{Examples}


\begin{minted}{jlcon}
julia> cmp("abc", "abc")
0

julia> cmp("ab", "abc")
-1

julia> cmp("abc", "ab")
1

julia> cmp("ab", "ac")
-1

julia> cmp("ac", "ab")
1

julia> cmp("α", "a")
1

julia> cmp("b", "β")
-1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L237-L269}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3722145084740074291}{} 
\hyperlink{3722145084740074291}{\texttt{Base.lpad}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lpad(s, n::Integer, p::Union{AbstractChar,AbstractString}=' ') -> String
\end{minted}

Stringify \texttt{s} and pad the resulting string on the left with \texttt{p} to make it \texttt{n} characters (code points) long. If \texttt{s} is already \texttt{n} characters long, an equal string is returned. Pad with spaces by default.

\textbf{Examples}


\begin{minted}{jlcon}
julia> lpad("March", 10)
"     March"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L226-L238}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12508684325429723537}{} 
\hyperlink{12508684325429723537}{\texttt{Base.rpad}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rpad(s, n::Integer, p::Union{AbstractChar,AbstractString}=' ') -> String
\end{minted}

Stringify \texttt{s} and pad the resulting string on the right with \texttt{p} to make it \texttt{n} characters (code points) long. If \texttt{s} is already \texttt{n} characters long, an equal string is returned. Pad with spaces by default.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rpad("March", 20)
"March               "
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L253-L265}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17790464283749157857}{} 
\hyperlink{17790464283749157857}{\texttt{Base.findfirst}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findfirst(pattern::AbstractString, string::AbstractString)
findfirst(pattern::Regex, string::String)
\end{minted}

Find the first occurrence of \texttt{pattern} in \texttt{string}. Equivalent to \hyperlink{9906000186778518011}{\texttt{findnext(pattern, string, firstindex(s))}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> findfirst("z", "Hello to the world") # returns nothing, but not printed in the REPL

julia> findfirst("Julia", "JuliaLang")
1:5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/search.jl#L89-L103}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2491646810354884982}{} 
\hyperlink{2491646810354884982}{\texttt{Base.findnext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findnext(pattern::AbstractString, string::AbstractString, start::Integer)
findnext(pattern::Regex, string::String, start::Integer)
\end{minted}

Find the next occurrence of \texttt{pattern} in \texttt{string} starting at position \texttt{start}. \texttt{pattern} can be either a string, or a regular expression, in which case \texttt{string} must be of type \texttt{String}.

The return value is a range of indices where the matching sequence is found, such that \texttt{s[findnext(x, s, i)] == x}:

\texttt{findnext({\textquotedbl}substring{\textquotedbl}, string, i)} == \texttt{start:stop} such that \texttt{string[start:stop] == {\textquotedbl}substring{\textquotedbl}} and \texttt{i <= start}, or \texttt{nothing} if unmatched.

\textbf{Examples}


\begin{minted}{jlcon}
julia> findnext("z", "Hello to the world", 1) === nothing
true

julia> findnext("o", "Hello to the world", 6)
8:8

julia> findnext("Lang", "JuliaLang", 2)
6:9
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/search.jl#L249-L274}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17670820783371803126}{} 
\hyperlink{17670820783371803126}{\texttt{Base.findnext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findnext(ch::AbstractChar, string::AbstractString, start::Integer)
\end{minted}

Find the next occurrence of character \texttt{ch} in \texttt{string} starting at position \texttt{start}.

\begin{quote}
\textbf{Julia 1.3}

This method requires at least Julia 1.3.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> findnext('z', "Hello to the world", 1) === nothing
true

julia> findnext('o', "Hello to the world", 6)
8
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/search.jl#L277-L293}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9131404165887186379}{} 
\hyperlink{9131404165887186379}{\texttt{Base.findlast}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findlast(pattern::AbstractString, string::AbstractString)
\end{minted}

Find the last occurrence of \texttt{pattern} in \texttt{string}. Equivalent to \hyperlink{3864667477361062614}{\texttt{findprev(pattern, string, lastindex(string))}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> findlast("o", "Hello to the world")
15:15

julia> findfirst("Julia", "JuliaLang")
1:5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/search.jl#L297-L311}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17692183083231057658}{} 
\hyperlink{17692183083231057658}{\texttt{Base.findlast}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findlast(ch::AbstractChar, string::AbstractString)
\end{minted}

Find the last occurrence of character \texttt{ch} in \texttt{string}.

\begin{quote}
\textbf{Julia 1.3}

This method requires at least Julia 1.3.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> findlast('p', "happy")
4

julia> findlast('z', "happy") === nothing
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/search.jl#L315-L331}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16511176906297413591}{} 
\hyperlink{16511176906297413591}{\texttt{Base.findprev}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findprev(pattern::AbstractString, string::AbstractString, start::Integer)
\end{minted}

Find the previous occurrence of \texttt{pattern} in \texttt{string} starting at position \texttt{start}.

The return value is a range of indices where the matching sequence is found, such that \texttt{s[findprev(x, s, i)] == x}:

\texttt{findprev({\textquotedbl}substring{\textquotedbl}, string, i)} == \texttt{start:stop} such that \texttt{string[start:stop] == {\textquotedbl}substring{\textquotedbl}} and \texttt{stop <= i}, or \texttt{nothing} if unmatched.

\textbf{Examples}


\begin{minted}{jlcon}
julia> findprev("z", "Hello to the world", 18) === nothing
true

julia> findprev("o", "Hello to the world", 18)
15:15

julia> findprev("Julia", "JuliaLang", 6)
1:5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/search.jl#L464-L486}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7988132114328914630}{} 
\hyperlink{7988132114328914630}{\texttt{Base.occursin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
occursin(needle::Union{AbstractString,Regex,AbstractChar}, haystack::AbstractString)
\end{minted}

Determine whether the first argument is a substring of the second. If \texttt{needle} is a regular expression, checks whether \texttt{haystack} contains a match.

\textbf{Examples}


\begin{minted}{jlcon}
julia> occursin("Julia", "JuliaLang is pretty cool!")
true

julia> occursin('a', "JuliaLang is pretty cool!")
true

julia> occursin(r"a.a", "aba")
true

julia> occursin(r"a.a", "abba")
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/search.jl#L509-L529}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14584532121712292440}{} 
\hyperlink{14584532121712292440}{\texttt{Base.reverse}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reverse(s::AbstractString) -> AbstractString
\end{minted}

Reverses a string. Technically, this function reverses the codepoints in a string and its main utility is for reversed-order string processing, especially for reversed regular-expression searches. See also \hyperlink{16812685153025781176}{\texttt{reverseind}} to convert indices in \texttt{s} to indices in \texttt{reverse(s)} and vice-versa, and \texttt{graphemes} from module \texttt{Unicode} to operate on user-visible {\textquotedbl}characters{\textquotedbl} (graphemes) rather than codepoints. See also \hyperlink{12943296479800134710}{\texttt{Iterators.reverse}} for reverse-order iteration without making a copy. Custom string types must implement the \texttt{reverse} function themselves and should typically return a string with the same type and encoding. If they return a string with a different encoding, they must also override \texttt{reverseind} for that string type to satisfy \texttt{s[reverseind(s,i)] == reverse(s)[i]}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> reverse("JuliaLang")
"gnaLailuJ"

julia> reverse("ax̂e") # combining characters can lead to surprising results
"êxa"

julia> using Unicode

julia> join(reverse(collect(graphemes("ax̂e")))) # reverses graphemes
"ex̂a"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/substring.jl#L116-L143}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17541271486456290686}{} 
\hyperlink{17541271486456290686}{\texttt{Base.replace}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
replace(s::AbstractString, pat=>r; [count::Integer])
\end{minted}

Search for the given pattern \texttt{pat} in \texttt{s}, and replace each occurrence with \texttt{r}. If \texttt{count} is provided, replace at most \texttt{count} occurrences. \texttt{pat} may be a single character, a vector or a set of characters, a string, or a regular expression. If \texttt{r} is a function, each occurrence is replaced with \texttt{r(s)} where \texttt{s} is the matched substring (when \texttt{pat} is a \texttt{Regex} or \texttt{AbstractString}) or character (when \texttt{pat} is an \texttt{AbstractChar} or a collection of \texttt{AbstractChar}). If \texttt{pat} is a regular expression and \texttt{r} is a \hyperlink{16275294768422181757}{\texttt{SubstitutionString}}, then capture group references in \texttt{r} are replaced with the corresponding matched text. To remove instances of \texttt{pat} from \texttt{string}, set \texttt{r} to the empty \texttt{String} (\texttt{{\textquotedbl}{\textquotedbl}}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> replace("Python is a programming language.", "Python" => "Julia")
"Julia is a programming language."

julia> replace("The quick foxes run quickly.", "quick" => "slow", count=1)
"The slow foxes run quickly."

julia> replace("The quick foxes run quickly.", "quick" => "", count=1)
"The  foxes run quickly."

julia> replace("The quick foxes run quickly.", r"fox(es)?" => s"bus\1")
"The quick buses run quickly."
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L465-L493}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8368077469888537439}{} 
\hyperlink{8368077469888537439}{\texttt{Base.split}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
split(str::AbstractString, dlm; limit::Integer=0, keepempty::Bool=true)
split(str::AbstractString; limit::Integer=0, keepempty::Bool=false)
\end{minted}

Split \texttt{str} into an array of substrings on occurrences of the delimiter(s) \texttt{dlm}.  \texttt{dlm} can be any of the formats allowed by \hyperlink{9906000186778518011}{\texttt{findnext}}{\textquotesingle}s first argument (i.e. as a string, regular expression or a function), or as a single character or collection of characters.

If \texttt{dlm} is omitted, it defaults to \hyperlink{774253773882022491}{\texttt{isspace}}.

The optional keyword arguments are:

\begin{itemize}
\item \texttt{limit}: the maximum size of the result. \texttt{limit=0} implies no maximum (default)


\item \texttt{keepempty}: whether empty fields should be kept in the result. Default is \texttt{false} without a \texttt{dlm} argument, \texttt{true} with a \texttt{dlm} argument.

\end{itemize}
See also \hyperlink{15507349251888266905}{\texttt{rsplit}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = "Ma.rch"
"Ma.rch"

julia> split(a,".")
2-element Array{SubString{String},1}:
 "Ma"
 "rch"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L280-L308}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15507349251888266905}{} 
\hyperlink{15507349251888266905}{\texttt{Base.rsplit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rsplit(s::AbstractString; limit::Integer=0, keepempty::Bool=false)
rsplit(s::AbstractString, chars; limit::Integer=0, keepempty::Bool=true)
\end{minted}

Similar to \hyperlink{8368077469888537439}{\texttt{split}}, but starting from the end of the string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = "M.a.r.c.h"
"M.a.r.c.h"

julia> rsplit(a,".")
5-element Array{SubString{String},1}:
 "M"
 "a"
 "r"
 "c"
 "h"

julia> rsplit(a,".";limit=1)
1-element Array{SubString{String},1}:
 "M.a.r.c.h"

julia> rsplit(a,".";limit=2)
2-element Array{SubString{String},1}:
 "M.a.r.c"
 "h"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L354-L382}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7002432768371197450}{} 
\hyperlink{7002432768371197450}{\texttt{Base.strip}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
strip([pred=isspace,] str::AbstractString) -> SubString
strip(str::AbstractString, chars) -> SubString
\end{minted}

Remove leading and trailing characters from \texttt{str}, either those specified by \texttt{chars} or those for which the function \texttt{pred} returns \texttt{true}.

The default behaviour is to remove leading whitespace and delimiters: see \hyperlink{774253773882022491}{\texttt{isspace}} for precise details.

The optional \texttt{chars} argument specifies which characters to remove: it can be a single character, vector or set of characters.

\begin{quote}
\textbf{Julia 1.2}

The method which accepts a predicate function requires Julia 1.2 or later.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> strip("{3, 5}\n", ['{', '}', '\n'])
"3, 5"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L198-L219}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7433804272240772935}{} 
\hyperlink{7433804272240772935}{\texttt{Base.lstrip}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lstrip([pred=isspace,] str::AbstractString) -> SubString
lstrip(str::AbstractString, chars) -> SubString
\end{minted}

Remove leading characters from \texttt{str}, either those specified by \texttt{chars} or those for which the function \texttt{pred} returns \texttt{true}.

The default behaviour is to remove leading whitespace and delimiters: see \hyperlink{774253773882022491}{\texttt{isspace}} for precise details.

The optional \texttt{chars} argument specifies which characters to remove: it can be a single character, or a vector or set of characters.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = lpad("March", 20)
"               March"

julia> lstrip(a)
"March"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L135-L156}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8645844793440900923}{} 
\hyperlink{8645844793440900923}{\texttt{Base.rstrip}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rstrip([pred=isspace,] str::AbstractString) -> SubString
rstrip(str::AbstractString, chars) -> SubString
\end{minted}

Remove trailing characters from \texttt{str}, either those specified by \texttt{chars} or those for which the function \texttt{pred} returns \texttt{true}.

The default behaviour is to remove trailing whitespace and delimiters: see \hyperlink{774253773882022491}{\texttt{isspace}} for precise details.

The optional \texttt{chars} argument specifies which characters to remove: it can be a single character, or a vector or set of characters.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = rpad("March", 20)
"March               "

julia> rstrip(a)
"March"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L167-L188}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3780640516028077129}{} 
\hyperlink{3780640516028077129}{\texttt{Base.startswith}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
startswith(s::AbstractString, prefix::AbstractString)
\end{minted}

Return \texttt{true} if \texttt{s} starts with \texttt{prefix}. If \texttt{prefix} is a vector or set of characters, test whether the first character of \texttt{s} belongs to that set.

See also \hyperlink{7763134966257769023}{\texttt{endswith}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> startswith("JuliaLang", "Julia")
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L7-L20}{\texttt{source}}



\begin{lstlisting}
startswith(s::AbstractString, prefix::Regex)
\end{lstlisting}

Return \texttt{true} if \texttt{s} starts with the regex pattern, \texttt{prefix}.

\begin{quote}
\textbf{Note}

\texttt{startswith} does not compile the anchoring into the regular expression, but instead passes the anchoring as \texttt{match\_option} to PCRE. If compile time is amortized, \texttt{occursin(r{\textquotedbl}{\textasciicircum}...{\textquotedbl}, s)} is faster than \texttt{startswith(s, r{\textquotedbl}...{\textquotedbl})}.

\end{quote}
See also \hyperlink{7988132114328914630}{\texttt{occursin}} and \hyperlink{7763134966257769023}{\texttt{endswith}}.

\begin{quote}
\textbf{Julia 1.2}

This method requires at least Julia 1.2.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> startswith("JuliaLang", r"Julia|Romeo")
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/regex.jl#L181-L202}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7763134966257769023}{} 
\hyperlink{7763134966257769023}{\texttt{Base.endswith}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
endswith(s::AbstractString, suffix::AbstractString)
\end{minted}

Return \texttt{true} if \texttt{s} ends with \texttt{suffix}. If \texttt{suffix} is a vector or set of characters, test whether the last character of \texttt{s} belongs to that set.

See also \hyperlink{3780640516028077129}{\texttt{startswith}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> endswith("Sunday", "day")
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L27-L40}{\texttt{source}}



\begin{lstlisting}
endswith(s::AbstractString, suffix::Regex)
\end{lstlisting}

Return \texttt{true} if \texttt{s} ends with the regex pattern, \texttt{suffix}.

\begin{quote}
\textbf{Note}

\texttt{endswith} does not compile the anchoring into the regular expression, but instead passes the anchoring as \texttt{match\_option} to PCRE. If compile time is amortized, \texttt{occursin(r{\textquotedbl}...\${\textquotedbl}, s)} is faster than \texttt{endswith(s, r{\textquotedbl}...{\textquotedbl})}.

\end{quote}
See also \hyperlink{7988132114328914630}{\texttt{occursin}} and \hyperlink{3780640516028077129}{\texttt{startswith}}.

\begin{quote}
\textbf{Julia 1.2}

This method requires at least Julia 1.2.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> endswith("JuliaLang", r"Lang|Roberts")
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/regex.jl#L213-L234}{\texttt{source}}


\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Base.contains}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{10538250976171410519}{} 
\hyperlink{10538250976171410519}{\texttt{Base.first}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
first(s::AbstractString, n::Integer)
\end{minted}

Get a string consisting of the first \texttt{n} characters of \texttt{s}.


\begin{minted}{jlcon}
julia> first("∀ϵ≠0: ϵ²>0", 0)
""

julia> first("∀ϵ≠0: ϵ²>0", 1)
"∀"

julia> first("∀ϵ≠0: ϵ²>0", 3)
"∀ϵ≠"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L596-L611}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14768252027631185795}{} 
\hyperlink{14768252027631185795}{\texttt{Base.last}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
last(s::AbstractString, n::Integer)
\end{minted}

Get a string consisting of the last \texttt{n} characters of \texttt{s}.


\begin{minted}{jlcon}
julia> last("∀ϵ≠0: ϵ²>0", 0)
""

julia> last("∀ϵ≠0: ϵ²>0", 1)
"0"

julia> last("∀ϵ≠0: ϵ²>0", 3)
"²>0"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L614-L629}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3820837624621500945}{} 
\hyperlink{3820837624621500945}{\texttt{Base.Unicode.uppercase}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
uppercase(s::AbstractString)
\end{minted}

Return \texttt{s} with all characters converted to uppercase.

\textbf{Examples}


\begin{minted}{jlcon}
julia> uppercase("Julia")
"JULIA"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L507-L517}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1268691712877286833}{} 
\hyperlink{1268691712877286833}{\texttt{Base.Unicode.lowercase}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lowercase(s::AbstractString)
\end{minted}

Return \texttt{s} with all characters converted to lowercase.

\textbf{Examples}


\begin{minted}{jlcon}
julia> lowercase("STRINGS AND THINGS")
"strings and things"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L520-L530}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4707563025366615926}{} 
\hyperlink{4707563025366615926}{\texttt{Base.Unicode.titlecase}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
titlecase(s::AbstractString; [wordsep::Function], strict::Bool=true) -> String
\end{minted}

Capitalize the first character of each word in \texttt{s}; if \texttt{strict} is true, every other character is converted to lowercase, otherwise they are left unchanged. By default, all non-letters are considered as word separators; a predicate can be passed as the \texttt{wordsep} keyword to determine which characters should be considered as word separators. See also \hyperlink{17133955858733933884}{\texttt{uppercasefirst}} to capitalize only the first character in \texttt{s}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> titlecase("the JULIA programming language")
"The Julia Programming Language"

julia> titlecase("ISS - international space station", strict=false)
"ISS - International Space Station"

julia> titlecase("a-a b-b", wordsep = c->c==' ')
"A-a B-b"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L533-L556}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17133955858733933884}{} 
\hyperlink{17133955858733933884}{\texttt{Base.Unicode.uppercasefirst}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
uppercasefirst(s::AbstractString) -> String
\end{minted}

Return \texttt{s} with the first character converted to uppercase (technically {\textquotedbl}title case{\textquotedbl} for Unicode). See also \hyperlink{4707563025366615926}{\texttt{titlecase}} to capitalize the first character of every word in \texttt{s}.

See also: \hyperlink{8884363915338850304}{\texttt{lowercasefirst}}, \hyperlink{3820837624621500945}{\texttt{uppercase}}, \hyperlink{1268691712877286833}{\texttt{lowercase}}, \hyperlink{4707563025366615926}{\texttt{titlecase}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> uppercasefirst("python")
"Python"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L572-L587}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8884363915338850304}{} 
\hyperlink{8884363915338850304}{\texttt{Base.Unicode.lowercasefirst}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lowercasefirst(s::AbstractString)
\end{minted}

Return \texttt{s} with the first character converted to lowercase.

See also: \hyperlink{17133955858733933884}{\texttt{uppercasefirst}}, \hyperlink{3820837624621500945}{\texttt{uppercase}}, \hyperlink{1268691712877286833}{\texttt{lowercase}}, \hyperlink{4707563025366615926}{\texttt{titlecase}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> lowercasefirst("Julia")
"julia"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L596-L609}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18064910688022011979}{} 
\hyperlink{18064910688022011979}{\texttt{Base.join}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
join([io::IO,] strings [, delim [, last]])
\end{minted}

Join an array of \texttt{strings} into a single string, inserting the given delimiter (if any) between adjacent strings. If \texttt{last} is given, it will be used instead of \texttt{delim} between the last two strings. If \texttt{io} is given, the result is written to \texttt{io} rather than returned as as a \texttt{String}.

\texttt{strings} can be any iterable over elements \texttt{x} which are convertible to strings via \texttt{print(io::IOBuffer, x)}. \texttt{strings} will be printed to \texttt{io}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> join(["apples", "bananas", "pineapples"], ", ", " and ")
"apples, bananas and pineapples"

julia> join([1,2,3,4,5])
"12345"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/io.jl#L254-L273}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18002354026785919806}{} 
\hyperlink{18002354026785919806}{\texttt{Base.chop}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
chop(s::AbstractString; head::Integer = 0, tail::Integer = 1)
\end{minted}

Remove the first \texttt{head} and the last \texttt{tail} characters from \texttt{s}. The call \texttt{chop(s)} removes the last character from \texttt{s}. If it is requested to remove more characters than \texttt{length(s)} then an empty string is returned.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = "March"
"March"

julia> chop(a)
"Marc"

julia> chop(a, head = 1, tail = 2)
"ar"

julia> chop(a, head = 5, tail = 5)
""
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L73-L95}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5360081372937794006}{} 
\hyperlink{5360081372937794006}{\texttt{Base.chomp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
chomp(s::AbstractString) -> SubString
\end{minted}

Remove a single trailing newline from a string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> chomp("Hello\n")
"Hello"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L106-L116}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11299403048911786045}{} 
\hyperlink{11299403048911786045}{\texttt{Base.thisind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
thisind(s::AbstractString, i::Integer) -> Int
\end{minted}

If \texttt{i} is in bounds in \texttt{s} return the index of the start of the character whose encoding code unit \texttt{i} is part of. In other words, if \texttt{i} is the start of a character, return \texttt{i}; if \texttt{i} is not the start of a character, rewind until the start of a character and return that index. If \texttt{i} is equal to 0 or \texttt{ncodeunits(s)+1} return \texttt{i}. In all other cases throw \texttt{BoundsError}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> thisind("α", 0)
0

julia> thisind("α", 1)
1

julia> thisind("α", 2)
1

julia> thisind("α", 3)
3

julia> thisind("α", 4)
ERROR: BoundsError: attempt to access String
  at index [4]
[...]

julia> thisind("α", -1)
ERROR: BoundsError: attempt to access String
  at index [-1]
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L364-L397}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7455293228649070526}{} 
\hyperlink{7455293228649070526}{\texttt{Base.nextind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nextind(str::AbstractString, i::Integer, n::Integer=1) -> Int
\end{minted}

\begin{itemize}
\item Case \texttt{n == 1}

If \texttt{i} is in bounds in \texttt{s} return the index of the start of the character whose encoding starts after index \texttt{i}. In other words, if \texttt{i} is the start of a character, return the start of the next character; if \texttt{i} is not the start of a character, move forward until the start of a character and return that index. If \texttt{i} is equal to \texttt{0} return \texttt{1}. If \texttt{i} is in bounds but greater or equal to \texttt{lastindex(str)} return \texttt{ncodeunits(str)+1}. Otherwise throw \texttt{BoundsError}.


\item Case \texttt{n > 1}

Behaves like applying \texttt{n} times \texttt{nextind} for \texttt{n==1}. The only difference is that if \texttt{n} is so large that applying \texttt{nextind} would reach \texttt{ncodeunits(str)+1} then each remaining iteration increases the returned value by \texttt{1}. This means that in this case \texttt{nextind} can return a value greater than \texttt{ncodeunits(str)+1}.


\item Case \texttt{n == 0}

Return \texttt{i} only if \texttt{i} is a valid index in \texttt{s} or is equal to \texttt{0}. Otherwise \texttt{StringIndexError} or \texttt{BoundsError} is thrown.

\end{itemize}
\textbf{Examples}


\begin{minted}{jlcon}
julia> nextind("α", 0)
1

julia> nextind("α", 1)
3

julia> nextind("α", 3)
ERROR: BoundsError: attempt to access String
  at index [3]
[...]

julia> nextind("α", 0, 2)
3

julia> nextind("α", 1, 2)
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L470-L514}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15871508897466976220}{} 
\hyperlink{15871508897466976220}{\texttt{Base.prevind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
prevind(str::AbstractString, i::Integer, n::Integer=1) -> Int
\end{minted}

\begin{itemize}
\item Case \texttt{n == 1}

If \texttt{i} is in bounds in \texttt{s} return the index of the start of the character whose encoding starts before index \texttt{i}. In other words, if \texttt{i} is the start of a character, return the start of the previous character; if \texttt{i} is not the start of a character, rewind until the start of a character and return that index. If \texttt{i} is equal to \texttt{1} return \texttt{0}. If \texttt{i} is equal to \texttt{ncodeunits(str)+1} return \texttt{lastindex(str)}. Otherwise throw \texttt{BoundsError}.


\item Case \texttt{n > 1}

Behaves like applying \texttt{n} times \texttt{prevind} for \texttt{n==1}. The only difference is that if \texttt{n} is so large that applying \texttt{prevind} would reach \texttt{0} then each remaining iteration decreases the returned value by \texttt{1}. This means that in this case \texttt{prevind} can return a negative value.


\item Case \texttt{n == 0}

Return \texttt{i} only if \texttt{i} is a valid index in \texttt{str} or is equal to \texttt{ncodeunits(str)+1}. Otherwise \texttt{StringIndexError} or \texttt{BoundsError} is thrown.

\end{itemize}
\textbf{Examples}


\begin{minted}{jlcon}
julia> prevind("α", 3)
1

julia> prevind("α", 1)
0

julia> prevind("α", 0)
ERROR: BoundsError: attempt to access String
  at index [0]
[...]

julia> prevind("α", 2, 2)
0

julia> prevind("α", 2, 3)
-1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L410-L454}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16270671982929669109}{} 
\hyperlink{16270671982929669109}{\texttt{Base.Unicode.textwidth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
textwidth(c)
\end{minted}

Give the number of columns needed to print a character.

\textbf{Examples}


\begin{minted}{jlcon}
julia> textwidth('α')
1

julia> textwidth('⛵')
2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L213-L226}{\texttt{source}}



\begin{lstlisting}
textwidth(s::AbstractString)
\end{lstlisting}

Give the number of columns needed to print a string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> textwidth("March")
5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L232-L242}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15093956188358440526}{} 
\hyperlink{15093956188358440526}{\texttt{Base.isascii}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isascii(c::Union{AbstractChar,AbstractString}) -> Bool
\end{minted}

Test whether a character belongs to the ASCII character set, or whether this is true for all elements of a string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isascii('a')
true

julia> isascii('α')
false

julia> isascii("abc")
true

julia> isascii("αβγ")
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L543-L563}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4032541622324391497}{} 
\hyperlink{4032541622324391497}{\texttt{Base.Unicode.iscntrl}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
iscntrl(c::AbstractChar) -> Bool
\end{minted}

Tests whether a character is a control character. Control characters are the non-printing characters of the Latin-1 subset of Unicode.

\textbf{Examples}


\begin{minted}{jlcon}
julia> iscntrl('\x01')
true

julia> iscntrl('a')
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L405-L419}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6749017765435728728}{} 
\hyperlink{6749017765435728728}{\texttt{Base.Unicode.isdigit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isdigit(c::AbstractChar) -> Bool
\end{minted}

Tests whether a character is a decimal digit (0-9).

\textbf{Examples}


\begin{minted}{jlcon}
julia> isdigit('❤')
false

julia> isdigit('9')
true

julia> isdigit('α')
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L336-L352}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12561738838785727067}{} 
\hyperlink{12561738838785727067}{\texttt{Base.Unicode.isletter}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isletter(c::AbstractChar) -> Bool
\end{minted}

Test whether a character is a letter. A character is classified as a letter if it belongs to the Unicode general category Letter, i.e. a character whose category code begins with {\textquotesingle}L{\textquotesingle}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isletter('❤')
false

julia> isletter('α')
true

julia> isletter('9')
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L355-L373}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11243750221058781239}{} 
\hyperlink{11243750221058781239}{\texttt{Base.Unicode.islowercase}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
islowercase(c::AbstractChar) -> Bool
\end{minted}

Tests whether a character is a lowercase letter. A character is classified as lowercase if it belongs to Unicode category Ll, Letter: Lowercase.

\textbf{Examples}


\begin{minted}{jlcon}
julia> islowercase('α')
true

julia> islowercase('Γ')
false

julia> islowercase('❤')
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L276-L294}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12093502248158263869}{} 
\hyperlink{12093502248158263869}{\texttt{Base.Unicode.isnumeric}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isnumeric(c::AbstractChar) -> Bool
\end{minted}

Tests whether a character is numeric. A character is classified as numeric if it belongs to the Unicode general category Number, i.e. a character whose category code begins with {\textquotesingle}N{\textquotesingle}.

Note that this broad category includes characters such as ¾ and ௰. Use \hyperlink{6749017765435728728}{\texttt{isdigit}} to check whether a character a decimal digit between 0 and 9.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isnumeric('௰')
true

julia> isnumeric('9')
true

julia> isnumeric('α')
false

julia> isnumeric('❤')
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L376-L400}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7756178256858757543}{} 
\hyperlink{7756178256858757543}{\texttt{Base.Unicode.isprint}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isprint(c::AbstractChar) -> Bool
\end{minted}

Tests whether a character is printable, including spaces, but not a control character.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isprint('\x01')
false

julia> isprint('A')
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L470-L483}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12870722043550444957}{} 
\hyperlink{12870722043550444957}{\texttt{Base.Unicode.ispunct}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ispunct(c::AbstractChar) -> Bool
\end{minted}

Tests whether a character belongs to the Unicode general category Punctuation, i.e. a character whose category code begins with {\textquotesingle}P{\textquotesingle}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ispunct('α')
false

julia> ispunct('/')
true

julia> ispunct(';')
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L422-L439}{\texttt{source}}


\end{adjustwidth}
\hypertarget{774253773882022491}{} 
\hyperlink{774253773882022491}{\texttt{Base.Unicode.isspace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isspace(c::AbstractChar) -> Bool
\end{minted}

Tests whether a character is any whitespace character. Includes ASCII characters {\textquotesingle}{\textbackslash}t{\textquotesingle}, {\textquotesingle}{\textbackslash}n{\textquotesingle}, {\textquotesingle}{\textbackslash}v{\textquotesingle}, {\textquotesingle}{\textbackslash}f{\textquotesingle}, {\textquotesingle}{\textbackslash}r{\textquotesingle}, and {\textquotesingle} {\textquotesingle}, Latin-1 character U+0085, and characters in Unicode category Zs.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isspace('\n')
true

julia> isspace('\r')
true

julia> isspace(' ')
true

julia> isspace('\x20')
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L444-L465}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1249092202955861802}{} 
\hyperlink{1249092202955861802}{\texttt{Base.Unicode.isuppercase}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isuppercase(c::AbstractChar) -> Bool
\end{minted}

Tests whether a character is an uppercase letter. A character is classified as uppercase if it belongs to Unicode category Lu, Letter: Uppercase, or Lt, Letter: Titlecase.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isuppercase('γ')
false

julia> isuppercase('Γ')
true

julia> isuppercase('❤')
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L299-L317}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13818528006711193037}{} 
\hyperlink{13818528006711193037}{\texttt{Base.Unicode.isxdigit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isxdigit(c::AbstractChar) -> Bool
\end{minted}

Test whether a character is a valid hexadecimal digit. Note that this does not include \texttt{x} (as in the standard \texttt{0x} prefix).

\textbf{Examples}


\begin{minted}{jlcon}
julia> isxdigit('a')
true

julia> isxdigit('x')
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L488-L502}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2720373307114882969}{} 
\hyperlink{2720373307114882969}{\texttt{Base.escape\_string}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
escape_string(str::AbstractString[, esc])::AbstractString
escape_string(io, str::AbstractString[, esc::])::Nothing
\end{minted}

General escaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to \texttt{io}.

Backslashes (\texttt{{\textbackslash}}) are escaped with a double-backslash (\texttt{{\textquotedbl}{\textbackslash}{\textbackslash}{\textquotedbl}}). Non-printable characters are escaped either with their standard C escape codes, \texttt{{\textquotedbl}{\textbackslash}0{\textquotedbl}} for NUL (if unambiguous), unicode code point (\texttt{{\textquotedbl}{\textbackslash}u{\textquotedbl}} prefix) or hex (\texttt{{\textquotedbl}{\textbackslash}x{\textquotedbl}} prefix).

The optional \texttt{esc} argument specifies any additional characters that should also be escaped by a prepending backslash (\texttt{{\textquotedbl}} is also escaped by default in the first form).

\textbf{Examples}


\begin{minted}{jlcon}
julia> escape_string("aaa\nbbb")
"aaa\\nbbb"

julia> escape_string("\xfe\xff") # invalid utf-8
"\\xfe\\xff"

julia> escape_string(string('\u2135','\0')) # unambiguous
"ℵ\\0"

julia> escape_string(string('\u2135','\0','0')) # \0 would be ambiguous
"ℵ\\x000"
\end{minted}

\textbf{See also}

\hyperlink{4382494947698149975}{\texttt{unescape\_string}} for the reverse operation.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/io.jl#L310-L341}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4382494947698149975}{} 
\hyperlink{4382494947698149975}{\texttt{Base.unescape\_string}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unescape_string(str::AbstractString, keep = ())::AbstractString
unescape_string(io, s::AbstractString, keep = ())::Nothing
\end{minted}

General unescaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to \texttt{io}. The argument \texttt{keep} specifies a collection of characters which (along with backlashes) are to be kept as they are.

The following escape sequences are recognised:

\begin{itemize}
\item Escaped backslash (\texttt{{\textbackslash}{\textbackslash}})


\item Escaped double-quote (\texttt{{\textbackslash}{\textquotedbl}})


\item Standard C escape sequences (\texttt{{\textbackslash}a}, \texttt{{\textbackslash}b}, \texttt{{\textbackslash}t}, \texttt{{\textbackslash}n}, \texttt{{\textbackslash}v}, \texttt{{\textbackslash}f}, \texttt{{\textbackslash}r}, \texttt{{\textbackslash}e})


\item Unicode BMP code points (\texttt{{\textbackslash}u} with 1-4 trailing hex digits)


\item All Unicode code points (\texttt{{\textbackslash}U} with 1-8 trailing hex digits; max value = 0010ffff)


\item Hex bytes (\texttt{{\textbackslash}x} with 1-2 trailing hex digits)


\item Octal bytes (\texttt{{\textbackslash}} with 1-3 trailing octal digits)

\end{itemize}
\textbf{Examples}


\begin{minted}{jlcon}
julia> unescape_string("aaa\\nbbb") # C escape sequence
"aaa\nbbb"

julia> unescape_string("\\u03c0") # unicode
"π"

julia> unescape_string("\\101") # octal
"A"

julia> unescape_string("aaa \\g \\n", ['g']) # using `keep` argument
"aaa \\g \n"
\end{minted}

\textbf{See also}

\hyperlink{2720373307114882969}{\texttt{escape\_string}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/io.jl#L380-L415}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14629781252390713372}{}


\chapter{数组}



\hypertarget{4417167577090041953}{}


\section{构造函数与类型}


\hypertarget{6514416309183787338}{} 
\hyperlink{6514416309183787338}{\texttt{Core.AbstractArray}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractArray{T,N}
\end{minted}

Supertype for \texttt{N}-dimensional arrays (or array-like types) with elements of type \texttt{T}. \hyperlink{15492651498431872487}{\texttt{Array}} and other types are subtypes of this. See the manual section on the \hyperlink{9718377734213742156}{\texttt{AbstractArray} interface}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L5-L11}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12517057979818647811}{} 
\hyperlink{12517057979818647811}{\texttt{Base.AbstractVector}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractVector{T}
\end{minted}

Supertype for one-dimensional arrays (or array-like types) with elements of type \texttt{T}. Alias for \hyperlink{6514416309183787338}{\texttt{AbstractArray\{T,1\}}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L17-L22}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17966587371929951201}{} 
\hyperlink{17966587371929951201}{\texttt{Base.AbstractMatrix}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractMatrix{T}
\end{minted}

Supertype for two-dimensional arrays (or array-like types) with elements of type \texttt{T}. Alias for \hyperlink{6514416309183787338}{\texttt{AbstractArray\{T,2\}}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L25-L30}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1242753619689895999}{} 
\hyperlink{1242753619689895999}{\texttt{Base.AbstractVecOrMat}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractVecOrMat{T}
\end{minted}

Union type of \hyperlink{12517057979818647811}{\texttt{AbstractVector\{T\}}} and \hyperlink{17966587371929951201}{\texttt{AbstractMatrix\{T\}}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L33-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15492651498431872487}{} 
\hyperlink{15492651498431872487}{\texttt{Core.Array}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Array{T,N} <: AbstractArray{T,N}
\end{minted}

\texttt{N}-dimensional dense array with elements of type \texttt{T}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L45-L49}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16608354292334711958}{} 
\hyperlink{16608354292334711958}{\texttt{Core.Array}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Array{T}(undef, dims)
Array{T,N}(undef, dims)
\end{minted}

Construct an uninitialized \texttt{N}-dimensional \hyperlink{15492651498431872487}{\texttt{Array}} containing elements of type \texttt{T}. \texttt{N} can either be supplied explicitly, as in \texttt{Array\{T,N\}(undef, dims)}, or be determined by the length or number of \texttt{dims}. \texttt{dims} may be a tuple or a series of integer arguments corresponding to the lengths in each dimension. If the rank \texttt{N} is supplied explicitly, then it must match the length or number of \texttt{dims}. See \hyperlink{5151602251166445554}{\texttt{undef}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = Array{Float64,2}(undef, 2, 3) # N given explicitly
2×3 Array{Float64,2}:
 6.90198e-310  6.90198e-310  6.90198e-310
 6.90198e-310  6.90198e-310  0.0

julia> B = Array{Float64}(undef, 2) # N determined by the input
2-element Array{Float64,1}:
 1.87103e-320
 0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1824-L1847}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7218323500801746536}{} 
\hyperlink{7218323500801746536}{\texttt{Core.Array}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Array{T}(nothing, dims)
Array{T,N}(nothing, dims)
\end{minted}

Construct an \texttt{N}-dimensional \hyperlink{15492651498431872487}{\texttt{Array}} containing elements of type \texttt{T}, initialized with \hyperlink{9331422207248206047}{\texttt{nothing}} entries. Element type \texttt{T} must be able to hold these values, i.e. \texttt{Nothing <: T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Array{Union{Nothing, String}}(nothing, 2)
2-element Array{Union{Nothing, String},1}:
 nothing
 nothing

julia> Array{Union{Nothing, Int}}(nothing, 2, 3)
2×3 Array{Union{Nothing, Int64},2}:
 nothing  nothing  nothing
 nothing  nothing  nothing
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1850-L1870}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12823362688708528916}{} 
\hyperlink{12823362688708528916}{\texttt{Core.Array}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Array{T}(missing, dims)
Array{T,N}(missing, dims)
\end{minted}

Construct an \texttt{N}-dimensional \hyperlink{15492651498431872487}{\texttt{Array}} containing elements of type \texttt{T}, initialized with \hyperlink{14596725676261444434}{\texttt{missing}} entries. Element type \texttt{T} must be able to hold these values, i.e. \texttt{Missing <: T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Array{Union{Missing, String}}(missing, 2)
2-element Array{Union{Missing, String},1}:
 missing
 missing

julia> Array{Union{Missing, Int}}(missing, 2, 3)
2×3 Array{Union{Missing, Int64},2}:
 missing  missing  missing
 missing  missing  missing
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1874-L1894}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9570767809940895771}{} 
\hyperlink{9570767809940895771}{\texttt{Core.UndefInitializer}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UndefInitializer
\end{minted}

Singleton type used in array initialization, indicating the array-constructor-caller would like an uninitialized array. See also \hyperlink{5151602251166445554}{\texttt{undef}}, an alias for \texttt{UndefInitializer()}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Array{Float64,1}(UndefInitializer(), 3)
3-element Array{Float64,1}:
 2.2752528595e-314
 2.202942107e-314
 2.275252907e-314
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1897-L1912}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5151602251166445554}{} 
\hyperlink{5151602251166445554}{\texttt{Core.undef}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
undef
\end{minted}

Alias for \texttt{UndefInitializer()}, which constructs an instance of the singleton type \hyperlink{9570767809940895771}{\texttt{UndefInitializer}}, used in array initialization to indicate the array-constructor-caller would like an uninitialized array.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Array{Float64,1}(undef, 3)
3-element Array{Float64,1}:
 2.2752528595e-314
 2.202942107e-314
 2.275252907e-314
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1915-L1930}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10571362059486397014}{} 
\hyperlink{10571362059486397014}{\texttt{Base.Vector}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Vector{T} <: AbstractVector{T}
\end{minted}

One-dimensional dense array with elements of type \texttt{T}, often used to represent a mathematical vector. Alias for \hyperlink{15492651498431872487}{\texttt{Array\{T,1\}}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L52-L57}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11314200556699527986}{} 
\hyperlink{11314200556699527986}{\texttt{Base.Vector}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Vector{T}(undef, n)
\end{minted}

Construct an uninitialized \hyperlink{10571362059486397014}{\texttt{Vector\{T\}}} of length \texttt{n}. See \hyperlink{5151602251166445554}{\texttt{undef}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Vector{Float64}(undef, 3)
3-element Array{Float64,1}:
 6.90966e-310
 6.90966e-310
 6.90966e-310
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1725-L1738}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8846296074574617607}{} 
\hyperlink{8846296074574617607}{\texttt{Base.Vector}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Vector{T}(nothing, m)
\end{minted}

Construct a \hyperlink{10571362059486397014}{\texttt{Vector\{T\}}} of length \texttt{m}, initialized with \hyperlink{9331422207248206047}{\texttt{nothing}} entries. Element type \texttt{T} must be able to hold these values, i.e. \texttt{Nothing <: T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Vector{Union{Nothing, String}}(nothing, 2)
2-element Array{Union{Nothing, String},1}:
 nothing
 nothing
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1741-L1755}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4511365004580822281}{} 
\hyperlink{4511365004580822281}{\texttt{Base.Vector}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Vector{T}(missing, m)
\end{minted}

Construct a \hyperlink{10571362059486397014}{\texttt{Vector\{T\}}} of length \texttt{m}, initialized with \hyperlink{14596725676261444434}{\texttt{missing}} entries. Element type \texttt{T} must be able to hold these values, i.e. \texttt{Missing <: T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Vector{Union{Missing, String}}(missing, 2)
2-element Array{Union{Missing, String},1}:
 missing
 missing
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1758-L1772}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5448927444601277512}{} 
\hyperlink{5448927444601277512}{\texttt{Base.Matrix}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Matrix{T} <: AbstractMatrix{T}
\end{minted}

Two-dimensional dense array with elements of type \texttt{T}, often used to represent a mathematical matrix. Alias for \hyperlink{15492651498431872487}{\texttt{Array\{T,2\}}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L60-L65}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12196830356379655838}{} 
\hyperlink{12196830356379655838}{\texttt{Base.Matrix}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Matrix{T}(undef, m, n)
\end{minted}

Construct an uninitialized \hyperlink{5448927444601277512}{\texttt{Matrix\{T\}}} of size \texttt{m}×\texttt{n}. See \hyperlink{5151602251166445554}{\texttt{undef}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Matrix{Float64}(undef, 2, 3)
2×3 Array{Float64,2}:
 6.93517e-310  6.93517e-310  6.93517e-310
 6.93517e-310  6.93517e-310  1.29396e-320
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1775-L1787}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12588731237614698381}{} 
\hyperlink{12588731237614698381}{\texttt{Base.Matrix}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Matrix{T}(nothing, m, n)
\end{minted}

Construct a \hyperlink{5448927444601277512}{\texttt{Matrix\{T\}}} of size \texttt{m}×\texttt{n}, initialized with \hyperlink{9331422207248206047}{\texttt{nothing}} entries. Element type \texttt{T} must be able to hold these values, i.e. \texttt{Nothing <: T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Matrix{Union{Nothing, String}}(nothing, 2, 3)
2×3 Array{Union{Nothing, String},2}:
 nothing  nothing  nothing
 nothing  nothing  nothing
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1790-L1804}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10540962728142918076}{} 
\hyperlink{10540962728142918076}{\texttt{Base.Matrix}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Matrix{T}(missing, m, n)
\end{minted}

Construct a \hyperlink{5448927444601277512}{\texttt{Matrix\{T\}}} of size \texttt{m}×\texttt{n}, initialized with \hyperlink{14596725676261444434}{\texttt{missing}} entries. Element type \texttt{T} must be able to hold these values, i.e. \texttt{Missing <: T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Matrix{Union{Missing, String}}(missing, 2, 3)
2×3 Array{Union{Missing, String},2}:
 missing  missing  missing
 missing  missing  missing
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1807-L1821}{\texttt{source}}


\end{adjustwidth}
\hypertarget{445304492601262393}{} 
\hyperlink{445304492601262393}{\texttt{Base.VecOrMat}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
VecOrMat{T}
\end{minted}

Union type of \hyperlink{10571362059486397014}{\texttt{Vector\{T\}}} and \hyperlink{5448927444601277512}{\texttt{Matrix\{T\}}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L67-L71}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9999901851371131327}{} 
\hyperlink{9999901851371131327}{\texttt{Core.DenseArray}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DenseArray{T, N} <: AbstractArray{T,N}
\end{minted}

\texttt{N}-dimensional dense array with elements of type \texttt{T}. The elements of a dense array are stored contiguously in memory.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L74-L79}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12295200244111521486}{} 
\hyperlink{12295200244111521486}{\texttt{Base.DenseVector}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DenseVector{T}
\end{minted}

One-dimensional \hyperlink{9999901851371131327}{\texttt{DenseArray}} with elements of type \texttt{T}. Alias for \texttt{DenseArray\{T,1\}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L82-L86}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14980162445656578339}{} 
\hyperlink{14980162445656578339}{\texttt{Base.DenseMatrix}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DenseMatrix{T}
\end{minted}

Two-dimensional \hyperlink{9999901851371131327}{\texttt{DenseArray}} with elements of type \texttt{T}. Alias for \texttt{DenseArray\{T,2\}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L89-L93}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11093696735728490715}{} 
\hyperlink{11093696735728490715}{\texttt{Base.DenseVecOrMat}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DenseVecOrMat{T}
\end{minted}

Union type of \hyperlink{12295200244111521486}{\texttt{DenseVector\{T\}}} and \hyperlink{14980162445656578339}{\texttt{DenseMatrix\{T\}}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L96-L100}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14336154597485782910}{} 
\hyperlink{14336154597485782910}{\texttt{Base.StridedArray}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
StridedArray{T, N}
\end{minted}

An \texttt{N} dimensional \emph{strided} array with elements of type \texttt{T}. These arrays follow the \hyperlink{3010450308855105276}{strided array interface}. If \texttt{A} is a \texttt{StridedArray}, then its elements are stored in memory with offsets, which may vary between dimensions but are constant within a dimension. For example, \texttt{A} could have stride 2 in dimension 1, and stride 3 in dimension 2. Incrementing \texttt{A} along dimension \texttt{d} jumps in memory by [\texttt{strides(A, d)}] slots. Strided arrays are particularly important and useful because they can sometimes be passed directly as pointers to foreign language libraries like BLAS.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2286-L2297}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18350706206094827862}{} 
\hyperlink{18350706206094827862}{\texttt{Base.StridedVector}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
StridedVector{T}
\end{minted}

One dimensional \hyperlink{14336154597485782910}{\texttt{StridedArray}} with elements of type \texttt{T}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2300-L2304}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3855703768476610836}{} 
\hyperlink{3855703768476610836}{\texttt{Base.StridedMatrix}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
StridedMatrix{T}
\end{minted}

Two dimensional \hyperlink{14336154597485782910}{\texttt{StridedArray}} with elements of type \texttt{T}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2307-L2311}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1581729656055818973}{} 
\hyperlink{1581729656055818973}{\texttt{Base.StridedVecOrMat}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
StridedVecOrMat{T}
\end{minted}

Union type of \hyperlink{18350706206094827862}{\texttt{StridedVector}} and \hyperlink{3855703768476610836}{\texttt{StridedMatrix}} with elements of type \texttt{T}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2314-L2318}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2839226020402435013}{} 
\hyperlink{2839226020402435013}{\texttt{Base.getindex}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getindex(type[, elements...])
\end{minted}

Construct a 1-d array of the specified type. This is usually called with the syntax \texttt{Type[]}. Element values can be specified using \texttt{Type[a,b,c,...]}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Int8[1, 2, 3]
3-element Array{Int8,1}:
 1
 2
 3

julia> getindex(Int8, 1, 2, 3)
3-element Array{Int8,1}:
 1
 2
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L365-L385}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13837674686090348619}{} 
\hyperlink{13837674686090348619}{\texttt{Base.zeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
zeros([T=Float64,] dims::Tuple)
zeros([T=Float64,] dims...)
\end{minted}

Create an \texttt{Array}, with element type \texttt{T}, of all zeros with size specified by \texttt{dims}. See also \hyperlink{2836152204730819918}{\texttt{fill}}, \hyperlink{5858390260510292771}{\texttt{ones}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> zeros(1)
1-element Array{Float64,1}:
 0.0

julia> zeros(Int8, 2, 3)
2×3 Array{Int8,2}:
 0  0  0
 0  0  0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L455-L473}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5858390260510292771}{} 
\hyperlink{5858390260510292771}{\texttt{Base.ones}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ones([T=Float64,] dims::Tuple)
ones([T=Float64,] dims...)
\end{minted}

Create an \texttt{Array}, with element type \texttt{T}, of all ones with size specified by \texttt{dims}. See also: \hyperlink{2836152204730819918}{\texttt{fill}}, \hyperlink{13837674686090348619}{\texttt{zeros}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ones(1,2)
1×2 Array{Float64,2}:
 1.0  1.0

julia> ones(ComplexF64, 2, 3)
2×3 Array{Complex{Float64},2}:
 1.0+0.0im  1.0+0.0im  1.0+0.0im
 1.0+0.0im  1.0+0.0im  1.0+0.0im
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L476-L494}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18015155802543401629}{} 
\hyperlink{18015155802543401629}{\texttt{Base.BitArray}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
BitArray{N} <: AbstractArray{Bool, N}
\end{minted}

Space-efficient \texttt{N}-dimensional boolean array, using just one bit for each boolean value.

\texttt{BitArray}s pack up to 64 values into every 8 bytes, resulting in an 8x space efficiency over \texttt{Array\{Bool, N\}} and allowing some operations to work on 64 values at once.

By default, Julia returns \texttt{BitArrays} from \href{@ref Broadcasting}{broadcasting} operations that generate boolean elements (including dotted-comparisons like \texttt{.==}) as well as from the functions \hyperlink{12844393578243965152}{\texttt{trues}} and \hyperlink{12518029339635756199}{\texttt{falses}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/bitarray.jl#L7-L18}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2664788023587904444}{} 
\hyperlink{2664788023587904444}{\texttt{Base.BitArray}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
BitArray(undef, dims::Integer...)
BitArray{N}(undef, dims::NTuple{N,Int})
\end{minted}

Construct an undef \hyperlink{18015155802543401629}{\texttt{BitArray}} with the given dimensions. Behaves identically to the \hyperlink{15492651498431872487}{\texttt{Array}} constructor. See \hyperlink{5151602251166445554}{\texttt{undef}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> BitArray(undef, 2, 2)
2×2 BitArray{2}:
 0  0
 0  0

julia> BitArray(undef, (3, 1))
3×1 BitArray{2}:
 0
 0
 0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/bitarray.jl#L43-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17297916140801761844}{} 
\hyperlink{17297916140801761844}{\texttt{Base.BitArray}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
BitArray(itr)
\end{minted}

Construct a \hyperlink{18015155802543401629}{\texttt{BitArray}} generated by the given iterable object. The shape is inferred from the \texttt{itr} object.

\textbf{Examples}


\begin{minted}{jlcon}
julia> BitArray([1 0; 0 1])
2×2 BitArray{2}:
 1  0
 0  1

julia> BitArray(x+y == 3 for x = 1:2, y = 1:3)
2×3 BitArray{2}:
 0  1  0
 1  0  0

julia> BitArray(x+y == 3 for x = 1:2 for y = 1:3)
6-element BitArray{1}:
 0
 1
 0
 1
 0
 0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/bitarray.jl#L539-L566}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12844393578243965152}{} 
\hyperlink{12844393578243965152}{\texttt{Base.trues}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trues(dims)
\end{minted}

Create a \texttt{BitArray} with all values set to \texttt{true}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> trues(2,3)
2×3 BitArray{2}:
 1  1  1
 1  1  1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/bitarray.jl#L403-L415}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12518029339635756199}{} 
\hyperlink{12518029339635756199}{\texttt{Base.falses}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
falses(dims)
\end{minted}

Create a \texttt{BitArray} with all values set to \texttt{false}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> falses(2,3)
2×3 BitArray{2}:
 0  0  0
 0  0  0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/bitarray.jl#L385-L397}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2836152204730819918}{} 
\hyperlink{2836152204730819918}{\texttt{Base.fill}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fill(x, dims::Tuple)
fill(x, dims...)
\end{minted}

Create an array filled with the value \texttt{x}. For example, \texttt{fill(1.0, (5,5))} returns a 5×5 array of floats, with each element initialized to \texttt{1.0}.

\texttt{dims} may be specified as either a tuple or a sequence of arguments. For example, the common idiom \texttt{fill(x)} creates a zero-dimensional array containing the single value \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> fill(1.0, (5,5))
5×5 Array{Float64,2}:
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0

julia> fill(0.5, 1, 2)
1×2 Array{Float64,2}:
 0.5  0.5

julia> fill(42)
0-dimensional Array{Int64,0}:
42
\end{minted}

If \texttt{x} is an object reference, all elements will refer to the same object. \texttt{fill(Foo(), dims)} will return an array filled with the result of evaluating \texttt{Foo()} once.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L416-L447}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5162290739791026948}{} 
\hyperlink{5162290739791026948}{\texttt{Base.fill!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fill!(A, x)
\end{minted}

Fill array \texttt{A} with the value \texttt{x}. If \texttt{x} is an object reference, all elements will refer to the same object. \texttt{fill!(A, Foo())} will return \texttt{A} filled with the result of evaluating \texttt{Foo()} once.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = zeros(2,3)
2×3 Array{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0

julia> fill!(A, 2.)
2×3 Array{Float64,2}:
 2.0  2.0  2.0
 2.0  2.0  2.0

julia> a = [1, 1, 1]; A = fill!(Vector{Vector{Int}}(undef, 3), a); a[1] = 2; A
3-element Array{Array{Int64,1},1}:
 [2, 1, 1]
 [2, 1, 1]
 [2, 1, 1]

julia> x = 0; f() = (global x += 1; x); fill!(Vector{Int}(undef, 3), f())
3-element Array{Int64,1}:
 1
 1
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L889-L920}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15525808546723795098}{} 
\hyperlink{15525808546723795098}{\texttt{Base.similar}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
similar(array, [element_type=eltype(array)], [dims=size(array)])
\end{minted}

Create an uninitialized mutable array with the given element type and size, based upon the given source array. The second and third arguments are both optional, defaulting to the given array{\textquotesingle}s \texttt{eltype} and \texttt{size}. The dimensions may be specified either as a single tuple argument or as a series of integer arguments.

Custom AbstractArray subtypes may choose which specific array type is best-suited to return for the given element type and dimensionality. If they do not specialize this method, the default is an \texttt{Array\{element\_type\}(undef, dims...)}.

For example, \texttt{similar(1:10, 1, 4)} returns an uninitialized \texttt{Array\{Int,2\}} since ranges are neither mutable nor support 2 dimensions:


\begin{minted}{jlcon}
julia> similar(1:10, 1, 4)
1×4 Array{Int64,2}:
 4419743872  4374413872  4419743888  0
\end{minted}

Conversely, \texttt{similar(trues(10,10), 2)} returns an uninitialized \texttt{BitVector} with two elements since \texttt{BitArray}s are both mutable and can support 1-dimensional arrays:


\begin{minted}{jlcon}
julia> similar(trues(10,10), 2)
2-element BitArray{1}:
 0
 0
\end{minted}

Since \texttt{BitArray}s can only store elements of type \hyperlink{46725311238864537}{\texttt{Bool}}, however, if you request a different element type it will create a regular \texttt{Array} instead:


\begin{minted}{jlcon}
julia> similar(falses(10), Float64, 2, 4)
2×4 Array{Float64,2}:
 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314
 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L582-L623}{\texttt{source}}



\begin{lstlisting}
similar(storagetype, axes)
\end{lstlisting}

Create an uninitialized mutable array analogous to that specified by \texttt{storagetype}, but with \texttt{axes} specified by the last argument. \texttt{storagetype} might be a type or a function.

\textbf{Examples}:


\begin{lstlisting}
similar(Array{Int}, axes(A))
\end{lstlisting}

creates an array that {\textquotedbl}acts like{\textquotedbl} an \texttt{Array\{Int\}} (and might indeed be backed by one), but which is indexed identically to \texttt{A}. If \texttt{A} has conventional indexing, this will be identical to \texttt{Array\{Int\}(undef, size(A))}, but if \texttt{A} has unconventional indexing then the indices of the result will match \texttt{A}.


\begin{lstlisting}
similar(BitArray, (axes(A, 2),))
\end{lstlisting}

would create a 1-dimensional logical array whose indices match those of the columns of \texttt{A}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L647-L668}{\texttt{source}}


\end{adjustwidth}

\hypertarget{9348596862671224476}{}


\section{基础函数}


\hypertarget{1688406579181746010}{} 
\hyperlink{1688406579181746010}{\texttt{Base.ndims}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ndims(A::AbstractArray) -> Integer
\end{minted}

Return the number of dimensions of \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = fill(1, (3,4,5));

julia> ndims(A)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L155-L167}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17888996102305087038}{} 
\hyperlink{17888996102305087038}{\texttt{Base.size}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
size(A::AbstractArray, [dim])
\end{minted}

Return a tuple containing the dimensions of \texttt{A}. Optionally you can specify a dimension to just get the length of that dimension.

Note that \texttt{size} may not be defined for arrays with non-standard indices, in which case \hyperlink{7074821531920287868}{\texttt{axes}} may be useful. See the manual chapter on \hyperlink{1238988360302116626}{arrays with custom indices}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = fill(1, (2,3,4));

julia> size(A)
(2, 3, 4)

julia> size(A, 2)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L18-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7074821531920287868}{} 
\hyperlink{7074821531920287868}{\texttt{Base.axes}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
axes(A)
\end{minted}

Return the tuple of valid indices for array \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = fill(1, (5,6,7));

julia> axes(A)
(Base.OneTo(5), Base.OneTo(6), Base.OneTo(7))
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L60-L72}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9203019773133814597}{} 
\hyperlink{9203019773133814597}{\texttt{Base.axes}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
axes(A, d)
\end{minted}

Return the valid range of indices for array \texttt{A} along dimension \texttt{d}.

See also \hyperlink{17888996102305087038}{\texttt{size}}, and the manual chapter on \hyperlink{1238988360302116626}{arrays with custom indices}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = fill(1, (5,6,7));

julia> axes(A, 2)
Base.OneTo(6)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L40-L54}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3699181304419743826}{} 
\hyperlink{3699181304419743826}{\texttt{Base.length}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
length(A::AbstractArray)
\end{minted}

Return the number of elements in the array, defaults to \texttt{prod(size(A))}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> length([1, 2, 3, 4])
4

julia> length([1 2; 3 4])
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L192-L205}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4701773772897287974}{} 
\hyperlink{4701773772897287974}{\texttt{Base.eachindex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eachindex(A...)
\end{minted}

Create an iterable object for visiting each index of an \texttt{AbstractArray} \texttt{A} in an efficient manner. For array types that have opted into fast linear indexing (like \texttt{Array}), this is simply the range \texttt{1:length(A)}. For other array types, return a specialized Cartesian range to efficiently index into the array with indices specified for every dimension. For other iterables, including strings and dictionaries, return an iterator object supporting arbitrary index types (e.g. unevenly spaced or non-integer indices).

If you supply more than one \texttt{AbstractArray} argument, \texttt{eachindex} will create an iterable object that is fast for all arguments (a \hyperlink{9165955949298153694}{\texttt{UnitRange}} if all inputs have fast linear indexing, a \hyperlink{16831958174907250244}{\texttt{CartesianIndices}} otherwise). If the arrays have different sizes and/or dimensionalities, a DimensionMismatch exception will be thrown.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4];

julia> for i in eachindex(A) # linear indexing
           println(i)
       end
1
2
3
4

julia> for i in eachindex(view(A, 1:2, 1:1)) # Cartesian indexing
           println(i)
       end
CartesianIndex(1, 1)
CartesianIndex(2, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L221-L255}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7782790551324367092}{} 
\hyperlink{7782790551324367092}{\texttt{Base.IndexStyle}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IndexStyle(A)
IndexStyle(typeof(A))
\end{minted}

\texttt{IndexStyle} specifies the {\textquotedbl}native indexing style{\textquotedbl} for array \texttt{A}. When you define a new \hyperlink{6514416309183787338}{\texttt{AbstractArray}} type, you can choose to implement either linear indexing (with \hyperlink{1761039776681330940}{\texttt{IndexLinear}}) or cartesian indexing. If you decide to only implement linear indexing, then you must set this trait for your array type:


\begin{lstlisting}
Base.IndexStyle(::Type{<:MyArray}) = IndexLinear()
\end{lstlisting}

The default is \hyperlink{4052302263500310575}{\texttt{IndexCartesian()}}.

Julia{\textquotesingle}s internal indexing machinery will automatically (and invisibly) recompute all indexing operations into the preferred style. This allows users to access elements of your array using any indexing style, even when explicit methods have not been provided.

If you define both styles of indexing for your \texttt{AbstractArray}, this trait can be used to select the most performant indexing style. Some methods check this trait on their inputs, and dispatch to different algorithms depending on the most efficient access pattern. In particular, \hyperlink{4701773772897287974}{\texttt{eachindex}} creates an iterator whose type depends on the setting of this trait.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/indices.jl#L68-L93}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1761039776681330940}{} 
\hyperlink{1761039776681330940}{\texttt{Base.IndexLinear}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IndexLinear()
\end{minted}

Subtype of \hyperlink{7782790551324367092}{\texttt{IndexStyle}} used to describe arrays which are optimally indexed by one linear index.

A linear indexing style uses one integer index to describe the position in the array (even if it{\textquotesingle}s a multidimensional array) and column-major ordering is used to efficiently access the elements. This means that requesting \hyperlink{4701773772897287974}{\texttt{eachindex}} from an array that is \texttt{IndexLinear} will return a simple one-dimensional range, even if it is multidimensional.

A custom array that reports its \texttt{IndexStyle} as \texttt{IndexLinear} only needs to implement indexing (and indexed assignment) with a single \texttt{Int} index; all other indexing expressions — including multidimensional accesses — will be recomputed to the linear index.  For example, if \texttt{A} were a \texttt{2×3} custom matrix with linear indexing, and we referenced \texttt{A[1, 3]}, this would be recomputed to the equivalent linear index and call \texttt{A[5]} since \texttt{2*1 + 3 = 5}.

See also \hyperlink{4052302263500310575}{\texttt{IndexCartesian}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/indices.jl#L16-L36}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4052302263500310575}{} 
\hyperlink{4052302263500310575}{\texttt{Base.IndexCartesian}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IndexCartesian()
\end{minted}

Subtype of \hyperlink{7782790551324367092}{\texttt{IndexStyle}} used to describe arrays which are optimally indexed by a Cartesian index. This is the default for new custom \hyperlink{6514416309183787338}{\texttt{AbstractArray}} subtypes.

A Cartesian indexing style uses multiple integer indices to describe the position in a multidimensional array, with exactly one index per dimension. This means that requesting \hyperlink{4701773772897287974}{\texttt{eachindex}} from an array that is \texttt{IndexCartesian} will return a range of \hyperlink{16831958174907250244}{\texttt{CartesianIndices}}.

A \texttt{N}-dimensional custom array that reports its \texttt{IndexStyle} as \texttt{IndexCartesian} needs to implement indexing (and indexed assignment) with exactly \texttt{N} \texttt{Int} indices; all other indexing expressions — including linear indexing — will be recomputed to the equivalent Cartesian location.  For example, if \texttt{A} were a \texttt{2×3} custom matrix with cartesian indexing, and we referenced \texttt{A[5]}, this would be recomputed to the equivalent Cartesian index and call \texttt{A[1, 3]} since \texttt{5 = 2*1 + 3}.

It is significantly more expensive to compute Cartesian indices from a linear index than it is to go the other way.  The former operation requires division — a very costly operation — whereas the latter only uses multiplication and addition and is essentially free. This asymmetry means it is far more costly to use linear indexing with an \texttt{IndexCartesian} array than it is to use Cartesian indexing with an \texttt{IndexLinear} array.

See also \hyperlink{1761039776681330940}{\texttt{IndexLinear}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/indices.jl#L39-L65}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17819607861919666057}{} 
\hyperlink{17819607861919666057}{\texttt{Base.conj!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
conj!(A)
\end{minted}

Transform an array to its complex conjugate in-place.

See also \hyperlink{9940023991150673697}{\texttt{conj}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1+im 2-im; 2+2im 3+im]
2×2 Array{Complex{Int64},2}:
 1+1im  2-1im
 2+2im  3+1im

julia> conj!(A);

julia> A
2×2 Array{Complex{Int64},2}:
 1-1im  2+1im
 2-2im  3-1im
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/arraymath.jl#L5-L26}{\texttt{source}}


\end{adjustwidth}
\hypertarget{97811245619734938}{} 
\hyperlink{97811245619734938}{\texttt{Base.stride}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stride(A, k::Integer)
\end{minted}

Return the distance in memory (in number of elements) between adjacent elements in dimension \texttt{k}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = fill(1, (3,4,5));

julia> stride(A,2)
3

julia> stride(A,3)
12
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L379-L394}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13576557637670855932}{} 
\hyperlink{13576557637670855932}{\texttt{Base.strides}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
strides(A)
\end{minted}

Return a tuple of the memory strides in each dimension.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = fill(1, (3,4,5));

julia> strides(A)
(1, 3, 12)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L364-L376}{\texttt{source}}


\end{adjustwidth}

\hypertarget{813179919394580087}{}


\section{广播与矢量化}



也可参照 \hyperlink{17801130558550430478}{dot syntax for vectorizing functions}； 例如，\texttt{f.(args...)} 隐式调用 \texttt{broadcast(f, args...)}。 与其依赖如 \texttt{sin} 函数的“已矢量化”方法，你应该使用 \texttt{sin.(a)} 来使用\texttt{broadcast}来矢量化。


\hypertarget{616124539803111168}{} 
\hyperlink{616124539803111168}{\texttt{Base.Broadcast.broadcast}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
broadcast(f, As...)
\end{minted}

Broadcast the function \texttt{f} over the arrays, tuples, collections, \hyperlink{7936024700322877457}{\texttt{Ref}}s and/or scalars \texttt{As}.

Broadcasting applies the function \texttt{f} over the elements of the container arguments and the scalars themselves in \texttt{As}. Singleton and missing dimensions are expanded to match the extents of the other arguments by virtually repeating the value. By default, only a limited number of types are considered scalars, including \texttt{Number}s, \texttt{String}s, \texttt{Symbol}s, \texttt{Type}s, \texttt{Function}s and some common singletons like \hyperlink{14596725676261444434}{\texttt{missing}} and \hyperlink{9331422207248206047}{\texttt{nothing}}. All other arguments are iterated over or indexed into elementwise.

The resulting container type is established by the following rules:

\begin{itemize}
\item If all the arguments are scalars or zero-dimensional arrays, it returns an unwrapped scalar.


\item If at least one argument is a tuple and all others are scalars or zero-dimensional arrays, it returns a tuple.


\item All other combinations of arguments default to returning an \texttt{Array}, but custom container types can define their own implementation and promotion-like rules to customize the result when they appear as arguments.

\end{itemize}
A special syntax exists for broadcasting: \texttt{f.(args...)} is equivalent to \texttt{broadcast(f, args...)}, and nested \texttt{f.(g.(args...))} calls are fused into a single broadcast loop.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1, 2, 3, 4, 5]
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia> B = [1 2; 3 4; 5 6; 7 8; 9 10]
5×2 Array{Int64,2}:
 1   2
 3   4
 5   6
 7   8
 9  10

julia> broadcast(+, A, B)
5×2 Array{Int64,2}:
  2   3
  5   6
  8   9
 11  12
 14  15

julia> parse.(Int, ["1", "2"])
2-element Array{Int64,1}:
 1
 2

julia> abs.((1, -2))
(1, 2)

julia> broadcast(+, 1.0, (0, -2.0))
(1.0, -1.0)

julia> (+).([[0,2], [1,3]], Ref{Vector{Int}}([1,-1]))
2-element Array{Array{Int64,1},1}:
 [1, 1]
 [2, 2]

julia> string.(("one","two","three","four"), ": ", 1:4)
4-element Array{String,1}:
 "one: 1"
 "two: 2"
 "three: 3"
 "four: 4"

\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/broadcast.jl#L682-L757}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7631985657411687574}{} 
\hyperlink{7631985657411687574}{\texttt{Base.Broadcast.broadcast!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
broadcast!(f, dest, As...)
\end{minted}

Like \hyperlink{616124539803111168}{\texttt{broadcast}}, but store the result of \texttt{broadcast(f, As...)} in the \texttt{dest} array. Note that \texttt{dest} is only used to store the result, and does not supply arguments to \texttt{f} unless it is also listed in the \texttt{As}, as in \texttt{broadcast!(f, A, A, B)} to perform \texttt{A[:] = broadcast(f, A, B)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1.0; 0.0]; B = [0.0; 0.0];

julia> broadcast!(+, B, A, (0, -2.0));

julia> B
2-element Array{Float64,1}:
  1.0
 -2.0

julia> A
2-element Array{Float64,1}:
 1.0
 0.0

julia> broadcast!(+, A, A, (0, -2.0));

julia> A
2-element Array{Float64,1}:
  1.0
 -2.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/broadcast.jl#L764-L796}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16688502228717894452}{} 
\hyperlink{16688502228717894452}{\texttt{Base.Broadcast.@\_\_dot\_\_}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@. expr
\end{minted}

Convert every function call or operator in \texttt{expr} into a {\textquotedbl}dot call{\textquotedbl} (e.g. convert \texttt{f(x)} to \texttt{f.(x)}), and convert every assignment in \texttt{expr} to a {\textquotedbl}dot assignment{\textquotedbl} (e.g. convert \texttt{+=} to \texttt{.+=}).

If you want to \emph{avoid} adding dots for selected function calls in \texttt{expr}, splice those function calls in with \texttt{\$}.  For example, \texttt{@. sqrt(abs(\$sort(x)))} is equivalent to \texttt{sqrt.(abs.(sort(x)))} (no dot for \texttt{sort}).

(\texttt{@.} is equivalent to a call to \texttt{@\_\_dot\_\_}.)

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = 1.0:3.0; y = similar(x);

julia> @. y = x + 3 * sin(x)
3-element Array{Float64,1}:
 3.5244129544236893
 4.727892280477045
 3.4233600241796016
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/broadcast.jl#L1191-L1215}{\texttt{source}}


\end{adjustwidth}

自定义类型的广播，请参照


\hypertarget{16514427843815723867}{} 
\hyperlink{16514427843815723867}{\texttt{Base.Broadcast.BroadcastStyle}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

\texttt{BroadcastStyle} is an abstract type and trait-function used to determine behavior of objects under broadcasting. \texttt{BroadcastStyle(typeof(x))} returns the style associated with \texttt{x}. To customize the broadcasting behavior of a type, one can declare a style by defining a type/method pair


\begin{lstlisting}
struct MyContainerStyle <: BroadcastStyle end
Base.BroadcastStyle(::Type{<:MyContainer}) = MyContainerStyle()
\end{lstlisting}

One then writes method(s) (at least \hyperlink{15525808546723795098}{\texttt{similar}}) operating on \texttt{Broadcasted\{MyContainerStyle\}}. There are also several pre-defined subtypes of \texttt{BroadcastStyle} that you may be able to leverage; see the \hyperlink{13211037977997948197}{Interfaces chapter} for more information.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/broadcast.jl#L21-L34}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18399209409025901494}{} 
\hyperlink{18399209409025901494}{\texttt{Base.Broadcast.AbstractArrayStyle}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

\texttt{Broadcast.AbstractArrayStyle\{N\} <: BroadcastStyle} is the abstract supertype for any style associated with an \texttt{AbstractArray} type. The \texttt{N} parameter is the dimensionality, which can be handy for AbstractArray types that only support specific dimensionalities:


\begin{lstlisting}
struct SparseMatrixStyle <: Broadcast.AbstractArrayStyle{2} end
Base.BroadcastStyle(::Type{<:SparseMatrixCSC}) = SparseMatrixStyle()
\end{lstlisting}

For \texttt{AbstractArray} types that support arbitrary dimensionality, \texttt{N} can be set to \texttt{Any}:


\begin{lstlisting}
struct MyArrayStyle <: Broadcast.AbstractArrayStyle{Any} end
Base.BroadcastStyle(::Type{<:MyArray}) = MyArrayStyle()
\end{lstlisting}

In cases where you want to be able to mix multiple \texttt{AbstractArrayStyle}s and keep track of dimensionality, your style needs to support a \hyperlink{1312938105781775871}{\texttt{Val}} constructor:


\begin{lstlisting}
struct MyArrayStyleDim{N} <: Broadcast.AbstractArrayStyle{N} end
(::Type{<:MyArrayStyleDim})(::Val{N}) where N = MyArrayStyleDim{N}()
\end{lstlisting}

Note that if two or more \texttt{AbstractArrayStyle} subtypes conflict, broadcasting machinery will fall back to producing \texttt{Array}s. If this is undesirable, you may need to define binary \hyperlink{16514427843815723867}{\texttt{BroadcastStyle}} rules to control the output type.

See also \hyperlink{5203521679854231580}{\texttt{Broadcast.DefaultArrayStyle}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/broadcast.jl#L51-L76}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7130961038203619012}{} 
\hyperlink{7130961038203619012}{\texttt{Base.Broadcast.ArrayStyle}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

\texttt{Broadcast.ArrayStyle\{MyArrayType\}()} is a \hyperlink{16514427843815723867}{\texttt{BroadcastStyle}} indicating that an object behaves as an array for broadcasting. It presents a simple way to construct \hyperlink{18399209409025901494}{\texttt{Broadcast.AbstractArrayStyle}}s for specific \texttt{AbstractArray} container types. Broadcast styles created this way lose track of dimensionality; if keeping track is important for your type, you should create your own custom \hyperlink{18399209409025901494}{\texttt{Broadcast.AbstractArrayStyle}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/broadcast.jl#L79-L85}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5203521679854231580}{} 
\hyperlink{5203521679854231580}{\texttt{Base.Broadcast.DefaultArrayStyle}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

\texttt{Broadcast.DefaultArrayStyle\{N\}()} is a \hyperlink{16514427843815723867}{\texttt{BroadcastStyle}} indicating that an object behaves as an \texttt{N}-dimensional array for broadcasting. Specifically, \texttt{DefaultArrayStyle} is used for any \texttt{AbstractArray} type that hasn{\textquotesingle}t defined a specialized style, and in the absence of overrides from other \texttt{broadcast} arguments the resulting output type is \texttt{Array}. When there are multiple inputs to \texttt{broadcast}, \texttt{DefaultArrayStyle} {\textquotedbl}loses{\textquotedbl} to any other \hyperlink{7130961038203619012}{\texttt{Broadcast.ArrayStyle}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/broadcast.jl#L89-L96}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3229213625072672556}{} 
\hyperlink{3229213625072672556}{\texttt{Base.Broadcast.broadcastable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Broadcast.broadcastable(x)
\end{minted}

Return either \texttt{x} or an object like \texttt{x} such that it supports \hyperlink{7074821531920287868}{\texttt{axes}}, indexing, and its type supports \hyperlink{1688406579181746010}{\texttt{ndims}}.

If \texttt{x} supports iteration, the returned value should have the same \texttt{axes} and indexing behaviors as \hyperlink{6278865767444641812}{\texttt{collect(x)}}.

If \texttt{x} is not an \texttt{AbstractArray} but it supports \texttt{axes}, indexing, and its type supports \texttt{ndims}, then \texttt{broadcastable(::typeof(x))} may be implemented to just return itself. Further, if \texttt{x} defines its own \hyperlink{16514427843815723867}{\texttt{BroadcastStyle}}, then it must define its \texttt{broadcastable} method to return itself for the custom style to have any effect.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Broadcast.broadcastable([1,2,3]) # like `identity` since arrays already support axes and indexing
3-element Array{Int64,1}:
 1
 2
 3

julia> Broadcast.broadcastable(Int) # Types don't support axes, indexing, or iteration but are commonly used as scalars
Base.RefValue{Type{Int64}}(Int64)

julia> Broadcast.broadcastable("hello") # Strings break convention of matching iteration and act like a scalar instead
Base.RefValue{String}("hello")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/broadcast.jl#L633-L660}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12795693983059633766}{} 
\hyperlink{12795693983059633766}{\texttt{Base.Broadcast.combine\_axes}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
combine_axes(As...) -> Tuple
\end{minted}

Determine the result axes for broadcasting across all values in \texttt{As}.


\begin{minted}{jlcon}
julia> Broadcast.combine_axes([1], [1 2; 3 4; 5 6])
(Base.OneTo(3), Base.OneTo(2))

julia> Broadcast.combine_axes(1, 1, 1)
()
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/broadcast.jl#L460-L472}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17310024314901524845}{} 
\hyperlink{17310024314901524845}{\texttt{Base.Broadcast.combine\_styles}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
combine_styles(cs...) -> BroadcastStyle
\end{minted}

Decides which \texttt{BroadcastStyle} to use for any number of value arguments. Uses \hyperlink{16514427843815723867}{\texttt{BroadcastStyle}} to get the style for each argument, and uses \hyperlink{6339732363631296845}{\texttt{result\_style}} to combine styles.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Broadcast.combine_styles([1], [1 2; 3 4])
Base.Broadcast.DefaultArrayStyle{2}()
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/broadcast.jl#L393-L406}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6339732363631296845}{} 
\hyperlink{6339732363631296845}{\texttt{Base.Broadcast.result\_style}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
result_style(s1::BroadcastStyle[, s2::BroadcastStyle]) -> BroadcastStyle
\end{minted}

Takes one or two \texttt{BroadcastStyle}s and combines them using \hyperlink{16514427843815723867}{\texttt{BroadcastStyle}} to determine a common \texttt{BroadcastStyle}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Broadcast.result_style(Broadcast.DefaultArrayStyle{0}(), Broadcast.DefaultArrayStyle{3}())
Base.Broadcast.DefaultArrayStyle{3}()

julia> Broadcast.result_style(Broadcast.Unknown(), Broadcast.DefaultArrayStyle{1}())
Base.Broadcast.DefaultArrayStyle{1}()
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/broadcast.jl#L414-L429}{\texttt{source}}


\end{adjustwidth}

\hypertarget{9968114529093360286}{}


\section{索引与赋值}


\hypertarget{70337294579126602}{} 
\hyperlink{70337294579126602}{\texttt{Base.getindex}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getindex(A, inds...)
\end{minted}

Return a subset of array \texttt{A} as specified by \texttt{inds}, where each \texttt{ind} may be an \texttt{Int}, an \hyperlink{13239199982495881110}{\texttt{AbstractRange}}, or a \hyperlink{10571362059486397014}{\texttt{Vector}}. See the manual section on \hyperlink{16717190941363337071}{array indexing} for details.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> getindex(A, 1)
1

julia> getindex(A, [2, 1])
2-element Array{Int64,1}:
 3
 1

julia> getindex(A, 2:4)
3-element Array{Int64,1}:
 3
 2
 4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L948-L976}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17903591429492118749}{} 
\hyperlink{17903591429492118749}{\texttt{Base.setindex!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
setindex!(A, X, inds...)
A[inds...] = X
\end{minted}

Store values from array \texttt{X} within some subset of \texttt{A} as specified by \texttt{inds}. The syntax \texttt{A[inds...] = X} is equivalent to \texttt{setindex!(A, X, inds...)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = zeros(2,2);

julia> setindex!(A, [10, 20], [1, 2]);

julia> A[[3, 4]] = [30, 40];

julia> A
2×2 Array{Float64,2}:
 10.0  30.0
 20.0  40.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L1049-L1069}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12981203184789384401}{} 
\hyperlink{12981203184789384401}{\texttt{Base.copyto!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
copyto!(dest, Rdest::CartesianIndices, src, Rsrc::CartesianIndices) -> dest
\end{minted}

Copy the block of \texttt{src} in the range of \texttt{Rsrc} to the block of \texttt{dest} in the range of \texttt{Rdest}. The sizes of the two regions must match.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L993-L998}{\texttt{source}}


\end{adjustwidth}
\hypertarget{976355747478401147}{} 
\hyperlink{976355747478401147}{\texttt{Base.isassigned}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isassigned(array, i) -> Bool
\end{minted}

Test whether the given array has a value associated with index \texttt{i}. Return \texttt{false} if the index is out of bounds, or has an undefined reference.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isassigned(rand(3, 3), 5)
true

julia> isassigned(rand(3, 3), 3 * 3 + 1)
false

julia> mutable struct Foo end

julia> v = similar(rand(3), Foo)
3-element Array{Foo,1}:
 #undef
 #undef
 #undef

julia> isassigned(v, 1)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L622-L647}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13649361117037263099}{} 
\hyperlink{13649361117037263099}{\texttt{Base.Colon}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Colon()
\end{minted}

Colons (:) are used to signify indexing entire objects or dimensions at once.

Very few operations are defined on Colons directly; instead they are converted by \hyperlink{10027537986402266830}{\texttt{to\_indices}} to an internal vector type (\texttt{Base.Slice}) to represent the collection of indices they span before being used.

The singleton instance of \texttt{Colon} is also a function used to construct ranges; see \hyperlink{1027906901078185239}{\texttt{:}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L659-L670}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4571802376991525093}{} 
\hyperlink{4571802376991525093}{\texttt{Base.IteratorsMD.CartesianIndex}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
CartesianIndex(i, j, k...)   -> I
CartesianIndex((i, j, k...)) -> I
\end{minted}

Create a multidimensional index \texttt{I}, which can be used for indexing a multidimensional array \texttt{A}.  In particular, \texttt{A[I]} is equivalent to \texttt{A[i,j,k...]}.  One can freely mix integer and \texttt{CartesianIndex} indices; for example, \texttt{A[Ipre, i, Ipost]} (where \texttt{Ipre} and \texttt{Ipost} are \texttt{CartesianIndex} indices and \texttt{i} is an \texttt{Int}) can be a useful expression when writing algorithms that work along a single dimension of an array of arbitrary dimensionality.

A \texttt{CartesianIndex} is sometimes produced by \hyperlink{4701773772897287974}{\texttt{eachindex}}, and always when iterating with an explicit \hyperlink{16831958174907250244}{\texttt{CartesianIndices}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = reshape(Vector(1:16), (2, 2, 2, 2))
2×2×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia> A[CartesianIndex((1, 1, 1, 1))]
1

julia> A[CartesianIndex((1, 1, 1, 2))]
9

julia> A[CartesianIndex((1, 1, 2, 1))]
5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L17-L62}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16831958174907250244}{} 
\hyperlink{16831958174907250244}{\texttt{Base.IteratorsMD.CartesianIndices}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
CartesianIndices(sz::Dims) -> R
CartesianIndices((istart:istop, jstart:jstop, ...)) -> R
\end{minted}

Define a region \texttt{R} spanning a multidimensional rectangular range of integer indices. These are most commonly encountered in the context of iteration, where \texttt{for I in R ... end} will return \hyperlink{4571802376991525093}{\texttt{CartesianIndex}} indices \texttt{I} equivalent to the nested loops


\begin{lstlisting}
for j = jstart:jstop
    for i = istart:istop
        ...
    end
end
\end{lstlisting}

Consequently these can be useful for writing algorithms that work in arbitrary dimensions.


\begin{lstlisting}
CartesianIndices(A::AbstractArray) -> R
\end{lstlisting}

As a convenience, constructing a \texttt{CartesianIndices} from an array makes a range of its indices.

\textbf{Examples}


\begin{minted}{jlcon}
julia> foreach(println, CartesianIndices((2, 2, 2)))
CartesianIndex(1, 1, 1)
CartesianIndex(2, 1, 1)
CartesianIndex(1, 2, 1)
CartesianIndex(2, 2, 1)
CartesianIndex(1, 1, 2)
CartesianIndex(2, 1, 2)
CartesianIndex(1, 2, 2)
CartesianIndex(2, 2, 2)

julia> CartesianIndices(fill(1, (2,3)))
2×3 CartesianIndices{2,Tuple{Base.OneTo{Int64},Base.OneTo{Int64}}}:
 CartesianIndex(1, 1)  CartesianIndex(1, 2)  CartesianIndex(1, 3)
 CartesianIndex(2, 1)  CartesianIndex(2, 2)  CartesianIndex(2, 3)
\end{minted}

\textbf{Conversion between linear and cartesian indices}

Linear index to cartesian index conversion exploits the fact that a \texttt{CartesianIndices} is an \texttt{AbstractArray} and can be indexed linearly:


\begin{minted}{jlcon}
julia> cartesian = CartesianIndices((1:3, 1:2))
3×2 CartesianIndices{2,Tuple{UnitRange{Int64},UnitRange{Int64}}}:
 CartesianIndex(1, 1)  CartesianIndex(1, 2)
 CartesianIndex(2, 1)  CartesianIndex(2, 2)
 CartesianIndex(3, 1)  CartesianIndex(3, 2)

julia> cartesian[4]
CartesianIndex(1, 2)
\end{minted}

\textbf{Broadcasting}

\texttt{CartesianIndices} support broadcasting arithmetic (+ and -) with a \texttt{CartesianIndex}.

\begin{quote}
\textbf{Julia 1.1}

Broadcasting of CartesianIndices requires at least Julia 1.1.

\end{quote}

\begin{minted}{jlcon}
julia> CIs = CartesianIndices((2:3, 5:6))
2×2 CartesianIndices{2,Tuple{UnitRange{Int64},UnitRange{Int64}}}:
 CartesianIndex(2, 5)  CartesianIndex(2, 6)
 CartesianIndex(3, 5)  CartesianIndex(3, 6)

julia> CI = CartesianIndex(3, 4)
CartesianIndex(3, 4)

julia> CIs .+ CI
2×2 CartesianIndices{2,Tuple{UnitRange{Int64},UnitRange{Int64}}}:
 CartesianIndex(5, 9)  CartesianIndex(5, 10)
 CartesianIndex(6, 9)  CartesianIndex(6, 10)
\end{minted}

For cartesian to linear index conversion, see \hyperlink{12250457823889413092}{\texttt{LinearIndices}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L168-L248}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16915357711927325718}{} 
\hyperlink{16915357711927325718}{\texttt{Base.Dims}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Dims{N}
\end{minted}

An \texttt{NTuple} of \texttt{N} \texttt{Int}s used to represent the dimensions of an \hyperlink{6514416309183787338}{\texttt{AbstractArray}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/indices.jl#L3-L8}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12250457823889413092}{} 
\hyperlink{12250457823889413092}{\texttt{Base.LinearIndices}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LinearIndices(A::AbstractArray)
\end{minted}

Return a \texttt{LinearIndices} array with the same shape and \hyperlink{7074821531920287868}{\texttt{axes}} as \texttt{A}, holding the linear index of each entry in \texttt{A}. Indexing this array with cartesian indices allows mapping them to linear indices.

For arrays with conventional indexing (indices start at 1), or any multidimensional array, linear indices range from 1 to \texttt{length(A)}. However, for \texttt{AbstractVector}s linear indices are \texttt{axes(A, 1)}, and therefore do not start at 1 for vectors with unconventional indexing.

Calling this function is the {\textquotedbl}safe{\textquotedbl} way to write algorithms that exploit linear indexing.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = fill(1, (5,6,7));

julia> b = LinearIndices(A);

julia> extrema(b)
(1, 210)
\end{minted}


\begin{lstlisting}
LinearIndices(inds::CartesianIndices) -> R
LinearIndices(sz::Dims) -> R
LinearIndices((istart:istop, jstart:jstop, ...)) -> R
\end{lstlisting}

Return a \texttt{LinearIndices} array with the specified shape or \hyperlink{7074821531920287868}{\texttt{axes}}.

\textbf{Example}

The main purpose of this constructor is intuitive conversion from cartesian to linear indexing:


\begin{minted}{jlcon}
julia> linear = LinearIndices((1:3, 1:2))
3×2 LinearIndices{2,Tuple{UnitRange{Int64},UnitRange{Int64}}}:
 1  4
 2  5
 3  6

julia> linear[1,2]
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/indices.jl#L396-L442}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10027537986402266830}{} 
\hyperlink{10027537986402266830}{\texttt{Base.to\_indices}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
to_indices(A, I::Tuple)
\end{minted}

Convert the tuple \texttt{I} to a tuple of indices for use in indexing into array \texttt{A}.

The returned tuple must only contain either \texttt{Int}s or \texttt{AbstractArray}s of scalar indices that are supported by array \texttt{A}. It will error upon encountering a novel index type that it does not know how to process.

For simple index types, it defers to the unexported \texttt{Base.to\_index(A, i)} to process each index \texttt{i}. While this internal function is not intended to be called directly, \texttt{Base.to\_index} may be extended by custom array or index types to provide custom indexing behaviors.

More complicated index types may require more context about the dimension into which they index. To support those cases, \texttt{to\_indices(A, I)} calls \texttt{to\_indices(A, axes(A), I)}, which then recursively walks through both the given tuple of indices and the dimensional indices of \texttt{A} in tandem. As such, not all index types are guaranteed to propagate to \texttt{Base.to\_index}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/indices.jl#L301-L320}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6593895036014271495}{} 
\hyperlink{6593895036014271495}{\texttt{Base.checkbounds}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
checkbounds(Bool, A, I...)
\end{minted}

Return \texttt{true} if the specified indices \texttt{I} are in bounds for the given array \texttt{A}. Subtypes of \texttt{AbstractArray} should specialize this method if they need to provide custom bounds checking behaviors; however, in many cases one can rely on \texttt{A}{\textquotesingle}s indices and \hyperlink{4607154172896664089}{\texttt{checkindex}}.

See also \hyperlink{4607154172896664089}{\texttt{checkindex}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = rand(3, 3);

julia> checkbounds(Bool, A, 2)
true

julia> checkbounds(Bool, A, 3, 4)
false

julia> checkbounds(Bool, A, 1:3)
true

julia> checkbounds(Bool, A, 1:3, 2:4)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L452-L478}{\texttt{source}}



\begin{lstlisting}
checkbounds(A, I...)
\end{lstlisting}

Throw an error if the specified indices \texttt{I} are not in bounds for the given array \texttt{A}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L495-L499}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4607154172896664089}{} 
\hyperlink{4607154172896664089}{\texttt{Base.checkindex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
checkindex(Bool, inds::AbstractUnitRange, index)
\end{minted}

Return \texttt{true} if the given \texttt{index} is within the bounds of \texttt{inds}. Custom types that would like to behave as indices for all arrays can extend this method in order to provide a specialized bounds checking implementation.

\textbf{Examples}


\begin{minted}{jlcon}
julia> checkindex(Bool, 1:20, 8)
true

julia> checkindex(Bool, 1:20, 21)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L540-L556}{\texttt{source}}


\end{adjustwidth}

\hypertarget{3647642488568491652}{}


\section{Views (SubArrays 以及其它 view 类型)}



A “view” is a data structure that acts like an array (it is a subtype of \texttt{AbstractArray}), but the underlying data is actually part of another array.



For example, if \texttt{x} is an array and \texttt{v = @view x[1:10]}, then \texttt{v} acts like a 10-element array, but its data is actually accessing the first 10 elements of \texttt{x}. Writing to a view, e.g. \texttt{v[3] = 2}, writes directly to the underlying array \texttt{x} (in this case modifying \texttt{x[3]}).



Slicing operations like \texttt{x[1:10]} create a copy by default in Julia. \texttt{@view x[1:10]} changes it to make a view. The \texttt{@views} macro can be used on a whole block of code (e.g. \texttt{@views function foo() .... end} or \texttt{@views begin ... end}) to change all the slicing operations in that block to use views.  Sometimes making a copy of the data is faster and sometimes using a view is faster, as described in the \hyperlink{7873250295862620958}{performance tips}.


\hypertarget{4861450464669906845}{} 
\hyperlink{4861450464669906845}{\texttt{Base.view}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
view(A, inds...)
\end{minted}

Like \hyperlink{13720608614876840481}{\texttt{getindex}}, but returns a view into the parent array \texttt{A} with the given indices instead of making a copy.  Calling \hyperlink{13720608614876840481}{\texttt{getindex}} or \hyperlink{1309244355901386657}{\texttt{setindex!}} on the returned \texttt{SubArray} computes the indices to the parent array on the fly without checking bounds.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> b = view(A, :, 1)
2-element view(::Array{Int64,2}, :, 1) with eltype Int64:
 1
 3

julia> fill!(b, 0)
2-element view(::Array{Int64,2}, :, 1) with eltype Int64:
 0
 0

julia> A # Note A has changed even though we modified b
2×2 Array{Int64,2}:
 0  2
 0  4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/subarray.jl#L129-L159}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4916348678965327831}{} 
\hyperlink{4916348678965327831}{\texttt{Base.@view}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@view A[inds...]
\end{minted}

Creates a \texttt{SubArray} from an indexing expression. This can only be applied directly to a reference expression (e.g. \texttt{@view A[1,2:end]}), and should \emph{not} be used as the target of an assignment (e.g. \texttt{@view(A[1,2:end]) = ...}).  See also \hyperlink{4544474300423667148}{\texttt{@views}} to switch an entire block of code to use views for slicing.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> b = @view A[:, 1]
2-element view(::Array{Int64,2}, :, 1) with eltype Int64:
 1
 3

julia> fill!(b, 0)
2-element view(::Array{Int64,2}, :, 1) with eltype Int64:
 0
 0

julia> A
2×2 Array{Int64,2}:
 0  2
 0  4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/views.jl#L72-L102}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4544474300423667148}{} 
\hyperlink{4544474300423667148}{\texttt{Base.@views}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@views expression
\end{minted}

Convert every array-slicing operation in the given expression (which may be a \texttt{begin}/\texttt{end} block, loop, function, etc.) to return a view. Scalar indices, non-array types, and explicit \hyperlink{13720608614876840481}{\texttt{getindex}} calls (as opposed to \texttt{array[...]}) are unaffected.

\begin{quote}
\textbf{Note}

The \texttt{@views} macro only affects \texttt{array[...]} expressions that appear explicitly in the given \texttt{expression}, not array slicing that occurs in functions called by that code.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = zeros(3, 3);

julia> @views for row in 1:3
           b = A[row, :]
           b[:] .= row
       end

julia> A
3×3 Array{Float64,2}:
 1.0  1.0  1.0
 2.0  2.0  2.0
 3.0  3.0  3.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/views.jl#L183-L212}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11732113189086969263}{} 
\hyperlink{11732113189086969263}{\texttt{Base.parent}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
parent(A)
\end{minted}

Returns the {\textquotedbl}parent array{\textquotedbl} of an array view type (e.g., \texttt{SubArray}), or the array itself if it is not a view.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> V = view(A, 1:2, :)
2×2 view(::Array{Int64,2}, 1:2, :) with eltype Int64:
 1  2
 3  4

julia> parent(V)
2×2 Array{Int64,2}:
 1  2
 3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L1112-L1135}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16743033525479285274}{} 
\hyperlink{16743033525479285274}{\texttt{Base.parentindices}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
parentindices(A)
\end{minted}

Return the indices in the \hyperlink{11732113189086969263}{\texttt{parent}} which correspond to the array view \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4];

julia> V = view(A, 1, :)
2-element view(::Array{Int64,2}, 1, :) with eltype Int64:
 1
 2

julia> parentindices(V)
(1, Base.Slice(Base.OneTo(2)))
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/subarray.jl#L82-L99}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16041553215191638546}{} 
\hyperlink{16041553215191638546}{\texttt{Base.selectdim}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
selectdim(A, d::Integer, i)
\end{minted}

Return a view of all the data of \texttt{A} where the index for dimension \texttt{d} equals \texttt{i}.

Equivalent to \texttt{view(A,:,:,...,i,:,:,...)} where \texttt{i} is in position \texttt{d}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2 3 4; 5 6 7 8]
2×4 Array{Int64,2}:
 1  2  3  4
 5  6  7  8

julia> selectdim(A, 2, 3)
2-element view(::Array{Int64,2}, :, 3) with eltype Int64:
 3
 7
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarraymath.jl#L102-L121}{\texttt{source}}


\end{adjustwidth}
\hypertarget{293815781001952115}{} 
\hyperlink{293815781001952115}{\texttt{Base.reinterpret}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reinterpret(type, A)
\end{minted}

Change the type-interpretation of a block of memory. For arrays, this constructs a view of the array with the same binary data as the given array, but with the specified element type. For example, \texttt{reinterpret(Float32, UInt32(7))} interprets the 4 bytes corresponding to \texttt{UInt32(7)} as a \hyperlink{8101639384272933082}{\texttt{Float32}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> reinterpret(Float32, UInt32(7))
1.0f-44

julia> reinterpret(Float32, UInt32[1 2 3 4 5])
1×5 reinterpret(Float32, ::Array{UInt32,2}):
 1.0f-45  3.0f-45  4.0f-45  6.0f-45  7.0f-45
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L396-L415}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3388738163419525310}{} 
\hyperlink{3388738163419525310}{\texttt{Base.reshape}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reshape(A, dims...) -> AbstractArray
reshape(A, dims) -> AbstractArray
\end{minted}

Return an array with the same data as \texttt{A}, but with different dimension sizes or number of dimensions. The two arrays share the same underlying data, so that the result is mutable if and only if \texttt{A} is mutable, and setting elements of one alters the values of the other.

The new dimensions may be specified either as a list of arguments or as a shape tuple. At most one dimension may be specified with a \texttt{:}, in which case its length is computed such that its product with all the specified dimensions is equal to the length of the original array \texttt{A}. The total number of elements must not change.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = Vector(1:16)
16-element Array{Int64,1}:
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16

julia> reshape(A, (4, 4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> reshape(A, 2, :)
2×8 Array{Int64,2}:
 1  3  5  7   9  11  13  15
 2  4  6  8  10  12  14  16

julia> reshape(1:6, 2, 3)
2×3 reshape(::UnitRange{Int64}, 2, 3) with eltype Int64:
 1  3  5
 2  4  6
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reshapedarray.jl#L54-L107}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18382575660271190579}{} 
\hyperlink{18382575660271190579}{\texttt{Base.dropdims}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dropdims(A; dims)
\end{minted}

Remove the dimensions specified by \texttt{dims} from array \texttt{A}. Elements of \texttt{dims} must be unique and within the range \texttt{1:ndims(A)}. \texttt{size(A,i)} must equal 1 for all \texttt{i} in \texttt{dims}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = reshape(Vector(1:4),(2,2,1,1))
2×2×1×1 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

julia> dropdims(a; dims=3)
2×2×1 Array{Int64,3}:
[:, :, 1] =
 1  3
 2  4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarraymath.jl#L48-L69}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18435874855636770528}{} 
\hyperlink{18435874855636770528}{\texttt{Base.vec}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
vec(a::AbstractArray) -> AbstractVector
\end{minted}

Reshape the array \texttt{a} as a one-dimensional column vector. Return \texttt{a} if it is already an \texttt{AbstractVector}. The resulting array shares the same underlying data as \texttt{a}, so it will only be mutable if \texttt{a} is mutable, in which case modifying one will also modify the other.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia> vec(a)
6-element Array{Int64,1}:
 1
 4
 2
 5
 3
 6

julia> vec(1:3)
1:3
\end{minted}

See also \hyperlink{3388738163419525310}{\texttt{reshape}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarraymath.jl#L11-L40}{\texttt{source}}


\end{adjustwidth}

\hypertarget{10571026513640698597}{}


\section{Concatenation and permutation}


\hypertarget{9868138443525443234}{} 
\hyperlink{9868138443525443234}{\texttt{Base.cat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cat(A...; dims=dims)
\end{minted}

Concatenate the input arrays along the specified dimensions in the iterable \texttt{dims}. For dimensions not in \texttt{dims}, all input arrays should have the same size, which will also be the size of the output array along that dimension. For dimensions in \texttt{dims}, the size of the output array is the sum of the sizes of the input arrays along that dimension. If \texttt{dims} is a single number, the different arrays are tightly stacked along that dimension. If \texttt{dims} is an iterable containing several dimensions, this allows one to construct block diagonal matrices and their higher-dimensional analogues by simultaneously increasing several dimensions for every new input array and putting zero blocks elsewhere. For example, \texttt{cat(matrices...; dims=(1,2))} builds a block diagonal matrix, i.e. a block matrix with \texttt{matrices[1]}, \texttt{matrices[2]}, ... as diagonal blocks and matching zero blocks away from the diagonal.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L1549-L1563}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14691815416955507876}{} 
\hyperlink{14691815416955507876}{\texttt{Base.vcat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
vcat(A...)
\end{minted}

Concatenate along dimension 1.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2 3 4 5]
1×5 Array{Int64,2}:
 1  2  3  4  5

julia> b = [6 7 8 9 10; 11 12 13 14 15]
2×5 Array{Int64,2}:
  6   7   8   9  10
 11  12  13  14  15

julia> vcat(a,b)
3×5 Array{Int64,2}:
  1   2   3   4   5
  6   7   8   9  10
 11  12  13  14  15

julia> c = ([1 2 3], [4 5 6])
([1 2 3], [4 5 6])

julia> vcat(c...)
2×3 Array{Int64,2}:
 1  2  3
 4  5  6
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L1471-L1501}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8862791894748483563}{} 
\hyperlink{8862791894748483563}{\texttt{Base.hcat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hcat(A...)
\end{minted}

Concatenate along dimension 2.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1; 2; 3; 4; 5]
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia> b = [6 7; 8 9; 10 11; 12 13; 14 15]
5×2 Array{Int64,2}:
  6   7
  8   9
 10  11
 12  13
 14  15

julia> hcat(a,b)
5×3 Array{Int64,2}:
 1   6   7
 2   8   9
 3  10  11
 4  12  13
 5  14  15

julia> c = ([1; 2; 3], [4; 5; 6])
([1, 2, 3], [4, 5, 6])

julia> hcat(c...)
3×2 Array{Int64,2}:
 1  4
 2  5
 3  6
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L1503-L1543}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16279083053557795116}{} 
\hyperlink{16279083053557795116}{\texttt{Base.hvcat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hvcat(rows::Tuple{Vararg{Int}}, values...)
\end{minted}

Horizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a, b, c, d, e, f = 1, 2, 3, 4, 5, 6
(1, 2, 3, 4, 5, 6)

julia> [a b c; d e f]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia> hvcat((3,3), a,b,c,d,e,f)
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia> [a b;c d; e f]
3×2 Array{Int64,2}:
 1  2
 3  4
 5  6

julia> hvcat((2,2,2), a,b,c,d,e,f)
3×2 Array{Int64,2}:
 1  2
 3  4
 5  6
\end{minted}

If the first argument is a single integer \texttt{n}, then all block rows are assumed to have \texttt{n} block columns.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L1594-L1631}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2932104842023453623}{} 
\hyperlink{2932104842023453623}{\texttt{Base.vect}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
vect(X...)
\end{minted}

Create a \hyperlink{10571362059486397014}{\texttt{Vector}} with element type computed from the \texttt{promote\_typeof} of the argument, containing the argument list.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = Base.vect(UInt8(1), 2.5, 1//2)
3-element Array{Float64,1}:
 1.0
 2.5
 0.5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L132-L146}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15182910221850902862}{} 
\hyperlink{15182910221850902862}{\texttt{Base.circshift}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
circshift(A, shifts)
\end{minted}

Circularly shift, i.e. rotate, the data in an array. The second argument is a tuple or vector giving the amount to shift in each dimension, or an integer to shift only in the first dimension.

\textbf{Examples}


\begin{minted}{jlcon}
julia> b = reshape(Vector(1:16), (4,4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> circshift(b, (0,2))
4×4 Array{Int64,2}:
  9  13  1  5
 10  14  2  6
 11  15  3  7
 12  16  4  8

julia> circshift(b, (-1,0))
4×4 Array{Int64,2}:
 2  6  10  14
 3  7  11  15
 4  8  12  16
 1  5   9  13

julia> a = BitArray([true, true, false, false, true])
5-element BitArray{1}:
 1
 1
 0
 0
 1

julia> circshift(a, 1)
5-element BitArray{1}:
 1
 1
 1
 0
 0

julia> circshift(a, -1)
5-element BitArray{1}:
 1
 0
 0
 1
 1
\end{minted}

See also \hyperlink{5319002815154535997}{\texttt{circshift!}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarraymath.jl#L184-L240}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5319002815154535997}{} 
\hyperlink{5319002815154535997}{\texttt{Base.circshift!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
circshift!(dest, src, shifts)
\end{minted}

Circularly shift, i.e. rotate, the data in \texttt{src}, storing the result in \texttt{dest}. \texttt{shifts} specifies the amount to shift in each dimension.

The \texttt{dest} array must be distinct from the \texttt{src} array (they cannot alias each other).

See also \hyperlink{15182910221850902862}{\texttt{circshift}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L1003-L1013}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13256910868822648458}{} 
\hyperlink{13256910868822648458}{\texttt{Base.circcopy!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
circcopy!(dest, src)
\end{minted}

Copy \texttt{src} to \texttt{dest}, indexing each dimension modulo its length. \texttt{src} and \texttt{dest} must have the same size, but can be offset in their indices; any offset results in a (circular) wraparound. If the arrays have overlapping indices, then on the domain of the overlap \texttt{dest} agrees with \texttt{src}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> src = reshape(Vector(1:16), (4,4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> dest = OffsetArray{Int}(undef, (0:3,2:5))

julia> circcopy!(dest, src)
OffsetArrays.OffsetArray{Int64,2,Array{Int64,2}} with indices 0:3×2:5:
 8  12  16  4
 5   9  13  1
 6  10  14  2
 7  11  15  3

julia> dest[1:3,2:4] == src[1:3,2:4]
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L1056-L1086}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16067208921941164599}{} 
\hyperlink{16067208921941164599}{\texttt{Base.findall}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findall(A)
\end{minted}

Return a vector \texttt{I} of the \texttt{true} indices or keys of \texttt{A}. If there are no such elements of \texttt{A}, return an empty array. To search for other kinds of values, pass a predicate as the first argument.

Indices or keys are of the same type as those returned by \hyperlink{6023948435845840069}{\texttt{keys(A)}} and \hyperlink{15543779110977484852}{\texttt{pairs(A)}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [true, false, false, true]
4-element Array{Bool,1}:
 1
 0
 0
 1

julia> findall(A)
2-element Array{Int64,1}:
 1
 4

julia> A = [true false; false true]
2×2 Array{Bool,2}:
 1  0
 0  1

julia> findall(A)
2-element Array{CartesianIndex{2},1}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 2)

julia> findall(falses(3))
0-element Array{Int64,1}
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L2026-L2063}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5230048188611808574}{} 
\hyperlink{5230048188611808574}{\texttt{Base.findall}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findall(f::Function, A)
\end{minted}

Return a vector \texttt{I} of the indices or keys of \texttt{A} where \texttt{f(A[I])} returns \texttt{true}. If there are no such elements of \texttt{A}, return an empty array.

Indices or keys are of the same type as those returned by \hyperlink{6023948435845840069}{\texttt{keys(A)}} and \hyperlink{15543779110977484852}{\texttt{pairs(A)}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = [1, 3, 4]
3-element Array{Int64,1}:
 1
 3
 4

julia> findall(isodd, x)
2-element Array{Int64,1}:
 1
 2

julia> A = [1 2 0; 3 4 0]
2×3 Array{Int64,2}:
 1  2  0
 3  4  0
julia> findall(isodd, A)
2-element Array{CartesianIndex{2},1}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 1)

julia> findall(!iszero, A)
4-element Array{CartesianIndex{2},1}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 1)
 CartesianIndex(1, 2)
 CartesianIndex(2, 2)

julia> d = Dict(:A => 10, :B => -1, :C => 0)
Dict{Symbol,Int64} with 3 entries:
  :A => 10
  :B => -1
  :C => 0

julia> findall(x -> x >= 0, d)
2-element Array{Symbol,1}:
 :A
 :C

\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1973-L2023}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13752961745140943082}{} 
\hyperlink{13752961745140943082}{\texttt{Base.findfirst}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findfirst(A)
\end{minted}

Return the index or key of the first \texttt{true} value in \texttt{A}. Return \texttt{nothing} if no such value is found. To search for other kinds of values, pass a predicate as the first argument.

Indices or keys are of the same type as those returned by \hyperlink{6023948435845840069}{\texttt{keys(A)}} and \hyperlink{15543779110977484852}{\texttt{pairs(A)}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [false, false, true, false]
4-element Array{Bool,1}:
 0
 0
 1
 0

julia> findfirst(A)
3

julia> findfirst(falses(3)) # returns nothing, but not printed in the REPL

julia> A = [false false; true false]
2×2 Array{Bool,2}:
 0  0
 1  0

julia> findfirst(A)
CartesianIndex(2, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1658-L1690}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10686327966799324598}{} 
\hyperlink{10686327966799324598}{\texttt{Base.findfirst}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findfirst(predicate::Function, A)
\end{minted}

Return the index or key of the first element of \texttt{A} for which \texttt{predicate} returns \texttt{true}. Return \texttt{nothing} if there is no such element.

Indices or keys are of the same type as those returned by \hyperlink{6023948435845840069}{\texttt{keys(A)}} and \hyperlink{15543779110977484852}{\texttt{pairs(A)}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1, 4, 2, 2]
4-element Array{Int64,1}:
 1
 4
 2
 2

julia> findfirst(iseven, A)
2

julia> findfirst(x -> x>10, A) # returns nothing, but not printed in the REPL

julia> findfirst(isequal(4), A)
2

julia> A = [1 4; 2 2]
2×2 Array{Int64,2}:
 1  4
 2  2

julia> findfirst(iseven, A)
CartesianIndex(2, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1740-L1774}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16601358451866933976}{} 
\hyperlink{16601358451866933976}{\texttt{Base.findlast}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findlast(A)
\end{minted}

Return the index or key of the last \texttt{true} value in \texttt{A}. Return \texttt{nothing} if there is no \texttt{true} value in \texttt{A}.

Indices or keys are of the same type as those returned by \hyperlink{6023948435845840069}{\texttt{keys(A)}} and \hyperlink{15543779110977484852}{\texttt{pairs(A)}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [true, false, true, false]
4-element Array{Bool,1}:
 1
 0
 1
 0

julia> findlast(A)
3

julia> A = falses(2,2);

julia> findlast(A) # returns nothing, but not printed in the REPL

julia> A = [true false; true false]
2×2 Array{Bool,2}:
 1  0
 1  0

julia> findlast(A)
CartesianIndex(2, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1839-L1872}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13690191743392331122}{} 
\hyperlink{13690191743392331122}{\texttt{Base.findlast}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findlast(predicate::Function, A)
\end{minted}

Return the index or key of the last element of \texttt{A} for which \texttt{predicate} returns \texttt{true}. Return \texttt{nothing} if there is no such element.

Indices or keys are of the same type as those returned by \hyperlink{6023948435845840069}{\texttt{keys(A)}} and \hyperlink{15543779110977484852}{\texttt{pairs(A)}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1, 2, 3, 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> findlast(isodd, A)
3

julia> findlast(x -> x > 5, A) # returns nothing, but not printed in the REPL

julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> findlast(isodd, A)
CartesianIndex(2, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1930-L1961}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9906000186778518011}{} 
\hyperlink{9906000186778518011}{\texttt{Base.findnext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findnext(A, i)
\end{minted}

Find the next index after or including \texttt{i} of a \texttt{true} element of \texttt{A}, or \texttt{nothing} if not found.

Indices are of the same type as those returned by \hyperlink{6023948435845840069}{\texttt{keys(A)}} and \hyperlink{15543779110977484852}{\texttt{pairs(A)}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [false, false, true, false]
4-element Array{Bool,1}:
 0
 0
 1
 0

julia> findnext(A, 1)
3

julia> findnext(A, 4) # returns nothing, but not printed in the REPL

julia> A = [false false; true false]
2×2 Array{Bool,2}:
 0  0
 1  0

julia> findnext(A, CartesianIndex(1, 1))
CartesianIndex(2, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1613-L1644}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2433853860677249610}{} 
\hyperlink{2433853860677249610}{\texttt{Base.findnext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findnext(predicate::Function, A, i)
\end{minted}

Find the next index after or including \texttt{i} of an element of \texttt{A} for which \texttt{predicate} returns \texttt{true}, or \texttt{nothing} if not found.

Indices are of the same type as those returned by \hyperlink{6023948435845840069}{\texttt{keys(A)}} and \hyperlink{15543779110977484852}{\texttt{pairs(A)}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1, 4, 2, 2];

julia> findnext(isodd, A, 1)
1

julia> findnext(isodd, A, 2) # returns nothing, but not printed in the REPL

julia> A = [1 4; 2 2];

julia> findnext(isodd, A, CartesianIndex(1, 1))
CartesianIndex(1, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1703-L1726}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3864667477361062614}{} 
\hyperlink{3864667477361062614}{\texttt{Base.findprev}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findprev(A, i)
\end{minted}

Find the previous index before or including \texttt{i} of a \texttt{true} element of \texttt{A}, or \texttt{nothing} if not found.

Indices are of the same type as those returned by \hyperlink{6023948435845840069}{\texttt{keys(A)}} and \hyperlink{15543779110977484852}{\texttt{pairs(A)}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [false, false, true, true]
4-element Array{Bool,1}:
 0
 0
 1
 1

julia> findprev(A, 3)
3

julia> findprev(A, 1) # returns nothing, but not printed in the REPL

julia> A = [false false; true true]
2×2 Array{Bool,2}:
 0  0
 1  1

julia> findprev(A, CartesianIndex(2, 1))
CartesianIndex(2, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1794-L1825}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17827047449430918639}{} 
\hyperlink{17827047449430918639}{\texttt{Base.findprev}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findprev(predicate::Function, A, i)
\end{minted}

Find the previous index before or including \texttt{i} of an element of \texttt{A} for which \texttt{predicate} returns \texttt{true}, or \texttt{nothing} if not found.

Indices are of the same type as those returned by \hyperlink{6023948435845840069}{\texttt{keys(A)}} and \hyperlink{15543779110977484852}{\texttt{pairs(A)}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4, 6, 1, 2]
4-element Array{Int64,1}:
 4
 6
 1
 2

julia> findprev(isodd, A, 1) # returns nothing, but not printed in the REPL

julia> findprev(isodd, A, 3)
3

julia> A = [4 6; 1 2]
2×2 Array{Int64,2}:
 4  6
 1  2

julia> findprev(isodd, A, CartesianIndex(1, 2))
CartesianIndex(2, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1885-L1916}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10913801624539723467}{} 
\hyperlink{10913801624539723467}{\texttt{Base.permutedims}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
permutedims(A::AbstractArray, perm)
\end{minted}

Permute the dimensions of array \texttt{A}. \texttt{perm} is a vector specifying a permutation of length \texttt{ndims(A)}.

See also: \hyperlink{16936235724694909186}{\texttt{PermutedDimsArray}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = reshape(Vector(1:8), (2,2,2))
2×2×2 Array{Int64,3}:
[:, :, 1] =
 1  3
 2  4

[:, :, 2] =
 5  7
 6  8

julia> permutedims(A, [3, 2, 1])
2×2×2 Array{Int64,3}:
[:, :, 1] =
 1  3
 5  7

[:, :, 2] =
 2  4
 6  8
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/permuteddimsarray.jl#L80-L110}{\texttt{source}}



\begin{lstlisting}
permutedims(m::AbstractMatrix)
\end{lstlisting}

Permute the dimensions of the matrix \texttt{m}, by flipping the elements across the diagonal of the matrix. Differs from \texttt{LinearAlgebra}{\textquotesingle}s \hyperlink{12700837529519091997}{\texttt{transpose}} in that the operation is not recursive.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4];

julia> b = [5 6; 7 8];

julia> c = [9 10; 11 12];

julia> d = [13 14; 15 16];

julia> X = [[a] [b]; [c] [d]]
2×2 Array{Array{Int64,2},2}:
 [1 2; 3 4]     [5 6; 7 8]
 [9 10; 11 12]  [13 14; 15 16]

julia> permutedims(X)
2×2 Array{Array{Int64,2},2}:
 [1 2; 3 4]  [9 10; 11 12]
 [5 6; 7 8]  [13 14; 15 16]

julia> transpose(X)
2×2 Transpose{Transpose{Int64,Array{Int64,2}},Array{Array{Int64,2},2}}:
 [1 3; 2 4]  [9 11; 10 12]
 [5 7; 6 8]  [13 15; 14 16]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/permuteddimsarray.jl#L116-L148}{\texttt{source}}



\begin{lstlisting}
permutedims(v::AbstractVector)
\end{lstlisting}

Reshape vector \texttt{v} into a \texttt{1 × length(v)} row matrix. Differs from \texttt{LinearAlgebra}{\textquotesingle}s \hyperlink{12700837529519091997}{\texttt{transpose}} in that the operation is not recursive.

\textbf{Examples}


\begin{minted}{jlcon}
julia> permutedims([1, 2, 3, 4])
1×4 Array{Int64,2}:
 1  2  3  4

julia> V = [[[1 2; 3 4]]; [[5 6; 7 8]]]
2-element Array{Array{Int64,2},1}:
 [1 2; 3 4]
 [5 6; 7 8]

julia> permutedims(V)
1×2 Array{Array{Int64,2},2}:
 [1 2; 3 4]  [5 6; 7 8]

julia> transpose(V)
1×2 Transpose{Transpose{Int64,Array{Int64,2}},Array{Array{Int64,2},1}}:
 [1 3; 2 4]  [5 7; 6 8]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/permuteddimsarray.jl#L151-L177}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15299422200414360384}{} 
\hyperlink{15299422200414360384}{\texttt{Base.permutedims!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
permutedims!(dest, src, perm)
\end{minted}

Permute the dimensions of array \texttt{src} and store the result in the array \texttt{dest}. \texttt{perm} is a vector specifying a permutation of length \texttt{ndims(src)}. The preallocated array \texttt{dest} should have \texttt{size(dest) == size(src)[perm]} and is completely overwritten. No in-place permutation is supported and unexpected results will happen if \texttt{src} and \texttt{dest} have overlapping memory regions.

See also \hyperlink{10913801624539723467}{\texttt{permutedims}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/permuteddimsarray.jl#L180-L190}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16936235724694909186}{} 
\hyperlink{16936235724694909186}{\texttt{Base.PermutedDimsArrays.PermutedDimsArray}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
PermutedDimsArray(A, perm) -> B
\end{minted}

Given an AbstractArray \texttt{A}, create a view \texttt{B} such that the dimensions appear to be permuted. Similar to \texttt{permutedims}, except that no copying occurs (\texttt{B} shares storage with \texttt{A}).

See also: \hyperlink{10913801624539723467}{\texttt{permutedims}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = rand(3,5,4);

julia> B = PermutedDimsArray(A, (3,1,2));

julia> size(B)
(4, 3, 5)

julia> B[3,1,2] == A[1,2,3]
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/permuteddimsarray.jl#L20-L41}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16545078180547259725}{} 
\hyperlink{16545078180547259725}{\texttt{Base.promote\_shape}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
promote_shape(s1, s2)
\end{minted}

Check two array shapes for compatibility, allowing trailing singleton dimensions, and return whichever shape has more dimensions.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = fill(1, (3,4,1,1,1));

julia> b = fill(1, (3,4));

julia> promote_shape(a,b)
(Base.OneTo(3), Base.OneTo(4), Base.OneTo(1), Base.OneTo(1), Base.OneTo(1))

julia> promote_shape((2,3,1,4), (2, 3, 1, 4, 1))
(2, 3, 1, 4, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/indices.jl#L132-L150}{\texttt{source}}


\end{adjustwidth}

\hypertarget{2513741487669385581}{}


\section{Array functions}


\hypertarget{318811369799573541}{} 
\hyperlink{318811369799573541}{\texttt{Base.accumulate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
accumulate(op, A; dims::Integer, [init])
\end{minted}

Cumulative operation \texttt{op} along the dimension \texttt{dims} of \texttt{A} (providing \texttt{dims} is optional for vectors). An initial value \texttt{init} may optionally be provided by a keyword argument. See also \hyperlink{5431648933624159647}{\texttt{accumulate!}} to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow). For common operations there are specialized variants of \texttt{accumulate}, see: \hyperlink{6230751605647278302}{\texttt{cumsum}}, \hyperlink{9956198945051267091}{\texttt{cumprod}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> accumulate(+, [1,2,3])
3-element Array{Int64,1}:
 1
 3
 6

julia> accumulate(*, [1,2,3])
3-element Array{Int64,1}:
 1
 2
 6

julia> accumulate(+, [1,2,3]; init=100)
3-element Array{Int64,1}:
 101
 103
 106

julia> accumulate(min, [1,2,-1]; init=0)
3-element Array{Int64,1}:
  0
  0
 -1

julia> accumulate(+, fill(1, 3, 3), dims=1)
3×3 Array{Int64,2}:
 1  1  1
 2  2  2
 3  3  3

julia> accumulate(+, fill(1, 3, 3), dims=2)
3×3 Array{Int64,2}:
 1  2  3
 1  2  3
 1  2  3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/accumulate.jl#L190-L237}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5431648933624159647}{} 
\hyperlink{5431648933624159647}{\texttt{Base.accumulate!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
accumulate!(op, B, A; [dims], [init])
\end{minted}

Cumulative operation \texttt{op} on \texttt{A} along the dimension \texttt{dims}, storing the result in \texttt{B}. Providing \texttt{dims} is optional for vectors.  If the keyword argument \texttt{init} is given, its value is used to instantiate the accumulation. See also \hyperlink{318811369799573541}{\texttt{accumulate}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = [1, 0, 2, 0, 3];

julia> y = [0, 0, 0, 0, 0];

julia> accumulate!(+, y, x);

julia> y
5-element Array{Int64,1}:
 1
 1
 3
 3
 6

julia> A = [1 2; 3 4];

julia> B = [0 0; 0 0];

julia> accumulate!(-, B, A, dims=1);

julia> B
2×2 Array{Int64,2}:
  1   2
 -2  -2

julia> accumulate!(-, B, A, dims=2);

julia> B
2×2 Array{Int64,2}:
 1  -1
 3  -1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/accumulate.jl#L250-L291}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9956198945051267091}{} 
\hyperlink{9956198945051267091}{\texttt{Base.cumprod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cumprod(A; dims::Integer)
\end{minted}

Cumulative product along the dimension \texttt{dim}. See also \hyperlink{17593173853905042752}{\texttt{cumprod!}} to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia> cumprod(a, dims=1)
2×3 Array{Int64,2}:
 1   2   3
 4  10  18

julia> cumprod(a, dims=2)
2×3 Array{Int64,2}:
 1   2    6
 4  20  120
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/accumulate.jl#L136-L160}{\texttt{source}}



\begin{lstlisting}
cumprod(x::AbstractVector)
\end{lstlisting}

Cumulative product of a vector. See also \hyperlink{17593173853905042752}{\texttt{cumprod!}} to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).

\textbf{Examples}


\begin{minted}{jlcon}
julia> cumprod(fill(1//2, 3))
3-element Array{Rational{Int64},1}:
 1//2
 1//4
 1//8

julia> cumprod([fill(1//3, 2, 2) for i in 1:3])
3-element Array{Array{Rational{Int64},2},1}:
 [1//3 1//3; 1//3 1//3]
 [2//9 2//9; 2//9 2//9]
 [4//27 4//27; 4//27 4//27]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/accumulate.jl#L165-L186}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17593173853905042752}{} 
\hyperlink{17593173853905042752}{\texttt{Base.cumprod!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cumprod!(B, A; dims::Integer)
\end{minted}

Cumulative product of \texttt{A} along the dimension \texttt{dims}, storing the result in \texttt{B}. See also \hyperlink{9956198945051267091}{\texttt{cumprod}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/accumulate.jl#L119-L124}{\texttt{source}}



\begin{lstlisting}
cumprod!(y::AbstractVector, x::AbstractVector)
\end{lstlisting}

Cumulative product of a vector \texttt{x}, storing the result in \texttt{y}. See also \hyperlink{9956198945051267091}{\texttt{cumprod}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/accumulate.jl#L128-L133}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6230751605647278302}{} 
\hyperlink{6230751605647278302}{\texttt{Base.cumsum}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cumsum(A; dims::Integer)
\end{minted}

Cumulative sum along the dimension \texttt{dims}. See also \hyperlink{6880214806638058949}{\texttt{cumsum!}} to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia> cumsum(a, dims=1)
2×3 Array{Int64,2}:
 1  2  3
 5  7  9

julia> cumsum(a, dims=2)
2×3 Array{Int64,2}:
 1  3   6
 4  9  15
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/accumulate.jl#L64-L88}{\texttt{source}}



\begin{lstlisting}
cumsum(x::AbstractVector)
\end{lstlisting}

Cumulative sum a vector. See also \hyperlink{6880214806638058949}{\texttt{cumsum!}} to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).

\textbf{Examples}


\begin{minted}{jlcon}
julia> cumsum([1, 1, 1])
3-element Array{Int64,1}:
 1
 2
 3

julia> cumsum([fill(1, 2) for i in 1:3])
3-element Array{Array{Int64,1},1}:
 [1, 1]
 [2, 2]
 [3, 3]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/accumulate.jl#L94-L115}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6880214806638058949}{} 
\hyperlink{6880214806638058949}{\texttt{Base.cumsum!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cumsum!(B, A; dims::Integer)
\end{minted}

Cumulative sum of \texttt{A} along the dimension \texttt{dims}, storing the result in \texttt{B}. See also \hyperlink{6230751605647278302}{\texttt{cumsum}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/accumulate.jl#L41-L45}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11629576691247647263}{} 
\hyperlink{11629576691247647263}{\texttt{Base.diff}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
diff(A::AbstractVector)
diff(A::AbstractArray; dims::Integer)
\end{minted}

Finite difference operator on a vector or a multidimensional array \texttt{A}. In the latter case the dimension to operate on needs to be specified with the \texttt{dims} keyword argument.

\begin{quote}
\textbf{Julia 1.1}

\texttt{diff} for arrays with dimension higher than 2 requires at least Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [2 4; 6 16]
2×2 Array{Int64,2}:
 2   4
 6  16

julia> diff(a, dims=2)
2×1 Array{Int64,2}:
  2
 10

julia> diff(vec(a))
3-element Array{Int64,1}:
  4
 -2
 12
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L795-L824}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15426606278434194584}{} 
\hyperlink{15426606278434194584}{\texttt{Base.repeat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
repeat(A::AbstractArray, counts::Integer...)
\end{minted}

Construct an array by repeating array \texttt{A} a given number of times in each dimension, specified by \texttt{counts}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> repeat([1, 2, 3], 2)
6-element Array{Int64,1}:
 1
 2
 3
 1
 2
 3

julia> repeat([1, 2, 3], 2, 3)
6×3 Array{Int64,2}:
 1  1  1
 2  2  2
 3  3  3
 1  1  1
 2  2  2
 3  3  3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarraymath.jl#L247-L272}{\texttt{source}}



\begin{lstlisting}
repeat(A::AbstractArray; inner=ntuple(x->1, ndims(A)), outer=ntuple(x->1, ndims(A)))
\end{lstlisting}

Construct an array by repeating the entries of \texttt{A}. The i-th element of \texttt{inner} specifies the number of times that the individual entries of the i-th dimension of \texttt{A} should be repeated. The i-th element of \texttt{outer} specifies the number of times that a slice along the i-th dimension of \texttt{A} should be repeated. If \texttt{inner} or \texttt{outer} are omitted, no repetition is performed.

\textbf{Examples}


\begin{minted}{jlcon}
julia> repeat(1:2, inner=2)
4-element Array{Int64,1}:
 1
 1
 2
 2

julia> repeat(1:2, outer=2)
4-element Array{Int64,1}:
 1
 2
 1
 2

julia> repeat([1 2; 3 4], inner=(2, 1), outer=(1, 3))
4×6 Array{Int64,2}:
 1  2  1  2  1  2
 1  2  1  2  1  2
 3  4  3  4  3  4
 3  4  3  4  3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarraymath.jl#L299-L331}{\texttt{source}}



\begin{minted}{julia}
repeat(s::AbstractString, r::Integer)
\end{minted}

Repeat a string \texttt{r} times. This can be written as \texttt{s{\textasciicircum}r}.

See also: \hyperlink{462277561264792021}{\texttt{{\textasciicircum}}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> repeat("ha", 3)
"hahaha"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L652-L664}{\texttt{source}}



\begin{minted}{julia}
repeat(c::AbstractChar, r::Integer) -> String
\end{minted}

Repeat a character \texttt{r} times. This can equivalently be accomplished by calling \hyperlink{462277561264792021}{\texttt{c{\textasciicircum}r}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> repeat('A', 3)
"AAA"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/string.jl#L308-L318}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12015243558136741941}{} 
\hyperlink{12015243558136741941}{\texttt{Base.rot180}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rot180(A)
\end{minted}

Rotate matrix \texttt{A} 180 degrees.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rot180(a)
2×2 Array{Int64,2}:
 4  3
 2  1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/arraymath.jl#L177-L194}{\texttt{source}}



\begin{lstlisting}
rot180(A, k)
\end{lstlisting}

Rotate matrix \texttt{A} 180 degrees an integer \texttt{k} number of times. If \texttt{k} is even, this is equivalent to a \texttt{copy}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rot180(a,1)
2×2 Array{Int64,2}:
 4  3
 2  1

julia> rot180(a,2)
2×2 Array{Int64,2}:
 1  2
 3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/arraymath.jl#L279-L302}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3749585719821242612}{} 
\hyperlink{3749585719821242612}{\texttt{Base.rotl90}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rotl90(A)
\end{minted}

Rotate matrix \texttt{A} left 90 degrees.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rotl90(a)
2×2 Array{Int64,2}:
 2  4
 1  3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/arraymath.jl#L122-L139}{\texttt{source}}



\begin{lstlisting}
rotl90(A, k)
\end{lstlisting}

Left-rotate matrix \texttt{A} 90 degrees counterclockwise an integer \texttt{k} number of times. If \texttt{k} is a multiple of four (including zero), this is equivalent to a \texttt{copy}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rotl90(a,1)
2×2 Array{Int64,2}:
 2  4
 1  3

julia> rotl90(a,2)
2×2 Array{Int64,2}:
 4  3
 2  1

julia> rotl90(a,3)
2×2 Array{Int64,2}:
 3  1
 4  2

julia> rotl90(a,4)
2×2 Array{Int64,2}:
 1  2
 3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/arraymath.jl#L204-L237}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4661209193738958579}{} 
\hyperlink{4661209193738958579}{\texttt{Base.rotr90}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rotr90(A)
\end{minted}

Rotate matrix \texttt{A} right 90 degrees.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rotr90(a)
2×2 Array{Int64,2}:
 3  1
 4  2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/arraymath.jl#L150-L167}{\texttt{source}}



\begin{lstlisting}
rotr90(A, k)
\end{lstlisting}

Right-rotate matrix \texttt{A} 90 degrees clockwise an integer \texttt{k} number of times. If \texttt{k} is a multiple of four (including zero), this is equivalent to a \texttt{copy}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rotr90(a,1)
2×2 Array{Int64,2}:
 3  1
 4  2

julia> rotr90(a,2)
2×2 Array{Int64,2}:
 4  3
 2  1

julia> rotr90(a,3)
2×2 Array{Int64,2}:
 2  4
 1  3

julia> rotr90(a,4)
2×2 Array{Int64,2}:
 1  2
 3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/arraymath.jl#L244-L277}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8678396932318499078}{} 
\hyperlink{8678396932318499078}{\texttt{Base.mapslices}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mapslices(f, A; dims)
\end{minted}

Transform the given dimensions of array \texttt{A} using function \texttt{f}. \texttt{f} is called on each slice of \texttt{A} of the form \texttt{A[...,:,...,:,...]}. \texttt{dims} is an integer vector specifying where the colons go in this expression. The results are concatenated along the remaining dimensions. For example, if \texttt{dims} is \texttt{[1,2]} and \texttt{A} is 4-dimensional, \texttt{f} is called on \texttt{A[:,:,i,j]} for all \texttt{i} and \texttt{j}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = reshape(Vector(1:16),(2,2,2,2))
2×2×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia> mapslices(sum, a, dims = [1,2])
1×1×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 10

[:, :, 2, 1] =
 26

[:, :, 1, 2] =
 42

[:, :, 2, 2] =
 58
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L1927-L1970}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9554202414701324127}{} 
\hyperlink{9554202414701324127}{\texttt{Base.eachrow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eachrow(A::AbstractVecOrMat)
\end{minted}

Create a generator that iterates over the first dimension of vector or matrix \texttt{A}, returning the rows as views.

See also \hyperlink{16048523827937992118}{\texttt{eachcol}} and \hyperlink{9044337245930922762}{\texttt{eachslice}}.

\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarraymath.jl#L410-L420}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16048523827937992118}{} 
\hyperlink{16048523827937992118}{\texttt{Base.eachcol}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eachcol(A::AbstractVecOrMat)
\end{minted}

Create a generator that iterates over the second dimension of matrix \texttt{A}, returning the columns as views.

See also \hyperlink{9554202414701324127}{\texttt{eachrow}} and \hyperlink{9044337245930922762}{\texttt{eachslice}}.

\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarraymath.jl#L424-L434}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9044337245930922762}{} 
\hyperlink{9044337245930922762}{\texttt{Base.eachslice}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eachslice(A::AbstractArray; dims)
\end{minted}

Create a generator that iterates over dimensions \texttt{dims} of \texttt{A}, returning views that select all the data from the other dimensions in \texttt{A}.

Only a single dimension in \texttt{dims} is currently supported. Equivalent to \texttt{(view(A,:,:,...,i,:,: ...)) for i in axes(A, dims))}, where \texttt{i} is in position \texttt{dims}.

See also \hyperlink{9554202414701324127}{\texttt{eachrow}}, \hyperlink{16048523827937992118}{\texttt{eachcol}}, and \hyperlink{16041553215191638546}{\texttt{selectdim}}.

\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarraymath.jl#L437-L450}{\texttt{source}}


\end{adjustwidth}

\hypertarget{12340194950665653103}{}


\section{Combinatorics}


\hypertarget{1395642908979377386}{} 
\hyperlink{1395642908979377386}{\texttt{Base.invperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
invperm(v)
\end{minted}

Return the inverse permutation of \texttt{v}. If \texttt{B = A[v]}, then \texttt{A == B[invperm(v)]}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [2; 4; 3; 1];

julia> invperm(v)
4-element Array{Int64,1}:
 4
 1
 3
 2

julia> A = ['a','b','c','d'];

julia> B = A[v]
4-element Array{Char,1}:
 'b'
 'd'
 'c'
 'a'

julia> B[invperm(v)]
4-element Array{Char,1}:
 'a'
 'b'
 'c'
 'd'
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/combinatorics.jl#L195-L228}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11897566016863942320}{} 
\hyperlink{11897566016863942320}{\texttt{Base.isperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isperm(v) -> Bool
\end{minted}

Return \texttt{true} if \texttt{v} is a valid permutation.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isperm([1; 2])
true

julia> isperm([1; 3])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/combinatorics.jl#L39-L52}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17157632988142440888}{} 
\hyperlink{17157632988142440888}{\texttt{Base.permute!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
permute!(v, p)
\end{minted}

Permute vector \texttt{v} in-place, according to permutation \texttt{p}. No checking is done to verify that \texttt{p} is a permutation.

To return a new permutation, use \texttt{v[p]}. Note that this is generally faster than \texttt{permute!(v,p)} for large vectors.

See also \hyperlink{7055834640889279783}{\texttt{invpermute!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1, 1, 3, 4];

julia> perm = [2, 4, 3, 1];

julia> permute!(A, perm);

julia> A
4-element Array{Int64,1}:
 1
 4
 3
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/combinatorics.jl#L119-L145}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7055834640889279783}{} 
\hyperlink{7055834640889279783}{\texttt{Base.invpermute!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
invpermute!(v, p)
\end{minted}

Like \hyperlink{17157632988142440888}{\texttt{permute!}}, but the inverse of the given permutation is applied.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1, 1, 3, 4];

julia> perm = [2, 4, 3, 1];

julia> invpermute!(A, perm);

julia> A
4-element Array{Int64,1}:
 4
 1
 3
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/combinatorics.jl#L172-L192}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5598774829914682536}{} 
\hyperlink{5598774829914682536}{\texttt{Base.reverse}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reverse(v [, start=1 [, stop=length(v) ]] )
\end{minted}

Return a copy of \texttt{v} reversed from start to stop.  See also \hyperlink{12943296479800134710}{\texttt{Iterators.reverse}} for reverse-order iteration without making a copy.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = Vector(1:5)
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia> reverse(A)
5-element Array{Int64,1}:
 5
 4
 3
 2
 1

julia> reverse(A, 1, 4)
5-element Array{Int64,1}:
 4
 3
 2
 1
 5

julia> reverse(A, 3, 5)
5-element Array{Int64,1}:
 1
 2
 5
 4
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1473-L1513}{\texttt{source}}



\begin{lstlisting}
reverse(A; dims::Integer)
\end{lstlisting}

Reverse \texttt{A} in dimension \texttt{dims}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> b = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> reverse(b, dims=2)
2×2 Array{Int64,2}:
 2  1
 4  3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarraymath.jl#L130-L147}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16812685153025781176}{} 
\hyperlink{16812685153025781176}{\texttt{Base.reverseind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reverseind(v, i)
\end{minted}

Given an index \texttt{i} in \hyperlink{5598774829914682536}{\texttt{reverse(v)}}, return the corresponding index in \texttt{v} so that \texttt{v[reverseind(v,i)] == reverse(v)[i]}. (This can be nontrivial in cases where \texttt{v} contains non-ASCII characters.)

\textbf{Examples}


\begin{minted}{jlcon}
julia> r = reverse("Julia")
"ailuJ"

julia> for i in 1:length(r)
           print(r[reverseind("Julia", i)])
       end
Julia
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L632-L649}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9702108366803637048}{} 
\hyperlink{9702108366803637048}{\texttt{Base.reverse!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reverse!(v [, start=1 [, stop=length(v) ]]) -> v
\end{minted}

In-place version of \hyperlink{5598774829914682536}{\texttt{reverse}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = Vector(1:5)
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia> reverse!(A);

julia> A
5-element Array{Int64,1}:
 5
 4
 3
 2
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1536-L1561}{\texttt{source}}


\end{adjustwidth}

\hypertarget{13032822450217674886}{}


\chapter{Tasks}


\hypertarget{7131243650304654155}{} 
\hyperlink{7131243650304654155}{\texttt{Core.Task}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Task(func)
\end{minted}

Create a \texttt{Task} (i.e. coroutine) to execute the given function \texttt{func} (which must be callable with no arguments). The task exits when this function returns.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a() = sum(i for i in 1:1000);

julia> b = Task(a);
\end{minted}

In this example, \texttt{b} is a runnable \texttt{Task} that hasn{\textquotesingle}t started yet.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1255-L1269}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16142823989571622868}{} 
\hyperlink{16142823989571622868}{\texttt{Base.@task}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@task
\end{minted}

Wrap an expression in a \hyperlink{7131243650304654155}{\texttt{Task}} without executing it, and return the \hyperlink{7131243650304654155}{\texttt{Task}}. This only creates a task, and does not run it.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a1() = sum(i for i in 1:1000);

julia> b = @task a1();

julia> istaskstarted(b)
false

julia> schedule(b);

julia> yield();

julia> istaskdone(b)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L88-L110}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10770947021537241619}{} 
\hyperlink{10770947021537241619}{\texttt{Base.@async}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@async
\end{minted}

Wrap an expression in a \hyperlink{7131243650304654155}{\texttt{Task}} and add it to the local machine{\textquotesingle}s scheduler queue.

Values can be interpolated into \texttt{@async} via \texttt{\$}, which copies the value directly into the constructed underlying closure. This allows you to insert the \emph{value} of a variable, isolating the aysnchronous code from changes to the variable{\textquotesingle}s value in the current task.

\begin{quote}
\textbf{Julia 1.4}

Interpolating values via \texttt{\$} is available as of Julia 1.4.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L343-L354}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14148755671315265621}{} 
\hyperlink{14148755671315265621}{\texttt{Base.asyncmap}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asyncmap(f, c...; ntasks=0, batch_size=nothing)
\end{minted}

Uses multiple concurrent tasks to map \texttt{f} over a collection (or multiple equal length collections). For multiple collection arguments, \texttt{f} is applied elementwise.

\texttt{ntasks} specifies the number of tasks to run concurrently. Depending on the length of the collections, if \texttt{ntasks} is unspecified, up to 100 tasks will be used for concurrent mapping.

\texttt{ntasks} can also be specified as a zero-arg function. In this case, the number of tasks to run in parallel is checked before processing every element and a new task started if the value of \texttt{ntasks\_func} is less than the current number of tasks.

If \texttt{batch\_size} is specified, the collection is processed in batch mode. \texttt{f} must then be a function that must accept a \texttt{Vector} of argument tuples and must return a vector of results. The input vector will have a length of \texttt{batch\_size} or less.

The following examples highlight execution in different tasks by returning the \texttt{objectid} of the tasks in which the mapping function is executed.

First, with \texttt{ntasks} undefined, each element is processed in a different task.


\begin{lstlisting}
julia> tskoid() = objectid(current_task());

julia> asyncmap(x->tskoid(), 1:5)
5-element Array{UInt64,1}:
 0x6e15e66c75c75853
 0x440f8819a1baa682
 0x9fb3eeadd0c83985
 0xebd3e35fe90d4050
 0x29efc93edce2b961

julia> length(unique(asyncmap(x->tskoid(), 1:5)))
5
\end{lstlisting}

With \texttt{ntasks=2} all elements are processed in 2 tasks.


\begin{lstlisting}
julia> asyncmap(x->tskoid(), 1:5; ntasks=2)
5-element Array{UInt64,1}:
 0x027ab1680df7ae94
 0xa23d2f80cd7cf157
 0x027ab1680df7ae94
 0xa23d2f80cd7cf157
 0x027ab1680df7ae94

julia> length(unique(asyncmap(x->tskoid(), 1:5; ntasks=2)))
2
\end{lstlisting}

With \texttt{batch\_size} defined, the mapping function needs to be changed to accept an array of argument tuples and return an array of results. \texttt{map} is used in the modified mapping function to achieve this.


\begin{lstlisting}
julia> batch_func(input) = map(x->string("args_tuple: ", x, ", element_val: ", x[1], ", task: ", tskoid()), input)
batch_func (generic function with 1 method)

julia> asyncmap(batch_func, 1:5; ntasks=2, batch_size=2)
5-element Array{String,1}:
 "args_tuple: (1,), element_val: 1, task: 9118321258196414413"
 "args_tuple: (2,), element_val: 2, task: 4904288162898683522"
 "args_tuple: (3,), element_val: 3, task: 9118321258196414413"
 "args_tuple: (4,), element_val: 4, task: 4904288162898683522"
 "args_tuple: (5,), element_val: 5, task: 9118321258196414413"
\end{lstlisting}

\begin{quote}
\textbf{Note}

Currently, all tasks in Julia are executed in a single OS thread co-operatively. Consequently, \texttt{asyncmap} is beneficial only when the mapping function involves any I/O - disk, network, remote worker invocation, etc.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/asyncmap.jl#L5-L79}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16469851777080200085}{} 
\hyperlink{16469851777080200085}{\texttt{Base.asyncmap!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asyncmap!(f, results, c...; ntasks=0, batch_size=nothing)
\end{minted}

Like \hyperlink{14148755671315265621}{\texttt{asyncmap}}, but stores output in \texttt{results} rather than returning a collection.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/asyncmap.jl#L412-L417}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12929971401717674174}{} 
\hyperlink{12929971401717674174}{\texttt{Base.current\_task}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
current_task()
\end{minted}

Get the currently running \hyperlink{7131243650304654155}{\texttt{Task}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L115-L119}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7432450399685996831}{} 
\hyperlink{7432450399685996831}{\texttt{Base.istaskdone}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
istaskdone(t::Task) -> Bool
\end{minted}

Determine whether a task has exited.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a2() = sum(i for i in 1:1000);

julia> b = Task(a2);

julia> istaskdone(b)
false

julia> schedule(b);

julia> yield();

julia> istaskdone(b)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L122-L143}{\texttt{source}}


\end{adjustwidth}
\hypertarget{188637489024602838}{} 
\hyperlink{188637489024602838}{\texttt{Base.istaskstarted}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
istaskstarted(t::Task) -> Bool
\end{minted}

Determine whether a task has started executing.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a3() = sum(i for i in 1:1000);

julia> b = Task(a3);

julia> istaskstarted(b)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L146-L160}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2767699747386067716}{} 
\hyperlink{2767699747386067716}{\texttt{Base.istaskfailed}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
istaskfailed(t::Task) -> Bool
\end{minted}

Determine whether a task has exited because an exception was thrown.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a4() = error("task failed");

julia> b = Task(a4);

julia> istaskfailed(b)
false

julia> schedule(b);

julia> yield();

julia> istaskfailed(b)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L163-L184}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8292907206163344794}{} 
\hyperlink{8292907206163344794}{\texttt{Base.task\_local\_storage}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
task_local_storage(key)
\end{minted}

Look up the value of a key in the current task{\textquotesingle}s task-local storage.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L199-L203}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2485476355246980354}{} 
\hyperlink{2485476355246980354}{\texttt{Base.task\_local\_storage}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
task_local_storage(key, value)
\end{minted}

Assign a value to a key in the current task{\textquotesingle}s task-local storage.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L206-L210}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18380692261281200127}{} 
\hyperlink{18380692261281200127}{\texttt{Base.task\_local\_storage}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
task_local_storage(body, key, value)
\end{minted}

Call the function \texttt{body} with a modified task-local storage, in which \texttt{value} is assigned to \texttt{key}; the previous value of \texttt{key}, or lack thereof, is restored afterwards. Useful for emulating dynamic scoping.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L213-L219}{\texttt{source}}


\end{adjustwidth}

\hypertarget{3706829557192562237}{}


\section{Scheduling}


\hypertarget{13455314829114364187}{} 
\hyperlink{13455314829114364187}{\texttt{Base.yield}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
yield()
\end{minted}

Switch to the scheduler to allow another scheduled task to run. A task that calls this function is still runnable, and will be restarted immediately if there are no other runnable tasks.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L600-L606}{\texttt{source}}



\begin{lstlisting}
yield(t::Task, arg = nothing)
\end{lstlisting}

A fast, unfair-scheduling version of \texttt{schedule(t, arg); yield()} which immediately yields to \texttt{t} before calling the scheduler.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L618-L623}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4920987536368477483}{} 
\hyperlink{4920987536368477483}{\texttt{Base.yieldto}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
yieldto(t::Task, arg = nothing)
\end{minted}

Switch to the given task. The first time a task is switched to, the task{\textquotesingle}s function is called with no arguments. On subsequent switches, \texttt{arg} is returned from the task{\textquotesingle}s last call to \texttt{yieldto}. This is a low-level call that only switches tasks, not considering states or scheduling in any way. Its use is discouraged.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L630-L637}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3231475347583891391}{} 
\hyperlink{3231475347583891391}{\texttt{Base.sleep}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sleep(seconds)
\end{minted}

Block the current task for a specified number of seconds. The minimum sleep time is 1 millisecond or input of \texttt{0.001}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/asyncevent.jl#L205-L210}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9185853093207176818}{} 
\hyperlink{9185853093207176818}{\texttt{Base.schedule}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
schedule(t::Task, [val]; error=false)
\end{minted}

Add a \hyperlink{7131243650304654155}{\texttt{Task}} to the scheduler{\textquotesingle}s queue. This causes the task to run constantly when the system is otherwise idle, unless the task performs a blocking operation such as \hyperlink{13761789780433862250}{\texttt{wait}}.

If a second argument \texttt{val} is provided, it will be passed to the task (via the return value of \hyperlink{4920987536368477483}{\texttt{yieldto}}) when it runs again. If \texttt{error} is \texttt{true}, the value is raised as an exception in the woken task.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a5() = sum(i for i in 1:1000);

julia> b = Task(a5);

julia> istaskstarted(b)
false

julia> schedule(b);

julia> yield();

julia> istaskstarted(b)
true

julia> istaskdone(b)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L556-L585}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4182455747623306187}{}


\section{Synchronization}


\hypertarget{7188613740509403855}{} 
\hyperlink{7188613740509403855}{\texttt{Base.@sync}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@sync
\end{minted}

Wait until all lexically-enclosed uses of \texttt{@async}, \texttt{@spawn}, \texttt{@spawnat} and \texttt{@distributed} are complete. All exceptions thrown by enclosed async operations are collected and thrown as a \texttt{CompositeException}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L323-L329}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13761789780433862250}{} 
\hyperlink{13761789780433862250}{\texttt{Base.wait}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Special note for \hyperlink{11528192138203594595}{\texttt{Threads.Condition}}:

The caller must be holding the \hyperlink{3013795445283337804}{\texttt{lock}} that owns \texttt{c} before calling this method. The calling task will be blocked until some other task wakes it, usually by calling \hyperlink{2865179286002578885}{\texttt{notify}}` on the same Condition object. The lock will be atomically released when blocking (even if it was locked recursively), and will be reacquired before returning.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/lock.jl#L211-L219}{\texttt{source}}



\begin{lstlisting}
wait(r::Future)
\end{lstlisting}

Wait for a value to become available for the specified \hyperlink{4170271048165085864}{\texttt{Future}}.




\begin{lstlisting}
wait(r::RemoteChannel, args...)
\end{lstlisting}

Wait for a value to become available on the specified \hyperlink{16773267780467157552}{\texttt{RemoteChannel}}.




\begin{lstlisting}
wait([x])
\end{lstlisting}

Block the current task until some event occurs, depending on the type of the argument:

\begin{itemize}
\item \hyperlink{12548845729684045604}{\texttt{Channel}}: Wait for a value to be appended to the channel.


\item \hyperlink{286351753995469758}{\texttt{Condition}}: Wait for \hyperlink{2865179286002578885}{\texttt{notify}} on a condition.


\item \texttt{Process}: Wait for a process or process chain to exit. The \texttt{exitcode} field of a process can be used to determine success or failure.


\item \hyperlink{7131243650304654155}{\texttt{Task}}: Wait for a \texttt{Task} to finish. If the task fails with an exception, a \texttt{TaskFailedException} (which wraps the failed task) is thrown.


\item \hyperlink{432946111555992347}{\texttt{RawFD}}: Wait for changes on a file descriptor (see the \texttt{FileWatching} package).

\end{itemize}
If no argument is passed, the task blocks for an undefined period. A task can only be restarted by an explicit call to \hyperlink{9185853093207176818}{\texttt{schedule}} or \hyperlink{4920987536368477483}{\texttt{yieldto}}.

Often \texttt{wait} is called within a \texttt{while} loop to ensure a waited-for condition is met before proceeding.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/condition.jl#L81-L99}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11007884648860062495}{} 
\hyperlink{11007884648860062495}{\texttt{Base.fetch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fetch(t::Task)
\end{minted}

Wait for a Task to finish, then return its result value. If the task fails with an exception, a \texttt{TaskFailedException} (which wraps the failed task) is thrown.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L274-L280}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6677218100159857934}{} 
\hyperlink{6677218100159857934}{\texttt{Base.timedwait}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
timedwait(testcb::Function, secs::Float64; pollint::Float64=0.1)
\end{minted}

Waits until \texttt{testcb} returns \texttt{true} or for \texttt{secs} seconds, whichever is earlier. \texttt{testcb} is polled every \texttt{pollint} seconds.

Returns :ok, :timed\_out, or :error



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/asyncevent.jl#L257-L264}{\texttt{source}}


\end{adjustwidth}
\hypertarget{286351753995469758}{} 
\hyperlink{286351753995469758}{\texttt{Base.Condition}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Condition()
\end{minted}

Create an edge-triggered event source that tasks can wait for. Tasks that call \hyperlink{13761789780433862250}{\texttt{wait}} on a \texttt{Condition} are suspended and queued. Tasks are woken up when \hyperlink{2865179286002578885}{\texttt{notify}} is later called on the \texttt{Condition}. Edge triggering means that only tasks waiting at the time \hyperlink{2865179286002578885}{\texttt{notify}} is called can be woken up. For level-triggered notifications, you must keep extra state to keep track of whether a notification has happened. The \hyperlink{12548845729684045604}{\texttt{Channel}} and \hyperlink{13017632704767046438}{\texttt{Threads.Event}} types do this, and can be used for level-triggered events.

This object is NOT thread-safe. See \hyperlink{11528192138203594595}{\texttt{Threads.Condition}} for a thread-safe version.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/condition.jl#L151-L162}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2865179286002578885}{} 
\hyperlink{2865179286002578885}{\texttt{Base.notify}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
notify(condition, val=nothing; all=true, error=false)
\end{minted}

Wake up tasks waiting for a condition, passing them \texttt{val}. If \texttt{all} is \texttt{true} (the default), all waiting tasks are woken, otherwise only one is. If \texttt{error} is \texttt{true}, the passed value is raised as an exception in the woken tasks.

Return the count of tasks woken up. Return 0 if no tasks are waiting on \texttt{condition}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/condition.jl#L115-L123}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11014313312721841609}{} 
\hyperlink{11014313312721841609}{\texttt{Base.Semaphore}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Semaphore(sem_size)
\end{minted}

Create a counting semaphore that allows at most \texttt{sem\_size} acquires to be in use at any time. Each acquire must be matched with a release.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/lock.jl#L225-L231}{\texttt{source}}


\end{adjustwidth}
\hypertarget{733284340937899961}{} 
\hyperlink{733284340937899961}{\texttt{Base.acquire}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acquire(s::Semaphore)
\end{minted}

Wait for one of the \texttt{sem\_size} permits to be available, blocking until one can be acquired.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/lock.jl#L239-L244}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8274760602310731764}{} 
\hyperlink{8274760602310731764}{\texttt{Base.release}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
release(s::Semaphore)
\end{minted}

Return one permit to the pool, possibly allowing another task to acquire it and resume execution.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/lock.jl#L258-L264}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11175712074621861288}{} 
\hyperlink{11175712074621861288}{\texttt{Base.AbstractLock}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractLock
\end{minted}

Abstract supertype describing types that implement the synchronization primitives: \hyperlink{3013795445283337804}{\texttt{lock}}, \hyperlink{8566561467185712956}{\texttt{trylock}}, \hyperlink{7477828718297215912}{\texttt{unlock}}, and \hyperlink{8304067307715619600}{\texttt{islocked}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/condition.jl#L11-L17}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3013795445283337804}{} 
\hyperlink{3013795445283337804}{\texttt{Base.lock}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lock(lock)
\end{minted}

Acquire the \texttt{lock} when it becomes available. If the lock is already locked by a different task/thread, wait for it to become available.

Each \texttt{lock} must be matched by an \hyperlink{7477828718297215912}{\texttt{unlock}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/lock.jl#L58-L66}{\texttt{source}}



\begin{lstlisting}
lock(f::Function, lock)
\end{lstlisting}

Acquire the \texttt{lock}, execute \texttt{f} with the \texttt{lock} held, and release the \texttt{lock} when \texttt{f} returns. If the lock is already locked by a different task/thread, wait for it to become available.

When this function returns, the \texttt{lock} has been released, so the caller should not attempt to \texttt{unlock} it.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/lock.jl#L148-L157}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7477828718297215912}{} 
\hyperlink{7477828718297215912}{\texttt{Base.unlock}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unlock(lock)
\end{minted}

Releases ownership of the \texttt{lock}.

If this is a recursive lock which has been acquired before, decrement an internal counter and return immediately.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/lock.jl#L90-L97}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8566561467185712956}{} 
\hyperlink{8566561467185712956}{\texttt{Base.trylock}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trylock(lock) -> Success (Boolean)
\end{minted}

Acquire the lock if it is available, and return \texttt{true} if successful. If the lock is already locked by a different task/thread, return \texttt{false}.

Each successful \texttt{trylock} must be matched by an \hyperlink{7477828718297215912}{\texttt{unlock}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/lock.jl#L31-L40}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8304067307715619600}{} 
\hyperlink{8304067307715619600}{\texttt{Base.islocked}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
islocked(lock) -> Status (Boolean)
\end{minted}

Check whether the \texttt{lock} is held by any task/thread. This should not be used for synchronization (see instead \hyperlink{8566561467185712956}{\texttt{trylock}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/lock.jl#L21-L26}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7552896090133941635}{} 
\hyperlink{7552896090133941635}{\texttt{Base.ReentrantLock}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ReentrantLock()
\end{minted}

Creates a re-entrant lock for synchronizing \hyperlink{7131243650304654155}{\texttt{Task}}s. The same task can acquire the lock as many times as required. Each \hyperlink{3013795445283337804}{\texttt{lock}} must be matched with an \hyperlink{7477828718297215912}{\texttt{unlock}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/lock.jl#L4-L10}{\texttt{source}}


\end{adjustwidth}

\hypertarget{5026428100850833092}{}


\section{Channels}


\hypertarget{12548845729684045604}{} 
\hyperlink{12548845729684045604}{\texttt{Base.Channel}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Channel{T=Any}(size::Int=0)
\end{minted}

Constructs a \texttt{Channel} with an internal buffer that can hold a maximum of \texttt{size} objects of type \texttt{T}. \hyperlink{12719543094136814100}{\texttt{put!}} calls on a full channel block until an object is removed with \hyperlink{4963355246106153560}{\texttt{take!}}.

\texttt{Channel(0)} constructs an unbuffered channel. \texttt{put!} blocks until a matching \texttt{take!} is called. And vice-versa.

Other constructors:

\begin{itemize}
\item \texttt{Channel()}: default constructor, equivalent to \texttt{Channel\{Any\}(0)}


\item \texttt{Channel(Inf)}: equivalent to \texttt{Channel\{Any\}(typemax(Int))}


\item \texttt{Channel(sz)}: equivalent to \texttt{Channel\{Any\}(sz)}

\end{itemize}
\begin{quote}
\textbf{Julia 1.3}

\end{quote}
The default constructor \texttt{Channel()} and default \texttt{size=0} were added in Julia 1.3.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/channels.jl#L10-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4793580164200292341}{} 
\hyperlink{4793580164200292341}{\texttt{Base.Channel}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Channel{T=Any}(func::Function, size=0; taskref=nothing, spawn=false)
\end{minted}

Create a new task from \texttt{func}, bind it to a new channel of type \texttt{T} and size \texttt{size}, and schedule the task, all in a single call.

\texttt{func} must accept the bound channel as its only argument.

If you need a reference to the created task, pass a \texttt{Ref\{Task\}} object via the keyword argument \texttt{taskref}.

If \texttt{spawn = true}, the Task created for \texttt{func} may be scheduled on another thread in parallel, equivalent to creating a task via \hyperlink{355982830105047813}{\texttt{Threads.@spawn}}.

Return a \texttt{Channel}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> chnl = Channel() do ch
           foreach(i -> put!(ch, i), 1:4)
       end;

julia> typeof(chnl)
Channel{Any}

julia> for i in chnl
           @show i
       end;
i = 1
i = 2
i = 3
i = 4
\end{minted}

Referencing the created task:


\begin{minted}{jlcon}
julia> taskref = Ref{Task}();

julia> chnl = Channel(taskref=taskref) do ch
           println(take!(ch))
       end;

julia> istaskdone(taskref[])
false

julia> put!(chnl, "Hello");
Hello

julia> istaskdone(taskref[])
true
\end{minted}

\begin{quote}
\textbf{Julia 1.3}

\end{quote}
The \texttt{spawn=} parameter was added in Julia 1.3. This constructor was added in Julia 1.3.   In earlier versions of Julia, Channel used keyword arguments to set \texttt{size} and \texttt{T}, but   those constructors are deprecated.


\begin{minted}{jlcon}
julia> chnl = Channel{Char}(1, spawn=true) do ch
           for c in "hello world"
               put!(ch, c)
           end
       end
Channel{Char}(sz_max:1,sz_curr:1)

julia> String(collect(chnl))
"hello world"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/channels.jl#L57-L126}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12719543094136814100}{} 
\hyperlink{12719543094136814100}{\texttt{Base.put!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
put!(c::Channel, v)
\end{minted}

Append an item \texttt{v} to the channel \texttt{c}. Blocks if the channel is full.

For unbuffered channels, blocks until a \hyperlink{4963355246106153560}{\texttt{take!}} is performed by a different task.

\begin{quote}
\textbf{Julia 1.1}

\texttt{v} now gets converted to the channel{\textquotesingle}s type with \hyperlink{1846942650946171605}{\texttt{convert}} as \texttt{put!} is called.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/channels.jl#L300-L310}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6608633734376348608}{} 
\hyperlink{6608633734376348608}{\texttt{Base.take!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
take!(c::Channel)
\end{minted}

Remove and return a value from a \hyperlink{12548845729684045604}{\texttt{Channel}}. Blocks until data is available.

For unbuffered channels, blocks until a \hyperlink{12719543094136814100}{\texttt{put!}} is performed by a different task.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/channels.jl#L375-L382}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15888554370655089980}{} 
\hyperlink{15888554370655089980}{\texttt{Base.isready}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isready(c::Channel)
\end{minted}

Determine whether a \hyperlink{12548845729684045604}{\texttt{Channel}} has a value stored to it. Returns immediately, does not block.

For unbuffered channels returns \texttt{true} if there are tasks waiting on a \hyperlink{12719543094136814100}{\texttt{put!}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/channels.jl#L413-L421}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7098010828229464277}{} 
\hyperlink{7098010828229464277}{\texttt{Base.fetch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fetch(c::Channel)
\end{minted}

Wait for and get the first available item from the channel. Does not remove the item. \texttt{fetch} is unsupported on an unbuffered (0-size) channel.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/channels.jl#L353-L358}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9979143087438478792}{} 
\hyperlink{9979143087438478792}{\texttt{Base.close}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
close(c::Channel[, excp::Exception])
\end{minted}

Close a channel. An exception (optionally given by \texttt{excp}), is thrown by:

\begin{itemize}
\item \hyperlink{12719543094136814100}{\texttt{put!}} on a closed channel.


\item \hyperlink{4963355246106153560}{\texttt{take!}} and \hyperlink{11007884648860062495}{\texttt{fetch}} on an empty, closed channel.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/channels.jl#L171-L178}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6778875052923307054}{} 
\hyperlink{6778875052923307054}{\texttt{Base.bind}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
bind(chnl::Channel, task::Task)
\end{minted}

Associate the lifetime of \texttt{chnl} with a task. \texttt{Channel} \texttt{chnl} is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on \texttt{chnl}.

The \texttt{chnl} object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed \texttt{Channel} objects.

When a channel is bound to multiple tasks, the first task to terminate will close the channel. When multiple channels are bound to the same task, termination of the task will close all of the bound channels.

\textbf{Examples}


\begin{minted}{jlcon}
julia> c = Channel(0);

julia> task = @async foreach(i->put!(c, i), 1:4);

julia> bind(c,task);

julia> for i in c
           @show i
       end;
i = 1
i = 2
i = 3
i = 4

julia> isopen(c)
false
\end{minted}


\begin{minted}{jlcon}
julia> c = Channel(0);

julia> task = @async (put!(c,1);error("foo"));

julia> bind(c,task);

julia> take!(c)
1

julia> put!(c,1);
ERROR: foo
Stacktrace:
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/channels.jl#L194-L243}{\texttt{source}}


\end{adjustwidth}

\hypertarget{7842773949108463380}{}


\chapter{Multi-Threading}


\hypertarget{15582842999596899869}{} 
\hyperlink{15582842999596899869}{\texttt{Base.Threads.@threads}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.@threads
\end{minted}

A macro to parallelize a for-loop to run with multiple threads. This spawns \texttt{nthreads()} number of threads, splits the iteration space amongst them, and iterates in parallel. A barrier is placed at the end of the loop which waits for all the threads to finish execution, and the loop returns.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/threadingconstructs.jl#L75-L82}{\texttt{source}}


\end{adjustwidth}
\hypertarget{355982830105047813}{} 
\hyperlink{355982830105047813}{\texttt{Base.Threads.@spawn}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.@spawn expr
\end{minted}

Create and run a \hyperlink{7131243650304654155}{\texttt{Task}} on any available thread. To wait for the task to finish, call \hyperlink{13761789780433862250}{\texttt{wait}} on the result of this macro, or call \hyperlink{11007884648860062495}{\texttt{fetch}} to wait and then obtain its return value.

Values can be interpolated into \texttt{@spawn} via \texttt{\$}, which copies the value directly into the constructed underlying closure. This allows you to insert the \emph{value} of a variable, isolating the aysnchronous code from changes to the variable{\textquotesingle}s value in the current task.

\begin{quote}
\textbf{Note}

This feature is currently considered experimental.

\end{quote}
\begin{quote}
\textbf{Julia 1.3}

This macro is available as of Julia 1.3.

\end{quote}
\begin{quote}
\textbf{Julia 1.4}

Interpolating values via \texttt{\$} is available as of Julia 1.4.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/threadingconstructs.jl#L103-L122}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12668125807854133993}{} 
\hyperlink{12668125807854133993}{\texttt{Base.Threads.threadid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.threadid()
\end{minted}

Get the ID number of the current thread of execution. The master thread has ID \texttt{1}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/threadingconstructs.jl#L5-L9}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11061583461116144745}{} 
\hyperlink{11061583461116144745}{\texttt{Base.Threads.nthreads}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.nthreads()
\end{minted}

Get the number of threads available to the Julia process. This is the inclusive upper bound on \texttt{threadid()}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/threadingconstructs.jl#L13-L18}{\texttt{source}}


\end{adjustwidth}

\hypertarget{9063370155780136313}{}


\section{Synchronization}


\hypertarget{11528192138203594595}{} 
\hyperlink{11528192138203594595}{\texttt{Base.Threads.Condition}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.Condition([lock])
\end{minted}

A thread-safe version of \hyperlink{286351753995469758}{\texttt{Base.Condition}}.

\begin{quote}
\textbf{Julia 1.2}

This functionality requires at least Julia 1.2.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/lock.jl#L201-L208}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13017632704767046438}{} 
\hyperlink{13017632704767046438}{\texttt{Base.Event}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Event()
\end{minted}

Create a level-triggered event source. Tasks that call \hyperlink{13761789780433862250}{\texttt{wait}} on an \texttt{Event} are suspended and queued until \texttt{notify} is called on the \texttt{Event}. After \texttt{notify} is called, the \texttt{Event} remains in a signaled state and tasks will no longer block when waiting for it.

\begin{quote}
\textbf{Julia 1.1}

This functionality requires at least Julia 1.1.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/lock.jl#L278-L288}{\texttt{source}}


\end{adjustwidth}

See also \hyperlink{7928897202753469122}{Synchronization}.



\hypertarget{14092913848436173389}{}


\section{Atomic operations}



\begin{quote}
\textbf{Warning}

The API for atomic operations has not yet been finalized and is likely to change.

\end{quote}

\hypertarget{1140117372581270616}{} 
\hyperlink{1140117372581270616}{\texttt{Base.Threads.Atomic}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.Atomic{T}
\end{minted}

Holds a reference to an object of type \texttt{T}, ensuring that it is only accessed atomically, i.e. in a thread-safe manner.

Only certain {\textquotedbl}simple{\textquotedbl} types can be used atomically, namely the primitive boolean, integer, and float-point types. These are \texttt{Bool}, \texttt{Int8}...\texttt{Int128}, \texttt{UInt8}...\texttt{UInt128}, and \texttt{Float16}...\texttt{Float64}.

New atomic objects can be created from a non-atomic values; if none is specified, the atomic object is initialized with zero.

Atomic objects can be accessed using the \texttt{[]} notation:

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> x[] = 1
1

julia> x[]
1
\end{minted}

Atomic operations use an \texttt{atomic\_} prefix, such as \hyperlink{4669846204248874730}{\texttt{atomic\_add!}}, \hyperlink{15583989732166753404}{\texttt{atomic\_xchg!}}, etc.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/atomics.jl#L34-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6924433775344145551}{} 
\hyperlink{6924433775344145551}{\texttt{Base.Threads.atomic\_cas!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.atomic_cas!(x::Atomic{T}, cmp::T, newval::T) where T
\end{minted}

Atomically compare-and-set \texttt{x}

Atomically compares the value in \texttt{x} with \texttt{cmp}. If equal, write \texttt{newval} to \texttt{x}. Otherwise, leaves \texttt{x} unmodified. Returns the old value in \texttt{x}. By comparing the returned value to \texttt{cmp} (via \texttt{===}) one knows whether \texttt{x} was modified and now holds the new value \texttt{newval}.

For further details, see LLVM{\textquotesingle}s \texttt{cmpxchg} instruction.

This function can be used to implement transactional semantics. Before the transaction, one records the value in \texttt{x}. After the transaction, the new value is stored only if \texttt{x} has not been modified in the mean time.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_cas!(x, 4, 2);

julia> x
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_cas!(x, 3, 2);

julia> x
Base.Threads.Atomic{Int64}(2)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/atomics.jl#L72-L104}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15583989732166753404}{} 
\hyperlink{15583989732166753404}{\texttt{Base.Threads.atomic\_xchg!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.atomic_xchg!(x::Atomic{T}, newval::T) where T
\end{minted}

Atomically exchange the value in \texttt{x}

Atomically exchanges the value in \texttt{x} with \texttt{newval}. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw xchg} instruction.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_xchg!(x, 2)
3

julia> x[]
2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/atomics.jl#L107-L128}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4669846204248874730}{} 
\hyperlink{4669846204248874730}{\texttt{Base.Threads.atomic\_add!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.atomic_add!(x::Atomic{T}, val::T) where T <: ArithmeticTypes
\end{minted}

Atomically add \texttt{val} to \texttt{x}

Performs \texttt{x[] += val} atomically. Returns the \textbf{old} value. Not defined for \texttt{Atomic\{Bool\}}.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw add} instruction.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_add!(x, 2)
3

julia> x[]
5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/atomics.jl#L131-L152}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17642173571521486894}{} 
\hyperlink{17642173571521486894}{\texttt{Base.Threads.atomic\_sub!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.atomic_sub!(x::Atomic{T}, val::T) where T <: ArithmeticTypes
\end{minted}

Atomically subtract \texttt{val} from \texttt{x}

Performs \texttt{x[] -= val} atomically. Returns the \textbf{old} value. Not defined for \texttt{Atomic\{Bool\}}.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw sub} instruction.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_sub!(x, 2)
3

julia> x[]
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/atomics.jl#L155-L176}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17667453349907943193}{} 
\hyperlink{17667453349907943193}{\texttt{Base.Threads.atomic\_and!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.atomic_and!(x::Atomic{T}, val::T) where T
\end{minted}

Atomically bitwise-and \texttt{x} with \texttt{val}

Performs \texttt{x[] \&= val} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw and} instruction.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_and!(x, 2)
3

julia> x[]
2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/atomics.jl#L179-L199}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7585036809570134634}{} 
\hyperlink{7585036809570134634}{\texttt{Base.Threads.atomic\_nand!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.atomic_nand!(x::Atomic{T}, val::T) where T
\end{minted}

Atomically bitwise-nand (not-and) \texttt{x} with \texttt{val}

Performs \texttt{x[] = {\textasciitilde}(x[] \& val)} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw nand} instruction.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_nand!(x, 2)
3

julia> x[]
-3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/atomics.jl#L202-L222}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13607043969188851947}{} 
\hyperlink{13607043969188851947}{\texttt{Base.Threads.atomic\_or!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.atomic_or!(x::Atomic{T}, val::T) where T
\end{minted}

Atomically bitwise-or \texttt{x} with \texttt{val}

Performs \texttt{x[] |= val} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw or} instruction.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(5)
Base.Threads.Atomic{Int64}(5)

julia> Threads.atomic_or!(x, 7)
5

julia> x[]
7
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/atomics.jl#L225-L245}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5701145140539338563}{} 
\hyperlink{5701145140539338563}{\texttt{Base.Threads.atomic\_xor!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.atomic_xor!(x::Atomic{T}, val::T) where T
\end{minted}

Atomically bitwise-xor (exclusive-or) \texttt{x} with \texttt{val}

Performs \texttt{x[] \$= val} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw xor} instruction.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(5)
Base.Threads.Atomic{Int64}(5)

julia> Threads.atomic_xor!(x, 7)
5

julia> x[]
2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/atomics.jl#L248-L268}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8102033568033818241}{} 
\hyperlink{8102033568033818241}{\texttt{Base.Threads.atomic\_max!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.atomic_max!(x::Atomic{T}, val::T) where T
\end{minted}

Atomically store the maximum of \texttt{x} and \texttt{val} in \texttt{x}

Performs \texttt{x[] = max(x[], val)} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw max} instruction.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(5)
Base.Threads.Atomic{Int64}(5)

julia> Threads.atomic_max!(x, 7)
5

julia> x[]
7
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/atomics.jl#L271-L291}{\texttt{source}}


\end{adjustwidth}
\hypertarget{392667369563982661}{} 
\hyperlink{392667369563982661}{\texttt{Base.Threads.atomic\_min!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.atomic_min!(x::Atomic{T}, val::T) where T
\end{minted}

Atomically store the minimum of \texttt{x} and \texttt{val} in \texttt{x}

Performs \texttt{x[] = min(x[], val)} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw min} instruction.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(7)
Base.Threads.Atomic{Int64}(7)

julia> Threads.atomic_min!(x, 5)
7

julia> x[]
5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/atomics.jl#L294-L314}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6451121520734566874}{} 
\hyperlink{6451121520734566874}{\texttt{Base.Threads.atomic\_fence}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.atomic_fence()
\end{minted}

Insert a sequential-consistency memory fence

Inserts a memory fence with sequentially-consistent ordering semantics. There are algorithms where this is needed, i.e. where an acquire/release ordering is insufficient.

This is likely a very expensive operation. Given that all other atomic operations in Julia already have acquire/release semantics, explicit fences should not be necessary in most cases.

For further details, see LLVM{\textquotesingle}s \texttt{fence} instruction.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/atomics.jl#L432-L446}{\texttt{source}}


\end{adjustwidth}

\hypertarget{6332880025315332163}{}


\section{ccall using a threadpool (Experimental)}


\hypertarget{4118169676263419404}{} 
\hyperlink{4118169676263419404}{\texttt{Base.@threadcall}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@threadcall((cfunc, clib), rettype, (argtypes...), argvals...)
\end{minted}

The \texttt{@threadcall} macro is called in the same way as \hyperlink{14245046751182637566}{\texttt{ccall}} but does the work in a different thread. This is useful when you want to call a blocking C function without causing the main \texttt{julia} thread to become blocked. Concurrency is limited by size of the libuv thread pool, which defaults to 4 threads but can be increased by setting the \texttt{UV\_THREADPOOL\_SIZE} environment variable and restarting the \texttt{julia} process.

Note that the called function should never call back into Julia.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/threadcall.jl#L7-L18}{\texttt{source}}


\end{adjustwidth}

\hypertarget{13905974260827344810}{}


\section{Low-level synchronization primitives}



These building blocks are used to create the regular synchronization objects.


\hypertarget{16883834658935510339}{} 
\hyperlink{16883834658935510339}{\texttt{Base.Threads.SpinLock}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SpinLock()
\end{minted}

Create a non-reentrant, test-and-test-and-set spin lock. Recursive use will result in a deadlock. This kind of lock should only be used around code that takes little time to execute and does not block (e.g. perform I/O). In general, \hyperlink{7552896090133941635}{\texttt{ReentrantLock}} should be used instead.

Each \hyperlink{3013795445283337804}{\texttt{lock}} must be matched with an \hyperlink{7477828718297215912}{\texttt{unlock}}.

Test-and-test-and-set spin locks are quickest up to about 30ish contending threads. If you have more contention than that, different synchronization approaches should be considered.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/locks-mt.jl#L14-L28}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4380185033557519432}{}


\chapter{常量}


\hypertarget{9331422207248206047}{} 
\hyperlink{9331422207248206047}{\texttt{Core.nothing}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nothing
\end{minted}

The singleton instance of type \hyperlink{13508459519898889544}{\texttt{Nothing}}, used by convention when there is no value to return (as in a C \texttt{void} function) or when a variable or field holds no value.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1057-L1062}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9054270179006636705}{} 
\hyperlink{9054270179006636705}{\texttt{Base.PROGRAM\_FILE}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
PROGRAM_FILE
\end{minted}

A string containing the script name passed to Julia from the command line. Note that the script name remains unchanged from within included files. Alternatively see \hyperlink{1518763743618824993}{\texttt{@\_\_FILE\_\_}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/initdefs.jl#L5-L11}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2567473177880607455}{} 
\hyperlink{2567473177880607455}{\texttt{Base.ARGS}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ARGS
\end{minted}

An array of the command line arguments passed to Julia, as strings.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/initdefs.jl#L14-L18}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11444309529550205492}{} 
\hyperlink{11444309529550205492}{\texttt{Base.C\_NULL}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
C_NULL
\end{minted}

The C null pointer constant, sometimes used when calling external code.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/pointer.jl#L13-L17}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12605722316331458198}{} 
\hyperlink{12605722316331458198}{\texttt{Base.VERSION}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
VERSION
\end{minted}

A \texttt{VersionNumber} object describing which version of Julia is in use. For details see \hyperlink{12935585355849408291}{Version Number Literals}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/version.jl#L216-L221}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15271486679944781836}{} 
\hyperlink{15271486679944781836}{\texttt{Base.DEPOT\_PATH}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DEPOT_PATH
\end{minted}

A stack of {\textquotedbl}depot{\textquotedbl} locations where the package manager, as well as Julia{\textquotesingle}s code loading mechanisms, look for package registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files. By default it includes:

\begin{itemize}
\item[1. ] \texttt{{\textasciitilde}/.julia} where \texttt{{\textasciitilde}} is the user home as appropriate on the system;


\item[2. ] an architecture-specific shared system directory, e.g. \texttt{/usr/local/share/julia};


\item[3. ] an architecture-independent shared system directory, e.g. \texttt{/usr/share/julia}.

\end{itemize}
So \texttt{DEPOT\_PATH} might be:


\begin{minted}{julia}
[joinpath(homedir(), ".julia"), "/usr/local/share/julia", "/usr/share/julia"]
\end{minted}

The first entry is the {\textquotedbl}user depot{\textquotedbl} and should be writable by and owned by the current user. The user depot is where: registries are cloned, new package versions are installed, named environments are created and updated, package repos are cloned, newly compiled package image files are saved, log files are written, development packages are checked out by default, and global configuration data is saved. Later entries in the depot path are treated as read-only and are appropriate for registries, packages, etc. installed and managed by system administrators.

\texttt{DEPOT\_PATH} is populated based on the \hyperlink{6468636275358768444}{\texttt{JULIA\_DEPOT\_PATH}} environment variable if set.

See also: \hyperlink{6468636275358768444}{\texttt{JULIA\_DEPOT\_PATH}}, and \href{@ref Code-Loading}{Code Loading}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/initdefs.jl#L44-L74}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17914149694871263675}{} 
\hyperlink{17914149694871263675}{\texttt{Base.LOAD\_PATH}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LOAD_PATH
\end{minted}

An array of paths for \texttt{using} and \texttt{import} statements to consider as project environments or package directories when loading code. It is populated based on the \hyperlink{8995491879208063980}{\texttt{JULIA\_LOAD\_PATH}} environment variable if set; otherwise it defaults to \texttt{[{\textquotedbl}@{\textquotedbl}, {\textquotedbl}@v\#.\#{\textquotedbl}, {\textquotedbl}@stdlib{\textquotedbl}]}. Entries starting with \texttt{@} have special meanings:

\begin{itemize}
\item \texttt{@} refers to the {\textquotedbl}current active environment{\textquotedbl}, the initial value of which is initially determined by the \hyperlink{596026888060672066}{\texttt{JULIA\_PROJECT}} environment variable or the \texttt{--project} command-line option.


\item \texttt{@stdlib} expands to the absolute path of the current Julia installation{\textquotesingle}s standard library directory.


\item \texttt{@name} refers to a named environment, which are stored in depots (see \hyperlink{6468636275358768444}{\texttt{JULIA\_DEPOT\_PATH}}) under the \texttt{environments} subdirectory. The user{\textquotesingle}s named environments are stored in \texttt{{\textasciitilde}/.julia/environments} so \texttt{@name} would refer to the environment in \texttt{{\textasciitilde}/.julia/environments/name} if it exists and contains a \texttt{Project.toml} file. If \texttt{name} contains \texttt{\#} characters, then they are replaced with the major, minor and patch components of the Julia version number. For example, if you are running Julia 1.2 then \texttt{@v\#.\#} expands to \texttt{@v1.2} and will look for an environment by that name, typically at \texttt{{\textasciitilde}/.julia/environments/v1.2}.

\end{itemize}
The fully expanded value of \texttt{LOAD\_PATH} that is searched for projects and packages can be seen by calling the \texttt{Base.load\_path()} function.

See also: \hyperlink{8995491879208063980}{\texttt{JULIA\_LOAD\_PATH}}, \hyperlink{596026888060672066}{\texttt{JULIA\_PROJECT}}, \hyperlink{6468636275358768444}{\texttt{JULIA\_DEPOT\_PATH}}, and \href{@ref Code-Loading}{Code Loading}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/initdefs.jl#L122-L156}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11034333937761980027}{} 
\hyperlink{11034333937761980027}{\texttt{Base.Sys.BINDIR}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.BINDIR
\end{minted}

A string containing the full path to the directory containing the \texttt{julia} executable.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L39-L43}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5072616208401232599}{} 
\hyperlink{5072616208401232599}{\texttt{Base.Sys.CPU\_THREADS}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.CPU_THREADS
\end{minted}

The number of logical CPU cores available in the system, i.e. the number of threads that the CPU can run concurrently. Note that this is not necessarily the number of CPU cores, for example, in the presence of \href{https://en.wikipedia.org/wiki/Hyper-threading}{hyper-threading}.

See Hwloc.jl or CpuId.jl for extended information, including number of physical cores.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L58-L67}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6553323097149877235}{} 
\hyperlink{6553323097149877235}{\texttt{Base.Sys.WORD\_SIZE}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.WORD_SIZE
\end{minted}

Standard word size on the current machine, in bits.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L92-L96}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9866627704997689218}{} 
\hyperlink{9866627704997689218}{\texttt{Base.Sys.KERNEL}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.KERNEL
\end{minted}

A symbol representing the name of the operating system, as returned by \texttt{uname} of the build configuration.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L78-L82}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10411677719248532228}{} 
\hyperlink{10411677719248532228}{\texttt{Base.Sys.ARCH}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.ARCH
\end{minted}

A symbol representing the architecture of the build configuration.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L70-L74}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14835867711534070832}{} 
\hyperlink{14835867711534070832}{\texttt{Base.Sys.MACHINE}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.MACHINE
\end{minted}

A string containing the build triple.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L85-L89}{\texttt{source}}


\end{adjustwidth}

参见：



\begin{itemize}
\item \hyperlink{3330957653919693521}{\texttt{stdin}}


\item \hyperlink{18181294266083891471}{\texttt{stdout}}


\item \hyperlink{6150355911915549172}{\texttt{stderr}}


\item \hyperlink{196658496437650743}{\texttt{ENV}}


\item \hyperlink{15528013539058180213}{\texttt{ENDIAN\_BOM}}


\item \texttt{Libc.MS\_ASYNC}


\item \texttt{Libc.MS\_INVALIDATE}


\item \texttt{Libc.MS\_SYNC}

\end{itemize}


\hypertarget{14157880486595246176}{}


\chapter{文件系统}


\hypertarget{16313884780490629439}{} 
\hyperlink{16313884780490629439}{\texttt{Base.Filesystem.pwd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pwd() -> AbstractString
\end{minted}

Get the current working directory.

\textbf{Examples}


\begin{minted}{jlcon}
julia> pwd()
"/home/JuliaUser"

julia> cd("/home/JuliaUser/Projects/julia")

julia> pwd()
"/home/JuliaUser/Projects/julia"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L32-L47}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2737128667296781766}{} 
\hyperlink{2737128667296781766}{\texttt{Base.Filesystem.cd}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cd(dir::AbstractString=homedir())
\end{minted}

Set the current working directory.

\textbf{Examples}


\begin{minted}{jlcon}
julia> cd("/home/JuliaUser/Projects/julia")

julia> pwd()
"/home/JuliaUser/Projects/julia"

julia> cd()

julia> pwd()
"/home/JuliaUser"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L65-L82}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5425414028590761114}{} 
\hyperlink{5425414028590761114}{\texttt{Base.Filesystem.cd}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cd(f::Function, dir::AbstractString=homedir())
\end{minted}

Temporarily change the current working directory to \texttt{dir}, apply function \texttt{f} and finally return to the original directory.

\textbf{Examples}


\begin{minted}{jlcon}
julia> pwd()
"/home/JuliaUser"

julia> cd(readdir, "/home/JuliaUser/Projects/julia")
34-element Array{String,1}:
 ".circleci"
 ".freebsdci.sh"
 ".git"
 ".gitattributes"
 ".github"
 ⋮
 "test"
 "ui"
 "usr"
 "usr-staging"

julia> pwd()
"/home/JuliaUser"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L111-L138}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3860759521350595217}{} 
\hyperlink{3860759521350595217}{\texttt{Base.Filesystem.readdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readdir(dir::AbstractString=pwd();
    join::Bool = false,
    sort::Bool = true,
) -> Vector{String}
\end{minted}

Return the names in the directory \texttt{dir} or the current working directory if not given. When \texttt{join} is false, \texttt{readdir} returns just the names in the directory as is; when \texttt{join} is true, it returns \texttt{joinpath(dir, name)} for each \texttt{name} so that the returned strings are full paths. If you want to get absolute paths back, call \texttt{readdir} with an absolute directory path and \texttt{join} set to true.

By default, \texttt{readdir} sorts the list of names it returns. If you want to skip sorting the names and get them in the order that the file system lists them, you can use \texttt{readir(dir, sort=false)} to opt out of sorting.

\begin{quote}
\textbf{Julia 1.4}

The \texttt{join} and \texttt{sort} keyword arguments require at least Julia 1.4.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> cd("/home/JuliaUser/dev/julia")

julia> readdir()
30-element Array{String,1}:
 ".appveyor.yml"
 ".git"
 ".gitattributes"
 ⋮
 "ui"
 "usr"
 "usr-staging"

julia> readdir(join=true)
30-element Array{String,1}:
 "/home/JuliaUser/dev/julia/.appveyor.yml"
 "/home/JuliaUser/dev/julia/.git"
 "/home/JuliaUser/dev/julia/.gitattributes"
 ⋮
 "/home/JuliaUser/dev/julia/ui"
 "/home/JuliaUser/dev/julia/usr"
 "/home/JuliaUser/dev/julia/usr-staging"

julia> readdir("base")
145-element Array{String,1}:
 ".gitignore"
 "Base.jl"
 "Enums.jl"
 ⋮
 "version_git.sh"
 "views.jl"
 "weakkeydict.jl"

julia> readdir("base", join=true)
145-element Array{String,1}:
 "base/.gitignore"
 "base/Base.jl"
 "base/Enums.jl"
 ⋮
 "base/version_git.sh"
 "base/views.jl"
 "base/weakkeydict.jl"```

julia> readdir(abspath("base"), join=true)
145-element Array{String,1}:
 "/home/JuliaUser/dev/julia/base/.gitignore"
 "/home/JuliaUser/dev/julia/base/Base.jl"
 "/home/JuliaUser/dev/julia/base/Enums.jl"
 ⋮
 "/home/JuliaUser/dev/julia/base/version_git.sh"
 "/home/JuliaUser/dev/julia/base/views.jl"
 "/home/JuliaUser/dev/julia/base/weakkeydict.jl"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L699-L772}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6143720268840384551}{} 
\hyperlink{6143720268840384551}{\texttt{Base.Filesystem.walkdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
walkdir(dir; topdown=true, follow_symlinks=false, onerror=throw)
\end{minted}

Return an iterator that walks the directory tree of a directory. The iterator returns a tuple containing \texttt{(rootpath, dirs, files)}. The directory tree can be traversed top-down or bottom-up. If \texttt{walkdir} encounters a \hyperlink{16303515589950241655}{\texttt{SystemError}} it will rethrow the error by default. A custom error handling function can be provided through \texttt{onerror} keyword argument. \texttt{onerror} is called with a \texttt{SystemError} as argument.

\textbf{Examples}


\begin{minted}{julia}
for (root, dirs, files) in walkdir(".")
    println("Directories in $root")
    for dir in dirs
        println(joinpath(root, dir)) # path to directories
    end
    println("Files in $root")
    for file in files
        println(joinpath(root, file)) # path to files
    end
end
\end{minted}


\begin{minted}{jlcon}
julia> mkpath("my/test/dir");

julia> itr = walkdir("my");

julia> (root, dirs, files) = first(itr)
("my", ["test"], String[])

julia> (root, dirs, files) = first(itr)
("my/test", ["dir"], String[])

julia> (root, dirs, files) = first(itr)
("my/test/dir", String[], String[])
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L801-L840}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17495480510333417689}{} 
\hyperlink{17495480510333417689}{\texttt{Base.Filesystem.mkdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mkdir(path::AbstractString; mode::Unsigned = 0o777)
\end{minted}

Make a new directory with name \texttt{path} and permissions \texttt{mode}. \texttt{mode} defaults to \texttt{0o777}, modified by the current file creation mask. This function never creates more than one directory. If the directory already exists, or some intermediate directories do not exist, this function throws an error. See \hyperlink{12505165128372133919}{\texttt{mkpath}} for a function which creates all required intermediate directories. Return \texttt{path}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> mkdir("testingdir")
"testingdir"

julia> cd("testingdir")

julia> pwd()
"/home/JuliaUser/testingdir"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L148-L168}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12505165128372133919}{} 
\hyperlink{12505165128372133919}{\texttt{Base.Filesystem.mkpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mkpath(path::AbstractString; mode::Unsigned = 0o777)
\end{minted}

Create all directories in the given \texttt{path}, with permissions \texttt{mode}. \texttt{mode} defaults to \texttt{0o777}, modified by the current file creation mask. Return \texttt{path}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> mkdir("testingdir")
"testingdir"

julia> cd("testingdir")

julia> pwd()
"/home/JuliaUser/testingdir"

julia> mkpath("my/test/dir")
"my/test/dir"

julia> readdir()
1-element Array{String,1}:
 "my"

julia> cd("my")

julia> readdir()
1-element Array{String,1}:
 "test"

julia> readdir("test")
1-element Array{String,1}:
 "dir"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L186-L220}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2547536134326433103}{} 
\hyperlink{2547536134326433103}{\texttt{Base.Filesystem.symlink}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
symlink(target::AbstractString, link::AbstractString)
\end{minted}

Creates a symbolic link to \texttt{target} with the name \texttt{link}.

\begin{quote}
\textbf{Note}

This function raises an error under operating systems that do not support soft symbolic links, such as Windows XP.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L930-L938}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17144805426178555631}{} 
\hyperlink{17144805426178555631}{\texttt{Base.Filesystem.readlink}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readlink(path::AbstractString) -> AbstractString
\end{minted}

Return the target location a symbolic link \texttt{path} points to.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L961-L965}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11345760495317535206}{} 
\hyperlink{11345760495317535206}{\texttt{Base.Filesystem.chmod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
chmod(path::AbstractString, mode::Integer; recursive::Bool=false)
\end{minted}

Change the permissions mode of \texttt{path} to \texttt{mode}. Only integer \texttt{mode}s (e.g. \texttt{0o777}) are currently supported. If \texttt{recursive=true} and the path is a directory all permissions in that directory will be recursively changed. Return \texttt{path}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L985-L992}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11782125422345839965}{} 
\hyperlink{11782125422345839965}{\texttt{Base.Filesystem.chown}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
chown(path::AbstractString, owner::Integer, group::Integer=-1)
\end{minted}

Change the owner and/or group of \texttt{path} to \texttt{owner} and/or \texttt{group}. If the value entered for \texttt{owner} or \texttt{group} is \texttt{-1} the corresponding ID will not change. Only integer \texttt{owner}s and \texttt{group}s are currently supported. Return \texttt{path}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L1006-L1012}{\texttt{source}}


\end{adjustwidth}
\hypertarget{432946111555992347}{} 
\hyperlink{432946111555992347}{\texttt{Base.Libc.RawFD}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RawFD
\end{minted}

Primitive type which wraps the native OS file descriptor. \texttt{RawFD}s can be passed to methods like \hyperlink{10861694406169986183}{\texttt{stat}} to discover information about the underlying file, and can also be used to open streams, with the \texttt{RawFD} describing the OS file backing the stream.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L22-L30}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10861694406169986183}{} 
\hyperlink{10861694406169986183}{\texttt{Base.stat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stat(file)
\end{minted}

Returns a structure whose fields contain information about the file. The fields of the structure are:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Name & Description \\
\hline
size & The size (in bytes) of the file \\
\hline
device & ID of the device that contains the file \\
\hline
inode & The inode number of the file \\
\hline
mode & The protection mode of the file \\
\hline
nlink & The number of hard links to the file \\
\hline
uid & The user id of the owner of the file \\
\hline
gid & The group id of the file owner \\
\hline
rdev & If this file refers to a device, the ID of the device it refers to \\
\hline
blksize & The file-system preferred block size for the file \\
\hline
blocks & The number of such blocks allocated \\
\hline
mtime & Unix timestamp of when the file was last modified \\
\hline
ctime & Unix timestamp of when the file was created \\
\hline
\end{tabulary}

\end{table}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L87-L108}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14136422515630953157}{} 
\hyperlink{14136422515630953157}{\texttt{Base.Filesystem.lstat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lstat(file)
\end{minted}

Like \hyperlink{10861694406169986183}{\texttt{stat}}, but for symbolic links gets the info for the link itself rather than the file it refers to. This function must be called on a file path rather than a file object or a file descriptor.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L111-L118}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12867604313294084336}{} 
\hyperlink{12867604313294084336}{\texttt{Base.Filesystem.ctime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ctime(file)
\end{minted}

Equivalent to \texttt{stat(file).ctime}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L144-L148}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6000535741376632237}{} 
\hyperlink{6000535741376632237}{\texttt{Base.Filesystem.mtime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mtime(file)
\end{minted}

Equivalent to \texttt{stat(file).mtime}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L137-L141}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13483994185565548500}{} 
\hyperlink{13483994185565548500}{\texttt{Base.Filesystem.filemode}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
filemode(file)
\end{minted}

Equivalent to \texttt{stat(file).mode}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L123-L127}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7772513328501904656}{} 
\hyperlink{7772513328501904656}{\texttt{Base.Filesystem.filesize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
filesize(path...)
\end{minted}

Equivalent to \texttt{stat(file).size}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L130-L134}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1627468638377378187}{} 
\hyperlink{1627468638377378187}{\texttt{Base.Filesystem.uperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
uperm(file)
\end{minted}

Get the permissions of the owner of the file as a bitfield of


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Value & Description \\
\hline
01 & Execute Permission \\
\hline
02 & Write Permission \\
\hline
04 & Read Permission \\
\hline
\end{tabulary}

\end{table}

For allowed arguments, see \hyperlink{10861694406169986183}{\texttt{stat}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L260-L272}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7004818904788863313}{} 
\hyperlink{7004818904788863313}{\texttt{Base.Filesystem.gperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gperm(file)
\end{minted}

Like \hyperlink{1627468638377378187}{\texttt{uperm}} but gets the permissions of the group owning the file.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L275-L279}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5276829438522229212}{} 
\hyperlink{5276829438522229212}{\texttt{Base.Filesystem.operm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
operm(file)
\end{minted}

Like \hyperlink{1627468638377378187}{\texttt{uperm}} but gets the permissions for people who neither own the file nor are a member of the group owning the file



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L282-L287}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5101460505107133606}{} 
\hyperlink{5101460505107133606}{\texttt{Base.Filesystem.cp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cp(src::AbstractString, dst::AbstractString; force::Bool=false, follow_symlinks::Bool=false)
\end{minted}

Copy the file, link, or directory from \texttt{src} to \texttt{dst}. \texttt{force=true} will first remove an existing \texttt{dst}.

If \texttt{follow\_symlinks=false}, and \texttt{src} is a symbolic link, \texttt{dst} will be created as a symbolic link. If \texttt{follow\_symlinks=true} and \texttt{src} is a symbolic link, \texttt{dst} will be a copy of the file or directory \texttt{src} refers to. Return \texttt{dst}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L332-L342}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3963309772903794843}{} 
\hyperlink{3963309772903794843}{\texttt{Base.download}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
download(url::AbstractString, [localfile::AbstractString])
\end{minted}

Download a file from the given url, optionally renaming it to the given local file name. If no filename is given this will download into a randomly-named file in your temp directory. Note that this function relies on the availability of external tools such as \texttt{curl}, \texttt{wget} or \texttt{fetch} to download the file and is provided for convenience. For production use or situations in which more options are needed, please use a package that provides the desired functionality instead.

Returns the filename of the downloaded file.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/download.jl#L85-L96}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5817011497347557360}{} 
\hyperlink{5817011497347557360}{\texttt{Base.Filesystem.mv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mv(src::AbstractString, dst::AbstractString; force::Bool=false)
\end{minted}

Move the file, link, or directory from \texttt{src} to \texttt{dst}. \texttt{force=true} will first remove an existing \texttt{dst}. Return \texttt{dst}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> write("hello.txt", "world");

julia> mv("hello.txt", "goodbye.txt")
"goodbye.txt"

julia> "hello.txt" in readdir()
false

julia> readline("goodbye.txt")
"world"

julia> write("hello.txt", "world2");

julia> mv("hello.txt", "goodbye.txt")
ERROR: ArgumentError: 'goodbye.txt' exists. `force=true` is required to remove 'goodbye.txt' before moving.
Stacktrace:
 [1] #checkfor_mv_cp_cptree#10(::Bool, ::Function, ::String, ::String, ::String) at ./file.jl:293
[...]

julia> mv("hello.txt", "goodbye.txt", force=true)
"goodbye.txt"

julia> rm("goodbye.txt");

\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L356-L390}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9379238926612566029}{} 
\hyperlink{9379238926612566029}{\texttt{Base.Filesystem.rm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rm(path::AbstractString; force::Bool=false, recursive::Bool=false)
\end{minted}

Delete the file, link, or empty directory at the given path. If \texttt{force=true} is passed, a non-existing path is not treated as error. If \texttt{recursive=true} is passed and the path is a directory, then all contents are removed recursively.

\textbf{Examples}


\begin{minted}{jlcon}
julia> mkpath("my/test/dir");

julia> rm("my", recursive=true)

julia> rm("this_file_does_not_exist", force=true)

julia> rm("this_file_does_not_exist")
ERROR: IOError: unlink: no such file or directory (ENOENT)
Stacktrace:
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L238-L258}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12527826024259193863}{} 
\hyperlink{12527826024259193863}{\texttt{Base.Filesystem.touch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
touch(path::AbstractString)
\end{minted}

Update the last-modified timestamp on a file to the current time.

If the file does not exist a new file is created.

Return \texttt{path}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> write("my_little_file", 2);

julia> mtime("my_little_file")
1.5273815391135583e9

julia> touch("my_little_file");

julia> mtime("my_little_file")
1.527381559163435e9
\end{minted}

We can see the \hyperlink{6000535741376632237}{\texttt{mtime}} has been modified by \texttt{touch}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L397-L420}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14845808124082506604}{} 
\hyperlink{14845808124082506604}{\texttt{Base.Filesystem.tempname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tempname(parent=tempdir(); cleanup=true) -> String
\end{minted}

Generate a temporary file path. This function only returns a path; no file is created. The path is likely to be unique, but this cannot be guaranteed due to the very remote posibility of two simultaneous calls to \texttt{tempname} generating the same file name. The name is guaranteed to differ from all files already existing at the time of the call to \texttt{tempname}.

When called with no arguments, the temporary name will be an absolute path to a temporary name in the system temporary directory as given by \texttt{tempdir()}. If a \texttt{parent} directory argument is given, the temporary path will be in that directory instead.

The \texttt{cleanup} option controls whether the process attempts to delete the returned path automatically when the process exits. Note that the \texttt{tempname} function does not create any file or directory at the returned location, so there is nothing to cleanup unless you create a file or directory there. If you do and \texttt{clean} is \texttt{true} it will be deleted upon process termination.

\begin{quote}
\textbf{Julia 1.4}

The \texttt{parent} and \texttt{cleanup} arguments were added in 1.4. Prior to Julia 1.4 the path \texttt{tempname} would never be cleaned up at process termination.

\end{quote}
\begin{quote}
\textbf{Warning}

This can lead to security holes if another process obtains the same file name and creates the file before you are able to. Open the file with \texttt{JL\_O\_EXCL} if this is a concern. Using \hyperlink{16166286599015420654}{\texttt{mktemp()}} is also recommended instead.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L571-L601}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9014859942851246694}{} 
\hyperlink{9014859942851246694}{\texttt{Base.Filesystem.tempdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tempdir()
\end{minted}

Gets the path of the temporary directory. On Windows, \texttt{tempdir()} uses the first environment variable found in the ordered list \texttt{TMP}, \texttt{TEMP}, \texttt{USERPROFILE}. On all other operating systems, \texttt{tempdir()} uses the first environment variable found in the ordered list \texttt{TMPDIR}, \texttt{TMP}, \texttt{TEMP}, and \texttt{TEMPDIR}. If none of these are found, the path \texttt{{\textquotedbl}/tmp{\textquotedbl}} is used.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L437-L444}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16166286599015420654}{} 
\hyperlink{16166286599015420654}{\texttt{Base.Filesystem.mktemp}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mktemp(parent=tempdir(); cleanup=true) -> (path, io)
\end{minted}

Return \texttt{(path, io)}, where \texttt{path} is the path of a new temporary file in \texttt{parent} and \texttt{io} is an open file object for this path. The \texttt{cleanup} option controls whether the temporary file is automatically deleted when the process exits.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L604-L610}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18178401863594160042}{} 
\hyperlink{18178401863594160042}{\texttt{Base.Filesystem.mktemp}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mktemp(f::Function, parent=tempdir())
\end{minted}

Apply the function \texttt{f} to the result of \hyperlink{16166286599015420654}{\texttt{mktemp(parent)}} and remove the temporary file upon completion.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L650-L655}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13323517924995570544}{} 
\hyperlink{13323517924995570544}{\texttt{Base.Filesystem.mktempdir}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mktempdir(parent=tempdir(); prefix="jl_", cleanup=true) -> path
\end{minted}

Create a temporary directory in the \texttt{parent} directory with a name constructed from the given prefix and a random suffix, and return its path. Additionally, any trailing \texttt{X} characters may be replaced with random characters. If \texttt{parent} does not exist, throw an error. The \texttt{cleanup} option controls whether the temporary directory is automatically deleted when the process exits.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L613-L621}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7773039401295251460}{} 
\hyperlink{7773039401295251460}{\texttt{Base.Filesystem.mktempdir}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mktempdir(f::Function, parent=tempdir(); prefix="jl_")
\end{minted}

Apply the function \texttt{f} to the result of \hyperlink{13323517924995570544}{\texttt{mktempdir(parent; prefix)}} and remove the temporary directory all of its contents upon completion.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L672-L677}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12165280569414957484}{} 
\hyperlink{12165280569414957484}{\texttt{Base.Filesystem.isblockdev}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isblockdev(path) -> Bool
\end{minted}

Return \texttt{true} if \texttt{path} is a block device, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L194-L198}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16977107907382267368}{} 
\hyperlink{16977107907382267368}{\texttt{Base.Filesystem.ischardev}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ischardev(path) -> Bool
\end{minted}

Return \texttt{true} if \texttt{path} is a character device, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L169-L173}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3518595943652428720}{} 
\hyperlink{3518595943652428720}{\texttt{Base.Filesystem.isdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isdir(path) -> Bool
\end{minted}

Return \texttt{true} if \texttt{path} is a directory, \texttt{false} otherwise.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isdir(homedir())
true

julia> isdir("not/a/directory")
false
\end{minted}

See also: \hyperlink{7436789928697285849}{\texttt{isfile}} and \hyperlink{14301659288222317301}{\texttt{ispath}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L176-L191}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5085310894552406152}{} 
\hyperlink{5085310894552406152}{\texttt{Base.Filesystem.isfifo}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isfifo(path) -> Bool
\end{minted}

Return \texttt{true} if \texttt{path} is a FIFO, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L162-L166}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7436789928697285849}{} 
\hyperlink{7436789928697285849}{\texttt{Base.Filesystem.isfile}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isfile(path) -> Bool
\end{minted}

Return \texttt{true} if \texttt{path} is a regular file, \texttt{false} otherwise.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isfile(homedir())
false

julia> f = open("test_file.txt", "w");

julia> isfile(f)
true

julia> close(f); rm("test_file.txt")
\end{minted}

See also: \hyperlink{3518595943652428720}{\texttt{isdir}} and \hyperlink{14301659288222317301}{\texttt{ispath}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L201-L220}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4451336630382958860}{} 
\hyperlink{4451336630382958860}{\texttt{Base.Filesystem.islink}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
islink(path) -> Bool
\end{minted}

Return \texttt{true} if \texttt{path} is a symbolic link, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L223-L227}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5555615057884788946}{} 
\hyperlink{5555615057884788946}{\texttt{Base.Filesystem.ismount}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ismount(path) -> Bool
\end{minted}

Return \texttt{true} if \texttt{path} is a mount point, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L328-L332}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14301659288222317301}{} 
\hyperlink{14301659288222317301}{\texttt{Base.Filesystem.ispath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ispath(path) -> Bool
\end{minted}

Return \texttt{true} if a valid filesystem entity exists at \texttt{path}, otherwise returns \texttt{false}. This is the generalization of \hyperlink{7436789928697285849}{\texttt{isfile}}, \hyperlink{3518595943652428720}{\texttt{isdir}} etc.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L153-L159}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13653840348451879213}{} 
\hyperlink{13653840348451879213}{\texttt{Base.Filesystem.issetgid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issetgid(path) -> Bool
\end{minted}

Return \texttt{true} if \texttt{path} has the setgid flag set, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L246-L250}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16213917845195501776}{} 
\hyperlink{16213917845195501776}{\texttt{Base.Filesystem.issetuid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issetuid(path) -> Bool
\end{minted}

Return \texttt{true} if \texttt{path} has the setuid flag set, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L239-L243}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17017605444718674714}{} 
\hyperlink{17017605444718674714}{\texttt{Base.Filesystem.issocket}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issocket(path) -> Bool
\end{minted}

Return \texttt{true} if \texttt{path} is a socket, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L230-L234}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5099487162005794677}{} 
\hyperlink{5099487162005794677}{\texttt{Base.Filesystem.issticky}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issticky(path) -> Bool
\end{minted}

Return \texttt{true} if \texttt{path} has the sticky bit set, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L253-L257}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10630566360559889134}{} 
\hyperlink{10630566360559889134}{\texttt{Base.Filesystem.homedir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
homedir() -> String
\end{minted}

Return the current user{\textquotesingle}s home directory.

\begin{quote}
\textbf{Note}

\texttt{homedir} determines the home directory via \texttt{libuv}{\textquotesingle}s \texttt{uv\_os\_homedir}. For details (for example on how to specify the home directory via environment variables), see the \href{http://docs.libuv.org/en/v1.x/misc.html\#c.uv\_os\_homedir}{\texttt{uv\_os\_homedir} documentation}.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L54-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10993431289442855643}{} 
\hyperlink{10993431289442855643}{\texttt{Base.Filesystem.dirname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dirname(path::AbstractString) -> AbstractString
\end{minted}

Get the directory part of a path. Trailing characters ({\textquotesingle}/{\textquotesingle} or {\textquotesingle}{\textbackslash}{\textquotesingle}) in the path are counted as part of the path.

\textbf{Examples}


\begin{minted}{jlcon}
julia> dirname("/home/myuser")
"/home"

julia> dirname("/home/myuser/")
"/home/myuser"
\end{minted}

See also: \hyperlink{16452154606861459390}{\texttt{basename}}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L144-L160}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16452154606861459390}{} 
\hyperlink{16452154606861459390}{\texttt{Base.Filesystem.basename}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
basename(path::AbstractString) -> AbstractString
\end{minted}

Get the file name part of a path.

\textbf{Examples}


\begin{minted}{jlcon}
julia> basename("/home/myuser/example.jl")
"example.jl"
\end{minted}

See also: \hyperlink{10993431289442855643}{\texttt{dirname}}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L163-L175}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1518763743618824993}{} 
\hyperlink{1518763743618824993}{\texttt{Base.@\_\_FILE\_\_}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@__FILE__ -> AbstractString
\end{minted}

Expand to a string with the path to the file containing the macrocall, or an empty string if evaluated by \texttt{julia -e <expr>}. Return \texttt{nothing} if the macro was missing parser source information. Alternatively see \hyperlink{9054270179006636705}{\texttt{PROGRAM\_FILE}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/loading.jl#L1480-L1487}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12719499456415901450}{} 
\hyperlink{12719499456415901450}{\texttt{Base.@\_\_DIR\_\_}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@__DIR__ -> AbstractString
\end{minted}

Expand to a string with the absolute path to the directory of the file containing the macrocall. Return the current working directory if run from a REPL or if evaluated by \texttt{julia -e <expr>}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/loading.jl#L1493-L1499}{\texttt{source}}


\end{adjustwidth}
\hypertarget{277452200962288519}{} 
\hyperlink{277452200962288519}{\texttt{Base.@\_\_LINE\_\_}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@__LINE__ -> Int
\end{minted}

Expand to the line number of the location of the macrocall. Return \texttt{0} if the line number could not be determined.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L792-L797}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13394819469005127600}{} 
\hyperlink{13394819469005127600}{\texttt{Base.Filesystem.isabspath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isabspath(path::AbstractString) -> Bool
\end{minted}

Determine whether a path is absolute (begins at the root directory).

\textbf{Examples}


\begin{minted}{jlcon}
julia> isabspath("/home")
true

julia> isabspath("home")
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L87-L100}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7293742883276660783}{} 
\hyperlink{7293742883276660783}{\texttt{Base.Filesystem.isdirpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isdirpath(path::AbstractString) -> Bool
\end{minted}

Determine whether a path refers to a directory (for example, ends with a path separator).

\textbf{Examples}


\begin{minted}{jlcon}
julia> isdirpath("/home")
false

julia> isdirpath("/home/")
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L103-L116}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12470257079932202886}{} 
\hyperlink{12470257079932202886}{\texttt{Base.Filesystem.joinpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
joinpath(parts::AbstractString...) -> String
\end{minted}

Join path components into a full path. If some argument is an absolute path or (on Windows) has a drive specification that doesn{\textquotesingle}t match the drive computed for the join of the preceding paths, then prior components are dropped.

Note on Windows since there is a current directory for each drive, \texttt{joinpath({\textquotedbl}c:{\textquotedbl}, {\textquotedbl}foo{\textquotedbl})} represents a path relative to the current directory on drive {\textquotedbl}c:{\textquotedbl} so this is equal to {\textquotedbl}c:foo{\textquotedbl}, not {\textquotedbl}c:{\textbackslash}foo{\textquotedbl}. Furthermore, \texttt{joinpath} treats this as a non-absolute path and ignores the drive letter casing, hence \texttt{joinpath({\textquotedbl}C:{\textbackslash}A{\textquotedbl},{\textquotedbl}c:b{\textquotedbl}) = {\textquotedbl}C:{\textbackslash}A{\textbackslash}b{\textquotedbl}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> joinpath("/home/myuser", "example.jl")
"/home/myuser/example.jl"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L304-L321}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4673100532388501717}{} 
\hyperlink{4673100532388501717}{\texttt{Base.Filesystem.abspath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
abspath(path::AbstractString) -> String
\end{minted}

Convert a path to an absolute path by adding the current directory if necessary. Also normalizes the path as in \hyperlink{5019859018770545283}{\texttt{normpath}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L377-L382}{\texttt{source}}



\begin{lstlisting}
abspath(path::AbstractString, paths::AbstractString...) -> String
\end{lstlisting}

Convert a set of paths to an absolute path by joining them together and adding the current directory if necessary. Equivalent to \texttt{abspath(joinpath(path, paths...))}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L385-L390}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5019859018770545283}{} 
\hyperlink{5019859018770545283}{\texttt{Base.Filesystem.normpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
normpath(path::AbstractString) -> String
\end{minted}

Normalize a path, removing {\textquotedbl}.{\textquotedbl} and {\textquotedbl}..{\textquotedbl} entries.

\textbf{Examples}


\begin{minted}{jlcon}
julia> normpath("/home/myuser/../example.jl")
"/home/example.jl"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L324-L334}{\texttt{source}}



\begin{lstlisting}
normpath(path::AbstractString, paths::AbstractString...) -> String
\end{lstlisting}

Convert a set of paths to a normalized path by joining them together and removing {\textquotedbl}.{\textquotedbl} and {\textquotedbl}..{\textquotedbl} entries. Equivalent to \texttt{normpath(joinpath(path, paths...))}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L369-L374}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6055776470592315771}{} 
\hyperlink{6055776470592315771}{\texttt{Base.Filesystem.realpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
realpath(path::AbstractString) -> String
\end{minted}

Canonicalize a path by expanding symbolic links and removing {\textquotedbl}.{\textquotedbl} and {\textquotedbl}..{\textquotedbl} entries. On case-insensitive case-preserving filesystems (typically Mac and Windows), the filesystem{\textquotesingle}s stored case for the path is returned.

(This function throws an exception if \texttt{path} does not exist in the filesystem.)



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L412-L420}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16322454670651695984}{} 
\hyperlink{16322454670651695984}{\texttt{Base.Filesystem.relpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
relpath(path::AbstractString, startpath::AbstractString = ".") -> AbstractString
\end{minted}

Return a relative filepath to \texttt{path} either from the current directory or from an optional start directory. This is a path computation: the filesystem is not accessed to confirm the existence or nature of \texttt{path} or \texttt{startpath}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L482-L488}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10521892386506791258}{} 
\hyperlink{10521892386506791258}{\texttt{Base.Filesystem.expanduser}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
expanduser(path::AbstractString) -> AbstractString
\end{minted}

On Unix systems, replace a tilde character at the start of a path with the current user{\textquotesingle}s home directory.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L467-L471}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8483950538709909733}{} 
\hyperlink{8483950538709909733}{\texttt{Base.Filesystem.splitdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
splitdir(path::AbstractString) -> (AbstractString, AbstractString)
\end{minted}

Split a path into a tuple of the directory name and file name.

\textbf{Examples}


\begin{minted}{jlcon}
julia> splitdir("/home/myuser")
("/home", "myuser")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L119-L129}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14253131097250488223}{} 
\hyperlink{14253131097250488223}{\texttt{Base.Filesystem.splitdrive}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
splitdrive(path::AbstractString) -> (AbstractString, AbstractString)
\end{minted}

On Windows, split a path into the drive letter part and the path part. On Unix systems, the first component is always the empty string.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L46-L51}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4740094249280549542}{} 
\hyperlink{4740094249280549542}{\texttt{Base.Filesystem.splitext}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
splitext(path::AbstractString) -> (AbstractString, AbstractString)
\end{minted}

If the last component of a path contains a dot, split the path into everything before the dot and everything including and after the dot. Otherwise, return a tuple of the argument unmodified and the empty string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> splitext("/home/myuser/example.jl")
("/home/myuser/example", ".jl")

julia> splitext("/home/myuser/example")
("/home/myuser/example", "")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L178-L193}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11497527244991617161}{} 
\hyperlink{11497527244991617161}{\texttt{Base.Filesystem.splitpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
splitpath(path::AbstractString) -> Vector{String}
\end{minted}

Split a file path into all its path components. This is the opposite of \texttt{joinpath}. Returns an array of substrings, one for each directory or file in the path, including the root directory if present.

\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> splitpath("/home/myuser/example.jl")
4-element Array{String,1}:
 "/"
 "home"
 "myuser"
 "example.jl"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L204-L223}{\texttt{source}}


\end{adjustwidth}

\hypertarget{8198446107690940585}{}


\chapter{I/O 与网络}



\hypertarget{6650448682363190797}{}


\section{通用 I/O}


\hypertarget{18181294266083891471}{} 
\hyperlink{18181294266083891471}{\texttt{Base.stdout}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stdout
\end{minted}

Global variable referring to the standard out stream.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libuv.jl#L135-L139}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6150355911915549172}{} 
\hyperlink{6150355911915549172}{\texttt{Base.stderr}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stderr
\end{minted}

Global variable referring to the standard error stream.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libuv.jl#L142-L146}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3330957653919693521}{} 
\hyperlink{3330957653919693521}{\texttt{Base.stdin}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stdin
\end{minted}

Global variable referring to the standard input stream.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libuv.jl#L128-L132}{\texttt{source}}


\end{adjustwidth}
\hypertarget{300818094931158296}{} 
\hyperlink{300818094931158296}{\texttt{Base.open}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
open(f::Function, args...; kwargs....)
\end{minted}

Apply the function \texttt{f} to the result of \texttt{open(args...; kwargs...)} and close the resulting file descriptor upon completion.

\textbf{Examples}


\begin{minted}{jlcon}
julia> open("myfile.txt", "w") do io
           write(io, "Hello world!")
       end;

julia> open(f->read(f, String), "myfile.txt")
"Hello world!"

julia> rm("myfile.txt")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L277-L294}{\texttt{source}}



\begin{lstlisting}
open(filename::AbstractString; keywords...) -> IOStream
\end{lstlisting}

Open a file in a mode specified by five boolean keyword arguments:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Keyword & Description & Default \\
\hline
\texttt{read} & open for reading & \texttt{!write} \\
\hline
\texttt{write} & open for writing & \texttt{truncate | append} \\
\hline
\texttt{create} & create if non-existent & \texttt{!read \& write | truncate | append} \\
\hline
\texttt{truncate} & truncate to zero size & \texttt{!read \& write} \\
\hline
\texttt{append} & seek to end & \texttt{false} \\
\hline
\end{tabulary}

\end{table}

The default when no keywords are passed is to open files for reading only. Returns a stream for accessing the opened file.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L223-L238}{\texttt{source}}



\begin{lstlisting}
open(filename::AbstractString, [mode::AbstractString]) -> IOStream
\end{lstlisting}

Alternate syntax for open, where a string-based mode specifier is used instead of the five booleans. The values of \texttt{mode} correspond to those from \texttt{fopen(3)} or Perl \texttt{open}, and are equivalent to setting the following boolean groups:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Mode & Description & Keywords \\
\hline
\texttt{r} & read & none \\
\hline
\texttt{w} & write, create, truncate & \texttt{write = true} \\
\hline
\texttt{a} & write, create, append & \texttt{append = true} \\
\hline
\texttt{r+} & read, write & \texttt{read = true, write = true} \\
\hline
\texttt{w+} & read, write, create, truncate & \texttt{truncate = true, read = true} \\
\hline
\texttt{a+} & read, write, create, append & \texttt{append = true, read = true} \\
\hline
\end{tabulary}

\end{table}

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = open("myfile.txt", "w");

julia> write(io, "Hello world!");

julia> close(io);

julia> io = open("myfile.txt", "r");

julia> read(io, String)
"Hello world!"

julia> write(io, "This file is read only")
ERROR: ArgumentError: write failed, IOStream is not writeable
[...]

julia> close(io)

julia> io = open("myfile.txt", "a");

julia> write(io, "This stream is not read only")
28

julia> close(io)

julia> rm("myfile.txt")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L264-L308}{\texttt{source}}



\begin{lstlisting}
open(fd::OS_HANDLE) -> IO
\end{lstlisting}

Take a raw file descriptor wrap it in a Julia-aware IO type, and take ownership of the fd handle. Call \texttt{open(Libc.dup(fd))} to avoid the ownership capture of the original handle.

\begin{quote}
\textbf{Warn}

Do not call this on a handle that{\textquotesingle}s already owned by some other part of the system.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stream.jl#L258-L269}{\texttt{source}}



\begin{lstlisting}
open(command, mode::AbstractString, stdio=devnull)
\end{lstlisting}

Run \texttt{command} asynchronously. Like \texttt{open(command, stdio; read, write)} except specifying the read and write flags via a mode string instead of keyword arguments. Possible mode strings are:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Mode & Description & Keywords \\
\hline
\texttt{r} & read & none \\
\hline
\texttt{w} & write & \texttt{write = true} \\
\hline
\texttt{r+} & read, write & \texttt{read = true, write = true} \\
\hline
\texttt{w+} & read, write & \texttt{read = true, write = true} \\
\hline
\end{tabulary}

\end{table}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/process.jl#L323-L336}{\texttt{source}}



\begin{lstlisting}
open(command, stdio=devnull; write::Bool = false, read::Bool = !write)
\end{lstlisting}

Start running \texttt{command} asynchronously, and return a \texttt{process::IO} object.  If \texttt{read} is true, then reads from the process come from the process{\textquotesingle}s standard output and \texttt{stdio} optionally specifies the process{\textquotesingle}s standard input stream.  If \texttt{write} is true, then writes go to the process{\textquotesingle}s standard input and \texttt{stdio} optionally specifies the process{\textquotesingle}s standard output stream. The process{\textquotesingle}s standard error stream is connected to the current global \texttt{stderr}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/process.jl#L350-L359}{\texttt{source}}



\begin{lstlisting}
open(f::Function, command, args...; kwargs...)
\end{lstlisting}

Similar to \texttt{open(command, args...; kwargs...)}, but calls \texttt{f(stream)} on the resulting process stream, then closes the input stream and waits for the process to complete. Returns the value returned by \texttt{f}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/process.jl#L383-L389}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12496894737220238417}{} 
\hyperlink{12496894737220238417}{\texttt{Base.IOStream}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IOStream
\end{minted}

A buffered IO stream wrapping an OS file descriptor. Mostly used to represent files returned by \hyperlink{300818094931158296}{\texttt{open}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L7-L12}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15789326112236459498}{} 
\hyperlink{15789326112236459498}{\texttt{Base.IOBuffer}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IOBuffer([data::AbstractVector{UInt8}]; keywords...) -> IOBuffer
\end{minted}

Create an in-memory I/O stream, which may optionally operate on a pre-existing array.

It may take optional keyword arguments:

\begin{itemize}
\item \texttt{read}, \texttt{write}, \texttt{append}: restricts operations to the buffer; see \texttt{open} for details.


\item \texttt{truncate}: truncates the buffer size to zero length.


\item \texttt{maxsize}: specifies a size beyond which the buffer may not be grown.


\item \texttt{sizehint}: suggests a capacity of the buffer (\texttt{data} must implement \texttt{sizehint!(data, size)}).

\end{itemize}
When \texttt{data} is not given, the buffer will be both readable and writable by default.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer();

julia> write(io, "JuliaLang is a GitHub organization.", " It has many members.")
56

julia> String(take!(io))
"JuliaLang is a GitHub organization. It has many members."

julia> io = IOBuffer(b"JuliaLang is a GitHub organization.")
IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=35, maxsize=Inf, ptr=1, mark=-1)

julia> read(io, String)
"JuliaLang is a GitHub organization."

julia> write(io, "This isn't writable.")
ERROR: ArgumentError: ensureroom failed, IOBuffer is not writeable

julia> io = IOBuffer(UInt8[], read=true, write=true, maxsize=34)
IOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=0, maxsize=34, ptr=1, mark=-1)

julia> write(io, "JuliaLang is a GitHub organization.")
34

julia> String(take!(io))
"JuliaLang is a GitHub organization"

julia> length(read(IOBuffer(b"data", read=true, truncate=false)))
4

julia> length(read(IOBuffer(b"data", read=true, truncate=true)))
0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iobuffer.jl#L35-L82}{\texttt{source}}



\begin{lstlisting}
IOBuffer(string::String)
\end{lstlisting}

Create a read-only \texttt{IOBuffer} on the data underlying the given string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer("Haho");

julia> String(take!(io))
"Haho"

julia> String(take!(io))
"Haho"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/io.jl#L233-L248}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4963355246106153560}{} 
\hyperlink{4963355246106153560}{\texttt{Base.take!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
take!(b::IOBuffer)
\end{minted}

Obtain the contents of an \texttt{IOBuffer} as an array, without copying. Afterwards, the \texttt{IOBuffer} is reset to its initial state.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer();

julia> write(io, "JuliaLang is a GitHub organization.", " It has many members.")
56

julia> String(take!(io))
"JuliaLang is a GitHub organization. It has many members."
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iobuffer.jl#L348-L364}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4200832604380534486}{} 
\hyperlink{4200832604380534486}{\texttt{Base.fdio}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fdio([name::AbstractString, ]fd::Integer[, own::Bool=false]) -> IOStream
\end{minted}

Create an \hyperlink{12496894737220238417}{\texttt{IOStream}} object from an integer file descriptor. If \texttt{own} is \texttt{true}, closing this object will close the underlying descriptor. By default, an \texttt{IOStream} is closed when it is garbage collected. \texttt{name} allows you to associate the descriptor with a named file.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L208-L214}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4551926523947041107}{} 
\hyperlink{4551926523947041107}{\texttt{Base.flush}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
flush(stream)
\end{minted}

Commit all currently buffered writes to the given stream.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L1029-L1033}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5331333469799487255}{} 
\hyperlink{5331333469799487255}{\texttt{Base.close}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
close(stream)
\end{minted}

Close an I/O stream. Performs a \hyperlink{4551926523947041107}{\texttt{flush}} first.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L57-L61}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16947913578760238729}{} 
\hyperlink{16947913578760238729}{\texttt{Base.write}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
write(io::IO, x)
write(filename::AbstractString, x)
\end{minted}

Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream.   See also \hyperlink{8248717042415202230}{\texttt{print}} to write a text representation (with an encoding that may depend upon \texttt{io}).

You can write multiple values with the same \texttt{write} call. i.e. the following are equivalent:


\begin{lstlisting}
write(io, x, y...)
write(io, x) + write(io, y...)
\end{lstlisting}

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer();

julia> write(io, "JuliaLang is a GitHub organization.", " It has many members.")
56

julia> String(take!(io))
"JuliaLang is a GitHub organization. It has many members."

julia> write(io, "Sometimes those members") + write(io, " write documentation.")
44

julia> String(take!(io))
"Sometimes those members write documentation."
\end{minted}

User-defined plain-data types without \texttt{write} methods can be written when wrapped in a \texttt{Ref}:


\begin{minted}{jlcon}
julia> struct MyStruct; x::Float64; end

julia> io = IOBuffer()
IOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=0, maxsize=Inf, ptr=1, mark=-1)

julia> write(io, Ref(MyStruct(42.0)))
8

julia> seekstart(io); read!(io, Ref(MyStruct(NaN)))
Base.RefValue{MyStruct}(MyStruct(42.0))
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L148-L190}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8104134490906192097}{} 
\hyperlink{8104134490906192097}{\texttt{Base.read}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
read(io::IO, T)
\end{minted}

Read a single value of type \texttt{T} from \texttt{io}, in canonical binary representation.


\begin{lstlisting}
read(io::IO, String)
\end{lstlisting}

Read the entirety of \texttt{io}, as a \texttt{String}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer("JuliaLang is a GitHub organization");

julia> read(io, Char)
'J': ASCII/Unicode U+004A (category Lu: Letter, uppercase)

julia> io = IOBuffer("JuliaLang is a GitHub organization");

julia> read(io, String)
"JuliaLang is a GitHub organization"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L124-L145}{\texttt{source}}



\begin{lstlisting}
read(filename::AbstractString, args...)
\end{lstlisting}

Open a file and read its contents. \texttt{args} is passed to \texttt{read}: this is equivalent to \texttt{open(io->read(io, args...), filename)}.


\begin{lstlisting}
read(filename::AbstractString, String)
\end{lstlisting}

Read the entire contents of a file as a string.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L369-L378}{\texttt{source}}



\begin{lstlisting}
read(s::IO, nb=typemax(Int))
\end{lstlisting}

Read at most \texttt{nb} bytes from \texttt{s}, returning a \texttt{Vector\{UInt8\}} of the bytes read.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L903-L907}{\texttt{source}}



\begin{lstlisting}
read(s::IOStream, nb::Integer; all=true)
\end{lstlisting}

Read at most \texttt{nb} bytes from \texttt{s}, returning a \texttt{Vector\{UInt8\}} of the bytes read.

If \texttt{all} is \texttt{true} (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If \texttt{all} is \texttt{false}, at most one \texttt{read} call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the \texttt{all} option.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L471-L480}{\texttt{source}}



\begin{lstlisting}
read(command::Cmd)
\end{lstlisting}

Run \texttt{command} and return the resulting output as an array of bytes.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/process.jl#L404-L408}{\texttt{source}}



\begin{lstlisting}
read(command::Cmd, String)
\end{lstlisting}

Run \texttt{command} and return the resulting output as a \texttt{String}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/process.jl#L416-L420}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7305890466159196010}{} 
\hyperlink{7305890466159196010}{\texttt{Base.read!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
read!(stream::IO, array::AbstractArray)
read!(filename::AbstractString, array::AbstractArray)
\end{minted}

Read binary data from an I/O stream or file, filling in \texttt{array}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L383-L388}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14376170011353973168}{} 
\hyperlink{14376170011353973168}{\texttt{Base.readbytes!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readbytes!(stream::IO, b::AbstractVector{UInt8}, nb=length(b))
\end{minted}

Read at most \texttt{nb} bytes from \texttt{stream} into \texttt{b}, returning the number of bytes read. The size of \texttt{b} will be increased if needed (i.e. if \texttt{nb} is greater than \texttt{length(b)} and enough bytes could be read), but it will never be decreased.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L877-L883}{\texttt{source}}



\begin{lstlisting}
readbytes!(stream::IOStream, b::AbstractVector{UInt8}, nb=length(b); all::Bool=true)
\end{lstlisting}

Read at most \texttt{nb} bytes from \texttt{stream} into \texttt{b}, returning the number of bytes read. The size of \texttt{b} will be increased if needed (i.e. if \texttt{nb} is greater than \texttt{length(b)} and enough bytes could be read), but it will never be decreased.

If \texttt{all} is \texttt{true} (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If \texttt{all} is \texttt{false}, at most one \texttt{read} call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the \texttt{all} option.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L436-L447}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14873825528169247088}{} 
\hyperlink{14873825528169247088}{\texttt{Base.unsafe\_read}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unsafe_read(io::IO, ref, nbytes::UInt)
\end{minted}

Copy \texttt{nbytes} from the \texttt{IO} stream object into \texttt{ref} (converted to a pointer).

It is recommended that subtypes \texttt{T<:IO} override the following method signature to provide more efficient implementations: \texttt{unsafe\_read(s::T, p::Ptr\{UInt8\}, n::UInt)}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L213-L221}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7085957152663564741}{} 
\hyperlink{7085957152663564741}{\texttt{Base.unsafe\_write}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unsafe_write(io::IO, ref, nbytes::UInt)
\end{minted}

Copy \texttt{nbytes} from \texttt{ref} (converted to a pointer) into the \texttt{IO} object.

It is recommended that subtypes \texttt{T<:IO} override the following method signature to provide more efficient implementations: \texttt{unsafe\_write(s::T, p::Ptr\{UInt8\}, n::UInt)}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L196-L204}{\texttt{source}}


\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Base.peek}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{14999933350742523048}{} 
\hyperlink{14999933350742523048}{\texttt{Base.position}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
position(s)
\end{minted}

Get the current position of a stream.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer("JuliaLang is a GitHub organization.");

julia> seek(io, 5);

julia> position(io)
5

julia> skip(io, 10);

julia> position(io)
15

julia> seekend(io);

julia> position(io)
35
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L170-L194}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11269748483301652100}{} 
\hyperlink{11269748483301652100}{\texttt{Base.seek}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
seek(s, pos)
\end{minted}

Seek a stream to the given position.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer("JuliaLang is a GitHub organization.");

julia> seek(io, 5);

julia> read(io, Char)
'L': ASCII/Unicode U+004C (category Lu: Letter, uppercase)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L91-L105}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17809695755202491288}{} 
\hyperlink{17809695755202491288}{\texttt{Base.seekstart}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
seekstart(s)
\end{minted}

Seek a stream to its beginning.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer("JuliaLang is a GitHub organization.");

julia> seek(io, 5);

julia> read(io, Char)
'L': ASCII/Unicode U+004C (category Lu: Letter, uppercase)

julia> seekstart(io);

julia> read(io, Char)
'J': ASCII/Unicode U+004A (category Lu: Letter, uppercase)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L113-L132}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7051129712452805515}{} 
\hyperlink{7051129712452805515}{\texttt{Base.seekend}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
seekend(s)
\end{minted}

Seek a stream to its end.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L135-L139}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3828582500400083834}{} 
\hyperlink{3828582500400083834}{\texttt{Base.skip}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
skip(s, offset)
\end{minted}

Seek a stream relative to the current position.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer("JuliaLang is a GitHub organization.");

julia> seek(io, 5);

julia> skip(io, 10);

julia> read(io, Char)
'G': ASCII/Unicode U+0047 (category Lu: Letter, uppercase)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L146-L162}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12695720152576749628}{} 
\hyperlink{12695720152576749628}{\texttt{Base.mark}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mark(s)
\end{minted}

Add a mark at the current position of stream \texttt{s}. Return the marked position.

See also \hyperlink{1677829146244042320}{\texttt{unmark}}, \hyperlink{17642823092929127210}{\texttt{reset}}, \hyperlink{5764088774799520350}{\texttt{ismarked}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L977-L983}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1677829146244042320}{} 
\hyperlink{1677829146244042320}{\texttt{Base.unmark}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unmark(s)
\end{minted}

Remove a mark from stream \texttt{s}. Return \texttt{true} if the stream was marked, \texttt{false} otherwise.

See also \hyperlink{12695720152576749628}{\texttt{mark}}, \hyperlink{17642823092929127210}{\texttt{reset}}, \hyperlink{5764088774799520350}{\texttt{ismarked}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L988-L994}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17642823092929127210}{} 
\hyperlink{17642823092929127210}{\texttt{Base.reset}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reset(s)
\end{minted}

Reset a stream \texttt{s} to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked.

See also \hyperlink{12695720152576749628}{\texttt{mark}}, \hyperlink{1677829146244042320}{\texttt{unmark}}, \hyperlink{5764088774799520350}{\texttt{ismarked}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L1001-L1008}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5764088774799520350}{} 
\hyperlink{5764088774799520350}{\texttt{Base.ismarked}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ismarked(s)
\end{minted}

Return \texttt{true} if stream \texttt{s} is marked.

See also \hyperlink{12695720152576749628}{\texttt{mark}}, \hyperlink{1677829146244042320}{\texttt{unmark}}, \hyperlink{17642823092929127210}{\texttt{reset}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L1017-L1023}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1214745596749163873}{} 
\hyperlink{1214745596749163873}{\texttt{Base.eof}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eof(stream) -> Bool
\end{minted}

Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return \texttt{false}. Therefore it is always safe to read one byte after seeing \texttt{eof} return \texttt{false}. \texttt{eof} will return \texttt{false} as long as buffered data is still available, even if the remote end of a connection is closed.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L352-L360}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3535270730162763546}{} 
\hyperlink{3535270730162763546}{\texttt{Base.isreadonly}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isreadonly(io) -> Bool
\end{minted}

Determine whether a stream is read-only.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer("JuliaLang is a GitHub organization");

julia> isreadonly(io)
true

julia> io = IOBuffer();

julia> isreadonly(io)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L560-L577}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5354682531169079914}{} 
\hyperlink{5354682531169079914}{\texttt{Base.iswritable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
iswritable(io) -> Bool
\end{minted}

Return \texttt{true} if the specified IO object is writable (if that can be determined).

\textbf{Examples}


\begin{minted}{jlcon}
julia> open("myfile.txt", "w") do io
           print(io, "Hello world!");
           iswritable(io)
       end
true

julia> open("myfile.txt", "r") do io
           iswritable(io)
       end
false

julia> rm("myfile.txt")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L99-L119}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7695515320845284530}{} 
\hyperlink{7695515320845284530}{\texttt{Base.isreadable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isreadable(io) -> Bool
\end{minted}

Return \texttt{true} if the specified IO object is readable (if that can be determined).

\textbf{Examples}


\begin{minted}{jlcon}
julia> open("myfile.txt", "w") do io
           print(io, "Hello world!");
           isreadable(io)
       end
false

julia> open("myfile.txt", "r") do io
           isreadable(io)
       end
true

julia> rm("myfile.txt")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L76-L96}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12411519405593851135}{} 
\hyperlink{12411519405593851135}{\texttt{Base.isopen}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isopen(object) -> Bool
\end{minted}

Determine whether an object - such as a stream or timer – is not yet closed. Once an object is closed, it will never produce a new event. However, since a closed stream may still have data to read in its buffer, use \hyperlink{1214745596749163873}{\texttt{eof}} to check for the ability to read data. Use the \texttt{FileWatching} package to be notified when a stream might be writable or readable.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = open("my_file.txt", "w+");

julia> isopen(io)
true

julia> close(io)

julia> isopen(io)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L33-L54}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4096210142404798505}{} 
\hyperlink{4096210142404798505}{\texttt{Base.fd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fd(stream)
\end{minted}

Return the file descriptor backing the stream or file. Note that this function only applies to synchronous \texttt{File}{\textquotesingle}s and \texttt{IOStream}{\textquotesingle}s not to any of the asynchronous streams.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L36-L41}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1112291265677833393}{} 
\hyperlink{1112291265677833393}{\texttt{Base.redirect\_stdout}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
redirect_stdout([stream]) -> (rd, wr)
\end{minted}

Create a pipe to which all C and Julia level \hyperlink{18181294266083891471}{\texttt{stdout}} output will be redirected. Returns a tuple \texttt{(rd, wr)} representing the pipe ends. Data written to \hyperlink{18181294266083891471}{\texttt{stdout}} may now be read from the \texttt{rd} end of the pipe. The \texttt{wr} end is given for convenience in case the old \hyperlink{18181294266083891471}{\texttt{stdout}} object was cached by the user and needs to be replaced elsewhere.

If called with the optional \texttt{stream} argument, then returns \texttt{stream} itself.

\begin{quote}
\textbf{Note}

\texttt{stream} must be a \texttt{TTY}, a \texttt{Pipe}, or a socket.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stream.jl#L1106-L1121}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12923908242336925438}{} 
\hyperlink{12923908242336925438}{\texttt{Base.redirect\_stdout}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
redirect_stdout(f::Function, stream)
\end{minted}

Run the function \texttt{f} while redirecting \hyperlink{18181294266083891471}{\texttt{stdout}} to \texttt{stream}. Upon completion, \hyperlink{18181294266083891471}{\texttt{stdout}} is restored to its prior setting.

\begin{quote}
\textbf{Note}

\texttt{stream} must be a \texttt{TTY}, a \texttt{Pipe}, or a socket.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stream.jl#L1160-L1168}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17653990356642003163}{} 
\hyperlink{17653990356642003163}{\texttt{Base.redirect\_stderr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
redirect_stderr([stream]) -> (rd, wr)
\end{minted}

Like \hyperlink{1112291265677833393}{\texttt{redirect\_stdout}}, but for \hyperlink{6150355911915549172}{\texttt{stderr}}.

\begin{quote}
\textbf{Note}

\texttt{stream} must be a \texttt{TTY}, a \texttt{Pipe}, or a socket.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stream.jl#L1124-L1131}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4630317800478362301}{} 
\hyperlink{4630317800478362301}{\texttt{Base.redirect\_stderr}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
redirect_stderr(f::Function, stream)
\end{minted}

Run the function \texttt{f} while redirecting \hyperlink{6150355911915549172}{\texttt{stderr}} to \texttt{stream}. Upon completion, \hyperlink{6150355911915549172}{\texttt{stderr}} is restored to its prior setting.

\begin{quote}
\textbf{Note}

\texttt{stream} must be a \texttt{TTY}, a \texttt{Pipe}, or a socket.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stream.jl#L1171-L1179}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17751303507361009787}{} 
\hyperlink{17751303507361009787}{\texttt{Base.redirect\_stdin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
redirect_stdin([stream]) -> (rd, wr)
\end{minted}

Like \hyperlink{1112291265677833393}{\texttt{redirect\_stdout}}, but for \hyperlink{3330957653919693521}{\texttt{stdin}}. Note that the order of the return tuple is still \texttt{(rd, wr)}, i.e. data to be read from \hyperlink{3330957653919693521}{\texttt{stdin}} may be written to \texttt{wr}.

\begin{quote}
\textbf{Note}

\texttt{stream} must be a \texttt{TTY}, a \texttt{Pipe}, or a socket.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stream.jl#L1134-L1143}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17205945783347532140}{} 
\hyperlink{17205945783347532140}{\texttt{Base.redirect\_stdin}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
redirect_stdin(f::Function, stream)
\end{minted}

Run the function \texttt{f} while redirecting \hyperlink{3330957653919693521}{\texttt{stdin}} to \texttt{stream}. Upon completion, \hyperlink{3330957653919693521}{\texttt{stdin}} is restored to its prior setting.

\begin{quote}
\textbf{Note}

\texttt{stream} must be a \texttt{TTY}, a \texttt{Pipe}, or a socket.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stream.jl#L1182-L1190}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1622401395685476756}{} 
\hyperlink{1622401395685476756}{\texttt{Base.readchomp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readchomp(x)
\end{minted}

Read the entirety of \texttt{x} as a string and remove a single trailing newline if there is one. Equivalent to \texttt{chomp(read(x, String))}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> open("my_file.txt", "w") do io
           write(io, "JuliaLang is a GitHub organization.\nIt has many members.\n");
       end;

julia> readchomp("my_file.txt")
"JuliaLang is a GitHub organization.\nIt has many members."

julia> rm("my_file.txt");
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L855-L872}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16572122454613115528}{} 
\hyperlink{16572122454613115528}{\texttt{Base.truncate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
truncate(file, n)
\end{minted}

Resize the file or buffer given by the first argument to exactly \texttt{n} bytes, filling previously unallocated space with {\textquotesingle}{\textbackslash}0{\textquotesingle} if the file or buffer is grown.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer();

julia> write(io, "JuliaLang is a GitHub organization.")
35

julia> truncate(io, 15)
IOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=15, maxsize=Inf, ptr=16, mark=-1)

julia> String(take!(io))
"JuliaLang is a "

julia> io = IOBuffer();

julia> write(io, "JuliaLang is a GitHub organization.");

julia> truncate(io, 40);

julia> String(take!(io))
"JuliaLang is a GitHub organization.\0\0\0\0\0"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L56-L84}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6177395059245061697}{} 
\hyperlink{6177395059245061697}{\texttt{Base.skipchars}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
skipchars(predicate, io::IO; linecomment=nothing)
\end{minted}

Advance the stream \texttt{io} such that the next-read character will be the first remaining for which \texttt{predicate} returns \texttt{false}. If the keyword argument \texttt{linecomment} is specified, all characters from that character until the start of the next line are ignored.

\textbf{Examples}


\begin{minted}{jlcon}
julia> buf = IOBuffer("    text")
IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=8, maxsize=Inf, ptr=1, mark=-1)

julia> skipchars(isspace, buf)
IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=8, maxsize=Inf, ptr=5, mark=-1)

julia> String(readavailable(buf))
"text"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L1036-L1054}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17858389738629138759}{} 
\hyperlink{17858389738629138759}{\texttt{Base.countlines}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
countlines(io::IO; eol::AbstractChar = '\n')
\end{minted}

Read \texttt{io} until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than \texttt{{\textquotesingle}{\textbackslash}n{\textquotesingle}} are supported by passing them as the second argument.  The last non-empty line of \texttt{io} is counted even if it does not end with the EOL, matching the length returned by \hyperlink{3474649815265066504}{\texttt{eachline}} and \hyperlink{2102076388448706590}{\texttt{readlines}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer("JuliaLang is a GitHub organization.\n");

julia> countlines(io)
1

julia> io = IOBuffer("JuliaLang is a GitHub organization.");

julia> countlines(io)
1

julia> countlines(io, eol = '.')
0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L1068-L1091}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16959584405141637900}{} 
\hyperlink{16959584405141637900}{\texttt{Base.PipeBuffer}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
PipeBuffer(data::Vector{UInt8}=UInt8[]; maxsize::Integer = typemax(Int))
\end{minted}

An \hyperlink{15789326112236459498}{\texttt{IOBuffer}} that allows reading and performs writes by appending. Seeking and truncating are not supported. See \hyperlink{15789326112236459498}{\texttt{IOBuffer}} for the available constructors. If \texttt{data} is given, creates a \texttt{PipeBuffer} to operate on a data vector, optionally specifying a size beyond which the underlying \texttt{Array} may not be grown.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iobuffer.jl#L127-L135}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11079438348370067557}{} 
\hyperlink{11079438348370067557}{\texttt{Base.readavailable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readavailable(stream)
\end{minted}

Read all available data on the stream, blocking the task only if no data is available. The result is a \texttt{Vector\{UInt8,1\}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L68-L73}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13454403377667762339}{} 
\hyperlink{13454403377667762339}{\texttt{Base.IOContext}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IOContext
\end{minted}

\texttt{IOContext} provides a mechanism for passing output configuration settings among \hyperlink{14071376285304310153}{\texttt{show}} methods.

In short, it is an immutable dictionary that is a subclass of \texttt{IO}. It supports standard dictionary operations such as \hyperlink{13720608614876840481}{\texttt{getindex}}, and can also be used as an I/O stream.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/show.jl#L207-L214}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15316695504427164836}{} 
\hyperlink{15316695504427164836}{\texttt{Base.IOContext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IOContext(io::IO, KV::Pair...)
\end{minted}

Create an \texttt{IOContext} that wraps a given stream, adding the specified \texttt{key=>value} pairs to the properties of that stream (note that \texttt{io} can itself be an \texttt{IOContext}).

\begin{itemize}
\item use \texttt{(key => value) in io} to see if this particular combination is in the properties set


\item use \texttt{get(io, key, default)} to retrieve the most recent value for a particular key

\end{itemize}
The following properties are in common use:

\begin{itemize}
\item \texttt{:compact}: Boolean specifying that small values should be printed more compactly, e.g. that numbers should be printed with fewer digits. This is set when printing array elements.


\item \texttt{:limit}: Boolean specifying that containers should be truncated, e.g. showing \texttt{…} in place of most elements.


\item \texttt{:displaysize}: A \texttt{Tuple\{Int,Int\}} giving the size in rows and columns to use for text output. This can be used to override the display size for called functions, but to get the size of the screen use the \texttt{displaysize} function.


\item \texttt{:typeinfo}: a \texttt{Type} characterizing the information already printed concerning the type of the object about to be displayed. This is mainly useful when displaying a collection of objects of the same type, so that redundant type information can be avoided (e.g. \texttt{[Float16(0)]} can be shown as {\textquotedbl}Float16[0.0]{\textquotedbl} instead of {\textquotedbl}Float16[Float16(0.0)]{\textquotedbl} : while displaying the elements of the array, the \texttt{:typeinfo} property will be set to \texttt{Float16}).


\item \texttt{:color}: Boolean specifying whether ANSI color/escape codes are supported/expected. By default, this is determined by whether \texttt{io} is a compatible terminal and by any \texttt{--color} command-line flag when \texttt{julia} was launched.

\end{itemize}
\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer();

julia> printstyled(IOContext(io, :color => true), "string", color=:red)

julia> String(take!(io))
"\e[31mstring\e[39m"

julia> printstyled(io, "string", color=:red)

julia> String(take!(io))
"string"
\end{minted}


\begin{minted}{jlcon}
julia> print(IOContext(stdout, :compact => false), 1.12341234)
1.12341234
julia> print(IOContext(stdout, :compact => true), 1.12341234)
1.12341
\end{minted}


\begin{minted}{jlcon}
julia> function f(io::IO)
           if get(io, :short, false)
               print(io, "short")
           else
               print(io, "loooooong")
           end
       end
f (generic function with 1 method)

julia> f(stdout)
loooooong
julia> f(IOContext(stdout, :short => true))
short
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/show.jl#L250-L317}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9657846139399432866}{} 
\hyperlink{9657846139399432866}{\texttt{Base.IOContext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IOContext(io::IO, context::IOContext)
\end{minted}

Create an \texttt{IOContext} that wraps an alternate \texttt{IO} but inherits the properties of \texttt{context}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/show.jl#L243-L247}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14803809014545196748}{}


\section{文本 I/O}


\hypertarget{14071376285304310153}{} 
\hyperlink{14071376285304310153}{\texttt{Base.show}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
show(x)
\end{minted}

Write an informative text representation of a value to the current output stream. New types should overload \texttt{show(io::IO, x)} where the first argument is a stream. The representation used by \texttt{show} generally includes Julia-specific formatting and type information.

\hyperlink{13076889230390082034}{\texttt{repr}} returns the output of \texttt{show} as a string.

See also \hyperlink{8248717042415202230}{\texttt{print}}, which writes un-decorated representations.

\textbf{Examples}


\begin{minted}{jlcon}
julia> show("Hello World!")
"Hello World!"
julia> print("Hello World!")
Hello World!
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/show.jl#L353-L371}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17506338626525391609}{} 
\hyperlink{17506338626525391609}{\texttt{Base.summary}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
summary(io::IO, x)
str = summary(x)
\end{minted}

Print to a stream \texttt{io}, or return a string \texttt{str}, giving a brief description of a value. By default returns \texttt{string(typeof(x))}, e.g. \hyperlink{7720564657383125058}{\texttt{Int64}}.

For arrays, returns a string of size and type info, e.g. \texttt{10-element Array\{Int64,1\}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> summary(1)
"Int64"

julia> summary(zeros(2))
"2-element Array{Float64,1}"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/show.jl#L2094-L2112}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8248717042415202230}{} 
\hyperlink{8248717042415202230}{\texttt{Base.print}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
print([io::IO], xs...)
\end{minted}

Write to \texttt{io} (or to the default output stream \hyperlink{18181294266083891471}{\texttt{stdout}} if \texttt{io} is not given) a canonical (un-decorated) text representation. The representation used by \texttt{print} includes minimal formatting and tries to avoid Julia-specific details.

\texttt{print} falls back to calling \texttt{show}, so most types should just define \texttt{show}. Define \texttt{print} if your type has a separate {\textquotedbl}plain{\textquotedbl} representation. For example, \texttt{show} displays strings with quotes, and \texttt{print} displays strings without quotes.

\hyperlink{7919678712989769360}{\texttt{string}} returns the output of \texttt{print} as a string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> print("Hello World!")
Hello World!
julia> io = IOBuffer();

julia> print(io, "Hello", ' ', :World!)

julia> String(take!(io))
"Hello World!"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/io.jl#L5-L31}{\texttt{source}}


\end{adjustwidth}
\hypertarget{783803254548423222}{} 
\hyperlink{783803254548423222}{\texttt{Base.println}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
println([io::IO], xs...)
\end{minted}

Print (using \hyperlink{8248717042415202230}{\texttt{print}}) \texttt{xs} followed by a newline. If \texttt{io} is not supplied, prints to \hyperlink{18181294266083891471}{\texttt{stdout}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> println("Hello, world")
Hello, world

julia> io = IOBuffer();

julia> println(io, "Hello, world")

julia> String(take!(io))
"Hello, world\n"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/io.jl#L54-L72}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16920681785945917903}{} 
\hyperlink{16920681785945917903}{\texttt{Base.printstyled}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
printstyled([io], xs...; bold::Bool=false, color::Union{Symbol,Int}=:normal)
\end{minted}

Print \texttt{xs} in a color specified as a symbol or integer, optionally in bold.

\texttt{color} may take any of the values \texttt{:normal}, \texttt{:default}, \texttt{:bold}, \texttt{:black}, \texttt{:blink}, \texttt{:blue}, \texttt{:cyan}, \texttt{:green}, \texttt{:hidden}, \texttt{:light\_black}, \texttt{:light\_blue}, \texttt{:light\_cyan}, \texttt{:light\_green}, \texttt{:light\_magenta}, \texttt{:light\_red}, \texttt{:light\_yellow}, \texttt{:magenta}, \texttt{:nothing}, \texttt{:red}, \texttt{:reverse}, \texttt{:underline}, \texttt{:white}, or  \texttt{:yellow} or an integer between 0 and 255 inclusive. Note that not all terminals support 256 colors. If the keyword \texttt{bold} is given as \texttt{true}, the result will be printed in bold.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/util.jl#L408-L416}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6652981552509545835}{} 
\hyperlink{6652981552509545835}{\texttt{Base.sprint}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sprint(f::Function, args...; context=nothing, sizehint=0)
\end{minted}

Call the given function with an I/O stream and the supplied extra arguments. Everything written to this I/O stream is returned as a string. \texttt{context} can be either an \hyperlink{13454403377667762339}{\texttt{IOContext}} whose properties will be used, or a \texttt{Pair} specifying a property and its value. \texttt{sizehint} suggests the capacity of the buffer (in bytes).

The optional keyword argument \texttt{context} can be set to \texttt{:key=>value} pair or an \texttt{IO} or \hyperlink{13454403377667762339}{\texttt{IOContext}} object whose attributes are used for the I/O stream passed to \texttt{f}.  The optional \texttt{sizehint} is a suggested size (in bytes) to allocate for the buffer used to write the string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sprint(show, 66.66666; context=:compact => true)
"66.6667"

julia> sprint(showerror, BoundsError([1], 100))
"BoundsError: attempt to access 1-element Array{Int64,1} at index [100]"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/io.jl#L77-L99}{\texttt{source}}


\end{adjustwidth}
\hypertarget{991925725019765935}{} 
\hyperlink{991925725019765935}{\texttt{Base.showerror}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
showerror(io, e)
\end{minted}

Show a descriptive representation of an exception object \texttt{e}. This method is used to display the exception after a call to \hyperlink{16410366672587017456}{\texttt{throw}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> struct MyException <: Exception
           msg::AbstractString
       end

julia> function Base.showerror(io::IO, err::MyException)
           print(io, "MyException: ")
           print(io, err.msg)
       end

julia> err = MyException("test exception")
MyException("test exception")

julia> sprint(showerror, err)
"MyException: test exception"

julia> throw(MyException("test exception"))
ERROR: MyException: test exception
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/errorshow.jl#L3-L29}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15981569052160951906}{} 
\hyperlink{15981569052160951906}{\texttt{Base.dump}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dump(x; maxdepth=8)
\end{minted}

Show every part of the representation of a value. The depth of the output is truncated at \texttt{maxdepth}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> struct MyStruct
           x
           y
       end

julia> x = MyStruct(1, (2,3));

julia> dump(x)
MyStruct
  x: Int64 1
  y: Tuple{Int64,Int64}
    1: Int64 2
    2: Int64 3

julia> dump(x; maxdepth = 1)
MyStruct
  x: Int64 1
  y: Tuple{Int64,Int64}
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/show.jl#L2017-L2044}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11314997131411442967}{} 
\hyperlink{11314997131411442967}{\texttt{Base.Meta.@dump}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@dump expr
\end{minted}

Show every part of the representation of the given expression. Equivalent to \hyperlink{15981569052160951906}{\texttt{dump(:(expr))}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/meta.jl#L106-L111}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14199256323314707596}{} 
\hyperlink{14199256323314707596}{\texttt{Base.readline}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readline(io::IO=stdin; keep::Bool=false)
readline(filename::AbstractString; keep::Bool=false)
\end{minted}

Read a single line of text from the given I/O stream or file (defaults to \texttt{stdin}). When reading from a file, the text is assumed to be encoded in UTF-8. Lines in the input end with \texttt{{\textquotesingle}{\textbackslash}n{\textquotesingle}} or \texttt{{\textquotedbl}{\textbackslash}r{\textbackslash}n{\textquotedbl}} or the end of an input stream. When \texttt{keep} is false (as it is by default), these trailing newline characters are removed from the line before it is returned. When \texttt{keep} is true, they are returned as part of the line.

\textbf{Examples}


\begin{minted}{jlcon}
julia> open("my_file.txt", "w") do io
           write(io, "JuliaLang is a GitHub organization.\nIt has many members.\n");
       end
57

julia> readline("my_file.txt")
"JuliaLang is a GitHub organization."

julia> readline("my_file.txt", keep=true)
"JuliaLang is a GitHub organization.\n"

julia> rm("my_file.txt")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L420-L446}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16924445721840905654}{} 
\hyperlink{16924445721840905654}{\texttt{Base.readuntil}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readuntil(stream::IO, delim; keep::Bool = false)
readuntil(filename::AbstractString, delim; keep::Bool = false)
\end{minted}

Read a string from an I/O stream or a file, up to the given delimiter. The delimiter can be a \texttt{UInt8}, \texttt{AbstractChar}, string, or vector. Keyword argument \texttt{keep} controls whether the delimiter is included in the result. The text is assumed to be encoded in UTF-8.

\textbf{Examples}


\begin{minted}{jlcon}
julia> open("my_file.txt", "w") do io
           write(io, "JuliaLang is a GitHub organization.\nIt has many members.\n");
       end
57

julia> readuntil("my_file.txt", 'L')
"Julia"

julia> readuntil("my_file.txt", '.', keep = true)
"JuliaLang is a GitHub organization."

julia> rm("my_file.txt")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L393-L417}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2102076388448706590}{} 
\hyperlink{2102076388448706590}{\texttt{Base.readlines}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readlines(io::IO=stdin; keep::Bool=false)
readlines(filename::AbstractString; keep::Bool=false)
\end{minted}

Read all lines of an I/O stream or a file as a vector of strings. Behavior is equivalent to saving the result of reading \hyperlink{14199256323314707596}{\texttt{readline}} repeatedly with the same arguments and saving the resulting lines as a vector of strings.

\textbf{Examples}


\begin{minted}{jlcon}
julia> open("my_file.txt", "w") do io
           write(io, "JuliaLang is a GitHub organization.\nIt has many members.\n");
       end
57

julia> readlines("my_file.txt")
2-element Array{String,1}:
 "JuliaLang is a GitHub organization."
 "It has many members."

julia> readlines("my_file.txt", keep=true)
2-element Array{String,1}:
 "JuliaLang is a GitHub organization.\n"
 "It has many members.\n"

julia> rm("my_file.txt")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L465-L492}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3474649815265066504}{} 
\hyperlink{3474649815265066504}{\texttt{Base.eachline}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eachline(io::IO=stdin; keep::Bool=false)
eachline(filename::AbstractString; keep::Bool=false)
\end{minted}

Create an iterable \texttt{EachLine} object that will yield each line from an I/O stream or a file. Iteration calls \hyperlink{14199256323314707596}{\texttt{readline}} on the stream argument repeatedly with \texttt{keep} passed through, determining whether trailing end-of-line characters are retained. When called with a file name, the file is opened once at the beginning of iteration and closed at the end. If iteration is interrupted, the file will be closed when the \texttt{EachLine} object is garbage collected.

\textbf{Examples}


\begin{minted}{jlcon}
julia> open("my_file.txt", "w") do io
           write(io, "JuliaLang is a GitHub organization.\n It has many members.\n");
       end;

julia> for line in eachline("my_file.txt")
           print(line)
       end
JuliaLang is a GitHub organization. It has many members.

julia> rm("my_file.txt");
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L929-L953}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1969380123003883060}{} 
\hyperlink{1969380123003883060}{\texttt{Base.displaysize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
displaysize([io::IO]) -> (lines, columns)
\end{minted}

Return the nominal size of the screen that may be used for rendering output to this \texttt{IO} object. If no input is provided, the environment variables \texttt{LINES} and \texttt{COLUMNS} are read. If those are not set, a default size of \texttt{(24, 80)} is returned.

\textbf{Examples}


\begin{minted}{jlcon}
julia> withenv("LINES" => 30, "COLUMNS" => 100) do
           displaysize()
       end
(30, 100)
\end{minted}

To get your TTY size,


\begin{minted}{julia}
julia> displaysize(stdout)
(34, 147)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stream.jl#L430-L452}{\texttt{source}}


\end{adjustwidth}

\hypertarget{6006580368420106291}{}


\section{多媒体 I/O}



就像文本输出用 \hyperlink{8248717042415202230}{\texttt{print}} 实现，用户自定义类型可以通过重载 \hyperlink{14071376285304310153}{\texttt{show}} 来指定其文本化表示， Julia 提供了一个应用于富多媒体输出的标准化机制 （例如图片、格式化文本、甚至音频和视频），由以下三部分组成：



\begin{itemize}
\item 函数 \hyperlink{12073120410747960438}{\texttt{display(x)}} 来请求一个 Julia 对象 \texttt{x} 最丰富的多媒体展示，并以纯文本作为后备模式。


\item 重载 \hyperlink{14071376285304310153}{\texttt{show}} 允许指定用户自定义类型的任意多媒体表现形式（以标准MIME类型为键值）。


\item Multimedia-capable display backends may be registered by subclassing a generic \hyperlink{10910270786739084548}{\texttt{AbstractDisplay}} type 并通过 \hyperlink{13142233867690107090}{\texttt{pushdisplay}} 将其压进显示后端的栈中。

\end{itemize}


基础 Julia 运行环境只提供纯文本显示， 但是更富的显示可以通过加载外部模块或者使用图形化 Julia 环境 （比如基于 IPython 的 IJulia notebook）来实现。


\hypertarget{10910270786739084548}{} 
\hyperlink{10910270786739084548}{\texttt{Base.Multimedia.AbstractDisplay}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractDisplay
\end{minted}

Abstract supertype for rich display output devices. \hyperlink{15269032442876270904}{\texttt{TextDisplay}} is a subtype of this.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L205-L210}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12073120410747960438}{} 
\hyperlink{12073120410747960438}{\texttt{Base.Multimedia.display}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
display(x)
display(d::AbstractDisplay, x)
display(mime, x)
display(d::AbstractDisplay, mime, x)
\end{minted}

AbstractDisplay \texttt{x} using the topmost applicable display in the display stack, typically using the richest supported multimedia output for \texttt{x}, with plain-text \hyperlink{18181294266083891471}{\texttt{stdout}} output as a fallback. The \texttt{display(d, x)} variant attempts to display \texttt{x} on the given display \texttt{d} only, throwing a \hyperlink{68769522931907606}{\texttt{MethodError}} if \texttt{d} cannot display objects of this type.

In general, you cannot assume that \texttt{display} output goes to \texttt{stdout} (unlike \hyperlink{8248717042415202230}{\texttt{print(x)}} or \hyperlink{14071376285304310153}{\texttt{show(x)}}).  For example, \texttt{display(x)} may open up a separate window with an image. \texttt{display(x)} means {\textquotedbl}show \texttt{x} in the best way you can for the current output device(s).{\textquotedbl} If you want REPL-like text output that is guaranteed to go to \texttt{stdout}, use \hyperlink{552201489544217829}{\texttt{show(stdout, {\textquotedbl}text/plain{\textquotedbl}, x)}} instead.

There are also two variants with a \texttt{mime} argument (a MIME type string, such as \texttt{{\textquotedbl}image/png{\textquotedbl}}), which attempt to display \texttt{x} using the requested MIME type \emph{only}, throwing a \texttt{MethodError} if this type is not supported by either the display(s) or by \texttt{x}. With these variants, one can also supply the {\textquotedbl}raw{\textquotedbl} data in the requested MIME type by passing \texttt{x::AbstractString} (for MIME types with text-based storage, such as text/html or application/postscript) or \texttt{x::Vector\{UInt8\}} (for binary MIME types).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L295-L318}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3747338623378176831}{} 
\hyperlink{3747338623378176831}{\texttt{Base.Multimedia.redisplay}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
redisplay(x)
redisplay(d::AbstractDisplay, x)
redisplay(mime, x)
redisplay(d::AbstractDisplay, mime, x)
\end{minted}

By default, the \texttt{redisplay} functions simply call \hyperlink{12073120410747960438}{\texttt{display}}. However, some display backends may override \texttt{redisplay} to modify an existing display of \texttt{x} (if any). Using \texttt{redisplay} is also a hint to the backend that \texttt{x} may be redisplayed several times, and the backend may choose to defer the display until (for example) the next interactive prompt.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L365-L377}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18261911967873698059}{} 
\hyperlink{18261911967873698059}{\texttt{Base.Multimedia.displayable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
displayable(mime) -> Bool
displayable(d::AbstractDisplay, mime) -> Bool
\end{minted}

Returns a boolean value indicating whether the given \texttt{mime} type (string) is displayable by any of the displays in the current display stack, or specifically by the display \texttt{d} in the second variant.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L217-L224}{\texttt{source}}


\end{adjustwidth}
\hypertarget{552201489544217829}{} 
\hyperlink{552201489544217829}{\texttt{Base.show}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
show(io, mime, x)
\end{minted}

The \hyperlink{12073120410747960438}{\texttt{display}} functions ultimately call \texttt{show} in order to write an object \texttt{x} as a given \texttt{mime} type to a given I/O stream \texttt{io} (usually a memory buffer), if possible. In order to provide a rich multimedia representation of a user-defined type \texttt{T}, it is only necessary to define a new \texttt{show} method for \texttt{T}, via: \texttt{show(io, ::MIME{\textquotedbl}mime{\textquotedbl}, x::T) = ...}, where \texttt{mime} is a MIME-type string and the function body calls \hyperlink{16947913578760238729}{\texttt{write}} (or similar) to write that representation of \texttt{x} to \texttt{io}. (Note that the \texttt{MIME{\textquotedbl}{\textquotedbl}} notation only supports literal strings; to construct \texttt{MIME} types in a more flexible manner use \texttt{MIME\{Symbol({\textquotedbl}{\textquotedbl})\}}.)

For example, if you define a \texttt{MyImage} type and know how to write it to a PNG file, you could define a function \texttt{show(io, ::MIME{\textquotedbl}image/png{\textquotedbl}, x::MyImage) = ...} to allow your images to be displayed on any PNG-capable \texttt{AbstractDisplay} (such as IJulia). As usual, be sure to \texttt{import Base.show} in order to add new methods to the built-in Julia function \texttt{show}.

The default MIME type is \texttt{MIME{\textquotedbl}text/plain{\textquotedbl}}. There is a fallback definition for \texttt{text/plain} output that calls \texttt{show} with 2 arguments. Therefore, this case should be handled by defining a 2-argument \texttt{show(io::IO, x::MyType)} method.

Technically, the \texttt{MIME{\textquotedbl}mime{\textquotedbl}} macro defines a singleton type for the given \texttt{mime} string, which allows us to exploit Julia{\textquotesingle}s dispatch mechanisms in determining how to display objects of any given type.

The first argument to \texttt{show} can be an \hyperlink{13454403377667762339}{\texttt{IOContext}} specifying output format properties. See \hyperlink{13454403377667762339}{\texttt{IOContext}} for details.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L79-L107}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17009846549175764333}{} 
\hyperlink{17009846549175764333}{\texttt{Base.Multimedia.showable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
showable(mime, x)
\end{minted}

Returns a boolean value indicating whether or not the object \texttt{x} can be written as the given \texttt{mime} type.

(By default, this is determined automatically by the existence of the corresponding \hyperlink{14071376285304310153}{\texttt{show}} method for \texttt{typeof(x)}.  Some types provide custom \texttt{showable} methods; for example, if the available MIME formats depend on the \emph{value} of \texttt{x}.)

\textbf{Examples}


\begin{minted}{jlcon}
julia> showable(MIME("text/plain"), rand(5))
true

julia> showable("img/png", rand(5))
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L57-L75}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13076889230390082034}{} 
\hyperlink{13076889230390082034}{\texttt{Base.repr}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
repr(mime, x; context=nothing)
\end{minted}

Returns an \texttt{AbstractString} or \texttt{Vector\{UInt8\}} containing the representation of \texttt{x} in the requested \texttt{mime} type, as written by \hyperlink{552201489544217829}{\texttt{show(io, mime, x)}} (throwing a \hyperlink{68769522931907606}{\texttt{MethodError}} if no appropriate \texttt{show} is available). An \texttt{AbstractString} is returned for MIME types with textual representations (such as \texttt{{\textquotedbl}text/html{\textquotedbl}} or \texttt{{\textquotedbl}application/postscript{\textquotedbl}}), whereas binary data is returned as \texttt{Vector\{UInt8\}}. (The function \texttt{istextmime(mime)} returns whether or not Julia treats a given \texttt{mime} type as text.)

The optional keyword argument \texttt{context} can be set to \texttt{:key=>value} pair or an \texttt{IO} or \hyperlink{13454403377667762339}{\texttt{IOContext}} object whose attributes are used for the I/O stream passed to \texttt{show}.

As a special case, if \texttt{x} is an \texttt{AbstractString} (for textual MIME types) or a \texttt{Vector\{UInt8\}} (for binary MIME types), the \texttt{repr} function assumes that \texttt{x} is already in the requested \texttt{mime} format and simply returns \texttt{x}. This special case does not apply to the \texttt{{\textquotedbl}text/plain{\textquotedbl}} MIME type. This is useful so that raw data can be passed to \texttt{display(m::MIME, x)}.

In particular, \texttt{repr({\textquotedbl}text/plain{\textquotedbl}, x)} is typically a {\textquotedbl}pretty-printed{\textquotedbl} version of \texttt{x} designed for human consumption.  See also \hyperlink{1022185167898104929}{\texttt{repr(x)}} to instead return a string corresponding to \hyperlink{14071376285304310153}{\texttt{show(x)}} that may be closer to how the value of \texttt{x} would be entered in Julia.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4];

julia> repr("text/plain", A)
"2×2 Array{Int64,2}:\n 1  2\n 3  4"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L111-L144}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8600147476403167481}{} 
\hyperlink{8600147476403167481}{\texttt{Base.Multimedia.MIME}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
MIME
\end{minted}

A type representing a standard internet data format. {\textquotedbl}MIME{\textquotedbl} stands for {\textquotedbl}Multipurpose Internet Mail Extensions{\textquotedbl}, since the standard was originally used to describe multimedia attachments to email messages.

A \texttt{MIME} object can be passed as the second argument to \hyperlink{14071376285304310153}{\texttt{show}} to request output in that format.

\textbf{Examples}


\begin{minted}{jlcon}
julia> show(stdout, MIME("text/plain"), "hi")
"hi"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L16-L31}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6820226512558634039}{} 
\hyperlink{6820226512558634039}{\texttt{Base.Multimedia.@MIME\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@MIME_str
\end{minted}

A convenience macro for writing \hyperlink{8600147476403167481}{\texttt{MIME}} types, typically used when adding methods to \hyperlink{14071376285304310153}{\texttt{show}}. For example the syntax \texttt{show(io::IO, ::MIME{\textquotedbl}text/html{\textquotedbl}, x::MyType) = ...} could be used to define how to write an HTML representation of \texttt{MyType}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L34-L41}{\texttt{source}}


\end{adjustwidth}

如上面提到的，用户可以定义新的显示后端。 例如，可以在窗口显示 PNG 图片的模块可以在 Julia 中注册这个能力， 以便为有 PNG 表示的类型调用 \hyperlink{12073120410747960438}{\texttt{display(x)}} 时可以在模块窗口中自动显示图片。



In order to define a new display backend, one should first create a subtype \texttt{D} of the abstract class \hyperlink{10910270786739084548}{\texttt{AbstractDisplay}}.  Then, for each MIME type (\texttt{mime} string) that can be displayed on \texttt{D}, one should define a function \texttt{display(d::D, ::MIME{\textquotedbl}mime{\textquotedbl}, x) = ...} that displays \texttt{x} as that MIME type, usually by calling \hyperlink{552201489544217829}{\texttt{show(io, mime, x)}} or \hyperlink{13076889230390082034}{\texttt{repr(io, mime, x)}}. A \hyperlink{68769522931907606}{\texttt{MethodError}} should be thrown if \texttt{x} cannot be displayed as that MIME type; this is automatic if one calls \texttt{show} or \texttt{repr}. Finally, one should define a function \texttt{display(d::D, x)} that queries \hyperlink{17009846549175764333}{\texttt{showable(mime, x)}} for the \texttt{mime} types supported by \texttt{D} and displays the {\textquotedbl}best{\textquotedbl} one; a \texttt{MethodError} should be thrown if no supported MIME types are found for \texttt{x}.  Similarly, some subtypes may wish to override \hyperlink{3747338623378176831}{\texttt{redisplay(d::D, ...)}}. (Again, one should \texttt{import Base.display} to add new methods to \texttt{display}.) The return values of these functions are up to the implementation (since in some cases it may be useful to return a display {\textquotedbl}handle{\textquotedbl} of some type).  The display functions for \texttt{D} can then be called directly, but they can also be invoked automatically from \hyperlink{12073120410747960438}{\texttt{display(x)}} simply by pushing a new display onto the display-backend stack with:


\hypertarget{13142233867690107090}{} 
\hyperlink{13142233867690107090}{\texttt{Base.Multimedia.pushdisplay}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pushdisplay(d::AbstractDisplay)
\end{minted}

Pushes a new display \texttt{d} on top of the global display-backend stack. Calling \texttt{display(x)} or \texttt{display(mime, x)} will display \texttt{x} on the topmost compatible backend in the stack (i.e., the topmost backend that does not throw a \hyperlink{68769522931907606}{\texttt{MethodError}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L260-L266}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8186818521201126118}{} 
\hyperlink{8186818521201126118}{\texttt{Base.Multimedia.popdisplay}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
popdisplay()
popdisplay(d::AbstractDisplay)
\end{minted}

Pop the topmost backend off of the display-backend stack, or the topmost copy of \texttt{d} in the second variant.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L272-L278}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15269032442876270904}{} 
\hyperlink{15269032442876270904}{\texttt{Base.Multimedia.TextDisplay}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
TextDisplay(io::IO)
\end{minted}

Returns a \texttt{TextDisplay <: AbstractDisplay}, which displays any object as the text/plain MIME type (by default), writing the text representation to the given I/O stream. (This is how objects are printed in the Julia REPL.)



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L230-L236}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14215879795817507566}{} 
\hyperlink{14215879795817507566}{\texttt{Base.Multimedia.istextmime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
istextmime(m::MIME)
\end{minted}

Determine whether a MIME type is text data. MIME types are assumed to be binary data except for a set of types known to be text data (possibly Unicode).

\textbf{Examples}


\begin{minted}{jlcon}
julia> istextmime(MIME("text/plain"))
true

julia> istextmime(MIME("img/png"))
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L166-L180}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4207587152343103076}{}


\section{网络 I/O}


\hypertarget{17592092836786738289}{} 
\hyperlink{17592092836786738289}{\texttt{Base.bytesavailable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
bytesavailable(io)
\end{minted}

Return the number of bytes available for reading before a read from this stream or buffer will block.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer("JuliaLang is a GitHub organization");

julia> bytesavailable(io)
34
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L337-L349}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17463337378549787661}{} 
\hyperlink{17463337378549787661}{\texttt{Base.ntoh}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ntoh(x)
\end{minted}

Convert the endianness of a value from Network byte order (big-endian) to that used by the Host.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L531-L535}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17749829108559566344}{} 
\hyperlink{17749829108559566344}{\texttt{Base.hton}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hton(x)
\end{minted}

Convert the endianness of a value from that used by the Host to Network byte order (big-endian).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L538-L542}{\texttt{source}}


\end{adjustwidth}
\hypertarget{931615445303306874}{} 
\hyperlink{931615445303306874}{\texttt{Base.ltoh}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ltoh(x)
\end{minted}

Convert the endianness of a value from Little-endian to that used by the Host.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L545-L549}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6797011189807622497}{} 
\hyperlink{6797011189807622497}{\texttt{Base.htol}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
htol(x)
\end{minted}

Convert the endianness of a value from that used by the Host to Little-endian.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L552-L556}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15528013539058180213}{} 
\hyperlink{15528013539058180213}{\texttt{Base.ENDIAN\_BOM}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ENDIAN_BOM
\end{minted}

The 32-bit byte-order-mark indicates the native byte order of the host machine. Little-endian machines will contain the value \texttt{0x04030201}. Big-endian machines will contain the value \texttt{0x01020304}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L522-L528}{\texttt{source}}


\end{adjustwidth}

\hypertarget{6778474211430286926}{}


\chapter{运算符与记号}



数学符号与函数的扩展文档在 \hyperlink{15384328882825997796}{这里}.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
符号 & 含义 \\
\hline
\texttt{@m} & the at-symbol invokes \hyperlink{5127151953463206825}{macro} \texttt{m}; followed by space-separated expressions or a function-call-like argument list \\
\hline
\hyperlink{4329035214952292986}{\texttt{!}} & an exclamation mark is a prefix operator for logical negation ({\textquotedbl}not{\textquotedbl}) \\
\hline
\texttt{a!} & function names that end with an exclamation mark modify one or more of their arguments by convention \\
\hline
\texttt{\#} & the number sign (or hash or pound) character begins single line comments \\
\hline
\texttt{\#=} & when followed by an equals sign, it begins a multi-line comment (these are nestable) \\
\hline
\texttt{=\#} & end a multi-line comment by immediately preceding the number sign with an equals sign \\
\hline
\texttt{\$} & the dollar sign is used for \hyperlink{4452850363638134205}{string} and \hyperlink{2110612885536688224}{expression} interpolation \\
\hline
\hyperlink{3827563084771191385}{\texttt{\%}} & the percent symbol is the remainder operator \\
\hline
\hyperlink{462277561264792021}{\texttt{{\textasciicircum}}} & the caret is the exponentiation operator. \\
\hline
\hyperlink{1494761116451616317}{\texttt{\&}} & single ampersand is bitwise and \\
\hline
\hyperlink{4714012140247170866}{\texttt{\&\&}} & double ampersands is short-circuiting boolean and \\
\hline
\hyperlink{9633687763646488853}{\texttt{|}} & single pipe character is bitwise or \\
\hline
\hyperlink{2053797086840563251}{\texttt{||}} & double pipe characters is short-circuiting boolean or \\
\hline
\hyperlink{7071880015536674935}{\texttt{\unicodeveebar{}}} & the unicode xor character is bitwise exclusive or \\
\hline
\hyperlink{2433030275488323500}{\texttt{{\textasciitilde}}} & the tilde is an operator for bitwise not \\
\hline
\texttt{{\textquotesingle}} & a trailing apostrophe is the \hyperlink{10565518144285607255}{\texttt{adjoint}} (that is, the complex transpose) operator Aᴴ \\
\hline
\hyperlink{7592762607639177347}{\texttt{*}} & the asterisk is used for multiplication, including matrix multiplication and \hyperlink{12933998460683957945}{string concatenation} \\
\hline
\hyperlink{4103478871488785445}{\texttt{/}} & forward slash divides the argument on its left by the one on its right \\
\hline
\hyperlink{4639577998029770435}{\texttt{{\textbackslash}}} & backslash operator divides the argument on its right by the one on its left, commonly used to solve matrix equations \\
\hline
\texttt{()} & parentheses with no arguments constructs an empty \hyperlink{17462354060312563026}{\texttt{Tuple}} \\
\hline
\texttt{(a,...)} & parentheses with comma-separated arguments constructs a tuple containing its arguments \\
\hline
\texttt{(a=1,...)} & parentheses with comma-separated assignments constructs a \hyperlink{3845731488275720657}{\texttt{NamedTuple}} \\
\hline
\texttt{(x;y)} & parentheses can also be used to group one or more semicolon separated expressions \\
\hline
\texttt{a[]} & \hyperlink{16717190941363337071}{array indexing} (calling \hyperlink{13720608614876840481}{\texttt{getindex}} or \hyperlink{1309244355901386657}{\texttt{setindex!}}) \\
\hline
\texttt{[,]} & \hyperlink{13961675686342166416}{vector literal constructor} (calling \hyperlink{2932104842023453623}{\texttt{vect}}) \\
\hline
\texttt{[;]} & \hyperlink{7211239115857068032}{vertical concatenation} (calling \hyperlink{14691815416955507876}{\texttt{vcat}} or \hyperlink{16279083053557795116}{\texttt{hvcat}}) \\
\hline
\texttt{[    ]} & with space-separated expressions, \hyperlink{12933998460683957945}{horizontal concatenation} (calling \hyperlink{8862791894748483563}{\texttt{hcat}} or \hyperlink{16279083053557795116}{\texttt{hvcat}}) \\
\hline
\texttt{T\{ \}} & curly braces following a type list that type{\textquotesingle}s \href{@ref Parametric-Types}{parameters} \\
\hline
\texttt{\{\}} & curly braces can also be used to group multiple \hyperlink{7395867868929900722}{\texttt{where}} expressions in function declarations \\
\hline
\texttt{;} & semicolons separate statements, begin a list of keyword arguments in function declarations or calls, or are used to separate array literals for vertical concatenation \\
\hline
\texttt{,} & commas separate function arguments or tuple or array components \\
\hline
\texttt{?} & the question mark delimits the ternary conditional operator (used like: \texttt{conditional ? if\_true : if\_false}) \\
\hline
\texttt{{\textquotedbl} {\textquotedbl}} & the single double-quote character delimits \hyperlink{2825695355940841177}{\texttt{String}} literals \\
\hline
\texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl} {\textquotedbl}{\textquotedbl}{\textquotedbl}} & three double-quote characters delimits string literals that may contain \texttt{{\textquotedbl}} and ignore leading indentation \\
\hline
\texttt{{\textquotesingle} {\textquotesingle}} & the single-quote character delimits \hyperlink{3463806064296245385}{\texttt{Char}} (that is, character) literals \\
\hline
\texttt{` `} & the backtick character delimits \href{@ref Running-External-Programs}{external process} (\hyperlink{10541952265148699805}{\texttt{Cmd}}) literals \\
\hline
\texttt{A...} & triple periods are a postfix operator that {\textquotedbl}splat{\textquotedbl} their arguments{\textquotesingle} contents into many arguments of a function call or declare a varargs function that {\textquotedbl}slurps{\textquotedbl} up many arguments into a single tuple \\
\hline
\texttt{a.b} & single periods access named fields in objects/modules (calling \hyperlink{11040282462516403506}{\texttt{getproperty}} or \hyperlink{9055518433069578344}{\texttt{setproperty!}}) \\
\hline
\texttt{f.()} & periods may also prefix parentheses (like \texttt{f.(...)}) or infix operators (like \texttt{.+}) to perform the function element-wise (calling \hyperlink{616124539803111168}{\texttt{broadcast}}) \\
\hline
\texttt{a:b} & colons (\hyperlink{1027906901078185239}{\texttt{:}}) used as a binary infix operator construct a range from \texttt{a} to \texttt{b} (inclusive) with fixed step size \texttt{1} \\
\hline
\texttt{a:s:b} & colons (\hyperlink{1027906901078185239}{\texttt{:}}) used as a ternary infix operator construct a range from \texttt{a} to \texttt{b} (inclusive) with step size \texttt{s} \\
\hline
\texttt{:} & when used by themselves, \hyperlink{13649361117037263099}{\texttt{Colon}}s represent all indices within a dimension, frequently combined with \hyperlink{16717190941363337071}{indexing} \\
\hline
\texttt{::} & double-colons represent a type annotation or \hyperlink{11044636010338290257}{\texttt{typeassert}}, depending on context, frequently used when declaring function arguments \\
\hline
\texttt{:( )} & quoted expression \\
\hline
\texttt{:a} & \hyperlink{18332791376992528422}{\texttt{Symbol}} a \\
\hline
\hyperlink{6254591906563366276}{\texttt{<:}} & subtype operator \\
\hline
\hyperlink{13074915255343859584}{\texttt{>:}} & supertype operator (reverse of subtype operator) \\
\hline
\texttt{=} & single equals sign is \hyperlink{5717755217131708382}{assignment} \\
\hline
\hyperlink{15143149452920304570}{\texttt{==}} & double equals sign is value equality comparison \\
\hline
\hyperlink{7974744969331231272}{\texttt{===}} & triple equals sign is programmatically identical equality comparison. \\
\hline
\end{tabulary}

\end{table}



\hypertarget{18182954167110420496}{}


\chapter{排序及相关函数}



Julia 拥有为数众多的灵活的 API，用于对已经排序的值数组进行排序和交互。默认情况下，Julia 会选择合理的算法并按标准升序进行排序：




\begin{minted}{jlcon}
julia> sort([2,3,1])
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



你同样可以轻松实现逆序排序：




\begin{minted}{jlcon}
julia> sort([2,3,1], rev=true)
3-element Array{Int64,1}:
 3
 2
 1
\end{minted}



对数组进行 in-place 排序时，要使用 \texttt{!} 版的排序函数：




\begin{minted}{jlcon}
julia> a = [2,3,1];

julia> sort!(a);

julia> a
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



你可以计算用于排列的索引，而不是直接对数组进行排序：




\begin{minted}{jlcon}
julia> v = randn(5)
5-element Array{Float64,1}:
  0.297288
  0.382396
 -0.597634
 -0.0104452
 -0.839027

julia> p = sortperm(v)
5-element Array{Int64,1}:
 5
 3
 4
 1
 2

julia> v[p]
5-element Array{Float64,1}:
 -0.839027
 -0.597634
 -0.0104452
  0.297288
  0.382396
\end{minted}



数组可以根据对其值任意的转换结果来进行排序；




\begin{minted}{jlcon}
julia> sort(v, by=abs)
5-element Array{Float64,1}:
 -0.0104452
  0.297288
  0.382396
 -0.597634
 -0.839027
\end{minted}



或者通过转换来进行逆序排序




\begin{minted}{jlcon}
julia> sort(v, by=abs, rev=true)
5-element Array{Float64,1}:
 -0.839027
 -0.597634
  0.382396
  0.297288
 -0.0104452
\end{minted}



如有必要，可以选择排序算法：




\begin{minted}{jlcon}
julia> sort(v, alg=InsertionSort)
5-element Array{Float64,1}:
 -0.839027
 -0.597634
 -0.0104452
  0.297288
  0.382396
\end{minted}



所有与排序和顺序相关的函数依赖于“小于”关系，该关系定义了要操纵的值的总顺序。默认情况下会调用 \texttt{isless} 函数，但可以通过 \texttt{lt} 关键字指定关系。



\hypertarget{4871241370828313347}{}


\section{排序函数}


\hypertarget{12296873681374954808}{} 
\hyperlink{12296873681374954808}{\texttt{Base.sort!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sort!(v; alg::Algorithm=defalg(v), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)
\end{minted}

Sort the vector \texttt{v} in place. \hyperlink{3128942217888095342}{\texttt{QuickSort}} is used by default for numeric arrays while \hyperlink{15702510047226101978}{\texttt{MergeSort}} is used for other arrays. You can specify an algorithm to use via the \texttt{alg} keyword (see \href{@ref}{Sorting Algorithms} for available algorithms). The \texttt{by} keyword lets you provide a function that will be applied to each element before comparison; the \texttt{lt} keyword allows providing a custom {\textquotedbl}less than{\textquotedbl} function; use \texttt{rev=true} to reverse the sorting order. These options are independent and can be used together in all possible combinations: if both \texttt{by} and \texttt{lt} are specified, the \texttt{lt} function is applied to the result of the \texttt{by} function; \texttt{rev=true} reverses whatever ordering specified via the \texttt{by} and \texttt{lt} keywords.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [3, 1, 2]; sort!(v); v
3-element Array{Int64,1}:
 1
 2
 3

julia> v = [3, 1, 2]; sort!(v, rev = true); v
3-element Array{Int64,1}:
 3
 2
 1

julia> v = [(1, "c"), (3, "a"), (2, "b")]; sort!(v, by = x -> x[1]); v
3-element Array{Tuple{Int64,String},1}:
 (1, "c")
 (2, "b")
 (3, "a")

julia> v = [(1, "c"), (3, "a"), (2, "b")]; sort!(v, by = x -> x[2]); v
3-element Array{Tuple{Int64,String},1}:
 (3, "a")
 (2, "b")
 (1, "c")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L658-L696}{\texttt{source}}



\begin{lstlisting}
sort!(A; dims::Integer, alg::Algorithm=defalg(A), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)
\end{lstlisting}

Sort the multidimensional array \texttt{A} along dimension \texttt{dims}. See \hyperlink{12296873681374954808}{\texttt{sort!}} for a description of possible keyword arguments.

To sort slices of an array, refer to \hyperlink{16302460085412736163}{\texttt{sortslices}}.

\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4 3; 1 2]
2×2 Array{Int64,2}:
 4  3
 1  2

julia> sort!(A, dims = 1); A
2×2 Array{Int64,2}:
 1  2
 4  3

julia> sort!(A, dims = 2); A
2×2 Array{Int64,2}:
 1  2
 3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L1052-L1080}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8473525809131227606}{} 
\hyperlink{8473525809131227606}{\texttt{Base.sort}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sort(v; alg::Algorithm=defalg(v), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)
\end{minted}

Variant of \hyperlink{12296873681374954808}{\texttt{sort!}} that returns a sorted copy of \texttt{v} leaving \texttt{v} itself unmodified.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [3, 1, 2];

julia> sort(v)
3-element Array{Int64,1}:
 1
 2
 3

julia> v
3-element Array{Int64,1}:
 3
 1
 2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L741-L762}{\texttt{source}}



\begin{lstlisting}
sort(A; dims::Integer, alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)
\end{lstlisting}

Sort a multidimensional array \texttt{A} along the given dimension. See \hyperlink{12296873681374954808}{\texttt{sort!}} for a description of possible keyword arguments.

To sort slices of an array, refer to \hyperlink{16302460085412736163}{\texttt{sortslices}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4 3; 1 2]
2×2 Array{Int64,2}:
 4  3
 1  2

julia> sort(A, dims = 1)
2×2 Array{Int64,2}:
 1  2
 4  3

julia> sort(A, dims = 2)
2×2 Array{Int64,2}:
 3  4
 1  2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L994-L1020}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17035770587913381438}{} 
\hyperlink{17035770587913381438}{\texttt{Base.sortperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sortperm(v; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)
\end{minted}

Return a permutation vector \texttt{I} that puts \texttt{v[I]} in sorted order. The order is specified using the same keywords as \hyperlink{12296873681374954808}{\texttt{sort!}}. The permutation is guaranteed to be stable even if the sorting algorithm is unstable, meaning that indices of equal elements appear in ascending order.

See also \hyperlink{9803303601105416895}{\texttt{sortperm!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [3, 1, 2];

julia> p = sortperm(v)
3-element Array{Int64,1}:
 2
 3
 1

julia> v[p]
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L871-L897}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6009222092275543960}{} 
\hyperlink{6009222092275543960}{\texttt{Base.Sort.InsertionSort}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
InsertionSort
\end{minted}

Indicate that a sorting function should use the insertion sort algorithm. Insertion sort traverses the collection one element at a time, inserting each element into its correct, sorted position in the output list.

Characteristics:

\begin{itemize}
\item \emph{stable}: preserves the ordering of elements which compare equal (e.g. {\textquotedbl}a{\textquotedbl} and {\textquotedbl}A{\textquotedbl} in a sort of letters which ignores case).


\item \emph{in-place} in memory.


\item \emph{quadratic performance} in the number of elements to be sorted: it is well-suited to small collections but should not be used for large ones.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L420-L435}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15702510047226101978}{} 
\hyperlink{15702510047226101978}{\texttt{Base.Sort.MergeSort}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
MergeSort
\end{minted}

Indicate that a sorting function should use the merge sort algorithm. Merge sort divides the collection into subcollections and repeatedly merges them, sorting each subcollection at each step, until the entire collection has been recombined in sorted form.

Characteristics:

\begin{itemize}
\item \emph{stable}: preserves the ordering of elements which compare equal (e.g. {\textquotedbl}a{\textquotedbl} and {\textquotedbl}A{\textquotedbl} in a sort of letters which ignores case).


\item \emph{not in-place} in memory.


\item \emph{divide-and-conquer} sort strategy.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L452-L467}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3128942217888095342}{} 
\hyperlink{3128942217888095342}{\texttt{Base.Sort.QuickSort}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
QuickSort
\end{minted}

Indicate that a sorting function should use the quick sort algorithm, which is \emph{not} stable.

Characteristics:

\begin{itemize}
\item \emph{not stable}: does not preserve the ordering of elements which compare equal (e.g. {\textquotedbl}a{\textquotedbl} and {\textquotedbl}A{\textquotedbl} in a sort of letters which ignores case).


\item \emph{in-place} in memory.


\item \emph{divide-and-conquer}: sort strategy similar to \hyperlink{15702510047226101978}{\texttt{MergeSort}}.


\item \emph{good performance} for large collections.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L437-L450}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9221207223457135076}{} 
\hyperlink{9221207223457135076}{\texttt{Base.Sort.PartialQuickSort}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
PartialQuickSort{T <: Union{Integer,OrdinalRange}}
\end{minted}

Indicate that a sorting function should use the partial quick sort algorithm. Partial quick sort returns the smallest \texttt{k} elements sorted from smallest to largest, finding them and sorting them using \hyperlink{3128942217888095342}{\texttt{QuickSort}}.

Characteristics:

\begin{itemize}
\item \emph{not stable}: does not preserve the ordering of elements which compare equal (e.g. {\textquotedbl}a{\textquotedbl} and {\textquotedbl}A{\textquotedbl} in a sort of letters which ignores case).


\item \emph{in-place} in memory.


\item \emph{divide-and-conquer}: sort strategy similar to \hyperlink{15702510047226101978}{\texttt{MergeSort}}.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L401-L414}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9803303601105416895}{} 
\hyperlink{9803303601105416895}{\texttt{Base.Sort.sortperm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sortperm!(ix, v; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward, initialized::Bool=false)
\end{minted}

Like \hyperlink{17035770587913381438}{\texttt{sortperm}}, but accepts a preallocated index vector \texttt{ix}.  If \texttt{initialized} is \texttt{false} (the default), \texttt{ix} is initialized to contain the values \texttt{1:length(v)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [3, 1, 2]; p = zeros(Int, 3);

julia> sortperm!(p, v); p
3-element Array{Int64,1}:
 2
 3
 1

julia> v[p]
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L925-L947}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16302460085412736163}{} 
\hyperlink{16302460085412736163}{\texttt{Base.sortslices}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sortslices(A; dims, alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)
\end{minted}

Sort slices of an array \texttt{A}. The required keyword argument \texttt{dims} must be either an integer or a tuple of integers. It specifies the dimension(s) over which the slices are sorted.

E.g., if \texttt{A} is a matrix, \texttt{dims=1} will sort rows, \texttt{dims=2} will sort columns. Note that the default comparison function on one dimensional slices sorts lexicographically.

For the remaining keyword arguments, see the documentation of \hyperlink{12296873681374954808}{\texttt{sort!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1) # Sort rows
3×3 Array{Int64,2}:
 -1   6  4
  7   3  5
  9  -2  8

julia> sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1, lt=(x,y)->isless(x[2],y[2]))
3×3 Array{Int64,2}:
  9  -2  8
  7   3  5
 -1   6  4

julia> sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1, rev=true)
3×3 Array{Int64,2}:
  9  -2  8
  7   3  5
 -1   6  4

julia> sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2) # Sort columns
3×3 Array{Int64,2}:
  3   5  7
 -1  -4  6
 -2   8  9

julia> sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2, alg=InsertionSort, lt=(x,y)->isless(x[2],y[2]))
3×3 Array{Int64,2}:
  5   3  7
 -4  -1  6
  8  -2  9

julia> sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2, rev=true)
3×3 Array{Int64,2}:
 7   5   3
 6  -4  -1
 9   8  -2
\end{minted}

\textbf{Higher dimensions}

\texttt{sortslices} extends naturally to higher dimensions. E.g., if \texttt{A} is a a 2x2x2 array, \texttt{sortslices(A, dims=3)} will sort slices within the 3rd dimension, passing the 2x2 slices \texttt{A[:, :, 1]} and \texttt{A[:, :, 2]} to the comparison function. Note that while there is no default order on higher-dimensional slices, you may use the \texttt{by} or \texttt{lt} keyword argument to specify such an order.

If \texttt{dims} is a tuple, the order of the dimensions in \texttt{dims} is relevant and specifies the linear order of the slices. E.g., if \texttt{A} is three dimensional and \texttt{dims} is \texttt{(1, 2)}, the orderings of the first two dimensions are re-arranged such such that the slices (of the remaining third dimension) are sorted. If \texttt{dims} is \texttt{(2, 1)} instead, the same slices will be taken, but the result order will be row-major instead.

\textbf{Higher dimensional examples}


\begin{lstlisting}
julia> A = permutedims(reshape([4 3; 2 1; 'A' 'B'; 'C' 'D'], (2, 2, 2)), (1, 3, 2))
2×2×2 Array{Any,3}:
[:, :, 1] =
 4  3
 2  1

[:, :, 2] =
 'A'  'B'
 'C'  'D'

julia> sortslices(A, dims=(1,2))
2×2×2 Array{Any,3}:
[:, :, 1] =
 1  3
 2  4

[:, :, 2] =
 'D'  'B'
 'C'  'A'

julia> sortslices(A, dims=(2,1))
2×2×2 Array{Any,3}:
[:, :, 1] =
 1  2
 3  4

[:, :, 2] =
 'D'  'C'
 'B'  'A'

julia> sortslices(reshape([5; 4; 3; 2; 1], (1,1,5)), dims=3, by=x->x[1,1])
1×1×5 Array{Int64,3}:
[:, :, 1] =
 1

[:, :, 2] =
 2

[:, :, 3] =
 3

[:, :, 4] =
 4

[:, :, 5] =
 5
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L1650-L1766}{\texttt{source}}


\end{adjustwidth}

\hypertarget{12039042665737142654}{}


\section{排列顺序相关的函数}


\hypertarget{16696594531893143583}{} 
\hyperlink{16696594531893143583}{\texttt{Base.issorted}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issorted(v, lt=isless, by=identity, rev:Bool=false, order::Ordering=Forward)
\end{minted}

Test whether a vector is in sorted order. The \texttt{lt}, \texttt{by} and \texttt{rev} keywords modify what order is considered to be sorted just as they do for \hyperlink{8473525809131227606}{\texttt{sort}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> issorted([1, 2, 3])
true

julia> issorted([(1, "b"), (2, "a")], by = x -> x[1])
true

julia> issorted([(1, "b"), (2, "a")], by = x -> x[2])
false

julia> issorted([(1, "b"), (2, "a")], by = x -> x[2], rev=true)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L69-L89}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17287969759719368562}{} 
\hyperlink{17287969759719368562}{\texttt{Base.Sort.searchsorted}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
searchsorted(a, x; by=<transform>, lt=<comparison>, rev=false)
\end{minted}

Return the range of indices of \texttt{a} which compare as equal to \texttt{x} (using binary search) according to the order specified by the \texttt{by}, \texttt{lt} and \texttt{rev} keywords, assuming that \texttt{a} is already sorted in that order. Return an empty range located at the insertion point if \texttt{a} does not contain values equal to \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> searchsorted([1, 2, 4, 5, 5, 7], 4) # single match
3:3

julia> searchsorted([1, 2, 4, 5, 5, 7], 5) # multiple matches
4:5

julia> searchsorted([1, 2, 4, 5, 5, 7], 3) # no match, insert in the middle
3:2

julia> searchsorted([1, 2, 4, 5, 5, 7], 9) # no match, insert at end
7:6

julia> searchsorted([1, 2, 4, 5, 5, 7], 0) # no match, insert at start
1:0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L313-L338}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12786822915971523090}{} 
\hyperlink{12786822915971523090}{\texttt{Base.Sort.searchsortedfirst}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
searchsortedfirst(a, x; by=<transform>, lt=<comparison>, rev=false)
\end{minted}

Return the index of the first value in \texttt{a} greater than or equal to \texttt{x}, according to the specified order. Return \texttt{length(a) + 1} if \texttt{x} is greater than all values in \texttt{a}. \texttt{a} is assumed to be sorted.

\textbf{Examples}


\begin{minted}{jlcon}
julia> searchsortedfirst([1, 2, 4, 5, 5, 7], 4) # single match
3

julia> searchsortedfirst([1, 2, 4, 5, 5, 7], 5) # multiple matches
4

julia> searchsortedfirst([1, 2, 4, 5, 5, 7], 3) # no match, insert in the middle
3

julia> searchsortedfirst([1, 2, 4, 5, 5, 7], 9) # no match, insert at end
7

julia> searchsortedfirst([1, 2, 4, 5, 5, 7], 0) # no match, insert at start
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L340-L364}{\texttt{source}}


\end{adjustwidth}
\hypertarget{572230519808649943}{} 
\hyperlink{572230519808649943}{\texttt{Base.Sort.searchsortedlast}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
searchsortedlast(a, x; by=<transform>, lt=<comparison>, rev=false)
\end{minted}

Return the index of the last value in \texttt{a} less than or equal to \texttt{x}, according to the specified order. Return \texttt{0} if \texttt{x} is less than all values in \texttt{a}. \texttt{a} is assumed to be sorted.

\textbf{Examples}


\begin{minted}{jlcon}
julia> searchsortedlast([1, 2, 4, 5, 5, 7], 4) # single match
3

julia> searchsortedlast([1, 2, 4, 5, 5, 7], 5) # multiple matches
5

julia> searchsortedlast([1, 2, 4, 5, 5, 7], 3) # no match, insert in the middle
2

julia> searchsortedlast([1, 2, 4, 5, 5, 7], 9) # no match, insert at end
6

julia> searchsortedlast([1, 2, 4, 5, 5, 7], 0) # no match, insert at start
0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L366-L390}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1055038474257484236}{} 
\hyperlink{1055038474257484236}{\texttt{Base.Sort.partialsort!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
partialsort!(v, k; by=<transform>, lt=<comparison>, rev=false)
\end{minted}

Partially sort the vector \texttt{v} in place, according to the order specified by \texttt{by}, \texttt{lt} and \texttt{rev} so that the value at index \texttt{k} (or range of adjacent values if \texttt{k} is a range) occurs at the position where it would appear if the array were fully sorted via a non-stable algorithm. If \texttt{k} is a single index, that value is returned; if \texttt{k} is a range, an array of values at those indices is returned. Note that \texttt{partialsort!} does not fully sort the input array.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1, 2, 4, 3, 4]
5-element Array{Int64,1}:
 1
 2
 4
 3
 4

julia> partialsort!(a, 4)
4

julia> a
5-element Array{Int64,1}:
 1
 2
 3
 4
 4

julia> a = [1, 2, 4, 3, 4]
5-element Array{Int64,1}:
 1
 2
 4
 3
 4

julia> partialsort!(a, 4, rev=true)
2

julia> a
5-element Array{Int64,1}:
 4
 4
 3
 2
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L103-L153}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16583557202403194142}{} 
\hyperlink{16583557202403194142}{\texttt{Base.Sort.partialsort}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
partialsort(v, k, by=<transform>, lt=<comparison>, rev=false)
\end{minted}

Variant of \hyperlink{1055038474257484236}{\texttt{partialsort!}} which copies \texttt{v} before partially sorting it, thereby returning the same thing as \texttt{partialsort!} but leaving \texttt{v} unmodified.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L158-L163}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1642559230838768770}{} 
\hyperlink{1642559230838768770}{\texttt{Base.Sort.partialsortperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
partialsortperm(v, k; by=<transform>, lt=<comparison>, rev=false)
\end{minted}

Return a partial permutation \texttt{I} of the vector \texttt{v}, so that \texttt{v[I]} returns values of a fully sorted version of \texttt{v} at index \texttt{k}. If \texttt{k} is a range, a vector of indices is returned; if \texttt{k} is an integer, a single index is returned. The order is specified using the same keywords as \texttt{sort!}. The permutation is stable, meaning that indices of equal elements appear in ascending order.

Note that this function is equivalent to, but more efficient than, calling \texttt{sortperm(...)[k]}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [3, 1, 2, 1];

julia> v[partialsortperm(v, 1)]
1

julia> p = partialsortperm(v, 1:3)
3-element view(::Array{Int64,1}, 1:3) with eltype Int64:
 2
 4
 3

julia> v[p]
3-element Array{Int64,1}:
 1
 1
 2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L767-L797}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15860704871012966363}{} 
\hyperlink{15860704871012966363}{\texttt{Base.Sort.partialsortperm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
partialsortperm!(ix, v, k; by=<transform>, lt=<comparison>, rev=false, initialized=false)
\end{minted}

Like \hyperlink{1642559230838768770}{\texttt{partialsortperm}}, but accepts a preallocated index vector \texttt{ix} the same size as \texttt{v}, which is used to store (a permutation of) the indices of \texttt{v}.

If the index vector \texttt{ix} is initialized with the indices of \texttt{v} (or a permutation thereof), \texttt{initialized} should be set to \texttt{true}.

If \texttt{initialized} is \texttt{false} (the default), then \texttt{ix} is initialized to contain the indices of \texttt{v}.

If \texttt{initialized} is \texttt{true}, but \texttt{ix} does not contain (a permutation of) the indices of \texttt{v}, the behavior of \texttt{partialsortperm!} is undefined.

(Typically, the indices of \texttt{v} will be \texttt{1:length(v)}, although if \texttt{v} has an alternative array type with non-one-based indices, such as an \texttt{OffsetArray}, \texttt{ix} must also be an \texttt{OffsetArray} with the same indices, and must contain as values (a permutation of) these same indices.)

Upon return, \texttt{ix} is guaranteed to have the indices \texttt{k} in their sorted positions, such that


\begin{minted}{julia}
partialsortperm!(ix, v, k);
v[ix[k]] == partialsort(v, k)
\end{minted}

The return value is the \texttt{k}th element of \texttt{ix} if \texttt{k} is an integer, or view into \texttt{ix} if \texttt{k} is a range.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [3, 1, 2, 1];

julia> ix = Vector{Int}(undef, 4);

julia> partialsortperm!(ix, v, 1)
2

julia> ix = [1:4;];

julia> partialsortperm!(ix, v, 2:3, initialized=true)
2-element view(::Array{Int64,1}, 2:3) with eltype Int64:
 4
 3
\end{minted}


\begin{lstlisting}

\end{lstlisting}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L801-L845}{\texttt{source}}


\end{adjustwidth}

\hypertarget{16771045260393095482}{}


\section{排序算法}



目前，Julia Base 中有四种可用的排序算法：



\begin{itemize}
\item \hyperlink{6009222092275543960}{\texttt{InsertionSort}}


\item \hyperlink{3128942217888095342}{\texttt{QuickSort}}


\item \hyperlink{9221207223457135076}{\texttt{PartialQuickSort(k)}}


\item \hyperlink{15702510047226101978}{\texttt{MergeSort}}

\end{itemize}


\texttt{InsertionSort} 是一个在 \texttt{QuickSort} 中使用的时间复杂度为 O(n{\textasciicircum}2) 的稳定的排序算法，它通常在 \texttt{n} 比较小的时候才具有较高的效率。



\texttt{QuickSort} 是一个内置并且非常快，但是不稳定的时间复杂度为 O(n log n）的排序算法，例如即使数组两个元素相等的，它们排序之后的顺序也可能和在原数组中顺序不一致。\texttt{QuickSort} 是内置的包括整数和浮点数在内的数字值的默认排序算法。



\texttt{PartialQuickSort(k)} 类似于 \texttt{QuickSort}，但是如果 \texttt{k} 是一个整数，输出数组只排序到索引 \texttt{k}，如果 \texttt{k} 是 \texttt{OrdinalRange}，则输出数组排在 \texttt{k} 范围内。 例如：




\begin{minted}{julia}
x = rand(1:500, 100)
k = 50
k2 = 50:100
s = sort(x; alg=QuickSort)
ps = sort(x; alg=PartialQuickSort(k))
qs = sort(x; alg=PartialQuickSort(k2))
map(issorted, (s, ps, qs))             # => (true, false, false)
map(x->issorted(x[1:k]), (s, ps, qs))  # => (true, true, false)
map(x->issorted(x[k2]), (s, ps, qs))   # => (true, false, true)
s[1:k] == ps[1:k]                      # => true
s[k2] == qs[k2]                        # => true
\end{minted}



\texttt{MergeSort} 是一个时间复杂度为 O(n log n) 的稳定但是非 in-place 的算法，它需要一个大小为输入数组一般的临时数组——同时也不像 \texttt{QuickSort} 一样快。\texttt{MergeSort} 是非数值型数据的默认排序算法。



默认排序算法的选择是基于它们的快速稳定，或者 \emph{appear} 之类的。对于数值类型，实际上选择了 \texttt{QuickSort}，因为在这种情况下，它更快，与稳定排序没有区别(除非数组以某种方式记录了突变)



Julia选择默认排序算法的机制是通过 \texttt{Base.Sort.defalg} 来实现的，其允许将特定算法注册为特定数组的所有排序函数中的默认值。例如，这有两个默认算法 \href{https://github.com/JuliaLang/julia/blob/master/base/sort.jl}{\texttt{sort.jl}}:




\begin{minted}{julia}
defalg(v::AbstractArray) = MergeSort
defalg(v::AbstractArray{<:Number}) = QuickSort
\end{minted}



对于数值型数组，选择非稳定的默认排序算法的原则是稳定的排序算法没有必要的（例如：但两个值相比较时相等且不可区分时）。



\hypertarget{17136071574841524151}{}


\chapter{迭代相关}


\hypertarget{6781886173930121818}{} 
\hyperlink{6781886173930121818}{\texttt{Base.Iterators.Stateful}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Stateful(itr)
\end{minted}

There are several different ways to think about this iterator wrapper:

\begin{itemize}
\item[1. ] It provides a mutable wrapper around an iterator and its iteration state.


\item[2. ] It turns an iterator-like abstraction into a \texttt{Channel}-like abstraction.


\item[3. ] It{\textquotesingle}s an iterator that mutates to become its own rest iterator whenever an item is produced.

\end{itemize}
\texttt{Stateful} provides the regular iterator interface. Like other mutable iterators (e.g. \hyperlink{12548845729684045604}{\texttt{Channel}}), if iteration is stopped early (e.g. by a \hyperlink{6474422097180568887}{\texttt{break}} in a \hyperlink{9105224580875818383}{\texttt{for}} loop), iteration can be resumed from the same spot by continuing to iterate over the same iterator object (in contrast, an immutable iterator would restart from the beginning).

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = Iterators.Stateful("abcdef");

julia> isempty(a)
false

julia> popfirst!(a)
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)

julia> collect(Iterators.take(a, 3))
3-element Array{Char,1}:
 'b'
 'c'
 'd'

julia> collect(a)
2-element Array{Char,1}:
 'e'
 'f'
\end{minted}


\begin{minted}{jlcon}
julia> a = Iterators.Stateful([1,1,1,2,3,4]);

julia> for x in a; x == 1 || break; end

julia> Base.peek(a)
3

julia> sum(a) # Sum the remaining elements
7
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L1151-L1202}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11836366300100000234}{} 
\hyperlink{11836366300100000234}{\texttt{Base.Iterators.zip}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
zip(iters...)
\end{minted}

Run multiple iterators at the same time, until any of them is exhausted. The value type of the \texttt{zip} iterator is a tuple of values of its subiterators.

\begin{quote}
\textbf{Note}

\texttt{zip} orders the calls to its subiterators in such a way that stateful iterators will not advance when another iterator finishes in the current iteration.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> a = 1:5
1:5

julia> b = ["e","d","b","c","a"]
5-element Array{String,1}:
 "e"
 "d"
 "b"
 "c"
 "a"

julia> c = zip(a,b)
Base.Iterators.Zip{Tuple{UnitRange{Int64},Array{String,1}}}((1:5, ["e", "d", "b", "c", "a"]))

julia> length(c)
5

julia> first(c)
(1, "e")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L267-L299}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2184606349967262519}{} 
\hyperlink{2184606349967262519}{\texttt{Base.Iterators.enumerate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
enumerate(iter)
\end{minted}

An iterator that yields \texttt{(i, x)} where \texttt{i} is a counter starting at 1, and \texttt{x} is the \texttt{i}th value from the given iterator. It{\textquotesingle}s useful when you need not only the values \texttt{x} over which you are iterating, but also the number of iterations so far. Note that \texttt{i} may not be valid for indexing \texttt{iter}; it{\textquotesingle}s also possible that \texttt{x != iter[i]}, if \texttt{iter} has indices that do not start at 1. See the \texttt{pairs(IndexLinear(), iter)} method if you want to ensure that \texttt{i} is an index.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = ["a", "b", "c"];

julia> for (index, value) in enumerate(a)
           println("$index $value")
       end
1 a
2 b
3 c
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L110-L132}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3784260484755044695}{} 
\hyperlink{3784260484755044695}{\texttt{Base.Iterators.rest}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rest(iter, state)
\end{minted}

An iterator that yields the same elements as \texttt{iter}, but starting at the given \texttt{state}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> collect(Iterators.rest([1,2,3,4], 2))
3-element Array{Int64,1}:
 2
 3
 4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L504-L517}{\texttt{source}}


\end{adjustwidth}
\hypertarget{218851424586263192}{} 
\hyperlink{218851424586263192}{\texttt{Base.Iterators.countfrom}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
countfrom(start=1, step=1)
\end{minted}

An iterator that counts forever, starting at \texttt{start} and incrementing by \texttt{step}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> for v in Iterators.countfrom(5, 2)
           v > 10 && break
           println(v)
       end
5
7
9
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L563-L578}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7844855039511634473}{} 
\hyperlink{7844855039511634473}{\texttt{Base.Iterators.take}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
take(iter, n)
\end{minted}

An iterator that generates at most the first \texttt{n} elements of \texttt{iter}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = 1:2:11
1:2:11

julia> collect(a)
6-element Array{Int64,1}:
  1
  3
  5
  7
  9
 11

julia> collect(Iterators.take(a,3))
3-element Array{Int64,1}:
 1
 3
 5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L600-L625}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6722714944255905418}{} 
\hyperlink{6722714944255905418}{\texttt{Base.Iterators.takewhile}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
takewhile(pred, iter)
\end{minted}

An iterator that generates element from \texttt{iter} as long as predicate \texttt{pred} is true, afterwards, drops every element.

\begin{quote}
\textbf{Julia 1.4}

This function requires at least Julia 1.4.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> s = collect(1:5)
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia> collect(Iterators.takewhile(<(3),s))
2-element Array{Int64,1}:
 1
 2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L713-L738}{\texttt{source}}


\end{adjustwidth}
\hypertarget{744681231854455039}{} 
\hyperlink{744681231854455039}{\texttt{Base.Iterators.drop}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
drop(iter, n)
\end{minted}

An iterator that generates all but the first \texttt{n} elements of \texttt{iter}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = 1:2:11
1:2:11

julia> collect(a)
6-element Array{Int64,1}:
  1
  3
  5
  7
  9
 11

julia> collect(Iterators.drop(a,4))
2-element Array{Int64,1}:
  9
 11
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L657-L681}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1884086427843682212}{} 
\hyperlink{1884086427843682212}{\texttt{Base.Iterators.dropwhile}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dropwhile(pred, iter)
\end{minted}

An iterator that drops element from \texttt{iter} as long as predicate \texttt{pred} is true, afterwards, returns every element.

\begin{quote}
\textbf{Julia 1.4}

This function requires at least Julia 1.4.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> s = collect(1:5)
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia> collect(Iterators.dropwhile(<(3),s))
3-element Array{Int64,1}:
 3
 4
 5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L760-L786}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13881904186147539554}{} 
\hyperlink{13881904186147539554}{\texttt{Base.Iterators.cycle}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cycle(iter)
\end{minted}

An iterator that cycles through \texttt{iter} forever. If \texttt{iter} is empty, so is \texttt{cycle(iter)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> for (i, v) in enumerate(Iterators.cycle("hello"))
           print(v)
           i > 10 && break
       end
hellohelloh
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L810-L824}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16149631071727159175}{} 
\hyperlink{16149631071727159175}{\texttt{Base.Iterators.repeated}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
repeated(x[, n::Int])
\end{minted}

An iterator that generates the value \texttt{x} forever. If \texttt{n} is specified, generates \texttt{x} that many times (equivalent to \texttt{take(repeated(x), n)}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = Iterators.repeated([1 2], 4);

julia> collect(a)
4-element Array{Array{Int64,2},1}:
 [1 2]
 [1 2]
 [1 2]
 [1 2]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L849-L866}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12093738197940348056}{} 
\hyperlink{12093738197940348056}{\texttt{Base.Iterators.product}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
product(iters...)
\end{minted}

Return an iterator over the product of several iterators. Each generated element is a tuple whose \texttt{i}th element comes from the \texttt{i}th argument iterator. The first iterator changes the fastest.

\textbf{Examples}


\begin{minted}{jlcon}
julia> collect(Iterators.product(1:2, 3:5))
2×3 Array{Tuple{Int64,Int64},2}:
 (1, 3)  (1, 4)  (1, 5)
 (2, 3)  (2, 4)  (2, 5)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L883-L897}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6994420133663892005}{} 
\hyperlink{6994420133663892005}{\texttt{Base.Iterators.flatten}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
flatten(iter)
\end{minted}

Given an iterator that yields iterators, return an iterator that yields the elements of those iterators. Put differently, the elements of the argument iterator are concatenated.

\textbf{Examples}


\begin{minted}{jlcon}
julia> collect(Iterators.flatten((1:2, 8:9)))
4-element Array{Int64,1}:
 1
 2
 8
 9
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L1005-L1021}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16897863122939587148}{} 
\hyperlink{16897863122939587148}{\texttt{Base.Iterators.partition}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
partition(collection, n)
\end{minted}

Iterate over a collection \texttt{n} elements at a time.

\textbf{Examples}


\begin{minted}{jlcon}
julia> collect(Iterators.partition([1,2,3,4,5], 2))
3-element Array{SubArray{Int64,1,Array{Int64,1},Tuple{UnitRange{Int64}},true},1}:
 [1, 2]
 [3, 4]
 [5]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L1069-L1082}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10895775009535736865}{} 
\hyperlink{10895775009535736865}{\texttt{Base.Iterators.filter}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Iterators.filter(flt, itr)
\end{minted}

Given a predicate function \texttt{flt} and an iterable object \texttt{itr}, return an iterable object which upon iteration yields the elements \texttt{x} of \texttt{itr} that satisfy \texttt{flt(x)}. The order of the original iterator is preserved.

This function is \emph{lazy}; that is, it is guaranteed to return in  \(Θ(1)\)  time and use  \(Θ(1)\)  additional space, and \texttt{flt} will not be called by an invocation of \texttt{filter}. Calls to \texttt{flt} will be made when iterating over the returned iterable object. These calls are not cached and repeated calls will be made when reiterating.

See \hyperlink{11445961893478569145}{\texttt{Base.filter}} for an eager implementation of filtering for arrays.

\textbf{Examples}


\begin{minted}{jlcon}
julia> f = Iterators.filter(isodd, [1, 2, 3, 4, 5])
Base.Iterators.Filter{typeof(isodd),Array{Int64,1}}(isodd, [1, 2, 3, 4, 5])

julia> foreach(println, f)
1
3
5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L399-L424}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7329463517237104739}{} 
\hyperlink{7329463517237104739}{\texttt{Base.Iterators.accumulate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Iterators.accumulate(f, itr)
\end{minted}

Given a 2-argument function \texttt{f} and an iterator \texttt{itr}, return a new iterator that successively applies \texttt{f} to the previous value and the next element of \texttt{itr}.

This is effectively a lazy version of \hyperlink{318811369799573541}{\texttt{Base.accumulate}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> f = Iterators.accumulate(+, [1,2,3,4])
Base.Iterators.Accumulate{typeof(+),Array{Int64,1}}(+, [1, 2, 3, 4])

julia> foreach(println, f)
1
3
6
10
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L451-L471}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12943296479800134710}{} 
\hyperlink{12943296479800134710}{\texttt{Base.Iterators.reverse}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Iterators.reverse(itr)
\end{minted}

Given an iterator \texttt{itr}, then \texttt{reverse(itr)} is an iterator over the same collection but in the reverse order.

This iterator is {\textquotedbl}lazy{\textquotedbl} in that it does not make a copy of the collection in order to reverse it; see \hyperlink{5598774829914682536}{\texttt{Base.reverse}} for an eager implementation.

Not all iterator types \texttt{T} support reverse-order iteration.  If \texttt{T} doesn{\textquotesingle}t, then iterating over \texttt{Iterators.reverse(itr::T)} will throw a \hyperlink{68769522931907606}{\texttt{MethodError}} because of the missing \hyperlink{1722534687975587846}{\texttt{iterate}} methods for \texttt{Iterators.Reverse\{T\}}. (To implement these methods, the original iterator \texttt{itr::T} can be obtained from \texttt{r = Iterators.reverse(itr)} by \texttt{r.itr}.)

\textbf{Examples}


\begin{minted}{jlcon}
julia> foreach(println, Iterators.reverse(1:5))
5
4
3
2
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L50-L74}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5308857578406686427}{} 
\hyperlink{5308857578406686427}{\texttt{Base.Iterators.only}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
only(x)
\end{minted}

Returns the one and only element of collection \texttt{x}, and throws an \texttt{ArgumentError} if the collection has zero or multiple elements.

See also: \hyperlink{10301663699427216331}{\texttt{first}}, \hyperlink{7482613677577278193}{\texttt{last}}.

\begin{quote}
\textbf{Julia 1.4}

This method requires at least Julia 1.4.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L1269-L1279}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16532200500820416330}{} 
\hyperlink{16532200500820416330}{\texttt{Base.Iterators.peel}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
peel(iter)
\end{minted}

Returns the first element and an iterator over the remaining elements.

\textbf{Examples}


\begin{minted}{jlcon}
julia> (a, rest) = Iterators.peel("abc");

julia> a
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)

julia> collect(rest)
2-element Array{Char,1}:
 'b'
 'c'
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L522-L539}{\texttt{source}}


\end{adjustwidth}

\hypertarget{10594336122437775517}{}


\chapter{C 接口}


\hypertarget{14245046751182637566}{} 
\hyperlink{14245046751182637566}{\texttt{ccall}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ccall((function_name, library), returntype, (argtype1, ...), argvalue1, ...)
ccall(function_name, returntype, (argtype1, ...), argvalue1, ...)
ccall(function_pointer, returntype, (argtype1, ...), argvalue1, ...)
\end{minted}

Call a function in a C-exported shared library, specified by the tuple \texttt{(function\_name, library)}, where each component is either a string or symbol. Instead of specifying a library, one can also use a \texttt{function\_name} symbol or string, which is resolved in the current process. Alternatively, \texttt{ccall} may also be used to call a function pointer \texttt{function\_pointer}, such as one returned by \texttt{dlsym}.

Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression.

Each \texttt{argvalue} to the \texttt{ccall} will be converted to the corresponding \texttt{argtype}, by automatic insertion of calls to \texttt{unsafe\_convert(argtype, cconvert(argtype, argvalue))}. (See also the documentation for \hyperlink{6011318385865707029}{\texttt{unsafe\_convert}} and \hyperlink{16487788729383051927}{\texttt{cconvert}} for further details.) In most cases, this simply results in a call to \texttt{convert(argtype, argvalue)}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L849-L867}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2746947069730856184}{} 
\hyperlink{2746947069730856184}{\texttt{Core.Intrinsics.cglobal}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cglobal((symbol, library) [, type=Cvoid])
\end{minted}

Obtain a pointer to a global variable in a C-exported shared library, specified exactly as in \hyperlink{14245046751182637566}{\texttt{ccall}}. Returns a \texttt{Ptr\{Type\}}, defaulting to \texttt{Ptr\{Cvoid\}} if no \texttt{Type} argument is supplied. The values can be read or written by \hyperlink{13744149973765810952}{\texttt{unsafe\_load}} or \hyperlink{4579672834750013041}{\texttt{unsafe\_store!}}, respectively.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L7-L16}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11617107520401351255}{} 
\hyperlink{11617107520401351255}{\texttt{Base.@cfunction}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@cfunction(callable, ReturnType, (ArgumentTypes...,)) -> Ptr{Cvoid}
@cfunction($callable, ReturnType, (ArgumentTypes...,)) -> CFunction
\end{minted}

Generate a C-callable function pointer from the Julia function \texttt{callable} for the given type signature. To pass the return value to a \texttt{ccall}, use the argument type \texttt{Ptr\{Cvoid\}} in the signature.

Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression (although it can include a splat expression). And that these arguments will be evaluated in global scope during compile-time (not deferred until runtime). Adding a {\textquotesingle}\${\textquotesingle} in front of the function argument changes this to instead create a runtime closure over the local variable \texttt{callable} (this is not supported on all architectures).

See \href{@ref Calling-C-and-Fortran-Code}{manual section on ccall and cfunction usage}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> function foo(x::Int, y::Int)
           return x + y
       end

julia> @cfunction(foo, Int, (Int, Int))
Ptr{Cvoid} @0x000000001b82fcd0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L38-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2295032871603833153}{} 
\hyperlink{2295032871603833153}{\texttt{Base.CFunction}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
CFunction struct
\end{minted}

Garbage-collection handle for the return value from \texttt{@cfunction} when the first argument is annotated with {\textquotesingle}\${\textquotesingle}. Like all \texttt{cfunction} handles, it should be passed to \texttt{ccall} as a \texttt{Ptr\{Cvoid\}}, and will be converted automatically at the call site to the appropriate type.

See \hyperlink{11617107520401351255}{\texttt{@cfunction}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L19-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6011318385865707029}{} 
\hyperlink{6011318385865707029}{\texttt{Base.unsafe\_convert}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unsafe_convert(T, x)
\end{minted}

Convert \texttt{x} to a C argument of type \texttt{T} where the input \texttt{x} must be the return value of \texttt{cconvert(T, ...)}.

In cases where \hyperlink{1846942650946171605}{\texttt{convert}} would need to take a Julia object and turn it into a \texttt{Ptr}, this function should be used to define and perform that conversion.

Be careful to ensure that a Julia reference to \texttt{x} exists as long as the result of this function will be used. Accordingly, the argument \texttt{x} to this function should never be an expression, only a variable name or field reference. For example, \texttt{x=a.b.c} is acceptable, but \texttt{x=[a,b,c]} is not.

The \texttt{unsafe} prefix on this function indicates that using the result of this function after the \texttt{x} argument to this function is no longer accessible to the program may cause undefined behavior, including program corruption or segfaults, at any later time.

See also \hyperlink{16487788729383051927}{\texttt{cconvert}}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/pointer.jl#L34-L54}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16487788729383051927}{} 
\hyperlink{16487788729383051927}{\texttt{Base.cconvert}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cconvert(T,x)
\end{minted}

Convert \texttt{x} to a value to be passed to C code as type \texttt{T}, typically by calling \texttt{convert(T, x)}.

In cases where \texttt{x} cannot be safely converted to \texttt{T}, unlike \hyperlink{1846942650946171605}{\texttt{convert}}, \texttt{cconvert} may return an object of a type different from \texttt{T}, which however is suitable for \hyperlink{6011318385865707029}{\texttt{unsafe\_convert}} to handle. The result of this function should be kept valid (for the GC) until the result of \hyperlink{6011318385865707029}{\texttt{unsafe\_convert}} is not needed anymore. This can be used to allocate memory that will be accessed by the \texttt{ccall}. If multiple objects need to be allocated, a tuple of the objects can be used as return value.

Neither \texttt{convert} nor \texttt{cconvert} should take a Julia object and turn it into a \texttt{Ptr}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L374-L387}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13744149973765810952}{} 
\hyperlink{13744149973765810952}{\texttt{Base.unsafe\_load}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unsafe_load(p::Ptr{T}, i::Integer=1)
\end{minted}

Load a value of type \texttt{T} from the address of the \texttt{i}th element (1-indexed) starting at \texttt{p}. This is equivalent to the C expression \texttt{p[i-1]}.

The \texttt{unsafe} prefix on this function indicates that no validation is performed on the pointer \texttt{p} to ensure that it is valid. Incorrect usage may segfault your program or return garbage answers, in the same manner as C.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/pointer.jl#L95-L104}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4579672834750013041}{} 
\hyperlink{4579672834750013041}{\texttt{Base.unsafe\_store!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unsafe_store!(p::Ptr{T}, x, i::Integer=1)
\end{minted}

Store a value of type \texttt{T} to the address of the \texttt{i}th element (1-indexed) starting at \texttt{p}. This is equivalent to the C expression \texttt{p[i-1] = x}.

The \texttt{unsafe} prefix on this function indicates that no validation is performed on the pointer \texttt{p} to ensure that it is valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/pointer.jl#L107-L116}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2923048042876508667}{} 
\hyperlink{2923048042876508667}{\texttt{Base.unsafe\_copyto!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unsafe_copyto!(dest::Ptr{T}, src::Ptr{T}, N)
\end{minted}

Copy \texttt{N} elements from a source pointer to a destination, with no checking. The size of an element is determined by the type of the pointers.

The \texttt{unsafe} prefix on this function indicates that no validation is performed on the pointers \texttt{dest} and \texttt{src} to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L234-L243}{\texttt{source}}


\end{adjustwidth}
\hypertarget{151396139589158542}{} 
\hyperlink{151396139589158542}{\texttt{Base.unsafe\_copyto!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unsafe_copyto!(dest::Array, do, src::Array, so, N)
\end{minted}

Copy \texttt{N} elements from a source array to a destination, starting at offset \texttt{so} in the source and \texttt{do} in the destination (1-indexed).

The \texttt{unsafe} prefix on this function indicates that no validation is performed to ensure that N is inbounds on either array. Incorrect usage may corrupt or segfault your program, in the same manner as C.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L252-L261}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12476124489163612623}{} 
\hyperlink{12476124489163612623}{\texttt{Base.copyto!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
copyto!(dest, do, src, so, N)
\end{minted}

Copy \texttt{N} elements from collection \texttt{src} starting at offset \texttt{so}, to array \texttt{dest} starting at offset \texttt{do}. Return \texttt{dest}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L306-L311}{\texttt{source}}



\begin{lstlisting}
copyto!(dest::AbstractArray, src) -> dest
\end{lstlisting}

Copy all elements from collection \texttt{src} to array \texttt{dest}, whose length must be greater than or equal to the length \texttt{n} of \texttt{src}. The first \texttt{n} elements of \texttt{dest} are overwritten, the other elements are left untouched.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = [1., 0., 3., 0., 5.];

julia> y = zeros(7);

julia> copyto!(y, x);

julia> y
7-element Array{Float64,1}:
 1.0
 0.0
 3.0
 0.0
 5.0
 0.0
 0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L929-L955}{\texttt{source}}



\begin{minted}{julia}
copyto!(dest, Rdest::CartesianIndices, src, Rsrc::CartesianIndices) -> dest
\end{minted}

Copy the block of \texttt{src} in the range of \texttt{Rsrc} to the block of \texttt{dest} in the range of \texttt{Rdest}. The sizes of the two regions must match.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L993-L998}{\texttt{source}}



\begin{lstlisting}
copyto!(dest::AbstractMatrix, src::UniformScaling)
\end{lstlisting}

Copies a \hyperlink{723087258311673942}{\texttt{UniformScaling}} onto a matrix.

\begin{quote}
\textbf{Julia 1.1}

In Julia 1.0 this method only supported a square destination matrix. Julia 1.1. added support for a rectangular matrix.

\end{quote}


\end{adjustwidth}
\hypertarget{8901246211940014300}{} 
\hyperlink{8901246211940014300}{\texttt{Base.pointer}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pointer(array [, index])
\end{minted}

Get the native address of an array or string, optionally at a given location \texttt{index}.

This function is {\textquotedbl}unsafe{\textquotedbl}. Be careful to ensure that a Julia reference to \texttt{array} exists as long as this pointer will be used. The \hyperlink{6484353991353718972}{\texttt{GC.@preserve}} macro should be used to protect the \texttt{array} argument from garbage collection within a given block of code.

Calling \hyperlink{7936024700322877457}{\texttt{Ref(array[, index])}} is generally preferable to this function as it guarantees validity.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L172-L183}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14566494858943689253}{} 
\hyperlink{14566494858943689253}{\texttt{Base.unsafe\_wrap}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unsafe_wrap(Array, pointer::Ptr{T}, dims; own = false)
\end{minted}

Wrap a Julia \texttt{Array} object around the data at the address given by \texttt{pointer}, without making a copy.  The pointer element type \texttt{T} determines the array element type. \texttt{dims} is either an integer (for a 1d array) or a tuple of the array dimensions. \texttt{own} optionally specifies whether Julia should take ownership of the memory, calling \texttt{free} on the pointer when the array is no longer referenced.

This function is labeled {\textquotedbl}unsafe{\textquotedbl} because it will crash if \texttt{pointer} is not a valid memory address to data of the requested length.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/pointer.jl#L70-L81}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9366554937543398846}{} 
\hyperlink{9366554937543398846}{\texttt{Base.pointer\_from\_objref}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pointer_from_objref(x)
\end{minted}

Get the memory address of a Julia object as a \texttt{Ptr}. The existence of the resulting \texttt{Ptr} will not protect the object from garbage collection, so you must ensure that the object remains referenced for the whole time that the \texttt{Ptr} will be used.

This function may not be called on immutable objects, since they do not have stable memory addresses.

See also: \hyperlink{10812596548944930674}{\texttt{unsafe\_pointer\_to\_objref}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/pointer.jl#L132-L143}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10812596548944930674}{} 
\hyperlink{10812596548944930674}{\texttt{Base.unsafe\_pointer\_to\_objref}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unsafe_pointer_to_objref(p::Ptr)
\end{minted}

Convert a \texttt{Ptr} to an object reference. Assumes the pointer refers to a valid heap-allocated Julia object. If this is not the case, undefined behavior results, hence this function is considered {\textquotedbl}unsafe{\textquotedbl} and should be used with care.

See also: \hyperlink{9366554937543398846}{\texttt{pointer\_from\_objref}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/pointer.jl#L121-L129}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15284219011001573060}{} 
\hyperlink{15284219011001573060}{\texttt{Base.disable\_sigint}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
disable_sigint(f::Function)
\end{minted}

Disable Ctrl-C handler during execution of a function on the current task, for calling external code that may call julia code that is not interrupt safe. Intended to be called using \texttt{do} block syntax as follows:


\begin{lstlisting}
disable_sigint() do
    # interrupt-unsafe code
    ...
end
\end{lstlisting}

This is not needed on worker threads (\texttt{Threads.threadid() != 1}) since the \texttt{InterruptException} will only be delivered to the master thread. External functions that do not call julia code or julia runtime automatically disable sigint during their execution.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L427-L443}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1880405387924190637}{} 
\hyperlink{1880405387924190637}{\texttt{Base.reenable\_sigint}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reenable_sigint(f::Function)
\end{minted}

Re-enable Ctrl-C handler during execution of a function. Temporarily reverses the effect of \hyperlink{15284219011001573060}{\texttt{disable\_sigint}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L452-L457}{\texttt{source}}


\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Base.exit\_on\_sigint}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{16566861134678143754}{} 
\hyperlink{16566861134678143754}{\texttt{Base.systemerror}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
systemerror(sysfunc[, errno::Cint=Libc.errno()])
systemerror(sysfunc, iftrue::Bool)
\end{minted}

Raises a \texttt{SystemError} for \texttt{errno} with the descriptive string \texttt{sysfunc} if \texttt{iftrue} is \texttt{true}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/error.jl#L161-L166}{\texttt{source}}


\end{adjustwidth}
\hypertarget{329703646940222502}{} 
\hyperlink{329703646940222502}{\texttt{Base.windowserror}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
windowserror(sysfunc[, code::UInt32=Libc.GetLastError()])
windowserror(sysfunc, iftrue::Bool)
\end{minted}

Like \hyperlink{16566861134678143754}{\texttt{systemerror}}, but for Windows API functions that use \hyperlink{5383660591411020262}{\texttt{GetLastError}} to return an error code instead of setting \hyperlink{6265587084343794273}{\texttt{errno}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/error.jl#L175-L181}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10630331440513004826}{} 
\hyperlink{10630331440513004826}{\texttt{Core.Ptr}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Ptr{T}
\end{minted}

A memory address referring to data of type \texttt{T}.  However, there is no guarantee that the memory is actually valid, or that it actually represents data of the specified type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/pointer.jl#L3-L8}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7936024700322877457}{} 
\hyperlink{7936024700322877457}{\texttt{Core.Ref}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Ref{T}
\end{minted}

An object that safely references data of type \texttt{T}. This type is guaranteed to point to valid, Julia-allocated memory of the correct type. The underlying data is protected from freeing by the garbage collector as long as the \texttt{Ref} itself is referenced.

In Julia, \texttt{Ref} objects are dereferenced (loaded or stored) with \texttt{[]}.

Creation of a \texttt{Ref} to a value \texttt{x} of type \texttt{T} is usually written \texttt{Ref(x)}. Additionally, for creating interior pointers to containers (such as Array or Ptr), it can be written \texttt{Ref(a, i)} for creating a reference to the \texttt{i}-th element of \texttt{a}.

When passed as a \texttt{ccall} argument (either as a \texttt{Ptr} or \texttt{Ref} type), a \texttt{Ref} object will be converted to a native pointer to the data it references.

There is no invalid (NULL) \texttt{Ref} in Julia, but a \texttt{C\_NULL} instance of \texttt{Ptr} can be passed to a \texttt{ccall} Ref argument.

\textbf{Use in broadcasting}

Broadcasting with \texttt{Ref(x)} treats \texttt{x} as a scalar:


\begin{minted}{jlcon}
julia> isa.(Ref([1,2,3]), [Array, Dict, Int])
3-element BitArray{1}:
 1
 0
 0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/refpointer.jl#L3-L32}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1445070667463182719}{} 
\hyperlink{1445070667463182719}{\texttt{Base.Cchar}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cchar
\end{minted}

Equivalent to the native \texttt{char} c-type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L86-L90}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8681597464447377029}{} 
\hyperlink{8681597464447377029}{\texttt{Base.Cuchar}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cuchar
\end{minted}

Equivalent to the native \texttt{unsigned char} c-type (\hyperlink{6609065134969660118}{\texttt{UInt8}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L6-L10}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15152042474889311053}{} 
\hyperlink{15152042474889311053}{\texttt{Base.Cshort}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cshort
\end{minted}

Equivalent to the native \texttt{signed short} c-type (\hyperlink{6667287249103968645}{\texttt{Int16}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L14-L18}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8632604011862685836}{} 
\hyperlink{8632604011862685836}{\texttt{Base.Cstring}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cstring
\end{minted}

A C-style string composed of the native character type \hyperlink{1445070667463182719}{\texttt{Cchar}}s. \texttt{Cstring}s are NUL-terminated. For C-style strings composed of the native wide character type, see \hyperlink{510630608879002831}{\texttt{Cwstring}}. For more information about string interopability with C, see the \hyperlink{8959797014682889223}{manual}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L138-L147}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12769525139115944472}{} 
\hyperlink{12769525139115944472}{\texttt{Base.Cushort}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cushort
\end{minted}

Equivalent to the native \texttt{unsigned short} c-type (\hyperlink{7018610346698168012}{\texttt{UInt16}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L22-L26}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4506686204672235089}{} 
\hyperlink{4506686204672235089}{\texttt{Base.Cint}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cint
\end{minted}

Equivalent to the native \texttt{signed int} c-type (\hyperlink{10103694114785108551}{\texttt{Int32}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L30-L34}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11551219982691686969}{} 
\hyperlink{11551219982691686969}{\texttt{Base.Cuint}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cuint
\end{minted}

Equivalent to the native \texttt{unsigned int} c-type (\hyperlink{8690996847580776341}{\texttt{UInt32}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L38-L42}{\texttt{source}}


\end{adjustwidth}
\hypertarget{634246884863419146}{} 
\hyperlink{634246884863419146}{\texttt{Base.Clong}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Clong
\end{minted}

Equivalent to the native \texttt{signed long} c-type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L104-L108}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1371835691073233846}{} 
\hyperlink{1371835691073233846}{\texttt{Base.Culong}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Culong
\end{minted}

Equivalent to the native \texttt{unsigned long} c-type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L111-L115}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11934627959417709350}{} 
\hyperlink{11934627959417709350}{\texttt{Base.Clonglong}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Clonglong
\end{minted}

Equivalent to the native \texttt{signed long long} c-type (\hyperlink{7720564657383125058}{\texttt{Int64}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L86-L90}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12084952472844229160}{} 
\hyperlink{12084952472844229160}{\texttt{Base.Culonglong}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Culonglong
\end{minted}

Equivalent to the native \texttt{unsigned long long} c-type (\hyperlink{5500998675195555601}{\texttt{UInt64}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L94-L98}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13457418202407416700}{} 
\hyperlink{13457418202407416700}{\texttt{Base.Cintmax\_t}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cintmax_t
\end{minted}

Equivalent to the native \texttt{intmax\_t} c-type (\hyperlink{7720564657383125058}{\texttt{Int64}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L70-L74}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11180754709564572253}{} 
\hyperlink{11180754709564572253}{\texttt{Base.Cuintmax\_t}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cuintmax_t
\end{minted}

Equivalent to the native \texttt{uintmax\_t} c-type (\hyperlink{5500998675195555601}{\texttt{UInt64}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L78-L82}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12059505362233183406}{} 
\hyperlink{12059505362233183406}{\texttt{Base.Csize\_t}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Csize_t
\end{minted}

Equivalent to the native \texttt{size\_t} c-type (\texttt{UInt}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L54-L58}{\texttt{source}}


\end{adjustwidth}
\hypertarget{395962290360403795}{} 
\hyperlink{395962290360403795}{\texttt{Base.Cssize\_t}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cssize_t
\end{minted}

Equivalent to the native \texttt{ssize\_t} c-type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L62-L66}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9258508309302754837}{} 
\hyperlink{9258508309302754837}{\texttt{Base.Cptrdiff\_t}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cptrdiff_t
\end{minted}

Equivalent to the native \texttt{ptrdiff\_t} c-type (\texttt{Int}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L46-L50}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2619479148155454993}{} 
\hyperlink{2619479148155454993}{\texttt{Base.Cwchar\_t}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cwchar_t
\end{minted}

Equivalent to the native \texttt{wchar\_t} c-type (\hyperlink{10103694114785108551}{\texttt{Int32}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L118-L122}{\texttt{source}}


\end{adjustwidth}
\hypertarget{510630608879002831}{} 
\hyperlink{510630608879002831}{\texttt{Base.Cwstring}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cwstring
\end{minted}

A C-style string composed of the native wide character type \hyperlink{2619479148155454993}{\texttt{Cwchar\_t}}s. \texttt{Cwstring}s are NUL-terminated. For C-style strings composed of the native character type, see \hyperlink{8632604011862685836}{\texttt{Cstring}}. For more information about string interopability with C, see the \hyperlink{8959797014682889223}{manual}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L125-L135}{\texttt{source}}


\end{adjustwidth}
\hypertarget{899076182665625215}{} 
\hyperlink{899076182665625215}{\texttt{Base.Cfloat}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cfloat
\end{minted}

Equivalent to the native \texttt{float} c-type (\hyperlink{8101639384272933082}{\texttt{Float32}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L102-L106}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5889169829041130899}{} 
\hyperlink{5889169829041130899}{\texttt{Base.Cdouble}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cdouble
\end{minted}

Equivalent to the native \texttt{double} c-type (\hyperlink{5027751419500983000}{\texttt{Float64}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L110-L114}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4194942111221907511}{}


\chapter{LLVM 接口}


\hypertarget{12406828992589210838}{} 
\hyperlink{12406828992589210838}{\texttt{Core.Intrinsics.llvmcall}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
llvmcall(IR::String, ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)
llvmcall((declarations::String, IR::String), ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)
\end{minted}

Call LLVM IR string in the first argument. Similar to an LLVM function \texttt{define} block, arguments are available as consecutive unnamed SSA variables (\%0, \%1, etc.).

The optional declarations string contains external functions declarations that are necessary for llvm to compile the IR string. Multiple declarations can be passed in by separating them with line breaks.

Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression.

Each \texttt{ArgumentValue} to \texttt{llvmcall} will be converted to the corresponding \texttt{ArgumentType}, by automatic insertion of calls to \texttt{unsafe\_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue))}. (See also the documentation for \hyperlink{6011318385865707029}{\texttt{unsafe\_convert}} and \hyperlink{16487788729383051927}{\texttt{cconvert}} for further details.) In most cases, this simply results in a call to \texttt{convert(ArgumentType, ArgumentValue)}.

See \texttt{test/llvmcall.jl} for usage examples.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L870-L891}{\texttt{source}}


\end{adjustwidth}

\hypertarget{18164912302030951678}{}


\chapter{C 标准库}


\hypertarget{6469711430097433314}{} 
\hyperlink{6469711430097433314}{\texttt{Base.Libc.malloc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
malloc(size::Integer) -> Ptr{Cvoid}
\end{minted}

Call \texttt{malloc} from the C standard library.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L348-L352}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13715091851486420318}{} 
\hyperlink{13715091851486420318}{\texttt{Base.Libc.calloc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
calloc(num::Integer, size::Integer) -> Ptr{Cvoid}
\end{minted}

Call \texttt{calloc} from the C standard library.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L365-L369}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1243276183164334610}{} 
\hyperlink{1243276183164334610}{\texttt{Base.Libc.realloc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
realloc(addr::Ptr, size::Integer) -> Ptr{Cvoid}
\end{minted}

Call \texttt{realloc} from the C standard library.

See warning in the documentation for \hyperlink{1633533624062187737}{\texttt{free}} regarding only using this on memory originally obtained from \hyperlink{6469711430097433314}{\texttt{malloc}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L355-L362}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1633533624062187737}{} 
\hyperlink{1633533624062187737}{\texttt{Base.Libc.free}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
free(addr::Ptr)
\end{minted}

Call \texttt{free} from the C standard library. Only use this on memory obtained from \hyperlink{6469711430097433314}{\texttt{malloc}}, not on pointers retrieved from other C libraries. \hyperlink{10630331440513004826}{\texttt{Ptr}} objects obtained from C libraries should be freed by the free functions defined in that library, to avoid assertion failures if multiple \texttt{libc} libraries exist on the system.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L338-L345}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6265587084343794273}{} 
\hyperlink{6265587084343794273}{\texttt{Base.Libc.errno}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
errno([code])
\end{minted}

Get the value of the C library{\textquotesingle}s \texttt{errno}. If an argument is specified, it is used to set the value of \texttt{errno}.

The value of \texttt{errno} is only valid immediately after a \texttt{ccall} to a C library routine that sets it. Specifically, you cannot call \texttt{errno} at the next prompt in a REPL, because lots of code is executed between prompts.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L278-L287}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5310873199456377483}{} 
\hyperlink{5310873199456377483}{\texttt{Base.Libc.strerror}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
strerror(n=errno())
\end{minted}

Convert a system call error code to a descriptive string



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L291-L295}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5383660591411020262}{} 
\hyperlink{5383660591411020262}{\texttt{Base.Libc.GetLastError}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GetLastError()
\end{minted}

Call the Win32 \texttt{GetLastError} function [only available on Windows].



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L299-L303}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14255728048411856987}{} 
\hyperlink{14255728048411856987}{\texttt{Base.Libc.FormatMessage}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
FormatMessage(n=GetLastError())
\end{minted}

Convert a Win32 system call error code to a descriptive string [only available on Windows].



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L306-L310}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2367147567483563544}{} 
\hyperlink{2367147567483563544}{\texttt{Base.Libc.time}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
time(t::TmStruct)
\end{minted}

Converts a \texttt{TmStruct} struct to a number of seconds since the epoch.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L235-L239}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14018638426810725597}{} 
\hyperlink{14018638426810725597}{\texttt{Base.Libc.strftime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
strftime([format], time)
\end{minted}

Convert time, given as a number of seconds since the epoch or a \texttt{TmStruct}, to a formatted string using the given format. Supported formats are the same as those in the standard C library.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L183-L189}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16724851840034148355}{} 
\hyperlink{16724851840034148355}{\texttt{Base.Libc.strptime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
strptime([format], timestr)
\end{minted}

Parse a formatted time string into a \texttt{TmStruct} giving the seconds, minute, hour, date, etc. Supported formats are the same as those in the standard C library. On some platforms, timezones will not be parsed correctly. If the result of this function will be passed to \texttt{time} to convert it to seconds since the epoch, the \texttt{isdst} field should be filled in manually. Setting it to \texttt{-1} will tell the C library to use the current system settings to determine the timezone.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L201-L210}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12094049763760222314}{} 
\hyperlink{12094049763760222314}{\texttt{Base.Libc.TmStruct}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
TmStruct([seconds])
\end{minted}

Convert a number of seconds since the epoch to broken-down format, with fields \texttt{sec}, \texttt{min}, \texttt{hour}, \texttt{mday}, \texttt{month}, \texttt{year}, \texttt{wday}, \texttt{yday}, and \texttt{isdst}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L148-L153}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17297724195103628361}{} 
\hyperlink{17297724195103628361}{\texttt{Base.Libc.flush\_cstdio}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
flush_cstdio()
\end{minted}

Flushes the C \texttt{stdout} and \texttt{stderr} streams (which may have been written to by external C code).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L105-L109}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8521588756986761846}{} 
\hyperlink{8521588756986761846}{\texttt{Base.Libc.systemsleep}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
systemsleep(s::Real)
\end{minted}

Suspends execution for \texttt{s} seconds. This function does not yield to Julia{\textquotesingle}s scheduler and therefore blocks the Julia thread that it is running on for the duration of the sleep time.

See also: \hyperlink{3231475347583891391}{\texttt{sleep}}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L125-L133}{\texttt{source}}


\end{adjustwidth}

\hypertarget{6978578663907728721}{}


\chapter{堆栈跟踪}


\hypertarget{16824886840215699957}{} 
\hyperlink{16824886840215699957}{\texttt{Base.StackTraces.StackFrame}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
StackFrame
\end{minted}

Stack information representing execution context, with the following fields:

\begin{itemize}
\item \texttt{func::Symbol}

The name of the function containing the execution context.


\item \texttt{linfo::Union\{Core.MethodInstance, CodeInfo, Nothing\}}

The MethodInstance containing the execution context (if it could be found).


\item \texttt{file::Symbol}

The path to the file containing the execution context.


\item \texttt{line::Int}

The line number in the file containing the execution context.


\item \texttt{from\_c::Bool}

True if the code is from C.


\item \texttt{inlined::Bool}

True if the code is from an inlined frame.


\item \texttt{pointer::UInt64}

Representation of the pointer to the execution context as returned by \texttt{backtrace}.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stacktraces.jl#L14-L47}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12289172590874430030}{} 
\hyperlink{12289172590874430030}{\texttt{Base.StackTraces.StackTrace}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
StackTrace
\end{minted}

An alias for \texttt{Vector\{StackFrame\}} provided for convenience; returned by calls to \texttt{stacktrace}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stacktraces.jl#L68-L73}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11964270650763140298}{} 
\hyperlink{11964270650763140298}{\texttt{Base.StackTraces.stacktrace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stacktrace([trace::Vector{Ptr{Cvoid}},] [c_funcs::Bool=false]) -> StackTrace
\end{minted}

Returns a stack trace in the form of a vector of \texttt{StackFrame}s. (By default stacktrace doesn{\textquotesingle}t return C functions, but this can be enabled.) When called without specifying a trace, \texttt{stacktrace} first calls \texttt{backtrace}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stacktraces.jl#L153-L159}{\texttt{source}}


\end{adjustwidth}

\texttt{Base.StackTraces} 中以下方法和类型不会被导出，需要显式调用，例如 \texttt{StackTraces.lookup(ptr)}。


\hypertarget{1451426077045795515}{} 
\hyperlink{1451426077045795515}{\texttt{Base.StackTraces.lookup}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lookup(pointer::Ptr{Cvoid}) -> Vector{StackFrame}
\end{minted}

Given a pointer to an execution context (usually generated by a call to \texttt{backtrace}), looks up stack frame context information. Returns an array of frame information for all functions inlined at that point, innermost function first.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stacktraces.jl#L99-L105}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11320665145957459671}{} 
\hyperlink{11320665145957459671}{\texttt{Base.StackTraces.remove\_frames!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
remove_frames!(stack::StackTrace, name::Symbol)
\end{minted}

Takes a \texttt{StackTrace} (a vector of \texttt{StackFrames}) and a function name (a \texttt{Symbol}) and removes the \texttt{StackFrame} specified by the function name from the \texttt{StackTrace} (also removing all frames above the specified function). Primarily used to remove \texttt{StackTraces} functions from the \texttt{StackTrace} prior to returning it.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stacktraces.jl#L182-L189}{\texttt{source}}



\begin{lstlisting}
remove_frames!(stack::StackTrace, m::Module)
\end{lstlisting}

Returns the \texttt{StackTrace} with all \texttt{StackFrame}s from the provided \texttt{Module} removed.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stacktraces.jl#L200-L204}{\texttt{source}}


\end{adjustwidth}

\hypertarget{13225358784905663355}{}


\chapter{SIMD 支持}



\texttt{VecElement\{T\}} 类型是为了构建 SIMD 运算符的库。实际使用中要求使用 \texttt{llvmcall}。类型按下文定义：




\begin{minted}{julia}
struct VecElement{T}
    value::T
end
\end{minted}



It has a special compilation rule: a homogeneous tuple of \texttt{VecElement\{T\}} maps to an LLVM \texttt{vector} type when \texttt{T} is a primitive bits type.



使用 \texttt{-O3} 参数时，编译器 \emph{可能} 自动为这样的元组向量化运算符。 例如接下来的程序，使用 \texttt{julia -O3} 编译，在x86系统中会生成两个 SIMD 附加指令（\texttt{addps}）：




\begin{minted}{julia}
const m128 = NTuple{4,VecElement{Float32}}

function add(a::m128, b::m128)
    (VecElement(a[1].value+b[1].value),
     VecElement(a[2].value+b[2].value),
     VecElement(a[3].value+b[3].value),
     VecElement(a[4].value+b[4].value))
end

triple(c::m128) = add(add(c,c),c)

code_native(triple,(m128,))
\end{minted}



然而，因为无法依靠自动向量化，以后将主要通过使用基于 \texttt{llvmcall} 的库来提供 SIMD 支持。



\part{Standard Library}


\hypertarget{11756231791819393325}{}


\chapter{Base64}


\hypertarget{6529833673026929543}{} 
\hyperlink{6529833673026929543}{\texttt{Base64.Base64}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base64
\end{minted}

Functionality for base-64 encoded strings and IO.



\end{adjustwidth}
\hypertarget{3718432815614240925}{} 
\hyperlink{3718432815614240925}{\texttt{Base64.Base64EncodePipe}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base64EncodePipe(ostream)
\end{minted}

Return a new write-only I/O stream, which converts any bytes written to it into base64-encoded ASCII bytes written to \texttt{ostream}.  Calling \hyperlink{5331333469799487255}{\texttt{close}} on the \texttt{Base64EncodePipe} stream is necessary to complete the encoding (but does not close \texttt{ostream}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer();

julia> iob64_encode = Base64EncodePipe(io);

julia> write(iob64_encode, "Hello!")
6

julia> close(iob64_encode);

julia> str = String(take!(io))
"SGVsbG8h"

julia> String(base64decode(str))
"Hello!"
\end{minted}



\end{adjustwidth}
\hypertarget{1446212874874362397}{} 
\hyperlink{1446212874874362397}{\texttt{Base64.base64encode}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
base64encode(writefunc, args...; context=nothing)
base64encode(args...; context=nothing)
\end{minted}

Given a \hyperlink{16947913578760238729}{\texttt{write}}-like function \texttt{writefunc}, which takes an I/O stream as its first argument, \texttt{base64encode(writefunc, args...)} calls \texttt{writefunc} to write \texttt{args...} to a base64-encoded string, and returns the string. \texttt{base64encode(args...)} is equivalent to \texttt{base64encode(write, args...)}: it converts its arguments into bytes using the standard \hyperlink{16947913578760238729}{\texttt{write}} functions and returns the base64-encoded string.

The optional keyword argument \texttt{context} can be set to \texttt{:key=>value} pair or an \texttt{IO} or \hyperlink{13454403377667762339}{\texttt{IOContext}} object whose attributes are used for the I/O stream passed to \texttt{writefunc} or \texttt{write}.

See also \hyperlink{7809304046524048078}{\texttt{base64decode}}.



\end{adjustwidth}
\hypertarget{3379294475433655298}{} 
\hyperlink{3379294475433655298}{\texttt{Base64.Base64DecodePipe}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base64DecodePipe(istream)
\end{minted}

Return a new read-only I/O stream, which decodes base64-encoded data read from \texttt{istream}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer();

julia> iob64_decode = Base64DecodePipe(io);

julia> write(io, "SGVsbG8h")
8

julia> seekstart(io);

julia> String(read(iob64_decode))
"Hello!"
\end{minted}



\end{adjustwidth}
\hypertarget{7809304046524048078}{} 
\hyperlink{7809304046524048078}{\texttt{Base64.base64decode}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
base64decode(string)
\end{minted}

Decode the base64-encoded \texttt{string} and returns a \texttt{Vector\{UInt8\}} of the decoded bytes.

See also \hyperlink{1446212874874362397}{\texttt{base64encode}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> b = base64decode("SGVsbG8h")
6-element Array{UInt8,1}:
 0x48
 0x65
 0x6c
 0x6c
 0x6f
 0x21

julia> String(b)
"Hello!"
\end{minted}



\end{adjustwidth}
\hypertarget{17279723834582920486}{} 
\hyperlink{17279723834582920486}{\texttt{Base64.stringmime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stringmime(mime, x; context=nothing)
\end{minted}

Returns an \texttt{AbstractString} containing the representation of \texttt{x} in the requested \texttt{mime} type. This is similar to \hyperlink{13076889230390082034}{\texttt{repr(mime, x)}} except that binary data is base64-encoded as an ASCII string.

The optional keyword argument \texttt{context} can be set to \texttt{:key=>value} pair or an \texttt{IO} or \hyperlink{13454403377667762339}{\texttt{IOContext}} object whose attributes are used for the I/O stream passed to \hyperlink{14071376285304310153}{\texttt{show}}.



\end{adjustwidth}

\hypertarget{2465264826987872946}{}


\chapter{CRC32c}


\hypertarget{8058568265327059376}{} 
\hyperlink{8058568265327059376}{\texttt{CRC32c.crc32c}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
crc32c(data, crc::UInt32=0x00000000)
\end{minted}

Compute the CRC-32c checksum of the given \texttt{data}, which can be an \texttt{Array\{UInt8\}}, a contiguous subarray thereof, or a \texttt{String}.  Optionally, you can pass a starting \texttt{crc} integer to be mixed in with the checksum.  The \texttt{crc} parameter can be used to compute a checksum on data divided into chunks: performing \texttt{crc32c(data2, crc32c(data1))} is equivalent to the checksum of \texttt{[data1; data2]}. (Technically, a little-endian checksum is computed.)

There is also a method \texttt{crc32c(io, nb, crc)} to checksum \texttt{nb} bytes from a stream \texttt{io}, or \texttt{crc32c(io, crc)} to checksum all the remaining bytes. Hence you can do \hyperlink{300818094931158296}{\texttt{open(crc32c, filename)}} to checksum an entire file, or \texttt{crc32c(seekstart(buf))} to checksum an \hyperlink{15789326112236459498}{\texttt{IOBuffer}} without calling \hyperlink{4963355246106153560}{\texttt{take!}}.

For a \texttt{String}, note that the result is specific to the UTF-8 encoding (a different checksum would be obtained from a different Unicode encoding). To checksum an \texttt{a::Array} of some other bitstype, you can do \texttt{crc32c(reinterpret(UInt8,a))}, but note that the result may be endian-dependent.



\end{adjustwidth}
\hypertarget{2947862938473710782}{} 
\hyperlink{2947862938473710782}{\texttt{CRC32c.crc32c}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
crc32c(io::IO, [nb::Integer,] crc::UInt32=0x00000000)
\end{minted}

Read up to \texttt{nb} bytes from \texttt{io} and return the CRC-32c checksum, optionally mixed with a starting \texttt{crc} integer.  If \texttt{nb} is not supplied, then \texttt{io} will be read until the end of the stream.



\end{adjustwidth}

\hypertarget{12670537780554709073}{}


\chapter{日期}





\texttt{Dates} 模块提供了两种类型来处理日期：\hyperlink{4488183467971164548}{\texttt{Date}} 和 \hyperlink{17572689933274889838}{\texttt{DateTime}}，分别精确到日和毫秒；两者都是抽象类型 \hyperlink{4438614350756187528}{\texttt{TimeType}} 的子类型。区分类型的动机很简单：不必处理更高精度所带来的复杂性时，一些操作在代码和思维推理上都更加简单。例如，由于 \hyperlink{4488183467971164548}{\texttt{Date}} 类型仅精确到日（即没有时、分或秒），因此避免了时区、夏令时和闰秒等不必要的通常考虑。



Both \hyperlink{4488183467971164548}{\texttt{Date}} and \hyperlink{17572689933274889838}{\texttt{DateTime}} are basically immutable \hyperlink{7720564657383125058}{\texttt{Int64}} wrappers. The single \texttt{instant} field of either type is actually a \texttt{UTInstant\{P\}} type, which represents a continuously increasing machine timeline based on the UT second \footnotemark[1]. The \hyperlink{17572689933274889838}{\texttt{DateTime}} type is not aware of time zones (\emph{naive}, in Python parlance), analogous to a \emph{LocalDateTime} in Java 8. Additional time zone functionality can be added through the \href{https://github.com/JuliaTime/TimeZones.jl/}{TimeZones.jl package}, which compiles the \href{http://www.iana.org/time-zones}{IANA time zone database}. Both \hyperlink{4488183467971164548}{\texttt{Date}} and \hyperlink{17572689933274889838}{\texttt{DateTime}} are based on the \href{https://en.wikipedia.org/wiki/ISO\_8601}{ISO 8601} standard, which follows the proleptic Gregorian calendar. One note is that the ISO 8601 standard is particular about BC/BCE dates. In general, the last day of the BC/BCE era, 1-12-31 BC/BCE, was followed by 1-1-1 AD/CE, thus no year zero exists. The ISO standard, however, states that 1 BC/BCE is year zero, so \texttt{0000-12-31} is the day before \texttt{0001-01-01}, and year \texttt{-0001} (yes, negative one for the year) is 2 BC/BCE, year \texttt{-0002} is 3 BC/BCE, etc.



\footnotetext[1]{The notion of the UT second is actually quite fundamental. There are basically two different notions of time generally accepted, one based on the physical rotation of the earth (one full rotation = 1 day), the other based on the SI second (a fixed, constant value). These are radically different! Think about it, a {\textquotedbl}UT second{\textquotedbl}, as defined relative to the rotation of the earth, may have a different absolute length depending on the day! Anyway, the fact that \hyperlink{4488183467971164548}{\texttt{Date}} and \hyperlink{17572689933274889838}{\texttt{DateTime}} are based on UT seconds is a simplifying, yet honest assumption so that things like leap seconds and all their complexity can be avoided. This basis of time is formally called \href{https://en.wikipedia.org/wiki/Universal\_Time}{UT} or UT1. Basing types on the UT second basically means that every minute has 60 seconds and every day has 24 hours and leads to more natural calculations when working with calendar dates.

}


\hypertarget{5490460475085720426}{}


\section{构造函数}



\hyperlink{4488183467971164548}{\texttt{Date}} 和 \hyperlink{17572689933274889838}{\texttt{DateTime}} 类型可以通过整数或 \hyperlink{17624028548543163266}{\texttt{Period}} 类型，解析，或调整器来构造（稍后会详细介绍）：




\begin{minted}{jlcon}
julia> DateTime(2013)
2013-01-01T00:00:00

julia> DateTime(2013,7)
2013-07-01T00:00:00

julia> DateTime(2013,7,1)
2013-07-01T00:00:00

julia> DateTime(2013,7,1,12)
2013-07-01T12:00:00

julia> DateTime(2013,7,1,12,30)
2013-07-01T12:30:00

julia> DateTime(2013,7,1,12,30,59)
2013-07-01T12:30:59

julia> DateTime(2013,7,1,12,30,59,1)
2013-07-01T12:30:59.001

julia> Date(2013)
2013-01-01

julia> Date(2013,7)
2013-07-01

julia> Date(2013,7,1)
2013-07-01

julia> Date(Dates.Year(2013),Dates.Month(7),Dates.Day(1))
2013-07-01

julia> Date(Dates.Month(7),Dates.Year(2013))
2013-07-01
\end{minted}



\hyperlink{4488183467971164548}{\texttt{Date}} or \hyperlink{17572689933274889838}{\texttt{DateTime}} parsing is accomplished by the use of format strings. Format strings work by the notion of defining \emph{delimited} or \emph{fixed-width} {\textquotedbl}slots{\textquotedbl} that contain a period to parse and passing the text to parse and format string to a \hyperlink{4488183467971164548}{\texttt{Date}} or \hyperlink{17572689933274889838}{\texttt{DateTime}} constructor, of the form \texttt{Date({\textquotedbl}2015-01-01{\textquotedbl},{\textquotedbl}y-m-d{\textquotedbl})} or \texttt{DateTime({\textquotedbl}20150101{\textquotedbl},{\textquotedbl}yyyymmdd{\textquotedbl})}.



Delimited slots are marked by specifying the delimiter the parser should expect between two subsequent periods; so \texttt{{\textquotedbl}y-m-d{\textquotedbl}} lets the parser know that between the first and second slots in a date string like \texttt{{\textquotedbl}2014-07-16{\textquotedbl}}, it should find the \texttt{-} character. The \texttt{y}, \texttt{m}, and \texttt{d} characters let the parser know which periods to parse in each slot.



Fixed-width slots are specified by repeating the period character the number of times corresponding to the width with no delimiter between characters. So \texttt{{\textquotedbl}yyyymmdd{\textquotedbl}} would correspond to a date string like \texttt{{\textquotedbl}20140716{\textquotedbl}}. The parser distinguishes a fixed-width slot by the absence of a delimiter, noting the transition \texttt{{\textquotedbl}yyyymm{\textquotedbl}} from one period character to the next.



Support for text-form month parsing is also supported through the \texttt{u} and \texttt{U} characters, for abbreviated and full-length month names, respectively. By default, only English month names are supported, so \texttt{u} corresponds to {\textquotedbl}Jan{\textquotedbl}, {\textquotedbl}Feb{\textquotedbl}, {\textquotedbl}Mar{\textquotedbl}, etc. And \texttt{U} corresponds to {\textquotedbl}January{\textquotedbl}, {\textquotedbl}February{\textquotedbl}, {\textquotedbl}March{\textquotedbl}, etc. Similar to other name=>value mapping functions \hyperlink{2440842966718954493}{\texttt{dayname}} and \hyperlink{16585759639636493546}{\texttt{monthname}}, custom locales can be loaded by passing in the \texttt{locale=>Dict\{String,Int\}} mapping to the \texttt{MONTHTOVALUEABBR} and \texttt{MONTHTOVALUE} dicts for abbreviated and full-name month names, respectively.



One note on parsing performance: using the \texttt{Date(date\_string,format\_string)} function is fine if only called a few times. If there are many similarly formatted date strings to parse however, it is much more efficient to first create a \hyperlink{18093459443158853001}{\texttt{Dates.DateFormat}}, and pass it instead of a raw format string.




\begin{minted}{jlcon}
julia> df = DateFormat("y-m-d");

julia> dt = Date("2015-01-01",df)
2015-01-01

julia> dt2 = Date("2015-01-02",df)
2015-01-02
\end{minted}



You can also use the \texttt{dateformat{\textquotedbl}{\textquotedbl}} string macro. This macro creates the \texttt{DateFormat} object once when the macro is expanded and uses the same \texttt{DateFormat} object even if a code snippet is run multiple times.




\begin{minted}{jlcon}
julia> for i = 1:10^5
           Date("2015-01-01", dateformat"y-m-d")
       end
\end{minted}



A full suite of parsing and formatting tests and examples is available in \href{https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/io.jl}{\texttt{stdlib/Dates/test/io.jl}}.



\hypertarget{5885257312656473374}{}


\section{持续时间/比较}



Finding the length of time between two \hyperlink{4488183467971164548}{\texttt{Date}} or \hyperlink{17572689933274889838}{\texttt{DateTime}} is straightforward given their underlying representation as \texttt{UTInstant\{Day\}} and \texttt{UTInstant\{Millisecond\}}, respectively. The difference between \hyperlink{4488183467971164548}{\texttt{Date}} is returned in the number of \hyperlink{13217464551942182596}{\texttt{Day}}, and \hyperlink{17572689933274889838}{\texttt{DateTime}} in the number of \hyperlink{9366634148855607364}{\texttt{Millisecond}}. Similarly, comparing \hyperlink{4438614350756187528}{\texttt{TimeType}} is a simple matter of comparing the underlying machine instants (which in turn compares the internal \hyperlink{7720564657383125058}{\texttt{Int64}} values).




\begin{minted}{jlcon}
julia> dt = Date(2012,2,29)
2012-02-29

julia> dt2 = Date(2000,2,1)
2000-02-01

julia> dump(dt)
Date
  instant: Dates.UTInstant{Day}
    periods: Day
      value: Int64 734562

julia> dump(dt2)
Date
  instant: Dates.UTInstant{Day}
    periods: Day
      value: Int64 730151

julia> dt > dt2
true

julia> dt != dt2
true

julia> dt + dt2
ERROR: MethodError: no method matching +(::Date, ::Date)
[...]

julia> dt * dt2
ERROR: MethodError: no method matching *(::Date, ::Date)
[...]

julia> dt / dt2
ERROR: MethodError: no method matching /(::Date, ::Date)

julia> dt - dt2
4411 days

julia> dt2 - dt
-4411 days

julia> dt = DateTime(2012,2,29)
2012-02-29T00:00:00

julia> dt2 = DateTime(2000,2,1)
2000-02-01T00:00:00

julia> dt - dt2
381110400000 milliseconds
\end{minted}



\hypertarget{1797872614315202652}{}


\section{访问函数}



Because the \hyperlink{4488183467971164548}{\texttt{Date}} and \hyperlink{17572689933274889838}{\texttt{DateTime}} types are stored as single \hyperlink{7720564657383125058}{\texttt{Int64}} values, date parts or fields can be retrieved through accessor functions. The lowercase accessors return the field as an integer:




\begin{minted}{jlcon}
julia> t = Date(2014, 1, 31)
2014-01-31

julia> Dates.year(t)
2014

julia> Dates.month(t)
1

julia> Dates.week(t)
5

julia> Dates.day(t)
31
\end{minted}



当首字母大写时会返回对应 \hyperlink{17624028548543163266}{\texttt{Period}} 类型的相同值：




\begin{minted}{jlcon}
julia> Dates.Year(t)
2014 years

julia> Dates.Day(t)
31 days
\end{minted}



Compound methods are provided, as they provide a measure of efficiency if multiple fields are needed at the same time:




\begin{minted}{jlcon}
julia> Dates.yearmonth(t)
(2014, 1)

julia> Dates.monthday(t)
(1, 31)

julia> Dates.yearmonthday(t)
(2014, 1, 31)
\end{minted}



One may also access the underlying \texttt{UTInstant} or integer value:




\begin{minted}{jlcon}
julia> dump(t)
Date
  instant: Dates.UTInstant{Day}
    periods: Day
      value: Int64 735264

julia> t.instant
Dates.UTInstant{Day}(Day(735264))

julia> Dates.value(t)
735264
\end{minted}



\hypertarget{6547083286508545671}{}


\section{查询函数}



Query functions provide calendrical information about a \hyperlink{4438614350756187528}{\texttt{TimeType}}. They include information about the day of the week:




\begin{minted}{jlcon}
julia> t = Date(2014, 1, 31)
2014-01-31

julia> Dates.dayofweek(t)
5

julia> Dates.dayname(t)
"Friday"

julia> Dates.dayofweekofmonth(t) # 5th Friday of January
5
\end{minted}



一年中的月份：




\begin{minted}{jlcon}
julia> Dates.monthname(t)
"January"

julia> Dates.daysinmonth(t)
31
\end{minted}



As well as information about the \hyperlink{4438614350756187528}{\texttt{TimeType}}{\textquotesingle}s year and quarter:




\begin{minted}{jlcon}
julia> Dates.isleapyear(t)
false

julia> Dates.dayofyear(t)
31

julia> Dates.quarterofyear(t)
1

julia> Dates.dayofquarter(t)
31
\end{minted}



The \hyperlink{2440842966718954493}{\texttt{dayname}} and \hyperlink{16585759639636493546}{\texttt{monthname}} methods can also take an optional \texttt{locale} keyword that can be used to return the name of the day or month of the year for other languages/locales. There are also versions of these functions returning the abbreviated names, namely \hyperlink{18198970391837299875}{\texttt{dayabbr}} and \hyperlink{12804940912944832895}{\texttt{monthabbr}}. First the mapping is loaded into the \texttt{LOCALES} variable:




\begin{minted}{jlcon}
julia> french_months = ["janvier", "février", "mars", "avril", "mai", "juin",
                        "juillet", "août", "septembre", "octobre", "novembre", "décembre"];

julia> french_monts_abbrev = ["janv","févr","mars","avril","mai","juin",
                              "juil","août","sept","oct","nov","déc"];

julia> french_days = ["lundi","mardi","mercredi","jeudi","vendredi","samedi","dimanche"];

julia> Dates.LOCALES["french"] = Dates.DateLocale(french_months, french_monts_abbrev, french_days, [""]);
\end{minted}



The above mentioned functions can then be used to perform the queries:




\begin{minted}{jlcon}
julia> Dates.dayname(t;locale="french")
"vendredi"

julia> Dates.monthname(t;locale="french")
"janvier"

julia> Dates.monthabbr(t;locale="french")
"janv"
\end{minted}



自从缩写版本的 \texttt{days} 函数不加载之后，试图访问函数 \texttt{dayabbr} 将导致一个错误。




\begin{minted}{jlcon}
julia> Dates.dayabbr(t;locale="french")
ERROR: BoundsError: attempt to access 1-element Array{String,1} at index [5]
Stacktrace:
[...]
\end{minted}



\hypertarget{552552737851946510}{}


\section{TimeType 时间运算}



It{\textquotesingle}s good practice when using any language/date framework to be familiar with how date-period arithmetic is handled as there are some \href{https://codeblog.jonskeet.uk/2010/12/01/the-joys-of-date-time-arithmetic/}{tricky issues} to deal with (though much less so for day-precision types).



The \texttt{Dates} module approach tries to follow the simple principle of trying to change as little as possible when doing \hyperlink{17624028548543163266}{\texttt{Period}} arithmetic. This approach is also often known as \emph{calendrical} arithmetic or what you would probably guess if someone were to ask you the same calculation in a conversation. Why all the fuss about this? Let{\textquotesingle}s take a classic example: add 1 month to January 31st, 2014. What{\textquotesingle}s the answer? Javascript will say \href{https://markhneedham.com/blog/2009/01/07/javascript-add-a-month-to-a-date/}{March 3} (assumes 31 days). PHP says \href{https://stackoverflow.com/questions/5760262/php-adding-months-to-a-date-while-not-exceeding-the-last-day-of-the-month}{March 2} (assumes 30 days). The fact is, there is no right answer. In the \texttt{Dates} module, it gives the result of February 28th. How does it figure that out? I like to think of the classic 7-7-7 gambling game in casinos.



Now just imagine that instead of 7-7-7, the slots are Year-Month-Day, or in our example, 2014-01-31. When you ask to add 1 month to this date, the month slot is incremented, so now we have 2014-02-31. Then the day number is checked if it is greater than the last valid day of the new month; if it is (as in the case above), the day number is adjusted down to the last valid day (28). What are the ramifications with this approach? Go ahead and add another month to our date, \texttt{2014-02-28 + Month(1) == 2014-03-28}. What? Were you expecting the last day of March? Nope, sorry, remember the 7-7-7 slots. As few slots as possible are going to change, so we first increment the month slot by 1, 2014-03-28, and boom, we{\textquotesingle}re done because that{\textquotesingle}s a valid date. On the other hand, if we were to add 2 months to our original date, 2014-01-31, then we end up with 2014-03-31, as expected. The other ramification of this approach is a loss in associativity when a specific ordering is forced (i.e. adding things in different orders results in different outcomes). For example:




\begin{minted}{jlcon}
julia> (Date(2014,1,29)+Dates.Day(1)) + Dates.Month(1)
2014-02-28

julia> (Date(2014,1,29)+Dates.Month(1)) + Dates.Day(1)
2014-03-01
\end{minted}



What{\textquotesingle}s going on there? In the first line, we{\textquotesingle}re adding 1 day to January 29th, which results in 2014-01-30; then we add 1 month, so we get 2014-02-30, which then adjusts down to 2014-02-28. In the second example, we add 1 month \emph{first}, where we get 2014-02-29, which adjusts down to 2014-02-28, and \emph{then} add 1 day, which results in 2014-03-01. One design principle that helps in this case is that, in the presence of multiple Periods, the operations will be ordered by the Periods{\textquotesingle} \emph{types}, not their value or positional order; this means \texttt{Year} will always be added first, then \texttt{Month}, then \texttt{Week}, etc. Hence the following \emph{does} result in associativity and Just Works:




\begin{minted}{jlcon}
julia> Date(2014,1,29) + Dates.Day(1) + Dates.Month(1)
2014-03-01

julia> Date(2014,1,29) + Dates.Month(1) + Dates.Day(1)
2014-03-01
\end{minted}



Tricky? Perhaps. What is an innocent \texttt{Dates} user to do? The bottom line is to be aware that explicitly forcing a certain associativity, when dealing with months, may lead to some unexpected results, but otherwise, everything should work as expected. Thankfully, that{\textquotesingle}s pretty much the extent of the odd cases in date-period arithmetic when dealing with time in UT (avoiding the {\textquotedbl}joys{\textquotedbl} of dealing with daylight savings, leap seconds, etc.).



另外，所有时间运算都可以与范围一起使用：




\begin{minted}{jlcon}
julia> dr = Date(2014,1,29):Day(1):Date(2014,2,3)
Date("2014-01-29"):Day(1):Date("2014-02-03")

julia> collect(dr)
6-element Array{Date,1}:
 2014-01-29
 2014-01-30
 2014-01-31
 2014-02-01
 2014-02-02
 2014-02-03

julia> dr = Date(2014,1,29):Dates.Month(1):Date(2014,07,29)
Date("2014-01-29"):Month(1):Date("2014-07-29")

julia> collect(dr)
7-element Array{Date,1}:
 2014-01-29
 2014-02-28
 2014-03-29
 2014-04-29
 2014-05-29
 2014-06-29
 2014-07-29
\end{minted}



\hypertarget{16701273079523868506}{}


\section{调整器函数}



As convenient as date-period arithmetic is, often the kinds of calculations needed on dates take on a \emph{calendrical} or \emph{temporal} nature rather than a fixed number of periods. Holidays are a perfect example; most follow rules such as {\textquotedbl}Memorial Day = Last Monday of May{\textquotedbl}, or {\textquotedbl}Thanksgiving = 4th Thursday of November{\textquotedbl}. These kinds of temporal expressions deal with rules relative to the calendar, like first or last of the month, next Tuesday, or the first and third Wednesdays, etc.



The \texttt{Dates} module provides the \emph{adjuster} API through several convenient methods that aid in simply and succinctly expressing temporal rules. The first group of adjuster methods deal with the first and last of weeks, months, quarters, and years. They each take a single \hyperlink{4438614350756187528}{\texttt{TimeType}} as input and return or \emph{adjust to} the first or last of the desired period relative to the input.




\begin{minted}{jlcon}
julia> Dates.firstdayofweek(Date(2014,7,16)) # Adjusts the input to the Monday of the input's week
2014-07-14

julia> Dates.lastdayofmonth(Date(2014,7,16)) # Adjusts to the last day of the input's month
2014-07-31

julia> Dates.lastdayofquarter(Date(2014,7,16)) # Adjusts to the last day of the input's quarter
2014-09-30
\end{minted}



The next two higher-order methods, \hyperlink{9410879287453023176}{\texttt{tonext}}, and \hyperlink{5295237512711135506}{\texttt{toprev}}, generalize working with temporal expressions by taking a \texttt{DateFunction} as first argument, along with a starting \hyperlink{4438614350756187528}{\texttt{TimeType}}. A \texttt{DateFunction} is just a function, usually anonymous, that takes a single \hyperlink{4438614350756187528}{\texttt{TimeType}} as input and returns a \hyperlink{46725311238864537}{\texttt{Bool}}, \texttt{true} indicating a satisfied adjustment criterion. For example:




\begin{minted}{jlcon}
julia> istuesday = x->Dates.dayofweek(x) == Dates.Tuesday; # 当 x 是周二时返回 true

julia> Dates.tonext(istuesday, Date(2014,7,13)) # 2014-07-13 是周日
2014-07-15

julia> Dates.tonext(Date(2014,7,13), Dates.Tuesday) # 星期调整的便捷方法
2014-07-15
\end{minted}



This is useful with the do-block syntax for more complex temporal expressions:




\begin{minted}{jlcon}
julia> Dates.tonext(Date(2014,7,13)) do x
           # 在十一月的第四个星期四——感恩节那天返回 true
           Dates.dayofweek(x) == Dates.Thursday &&
           Dates.dayofweekofmonth(x) == 4 &&
           Dates.month(x) == Dates.November
       end
2014-11-27
\end{minted}



The \hyperlink{11445961893478569145}{\texttt{Base.filter}} method can be used to obtain all valid dates/moments in a specified range:




\begin{minted}{jlcon}
# Pittsburgh street cleaning; Every 2nd Tuesday from April to November
# Date range from January 1st, 2014 to January 1st, 2015
julia> dr = Dates.Date(2014):Day(1):Dates.Date(2015);

julia> filter(dr) do x
           Dates.dayofweek(x) == Dates.Tue &&
           Dates.April <= Dates.month(x) <= Dates.Nov &&
           Dates.dayofweekofmonth(x) == 2
       end
8-element Array{Date,1}:
 2014-04-08
 2014-05-13
 2014-06-10
 2014-07-08
 2014-08-12
 2014-09-09
 2014-10-14
 2014-11-11
\end{minted}



Additional examples and tests are available in \href{https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/adjusters.jl}{\texttt{stdlib/Dates/test/adjusters.jl}}.



\hypertarget{17903801457919484645}{}


\section{时间段类型}



Periods are a human view of discrete, sometimes irregular durations of time. Consider 1 month; it could represent, in days, a value of 28, 29, 30, or 31 depending on the year and month context. Or a year could represent 365 or 366 days in the case of a leap year. \hyperlink{17624028548543163266}{\texttt{Period}} types are simple \hyperlink{7720564657383125058}{\texttt{Int64}} wrappers and are constructed by wrapping any \texttt{Int64} convertible type, i.e. \texttt{Year(1)} or \texttt{Month(3.0)}. Arithmetic between \hyperlink{17624028548543163266}{\texttt{Period}} of the same type behave like integers, and limited \texttt{Period-Real} arithmetic is available.  You can extract the underlying integer with \hyperlink{6471383377711200525}{\texttt{Dates.value}}.




\begin{minted}{jlcon}
julia> y1 = Dates.Year(1)
1 year

julia> y2 = Dates.Year(2)
2 years

julia> y3 = Dates.Year(10)
10 years

julia> y1 + y2
3 years

julia> div(y3,y2)
5

julia> y3 - y2
8 years

julia> y3 % y2
0 years

julia> div(y3,3) # mirrors integer division
3 years

julia> Dates.value(Dates.Millisecond(10))
10
\end{minted}



\hypertarget{2131702258451006422}{}


\section{取整}



\hyperlink{4488183467971164548}{\texttt{Date}} and \hyperlink{17572689933274889838}{\texttt{DateTime}} values can be rounded to a specified resolution (e.g., 1 month or 15 minutes) with \hyperlink{11115257331910840693}{\texttt{floor}}, \hyperlink{10519509038312853061}{\texttt{ceil}}, or \hyperlink{12930779325193350739}{\texttt{round}}:




\begin{minted}{jlcon}
julia> floor(Date(1985, 8, 16), Dates.Month)
1985-08-01

julia> ceil(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))
2013-02-13T00:45:00

julia> round(DateTime(2016, 8, 6, 20, 15), Dates.Day)
2016-08-07T00:00:00
\end{minted}



Unlike the numeric \hyperlink{12930779325193350739}{\texttt{round}} method, which breaks ties toward the even number by default, the \hyperlink{4438614350756187528}{\texttt{TimeType}}\hyperlink{12930779325193350739}{\texttt{round}} method uses the \texttt{RoundNearestTiesUp} rounding mode. (It{\textquotesingle}s difficult to guess what breaking ties to nearest {\textquotedbl}even{\textquotedbl} \hyperlink{4438614350756187528}{\texttt{TimeType}} would entail.) Further details on the available \texttt{RoundingMode} s can be found in the \hyperlink{2504340439131318713}{API reference}.



Rounding should generally behave as expected, but there are a few cases in which the expected behaviour is not obvious.



\hypertarget{18235125897086797691}{}


\subsection{Rounding Epoch}



In many cases, the resolution specified for rounding (e.g., \texttt{Dates.Second(30)}) divides evenly into the next largest period (in this case, \texttt{Dates.Minute(1)}). But rounding behaviour in cases in which this is not true may lead to confusion. What is the expected result of rounding a \hyperlink{17572689933274889838}{\texttt{DateTime}} to the nearest 10 hours?




\begin{minted}{jlcon}
julia> round(DateTime(2016, 7, 17, 11, 55), Dates.Hour(10))
2016-07-17T12:00:00
\end{minted}



That may seem confusing, given that the hour (12) is not divisible by 10. The reason that \texttt{2016-07-17T12:00:00} was chosen is that it is 17,676,660 hours after \texttt{0000-01-01T00:00:00}, and 17,676,660 is divisible by 10.



As Julia \hyperlink{4488183467971164548}{\texttt{Date}} and \hyperlink{17572689933274889838}{\texttt{DateTime}} values are represented according to the ISO 8601 standard, \texttt{0000-01-01T00:00:00} was chosen as base (or {\textquotedbl}rounding epoch{\textquotedbl}) from which to begin the count of days (and milliseconds) used in rounding calculations. (Note that this differs slightly from Julia{\textquotesingle}s internal representation of \hyperlink{4488183467971164548}{\texttt{Date}} s using Rata Die notation; but since the ISO 8601 standard is most visible to the end user, \texttt{0000-01-01T00:00:00} was chosen as the rounding epoch instead of the \texttt{0000-12-31T00:00:00} used internally to minimize confusion.)



The only exception to the use of \texttt{0000-01-01T00:00:00} as the rounding epoch is when rounding to weeks. Rounding to the nearest week will always return a Monday (the first day of the week as specified by ISO 8601). For this reason, we use \texttt{0000-01-03T00:00:00} (the first day of the first week of year 0000, as defined by ISO 8601) as the base when rounding to a number of weeks.



Here is a related case in which the expected behaviour is not necessarily obvious: What happens when we round to the nearest \texttt{P(2)}, where \texttt{P} is a \hyperlink{17624028548543163266}{\texttt{Period}} type? In some cases (specifically, when \texttt{P <: Dates.TimePeriod}) the answer is clear:




\begin{minted}{jlcon}
julia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Hour(2))
2016-07-17T08:00:00

julia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Minute(2))
2016-07-17T08:56:00
\end{minted}



This seems obvious, because two of each of these periods still divides evenly into the next larger order period. But in the case of two months (which still divides evenly into one year), the answer may be surprising:




\begin{minted}{jlcon}
julia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Month(2))
2016-07-01T00:00:00
\end{minted}



Why round to the first day in July, even though it is month 7 (an odd number)? The key is that months are 1-indexed (the first month is assigned 1), unlike hours, minutes, seconds, and milliseconds (the first of which are assigned 0).



This means that rounding a \hyperlink{17572689933274889838}{\texttt{DateTime}} to an even multiple of seconds, minutes, hours, or years (because the ISO 8601 specification includes a year zero) will result in a \hyperlink{17572689933274889838}{\texttt{DateTime}} with an even value in that field, while rounding a \hyperlink{17572689933274889838}{\texttt{DateTime}} to an even multiple of months will result in the months field having an odd value. Because both months and years may contain an irregular number of days, whether rounding to an even number of days will result in an even value in the days field is uncertain.



See the \hyperlink{2504340439131318713}{API reference} for additional information on methods exported from the \texttt{Dates} module.



\hypertarget{14493106802066079367}{}


\chapter{API reference}



\hypertarget{16585603824908593588}{}


\section{日期和时间类型}


\hypertarget{17624028548543163266}{} 
\hyperlink{17624028548543163266}{\texttt{Dates.Period}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Period
Year
Month
Week
Day
Hour
Minute
Second
Millisecond
Microsecond
Nanosecond
\end{minted}

\texttt{Period} types represent discrete, human representations of time.



\end{adjustwidth}
\hypertarget{10034674628199158268}{} 
\hyperlink{10034674628199158268}{\texttt{Dates.CompoundPeriod}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
CompoundPeriod
\end{minted}

A \texttt{CompoundPeriod} is useful for expressing time periods that are not a fixed multiple of smaller periods. For example, {\textquotedbl}a year and a  day{\textquotedbl} is not a fixed number of days, but can be expressed using a \texttt{CompoundPeriod}. In fact, a \texttt{CompoundPeriod} is automatically generated by addition of different period types, e.g. \texttt{Year(1) + Day(1)} produces a \texttt{CompoundPeriod} result.



\end{adjustwidth}
\hypertarget{4529923194910083363}{} 
\hyperlink{4529923194910083363}{\texttt{Dates.Instant}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Instant
\end{minted}

\texttt{Instant} types represent integer-based, machine representations of time as continuous timelines starting from an epoch.



\end{adjustwidth}
\hypertarget{5087474460137130402}{} 
\hyperlink{5087474460137130402}{\texttt{Dates.UTInstant}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UTInstant{T}
\end{minted}

The \texttt{UTInstant} represents a machine timeline based on UT time (1 day = one revolution of the earth). The \texttt{T} is a \texttt{Period} parameter that indicates the resolution or precision of the instant.



\end{adjustwidth}
\hypertarget{4438614350756187528}{} 
\hyperlink{4438614350756187528}{\texttt{Dates.TimeType}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
TimeType
\end{minted}

\texttt{TimeType} types wrap \texttt{Instant} machine instances to provide human representations of the machine instant. \texttt{Time}, \texttt{DateTime} and \texttt{Date} are subtypes of \texttt{TimeType}.



\end{adjustwidth}
\hypertarget{17572689933274889838}{} 
\hyperlink{17572689933274889838}{\texttt{Dates.DateTime}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DateTime
\end{minted}

\texttt{DateTime} wraps a \texttt{UTInstant\{Millisecond\}} and interprets it according to the proleptic Gregorian calendar.



\end{adjustwidth}
\hypertarget{4488183467971164548}{} 
\hyperlink{4488183467971164548}{\texttt{Dates.Date}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Date
\end{minted}

\texttt{Date} wraps a \texttt{UTInstant\{Day\}} and interprets it according to the proleptic Gregorian calendar.



\end{adjustwidth}
\hypertarget{8861990744010508981}{} 
\hyperlink{8861990744010508981}{\texttt{Dates.Time}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Time
\end{minted}

\texttt{Time} wraps a \texttt{Nanosecond} and represents a specific moment in a 24-hour day.



\end{adjustwidth}

\hypertarget{9236894787070694841}{}


\section{日期函数}


\hypertarget{1328456258006961178}{} 
\hyperlink{1328456258006961178}{\texttt{Dates.DateTime}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DateTime(y, [m, d, h, mi, s, ms]) -> DateTime
\end{minted}

Construct a \texttt{DateTime} type by parts. Arguments must be convertible to \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{8234829693150521940}{} 
\hyperlink{8234829693150521940}{\texttt{Dates.DateTime}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DateTime(periods::Period...) -> DateTime
\end{minted}

Construct a \texttt{DateTime} type by \texttt{Period} type parts. Arguments may be in any order. DateTime parts not provided will default to the value of \texttt{Dates.default(period)}.



\end{adjustwidth}
\hypertarget{18390475731552157559}{} 
\hyperlink{18390475731552157559}{\texttt{Dates.DateTime}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DateTime(f::Function, y[, m, d, h, mi, s]; step=Day(1), limit=10000) -> DateTime
\end{minted}

Create a \texttt{DateTime} through the adjuster API. The starting point will be constructed from the provided \texttt{y, m, d...} arguments, and will be adjusted until \texttt{f::Function} returns \texttt{true}. The step size in adjusting can be provided manually through the \texttt{step} keyword. \texttt{limit} provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (in the case that \texttt{f::Function} is never satisfied).

\textbf{Examples}


\begin{minted}{jlcon}
julia> DateTime(dt -> Dates.second(dt) == 40, 2010, 10, 20, 10; step = Dates.Second(1))
2010-10-20T10:00:40

julia> DateTime(dt -> Dates.hour(dt) == 20, 2010, 10, 20, 10; step = Dates.Hour(1), limit = 5)
ERROR: ArgumentError: Adjustment limit reached: 5 iterations
Stacktrace:
[...]
\end{minted}



\end{adjustwidth}
\hypertarget{12066645755218970960}{} 
\hyperlink{12066645755218970960}{\texttt{Dates.DateTime}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DateTime(dt::Date) -> DateTime
\end{minted}

Convert a \texttt{Date} to a \texttt{DateTime}. The hour, minute, second, and millisecond parts of the new \texttt{DateTime} are assumed to be zero.



\end{adjustwidth}
\hypertarget{17944514963000811562}{} 
\hyperlink{17944514963000811562}{\texttt{Dates.DateTime}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DateTime(dt::AbstractString, format::AbstractString; locale="english") -> DateTime
\end{minted}

Construct a \texttt{DateTime} by parsing the \texttt{dt} date time string following the pattern given in the \texttt{format} string.

This method creates a \texttt{DateFormat} object each time it is called. If you are parsing many date time strings of the same format, consider creating a \hyperlink{18093459443158853001}{\texttt{DateFormat}} object once and using that as the second argument instead.



\end{adjustwidth}
\hypertarget{16940765638871841169}{} 
\hyperlink{16940765638871841169}{\texttt{Dates.format}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
format(dt::TimeType, format::AbstractString; locale="english") -> AbstractString
\end{minted}

Construct a string by using a \texttt{TimeType} object and applying the provided \texttt{format}. The following character codes can be used to construct the \texttt{format} string:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Code & Examples & Comment \\
\hline
\texttt{y} & 6 & Numeric year with a fixed width \\
\hline
\texttt{Y} & 1996 & Numeric year with a minimum width \\
\hline
\texttt{m} & 1, 12 & Numeric month with a minimum width \\
\hline
\texttt{u} & Jan & Month name shortened to 3-chars according to the \texttt{locale} \\
\hline
\texttt{U} & January & Full month name according to the \texttt{locale} keyword \\
\hline
\texttt{d} & 1, 31 & Day of the month with a minimum width \\
\hline
\texttt{H} & 0, 23 & Hour (24-hour clock) with a minimum width \\
\hline
\texttt{M} & 0, 59 & Minute with a minimum width \\
\hline
\texttt{S} & 0, 59 & Second with a minimum width \\
\hline
\texttt{s} & 000, 500 & Millisecond with a minimum width of 3 \\
\hline
\texttt{e} & Mon, Tue & Abbreviated days of the week \\
\hline
\texttt{E} & Monday & Full day of week name \\
\hline
\end{tabulary}

\end{table}

The number of sequential code characters indicate the width of the code. A format of \texttt{yyyy-mm} specifies that the code \texttt{y} should have a width of four while \texttt{m} a width of two. Codes that yield numeric digits have an associated mode: fixed-width or minimum-width. The fixed-width mode left-pads the value with zeros when it is shorter than the specified width and truncates the value when longer. Minimum-width mode works the same as fixed-width except that it does not truncate values longer than the width.

When creating a \texttt{format} you can use any non-code characters as a separator. For example to generate the string {\textquotedbl}1996-01-15T00:00:00{\textquotedbl} you could use \texttt{format}: {\textquotedbl}yyyy-mm-ddTHH:MM:SS{\textquotedbl}. Note that if you need to use a code character as a literal you can use the escape character backslash. The string {\textquotedbl}1996y01m{\textquotedbl} can be produced with the format {\textquotedbl}yyyy{\textbackslash}ymm{\textbackslash}m{\textquotedbl}.



\end{adjustwidth}
\hypertarget{18093459443158853001}{} 
\hyperlink{18093459443158853001}{\texttt{Dates.DateFormat}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DateFormat(format::AbstractString, locale="english") -> DateFormat
\end{minted}

Construct a date formatting object that can be used for parsing date strings or formatting a date object as a string. The following character codes can be used to construct the \texttt{format} string:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Code & Matches & Comment \\
\hline
\texttt{y} & 1996, 96 & Returns year of 1996, 0096 \\
\hline
\texttt{Y} & 1996, 96 & Returns year of 1996, 0096. Equivalent to \texttt{y} \\
\hline
\texttt{m} & 1, 01 & Matches 1 or 2-digit months \\
\hline
\texttt{u} & Jan & Matches abbreviated months according to the \texttt{locale} keyword \\
\hline
\texttt{U} & January & Matches full month names according to the \texttt{locale} keyword \\
\hline
\texttt{d} & 1, 01 & Matches 1 or 2-digit days \\
\hline
\texttt{H} & 00 & Matches hours (24-hour clock) \\
\hline
\texttt{I} & 00 & For outputting hours with 12-hour clock \\
\hline
\texttt{M} & 00 & Matches minutes \\
\hline
\texttt{S} & 00 & Matches seconds \\
\hline
\texttt{s} & .500 & Matches milliseconds \\
\hline
\texttt{e} & Mon, Tues & Matches abbreviated days of the week \\
\hline
\texttt{E} & Monday & Matches full name days of the week \\
\hline
\texttt{p} & AM & Matches AM/PM (case-insensitive) \\
\hline
\texttt{yyyymmdd} & 19960101 & Matches fixed-width year, month, and day \\
\hline
\end{tabulary}

\end{table}

Characters not listed above are normally treated as delimiters between date and time slots. For example a \texttt{dt} string of {\textquotedbl}1996-01-15T00:00:00.0{\textquotedbl} would have a \texttt{format} string like {\textquotedbl}y-m-dTH:M:S.s{\textquotedbl}. If you need to use a code character as a delimiter you can escape it using backslash. The date {\textquotedbl}1995y01m{\textquotedbl} would have the format {\textquotedbl}y{\textbackslash}ym{\textbackslash}m{\textquotedbl}.

Note that 12:00AM corresponds 00:00 (midnight), and 12:00PM corresponds to 12:00 (noon). When parsing a time with a \texttt{p} specifier, any hour (either \texttt{H} or \texttt{I}) is interpreted as as a 12-hour clock, so the \texttt{I} code is mainly useful for output.

Creating a DateFormat object is expensive. Whenever possible, create it once and use it many times or try the \texttt{dateformat{\textquotedbl}{\textquotedbl}} string macro. Using this macro creates the DateFormat object once at macro expansion time and reuses it later. see \hyperlink{10511139750795822255}{\texttt{@dateformat\_str}}.

See \hyperlink{17572689933274889838}{\texttt{DateTime}} and \hyperlink{16940765638871841169}{\texttt{format}} for how to use a DateFormat object to parse and write Date strings respectively.



\end{adjustwidth}
\hypertarget{10511139750795822255}{} 
\hyperlink{10511139750795822255}{\texttt{Dates.@dateformat\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dateformat"Y-m-d H:M:S"
\end{minted}

Create a \hyperlink{18093459443158853001}{\texttt{DateFormat}} object. Similar to \texttt{DateFormat({\textquotedbl}Y-m-d H:M:S{\textquotedbl})} but creates the DateFormat object once during macro expansion.

See \hyperlink{18093459443158853001}{\texttt{DateFormat}} for details about format specifiers.



\end{adjustwidth}
\hypertarget{3209456936474118206}{} 
\hyperlink{3209456936474118206}{\texttt{Dates.DateTime}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DateTime(dt::AbstractString, df::DateFormat) -> DateTime
\end{minted}

Construct a \texttt{DateTime} by parsing the \texttt{dt} date time string following the pattern given in the \hyperlink{18093459443158853001}{\texttt{DateFormat}} object. Similar to \texttt{DateTime(::AbstractString, ::AbstractString)} but more efficient when repeatedly parsing similarly formatted date time strings with a pre-created \texttt{DateFormat} object.



\end{adjustwidth}
\hypertarget{3763584541689775694}{} 
\hyperlink{3763584541689775694}{\texttt{Dates.Date}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Date(y, [m, d]) -> Date
\end{minted}

Construct a \texttt{Date} type by parts. Arguments must be convertible to \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{13807007941640052204}{} 
\hyperlink{13807007941640052204}{\texttt{Dates.Date}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Date(period::Period...) -> Date
\end{minted}

Construct a \texttt{Date} type by \texttt{Period} type parts. Arguments may be in any order. \texttt{Date} parts not provided will default to the value of \texttt{Dates.default(period)}.



\end{adjustwidth}
\hypertarget{14780297511642453784}{} 
\hyperlink{14780297511642453784}{\texttt{Dates.Date}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Date(f::Function, y[, m, d]; step=Day(1), limit=10000) -> Date
\end{minted}

Create a \texttt{Date} through the adjuster API. The starting point will be constructed from the provided \texttt{y, m, d} arguments, and will be adjusted until \texttt{f::Function} returns \texttt{true}. The step size in adjusting can be provided manually through the \texttt{step} keyword. \texttt{limit} provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (given that \texttt{f::Function} is never satisfied).

\textbf{Examples}


\begin{minted}{jlcon}
julia> Date(date -> Dates.week(date) == 20, 2010, 01, 01)
2010-05-17

julia> Date(date -> Dates.year(date) == 2010, 2000, 01, 01)
2010-01-01

julia> Date(date -> Dates.month(date) == 10, 2000, 01, 01; limit = 5)
ERROR: ArgumentError: Adjustment limit reached: 5 iterations
Stacktrace:
[...]
\end{minted}



\end{adjustwidth}
\hypertarget{2036888574814255715}{} 
\hyperlink{2036888574814255715}{\texttt{Dates.Date}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Date(dt::DateTime) -> Date
\end{minted}

Convert a \texttt{DateTime} to a \texttt{Date}. The hour, minute, second, and millisecond parts of the \texttt{DateTime} are truncated, so only the year, month and day parts are used in construction.



\end{adjustwidth}
\hypertarget{8343259543700535183}{} 
\hyperlink{8343259543700535183}{\texttt{Dates.Date}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Date(d::AbstractString, format::AbstractString; locale="english") -> Date
\end{minted}

Construct a \texttt{Date} by parsing the \texttt{d} date string following the pattern given in the \texttt{format} string.

This method creates a \texttt{DateFormat} object each time it is called. If you are parsing many date strings of the same format, consider creating a \hyperlink{18093459443158853001}{\texttt{DateFormat}} object once and using that as the second argument instead.



\end{adjustwidth}
\hypertarget{10945442581319807702}{} 
\hyperlink{10945442581319807702}{\texttt{Dates.Date}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Date(d::AbstractString, df::DateFormat) -> Date
\end{minted}

Parse a date from a date string \texttt{d} using a \texttt{DateFormat} object \texttt{df}.



\end{adjustwidth}
\hypertarget{12389382980626687194}{} 
\hyperlink{12389382980626687194}{\texttt{Dates.Time}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Time(h, [mi, s, ms, us, ns]) -> Time
\end{minted}

Construct a \texttt{Time} type by parts. Arguments must be convertible to \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{2540456868150513770}{} 
\hyperlink{2540456868150513770}{\texttt{Dates.Time}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Time(period::TimePeriod...) -> Time
\end{minted}

Construct a \texttt{Time} type by \texttt{Period} type parts. Arguments may be in any order. \texttt{Time} parts not provided will default to the value of \texttt{Dates.default(period)}.



\end{adjustwidth}
\hypertarget{10615626888769753904}{} 
\hyperlink{10615626888769753904}{\texttt{Dates.Time}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Time(f::Function, h, mi=0; step::Period=Second(1), limit::Int=10000)
Time(f::Function, h, mi, s; step::Period=Millisecond(1), limit::Int=10000)
Time(f::Function, h, mi, s, ms; step::Period=Microsecond(1), limit::Int=10000)
Time(f::Function, h, mi, s, ms, us; step::Period=Nanosecond(1), limit::Int=10000)
\end{minted}

Create a \texttt{Time} through the adjuster API. The starting point will be constructed from the provided \texttt{h, mi, s, ms, us} arguments, and will be adjusted until \texttt{f::Function} returns \texttt{true}. The step size in adjusting can be provided manually through the \texttt{step} keyword. \texttt{limit} provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (in the case that \texttt{f::Function} is never satisfied). Note that the default step will adjust to allow for greater precision for the given arguments; i.e. if hour, minute, and second arguments are provided, the default step will be \texttt{Millisecond(1)} instead of \texttt{Second(1)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.Time(t -> Dates.minute(t) == 30, 20)
20:30:00

julia> Dates.Time(t -> Dates.minute(t) == 0, 20)
20:00:00

julia> Dates.Time(t -> Dates.hour(t) == 10, 3; limit = 5)
ERROR: ArgumentError: Adjustment limit reached: 5 iterations
Stacktrace:
[...]
\end{minted}



\end{adjustwidth}
\hypertarget{12276226804029079320}{} 
\hyperlink{12276226804029079320}{\texttt{Dates.Time}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Time(dt::DateTime) -> Time
\end{minted}

Convert a \texttt{DateTime} to a \texttt{Time}. The hour, minute, second, and millisecond parts of the \texttt{DateTime} are used to create the new \texttt{Time}. Microsecond and nanoseconds are zero by default.



\end{adjustwidth}
\hypertarget{18169882256128304087}{} 
\hyperlink{18169882256128304087}{\texttt{Dates.now}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
now() -> DateTime
\end{minted}

Return a \texttt{DateTime} corresponding to the user{\textquotesingle}s system time including the system timezone locale.



\end{adjustwidth}
\hypertarget{14867142023322691223}{} 
\hyperlink{14867142023322691223}{\texttt{Dates.now}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
now(::Type{UTC}) -> DateTime
\end{minted}

Return a \texttt{DateTime} corresponding to the user{\textquotesingle}s system time as UTC/GMT.



\end{adjustwidth}
\hypertarget{4594213520310841636}{} 
\hyperlink{4594213520310841636}{\texttt{Base.eps}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eps(::DateTime) -> Millisecond
eps(::Date) -> Day
eps(::Time) -> Nanosecond
\end{minted}

Returns \texttt{Millisecond(1)} for \texttt{DateTime} values, \texttt{Day(1)} for \texttt{Date} values, and \texttt{Nanosecond(1)} for \texttt{Time} values.



\end{adjustwidth}

\hypertarget{15274886386548419130}{}


\subsection{Accessor Functions}


\hypertarget{9714527822092754339}{} 
\hyperlink{9714527822092754339}{\texttt{Dates.year}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
year(dt::TimeType) -> Int64
\end{minted}

The year of a \texttt{Date} or \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{3646624885120036576}{} 
\hyperlink{3646624885120036576}{\texttt{Dates.month}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
month(dt::TimeType) -> Int64
\end{minted}

The month of a \texttt{Date} or \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{15002548627104558576}{} 
\hyperlink{15002548627104558576}{\texttt{Dates.week}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
week(dt::TimeType) -> Int64
\end{minted}

Return the \href{https://en.wikipedia.org/wiki/ISO\_week\_date}{ISO week date} of a \texttt{Date} or \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}. Note that the first week of a year is the week that contains the first Thursday of the year, which can result in dates prior to January 4th being in the last week of the previous year. For example, \texttt{week(Date(2005, 1, 1))} is the 53rd week of 2004.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.week(Date(1989, 6, 22))
25

julia> Dates.week(Date(2005, 1, 1))
53

julia> Dates.week(Date(2004, 12, 31))
53
\end{minted}



\end{adjustwidth}
\hypertarget{15216601024330128019}{} 
\hyperlink{15216601024330128019}{\texttt{Dates.day}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
day(dt::TimeType) -> Int64
\end{minted}

The day of month of a \texttt{Date} or \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{14478105094783051644}{} 
\hyperlink{14478105094783051644}{\texttt{Dates.hour}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hour(dt::DateTime) -> Int64
\end{minted}

The hour of day of a \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.




\begin{lstlisting}
hour(t::Time) -> Int64
\end{lstlisting}

The hour of a \texttt{Time} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{1962337999361765726}{} 
\hyperlink{1962337999361765726}{\texttt{Dates.minute}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
minute(dt::DateTime) -> Int64
\end{minted}

The minute of a \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.




\begin{lstlisting}
minute(t::Time) -> Int64
\end{lstlisting}

The minute of a \texttt{Time} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{15148061267327101157}{} 
\hyperlink{15148061267327101157}{\texttt{Dates.second}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
second(dt::DateTime) -> Int64
\end{minted}

The second of a \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.




\begin{lstlisting}
second(t::Time) -> Int64
\end{lstlisting}

The second of a \texttt{Time} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{4812831413693375163}{} 
\hyperlink{4812831413693375163}{\texttt{Dates.millisecond}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
millisecond(dt::DateTime) -> Int64
\end{minted}

The millisecond of a \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.




\begin{lstlisting}
millisecond(t::Time) -> Int64
\end{lstlisting}

The millisecond of a \texttt{Time} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{13472031808151614256}{} 
\hyperlink{13472031808151614256}{\texttt{Dates.microsecond}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
microsecond(t::Time) -> Int64
\end{minted}

The microsecond of a \texttt{Time} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{5077020706593048697}{} 
\hyperlink{5077020706593048697}{\texttt{Dates.nanosecond}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nanosecond(t::Time) -> Int64
\end{minted}

The nanosecond of a \texttt{Time} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{16556427820393178039}{} 
\hyperlink{16556427820393178039}{\texttt{Dates.Year}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Year(v)
\end{minted}

Construct a \texttt{Year} object with the given \texttt{v} value. Input must be losslessly convertible to an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{2872605566119772618}{} 
\hyperlink{2872605566119772618}{\texttt{Dates.Month}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Month(v)
\end{minted}

Construct a \texttt{Month} object with the given \texttt{v} value. Input must be losslessly convertible to an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{9656974277347347506}{} 
\hyperlink{9656974277347347506}{\texttt{Dates.Week}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Week(v)
\end{minted}

Construct a \texttt{Week} object with the given \texttt{v} value. Input must be losslessly convertible to an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{13217464551942182596}{} 
\hyperlink{13217464551942182596}{\texttt{Dates.Day}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Day(v)
\end{minted}

Construct a \texttt{Day} object with the given \texttt{v} value. Input must be losslessly convertible to an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{11671105558328225558}{} 
\hyperlink{11671105558328225558}{\texttt{Dates.Hour}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Hour(dt::DateTime) -> Hour
\end{minted}

The hour part of a DateTime as a \texttt{Hour}.



\end{adjustwidth}
\hypertarget{15437593953944371601}{} 
\hyperlink{15437593953944371601}{\texttt{Dates.Minute}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Minute(dt::DateTime) -> Minute
\end{minted}

The minute part of a DateTime as a \texttt{Minute}.



\end{adjustwidth}
\hypertarget{544402402471521748}{} 
\hyperlink{544402402471521748}{\texttt{Dates.Second}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Second(dt::DateTime) -> Second
\end{minted}

The second part of a DateTime as a \texttt{Second}.



\end{adjustwidth}
\hypertarget{9366634148855607364}{} 
\hyperlink{9366634148855607364}{\texttt{Dates.Millisecond}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Millisecond(dt::DateTime) -> Millisecond
\end{minted}

The millisecond part of a DateTime as a \texttt{Millisecond}.



\end{adjustwidth}
\hypertarget{4155472013117853166}{} 
\hyperlink{4155472013117853166}{\texttt{Dates.Microsecond}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Microsecond(dt::Time) -> Microsecond
\end{minted}

The microsecond part of a Time as a \texttt{Microsecond}.



\end{adjustwidth}
\hypertarget{14345635682555926790}{} 
\hyperlink{14345635682555926790}{\texttt{Dates.Nanosecond}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Nanosecond(dt::Time) -> Nanosecond
\end{minted}

The nanosecond part of a Time as a \texttt{Nanosecond}.



\end{adjustwidth}
\hypertarget{1408650772715600889}{} 
\hyperlink{1408650772715600889}{\texttt{Dates.yearmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
yearmonth(dt::TimeType) -> (Int64, Int64)
\end{minted}

Simultaneously return the year and month parts of a \texttt{Date} or \texttt{DateTime}.



\end{adjustwidth}
\hypertarget{17847736901982891967}{} 
\hyperlink{17847736901982891967}{\texttt{Dates.monthday}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
monthday(dt::TimeType) -> (Int64, Int64)
\end{minted}

Simultaneously return the month and day parts of a \texttt{Date} or \texttt{DateTime}.



\end{adjustwidth}
\hypertarget{18225305010779633841}{} 
\hyperlink{18225305010779633841}{\texttt{Dates.yearmonthday}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
yearmonthday(dt::TimeType) -> (Int64, Int64, Int64)
\end{minted}

Simultaneously return the year, month and day parts of a \texttt{Date} or \texttt{DateTime}.



\end{adjustwidth}

\hypertarget{16158364891045757229}{}


\subsection{Query Functions}


\hypertarget{2440842966718954493}{} 
\hyperlink{2440842966718954493}{\texttt{Dates.dayname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dayname(dt::TimeType; locale="english") -> String
dayname(day::Integer; locale="english") -> String
\end{minted}

Return the full day name corresponding to the day of the week of the \texttt{Date} or \texttt{DateTime} in the given \texttt{locale}. Also accepts \texttt{Integer}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.dayname(Date("2000-01-01"))
"Saturday"

julia> Dates.dayname(4)
"Thursday"
\end{minted}



\end{adjustwidth}
\hypertarget{18198970391837299875}{} 
\hyperlink{18198970391837299875}{\texttt{Dates.dayabbr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dayabbr(dt::TimeType; locale="english") -> String
dayabbr(day::Integer; locale="english") -> String
\end{minted}

Return the abbreviated name corresponding to the day of the week of the \texttt{Date} or \texttt{DateTime} in the given \texttt{locale}. Also accepts \texttt{Integer}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.dayabbr(Date("2000-01-01"))
"Sat"

julia> Dates.dayabbr(3)
"Wed"
\end{minted}



\end{adjustwidth}
\hypertarget{12798531608759474645}{} 
\hyperlink{12798531608759474645}{\texttt{Dates.dayofweek}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dayofweek(dt::TimeType) -> Int64
\end{minted}

Return the day of the week as an \hyperlink{7720564657383125058}{\texttt{Int64}} with \texttt{1 = Monday, 2 = Tuesday, etc.}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.dayofweek(Date("2000-01-01"))
6
\end{minted}



\end{adjustwidth}
\hypertarget{11391658730748043877}{} 
\hyperlink{11391658730748043877}{\texttt{Dates.dayofmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dayofmonth(dt::TimeType) -> Int64
\end{minted}

The day of month of a \texttt{Date} or \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{3444497056704321071}{} 
\hyperlink{3444497056704321071}{\texttt{Dates.dayofweekofmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dayofweekofmonth(dt::TimeType) -> Int
\end{minted}

For the day of week of \texttt{dt}, return which number it is in \texttt{dt}{\textquotesingle}s month. So if the day of the week of \texttt{dt} is Monday, then \texttt{1 = First Monday of the month, 2 = Second Monday of the month, etc.} In the range 1:5.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.dayofweekofmonth(Date("2000-02-01"))
1

julia> Dates.dayofweekofmonth(Date("2000-02-08"))
2

julia> Dates.dayofweekofmonth(Date("2000-02-15"))
3
\end{minted}



\end{adjustwidth}
\hypertarget{3276636057341185884}{} 
\hyperlink{3276636057341185884}{\texttt{Dates.daysofweekinmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
daysofweekinmonth(dt::TimeType) -> Int
\end{minted}

For the day of week of \texttt{dt}, return the total number of that day of the week in \texttt{dt}{\textquotesingle}s month. Returns 4 or 5. Useful in temporal expressions for specifying the last day of a week in a month by including \texttt{dayofweekofmonth(dt) == daysofweekinmonth(dt)} in the adjuster function.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.daysofweekinmonth(Date("2005-01-01"))
5

julia> Dates.daysofweekinmonth(Date("2005-01-04"))
4
\end{minted}



\end{adjustwidth}
\hypertarget{16585759639636493546}{} 
\hyperlink{16585759639636493546}{\texttt{Dates.monthname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
monthname(dt::TimeType; locale="english") -> String
monthname(month::Integer, locale="english") -> String
\end{minted}

Return the full name of the month of the \texttt{Date} or \texttt{DateTime} or \texttt{Integer} in the given \texttt{locale}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.monthname(Date("2005-01-04"))
"January"

julia> Dates.monthname(2)
"February"
\end{minted}



\end{adjustwidth}
\hypertarget{12804940912944832895}{} 
\hyperlink{12804940912944832895}{\texttt{Dates.monthabbr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
monthabbr(dt::TimeType; locale="english") -> String
monthabbr(month::Integer, locale="english") -> String
\end{minted}

Return the abbreviated month name of the \texttt{Date} or \texttt{DateTime} or \texttt{Integer} in the given \texttt{locale}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.monthabbr(Date("2005-01-04"))
"Jan"

julia> monthabbr(2)
"Feb"
\end{minted}



\end{adjustwidth}
\hypertarget{7867088328366678414}{} 
\hyperlink{7867088328366678414}{\texttt{Dates.daysinmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
daysinmonth(dt::TimeType) -> Int
\end{minted}

Return the number of days in the month of \texttt{dt}. Value will be 28, 29, 30, or 31.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.daysinmonth(Date("2000-01"))
31

julia> Dates.daysinmonth(Date("2001-02"))
28

julia> Dates.daysinmonth(Date("2000-02"))
29
\end{minted}



\end{adjustwidth}
\hypertarget{8386083064240039655}{} 
\hyperlink{8386083064240039655}{\texttt{Dates.isleapyear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isleapyear(dt::TimeType) -> Bool
\end{minted}

Return \texttt{true} if the year of \texttt{dt} is a leap year.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.isleapyear(Date("2004"))
true

julia> Dates.isleapyear(Date("2005"))
false
\end{minted}



\end{adjustwidth}
\hypertarget{4496651838489546625}{} 
\hyperlink{4496651838489546625}{\texttt{Dates.dayofyear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dayofyear(dt::TimeType) -> Int
\end{minted}

Return the day of the year for \texttt{dt} with January 1st being day 1.



\end{adjustwidth}
\hypertarget{11086128603918251845}{} 
\hyperlink{11086128603918251845}{\texttt{Dates.daysinyear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
daysinyear(dt::TimeType) -> Int
\end{minted}

Return 366 if the year of \texttt{dt} is a leap year, otherwise return 365.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.daysinyear(1999)
365

julia> Dates.daysinyear(2000)
366
\end{minted}



\end{adjustwidth}
\hypertarget{6690591772267933900}{} 
\hyperlink{6690591772267933900}{\texttt{Dates.quarterofyear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
quarterofyear(dt::TimeType) -> Int
\end{minted}

Return the quarter that \texttt{dt} resides in. Range of value is 1:4.



\end{adjustwidth}
\hypertarget{10496844318360486693}{} 
\hyperlink{10496844318360486693}{\texttt{Dates.dayofquarter}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dayofquarter(dt::TimeType) -> Int
\end{minted}

Return the day of the current quarter of \texttt{dt}. Range of value is 1:92.



\end{adjustwidth}

\hypertarget{13551592780469201884}{}


\subsection{Adjuster Functions}


\hypertarget{173413331178974124}{} 
\hyperlink{173413331178974124}{\texttt{Base.trunc}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trunc(dt::TimeType, ::Type{Period}) -> TimeType
\end{minted}

Truncates the value of \texttt{dt} according to the provided \texttt{Period} type.

\textbf{Examples}


\begin{minted}{jlcon}
julia> trunc(Dates.DateTime("1996-01-01T12:30:00"), Dates.Day)
1996-01-01T00:00:00
\end{minted}



\end{adjustwidth}
\hypertarget{725369720992290901}{} 
\hyperlink{725369720992290901}{\texttt{Dates.firstdayofweek}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
firstdayofweek(dt::TimeType) -> TimeType
\end{minted}

Adjusts \texttt{dt} to the Monday of its week.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.firstdayofweek(DateTime("1996-01-05T12:30:00"))
1996-01-01T00:00:00
\end{minted}



\end{adjustwidth}
\hypertarget{15555713849502356755}{} 
\hyperlink{15555713849502356755}{\texttt{Dates.lastdayofweek}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lastdayofweek(dt::TimeType) -> TimeType
\end{minted}

Adjusts \texttt{dt} to the Sunday of its week.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.lastdayofweek(DateTime("1996-01-05T12:30:00"))
1996-01-07T00:00:00
\end{minted}



\end{adjustwidth}
\hypertarget{944292496394173921}{} 
\hyperlink{944292496394173921}{\texttt{Dates.firstdayofmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
firstdayofmonth(dt::TimeType) -> TimeType
\end{minted}

Adjusts \texttt{dt} to the first day of its month.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.firstdayofmonth(DateTime("1996-05-20"))
1996-05-01T00:00:00
\end{minted}



\end{adjustwidth}
\hypertarget{14220689943148611628}{} 
\hyperlink{14220689943148611628}{\texttt{Dates.lastdayofmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lastdayofmonth(dt::TimeType) -> TimeType
\end{minted}

Adjusts \texttt{dt} to the last day of its month.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.lastdayofmonth(DateTime("1996-05-20"))
1996-05-31T00:00:00
\end{minted}



\end{adjustwidth}
\hypertarget{16489505143268736660}{} 
\hyperlink{16489505143268736660}{\texttt{Dates.firstdayofyear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
firstdayofyear(dt::TimeType) -> TimeType
\end{minted}

Adjusts \texttt{dt} to the first day of its year.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.firstdayofyear(DateTime("1996-05-20"))
1996-01-01T00:00:00
\end{minted}



\end{adjustwidth}
\hypertarget{10580858002556506121}{} 
\hyperlink{10580858002556506121}{\texttt{Dates.lastdayofyear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lastdayofyear(dt::TimeType) -> TimeType
\end{minted}

Adjusts \texttt{dt} to the last day of its year.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.lastdayofyear(DateTime("1996-05-20"))
1996-12-31T00:00:00
\end{minted}



\end{adjustwidth}
\hypertarget{16102783699720368943}{} 
\hyperlink{16102783699720368943}{\texttt{Dates.firstdayofquarter}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
firstdayofquarter(dt::TimeType) -> TimeType
\end{minted}

Adjusts \texttt{dt} to the first day of its quarter.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.firstdayofquarter(DateTime("1996-05-20"))
1996-04-01T00:00:00

julia> Dates.firstdayofquarter(DateTime("1996-08-20"))
1996-07-01T00:00:00
\end{minted}



\end{adjustwidth}
\hypertarget{90261086996796964}{} 
\hyperlink{90261086996796964}{\texttt{Dates.lastdayofquarter}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lastdayofquarter(dt::TimeType) -> TimeType
\end{minted}

Adjusts \texttt{dt} to the last day of its quarter.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.lastdayofquarter(DateTime("1996-05-20"))
1996-06-30T00:00:00

julia> Dates.lastdayofquarter(DateTime("1996-08-20"))
1996-09-30T00:00:00
\end{minted}



\end{adjustwidth}
\hypertarget{9410879287453023176}{} 
\hyperlink{9410879287453023176}{\texttt{Dates.tonext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tonext(dt::TimeType, dow::Int; same::Bool=false) -> TimeType
\end{minted}

Adjusts \texttt{dt} to the next day of week corresponding to \texttt{dow} with \texttt{1 = Monday, 2 = Tuesday, etc}. Setting \texttt{same=true} allows the current \texttt{dt} to be considered as the next \texttt{dow}, allowing for no adjustment to occur.



\end{adjustwidth}
\hypertarget{5295237512711135506}{} 
\hyperlink{5295237512711135506}{\texttt{Dates.toprev}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
toprev(dt::TimeType, dow::Int; same::Bool=false) -> TimeType
\end{minted}

Adjusts \texttt{dt} to the previous day of week corresponding to \texttt{dow} with \texttt{1 = Monday, 2 = Tuesday, etc}. Setting \texttt{same=true} allows the current \texttt{dt} to be considered as the previous \texttt{dow}, allowing for no adjustment to occur.



\end{adjustwidth}
\hypertarget{14392816409484181570}{} 
\hyperlink{14392816409484181570}{\texttt{Dates.tofirst}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tofirst(dt::TimeType, dow::Int; of=Month) -> TimeType
\end{minted}

Adjusts \texttt{dt} to the first \texttt{dow} of its month. Alternatively, \texttt{of=Year} will adjust to the first \texttt{dow} of the year.



\end{adjustwidth}
\hypertarget{18080067486232724602}{} 
\hyperlink{18080067486232724602}{\texttt{Dates.tolast}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tolast(dt::TimeType, dow::Int; of=Month) -> TimeType
\end{minted}

Adjusts \texttt{dt} to the last \texttt{dow} of its month. Alternatively, \texttt{of=Year} will adjust to the last \texttt{dow} of the year.



\end{adjustwidth}
\hypertarget{4241078503475048595}{} 
\hyperlink{4241078503475048595}{\texttt{Dates.tonext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tonext(func::Function, dt::TimeType; step=Day(1), limit=10000, same=false) -> TimeType
\end{minted}

Adjusts \texttt{dt} by iterating at most \texttt{limit} iterations by \texttt{step} increments until \texttt{func} returns \texttt{true}. \texttt{func} must take a single \texttt{TimeType} argument and return a \hyperlink{46725311238864537}{\texttt{Bool}}. \texttt{same} allows \texttt{dt} to be considered in satisfying \texttt{func}.



\end{adjustwidth}
\hypertarget{7889720794479911439}{} 
\hyperlink{7889720794479911439}{\texttt{Dates.toprev}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
toprev(func::Function, dt::TimeType; step=Day(-1), limit=10000, same=false) -> TimeType
\end{minted}

Adjusts \texttt{dt} by iterating at most \texttt{limit} iterations by \texttt{step} increments until \texttt{func} returns \texttt{true}. \texttt{func} must take a single \texttt{TimeType} argument and return a \hyperlink{46725311238864537}{\texttt{Bool}}. \texttt{same} allows \texttt{dt} to be considered in satisfying \texttt{func}.



\end{adjustwidth}

\hypertarget{5161625535326415321}{}


\subsection{Periods}


\hypertarget{5339072836021258931}{} 
\hyperlink{5339072836021258931}{\texttt{Dates.Period}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Year(v)
Month(v)
Week(v)
Day(v)
Hour(v)
Minute(v)
Second(v)
Millisecond(v)
Microsecond(v)
Nanosecond(v)
\end{minted}

Construct a \texttt{Period} type with the given \texttt{v} value. Input must be losslessly convertible to an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{11754777390580731638}{} 
\hyperlink{11754777390580731638}{\texttt{Dates.CompoundPeriod}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
CompoundPeriod(periods) -> CompoundPeriod
\end{minted}

Construct a \texttt{CompoundPeriod} from a \texttt{Vector} of \texttt{Period}s. All \texttt{Period}s of the same type will be added together.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.CompoundPeriod(Dates.Hour(12), Dates.Hour(13))
25 hours

julia> Dates.CompoundPeriod(Dates.Hour(-1), Dates.Minute(1))
-1 hour, 1 minute

julia> Dates.CompoundPeriod(Dates.Month(1), Dates.Week(-2))
1 month, -2 weeks

julia> Dates.CompoundPeriod(Dates.Minute(50000))
50000 minutes
\end{minted}



\end{adjustwidth}
\hypertarget{6471383377711200525}{} 
\hyperlink{6471383377711200525}{\texttt{Dates.value}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Dates.value(x::Period) -> Int64
\end{minted}

For a given period, return the value associated with that period.  For example, \texttt{value(Millisecond(10))} returns 10 as an integer.



\end{adjustwidth}
\hypertarget{9890661094020401012}{} 
\hyperlink{9890661094020401012}{\texttt{Dates.default}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
default(p::Period) -> Period
\end{minted}

Returns a sensible {\textquotedbl}default{\textquotedbl} value for the input Period by returning \texttt{T(1)} for Year, Month, and Day, and \texttt{T(0)} for Hour, Minute, Second, and Millisecond.



\end{adjustwidth}

\hypertarget{13058474467070921522}{}


\subsection{取整函数}



\texttt{Date} and \texttt{DateTime} values can be rounded to a specified resolution (e.g., 1 month or 15 minutes) with \texttt{floor}, \texttt{ceil}, or \texttt{round}.


\hypertarget{6962549236860281908}{} 
\hyperlink{6962549236860281908}{\texttt{Base.floor}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
floor(dt::TimeType, p::Period) -> TimeType
\end{minted}

Return the nearest \texttt{Date} or \texttt{DateTime} less than or equal to \texttt{dt} at resolution \texttt{p}.

For convenience, \texttt{p} may be a type instead of a value: \texttt{floor(dt, Dates.Hour)} is a shortcut for \texttt{floor(dt, Dates.Hour(1))}.


\begin{minted}{jlcon}
julia> floor(Date(1985, 8, 16), Dates.Month)
1985-08-01

julia> floor(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))
2013-02-13T00:30:00

julia> floor(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)
2016-08-06T00:00:00
\end{minted}



\end{adjustwidth}
\hypertarget{13217485408632363978}{} 
\hyperlink{13217485408632363978}{\texttt{Base.ceil}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ceil(dt::TimeType, p::Period) -> TimeType
\end{minted}

Return the nearest \texttt{Date} or \texttt{DateTime} greater than or equal to \texttt{dt} at resolution \texttt{p}.

For convenience, \texttt{p} may be a type instead of a value: \texttt{ceil(dt, Dates.Hour)} is a shortcut for \texttt{ceil(dt, Dates.Hour(1))}.


\begin{minted}{jlcon}
julia> ceil(Date(1985, 8, 16), Dates.Month)
1985-09-01

julia> ceil(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))
2013-02-13T00:45:00

julia> ceil(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)
2016-08-07T00:00:00
\end{minted}



\end{adjustwidth}
\hypertarget{11570783396170921526}{} 
\hyperlink{11570783396170921526}{\texttt{Base.round}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
round(dt::TimeType, p::Period, [r::RoundingMode]) -> TimeType
\end{minted}

Return the \texttt{Date} or \texttt{DateTime} nearest to \texttt{dt} at resolution \texttt{p}. By default (\texttt{RoundNearestTiesUp}), ties (e.g., rounding 9:30 to the nearest hour) will be rounded up.

For convenience, \texttt{p} may be a type instead of a value: \texttt{round(dt, Dates.Hour)} is a shortcut for \texttt{round(dt, Dates.Hour(1))}.


\begin{minted}{jlcon}
julia> round(Date(1985, 8, 16), Dates.Month)
1985-08-01

julia> round(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))
2013-02-13T00:30:00

julia> round(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)
2016-08-07T00:00:00
\end{minted}

Valid rounding modes for \texttt{round(::TimeType, ::Period, ::RoundingMode)} are \texttt{RoundNearestTiesUp} (default), \texttt{RoundDown} (\texttt{floor}), and \texttt{RoundUp} (\texttt{ceil}).



\end{adjustwidth}

Most \texttt{Period} values can also be rounded to a specified resolution:


\hypertarget{3559289051512772121}{} 
\hyperlink{3559289051512772121}{\texttt{Base.floor}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
floor(x::Period, precision::T) where T <: Union{TimePeriod, Week, Day} -> T
\end{minted}

Round \texttt{x} down to the nearest multiple of \texttt{precision}. If \texttt{x} and \texttt{precision} are different subtypes of \texttt{Period}, the return value will have the same type as \texttt{precision}.

For convenience, \texttt{precision} may be a type instead of a value: \texttt{floor(x, Dates.Hour)} is a shortcut for \texttt{floor(x, Dates.Hour(1))}.


\begin{minted}{jlcon}
julia> floor(Dates.Day(16), Dates.Week)
2 weeks

julia> floor(Dates.Minute(44), Dates.Minute(15))
30 minutes

julia> floor(Dates.Hour(36), Dates.Day)
1 day
\end{minted}

Rounding to a \texttt{precision} of \texttt{Month}s or \texttt{Year}s is not supported, as these \texttt{Period}s are of inconsistent length.



\end{adjustwidth}
\hypertarget{6035166226319109738}{} 
\hyperlink{6035166226319109738}{\texttt{Base.ceil}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ceil(x::Period, precision::T) where T <: Union{TimePeriod, Week, Day} -> T
\end{minted}

Round \texttt{x} up to the nearest multiple of \texttt{precision}. If \texttt{x} and \texttt{precision} are different subtypes of \texttt{Period}, the return value will have the same type as \texttt{precision}.

For convenience, \texttt{precision} may be a type instead of a value: \texttt{ceil(x, Dates.Hour)} is a shortcut for \texttt{ceil(x, Dates.Hour(1))}.


\begin{minted}{jlcon}
julia> ceil(Dates.Day(16), Dates.Week)
3 weeks

julia> ceil(Dates.Minute(44), Dates.Minute(15))
45 minutes

julia> ceil(Dates.Hour(36), Dates.Day)
2 days
\end{minted}

Rounding to a \texttt{precision} of \texttt{Month}s or \texttt{Year}s is not supported, as these \texttt{Period}s are of inconsistent length.



\end{adjustwidth}
\hypertarget{15529975760511008617}{} 
\hyperlink{15529975760511008617}{\texttt{Base.round}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
round(x::Period, precision::T, [r::RoundingMode]) where T <: Union{TimePeriod, Week, Day} -> T
\end{minted}

Round \texttt{x} to the nearest multiple of \texttt{precision}. If \texttt{x} and \texttt{precision} are different subtypes of \texttt{Period}, the return value will have the same type as \texttt{precision}. By default (\texttt{RoundNearestTiesUp}), ties (e.g., rounding 90 minutes to the nearest hour) will be rounded up.

For convenience, \texttt{precision} may be a type instead of a value: \texttt{round(x, Dates.Hour)} is a shortcut for \texttt{round(x, Dates.Hour(1))}.


\begin{minted}{jlcon}
julia> round(Dates.Day(16), Dates.Week)
2 weeks

julia> round(Dates.Minute(44), Dates.Minute(15))
45 minutes

julia> round(Dates.Hour(36), Dates.Day)
2 days
\end{minted}

Valid rounding modes for \texttt{round(::Period, ::T, ::RoundingMode)} are \texttt{RoundNearestTiesUp} (default), \texttt{RoundDown} (\texttt{floor}), and \texttt{RoundUp} (\texttt{ceil}).

Rounding to a \texttt{precision} of \texttt{Month}s or \texttt{Year}s is not supported, as these \texttt{Period}s are of inconsistent length.



\end{adjustwidth}

The following functions are not exported:


\hypertarget{12245544538142909757}{} 
\hyperlink{12245544538142909757}{\texttt{Dates.floorceil}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
floorceil(dt::TimeType, p::Period) -> (TimeType, TimeType)
\end{minted}

Simultaneously return the \texttt{floor} and \texttt{ceil} of a \texttt{Date} or \texttt{DateTime} at resolution \texttt{p}. More efficient than calling both \texttt{floor} and \texttt{ceil} individually.




\begin{lstlisting}
floorceil(x::Period, precision::T) where T <: Union{TimePeriod, Week, Day} -> (T, T)
\end{lstlisting}

Simultaneously return the \texttt{floor} and \texttt{ceil} of \texttt{Period} at resolution \texttt{p}.  More efficient than calling both \texttt{floor} and \texttt{ceil} individually.



\end{adjustwidth}
\hypertarget{6172851707225539496}{} 
\hyperlink{6172851707225539496}{\texttt{Dates.epochdays2date}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
epochdays2date(days) -> Date
\end{minted}

Take the number of days since the rounding epoch (\texttt{0000-01-01T00:00:00}) and return the corresponding \texttt{Date}.



\end{adjustwidth}
\hypertarget{228819666916608027}{} 
\hyperlink{228819666916608027}{\texttt{Dates.epochms2datetime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
epochms2datetime(milliseconds) -> DateTime
\end{minted}

Take the number of milliseconds since the rounding epoch (\texttt{0000-01-01T00:00:00}) and return the corresponding \texttt{DateTime}.



\end{adjustwidth}
\hypertarget{4031977144092247953}{} 
\hyperlink{4031977144092247953}{\texttt{Dates.date2epochdays}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
date2epochdays(dt::Date) -> Int64
\end{minted}

Take the given \texttt{Date} and return the number of days since the rounding epoch (\texttt{0000-01-01T00:00:00}) as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{12248243003394996071}{} 
\hyperlink{12248243003394996071}{\texttt{Dates.datetime2epochms}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
datetime2epochms(dt::DateTime) -> Int64
\end{minted}

Take the given \texttt{DateTime} and return the number of milliseconds since the rounding epoch (\texttt{0000-01-01T00:00:00}) as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}

\hypertarget{7595184717708184953}{}


\subsection{转换函数}


\hypertarget{14772120662961874184}{} 
\hyperlink{14772120662961874184}{\texttt{Dates.today}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
today() -> Date
\end{minted}

Return the date portion of \texttt{now()}.



\end{adjustwidth}
\hypertarget{1873675393210620747}{} 
\hyperlink{1873675393210620747}{\texttt{Dates.unix2datetime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unix2datetime(x) -> DateTime
\end{minted}

Take the number of seconds since unix epoch \texttt{1970-01-01T00:00:00} and convert to the corresponding \texttt{DateTime}.



\end{adjustwidth}
\hypertarget{4964397354460606136}{} 
\hyperlink{4964397354460606136}{\texttt{Dates.datetime2unix}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
datetime2unix(dt::DateTime) -> Float64
\end{minted}

Take the given \texttt{DateTime} and return the number of seconds since the unix epoch \texttt{1970-01-01T00:00:00} as a \hyperlink{5027751419500983000}{\texttt{Float64}}.



\end{adjustwidth}
\hypertarget{2031899596964007680}{} 
\hyperlink{2031899596964007680}{\texttt{Dates.julian2datetime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
julian2datetime(julian_days) -> DateTime
\end{minted}

Take the number of Julian calendar days since epoch \texttt{-4713-11-24T12:00:00} and return the corresponding \texttt{DateTime}.



\end{adjustwidth}
\hypertarget{11675145653043813028}{} 
\hyperlink{11675145653043813028}{\texttt{Dates.datetime2julian}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
datetime2julian(dt::DateTime) -> Float64
\end{minted}

Take the given \texttt{DateTime} and return the number of Julian calendar days since the julian epoch \texttt{-4713-11-24T12:00:00} as a \hyperlink{5027751419500983000}{\texttt{Float64}}.



\end{adjustwidth}
\hypertarget{13618878841813439465}{} 
\hyperlink{13618878841813439465}{\texttt{Dates.rata2datetime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rata2datetime(days) -> DateTime
\end{minted}

Take the number of Rata Die days since epoch \texttt{0000-12-31T00:00:00} and return the corresponding \texttt{DateTime}.



\end{adjustwidth}
\hypertarget{4095235562821247460}{} 
\hyperlink{4095235562821247460}{\texttt{Dates.datetime2rata}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
datetime2rata(dt::TimeType) -> Int64
\end{minted}

Return the number of Rata Die days since epoch from the given \texttt{Date} or \texttt{DateTime}.



\end{adjustwidth}

\hypertarget{5407065244463689569}{}


\subsection{常量}



Days of the Week:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Variable & Abbr. & Value (Int) \\
\hline
\texttt{Monday} & \texttt{Mon} & 1 \\
\hline
\texttt{Tuesday} & \texttt{Tue} & 2 \\
\hline
\texttt{Wednesday} & \texttt{Wed} & 3 \\
\hline
\texttt{Thursday} & \texttt{Thu} & 4 \\
\hline
\texttt{Friday} & \texttt{Fri} & 5 \\
\hline
\texttt{Saturday} & \texttt{Sat} & 6 \\
\hline
\texttt{Sunday} & \texttt{Sun} & 7 \\
\hline
\end{tabulary}

\end{table}



Months of the Year:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Variable & Abbr. & Value (Int) \\
\hline
\texttt{January} & \texttt{Jan} & 1 \\
\hline
\texttt{February} & \texttt{Feb} & 2 \\
\hline
\texttt{March} & \texttt{Mar} & 3 \\
\hline
\texttt{April} & \texttt{Apr} & 4 \\
\hline
\texttt{May} & \texttt{May} & 5 \\
\hline
\texttt{June} & \texttt{Jun} & 6 \\
\hline
\texttt{July} & \texttt{Jul} & 7 \\
\hline
\texttt{August} & \texttt{Aug} & 8 \\
\hline
\texttt{September} & \texttt{Sep} & 9 \\
\hline
\texttt{October} & \texttt{Oct} & 10 \\
\hline
\texttt{November} & \texttt{Nov} & 11 \\
\hline
\texttt{December} & \texttt{Dec} & 12 \\
\hline
\end{tabulary}

\end{table}





\hypertarget{8991044554794555328}{}


\chapter{分隔符文件}


\hypertarget{16037077475059757878}{} 
\hyperlink{16037077475059757878}{\texttt{DelimitedFiles.readdlm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readdlm(source, delim::AbstractChar, T::Type, eol::AbstractChar; header=false, skipstart=0, skipblanks=true, use_mmap, quotes=true, dims, comments=false, comment_char='#')
\end{minted}

Read a matrix from the source where each line (separated by \texttt{eol}) gives one row, with elements separated by the given delimiter. The source can be a text file, stream or byte array. Memory mapped files can be used by passing the byte array representation of the mapped segment as source.

If \texttt{T} is a numeric type, the result is an array of that type, with any non-numeric elements as \texttt{NaN} for floating-point types, or zero. Other useful values of \texttt{T} include \texttt{String}, \texttt{AbstractString}, and \texttt{Any}.

If \texttt{header} is \texttt{true}, the first row of data will be read as header and the tuple \texttt{(data\_cells, header\_cells)} is returned instead of only \texttt{data\_cells}.

Specifying \texttt{skipstart} will ignore the corresponding number of initial lines from the input.

If \texttt{skipblanks} is \texttt{true}, blank lines in the input will be ignored.

If \texttt{use\_mmap} is \texttt{true}, the file specified by \texttt{source} is memory mapped for potential speedups. Default is \texttt{true} except on Windows. On Windows, you may want to specify \texttt{true} if the file is large, and is only read once and not written to.

If \texttt{quotes} is \texttt{true}, columns enclosed within double-quote ({\textquotedbl}) characters are allowed to contain new lines and column delimiters. Double-quote characters within a quoted field must be escaped with another double-quote.  Specifying \texttt{dims} as a tuple of the expected rows and columns (including header, if any) may speed up reading of large files.  If \texttt{comments} is \texttt{true}, lines beginning with \texttt{comment\_char} and text following \texttt{comment\_char} in any line are ignored.

\textbf{Examples}


\begin{minted}{jlcon}
julia> using DelimitedFiles

julia> x = [1; 2; 3; 4];

julia> y = [5; 6; 7; 8];

julia> open("delim_file.txt", "w") do io
           writedlm(io, [x y])
       end

julia> readdlm("delim_file.txt", '\t', Int, '\n')
4×2 Array{Int64,2}:
 1  5
 2  6
 3  7
 4  8

julia> rm("delim_file.txt")
\end{minted}



\end{adjustwidth}
\hypertarget{1307762155632158750}{} 
\hyperlink{1307762155632158750}{\texttt{DelimitedFiles.readdlm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readdlm(source, delim::AbstractChar, eol::AbstractChar; options...)
\end{minted}

If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.



\end{adjustwidth}
\hypertarget{11851910953015558329}{} 
\hyperlink{11851910953015558329}{\texttt{DelimitedFiles.readdlm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readdlm(source, delim::AbstractChar, T::Type; options...)
\end{minted}

The end of line delimiter is taken as \texttt{{\textbackslash}n}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> using DelimitedFiles

julia> x = [1; 2; 3; 4];

julia> y = [1.1; 2.2; 3.3; 4.4];

julia> open("delim_file.txt", "w") do io
           writedlm(io, [x y], ',')
       end;

julia> readdlm("delim_file.txt", ',', Float64)
4×2 Array{Float64,2}:
 1.0  1.1
 2.0  2.2
 3.0  3.3
 4.0  4.4

julia> rm("delim_file.txt")
\end{minted}



\end{adjustwidth}
\hypertarget{14088726821151253916}{} 
\hyperlink{14088726821151253916}{\texttt{DelimitedFiles.readdlm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readdlm(source, delim::AbstractChar; options...)
\end{minted}

The end of line delimiter is taken as \texttt{{\textbackslash}n}. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.

\textbf{Examples}


\begin{minted}{jlcon}
julia> using DelimitedFiles

julia> x = [1; 2; 3; 4];

julia> y = [1.1; 2.2; 3.3; 4.4];

julia> open("delim_file.txt", "w") do io
           writedlm(io, [x y], ',')
       end;

julia> readdlm("delim_file.txt", ',')
4×2 Array{Float64,2}:
 1.0  1.1
 2.0  2.2
 3.0  3.3
 4.0  4.4

julia> z = ["a"; "b"; "c"; "d"];

julia> open("delim_file.txt", "w") do io
           writedlm(io, [x z], ',')
       end;

julia> readdlm("delim_file.txt", ',')
4×2 Array{Any,2}:
 1  "a"
 2  "b"
 3  "c"
 4  "d"

julia> rm("delim_file.txt")
\end{minted}



\end{adjustwidth}
\hypertarget{2674796801770597595}{} 
\hyperlink{2674796801770597595}{\texttt{DelimitedFiles.readdlm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readdlm(source, T::Type; options...)
\end{minted}

The columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as \texttt{{\textbackslash}n}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> using DelimitedFiles

julia> x = [1; 2; 3; 4];

julia> y = [5; 6; 7; 8];

julia> open("delim_file.txt", "w") do io
           writedlm(io, [x y])
       end;

julia> readdlm("delim_file.txt", Int64)
4×2 Array{Int64,2}:
 1  5
 2  6
 3  7
 4  8

julia> readdlm("delim_file.txt", Float64)
4×2 Array{Float64,2}:
 1.0  5.0
 2.0  6.0
 3.0  7.0
 4.0  8.0

julia> rm("delim_file.txt")
\end{minted}



\end{adjustwidth}
\hypertarget{12553768345033130217}{} 
\hyperlink{12553768345033130217}{\texttt{DelimitedFiles.readdlm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readdlm(source; options...)
\end{minted}

The columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as \texttt{{\textbackslash}n}. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.

\textbf{Examples}


\begin{minted}{jlcon}
julia> using DelimitedFiles

julia> x = [1; 2; 3; 4];

julia> y = ["a"; "b"; "c"; "d"];

julia> open("delim_file.txt", "w") do io
           writedlm(io, [x y])
       end;

julia> readdlm("delim_file.txt")
4×2 Array{Any,2}:
 1  "a"
 2  "b"
 3  "c"
 4  "d"

julia> rm("delim_file.txt")
\end{minted}



\end{adjustwidth}
\hypertarget{18287165101716314167}{} 
\hyperlink{18287165101716314167}{\texttt{DelimitedFiles.writedlm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
writedlm(f, A, delim='\t'; opts)
\end{minted}

Write \texttt{A} (a vector, matrix, or an iterable collection of iterable rows) as text to \texttt{f} (either a filename string or an \texttt{IO} stream) using the given delimiter \texttt{delim} (which defaults to tab, but can be any printable Julia object, typically a \texttt{Char} or \texttt{AbstractString}).

For example, two vectors \texttt{x} and \texttt{y} of the same length can be written as two columns of tab-delimited text to \texttt{f} by either \texttt{writedlm(f, [x y])} or by \texttt{writedlm(f, zip(x, y))}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> using DelimitedFiles

julia> x = [1; 2; 3; 4];

julia> y = [5; 6; 7; 8];

julia> open("delim_file.txt", "w") do io
           writedlm(io, [x y])
       end

julia> readdlm("delim_file.txt", '\t', Int, '\n')
4×2 Array{Int64,2}:
 1  5
 2  6
 3  7
 4  8

julia> rm("delim_file.txt")
\end{minted}



\end{adjustwidth}

\hypertarget{18417912811524942081}{}


\chapter{分布式计算}


\hypertarget{2657399037748470653}{} 
\hyperlink{2657399037748470653}{\texttt{Distributed.addprocs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
addprocs(manager::ClusterManager; kwargs...) -> List of process identifiers
\end{minted}

Launches worker processes via the specified cluster manager.

For example, Beowulf clusters are supported via a custom cluster manager implemented in the package \texttt{ClusterManagers.jl}.

The number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable \texttt{JULIA\_WORKER\_TIMEOUT} in the worker process{\textquotesingle}s environment. Relevant only when using TCP/IP as transport.

To launch workers without blocking the REPL, or the containing function if launching workers programmatically, execute \texttt{addprocs} in its own task.

\textbf{Examples}


\begin{lstlisting}
# On busy clusters, call `addprocs` asynchronously
t = @async addprocs(...)
\end{lstlisting}


\begin{lstlisting}
# Utilize workers as and when they come online
if nprocs() > 1   # Ensure at least one new worker is available
   ....   # perform distributed execution
end
\end{lstlisting}


\begin{lstlisting}
# Retrieve newly launched worker IDs, or any error messages
if istaskdone(t)   # Check if `addprocs` has completed to ensure `fetch` doesn't block
    if nworkers() == N
        new_pids = fetch(t)
    else
        fetch(t)
    end
  end
\end{lstlisting}




\begin{lstlisting}
addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers
\end{lstlisting}

Add processes on remote machines via SSH. Requires \texttt{julia} to be installed in the same location on each node, or to be available via a shared file system.

\texttt{machines} is a vector of machine specifications. Workers are started for each specification.

A machine specification is either a string \texttt{machine\_spec} or a tuple - \texttt{(machine\_spec, count)}.

\texttt{machine\_spec} is a string of the form \texttt{[user@]host[:port] [bind\_addr[:port]]}. \texttt{user} defaults to current user, \texttt{port} to the standard ssh port. If \texttt{[bind\_addr[:port]]} is specified, other workers will connect to this worker at the specified \texttt{bind\_addr} and \texttt{port}.

\texttt{count} is the number of workers to be launched on the specified host. If specified as \texttt{:auto} it will launch as many workers as the number of CPU threads on the specific host.

Keyword arguments:

\begin{itemize}
\item \texttt{tunnel}: if \texttt{true} then SSH tunneling will be used to connect to the worker from the master process. Default is \texttt{false}.


\item \texttt{sshflags}: specifies additional ssh options, e.g. \texttt{sshflags=`-i /home/foo/bar.pem}`


\item \texttt{max\_parallel}: specifies the maximum number of workers connected to in parallel at a host. Defaults to 10.


\item \texttt{dir}: specifies the working directory on the workers. Defaults to the host{\textquotesingle}s current directory (as found by \texttt{pwd()})


\item \texttt{enable\_threaded\_blas}: if \texttt{true} then  BLAS will run on multiple threads in added processes. Default is \texttt{false}.


\item \texttt{exename}: name of the \texttt{julia} executable. Defaults to \texttt{{\textquotedbl}\$(Sys.BINDIR)/julia{\textquotedbl}} or \texttt{{\textquotedbl}\$(Sys.BINDIR)/julia-debug{\textquotedbl}} as the case may be.


\item \texttt{exeflags}: additional flags passed to the worker processes.


\item \texttt{topology}: Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.

\begin{itemize}
\item \texttt{topology=:all\_to\_all}: All processes are connected to each other. The default.


\item \texttt{topology=:master\_worker}: Only the driver process, i.e. \texttt{pid} 1 connects to the workers. The workers do not connect to each other.


\item \texttt{topology=:custom}: The \texttt{launch} method of the cluster manager specifies the connection topology via fields \texttt{ident} and \texttt{connect\_idents} in \texttt{WorkerConfig}. A worker with a cluster manager identity \texttt{ident} will connect to all workers specified in \texttt{connect\_idents}.

\end{itemize}

\item \texttt{lazy}: Applicable only with \texttt{topology=:all\_to\_all}. If \texttt{true}, worker-worker connections are setup lazily, i.e. they are setup at the first instance of a remote call between workers. Default is true.

\end{itemize}
Environment variables :

If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal situation and terminates. This timeout can be controlled via environment variable \texttt{JULIA\_WORKER\_TIMEOUT}. The value of \texttt{JULIA\_WORKER\_TIMEOUT} on the master process specifies the number of seconds a newly launched worker waits for connection establishment.




\begin{lstlisting}
addprocs(; kwargs...) -> List of process identifiers
\end{lstlisting}

Equivalent to \texttt{addprocs(Sys.CPU\_THREADS; kwargs...)}

Note that workers do not run a \texttt{.julia/config/startup.jl} startup script, nor do they synchronize their global state (such as global variables, new method definitions, and loaded modules) with any of the other running processes.




\begin{lstlisting}
addprocs(np::Integer; restrict=true, kwargs...) -> List of process identifiers
\end{lstlisting}

Launches workers using the in-built \texttt{LocalManager} which only launches workers on the local host. This can be used to take advantage of multiple cores. \texttt{addprocs(4)} will add 4 processes on the local machine. If \texttt{restrict} is \texttt{true}, binding is restricted to \texttt{127.0.0.1}. Keyword args \texttt{dir}, \texttt{exename}, \texttt{exeflags}, \texttt{topology}, \texttt{lazy} and \texttt{enable\_threaded\_blas} have the same effect as documented for \texttt{addprocs(machines)}.



\end{adjustwidth}
\hypertarget{12624410612036310990}{} 
\hyperlink{12624410612036310990}{\texttt{Distributed.nprocs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nprocs()
\end{minted}

Get the number of available processes.

\textbf{Examples}


\begin{minted}{jlcon}
julia> nprocs()
3

julia> workers()
5-element Array{Int64,1}:
 2
 3
\end{minted}



\end{adjustwidth}
\hypertarget{7237632848154090273}{} 
\hyperlink{7237632848154090273}{\texttt{Distributed.nworkers}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nworkers()
\end{minted}

Get the number of available worker processes. This is one less than \hyperlink{12624410612036310990}{\texttt{nprocs()}}. Equal to \texttt{nprocs()} if \texttt{nprocs() == 1}.

\textbf{Examples}


\begin{minted}{jlcon}
$ julia -p 5

julia> nprocs()
6

julia> nworkers()
5
\end{minted}



\end{adjustwidth}
\hypertarget{10683956780105113822}{} 
\hyperlink{10683956780105113822}{\texttt{Distributed.procs}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
procs()
\end{minted}

Return a list of all process identifiers, including pid 1 (which is not included by \hyperlink{7474509137601932173}{\texttt{workers()}}).

\textbf{Examples}


\begin{minted}{jlcon}
$ julia -p 5

julia> procs()
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



\end{adjustwidth}
\hypertarget{12431527815799129129}{} 
\hyperlink{12431527815799129129}{\texttt{Distributed.procs}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
procs(pid::Integer)
\end{minted}

Return a list of all process identifiers on the same physical node. Specifically all workers bound to the same ip-address as \texttt{pid} are returned.



\end{adjustwidth}
\hypertarget{7474509137601932173}{} 
\hyperlink{7474509137601932173}{\texttt{Distributed.workers}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
workers()
\end{minted}

Return a list of all worker process identifiers.

\textbf{Examples}


\begin{minted}{jlcon}
$ julia -p 5

julia> workers()
2-element Array{Int64,1}:
 2
 3
\end{minted}



\end{adjustwidth}
\hypertarget{16165500032398890398}{} 
\hyperlink{16165500032398890398}{\texttt{Distributed.rmprocs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rmprocs(pids...; waitfor=typemax(Int))
\end{minted}

Remove the specified workers. Note that only process 1 can add or remove workers.

Argument \texttt{waitfor} specifies how long to wait for the workers to shut down:

\begin{itemize}
\item If unspecified, \texttt{rmprocs} will wait until all requested \texttt{pids} are removed.


\item An \hyperlink{12102596058483452470}{\texttt{ErrorException}} is raised if all workers cannot be terminated before the requested \texttt{waitfor} seconds.


\item With a \texttt{waitfor} value of 0, the call returns immediately with the workers scheduled for removal in a different task. The scheduled \hyperlink{7131243650304654155}{\texttt{Task}} object is returned. The user should call \hyperlink{13761789780433862250}{\texttt{wait}} on the task before invoking any other parallel calls.

\end{itemize}
\textbf{Examples}


\begin{minted}{jlcon}
$ julia -p 5

julia> t = rmprocs(2, 3, waitfor=0)
Task (runnable) @0x0000000107c718d0

julia> wait(t)

julia> workers()
3-element Array{Int64,1}:
 4
 5
 6
\end{minted}



\end{adjustwidth}
\hypertarget{15554950403613599151}{} 
\hyperlink{15554950403613599151}{\texttt{Distributed.interrupt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
interrupt(pids::Integer...)
\end{minted}

Interrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.




\begin{lstlisting}
interrupt(pids::AbstractVector=workers())
\end{lstlisting}

Interrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.



\end{adjustwidth}
\hypertarget{15079655651797922234}{} 
\hyperlink{15079655651797922234}{\texttt{Distributed.myid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
myid()
\end{minted}

Get the id of the current process.

\textbf{Examples}


\begin{minted}{jlcon}
julia> myid()
1

julia> remotecall_fetch(() -> myid(), 4)
4
\end{minted}



\end{adjustwidth}
\hypertarget{9432281416771383761}{} 
\hyperlink{9432281416771383761}{\texttt{Distributed.pmap}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pmap(f, [::AbstractWorkerPool], c...; distributed=true, batch_size=1, on_error=nothing, retry_delays=[], retry_check=nothing) -> collection
\end{minted}

Transform collection \texttt{c} by applying \texttt{f} to each element using available workers and tasks.

For multiple collection arguments, apply \texttt{f} elementwise.

Note that \texttt{f} must be made available to all worker processes; see \href{@ref code-availability}{Code Availability and Loading Packages} for details.

If a worker pool is not specified, all available workers, i.e., the default worker pool is used.

By default, \texttt{pmap} distributes the computation over all specified workers. To use only the local process and distribute over tasks, specify \texttt{distributed=false}. This is equivalent to using \hyperlink{14148755671315265621}{\texttt{asyncmap}}. For example, \texttt{pmap(f, c; distributed=false)} is equivalent to \texttt{asyncmap(f,c; ntasks=()->nworkers())}

\texttt{pmap} can also use a mix of processes and tasks via the \texttt{batch\_size} argument. For batch sizes greater than 1, the collection is processed in multiple batches, each of length \texttt{batch\_size} or less. A batch is sent as a single request to a free worker, where a local \hyperlink{14148755671315265621}{\texttt{asyncmap}} processes elements from the batch using multiple concurrent tasks.

Any error stops \texttt{pmap} from processing the remainder of the collection. To override this behavior you can specify an error handling function via argument \texttt{on\_error} which takes in a single argument, i.e., the exception. The function can stop the processing by rethrowing the error, or, to continue, return any value which is then returned inline with the results to the caller.

Consider the following two examples. The first one returns the exception object inline, the second a 0 in place of any exception:


\begin{minted}{jlcon}
julia> pmap(x->iseven(x) ? error("foo") : x, 1:4; on_error=identity)
4-element Array{Any,1}:
 1
  ErrorException("foo")
 3
  ErrorException("foo")

julia> pmap(x->iseven(x) ? error("foo") : x, 1:4; on_error=ex->0)
4-element Array{Int64,1}:
 1
 0
 3
 0
\end{minted}

Errors can also be handled by retrying failed computations. Keyword arguments \texttt{retry\_delays} and \texttt{retry\_check} are passed through to \hyperlink{13615447016541985376}{\texttt{retry}} as keyword arguments \texttt{delays} and \texttt{check} respectively. If batching is specified, and an entire batch fails, all items in the batch are retried.

Note that if both \texttt{on\_error} and \texttt{retry\_delays} are specified, the \texttt{on\_error} hook is called before retrying. If \texttt{on\_error} does not throw (or rethrow) an exception, the element will not be retried.

Example: On errors, retry \texttt{f} on an element a maximum of 3 times without any delay between retries.


\begin{minted}{julia}
pmap(f, c; retry_delays = zeros(3))
\end{minted}

Example: Retry \texttt{f} only if the exception is not of type \hyperlink{5399118524830636312}{\texttt{InexactError}}, with exponentially increasing delays up to 3 times. Return a \texttt{NaN} in place for all \texttt{InexactError} occurrences.


\begin{minted}{julia}
pmap(f, c; on_error = e->(isa(e, InexactError) ? NaN : rethrow()), retry_delays = ExponentialBackOff(n = 3))
\end{minted}



\end{adjustwidth}
\hypertarget{10250718604436154991}{} 
\hyperlink{10250718604436154991}{\texttt{Distributed.RemoteException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RemoteException(captured)
\end{minted}

Exceptions on remote computations are captured and rethrown locally.  A \texttt{RemoteException} wraps the \texttt{pid} of the worker and a captured exception. A \texttt{CapturedException} captures the remote exception and a serializable form of the call stack when the exception was raised.



\end{adjustwidth}
\hypertarget{4170271048165085864}{} 
\hyperlink{4170271048165085864}{\texttt{Distributed.Future}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Future(w::Int, rrid::RRID, v::Union{Some, Nothing}=nothing)
\end{minted}

A \texttt{Future} is a placeholder for a single computation of unknown termination status and time. For multiple potential computations, see \texttt{RemoteChannel}. See \texttt{remoteref\_id} for identifying an \texttt{AbstractRemoteRef}.



\end{adjustwidth}
\hypertarget{16773267780467157552}{} 
\hyperlink{16773267780467157552}{\texttt{Distributed.RemoteChannel}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RemoteChannel(pid::Integer=myid())
\end{minted}

Make a reference to a \texttt{Channel\{Any\}(1)} on process \texttt{pid}. The default \texttt{pid} is the current process.


\begin{lstlisting}
RemoteChannel(f::Function, pid::Integer=myid())
\end{lstlisting}

Create references to remote channels of a specific size and type. \texttt{f} is a function that when executed on \texttt{pid} must return an implementation of an \texttt{AbstractChannel}.

For example, \texttt{RemoteChannel(()->Channel\{Int\}(10), pid)}, will return a reference to a channel of type \texttt{Int} and size 10 on \texttt{pid}.

The default \texttt{pid} is the current process.



\end{adjustwidth}
\hypertarget{16587595157480609141}{} 
\hyperlink{16587595157480609141}{\texttt{Base.fetch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fetch(x::Future)
\end{minted}

Wait for and get the value of a \hyperlink{4170271048165085864}{\texttt{Future}}. The fetched value is cached locally. Further calls to \texttt{fetch} on the same reference return the cached value. If the remote value is an exception, throws a \hyperlink{10250718604436154991}{\texttt{RemoteException}} which captures the remote exception and backtrace.



\end{adjustwidth}
\hypertarget{12485990804056740391}{} 
\hyperlink{12485990804056740391}{\texttt{Base.fetch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fetch(c::RemoteChannel)
\end{minted}

Wait for and get a value from a \hyperlink{16773267780467157552}{\texttt{RemoteChannel}}. Exceptions raised are the same as for a \hyperlink{4170271048165085864}{\texttt{Future}}. Does not remove the item fetched.



\end{adjustwidth}
\hypertarget{16286103980815121272}{} 
\hyperlink{16286103980815121272}{\texttt{Distributed.remotecall}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
remotecall(f, id::Integer, args...; kwargs...) -> Future
\end{minted}

Call a function \texttt{f} asynchronously on the given arguments on the specified process. Return a \hyperlink{4170271048165085864}{\texttt{Future}}. Keyword arguments, if any, are passed through to \texttt{f}.



\end{adjustwidth}
\hypertarget{14331709651005681807}{} 
\hyperlink{14331709651005681807}{\texttt{Distributed.remotecall\_wait}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
remotecall_wait(f, id::Integer, args...; kwargs...)
\end{minted}

Perform a faster \texttt{wait(remotecall(...))} in one message on the \texttt{Worker} specified by worker id \texttt{id}. Keyword arguments, if any, are passed through to \texttt{f}.

See also \hyperlink{13761789780433862250}{\texttt{wait}} and \hyperlink{16286103980815121272}{\texttt{remotecall}}.



\end{adjustwidth}
\hypertarget{14909184572421937971}{} 
\hyperlink{14909184572421937971}{\texttt{Distributed.remotecall\_fetch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
remotecall_fetch(f, id::Integer, args...; kwargs...)
\end{minted}

Perform \texttt{fetch(remotecall(...))} in one message. Keyword arguments, if any, are passed through to \texttt{f}. Any remote exceptions are captured in a \hyperlink{10250718604436154991}{\texttt{RemoteException}} and thrown.

See also \hyperlink{11007884648860062495}{\texttt{fetch}} and \hyperlink{16286103980815121272}{\texttt{remotecall}}.

\textbf{Examples}


\begin{minted}{jlcon}
$ julia -p 2

julia> remotecall_fetch(sqrt, 2, 4)
2.0

julia> remotecall_fetch(sqrt, 2, -4)
ERROR: On worker 2:
DomainError with -4.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
...
\end{minted}



\end{adjustwidth}
\hypertarget{10768474699483765487}{} 
\hyperlink{10768474699483765487}{\texttt{Distributed.remote\_do}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
remote_do(f, id::Integer, args...; kwargs...) -> nothing
\end{minted}

Executes \texttt{f} on worker \texttt{id} asynchronously. Unlike \hyperlink{16286103980815121272}{\texttt{remotecall}}, it does not store the result of computation, nor is there a way to wait for its completion.

A successful invocation indicates that the request has been accepted for execution on the remote node.

While consecutive \texttt{remotecall}s to the same worker are serialized in the order they are invoked, the order of executions on the remote worker is undetermined. For example, \texttt{remote\_do(f1, 2); remotecall(f2, 2); remote\_do(f3, 2)} will serialize the call to \texttt{f1}, followed by \texttt{f2} and \texttt{f3} in that order. However, it is not guaranteed that \texttt{f1} is executed before \texttt{f3} on worker 2.

Any exceptions thrown by \texttt{f} are printed to \hyperlink{6150355911915549172}{\texttt{stderr}} on the remote worker.

Keyword arguments, if any, are passed through to \texttt{f}.



\end{adjustwidth}
\hypertarget{2834687666116026096}{} 
\hyperlink{2834687666116026096}{\texttt{Base.put!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
put!(rr::RemoteChannel, args...)
\end{minted}

Store a set of values to the \hyperlink{16773267780467157552}{\texttt{RemoteChannel}}. If the channel is full, blocks until space is available. Return the first argument.



\end{adjustwidth}
\hypertarget{4609812859110888236}{} 
\hyperlink{4609812859110888236}{\texttt{Base.put!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
put!(rr::Future, v)
\end{minted}

Store a value to a \hyperlink{4170271048165085864}{\texttt{Future}} \texttt{rr}. \texttt{Future}s are write-once remote references. A \texttt{put!} on an already set \texttt{Future} throws an \texttt{Exception}. All asynchronous remote calls return \texttt{Future}s and set the value to the return value of the call upon completion.



\end{adjustwidth}
\hypertarget{1891403764656916697}{} 
\hyperlink{1891403764656916697}{\texttt{Base.take!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
take!(rr::RemoteChannel, args...)
\end{minted}

Fetch value(s) from a \hyperlink{16773267780467157552}{\texttt{RemoteChannel}} \texttt{rr}, removing the value(s) in the process.



\end{adjustwidth}
\hypertarget{6980559591888438300}{} 
\hyperlink{6980559591888438300}{\texttt{Base.isready}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isready(rr::RemoteChannel, args...)
\end{minted}

Determine whether a \hyperlink{16773267780467157552}{\texttt{RemoteChannel}} has a value stored to it. Note that this function can cause race conditions, since by the time you receive its result it may no longer be true. However, it can be safely used on a \hyperlink{4170271048165085864}{\texttt{Future}} since they are assigned only once.



\end{adjustwidth}
\hypertarget{10100315526321712686}{} 
\hyperlink{10100315526321712686}{\texttt{Base.isready}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isready(rr::Future)
\end{minted}

Determine whether a \hyperlink{4170271048165085864}{\texttt{Future}} has a value stored to it.

If the argument \texttt{Future} is owned by a different node, this call will block to wait for the answer. It is recommended to wait for \texttt{rr} in a separate task instead or to use a local \hyperlink{12548845729684045604}{\texttt{Channel}} as a proxy:


\begin{minted}{julia}
p = 1
f = Future(p)
@async put!(f, remotecall_fetch(long_computation, p))
isready(f)  # will not block
\end{minted}



\end{adjustwidth}
\hypertarget{3164386881139700111}{} 
\hyperlink{3164386881139700111}{\texttt{Distributed.AbstractWorkerPool}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractWorkerPool
\end{minted}

Supertype for worker pools such as \hyperlink{17976394752057970100}{\texttt{WorkerPool}} and \hyperlink{8617353702639655725}{\texttt{CachingPool}}. An \texttt{AbstractWorkerPool} should implement:

\begin{itemize}
\item \hyperlink{18026893834387542681}{\texttt{push!}} - add a new worker to the overall pool (available + busy)


\item \hyperlink{12719543094136814100}{\texttt{put!}} - put back a worker to the available pool


\item \hyperlink{4963355246106153560}{\texttt{take!}} - take a worker from the available pool (to be used for remote function execution)


\item \hyperlink{9362803119463040896}{\texttt{length}} - number of workers available in the overall pool


\item \hyperlink{15888554370655089980}{\texttt{isready}} - return false if a \texttt{take!} on the pool would block, else true

\end{itemize}
The default implementations of the above (on a \texttt{AbstractWorkerPool}) require fields

\begin{itemize}
\item \texttt{channel::Channel\{Int\}}


\item \texttt{workers::Set\{Int\}}

\end{itemize}
where \texttt{channel} contains free worker pids and \texttt{workers} is the set of all workers associated with this pool.



\end{adjustwidth}
\hypertarget{17976394752057970100}{} 
\hyperlink{17976394752057970100}{\texttt{Distributed.WorkerPool}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
WorkerPool(workers::Vector{Int})
\end{minted}

Create a \texttt{WorkerPool} from a vector of worker ids.

\textbf{Examples}


\begin{minted}{jlcon}
$ julia -p 3

julia> WorkerPool([2, 3])
WorkerPool(Channel{Int64}(sz_max:9223372036854775807,sz_curr:2), Set([2, 3]), RemoteChannel{Channel{Any}}(1, 1, 6))
\end{minted}



\end{adjustwidth}
\hypertarget{8617353702639655725}{} 
\hyperlink{8617353702639655725}{\texttt{Distributed.CachingPool}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
CachingPool(workers::Vector{Int})
\end{minted}

An implementation of an \texttt{AbstractWorkerPool}. \hyperlink{11837735656545549689}{\texttt{remote}}, \hyperlink{14909184572421937971}{\texttt{remotecall\_fetch}}, \hyperlink{9432281416771383761}{\texttt{pmap}} (and other remote calls which execute functions remotely) benefit from caching the serialized/deserialized functions on the worker nodes, especially closures (which may capture large amounts of data).

The remote cache is maintained for the lifetime of the returned \texttt{CachingPool} object. To clear the cache earlier, use \texttt{clear!(pool)}.

For global variables, only the bindings are captured in a closure, not the data. \texttt{let} blocks can be used to capture global data.

\textbf{Examples}


\begin{minted}{julia}
const foo = rand(10^8);
wp = CachingPool(workers())
let foo = foo
    pmap(wp, i -> sum(foo) + i, 1:100);
end
\end{minted}

The above would transfer \texttt{foo} only once to each worker.



\end{adjustwidth}
\hypertarget{994186287326037532}{} 
\hyperlink{994186287326037532}{\texttt{Distributed.default\_worker\_pool}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
default_worker_pool()
\end{minted}

\hyperlink{17976394752057970100}{\texttt{WorkerPool}} containing idle \hyperlink{7474509137601932173}{\texttt{workers}} - used by \texttt{remote(f)} and \hyperlink{9432281416771383761}{\texttt{pmap}} (by default).

\textbf{Examples}


\begin{minted}{jlcon}
$ julia -p 3

julia> default_worker_pool()
WorkerPool(Channel{Int64}(sz_max:9223372036854775807,sz_curr:3), Set([4, 2, 3]), RemoteChannel{Channel{Any}}(1, 1, 4))
\end{minted}



\end{adjustwidth}
\hypertarget{16881245113854963094}{} 
\hyperlink{16881245113854963094}{\texttt{Distributed.clear!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
clear!(pool::CachingPool) -> pool
\end{minted}

Removes all cached functions from all participating workers.



\end{adjustwidth}
\hypertarget{11837735656545549689}{} 
\hyperlink{11837735656545549689}{\texttt{Distributed.remote}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
remote([p::AbstractWorkerPool], f) -> Function
\end{minted}

Return an anonymous function that executes function \texttt{f} on an available worker (drawn from \hyperlink{17976394752057970100}{\texttt{WorkerPool}} \texttt{p} if provided) using \hyperlink{14909184572421937971}{\texttt{remotecall\_fetch}}.



\end{adjustwidth}
\hypertarget{13826444473261744969}{} 
\hyperlink{13826444473261744969}{\texttt{Distributed.remotecall}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
remotecall(f, pool::AbstractWorkerPool, args...; kwargs...) -> Future
\end{minted}

\hyperlink{17976394752057970100}{\texttt{WorkerPool}} variant of \texttt{remotecall(f, pid, ....)}. Wait for and take a free worker from \texttt{pool} and perform a \texttt{remotecall} on it.

\textbf{Examples}


\begin{minted}{jlcon}
$ julia -p 3

julia> wp = WorkerPool([2, 3]);

julia> A = rand(3000);

julia> f = remotecall(maximum, wp, A)
Future(2, 1, 6, nothing)
\end{minted}

In this example, the task ran on pid 2, called from pid 1.



\end{adjustwidth}
\hypertarget{1493466248843041179}{} 
\hyperlink{1493466248843041179}{\texttt{Distributed.remotecall\_wait}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
remotecall_wait(f, pool::AbstractWorkerPool, args...; kwargs...) -> Future
\end{minted}

\hyperlink{17976394752057970100}{\texttt{WorkerPool}} variant of \texttt{remotecall\_wait(f, pid, ....)}. Wait for and take a free worker from \texttt{pool} and perform a \texttt{remotecall\_wait} on it.

\textbf{Examples}


\begin{minted}{jlcon}
$ julia -p 3

julia> wp = WorkerPool([2, 3]);

julia> A = rand(3000);

julia> f = remotecall_wait(maximum, wp, A)
Future(3, 1, 9, nothing)

julia> fetch(f)
0.9995177101692958
\end{minted}



\end{adjustwidth}
\hypertarget{6431566786299199412}{} 
\hyperlink{6431566786299199412}{\texttt{Distributed.remotecall\_fetch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
remotecall_fetch(f, pool::AbstractWorkerPool, args...; kwargs...) -> result
\end{minted}

\hyperlink{17976394752057970100}{\texttt{WorkerPool}} variant of \texttt{remotecall\_fetch(f, pid, ....)}. Waits for and takes a free worker from \texttt{pool} and performs a \texttt{remotecall\_fetch} on it.

\textbf{Examples}


\begin{minted}{jlcon}
$ julia -p 3

julia> wp = WorkerPool([2, 3]);

julia> A = rand(3000);

julia> remotecall_fetch(maximum, wp, A)
0.9995177101692958
\end{minted}



\end{adjustwidth}
\hypertarget{9355776911888896083}{} 
\hyperlink{9355776911888896083}{\texttt{Distributed.remote\_do}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
remote_do(f, pool::AbstractWorkerPool, args...; kwargs...) -> nothing
\end{minted}

\hyperlink{17976394752057970100}{\texttt{WorkerPool}} variant of \texttt{remote\_do(f, pid, ....)}. Wait for and take a free worker from \texttt{pool} and perform a \texttt{remote\_do} on it.



\end{adjustwidth}
\hypertarget{11231712027010946923}{} 
\hyperlink{11231712027010946923}{\texttt{Distributed.@spawnat}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@spawnat p expr
\end{minted}

Create a closure around an expression and run the closure asynchronously on process \texttt{p}. Return a \hyperlink{4170271048165085864}{\texttt{Future}} to the result. If \texttt{p} is the quoted literal symbol \texttt{:any}, then the system will pick a processor to use automatically.

\textbf{Examples}


\begin{minted}{jlcon}
julia> addprocs(3);

julia> f = @spawnat 2 myid()
Future(2, 1, 3, nothing)

julia> fetch(f)
2

julia> f = @spawnat :any myid()
Future(3, 1, 7, nothing)

julia> fetch(f)
3
\end{minted}

\begin{quote}
\textbf{Julia 1.3}

The \texttt{:any} argument is available as of Julia 1.3.

\end{quote}


\end{adjustwidth}
\hypertarget{12924100318586144753}{} 
\hyperlink{12924100318586144753}{\texttt{Distributed.@fetch}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@fetch expr
\end{minted}

Equivalent to \texttt{fetch(@spawnat :any expr)}. See \hyperlink{11007884648860062495}{\texttt{fetch}} and \hyperlink{11231712027010946923}{\texttt{@spawnat}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> addprocs(3);

julia> @fetch myid()
2

julia> @fetch myid()
3

julia> @fetch myid()
4

julia> @fetch myid()
2
\end{minted}



\end{adjustwidth}
\hypertarget{4668231420319368373}{} 
\hyperlink{4668231420319368373}{\texttt{Distributed.@fetchfrom}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@fetchfrom
\end{minted}

Equivalent to \texttt{fetch(@spawnat p expr)}. See \hyperlink{11007884648860062495}{\texttt{fetch}} and \hyperlink{11231712027010946923}{\texttt{@spawnat}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> addprocs(3);

julia> @fetchfrom 2 myid()
2

julia> @fetchfrom 4 myid()
4
\end{minted}



\end{adjustwidth}
\hypertarget{4581929266257108937}{} 
\hyperlink{4581929266257108937}{\texttt{Distributed.@distributed}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@distributed
\end{minted}

A distributed memory, parallel for loop of the form :


\begin{lstlisting}
@distributed [reducer] for var = range
    body
end
\end{lstlisting}

The specified range is partitioned and locally executed across all workers. In case an optional reducer function is specified, \texttt{@distributed} performs local reductions on each worker with a final reduction on the calling process.

Note that without a reducer function, \texttt{@distributed} executes asynchronously, i.e. it spawns independent tasks on all available workers and returns immediately without waiting for completion. To wait for completion, prefix the call with \hyperlink{7188613740509403855}{\texttt{@sync}}, like :


\begin{lstlisting}
@sync @distributed for var = range
    body
end
\end{lstlisting}



\end{adjustwidth}
\hypertarget{4972064255482407966}{} 
\hyperlink{4972064255482407966}{\texttt{Distributed.@everywhere}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@everywhere [procs()] expr
\end{minted}

Execute an expression under \texttt{Main} on all \texttt{procs}. Errors on any of the processes are collected into a \hyperlink{15047752250898038281}{\texttt{CompositeException}} and thrown. For example:


\begin{lstlisting}
@everywhere bar = 1
\end{lstlisting}

will define \texttt{Main.bar} on all processes.

Unlike \hyperlink{11231712027010946923}{\texttt{@spawnat}}, \texttt{@everywhere} does not capture any local variables. Instead, local variables can be broadcast using interpolation:


\begin{lstlisting}
foo = 1
@everywhere bar = $foo
\end{lstlisting}

The optional argument \texttt{procs} allows specifying a subset of all processes to have execute the expression.

Equivalent to calling \texttt{remotecall\_eval(Main, procs, expr)}.



\end{adjustwidth}
\hypertarget{13290730966976452315}{} 
\hyperlink{13290730966976452315}{\texttt{Distributed.clear!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
clear!(syms, pids=workers(); mod=Main)
\end{minted}

Clears global bindings in modules by initializing them to \texttt{nothing}. \texttt{syms} should be of type \hyperlink{18332791376992528422}{\texttt{Symbol}} or a collection of \texttt{Symbol}s . \texttt{pids} and \texttt{mod} identify the processes and the module in which global variables are to be reinitialized. Only those names found to be defined under \texttt{mod} are cleared.

An exception is raised if a global constant is requested to be cleared.



\end{adjustwidth}
\hypertarget{10046899291571146856}{} 
\hyperlink{10046899291571146856}{\texttt{Distributed.remoteref\_id}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
remoteref_id(r::AbstractRemoteRef) -> RRID
\end{minted}

\texttt{Future}s and \texttt{RemoteChannel}s are identified by fields:

\begin{itemize}
\item \texttt{where} - refers to the node where the underlying object/storage referred to by the reference actually exists.


\item \texttt{whence} - refers to the node the remote reference was created from. Note that this is different from the node where the underlying object referred to actually exists. For example calling \texttt{RemoteChannel(2)} from the master process would result in a \texttt{where} value of 2 and a \texttt{whence} value of 1.


\item \texttt{id} is unique across all references created from the worker specified by \texttt{whence}.

\end{itemize}
Taken together,  \texttt{whence} and \texttt{id} uniquely identify a reference across all workers.

\texttt{remoteref\_id} is a low-level API which returns a \texttt{RRID} object that wraps \texttt{whence} and \texttt{id} values of a remote reference.



\end{adjustwidth}
\hypertarget{5007915834563819885}{} 
\hyperlink{5007915834563819885}{\texttt{Distributed.channel\_from\_id}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
channel_from_id(id) -> c
\end{minted}

A low-level API which returns the backing \texttt{AbstractChannel} for an \texttt{id} returned by \hyperlink{10046899291571146856}{\texttt{remoteref\_id}}. The call is valid only on the node where the backing channel exists.



\end{adjustwidth}
\hypertarget{806684110794204081}{} 
\hyperlink{806684110794204081}{\texttt{Distributed.worker\_id\_from\_socket}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
worker_id_from_socket(s) -> pid
\end{minted}

A low-level API which, given a \texttt{IO} connection or a \texttt{Worker}, returns the \texttt{pid} of the worker it is connected to. This is useful when writing custom \hyperlink{17931089632175850899}{\texttt{serialize}} methods for a type, which optimizes the data written out depending on the receiving process id.



\end{adjustwidth}
\hypertarget{914110747490695974}{} 
\hyperlink{914110747490695974}{\texttt{Distributed.cluster\_cookie}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cluster_cookie() -> cookie
\end{minted}

Return the cluster cookie.



\end{adjustwidth}
\hypertarget{7078615008605512632}{} 
\hyperlink{7078615008605512632}{\texttt{Distributed.cluster\_cookie}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cluster_cookie(cookie) -> cookie
\end{minted}

Set the passed cookie as the cluster cookie, then returns it.



\end{adjustwidth}

\hypertarget{6819108494041220011}{}


\section{Cluster Manager Interface}



This interface provides a mechanism to launch and manage Julia workers on different cluster environments. There are two types of managers present in Base: \texttt{LocalManager}, for launching additional workers on the same host, and \texttt{SSHManager}, for launching on remote hosts via \texttt{ssh}. TCP/IP sockets are used to connect and transport messages between processes. It is possible for Cluster Managers to provide a different transport.


\hypertarget{1673650075671996993}{} 
\hyperlink{1673650075671996993}{\texttt{Distributed.ClusterManager}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ClusterManager
\end{minted}

Supertype for cluster managers, which control workers processes as a cluster. Cluster managers implement how workers can be added, removed and communicated with. \texttt{SSHManager} and \texttt{LocalManager} are subtypes of this.



\end{adjustwidth}
\hypertarget{3351347791553517124}{} 
\hyperlink{3351347791553517124}{\texttt{Distributed.WorkerConfig}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
WorkerConfig
\end{minted}

Type used by \hyperlink{1673650075671996993}{\texttt{ClusterManager}}s to control workers added to their clusters. Some fields are used by all cluster managers to access a host:

\begin{itemize}
\item \texttt{io} – the connection used to access the worker (a subtype of \texttt{IO} or \texttt{Nothing})


\item \texttt{host} – the host address (either an \texttt{AbstractString} or \texttt{Nothing})


\item \texttt{port} – the port on the host used to connect to the worker (either an \texttt{Int} or \texttt{Nothing})

\end{itemize}
Some are used by the cluster manager to add workers to an already-initialized host:

\begin{itemize}
\item \texttt{count} – the number of workers to be launched on the host


\item \texttt{exename} – the path to the Julia executable on the host, defaults to \texttt{{\textquotedbl}\$(Sys.BINDIR)/julia{\textquotedbl}} or \texttt{{\textquotedbl}\$(Sys.BINDIR)/julia-debug{\textquotedbl}}


\item \texttt{exeflags} – flags to use when lauching Julia remotely

\end{itemize}
The \texttt{userdata} field is used to store information for each worker by external managers.

Some fields are used by \texttt{SSHManager} and similar managers:

\begin{itemize}
\item \texttt{tunnel} – \texttt{true} (use tunneling), \texttt{false} (do not use tunneling), or \hyperlink{9331422207248206047}{\texttt{nothing}} (use default for the manager)


\item \texttt{bind\_addr} – the address on the remote host to bind to


\item \texttt{sshflags} – flags to use in establishing the SSH connection


\item \texttt{max\_parallel} – the maximum number of workers to connect to in parallel on the host

\end{itemize}
Some fields are used by both \texttt{LocalManager}s and \texttt{SSHManager}s:

\begin{itemize}
\item \texttt{connect\_at} – determines whether this is a worker-to-worker or driver-to-worker setup call


\item \texttt{process} – the process which will be connected (usually the manager will assign this during \hyperlink{2657399037748470653}{\texttt{addprocs}})


\item \texttt{ospid} – the process ID according to the host OS, used to interrupt worker processes


\item \texttt{environ} – private dictionary used to store temporary information by Local/SSH managers


\item \texttt{ident} – worker as identified by the \hyperlink{1673650075671996993}{\texttt{ClusterManager}}


\item \texttt{connect\_idents} – list of worker ids the worker must connect to if using a custom topology


\item \texttt{enable\_threaded\_blas} – \texttt{true}, \texttt{false}, or \texttt{nothing}, whether to use threaded BLAS or not on the workers

\end{itemize}


\end{adjustwidth}
\hypertarget{7346188534454273843}{} 
\hyperlink{7346188534454273843}{\texttt{Distributed.launch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
launch(manager::ClusterManager, params::Dict, launched::Array, launch_ntfy::Condition)
\end{minted}

Implemented by cluster managers. For every Julia worker launched by this function, it should append a \texttt{WorkerConfig} entry to \texttt{launched} and notify \texttt{launch\_ntfy}. The function MUST exit once all workers, requested by \texttt{manager} have been launched. \texttt{params} is a dictionary of all keyword arguments \hyperlink{2657399037748470653}{\texttt{addprocs}} was called with.



\end{adjustwidth}
\hypertarget{8462349151012734144}{} 
\hyperlink{8462349151012734144}{\texttt{Distributed.manage}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
manage(manager::ClusterManager, id::Integer, config::WorkerConfig. op::Symbol)
\end{minted}

Implemented by cluster managers. It is called on the master process, during a worker{\textquotesingle}s lifetime, with appropriate \texttt{op} values:

\begin{itemize}
\item with \texttt{:register}/\texttt{:deregister} when a worker is added / removed from the Julia worker pool.


\item with \texttt{:interrupt} when \texttt{interrupt(workers)} is called. The \texttt{ClusterManager} should signal the appropriate worker with an interrupt signal.


\item with \texttt{:finalize} for cleanup purposes.

\end{itemize}


\end{adjustwidth}
\hypertarget{17836284879339877528}{} 
\hyperlink{17836284879339877528}{\texttt{Base.kill}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
kill(manager::ClusterManager, pid::Int, config::WorkerConfig)
\end{minted}

Implemented by cluster managers. It is called on the master process, by \hyperlink{16165500032398890398}{\texttt{rmprocs}}. It should cause the remote worker specified by \texttt{pid} to exit. \texttt{kill(manager::ClusterManager.....)} executes a remote \texttt{exit()} on \texttt{pid}.



\end{adjustwidth}
\hypertarget{9743233285520657275}{} 
\hyperlink{9743233285520657275}{\texttt{Sockets.connect}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
connect(manager::ClusterManager, pid::Int, config::WorkerConfig) -> (instrm::IO, outstrm::IO)
\end{minted}

Implemented by cluster managers using custom transports. It should establish a logical connection to worker with id \texttt{pid}, specified by \texttt{config} and return a pair of \texttt{IO} objects. Messages from \texttt{pid} to current process will be read off \texttt{instrm}, while messages to be sent to \texttt{pid} will be written to \texttt{outstrm}. The custom transport implementation must ensure that messages are delivered and received completely and in order. \texttt{connect(manager::ClusterManager.....)} sets up TCP/IP socket connections in-between workers.



\end{adjustwidth}
\hypertarget{12889811459778306363}{} 
\hyperlink{12889811459778306363}{\texttt{Distributed.init\_worker}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
init_worker(cookie::AbstractString, manager::ClusterManager=DefaultClusterManager())
\end{minted}

Called by cluster managers implementing custom transports. It initializes a newly launched process as a worker. Command line argument \texttt{--worker[=<cookie>]} has the effect of initializing a process as a worker using TCP/IP sockets for transport. \texttt{cookie} is a \hyperlink{914110747490695974}{\texttt{cluster\_cookie}}.



\end{adjustwidth}
\hypertarget{3765538736204641537}{} 
\hyperlink{3765538736204641537}{\texttt{Distributed.start\_worker}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
start_worker([out::IO=stdout], cookie::AbstractString=readline(stdin); close_stdin::Bool=true, stderr_to_stdout::Bool=true)
\end{minted}

\texttt{start\_worker} is an internal function which is the default entry point for worker processes connecting via TCP/IP. It sets up the process as a Julia cluster worker.

host:port information is written to stream \texttt{out} (defaults to stdout).

The function reads the cookie from stdin if required, and  listens on a free port (or if specified, the port in the \texttt{--bind-to} command line option) and schedules tasks to process incoming TCP connections and requests. It also (optionally) closes stdin and redirects stderr to stdout.

It does not return.



\end{adjustwidth}
\hypertarget{3971171154765725829}{} 
\hyperlink{3971171154765725829}{\texttt{Distributed.process\_messages}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
process_messages(r_stream::IO, w_stream::IO, incoming::Bool=true)
\end{minted}

Called by cluster managers using custom transports. It should be called when the custom transport implementation receives the first message from a remote worker. The custom transport must manage a logical connection to the remote worker and provide two \texttt{IO} objects, one for incoming messages and the other for messages addressed to the remote worker. If \texttt{incoming} is \texttt{true}, the remote peer initiated the connection. Whichever of the pair initiates the connection sends the cluster cookie and its Julia version number to perform the authentication handshake.

See also \hyperlink{914110747490695974}{\texttt{cluster\_cookie}}.



\end{adjustwidth}

\hypertarget{4477435705340973602}{}


\chapter{文件相关事件}


\hypertarget{4018465060202185434}{} 
\hyperlink{4018465060202185434}{\texttt{FileWatching.poll\_fd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
poll_fd(fd, timeout_s::Real=-1; readable=false, writable=false)
\end{minted}

Monitor a file descriptor \texttt{fd} for changes in the read or write availability, and with a timeout given by \texttt{timeout\_s} seconds.

The keyword arguments determine which of read and/or write status should be monitored; at least one of them must be set to \texttt{true}.

The returned value is an object with boolean fields \texttt{readable}, \texttt{writable}, and \texttt{timedout}, giving the result of the polling.



\end{adjustwidth}
\hypertarget{16623395181067730756}{} 
\hyperlink{16623395181067730756}{\texttt{FileWatching.poll\_file}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
poll_file(path::AbstractString, interval_s::Real=5.007, timeout_s::Real=-1) -> (previous::StatStruct, current)
\end{minted}

Monitor a file for changes by polling every \texttt{interval\_s} seconds until a change occurs or \texttt{timeout\_s} seconds have elapsed. The \texttt{interval\_s} should be a long period; the default is 5.007 seconds.

Returns a pair of status objects \texttt{(previous, current)} when a change is detected. The \texttt{previous} status is always a \texttt{StatStruct}, but it may have all of the fields zeroed (indicating the file didn{\textquotesingle}t previously exist, or wasn{\textquotesingle}t previously accessible).

The \texttt{current} status object may be a \texttt{StatStruct}, an \texttt{EOFError} (indicating the timeout elapsed), or some other \texttt{Exception} subtype (if the \texttt{stat} operation failed - for example, if the path does not exist).

To determine when a file was modified, compare \texttt{current isa StatStruct \&\& mtime(prev) != mtime(current)} to detect notification of changes. However, using \hyperlink{9407226289289061636}{\texttt{watch\_file}} for this operation is preferred, since it is more reliable and efficient, although in some situations it may not be available.



\end{adjustwidth}
\hypertarget{9407226289289061636}{} 
\hyperlink{9407226289289061636}{\texttt{FileWatching.watch\_file}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
watch_file(path::AbstractString, timeout_s::Real=-1)
\end{minted}

Watch file or directory \texttt{path} for changes until a change occurs or \texttt{timeout\_s} seconds have elapsed.

The returned value is an object with boolean fields \texttt{changed}, \texttt{renamed}, and \texttt{timedout}, giving the result of watching the file.

This behavior of this function varies slightly across platforms. See \href{https://nodejs.org/api/fs.html\#fs\_caveats}{https://nodejs.org/api/fs.html\#fs\_caveats} for more detailed information.



\end{adjustwidth}
\hypertarget{3977882412787158374}{} 
\hyperlink{3977882412787158374}{\texttt{FileWatching.watch\_folder}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
watch_folder(path::AbstractString, timeout_s::Real=-1)
\end{minted}

Watches a file or directory \texttt{path} for changes until a change has occurred or \texttt{timeout\_s} seconds have elapsed.

This will continuing tracking changes for \texttt{path} in the background until \texttt{unwatch\_folder} is called on the same \texttt{path}.

The returned value is an pair where the first field is the name of the changed file (if available) and the second field is an object with boolean fields \texttt{changed}, \texttt{renamed}, and \texttt{timedout}, giving the event.

This behavior of this function varies slightly across platforms. See \href{https://nodejs.org/api/fs.html\#fs\_caveats}{https://nodejs.org/api/fs.html\#fs\_caveats} for more detailed information.



\end{adjustwidth}
\hypertarget{18277052083824325968}{} 
\hyperlink{18277052083824325968}{\texttt{FileWatching.unwatch\_folder}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unwatch_folder(path::AbstractString)
\end{minted}

Stop background tracking of changes for \texttt{path}. It is not recommended to do this while another task is waiting for \texttt{watch\_folder} to return on the same path, as the result may be unpredictable.



\end{adjustwidth}

\hypertarget{5035560459599416721}{}


\chapter{交互式组件}


\hypertarget{6069714544176255543}{} 
\hyperlink{6069714544176255543}{\texttt{Base.Docs.apropos}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
apropos(string)
\end{minted}

Search through all documentation for a string, ignoring case.



\end{adjustwidth}
\hypertarget{18269429703422902914}{} 
\hyperlink{18269429703422902914}{\texttt{InteractiveUtils.varinfo}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
varinfo(m::Module=Main, pattern::Regex=r"")
\end{minted}

Return a markdown table giving information about exported global variables in a module, optionally restricted to those matching \texttt{pattern}.

The memory consumption estimate is an approximate lower bound on the size of the internal structure of the object.



\end{adjustwidth}
\hypertarget{11698106121547091928}{} 
\hyperlink{11698106121547091928}{\texttt{InteractiveUtils.versioninfo}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
versioninfo(io::IO=stdout; verbose::Bool=false)
\end{minted}

Print information about the version of Julia in use. The output is controlled with boolean keyword arguments:

\begin{itemize}
\item \texttt{verbose}: print all additional information

\end{itemize}


\end{adjustwidth}
\hypertarget{1845157398882896709}{} 
\hyperlink{1845157398882896709}{\texttt{InteractiveUtils.methodswith}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
methodswith(typ[, module or function]; supertypes::Bool=false])
\end{minted}

Return an array of methods with an argument of type \texttt{typ}.

The optional second argument restricts the search to a particular module or function (the default is all top-level modules).

If keyword \texttt{supertypes} is \texttt{true}, also return arguments with a parent type of \texttt{typ}, excluding type \texttt{Any}.



\end{adjustwidth}
\hypertarget{13112219412833772146}{} 
\hyperlink{13112219412833772146}{\texttt{InteractiveUtils.subtypes}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
subtypes(T::DataType)
\end{minted}

Return a list of immediate subtypes of DataType \texttt{T}. Note that all currently loaded subtypes are included, including those not visible in the current module.

\textbf{Examples}


\begin{minted}{jlcon}
julia> subtypes(Integer)
3-element Array{Any,1}:
 Bool
 Signed
 Unsigned
\end{minted}



\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{InteractiveUtils.supertypes}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{10268751953828531961}{} 
\hyperlink{10268751953828531961}{\texttt{InteractiveUtils.edit}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
edit(path::AbstractString, line::Integer=0)
\end{minted}

Edit a file or directory optionally providing a line number to edit the file at. Return to the \texttt{julia} prompt when you quit the editor. The editor can be changed by setting \texttt{JULIA\_EDITOR}, \texttt{VISUAL} or \texttt{EDITOR} as an environment variable.

See also: (\texttt{define\_editor})[@ref]



\end{adjustwidth}
\hypertarget{5817135015306723574}{} 
\hyperlink{5817135015306723574}{\texttt{InteractiveUtils.edit}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
edit(function, [types])
edit(module)
\end{minted}

Edit the definition of a function, optionally specifying a tuple of types to indicate which method to edit. For modules, open the main source file. The module needs to be loaded with \texttt{using} or \texttt{import} first.

\begin{quote}
\textbf{Julia 1.1}

\texttt{edit} on modules requires at least Julia 1.1.

\end{quote}
To ensure that the file can be opened at the given line, you may need to call \texttt{define\_editor} first.



\end{adjustwidth}
\hypertarget{15808508619915684107}{} 
\hyperlink{15808508619915684107}{\texttt{InteractiveUtils.@edit}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@edit
\end{minted}

Evaluates the arguments to the function or macro call, determines their types, and calls the \texttt{edit} function on the resulting expression.



\end{adjustwidth}
\hypertarget{7329923191421757530}{} 
\hyperlink{7329923191421757530}{\texttt{InteractiveUtils.define\_editor}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
define_editor(fn, pattern; wait=false)
\end{minted}

Define a new editor matching \texttt{pattern} that can be used to open a file (possibly at a given line number) using \texttt{fn}.

The \texttt{fn} argument is a function that determines how to open a file with the given editor. It should take three arguments, as follows:

\begin{itemize}
\item \texttt{cmd} - a base command object for the editor


\item \texttt{path} - the path to the source file to open


\item \texttt{line} - the line number to open the editor at

\end{itemize}
Editors which cannot open to a specific line with a command may ignore the \texttt{line} argument. The \texttt{fn} callback must return either an appropriate \texttt{Cmd} object to open a file or \texttt{nothing} to indicate that they cannot edit this file. Use \texttt{nothing} to indicate that this editor is not appropriate for the current environment and another editor should be attempted. It is possible to add more general editing hooks that need not spawn external commands by pushing a callback directly to the vector \texttt{EDITOR\_CALLBACKS}.

The \texttt{pattern} argument is a string, regular expression, or an array of strings and regular expressions. For the \texttt{fn} to be called, one of the patterns must match the value of \texttt{EDITOR}, \texttt{VISUAL} or \texttt{JULIA\_EDITOR}. For strings, the string must equal the \hyperlink{16452154606861459390}{\texttt{basename}} of the first word of the editor command, with its extension, if any, removed. E.g. {\textquotedbl}vi{\textquotedbl} doesn{\textquotesingle}t match {\textquotedbl}vim -g{\textquotedbl} but matches {\textquotedbl}/usr/bin/vi -m{\textquotedbl}; it also matches \texttt{vi.exe}. If \texttt{pattern} is a regex it is matched against all of the editor command as a shell-escaped string. An array pattern matches if any of its items match. If multiple editors match, the one added most recently is used.

By default julia does not wait for the editor to close, running it in the background. However, if the editor is terminal based, you will probably want to set \texttt{wait=true} and julia will wait for the editor to close before resuming.

If one of the editor environment variables is set, but no editor entry matches it, the default editor entry is invoked:


\begin{lstlisting}
(cmd, path, line) -> `$cmd $path`
\end{lstlisting}

Note that many editors are already defined. All of the following commands should already work:

\begin{itemize}
\item emacs


\item vim


\item nvim


\item nano


\item textmate


\item mate


\item kate


\item subl


\item atom


\item notepad++


\item Visual Studio Code


\item open


\item pycharm

\end{itemize}
\textbf{Example:}

The following defines the usage of terminal-based \texttt{emacs}:


\begin{lstlisting}
define_editor(
    r"\bemacs\b.*\s(-nw|--no-window-system)\b", wait=true) do cmd, path, line
    `$cmd +$line $path`
end
\end{lstlisting}

\begin{quote}
\textbf{Julia 1.4}

\texttt{define\_editor} was introduced in Julia 1.4.

\end{quote}


\end{adjustwidth}
\hypertarget{449855233258666437}{} 
\hyperlink{449855233258666437}{\texttt{InteractiveUtils.less}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
less(file::AbstractString, [line::Integer])
\end{minted}

Show a file using the default pager, optionally providing a starting line number. Returns to the \texttt{julia} prompt when you quit the pager.



\end{adjustwidth}
\hypertarget{16005681522948418287}{} 
\hyperlink{16005681522948418287}{\texttt{InteractiveUtils.less}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
less(function, [types])
\end{minted}

Show the definition of a function using the default pager, optionally specifying a tuple of types to indicate which method to see.



\end{adjustwidth}
\hypertarget{8935326068247481160}{} 
\hyperlink{8935326068247481160}{\texttt{InteractiveUtils.@less}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@less
\end{minted}

Evaluates the arguments to the function or macro call, determines their types, and calls the \texttt{less} function on the resulting expression.



\end{adjustwidth}
\hypertarget{5196080466457876497}{} 
\hyperlink{5196080466457876497}{\texttt{InteractiveUtils.@which}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@which
\end{minted}

Applied to a function or macro call, it evaluates the arguments to the specified call, and returns the \texttt{Method} object for the method that would be called for those arguments. Applied to a variable, it returns the module in which the variable was bound. It calls out to the \texttt{which} function.



\end{adjustwidth}
\hypertarget{12812718888833665191}{} 
\hyperlink{12812718888833665191}{\texttt{InteractiveUtils.@functionloc}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@functionloc
\end{minted}

Applied to a function or macro call, it evaluates the arguments to the specified call, and returns a tuple \texttt{(filename,line)} giving the location for the method that would be called for those arguments. It calls out to the \texttt{functionloc} function.



\end{adjustwidth}
\hypertarget{1376948972689074219}{} 
\hyperlink{1376948972689074219}{\texttt{InteractiveUtils.@code\_lowered}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@code_lowered
\end{minted}

Evaluates the arguments to the function or macro call, determines their types, and calls \hyperlink{18235967286596219009}{\texttt{code\_lowered}} on the resulting expression.



\end{adjustwidth}
\hypertarget{6823997547688846780}{} 
\hyperlink{6823997547688846780}{\texttt{InteractiveUtils.@code\_typed}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@code_typed
\end{minted}

Evaluates the arguments to the function or macro call, determines their types, and calls \hyperlink{14801595959157535515}{\texttt{code\_typed}} on the resulting expression. Use the optional argument \texttt{optimize} with


\begin{lstlisting}
@code_typed optimize=true foo(x)
\end{lstlisting}

to control whether additional optimizations, such as inlining, are also applied.



\end{adjustwidth}
\hypertarget{5565852192659724503}{} 
\hyperlink{5565852192659724503}{\texttt{InteractiveUtils.code\_warntype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
code_warntype([io::IO], f, types; debuginfo=:default)
\end{minted}

Prints lowered and type-inferred ASTs for the methods matching the given generic function and type signature to \texttt{io} which defaults to \texttt{stdout}. The ASTs are annotated in such a way as to cause {\textquotedbl}non-leaf{\textquotedbl} types to be emphasized (if color is available, displayed in red). This serves as a warning of potential type instability. Not all non-leaf types are particularly problematic for performance, so the results need to be used judiciously. In particular, unions containing either \hyperlink{14596725676261444434}{\texttt{missing}} or \hyperlink{9331422207248206047}{\texttt{nothing}} are displayed in yellow, since these are often intentional.

Keyword argument \texttt{debuginfo} may be one of \texttt{:source} or \texttt{:none} (default), to specify the verbosity of code comments.

See \hyperlink{7310642359836438564}{\texttt{@code\_warntype}} for more information.



\end{adjustwidth}
\hypertarget{8092893264277772840}{} 
\hyperlink{8092893264277772840}{\texttt{InteractiveUtils.@code\_warntype}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@code_warntype
\end{minted}

Evaluates the arguments to the function or macro call, determines their types, and calls \hyperlink{5565852192659724503}{\texttt{code\_warntype}} on the resulting expression.



\end{adjustwidth}
\hypertarget{1749471484368489435}{} 
\hyperlink{1749471484368489435}{\texttt{InteractiveUtils.code\_llvm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
code_llvm([io=stdout,], f, types; raw=false, dump_module=false, optimize=true, debuginfo=:default)
\end{minted}

Prints the LLVM bitcodes generated for running the method matching the given generic function and type signature to \texttt{io}.

If the \texttt{optimize} keyword is unset, the code will be shown before LLVM optimizations. All metadata and dbg.* calls are removed from the printed bitcode. For the full IR, set the \texttt{raw} keyword to true. To dump the entire module that encapsulates the function (with declarations), set the \texttt{dump\_module} keyword to true. Keyword argument \texttt{debuginfo} may be one of source (default) or none, to specify the verbosity of code comments.



\end{adjustwidth}
\hypertarget{18039596607712979441}{} 
\hyperlink{18039596607712979441}{\texttt{InteractiveUtils.@code\_llvm}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@code_llvm
\end{minted}

Evaluates the arguments to the function or macro call, determines their types, and calls \hyperlink{1749471484368489435}{\texttt{code\_llvm}} on the resulting expression. Set the optional keyword arguments \texttt{raw}, \texttt{dump\_module}, \texttt{debuginfo}, \texttt{optimize} by putting them and their value before the function call, like this:


\begin{lstlisting}
@code_llvm raw=true dump_module=true debuginfo=:default f(x)
@code_llvm optimize=false f(x)
\end{lstlisting}

\texttt{optimize} controls whether additional optimizations, such as inlining, are also applied. \texttt{raw} makes all metadata and dbg.* calls visible. \texttt{debuginfo} may be one of \texttt{:source} (default) or \texttt{:none},  to specify the verbosity of code comments. \texttt{dump\_module} prints the entire module that encapsulates the function.



\end{adjustwidth}
\hypertarget{2534314152947301270}{} 
\hyperlink{2534314152947301270}{\texttt{InteractiveUtils.code\_native}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
code_native([io=stdout,], f, types; syntax=:att, debuginfo=:default)
\end{minted}

Prints the native assembly instructions generated for running the method matching the given generic function and type signature to \texttt{io}. Switch assembly syntax using \texttt{syntax} symbol parameter set to \texttt{:att} for AT\&T syntax or \texttt{:intel} for Intel syntax. Keyword argument \texttt{debuginfo} may be one of source (default) or none, to specify the verbosity of code comments.



\end{adjustwidth}
\hypertarget{2629340111434042067}{} 
\hyperlink{2629340111434042067}{\texttt{InteractiveUtils.@code\_native}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@code_native
\end{minted}

Evaluates the arguments to the function or macro call, determines their types, and calls \hyperlink{2534314152947301270}{\texttt{code\_native}} on the resulting expression.

Set the optional keyword argument \texttt{debuginfo} by putting it before the function call, like this:


\begin{lstlisting}
@code_native debuginfo=:default f(x)
\end{lstlisting}

\texttt{debuginfo} may be one of \texttt{:source} (default) or \texttt{:none}, to specify the verbosity of code comments.



\end{adjustwidth}
\hypertarget{17688389159658604177}{} 
\hyperlink{17688389159658604177}{\texttt{InteractiveUtils.clipboard}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
clipboard(x)
\end{minted}

Send a printed form of \texttt{x} to the operating system clipboard ({\textquotedbl}copy{\textquotedbl}).




\begin{lstlisting}
clipboard() -> AbstractString
\end{lstlisting}

Return a string with the contents of the operating system clipboard ({\textquotedbl}paste{\textquotedbl}).



\end{adjustwidth}

\hypertarget{14272245692301851811}{}


\chapter{LibGit2}



The LibGit2 module provides bindings to \href{https://libgit2.org/}{libgit2}, a portable C library that implements core functionality for the \href{https://git-scm.com/}{Git} version control system. These bindings are currently used to power Julia{\textquotesingle}s package manager. It is expected that this module will eventually be moved into a separate package.



\hypertarget{13716495418266911399}{}


\subsection{Functionality}



Some of this documentation assumes some prior knowledge of the libgit2 API. For more information on some of the objects and methods referenced here, consult the upstream \href{https://libgit2.org/libgit2/\#v0.25.1}{libgit2 API reference}.


\hypertarget{6862256905288214016}{} 
\hyperlink{6862256905288214016}{\texttt{LibGit2.Buffer}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.Buffer
\end{minted}

A data buffer for exporting data from libgit2. Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_buf}{\texttt{git\_buf}} struct.

When fetching data from LibGit2, a typical usage would look like:


\begin{minted}{julia}
buf_ref = Ref(Buffer())
@check ccall(..., (Ptr{Buffer},), buf_ref)
# operation on buf_ref
free(buf_ref)
\end{minted}

In particular, note that \texttt{LibGit2.free} should be called afterward on the \texttt{Ref} object.



\end{adjustwidth}
\hypertarget{16441061243067746546}{} 
\hyperlink{16441061243067746546}{\texttt{LibGit2.CheckoutOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.CheckoutOptions
\end{minted}

Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_checkout\_options}{\texttt{git\_checkout\_options}} struct.

The fields represent:

\begin{itemize}
\item \texttt{version}: version of the struct in use, in case this changes later. For now, always \texttt{1}.


\item \texttt{checkout\_strategy}: determine how to handle conflicts and whether to force the  checkout/recreate missing files.


\item \texttt{disable\_filters}: if nonzero, do not apply filters like CLRF (to convert file newlines between UNIX and DOS).


\item \texttt{dir\_mode}: read/write/access mode for any directories involved in the checkout. Default is \texttt{0755}.


\item \texttt{file\_mode}: read/write/access mode for any files involved in the checkout.  Default is \texttt{0755} or \texttt{0644}, depending on the blob.


\item \texttt{file\_open\_flags}: bitflags used to open any files during the checkout.


\item \texttt{notify\_flags}: Flags for what sort of conflicts the user should be notified about.


\item \texttt{notify\_cb}: An optional callback function to notify the user if a checkout conflict occurs.  If this function returns a non-zero value, the checkout will be cancelled.


\item \texttt{notify\_payload}: Payload for the notify callback function.


\item \texttt{progress\_cb}: An optional callback function to display checkout progress.


\item \texttt{progress\_payload}: Payload for the progress callback.


\item \texttt{paths}: If not empty, describes which paths to search during the checkout.  If empty, the checkout will occur over all files in the repository.


\item \texttt{baseline}: Expected content of the \hyperlink{6689577338311178757}{\texttt{workdir}}, captured in a (pointer to a)  \hyperlink{6242150303858692069}{\texttt{GitTree}}. Defaults to the state of the tree at HEAD.


\item \texttt{baseline\_index}: Expected content of the \hyperlink{6689577338311178757}{\texttt{workdir}}, captured in a (pointer to a)  \texttt{GitIndex}. Defaults to the state of the index at HEAD.


\item \texttt{target\_directory}: If not empty, checkout to this directory instead of the \texttt{workdir}.


\item \texttt{ancestor\_label}: In case of conflicts, the name of the common ancestor side.


\item \texttt{our\_label}: In case of conflicts, the name of {\textquotedbl}our{\textquotedbl} side.


\item \texttt{their\_label}: In case of conflicts, the name of {\textquotedbl}their{\textquotedbl} side.


\item \texttt{perfdata\_cb}: An optional callback function to display performance data.


\item \texttt{perfdata\_payload}: Payload for the performance callback.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L32}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15963609167797539123}{} 
\hyperlink{15963609167797539123}{\texttt{LibGit2.CloneOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.CloneOptions
\end{minted}

Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_clone\_options}{\texttt{git\_clone\_options}} struct.

The fields represent:

\begin{itemize}
\item \texttt{version}: version of the struct in use, in case this changes later. For now, always \texttt{1}.


\item \texttt{checkout\_opts}: The options for performing the checkout of the remote as part of the clone.


\item \texttt{fetch\_opts}: The options for performing the pre-checkout fetch of the remote as part of the clone.


\item \texttt{bare}: If \texttt{0}, clone the full remote repository. If non-zero, perform a bare clone, in which  there is no local copy of the source files in the repository and the \hyperlink{12125979754140967861}{\texttt{gitdir}} and \hyperlink{6689577338311178757}{\texttt{workdir}}  are the same.


\item \texttt{localclone}: Flag whether to clone a local object database or do a fetch. The default is to let git decide.  It will not use the git-aware transport for a local clone, but will use it for URLs which begin with \texttt{file://}.


\item \texttt{checkout\_branch}: The name of the branch to checkout. If an empty string, the default branch of the  remote will be checked out.


\item \texttt{repository\_cb}: An optional callback which will be used to create the \emph{new} repository into which  the clone is made.


\item \texttt{repository\_cb\_payload}: The payload for the repository callback.


\item \texttt{remote\_cb}: An optional callback used to create the \hyperlink{9925970107179782013}{\texttt{GitRemote}} before making the clone from it.


\item \texttt{remote\_cb\_payload}: The payload for the remote callback.

\end{itemize}


\end{adjustwidth}
\hypertarget{7523488922232000806}{} 
\hyperlink{7523488922232000806}{\texttt{LibGit2.DescribeOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.DescribeOptions
\end{minted}

Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_describe\_options}{\texttt{git\_describe\_options}} struct.

The fields represent:

\begin{itemize}
\item \texttt{version}: version of the struct in use, in case this changes later. For now, always \texttt{1}.


\item \texttt{max\_candidates\_tags}: consider this many most recent tags in \texttt{refs/tags} to describe a commit.  Defaults to 10 (so that the 10 most recent tags would be examined to see if they describe a commit).


\item \texttt{describe\_strategy}: whether to consider all entries in \texttt{refs/tags} (equivalent to \texttt{git-describe --tags})  or all entries in \texttt{refs/} (equivalent to \texttt{git-describe --all}). The default is to only show annotated tags.  If \texttt{Consts.DESCRIBE\_TAGS} is passed, all tags, annotated or not, will be considered.  If \texttt{Consts.DESCRIBE\_ALL} is passed, any ref in \texttt{refs/} will be considered.


\item \texttt{pattern}: only consider tags which match \texttt{pattern}. Supports glob expansion.


\item \texttt{only\_follow\_first\_parent}: when finding the distance from a matching reference to the described  object, only consider the distance from the first parent.


\item \texttt{show\_commit\_oid\_as\_fallback}: if no matching reference can be found which describes a commit, show the  commit{\textquotesingle}s \hyperlink{202290709580230708}{\texttt{GitHash}} instead of throwing an error (the default behavior).

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L18}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6319202671460827960}{} 
\hyperlink{6319202671460827960}{\texttt{LibGit2.DescribeFormatOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.DescribeFormatOptions
\end{minted}

Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_describe\_format\_options}{\texttt{git\_describe\_format\_options}} struct.

The fields represent:

\begin{itemize}
\item \texttt{version}: version of the struct in use, in case this changes later. For now, always \texttt{1}.


\item \texttt{abbreviated\_size}: lower bound on the size of the abbreviated \texttt{GitHash} to use, defaulting to \texttt{7}.


\item \texttt{always\_use\_long\_format}: set to \texttt{1} to use the long format for strings even if a short format can be used.


\item \texttt{dirty\_suffix}: if set, this will be appended to the end of the description string if the \hyperlink{6689577338311178757}{\texttt{workdir}} is dirty.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L10}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9789233943804285928}{} 
\hyperlink{9789233943804285928}{\texttt{LibGit2.DiffDelta}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.DiffDelta
\end{minted}

Description of changes to one entry. Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_diff\_delta}{\texttt{git\_diff\_delta}} struct.

The fields represent:

\begin{itemize}
\item \texttt{status}: One of \texttt{Consts.DELTA\_STATUS}, indicating whether the file has been added/modified/deleted.


\item \texttt{flags}: Flags for the delta and the objects on each side. Determines whether to treat the file(s)  as binary/text, whether they exist on each side of the diff, and whether the object ids are known  to be correct.


\item \texttt{similarity}: Used to indicate if a file has been renamed or copied.


\item \texttt{nfiles}: The number of files in the delta (for instance, if the delta  was run on a submodule commit id, it may contain more than one file).


\item \texttt{old\_file}: A \hyperlink{18417152281461649554}{\texttt{DiffFile}} containing information about the file(s) before the changes.


\item \texttt{new\_file}: A \hyperlink{18417152281461649554}{\texttt{DiffFile}} containing information about the file(s) after the changes.

\end{itemize}


\end{adjustwidth}
\hypertarget{18417152281461649554}{} 
\hyperlink{18417152281461649554}{\texttt{LibGit2.DiffFile}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.DiffFile
\end{minted}

Description of one side of a delta. Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_diff\_file}{\texttt{git\_diff\_file}} struct.

The fields represent:

\begin{itemize}
\item \texttt{id}: the \hyperlink{202290709580230708}{\texttt{GitHash}} of the item in the diff. If the item is empty on this  side of the diff (for instance, if the diff is of the removal of a file), this will  be \texttt{GitHash(0)}.


\item \texttt{path}: a \texttt{NULL} terminated path to the item relative to the working directory of the repository.


\item \texttt{size}: the size of the item in bytes.


\item \texttt{flags}: a combination of the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_diff\_flag\_t}{\texttt{git\_diff\_flag\_t}}  flags. The \texttt{i}th bit of this integer sets the \texttt{i}th flag.


\item \texttt{mode}: the \hyperlink{10861694406169986183}{\texttt{stat}} mode for the item.


\item \texttt{id\_abbrev}: only present in LibGit2 versions newer than or equal to \texttt{0.25.0}.  The length of the \texttt{id} field when converted using \hyperlink{7919678712989769360}{\texttt{string}}. Usually equal to \texttt{OID\_HEXSZ} (40).

\end{itemize}


\end{adjustwidth}
\hypertarget{12061588653487632733}{} 
\hyperlink{12061588653487632733}{\texttt{LibGit2.DiffOptionsStruct}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.DiffOptionsStruct
\end{minted}

Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_diff\_options}{\texttt{git\_diff\_options}} struct.

The fields represent:

\begin{itemize}
\item \texttt{version}: version of the struct in use, in case this changes later. For now, always \texttt{1}.


\item \texttt{flags}: flags controlling which files will appear in the diff. Defaults to \texttt{DIFF\_NORMAL}.


\item \texttt{ignore\_submodules}: whether to look at files in submodules or not. Defaults to \texttt{SUBMODULE\_IGNORE\_UNSPECIFIED}, which means the submodule{\textquotesingle}s configuration will control  whether it appears in the diff or not.


\item \texttt{pathspec}: path to files to include in the diff. Default is to use all files in the repository.


\item \texttt{notify\_cb}: optional callback which will notify the user of changes to the diff as file deltas are  added to it.


\item \texttt{progress\_cb}: optional callback which will display diff progress. Only relevant on libgit2 versions  at least as new as 0.24.0.


\item \texttt{payload}: the payload to pass to \texttt{notify\_cb} and \texttt{progress\_cb}.


\item \texttt{context\_lines}: the number of \emph{unchanged} lines used to define the edges of a hunk.  This is also the number of lines which will be shown before/after a hunk to provide  context. Default is 3.


\item \texttt{interhunk\_lines}: the maximum number of \emph{unchanged} lines \emph{between} two separate  hunks allowed before the hunks will be combined. Default is 0.


\item \texttt{id\_abbrev}: sets the length of the abbreviated \hyperlink{202290709580230708}{\texttt{GitHash}} to print.  Default is \texttt{7}.


\item \texttt{max\_size}: the maximum file size of a blob. Above this size, it will be treated  as a binary blob. The default is 512 MB.


\item \texttt{old\_prefix}: the virtual file directory in which to place old files on one side  of the diff. Default is \texttt{{\textquotedbl}a{\textquotedbl}}.


\item \texttt{new\_prefix}: the virtual file directory in which to place new files on one side  of the diff. Default is \texttt{{\textquotedbl}b{\textquotedbl}}.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L30}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17806809481919147110}{} 
\hyperlink{17806809481919147110}{\texttt{LibGit2.FetchHead}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.FetchHead
\end{minted}

Contains the information about HEAD during a fetch, including the name and URL of the branch fetched from, the oid of the HEAD, and whether the fetched HEAD has been merged locally.

The fields represent:

\begin{itemize}
\item \texttt{name}: The name in the local reference database of the fetch head, for example,  \texttt{{\textquotedbl}refs/heads/master{\textquotedbl}}.


\item \texttt{url}: The URL of the fetch head.


\item \texttt{oid}: The \hyperlink{202290709580230708}{\texttt{GitHash}} of the tip of the fetch head.


\item \texttt{ismerge}: Boolean flag indicating whether the changes at the  remote have been merged into the local copy yet or not. If \texttt{true}, the local  copy is up to date with the remote fetch head.

\end{itemize}


\end{adjustwidth}
\hypertarget{7474664468985945267}{} 
\hyperlink{7474664468985945267}{\texttt{LibGit2.FetchOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.FetchOptions
\end{minted}

Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_fetch\_options}{\texttt{git\_fetch\_options}} struct.

The fields represent:

\begin{itemize}
\item \texttt{version}: version of the struct in use, in case this changes later. For now, always \texttt{1}.


\item \texttt{callbacks}: remote callbacks to use during the fetch.


\item \texttt{prune}: whether to perform a prune after the fetch or not. The default is to  use the setting from the \texttt{GitConfig}.


\item \texttt{update\_fetchhead}: whether to update the \hyperlink{17806809481919147110}{\texttt{FetchHead}} after the fetch.  The default is to perform the update, which is the normal git behavior.


\item \texttt{download\_tags}: whether to download tags present at the remote or not. The default  is to request the tags for objects which are being downloaded anyway from the server.


\item \texttt{proxy\_opts}: options for connecting to the remote through a proxy. See \hyperlink{1179613637206861638}{\texttt{ProxyOptions}}.  Only present on libgit2 versions newer than or equal to 0.25.0.


\item \texttt{custom\_headers}: any extra headers needed for the fetch. Only present on libgit2 versions  newer than or equal to 0.24.0.

\end{itemize}


\end{adjustwidth}
\hypertarget{9263689983564368210}{} 
\hyperlink{9263689983564368210}{\texttt{LibGit2.GitAnnotated}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GitAnnotated(repo::GitRepo, commit_id::GitHash)
GitAnnotated(repo::GitRepo, ref::GitReference)
GitAnnotated(repo::GitRepo, fh::FetchHead)
GitAnnotated(repo::GitRepo, comittish::AbstractString)
\end{minted}

An annotated git commit carries with it information about how it was looked up and why, so that rebase or merge operations have more information about the context of the commit. Conflict files contain information about the source/target branches in the merge which are conflicting, for instance. An annotated commit can refer to the tip of a remote branch, for instance when a \hyperlink{17806809481919147110}{\texttt{FetchHead}} is passed, or to a branch head described using \texttt{GitReference}.



\end{adjustwidth}
\hypertarget{11166114255561117709}{} 
\hyperlink{11166114255561117709}{\texttt{LibGit2.GitBlame}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GitBlame(repo::GitRepo, path::AbstractString; options::BlameOptions=BlameOptions())
\end{minted}

Construct a \texttt{GitBlame} object for the file at \texttt{path}, using change information gleaned from the history of \texttt{repo}. The \texttt{GitBlame} object records who changed which chunks of the file when, and how. \texttt{options} controls how to separate the contents of the file and which commits to probe - see \hyperlink{13109557230915215869}{\texttt{BlameOptions}} for more information.



\end{adjustwidth}
\hypertarget{13272891135715880949}{} 
\hyperlink{13272891135715880949}{\texttt{LibGit2.GitBlob}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GitBlob(repo::GitRepo, hash::AbstractGitHash)
GitBlob(repo::GitRepo, spec::AbstractString)
\end{minted}

Return a \texttt{GitBlob} object from \texttt{repo} specified by \texttt{hash}/\texttt{spec}.

\begin{itemize}
\item \texttt{hash} is a full (\texttt{GitHash}) or partial (\texttt{GitShortHash}) hash.


\item \texttt{spec} is a textual specification: see \href{https://git-scm.com/docs/git-rev-parse.html\#\_specifying\_revisions}{the git docs} for a full list.

\end{itemize}


\end{adjustwidth}
\hypertarget{5346527129202716606}{} 
\hyperlink{5346527129202716606}{\texttt{LibGit2.GitCommit}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GitCommit(repo::GitRepo, hash::AbstractGitHash)
GitCommit(repo::GitRepo, spec::AbstractString)
\end{minted}

Return a \texttt{GitCommit} object from \texttt{repo} specified by \texttt{hash}/\texttt{spec}.

\begin{itemize}
\item \texttt{hash} is a full (\texttt{GitHash}) or partial (\texttt{GitShortHash}) hash.


\item \texttt{spec} is a textual specification: see \href{https://git-scm.com/docs/git-rev-parse.html\#\_specifying\_revisions}{the git docs} for a full list.

\end{itemize}


\end{adjustwidth}
\hypertarget{202290709580230708}{} 
\hyperlink{202290709580230708}{\texttt{LibGit2.GitHash}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GitHash
\end{minted}

A git object identifier, based on the sha-1 hash. It is a 20 byte string (40 hex digits) used to identify a \texttt{GitObject} in a repository.



\end{adjustwidth}
\hypertarget{4668198389828625678}{} 
\hyperlink{4668198389828625678}{\texttt{LibGit2.GitObject}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GitObject(repo::GitRepo, hash::AbstractGitHash)
GitObject(repo::GitRepo, spec::AbstractString)
\end{minted}

Return the specified object (\hyperlink{5346527129202716606}{\texttt{GitCommit}}, \hyperlink{13272891135715880949}{\texttt{GitBlob}}, \hyperlink{6242150303858692069}{\texttt{GitTree}} or \hyperlink{10467695058580020738}{\texttt{GitTag}}) from \texttt{repo} specified by \texttt{hash}/\texttt{spec}.

\begin{itemize}
\item \texttt{hash} is a full (\texttt{GitHash}) or partial (\texttt{GitShortHash}) hash.


\item \texttt{spec} is a textual specification: see \href{https://git-scm.com/docs/git-rev-parse.html\#\_specifying\_revisions}{the git docs} for a full list.

\end{itemize}


\end{adjustwidth}
\hypertarget{9925970107179782013}{} 
\hyperlink{9925970107179782013}{\texttt{LibGit2.GitRemote}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GitRemote(repo::GitRepo, rmt_name::AbstractString, rmt_url::AbstractString) -> GitRemote
\end{minted}

Look up a remote git repository using its name and URL. Uses the default fetch refspec.

\textbf{Examples}


\begin{minted}{julia}
repo = LibGit2.init(repo_path)
remote = LibGit2.GitRemote(repo, "upstream", repo_url)
\end{minted}




\begin{lstlisting}
GitRemote(repo::GitRepo, rmt_name::AbstractString, rmt_url::AbstractString, fetch_spec::AbstractString) -> GitRemote
\end{lstlisting}

Look up a remote git repository using the repository{\textquotesingle}s name and URL, as well as specifications for how to fetch from the remote (e.g. which remote branch to fetch from).

\textbf{Examples}


\begin{minted}{julia}
repo = LibGit2.init(repo_path)
refspec = "+refs/heads/mybranch:refs/remotes/origin/mybranch"
remote = LibGit2.GitRemote(repo, "upstream", repo_url, refspec)
\end{minted}



\end{adjustwidth}
\hypertarget{13915605113589562056}{} 
\hyperlink{13915605113589562056}{\texttt{LibGit2.GitRemoteAnon}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GitRemoteAnon(repo::GitRepo, url::AbstractString) -> GitRemote
\end{minted}

Look up a remote git repository using only its URL, not its name.

\textbf{Examples}


\begin{minted}{julia}
repo = LibGit2.init(repo_path)
remote = LibGit2.GitRemoteAnon(repo, repo_url)
\end{minted}



\end{adjustwidth}
\hypertarget{3263346103236484748}{} 
\hyperlink{3263346103236484748}{\texttt{LibGit2.GitRepo}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.GitRepo(path::AbstractString)
\end{minted}

Open a git repository at \texttt{path}.



\end{adjustwidth}
\hypertarget{11364757486103041711}{} 
\hyperlink{11364757486103041711}{\texttt{LibGit2.GitRepoExt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.GitRepoExt(path::AbstractString, flags::Cuint = Cuint(Consts.REPOSITORY_OPEN_DEFAULT))
\end{minted}

Open a git repository at \texttt{path} with extended controls (for instance, if the current user must be a member of a special access group to read \texttt{path}).



\end{adjustwidth}
\hypertarget{7800294839307043628}{} 
\hyperlink{7800294839307043628}{\texttt{LibGit2.GitRevWalker}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GitRevWalker(repo::GitRepo)
\end{minted}

A \texttt{GitRevWalker} \emph{walks} through the \emph{revisions} (i.e. commits) of a git repository \texttt{repo}. It is a collection of the commits in the repository, and supports iteration and calls to \hyperlink{546421066875217314}{\texttt{map}} and \hyperlink{3202007276139600178}{\texttt{count}} (for instance, \texttt{count} could be used to determine what percentage of commits in a repository were made by a certain author).


\begin{minted}{julia}
cnt = LibGit2.with(LibGit2.GitRevWalker(repo)) do walker
    count((oid,repo)->(oid == commit_oid1), walker, oid=commit_oid1, by=LibGit2.Consts.SORT_TIME)
end
\end{minted}

Here, \texttt{count} finds the number of commits along the walk with a certain \texttt{GitHash}. Since the \texttt{GitHash} is unique to a commit, \texttt{cnt} will be \texttt{1}.



\end{adjustwidth}
\hypertarget{3676458372916825224}{} 
\hyperlink{3676458372916825224}{\texttt{LibGit2.GitShortHash}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GitShortHash(hash::GitHash, len::Integer)
\end{minted}

A shortened git object identifier, which can be used to identify a git object when it is unique, consisting of the initial \texttt{len} hexadecimal digits of \texttt{hash} (the remaining digits are ignored).



\end{adjustwidth}
\hypertarget{16780673881553092129}{} 
\hyperlink{16780673881553092129}{\texttt{LibGit2.GitSignature}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.GitSignature
\end{minted}

This is a Julia wrapper around a pointer to a \href{https://libgit2.org/libgit2/\#HEAD/type/git\_signature}{\texttt{git\_signature}} object.



\end{adjustwidth}
\hypertarget{5023272497907128319}{} 
\hyperlink{5023272497907128319}{\texttt{LibGit2.GitStatus}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.GitStatus(repo::GitRepo; status_opts=StatusOptions())
\end{minted}

Collect information about the status of each file in the git repository \texttt{repo} (e.g. is the file modified, staged, etc.). \texttt{status\_opts} can be used to set various options, for instance whether or not to look at untracked files or whether to include submodules or not. See \hyperlink{15761804013497693135}{\texttt{StatusOptions}} for more information.



\end{adjustwidth}
\hypertarget{10467695058580020738}{} 
\hyperlink{10467695058580020738}{\texttt{LibGit2.GitTag}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GitTag(repo::GitRepo, hash::AbstractGitHash)
GitTag(repo::GitRepo, spec::AbstractString)
\end{minted}

Return a \texttt{GitTag} object from \texttt{repo} specified by \texttt{hash}/\texttt{spec}.

\begin{itemize}
\item \texttt{hash} is a full (\texttt{GitHash}) or partial (\texttt{GitShortHash}) hash.


\item \texttt{spec} is a textual specification: see \href{https://git-scm.com/docs/git-rev-parse.html\#\_specifying\_revisions}{the git docs} for a full list.

\end{itemize}


\end{adjustwidth}
\hypertarget{6242150303858692069}{} 
\hyperlink{6242150303858692069}{\texttt{LibGit2.GitTree}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GitTree(repo::GitRepo, hash::AbstractGitHash)
GitTree(repo::GitRepo, spec::AbstractString)
\end{minted}

Return a \texttt{GitTree} object from \texttt{repo} specified by \texttt{hash}/\texttt{spec}.

\begin{itemize}
\item \texttt{hash} is a full (\texttt{GitHash}) or partial (\texttt{GitShortHash}) hash.


\item \texttt{spec} is a textual specification: see \href{https://git-scm.com/docs/git-rev-parse.html\#\_specifying\_revisions}{the git docs} for a full list.

\end{itemize}


\end{adjustwidth}
\hypertarget{2169451189682045075}{} 
\hyperlink{2169451189682045075}{\texttt{LibGit2.IndexEntry}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.IndexEntry
\end{minted}

In-memory representation of a file entry in the index. Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_index\_entry}{\texttt{git\_index\_entry}} struct.



\end{adjustwidth}
\hypertarget{13894240843968539685}{} 
\hyperlink{13894240843968539685}{\texttt{LibGit2.IndexTime}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.IndexTime
\end{minted}

Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_index\_time}{\texttt{git\_index\_time}} struct.



\end{adjustwidth}
\hypertarget{13109557230915215869}{} 
\hyperlink{13109557230915215869}{\texttt{LibGit2.BlameOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.BlameOptions
\end{minted}

Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_blame\_options}{\texttt{git\_blame\_options}} struct.

The fields represent:

\begin{itemize}
\item \texttt{version}: version of the struct in use, in case this changes later. For now, always \texttt{1}.


\item \texttt{flags}: one of \texttt{Consts.BLAME\_NORMAL} or \texttt{Consts.BLAME\_FIRST\_PARENT} (the other blame flags  are not yet implemented by libgit2).


\item \texttt{min\_match\_characters}: the minimum number of \emph{alphanumeric} characters which much change in a commit in order for the change to be associated with that commit. The default is 20. Only takes effect if one of the \texttt{Consts.BLAME\_*\_COPIES} flags are used, which libgit2 does not implement yet.


\item \texttt{newest\_commit}: the \hyperlink{202290709580230708}{\texttt{GitHash}} of the newest commit from which to look at changes.


\item \texttt{oldest\_commit}: the \hyperlink{202290709580230708}{\texttt{GitHash}} of the oldest commit from which to look at changes.


\item \texttt{min\_line}: the first line of the file from which to starting blaming. The default is \texttt{1}.


\item \texttt{max\_line}: the last line of the file to which to blame. The default is \texttt{0}, meaning the last line of the file.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L18}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7663922722360889557}{} 
\hyperlink{7663922722360889557}{\texttt{LibGit2.MergeOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.MergeOptions
\end{minted}

Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_merge\_options}{\texttt{git\_merge\_options}} struct.

The fields represent:

\begin{itemize}
\item \texttt{version}: version of the struct in use, in case this changes later. For now, always \texttt{1}.


\item \texttt{flags}: an \texttt{enum} for flags describing merge behavior.  Defined in \href{https://github.com/libgit2/libgit2/blob/HEAD/include/git2/merge.h\#L95}{\texttt{git\_merge\_flag\_t}}.  The corresponding Julia enum is \texttt{GIT\_MERGE} and has values:

\begin{itemize}
\item \texttt{MERGE\_FIND\_RENAMES}: detect if a file has been renamed between the common ancestor and the {\textquotedbl}ours{\textquotedbl} or {\textquotedbl}theirs{\textquotedbl} side of the merge. Allows merges where a file has been renamed.


\item \texttt{MERGE\_FAIL\_ON\_CONFLICT}: exit immediately if a conflict is found rather than trying to resolve it.


\item \texttt{MERGE\_SKIP\_REUC}: do not write the REUC extension on the index resulting from the merge.


\item \texttt{MERGE\_NO\_RECURSIVE}: if the commits being merged have multiple merge bases, use the first one, rather than trying to recursively merge the bases.

\end{itemize}

\item \texttt{rename\_threshold}: how similar two files must to consider one a rename of the other. This is an integer that sets the percentage similarity. The default is 50.


\item \texttt{target\_limit}: the maximum number of files to compare with to look for renames. The default is 200.


\item \texttt{metric}: optional custom function to use to determine the similarity between two files for rename detection.


\item \texttt{recursion\_limit}: the upper limit on the number of merges of common ancestors to perform to try to build a new virtual merge base for the merge. The default is no limit. This field is only present on libgit2 versions newer than 0.24.0.


\item \texttt{default\_driver}: the merge driver to use if both sides have changed. This field is only present on libgit2 versions newer than 0.25.0.


\item \texttt{file\_favor}: how to handle conflicting file contents for the \texttt{text} driver.

\begin{itemize}
\item \texttt{MERGE\_FILE\_FAVOR\_NORMAL}: if both sides of the merge have changes to a section,  make a note of the conflict in the index which \texttt{git checkout} will use to create  a merge file, which the user can then reference to resolve the conflicts. This is  the default.


\item \texttt{MERGE\_FILE\_FAVOR\_OURS}: if both sides of the merge have changes to a section,  use the version in the {\textquotedbl}ours{\textquotedbl} side of the merge in the index.


\item \texttt{MERGE\_FILE\_FAVOR\_THEIRS}: if both sides of the merge have changes to a section,  use the version in the {\textquotedbl}theirs{\textquotedbl} side of the merge in the index.


\item \texttt{MERGE\_FILE\_FAVOR\_UNION}: if both sides of the merge have changes to a section,  include each unique line from both sides in the file which is put into the index.

\end{itemize}

\item \texttt{file\_flags}: guidelines for merging files.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L42}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1179613637206861638}{} 
\hyperlink{1179613637206861638}{\texttt{LibGit2.ProxyOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.ProxyOptions
\end{minted}

Options for connecting through a proxy.

Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_proxy\_options}{\texttt{git\_proxy\_options}} struct.

The fields represent:

\begin{itemize}
\item \texttt{version}: version of the struct in use, in case this changes later. For now, always \texttt{1}.


\item \texttt{proxytype}: an \texttt{enum} for the type of proxy to use.  Defined in \href{https://libgit2.org/libgit2/\#HEAD/type/git\_proxy\_t}{\texttt{git\_proxy\_t}}.  The corresponding Julia enum is \texttt{GIT\_PROXY} and has values:

\begin{itemize}
\item \texttt{PROXY\_NONE}: do not attempt the connection through a proxy.


\item \texttt{PROXY\_AUTO}: attempt to figure out the proxy configuration from the git configuration.


\item \texttt{PROXY\_SPECIFIED}: connect using the URL given in the \texttt{url} field of this struct.

\end{itemize}
Default is to auto-detect the proxy type.


\item \texttt{url}: the URL of the proxy.


\item \texttt{credential\_cb}: a pointer to a callback function which will be called if the remote requires authentication to connect.


\item \texttt{certificate\_cb}: a pointer to a callback function which will be called if certificate verification fails. This lets the user decide whether or not to keep connecting. If the function returns \texttt{1}, connecting will be allowed. If it returns \texttt{0}, the connection will not be allowed. A negative value can be used to return errors.


\item \texttt{payload}: the payload to be provided to the two callback functions.

\end{itemize}
\textbf{Examples}


\begin{minted}{jlcon}
julia> fo = LibGit2.FetchOptions(
           proxy_opts = LibGit2.ProxyOptions(url = Cstring("https://my_proxy_url.com")))

julia> fetch(remote, "master", options=fo)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L32}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13899785564428555533}{} 
\hyperlink{13899785564428555533}{\texttt{LibGit2.PushOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.PushOptions
\end{minted}

Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_push\_options}{\texttt{git\_push\_options}} struct.

The fields represent:

\begin{itemize}
\item \texttt{version}: version of the struct in use, in case this changes later. For now, always \texttt{1}.


\item \texttt{parallelism}: if a pack file must be created, this variable sets the number of worker  threads which will be spawned by the packbuilder. If \texttt{0}, the packbuilder will auto-set  the number of threads to use. The default is \texttt{1}.


\item \texttt{callbacks}: the callbacks (e.g. for authentication with the remote) to use for the push.


\item \texttt{proxy\_opts}: only relevant if the LibGit2 version is greater than or equal to \texttt{0.25.0}.  Sets options for using a proxy to communicate with a remote. See \hyperlink{1179613637206861638}{\texttt{ProxyOptions}}  for more information.


\item \texttt{custom\_headers}: only relevant if the LibGit2 version is greater than or equal to \texttt{0.24.0}.  Extra headers needed for the push operation.

\end{itemize}


\end{adjustwidth}
\hypertarget{4600807719307889860}{} 
\hyperlink{4600807719307889860}{\texttt{LibGit2.RebaseOperation}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.RebaseOperation
\end{minted}

Describes a single instruction/operation to be performed during the rebase. Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_rebase\_operation\_t}{\texttt{git\_rebase\_operation}} struct.

The fields represent:

\begin{itemize}
\item \texttt{optype}: the type of rebase operation currently being performed. The options are:

\begin{itemize}
\item \texttt{REBASE\_OPERATION\_PICK}: cherry-pick the commit in question.


\item \texttt{REBASE\_OPERATION\_REWORD}: cherry-pick the commit in question, but rewrite its message using the prompt.


\item \texttt{REBASE\_OPERATION\_EDIT}: cherry-pick the commit in question, but allow the user to edit the commit{\textquotesingle}s contents and its message.


\item \texttt{REBASE\_OPERATION\_SQUASH}: squash the commit in question into the previous commit. The commit messages of the two commits will be merged.


\item \texttt{REBASE\_OPERATION\_FIXUP}: squash the commit in question into the previous commit. Only the commit message of the previous commit will be used.


\item \texttt{REBASE\_OPERATION\_EXEC}: do not cherry-pick a commit. Run a command and continue if the command exits successfully.

\end{itemize}

\item \texttt{id}: the \hyperlink{202290709580230708}{\texttt{GitHash}} of the commit being worked on during this rebase step.


\item \texttt{exec}: in case \texttt{REBASE\_OPERATION\_EXEC} is used, the command to run during this step (for instance, running the test suite after each commit).

\end{itemize}


\end{adjustwidth}
\hypertarget{9347726754162781322}{} 
\hyperlink{9347726754162781322}{\texttt{LibGit2.RebaseOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.RebaseOptions
\end{minted}

Matches the \texttt{git\_rebase\_options} struct.

The fields represent:

\begin{itemize}
\item \texttt{version}: version of the struct in use, in case this changes later. For now, always \texttt{1}.


\item \texttt{quiet}: inform other git clients helping with/working on the rebase that the rebase should be done {\textquotedbl}quietly{\textquotedbl}. Used for interoperability. The default is \texttt{1}.


\item \texttt{inmemory}: start an in-memory rebase. Callers working on the rebase can go through its steps and commit any changes, but cannot rewind HEAD or update the repository. The \hyperlink{6689577338311178757}{\texttt{workdir}} will not be modified. Only present on libgit2 versions newer than or equal to 0.24.0.


\item \texttt{rewrite\_notes\_ref}: name of the reference to notes to use to rewrite the commit notes as the rebase is finished.


\item \texttt{merge\_opts}: merge options controlling how the trees will be merged at each rebase step.  Only present on libgit2 versions newer than or equal to 0.24.0.


\item \texttt{checkout\_opts}: checkout options for writing files when initializing the rebase, stepping through it, and aborting it. See \hyperlink{16441061243067746546}{\texttt{CheckoutOptions}} for more information.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L18}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5220283667301575523}{} 
\hyperlink{5220283667301575523}{\texttt{LibGit2.RemoteCallbacks}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.RemoteCallbacks
\end{minted}

Callback settings. Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_remote\_callbacks}{\texttt{git\_remote\_callbacks}} struct.



\end{adjustwidth}
\hypertarget{8598007626850742967}{} 
\hyperlink{8598007626850742967}{\texttt{LibGit2.SignatureStruct}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.SignatureStruct
\end{minted}

An action signature (e.g. for committers, taggers, etc). Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_signature}{\texttt{git\_signature}} struct.

The fields represent:

\begin{itemize}
\item \texttt{name}: The full name of the committer or author of the commit.


\item \texttt{email}: The email at which the committer/author can be contacted.


\item \texttt{when}: a \hyperlink{11932909532186040994}{\texttt{TimeStruct}} indicating when the commit was  authored/committed into the repository.

\end{itemize}


\end{adjustwidth}
\hypertarget{16035791715224568905}{} 
\hyperlink{16035791715224568905}{\texttt{LibGit2.StatusEntry}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.StatusEntry
\end{minted}

Providing the differences between the file as it exists in HEAD and the index, and providing the differences between the index and the working directory. Matches the \texttt{git\_status\_entry} struct.

The fields represent:

\begin{itemize}
\item \texttt{status}: contains the status flags for the file, indicating if it is current, or has been changed in some way in the index or work tree.


\item \texttt{head\_to\_index}: a pointer to a \hyperlink{9789233943804285928}{\texttt{DiffDelta}} which encapsulates the difference(s) between the file as it exists in HEAD and in the index.


\item \texttt{index\_to\_workdir}: a pointer to a \texttt{DiffDelta} which encapsulates the difference(s) between the file as it exists in the index and in the \hyperlink{6689577338311178757}{\texttt{workdir}}.

\end{itemize}


\end{adjustwidth}
\hypertarget{15761804013497693135}{} 
\hyperlink{15761804013497693135}{\texttt{LibGit2.StatusOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.StatusOptions
\end{minted}

Options to control how \texttt{git\_status\_foreach\_ext()} will issue callbacks. Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_status\_opt\_t}{\texttt{git\_status\_opt\_t}} struct.

The fields represent:

\begin{itemize}
\item \texttt{version}: version of the struct in use, in case this changes later. For now, always \texttt{1}.


\item \texttt{show}: a flag for which files to examine and in which order. The default is \texttt{Consts.STATUS\_SHOW\_INDEX\_AND\_WORKDIR}.


\item \texttt{flags}: flags for controlling any callbacks used in a status call.


\item \texttt{pathspec}: an array of paths to use for path-matching. The behavior of the path-matching will vary depending on the values of \texttt{show} and \texttt{flags}.


\item The \texttt{baseline} is the tree to be used for comparison to the working directory and index; defaults to HEAD.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L15}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10686064701005230750}{} 
\hyperlink{10686064701005230750}{\texttt{LibGit2.StrArrayStruct}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.StrArrayStruct
\end{minted}

A LibGit2 representation of an array of strings. Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_strarray}{\texttt{git\_strarray}} struct.

When fetching data from LibGit2, a typical usage would look like:


\begin{minted}{julia}
sa_ref = Ref(StrArrayStruct())
@check ccall(..., (Ptr{StrArrayStruct},), sa_ref)
res = convert(Vector{String}, sa_ref[])
free(sa_ref)
\end{minted}

In particular, note that \texttt{LibGit2.free} should be called afterward on the \texttt{Ref} object.

Conversely, when passing a vector of strings to LibGit2, it is generally simplest to rely on implicit conversion:


\begin{minted}{julia}
strs = String[...]
@check ccall(..., (Ptr{StrArrayStruct},), strs)
\end{minted}

Note that no call to \texttt{free} is required as the data is allocated by Julia.



\end{adjustwidth}
\hypertarget{11932909532186040994}{} 
\hyperlink{11932909532186040994}{\texttt{LibGit2.TimeStruct}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.TimeStruct
\end{minted}

Time in a signature. Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_time}{\texttt{git\_time}} struct.



\end{adjustwidth}
\hypertarget{16270901697937111000}{} 
\hyperlink{16270901697937111000}{\texttt{LibGit2.add!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
add!(repo::GitRepo, files::AbstractString...; flags::Cuint = Consts.INDEX_ADD_DEFAULT)
add!(idx::GitIndex, files::AbstractString...; flags::Cuint = Consts.INDEX_ADD_DEFAULT)
\end{minted}

Add all the files with paths specified by \texttt{files} to the index \texttt{idx} (or the index of the \texttt{repo}). If the file already exists, the index entry will be updated. If the file does not exist already, it will be newly added into the index. \texttt{files} may contain glob patterns which will be expanded and any matching files will be added (unless \texttt{INDEX\_ADD\_DISABLE\_PATHSPEC\_MATCH} is set, see below). If a file has been ignored (in \texttt{.gitignore} or in the config), it \emph{will not} be added, \emph{unless} it is already being tracked in the index, in which case it \emph{will} be updated. The keyword argument \texttt{flags} is a set of bit-flags which control the behavior with respect to ignored files:

\begin{itemize}
\item \texttt{Consts.INDEX\_ADD\_DEFAULT} - default, described above.


\item \texttt{Consts.INDEX\_ADD\_FORCE} - disregard the existing ignore rules and force addition of the file to the index even if it is already ignored.


\item \texttt{Consts.INDEX\_ADD\_CHECK\_PATHSPEC} - cannot be used at the same time as \texttt{INDEX\_ADD\_FORCE}. Check that each file in \texttt{files} which exists on disk is not in the ignore list. If one of the files \emph{is} ignored, the function will return \texttt{EINVALIDSPEC}.


\item \texttt{Consts.INDEX\_ADD\_DISABLE\_PATHSPEC\_MATCH} - turn off glob matching, and only add files to the index which exactly match the paths specified in \texttt{files}.

\end{itemize}


\end{adjustwidth}
\hypertarget{6981412809211295791}{} 
\hyperlink{6981412809211295791}{\texttt{LibGit2.add\_fetch!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
add_fetch!(repo::GitRepo, rmt::GitRemote, fetch_spec::String)
\end{minted}

Add a \emph{fetch} refspec for the specified \texttt{rmt}. This refspec will contain information about which branch(es) to fetch from.

\textbf{Examples}


\begin{minted}{jlcon}
julia> LibGit2.add_fetch!(repo, remote, "upstream");

julia> LibGit2.fetch_refspecs(remote)
String["+refs/heads/*:refs/remotes/upstream/*"]
\end{minted}



\end{adjustwidth}
\hypertarget{2424007891894294055}{} 
\hyperlink{2424007891894294055}{\texttt{LibGit2.add\_push!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
add_push!(repo::GitRepo, rmt::GitRemote, push_spec::String)
\end{minted}

Add a \emph{push} refspec for the specified \texttt{rmt}. This refspec will contain information about which branch(es) to push to.

\textbf{Examples}


\begin{minted}{jlcon}
julia> LibGit2.add_push!(repo, remote, "refs/heads/master");

julia> remote = LibGit2.get(LibGit2.GitRemote, repo, branch);

julia> LibGit2.push_refspecs(remote)
String["refs/heads/master"]
\end{minted}

\begin{quote}
\textbf{Note}

You may need to \hyperlink{5331333469799487255}{\texttt{close}} and reopen the \texttt{GitRemote} in question after updating its push refspecs in order for the change to take effect and for calls to \hyperlink{9401118176170322302}{\texttt{push}} to work.

\end{quote}


\end{adjustwidth}
\hypertarget{12021530861844417654}{} 
\hyperlink{12021530861844417654}{\texttt{LibGit2.addblob!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.addblob!(repo::GitRepo, path::AbstractString)
\end{minted}

Read the file at \texttt{path} and adds it to the object database of \texttt{repo} as a loose blob. Return the \hyperlink{202290709580230708}{\texttt{GitHash}} of the resulting blob.

\textbf{Examples}


\begin{minted}{julia}
hash_str = string(commit_oid)
blob_file = joinpath(repo_path, ".git", "objects", hash_str[1:2], hash_str[3:end])
id = LibGit2.addblob!(repo, blob_file)
\end{minted}



\end{adjustwidth}
\hypertarget{7024880280540966409}{} 
\hyperlink{7024880280540966409}{\texttt{LibGit2.author}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
author(c::GitCommit)
\end{minted}

Return the \texttt{Signature} of the author of the commit \texttt{c}. The author is the person who made changes to the relevant file(s). See also \hyperlink{4819166445750615913}{\texttt{committer}}.



\end{adjustwidth}
\hypertarget{13671452176500407122}{} 
\hyperlink{13671452176500407122}{\texttt{LibGit2.authors}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
authors(repo::GitRepo) -> Vector{Signature}
\end{minted}

Return all authors of commits to the \texttt{repo} repository.

\textbf{Examples}


\begin{minted}{julia}
repo = LibGit2.GitRepo(repo_path)
repo_file = open(joinpath(repo_path, test_file), "a")

println(repo_file, commit_msg)
flush(repo_file)
LibGit2.add!(repo, test_file)
sig = LibGit2.Signature("TEST", "TEST@TEST.COM", round(time(), 0), 0)
commit_oid1 = LibGit2.commit(repo, "commit1"; author=sig, committer=sig)
println(repo_file, randstring(10))
flush(repo_file)
LibGit2.add!(repo, test_file)
commit_oid2 = LibGit2.commit(repo, "commit2"; author=sig, committer=sig)

# will be a Vector of [sig, sig]
auths = LibGit2.authors(repo)
\end{minted}



\end{adjustwidth}
\hypertarget{17976386758924249721}{} 
\hyperlink{17976386758924249721}{\texttt{LibGit2.branch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
branch(repo::GitRepo)
\end{minted}

Equivalent to \texttt{git branch}. Create a new branch from the current HEAD.



\end{adjustwidth}
\hypertarget{10282470573382896007}{} 
\hyperlink{10282470573382896007}{\texttt{LibGit2.branch!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
branch!(repo::GitRepo, branch_name::AbstractString, commit::AbstractString=""; kwargs...)
\end{minted}

Checkout a new git branch in the \texttt{repo} repository. \texttt{commit} is the \hyperlink{202290709580230708}{\texttt{GitHash}}, in string form, which will be the start of the new branch. If \texttt{commit} is an empty string, the current HEAD will be used.

The keyword arguments are:

\begin{itemize}
\item \texttt{track::AbstractString={\textquotedbl}{\textquotedbl}}: the name of the remote branch this new branch should track, if any. If empty (the default), no remote branch will be tracked.


\item \texttt{force::Bool=false}: if \texttt{true}, branch creation will be forced.


\item \texttt{set\_head::Bool=true}: if \texttt{true}, after the branch creation finishes the branch head will be set as the HEAD of \texttt{repo}.

\end{itemize}
Equivalent to \texttt{git checkout [-b|-B] <branch\_name> [<commit>] [--track <track>]}.

\textbf{Examples}


\begin{minted}{julia}
repo = LibGit2.GitRepo(repo_path)
LibGit2.branch!(repo, "new_branch", set_head=false)
\end{minted}



\end{adjustwidth}
\hypertarget{17667204238793225311}{} 
\hyperlink{17667204238793225311}{\texttt{LibGit2.checkout!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
checkout!(repo::GitRepo, commit::AbstractString=""; force::Bool=true)
\end{minted}

Equivalent to \texttt{git checkout [-f] --detach <commit>}. Checkout the git commit \texttt{commit} (a \hyperlink{202290709580230708}{\texttt{GitHash}} in string form) in \texttt{repo}. If \texttt{force} is \texttt{true}, force the checkout and discard any current changes. Note that this detaches the current HEAD.

\textbf{Examples}


\begin{minted}{julia}
repo = LibGit2.init(repo_path)
open(joinpath(LibGit2.path(repo), "file1"), "w") do f
    write(f, "111
")
end
LibGit2.add!(repo, "file1")
commit_oid = LibGit2.commit(repo, "add file1")
open(joinpath(LibGit2.path(repo), "file1"), "w") do f
    write(f, "112
")
end
# would fail without the force=true
# since there are modifications to the file
LibGit2.checkout!(repo, string(commit_oid), force=true)
\end{minted}



\end{adjustwidth}
\hypertarget{7099795087604363090}{} 
\hyperlink{7099795087604363090}{\texttt{LibGit2.clone}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
clone(repo_url::AbstractString, repo_path::AbstractString, clone_opts::CloneOptions)
\end{minted}

Clone the remote repository at \texttt{repo\_url} (which can be a remote URL or a path on the local filesystem) to \texttt{repo\_path} (which must be a path on the local filesystem). Options for the clone, such as whether to perform a bare clone or not, are set by \hyperlink{15963609167797539123}{\texttt{CloneOptions}}.

\textbf{Examples}


\begin{minted}{julia}
repo_url = "https://github.com/JuliaLang/Example.jl"
repo = LibGit2.clone(repo_url, "/home/me/projects/Example")
\end{minted}




\begin{lstlisting}
clone(repo_url::AbstractString, repo_path::AbstractString; kwargs...)
\end{lstlisting}

Clone a remote repository located at \texttt{repo\_url} to the local filesystem location \texttt{repo\_path}.

The keyword arguments are:

\begin{itemize}
\item \texttt{branch::AbstractString={\textquotedbl}{\textquotedbl}}: which branch of the remote to clone, if not the default repository branch (usually \texttt{master}).


\item \texttt{isbare::Bool=false}: if \texttt{true}, clone the remote as a bare repository, which will make \texttt{repo\_path} itself the git directory instead of \texttt{repo\_path/.git}. This means that a working tree cannot be checked out. Plays the role of the git CLI argument \texttt{--bare}.


\item \texttt{remote\_cb::Ptr\{Cvoid\}=C\_NULL}: a callback which will be used to create the remote before it is cloned. If \texttt{C\_NULL} (the default), no attempt will be made to create the remote - it will be assumed to already exist.


\item \texttt{credentials::Creds=nothing}: provides credentials and/or settings when authenticating against a private repository.


\item \texttt{callbacks::Callbacks=Callbacks()}: user provided callbacks and payloads.

\end{itemize}
Equivalent to \texttt{git clone [-b <branch>] [--bare] <repo\_url> <repo\_path>}.

\textbf{Examples}


\begin{minted}{julia}
repo_url = "https://github.com/JuliaLang/Example.jl"
repo1 = LibGit2.clone(repo_url, "test_path")
repo2 = LibGit2.clone(repo_url, "test_path", isbare=true)
julia_url = "https://github.com/JuliaLang/julia"
julia_repo = LibGit2.clone(julia_url, "julia_path", branch="release-0.6")
\end{minted}



\end{adjustwidth}
\hypertarget{9554164652611238018}{} 
\hyperlink{9554164652611238018}{\texttt{LibGit2.commit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
commit(repo::GitRepo, msg::AbstractString; kwargs...) -> GitHash
\end{minted}

Wrapper around \href{https://libgit2.org/libgit2/\#HEAD/group/commit/git\_commit\_create}{\texttt{git\_commit\_create}}. Create a commit in the repository \texttt{repo}. \texttt{msg} is the commit message. Return the OID of the new commit.

The keyword arguments are:

\begin{itemize}
\item \texttt{refname::AbstractString=Consts.HEAD\_FILE}: if not NULL, the name of the reference to update to point to the new commit. For example, \texttt{{\textquotedbl}HEAD{\textquotedbl}} will update the HEAD of the current branch. If the reference does not yet exist, it will be created.


\item \texttt{author::Signature = Signature(repo)} is a \texttt{Signature} containing information about the person who authored the commit.


\item \texttt{committer::Signature = Signature(repo)} is a \texttt{Signature} containing information about the person who committed the commit to the repository. Not necessarily the same as \texttt{author}, for instance if \texttt{author} emailed a patch to \texttt{committer} who committed it.


\item \texttt{tree\_id::GitHash = GitHash()} is a git tree to use to create the commit, showing its ancestry and relationship with any other history. \texttt{tree} must belong to \texttt{repo}.


\item \texttt{parent\_ids::Vector\{GitHash\}=GitHash[]} is a list of commits by \hyperlink{202290709580230708}{\texttt{GitHash}} to use as parent commits for the new one, and may be empty. A commit might have multiple parents if it is a merge commit, for example.

\end{itemize}



\begin{lstlisting}
LibGit2.commit(rb::GitRebase, sig::GitSignature)
\end{lstlisting}

Commit the current patch to the rebase \texttt{rb}, using \texttt{sig} as the committer. Is silent if the commit has already been applied.



\end{adjustwidth}
\hypertarget{4819166445750615913}{} 
\hyperlink{4819166445750615913}{\texttt{LibGit2.committer}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
committer(c::GitCommit)
\end{minted}

Return the \texttt{Signature} of the committer of the commit \texttt{c}. The committer is the person who committed the changes originally authored by the \hyperlink{7024880280540966409}{\texttt{author}}, but need not be the same as the \texttt{author}, for example, if the \texttt{author} emailed a patch to a \texttt{committer} who committed it.



\end{adjustwidth}
\hypertarget{3202007276139600178}{} 
\hyperlink{3202007276139600178}{\texttt{LibGit2.count}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.count(f::Function, walker::GitRevWalker; oid::GitHash=GitHash(), by::Cint=Consts.SORT_NONE, rev::Bool=false)
\end{minted}

Using the \hyperlink{7800294839307043628}{\texttt{GitRevWalker}} \texttt{walker} to {\textquotedbl}walk{\textquotedbl} over every commit in the repository{\textquotesingle}s history, find the number of commits which return \texttt{true} when \texttt{f} is applied to them. The keyword arguments are:     * \texttt{oid}: The \hyperlink{202290709580230708}{\texttt{GitHash}} of the commit to begin the walk from. The default is to use       \hyperlink{9792433728015067335}{\texttt{push\_head!}} and therefore the HEAD commit and all its ancestors.     * \texttt{by}: The sorting method. The default is not to sort. Other options are to sort by       topology (\texttt{LibGit2.Consts.SORT\_TOPOLOGICAL}), to sort forwards in time       (\texttt{LibGit2.Consts.SORT\_TIME}, most ancient first) or to sort backwards in time       (\texttt{LibGit2.Consts.SORT\_REVERSE}, most recent first).     * \texttt{rev}: Whether to reverse the sorted order (for instance, if topological sorting is used).

\textbf{Examples}


\begin{minted}{julia}
cnt = LibGit2.with(LibGit2.GitRevWalker(repo)) do walker
    count((oid, repo)->(oid == commit_oid1), walker, oid=commit_oid1, by=LibGit2.Consts.SORT_TIME)
end
\end{minted}

\texttt{count} finds the number of commits along the walk with a certain \texttt{GitHash} \texttt{commit\_oid1}, starting the walk from that commit and moving forwards in time from it. Since the \texttt{GitHash} is unique to a commit, \texttt{cnt} will be \texttt{1}.



\end{adjustwidth}
\hypertarget{14766056021243867485}{} 
\hyperlink{14766056021243867485}{\texttt{LibGit2.counthunks}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
counthunks(blame::GitBlame)
\end{minted}

Return the number of distinct {\textquotedbl}hunks{\textquotedbl} with a file. A hunk may contain multiple lines. A hunk is usually a piece of a file that was added/changed/removed together, for example, a function added to a source file or an inner loop that was optimized out of that function later.



\end{adjustwidth}
\hypertarget{3632112326305021926}{} 
\hyperlink{3632112326305021926}{\texttt{LibGit2.create\_branch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.create_branch(repo::GitRepo, bname::AbstractString, commit_obj::GitCommit; force::Bool=false)
\end{minted}

Create a new branch in the repository \texttt{repo} with name \texttt{bname}, which points to commit \texttt{commit\_obj} (which has to be part of \texttt{repo}). If \texttt{force} is \texttt{true}, overwrite an existing branch named \texttt{bname} if it exists. If \texttt{force} is \texttt{false} and a branch already exists named \texttt{bname}, this function will throw an error.



\end{adjustwidth}
\hypertarget{14873190507178513691}{} 
\hyperlink{14873190507178513691}{\texttt{LibGit2.credentials\_callback}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
credential_callback(...) -> Cint
\end{minted}

A LibGit2 credential callback function which provides different credential acquisition functionality w.r.t. a connection protocol. The \texttt{payload\_ptr} is required to contain a \texttt{LibGit2.CredentialPayload} object which will keep track of state and settings.

The \texttt{allowed\_types} contains a bitmask of \texttt{LibGit2.Consts.GIT\_CREDTYPE} values specifying which authentication methods should be attempted.

Credential authentication is done in the following order (if supported):

\begin{itemize}
\item SSH agent


\item SSH private/public key pair


\item Username/password plain text

\end{itemize}
If a user is presented with a credential prompt they can abort the prompt by typing \texttt{{\textasciicircum}D} (pressing the control key together with the \texttt{d} key).

\textbf{Note}: Due to the specifics of the \texttt{libgit2} authentication procedure, when authentication fails, this function is called again without any indication whether authentication was successful or not. To avoid an infinite loop from repeatedly using the same faulty credentials, we will keep track of state using the payload.

For addition details see the LibGit2 guide on \href{https://libgit2.org/docs/guides/authentication/}{authenticating against a server}.



\end{adjustwidth}
\hypertarget{9226239310211022593}{} 
\hyperlink{9226239310211022593}{\texttt{LibGit2.credentials\_cb}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

C function pointer for \texttt{credentials\_callback}



\end{adjustwidth}
\hypertarget{4585945206005903475}{} 
\hyperlink{4585945206005903475}{\texttt{LibGit2.default\_signature}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Return signature object. Free it after use.



\end{adjustwidth}
\hypertarget{3338994964608738996}{} 
\hyperlink{3338994964608738996}{\texttt{LibGit2.delete\_branch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.delete_branch(branch::GitReference)
\end{minted}

Delete the branch pointed to by \texttt{branch}.



\end{adjustwidth}
\hypertarget{15514326201827332376}{} 
\hyperlink{15514326201827332376}{\texttt{LibGit2.diff\_files}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
diff_files(repo::GitRepo, branch1::AbstractString, branch2::AbstractString; kwarg...) -> Vector{AbstractString}
\end{minted}

Show which files have changed in the git repository \texttt{repo} between branches \texttt{branch1} and \texttt{branch2}.

The keyword argument is:

\begin{itemize}
\item \texttt{filter::Set\{Consts.DELTA\_STATUS\}=Set([Consts.DELTA\_ADDED, Consts.DELTA\_MODIFIED, Consts.DELTA\_DELETED]))}, and it sets options for the diff. The default is to show files added, modified, or deleted.

\end{itemize}
Return only the \emph{names} of the files which have changed, \emph{not} their contents.

\textbf{Examples}


\begin{minted}{julia}
LibGit2.branch!(repo, "branch/a")
LibGit2.branch!(repo, "branch/b")
# add a file to repo
open(joinpath(LibGit2.path(repo),"file"),"w") do f
    write(f, "hello repo
")
end
LibGit2.add!(repo, "file")
LibGit2.commit(repo, "add file")
# returns ["file"]
filt = Set([LibGit2.Consts.DELTA_ADDED])
files = LibGit2.diff_files(repo, "branch/a", "branch/b", filter=filt)
# returns [] because existing files weren't modified
filt = Set([LibGit2.Consts.DELTA_MODIFIED])
files = LibGit2.diff_files(repo, "branch/a", "branch/b", filter=filt)
\end{minted}

Equivalent to \texttt{git diff --name-only --diff-filter=<filter> <branch1> <branch2>}.



\end{adjustwidth}
\hypertarget{13732663441533972746}{} 
\hyperlink{13732663441533972746}{\texttt{LibGit2.entryid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
entryid(te::GitTreeEntry)
\end{minted}

Return the \hyperlink{202290709580230708}{\texttt{GitHash}} of the object to which \texttt{te} refers.



\end{adjustwidth}
\hypertarget{5430515144387502914}{} 
\hyperlink{5430515144387502914}{\texttt{LibGit2.entrytype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
entrytype(te::GitTreeEntry)
\end{minted}

Return the type of the object to which \texttt{te} refers. The result will be one of the types which \hyperlink{5024227788763319693}{\texttt{objtype}} returns, e.g. a \texttt{GitTree} or \texttt{GitBlob}.



\end{adjustwidth}
\hypertarget{538444501253561978}{} 
\hyperlink{538444501253561978}{\texttt{LibGit2.fetch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fetch(rmt::GitRemote, refspecs; options::FetchOptions=FetchOptions(), msg="")
\end{minted}

Fetch from the specified \texttt{rmt} remote git repository, using \texttt{refspecs} to determine which remote branch(es) to fetch. The keyword arguments are:

\begin{itemize}
\item \texttt{options}: determines the options for the fetch, e.g. whether to prune afterwards. See \hyperlink{7474664468985945267}{\texttt{FetchOptions}} for more information.


\item \texttt{msg}: a message to insert into the reflogs.

\end{itemize}



\begin{lstlisting}
fetch(repo::GitRepo; kwargs...)
\end{lstlisting}

Fetches updates from an upstream of the repository \texttt{repo}.

The keyword arguments are:

\begin{itemize}
\item \texttt{remote::AbstractString={\textquotedbl}origin{\textquotedbl}}: which remote, specified by name, of \texttt{repo} to fetch from. If this is empty, the URL will be used to construct an anonymous remote.


\item \texttt{remoteurl::AbstractString={\textquotedbl}{\textquotedbl}}: the URL of \texttt{remote}. If not specified, will be assumed based on the given name of \texttt{remote}.


\item \texttt{refspecs=AbstractString[]}: determines properties of the fetch.


\item \texttt{credentials=nothing}: provides credentials and/or settings when authenticating against a private \texttt{remote}.


\item \texttt{callbacks=Callbacks()}: user provided callbacks and payloads.

\end{itemize}
Equivalent to \texttt{git fetch [<remoteurl>|<repo>] [<refspecs>]}.



\end{adjustwidth}
\hypertarget{17606053504537858539}{} 
\hyperlink{17606053504537858539}{\texttt{LibGit2.fetchheads}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fetchheads(repo::GitRepo) -> Vector{FetchHead}
\end{minted}

Return the list of all the fetch heads for \texttt{repo}, each represented as a \hyperlink{17806809481919147110}{\texttt{FetchHead}}, including their names, URLs, and merge statuses.

\textbf{Examples}


\begin{minted}{jlcon}
julia> fetch_heads = LibGit2.fetchheads(repo);

julia> fetch_heads[1].name
"refs/heads/master"

julia> fetch_heads[1].ismerge
true

julia> fetch_heads[2].name
"refs/heads/test_branch"

julia> fetch_heads[2].ismerge
false
\end{minted}



\end{adjustwidth}
\hypertarget{2305079754843803490}{} 
\hyperlink{2305079754843803490}{\texttt{LibGit2.fetch\_refspecs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fetch_refspecs(rmt::GitRemote) -> Vector{String}
\end{minted}

Get the \emph{fetch} refspecs for the specified \texttt{rmt}. These refspecs contain information about which branch(es) to fetch from.

\textbf{Examples}


\begin{minted}{jlcon}
julia> remote = LibGit2.get(LibGit2.GitRemote, repo, "upstream");

julia> LibGit2.add_fetch!(repo, remote, "upstream");

julia> LibGit2.fetch_refspecs(remote)
String["+refs/heads/*:refs/remotes/upstream/*"]
\end{minted}



\end{adjustwidth}
\hypertarget{14433606895966923953}{} 
\hyperlink{14433606895966923953}{\texttt{LibGit2.fetchhead\_foreach\_cb}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

C function pointer for \texttt{fetchhead\_foreach\_callback}



\end{adjustwidth}
\hypertarget{2535753121792845073}{} 
\hyperlink{2535753121792845073}{\texttt{LibGit2.merge\_base}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
merge_base(repo::GitRepo, one::AbstractString, two::AbstractString) -> GitHash
\end{minted}

Find a merge base (a common ancestor) between the commits \texttt{one} and \texttt{two}. \texttt{one} and \texttt{two} may both be in string form. Return the \texttt{GitHash} of the merge base.



\end{adjustwidth}
\hypertarget{1187901033925205953}{} 
\hyperlink{1187901033925205953}{\texttt{LibGit2.merge!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
merge!(repo::GitRepo; kwargs...) -> Bool
\end{minted}

Perform a git merge on the repository \texttt{repo}, merging commits with diverging history into the current branch. Return \texttt{true} if the merge succeeded, \texttt{false} if not.

The keyword arguments are:

\begin{itemize}
\item \texttt{committish::AbstractString={\textquotedbl}{\textquotedbl}}: Merge the named commit(s) in \texttt{committish}.


\item \texttt{branch::AbstractString={\textquotedbl}{\textquotedbl}}: Merge the branch \texttt{branch} and all its commits since it diverged from the current branch.


\item \texttt{fastforward::Bool=false}: If \texttt{fastforward} is \texttt{true}, only merge if the merge is a fast-forward (the current branch head is an ancestor of the commits to be merged), otherwise refuse to merge and return \texttt{false}. This is equivalent to the git CLI option \texttt{--ff-only}.


\item \texttt{merge\_opts::MergeOptions=MergeOptions()}: \texttt{merge\_opts} specifies options for the merge, such as merge strategy in case of conflicts.


\item \texttt{checkout\_opts::CheckoutOptions=CheckoutOptions()}: \texttt{checkout\_opts} specifies options for the checkout step.

\end{itemize}
Equivalent to \texttt{git merge [--ff-only] [<committish> | <branch>]}.

\begin{quote}
\textbf{Note}

If you specify a \texttt{branch}, this must be done in reference format, since the string will be turned into a \texttt{GitReference}. For example, if you wanted to merge branch \texttt{branch\_a}, you would call \texttt{merge!(repo, branch={\textquotedbl}refs/heads/branch\_a{\textquotedbl})}.

\end{quote}


\end{adjustwidth}
\hypertarget{6081828016566889200}{} 
\hyperlink{6081828016566889200}{\texttt{LibGit2.merge!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
merge!(repo::GitRepo, anns::Vector{GitAnnotated}; kwargs...) -> Bool
\end{minted}

Merge changes from the annotated commits (captured as \hyperlink{9263689983564368210}{\texttt{GitAnnotated}} objects) \texttt{anns} into the HEAD of the repository \texttt{repo}. The keyword arguments are:

\begin{itemize}
\item \texttt{merge\_opts::MergeOptions = MergeOptions()}: options for how to perform the merge, including whether fastforwarding is allowed. See \hyperlink{7663922722360889557}{\texttt{MergeOptions}} for more information.


\item \texttt{checkout\_opts::CheckoutOptions = CheckoutOptions()}: options for how to perform the checkout. See \hyperlink{16441061243067746546}{\texttt{CheckoutOptions}} for more information.

\end{itemize}
\texttt{anns} may refer to remote or local branch heads. Return \texttt{true} if the merge is successful, otherwise return \texttt{false} (for instance, if no merge is possible because the branches have no common ancestor).

\textbf{Examples}


\begin{minted}{julia}
upst_ann = LibGit2.GitAnnotated(repo, "branch/a")

# merge the branch in
LibGit2.merge!(repo, [upst_ann])
\end{minted}



\end{adjustwidth}
\hypertarget{4685130166334465369}{} 
\hyperlink{4685130166334465369}{\texttt{LibGit2.merge!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
merge!(repo::GitRepo, anns::Vector{GitAnnotated}, fastforward::Bool; kwargs...) -> Bool
\end{minted}

Merge changes from the annotated commits (captured as \hyperlink{9263689983564368210}{\texttt{GitAnnotated}} objects) \texttt{anns} into the HEAD of the repository \texttt{repo}. If \texttt{fastforward} is \texttt{true}, \emph{only} a fastforward merge is allowed. In this case, if conflicts occur, the merge will fail. Otherwise, if \texttt{fastforward} is \texttt{false}, the merge may produce a conflict file which the user will need to resolve.

The keyword arguments are:

\begin{itemize}
\item \texttt{merge\_opts::MergeOptions = MergeOptions()}: options for how to perform the merge, including whether fastforwarding is allowed. See \hyperlink{7663922722360889557}{\texttt{MergeOptions}} for more information.


\item \texttt{checkout\_opts::CheckoutOptions = CheckoutOptions()}: options for how to perform the checkout. See \hyperlink{16441061243067746546}{\texttt{CheckoutOptions}} for more information.

\end{itemize}
\texttt{anns} may refer to remote or local branch heads. Return \texttt{true} if the merge is successful, otherwise return \texttt{false} (for instance, if no merge is possible because the branches have no common ancestor).

\textbf{Examples}


\begin{minted}{julia}
upst_ann_1 = LibGit2.GitAnnotated(repo, "branch/a")

# merge the branch in, fastforward
LibGit2.merge!(repo, [upst_ann_1], true)

# merge conflicts!
upst_ann_2 = LibGit2.GitAnnotated(repo, "branch/b")
# merge the branch in, try to fastforward
LibGit2.merge!(repo, [upst_ann_2], true) # will return false
LibGit2.merge!(repo, [upst_ann_2], false) # will return true
\end{minted}



\end{adjustwidth}
\hypertarget{12324560892659859842}{} 
\hyperlink{12324560892659859842}{\texttt{LibGit2.ffmerge!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ffmerge!(repo::GitRepo, ann::GitAnnotated)
\end{minted}

Fastforward merge changes into current HEAD. This is only possible if the commit referred to by \texttt{ann} is descended from the current HEAD (e.g. if pulling changes from a remote branch which is simply ahead of the local branch tip).



\end{adjustwidth}
\hypertarget{2268784022172298907}{} 
\hyperlink{2268784022172298907}{\texttt{LibGit2.fullname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.fullname(ref::GitReference)
\end{minted}

Return the name of the reference pointed to by the symbolic reference \texttt{ref}. If \texttt{ref} is not a symbolic reference, return an empty string.



\end{adjustwidth}
\hypertarget{15490475873131507647}{} 
\hyperlink{15490475873131507647}{\texttt{LibGit2.features}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
features()
\end{minted}

Return a list of git features the current version of libgit2 supports, such as threading or using HTTPS or SSH.



\end{adjustwidth}
\hypertarget{4260849105857148209}{} 
\hyperlink{4260849105857148209}{\texttt{LibGit2.filename}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
filename(te::GitTreeEntry)
\end{minted}

Return the filename of the object on disk to which \texttt{te} refers.



\end{adjustwidth}
\hypertarget{10756827966829509667}{} 
\hyperlink{10756827966829509667}{\texttt{LibGit2.filemode}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
filemode(te::GitTreeEntry) -> Cint
\end{minted}

Return the UNIX filemode of the object on disk to which \texttt{te} refers as an integer.



\end{adjustwidth}
\hypertarget{12125979754140967861}{} 
\hyperlink{12125979754140967861}{\texttt{LibGit2.gitdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.gitdir(repo::GitRepo)
\end{minted}

Return the location of the {\textquotedbl}git{\textquotedbl} files of \texttt{repo}:

\begin{itemize}
\item for normal repositories, this is the location of the \texttt{.git} folder.


\item for bare repositories, this is the location of the repository itself.

\end{itemize}
See also \hyperlink{6689577338311178757}{\texttt{workdir}}, \hyperlink{7655803558162329563}{\texttt{path}}.



\end{adjustwidth}
\hypertarget{12071312184635750746}{} 
\hyperlink{12071312184635750746}{\texttt{LibGit2.git\_url}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.git_url(; kwargs...) -> String
\end{minted}

Create a string based upon the URL components provided. When the \texttt{scheme} keyword is not provided the URL produced will use the alternative \href{https://git-scm.com/docs/git-clone\#\_git\_urls\_a\_id\_urls\_a}{scp-like syntax}.

\textbf{Keywords}

\begin{itemize}
\item \texttt{scheme::AbstractString={\textquotedbl}{\textquotedbl}}: the URL scheme which identifies the protocol to be used. For HTTP use {\textquotedbl}http{\textquotedbl}, SSH use {\textquotedbl}ssh{\textquotedbl}, etc. When \texttt{scheme} is not provided the output format will be {\textquotedbl}ssh{\textquotedbl} but using the scp-like syntax.


\item \texttt{username::AbstractString={\textquotedbl}{\textquotedbl}}: the username to use in the output if provided.


\item \texttt{password::AbstractString={\textquotedbl}{\textquotedbl}}: the password to use in the output if provided.


\item \texttt{host::AbstractString={\textquotedbl}{\textquotedbl}}: the hostname to use in the output. A hostname is required to be specified.


\item \texttt{port::Union\{AbstractString,Integer\}={\textquotedbl}{\textquotedbl}}: the port number to use in the output if provided. Cannot be specified when using the scp-like syntax.


\item \texttt{path::AbstractString={\textquotedbl}{\textquotedbl}}: the path to use in the output if provided.

\end{itemize}
\begin{quote}
\textbf{Warning}

Avoid using passwords in URLs. Unlike the credential objects, Julia is not able to securely zero or destroy the sensitive data after use and the password may remain in memory; possibly to be exposed by an uninitialized memory.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> LibGit2.git_url(username="git", host="github.com", path="JuliaLang/julia.git")
"git@github.com:JuliaLang/julia.git"

julia> LibGit2.git_url(scheme="https", host="github.com", path="/JuliaLang/julia.git")
"https://github.com/JuliaLang/julia.git"

julia> LibGit2.git_url(scheme="ssh", username="git", host="github.com", port=2222, path="JuliaLang/julia.git")
"ssh://git@github.com:2222/JuliaLang/julia.git"
\end{minted}



\end{adjustwidth}
\hypertarget{6260170502036665222}{} 
\hyperlink{6260170502036665222}{\texttt{LibGit2.@githash\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@githash_str -> AbstractGitHash
\end{minted}

Construct a git hash object from the given string, returning a \texttt{GitShortHash} if the string is shorter than 40 hexadecimal digits, otherwise a \texttt{GitHash}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> LibGit2.githash"d114feb74ce633"
GitShortHash("d114feb74ce633")

julia> LibGit2.githash"d114feb74ce63307afe878a5228ad014e0289a85"
GitHash("d114feb74ce63307afe878a5228ad014e0289a85")
\end{minted}



\end{adjustwidth}
\hypertarget{14955163669937294027}{} 
\hyperlink{14955163669937294027}{\texttt{LibGit2.head}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.head(repo::GitRepo) -> GitReference
\end{minted}

Return a \texttt{GitReference} to the current HEAD of \texttt{repo}.




\begin{lstlisting}
head(pkg::AbstractString) -> String
\end{lstlisting}

Return current HEAD \hyperlink{202290709580230708}{\texttt{GitHash}} of the \texttt{pkg} repo as a string.



\end{adjustwidth}
\hypertarget{16482865322979618348}{} 
\hyperlink{16482865322979618348}{\texttt{LibGit2.head!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.head!(repo::GitRepo, ref::GitReference) -> GitReference
\end{minted}

Set the HEAD of \texttt{repo} to the object pointed to by \texttt{ref}.



\end{adjustwidth}
\hypertarget{15860910592870539871}{} 
\hyperlink{15860910592870539871}{\texttt{LibGit2.head\_oid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.head_oid(repo::GitRepo) -> GitHash
\end{minted}

Lookup the object id of the current HEAD of git repository \texttt{repo}.



\end{adjustwidth}
\hypertarget{9819416665219430137}{} 
\hyperlink{9819416665219430137}{\texttt{LibGit2.headname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.headname(repo::GitRepo)
\end{minted}

Lookup the name of the current HEAD of git repository \texttt{repo}. If \texttt{repo} is currently detached, return the name of the HEAD it{\textquotesingle}s detached from.



\end{adjustwidth}
\hypertarget{234151039133609684}{} 
\hyperlink{234151039133609684}{\texttt{LibGit2.init}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.init(path::AbstractString, bare::Bool=false) -> GitRepo
\end{minted}

Open a new git repository at \texttt{path}. If \texttt{bare} is \texttt{false}, the working tree will be created in \texttt{path/.git}. If \texttt{bare} is \texttt{true}, no working directory will be created.



\end{adjustwidth}
\hypertarget{330281650028652704}{} 
\hyperlink{330281650028652704}{\texttt{LibGit2.is\_ancestor\_of}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
is_ancestor_of(a::AbstractString, b::AbstractString, repo::GitRepo) -> Bool
\end{minted}

Return \texttt{true} if \texttt{a}, a \hyperlink{202290709580230708}{\texttt{GitHash}} in string form, is an ancestor of \texttt{b}, a \hyperlink{202290709580230708}{\texttt{GitHash}} in string form.

\textbf{Examples}


\begin{minted}{jlcon}
julia> repo = LibGit2.GitRepo(repo_path);

julia> LibGit2.add!(repo, test_file1);

julia> commit_oid1 = LibGit2.commit(repo, "commit1");

julia> LibGit2.add!(repo, test_file2);

julia> commit_oid2 = LibGit2.commit(repo, "commit2");

julia> LibGit2.is_ancestor_of(string(commit_oid1), string(commit_oid2), repo)
true
\end{minted}



\end{adjustwidth}
\hypertarget{404822283933661526}{} 
\hyperlink{404822283933661526}{\texttt{LibGit2.isbinary}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isbinary(blob::GitBlob) -> Bool
\end{minted}

Use a heuristic to guess if a file is binary: searching for NULL bytes and looking for a reasonable ratio of printable to non-printable characters among the first 8000 bytes.



\end{adjustwidth}
\hypertarget{12031902939660672720}{} 
\hyperlink{12031902939660672720}{\texttt{LibGit2.iscommit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
iscommit(id::AbstractString, repo::GitRepo) -> Bool
\end{minted}

Check if commit \texttt{id} (which is a \hyperlink{202290709580230708}{\texttt{GitHash}} in string form) is in the repository.

\textbf{Examples}


\begin{minted}{jlcon}
julia> repo = LibGit2.GitRepo(repo_path);

julia> LibGit2.add!(repo, test_file);

julia> commit_oid = LibGit2.commit(repo, "add test_file");

julia> LibGit2.iscommit(string(commit_oid), repo)
true
\end{minted}



\end{adjustwidth}
\hypertarget{3509758867865957563}{} 
\hyperlink{3509758867865957563}{\texttt{LibGit2.isdiff}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.isdiff(repo::GitRepo, treeish::AbstractString, pathspecs::AbstractString=""; cached::Bool=false)
\end{minted}

Checks if there are any differences between the tree specified by \texttt{treeish} and the tracked files in the working tree (if \texttt{cached=false}) or the index (if \texttt{cached=true}). \texttt{pathspecs} are the specifications for options for the diff.

\textbf{Examples}


\begin{minted}{julia}
repo = LibGit2.GitRepo(repo_path)
LibGit2.isdiff(repo, "HEAD") # should be false
open(joinpath(repo_path, new_file), "a") do f
    println(f, "here's my cool new file")
end
LibGit2.isdiff(repo, "HEAD") # now true
\end{minted}

Equivalent to \texttt{git diff-index <treeish> [-- <pathspecs>]}.



\end{adjustwidth}
\hypertarget{7941935372196782184}{} 
\hyperlink{7941935372196782184}{\texttt{LibGit2.isdirty}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.isdirty(repo::GitRepo, pathspecs::AbstractString=""; cached::Bool=false) -> Bool
\end{minted}

Check if there have been any changes to tracked files in the working tree (if \texttt{cached=false}) or the index (if \texttt{cached=true}). \texttt{pathspecs} are the specifications for options for the diff.

\textbf{Examples}


\begin{minted}{julia}
repo = LibGit2.GitRepo(repo_path)
LibGit2.isdirty(repo) # should be false
open(joinpath(repo_path, new_file), "a") do f
    println(f, "here's my cool new file")
end
LibGit2.isdirty(repo) # now true
LibGit2.isdirty(repo, new_file) # now true
\end{minted}

Equivalent to \texttt{git diff-index HEAD [-- <pathspecs>]}.



\end{adjustwidth}
\hypertarget{2361675915882834215}{} 
\hyperlink{2361675915882834215}{\texttt{LibGit2.isorphan}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.isorphan(repo::GitRepo)
\end{minted}

Check if the current branch is an {\textquotedbl}orphan{\textquotedbl} branch, i.e. has no commits. The first commit to this branch will have no parents.



\end{adjustwidth}
\hypertarget{2310531182237663864}{} 
\hyperlink{2310531182237663864}{\texttt{LibGit2.isset}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isset(val::Integer, flag::Integer)
\end{minted}

Test whether the bits of \texttt{val} indexed by \texttt{flag} are set (\texttt{1}) or unset (\texttt{0}).



\end{adjustwidth}
\hypertarget{12794222535204600786}{} 
\hyperlink{12794222535204600786}{\texttt{LibGit2.iszero}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
iszero(id::GitHash) -> Bool
\end{minted}

Determine whether all hexadecimal digits of the given \hyperlink{202290709580230708}{\texttt{GitHash}} are zero.



\end{adjustwidth}
\hypertarget{8872141007246166845}{} 
\hyperlink{8872141007246166845}{\texttt{LibGit2.lookup\_branch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lookup_branch(repo::GitRepo, branch_name::AbstractString, remote::Bool=false) -> Union{GitReference, Nothing}
\end{minted}

Determine if the branch specified by \texttt{branch\_name} exists in the repository \texttt{repo}. If \texttt{remote} is \texttt{true}, \texttt{repo} is assumed to be a remote git repository. Otherwise, it is part of the local filesystem.

Return either a \texttt{GitReference} to the requested branch if it exists, or \hyperlink{9331422207248206047}{\texttt{nothing}} if not.



\end{adjustwidth}
\hypertarget{546421066875217314}{} 
\hyperlink{546421066875217314}{\texttt{LibGit2.map}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.map(f::Function, walker::GitRevWalker; oid::GitHash=GitHash(), range::AbstractString="", by::Cint=Consts.SORT_NONE, rev::Bool=false)
\end{minted}

Using the \hyperlink{7800294839307043628}{\texttt{GitRevWalker}} \texttt{walker} to {\textquotedbl}walk{\textquotedbl} over every commit in the repository{\textquotesingle}s history, apply \texttt{f} to each commit in the walk. The keyword arguments are:     * \texttt{oid}: The \hyperlink{202290709580230708}{\texttt{GitHash}} of the commit to begin the walk from. The default is to use       \hyperlink{9792433728015067335}{\texttt{push\_head!}} and therefore the HEAD commit and all its ancestors.     * \texttt{range}: A range of \texttt{GitHash}s in the format \texttt{oid1..oid2}. \texttt{f} will be       applied to all commits between the two.     * \texttt{by}: The sorting method. The default is not to sort. Other options are to sort by       topology (\texttt{LibGit2.Consts.SORT\_TOPOLOGICAL}), to sort forwards in time       (\texttt{LibGit2.Consts.SORT\_TIME}, most ancient first) or to sort backwards in time       (\texttt{LibGit2.Consts.SORT\_REVERSE}, most recent first).     * \texttt{rev}: Whether to reverse the sorted order (for instance, if topological sorting is used).

\textbf{Examples}


\begin{minted}{julia}
oids = LibGit2.with(LibGit2.GitRevWalker(repo)) do walker
    LibGit2.map((oid, repo)->string(oid), walker, by=LibGit2.Consts.SORT_TIME)
end
\end{minted}

Here, \texttt{map} visits each commit using the \texttt{GitRevWalker} and finds its \texttt{GitHash}.



\end{adjustwidth}
\hypertarget{3649636619945218341}{} 
\hyperlink{3649636619945218341}{\texttt{LibGit2.mirror\_callback}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Mirror callback function

Function sets \texttt{+refs/*:refs/*} refspecs and \texttt{mirror} flag for remote reference.



\end{adjustwidth}
\hypertarget{381062800465562522}{} 
\hyperlink{381062800465562522}{\texttt{LibGit2.mirror\_cb}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

C function pointer for \texttt{mirror\_callback}



\end{adjustwidth}
\hypertarget{8348936587496719270}{} 
\hyperlink{8348936587496719270}{\texttt{LibGit2.message}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
message(c::GitCommit, raw::Bool=false)
\end{minted}

Return the commit message describing the changes made in commit \texttt{c}. If \texttt{raw} is \texttt{false}, return a slightly {\textquotedbl}cleaned up{\textquotedbl} message (which has any leading newlines removed). If \texttt{raw} is \texttt{true}, the message is not stripped of any such newlines.



\end{adjustwidth}
\hypertarget{8167742111561542209}{} 
\hyperlink{8167742111561542209}{\texttt{LibGit2.merge\_analysis}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
merge_analysis(repo::GitRepo, anns::Vector{GitAnnotated}) -> analysis, preference
\end{minted}

Run analysis on the branches pointed to by the annotated branch tips \texttt{anns} and determine under what circumstances they can be merged. For instance, if \texttt{anns[1]} is simply an ancestor of \texttt{ann[2]}, then \texttt{merge\_analysis} will report that a fast-forward merge is possible.

Return two outputs, \texttt{analysis} and \texttt{preference}. \texttt{analysis} has several possible values:     * \texttt{MERGE\_ANALYSIS\_NONE}: it is not possible to merge the elements of \texttt{anns}.     * \texttt{MERGE\_ANALYSIS\_NORMAL}: a regular merge, when HEAD and the commits that the       user wishes to merge have all diverged from a common ancestor. In this case the       changes have to be resolved and conflicts may occur.     * \texttt{MERGE\_ANALYSIS\_UP\_TO\_DATE}: all the input commits the user wishes to merge can       be reached from HEAD, so no merge needs to be performed.     * \texttt{MERGE\_ANALYSIS\_FASTFORWARD}: the input commit is a descendant of HEAD and so no       merge needs to be performed - instead, the user can simply checkout the       input commit(s).     * \texttt{MERGE\_ANALYSIS\_UNBORN}: the HEAD of the repository refers to a commit which does not       exist. It is not possible to merge, but it may be possible to checkout the input       commits. \texttt{preference} also has several possible values:     * \texttt{MERGE\_PREFERENCE\_NONE}: the user has no preference.     * \texttt{MERGE\_PREFERENCE\_NO\_FASTFORWARD}: do not allow any fast-forward merges.     * \texttt{MERGE\_PREFERENCE\_FASTFORWARD\_ONLY}: allow only fast-forward merges and no       other type (which may introduce conflicts). \texttt{preference} can be controlled through the repository or global git configuration.



\end{adjustwidth}
\hypertarget{2421524004789353091}{} 
\hyperlink{2421524004789353091}{\texttt{LibGit2.name}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.name(ref::GitReference)
\end{minted}

Return the full name of \texttt{ref}.




\begin{lstlisting}
name(rmt::GitRemote)
\end{lstlisting}

Get the name of a remote repository, for instance \texttt{{\textquotedbl}origin{\textquotedbl}}. If the remote is anonymous (see \hyperlink{13915605113589562056}{\texttt{GitRemoteAnon}}) the name will be an empty string \texttt{{\textquotedbl}{\textquotedbl}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> repo_url = "https://github.com/JuliaLang/Example.jl";

julia> repo = LibGit2.clone(cache_repo, "test_directory");

julia> remote = LibGit2.GitRemote(repo, "origin", repo_url);

julia> name(remote)
"origin"
\end{minted}




\begin{lstlisting}
LibGit2.name(tag::GitTag)
\end{lstlisting}

The name of \texttt{tag} (e.g. \texttt{{\textquotedbl}v0.5{\textquotedbl}}).



\end{adjustwidth}
\hypertarget{7748563965577890862}{} 
\hyperlink{7748563965577890862}{\texttt{LibGit2.need\_update}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
need_update(repo::GitRepo)
\end{minted}

Equivalent to \texttt{git update-index}. Return \texttt{true} if \texttt{repo} needs updating.



\end{adjustwidth}
\hypertarget{5024227788763319693}{} 
\hyperlink{5024227788763319693}{\texttt{LibGit2.objtype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
objtype(obj_type::Consts.OBJECT)
\end{minted}

Return the type corresponding to the enum value.



\end{adjustwidth}
\hypertarget{7655803558162329563}{} 
\hyperlink{7655803558162329563}{\texttt{LibGit2.path}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.path(repo::GitRepo)
\end{minted}

Return the base file path of the repository \texttt{repo}.

\begin{itemize}
\item for normal repositories, this will typically be the parent directory of the {\textquotedbl}.git{\textquotedbl} directory (note: this may be different than the working directory, see \texttt{workdir} for more details).


\item for bare repositories, this is the location of the {\textquotedbl}git{\textquotedbl} files.

\end{itemize}
See also \hyperlink{12125979754140967861}{\texttt{gitdir}}, \hyperlink{6689577338311178757}{\texttt{workdir}}.



\end{adjustwidth}
\hypertarget{16139465008527879046}{} 
\hyperlink{16139465008527879046}{\texttt{LibGit2.peel}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
peel([T,] ref::GitReference)
\end{minted}

Recursively peel \texttt{ref} until an object of type \texttt{T} is obtained. If no \texttt{T} is provided, then \texttt{ref} will be peeled until an object other than a \hyperlink{10467695058580020738}{\texttt{GitTag}} is obtained.

\begin{itemize}
\item A \texttt{GitTag} will be peeled to the object it references.


\item A \hyperlink{5346527129202716606}{\texttt{GitCommit}} will be peeled to a \hyperlink{6242150303858692069}{\texttt{GitTree}}.

\end{itemize}
\begin{quote}
\textbf{Note}

Only annotated tags can be peeled to \texttt{GitTag} objects. Lightweight tags (the default) are references under \texttt{refs/tags/} which point directly to \texttt{GitCommit} objects.

\end{quote}



\begin{lstlisting}
peel([T,] obj::GitObject)
\end{lstlisting}

Recursively peel \texttt{obj} until an object of type \texttt{T} is obtained. If no \texttt{T} is provided, then \texttt{obj} will be peeled until the type changes.

\begin{itemize}
\item A \texttt{GitTag} will be peeled to the object it references.


\item A \texttt{GitCommit} will be peeled to a \texttt{GitTree}.

\end{itemize}


\end{adjustwidth}
\hypertarget{8201535180875495206}{} 
\hyperlink{8201535180875495206}{\texttt{LibGit2.posixpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.posixpath(path)
\end{minted}

Standardise the path string \texttt{path} to use POSIX separators.



\end{adjustwidth}
\hypertarget{9401118176170322302}{} 
\hyperlink{9401118176170322302}{\texttt{LibGit2.push}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
push(rmt::GitRemote, refspecs; force::Bool=false, options::PushOptions=PushOptions())
\end{minted}

Push to the specified \texttt{rmt} remote git repository, using \texttt{refspecs} to determine which remote branch(es) to push to. The keyword arguments are:

\begin{itemize}
\item \texttt{force}: if \texttt{true}, a force-push will occur, disregarding conflicts.


\item \texttt{options}: determines the options for the push, e.g. which proxy headers to use. See \hyperlink{13899785564428555533}{\texttt{PushOptions}} for more information.

\end{itemize}
\begin{quote}
\textbf{Note}

You can add information about the push refspecs in two other ways: by setting an option in the repository{\textquotesingle}s \texttt{GitConfig} (with \texttt{push.default} as the key) or by calling \hyperlink{2424007891894294055}{\texttt{add\_push!}}. Otherwise you will need to explicitly specify a push refspec in the call to \texttt{push} for it to have any effect, like so: \texttt{LibGit2.push(repo, refspecs=[{\textquotedbl}refs/heads/master{\textquotedbl}])}.

\end{quote}



\begin{lstlisting}
push(repo::GitRepo; kwargs...)
\end{lstlisting}

Pushes updates to an upstream of \texttt{repo}.

The keyword arguments are:

\begin{itemize}
\item \texttt{remote::AbstractString={\textquotedbl}origin{\textquotedbl}}: the name of the upstream remote to push to.


\item \texttt{remoteurl::AbstractString={\textquotedbl}{\textquotedbl}}: the URL of \texttt{remote}.


\item \texttt{refspecs=AbstractString[]}: determines properties of the push.


\item \texttt{force::Bool=false}: determines if the push will be a force push,  overwriting the remote branch.


\item \texttt{credentials=nothing}: provides credentials and/or settings when authenticating against  a private \texttt{remote}.


\item \texttt{callbacks=Callbacks()}: user provided callbacks and payloads.

\end{itemize}
Equivalent to \texttt{git push [<remoteurl>|<repo>] [<refspecs>]}.



\end{adjustwidth}
\hypertarget{1094911863830060497}{} 
\hyperlink{1094911863830060497}{\texttt{LibGit2.push!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.push!(w::GitRevWalker, cid::GitHash)
\end{minted}

Start the \hyperlink{7800294839307043628}{\texttt{GitRevWalker}} \texttt{walker} at commit \texttt{cid}. This function can be used to apply a function to all commits since a certain year, by passing the first commit of that year as \texttt{cid} and then passing the resulting \texttt{w} to \hyperlink{546421066875217314}{\texttt{map}}.



\end{adjustwidth}
\hypertarget{9792433728015067335}{} 
\hyperlink{9792433728015067335}{\texttt{LibGit2.push\_head!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.push_head!(w::GitRevWalker)
\end{minted}

Push the HEAD commit and its ancestors onto the \hyperlink{7800294839307043628}{\texttt{GitRevWalker}} \texttt{w}. This ensures that HEAD and all its ancestor commits will be encountered during the walk.



\end{adjustwidth}
\hypertarget{13692255696673908343}{} 
\hyperlink{13692255696673908343}{\texttt{LibGit2.push\_refspecs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
push_refspecs(rmt::GitRemote) -> Vector{String}
\end{minted}

Get the \emph{push} refspecs for the specified \texttt{rmt}. These refspecs contain information about which branch(es) to push to.

\textbf{Examples}


\begin{minted}{jlcon}
julia> remote = LibGit2.get(LibGit2.GitRemote, repo, "upstream");

julia> LibGit2.add_push!(repo, remote, "refs/heads/master");

julia> close(remote);

julia> remote = LibGit2.get(LibGit2.GitRemote, repo, "upstream");

julia> LibGit2.push_refspecs(remote)
String["refs/heads/master"]
\end{minted}



\end{adjustwidth}
\hypertarget{17280494735661401954}{} 
\hyperlink{17280494735661401954}{\texttt{LibGit2.raw}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
raw(id::GitHash) -> Vector{UInt8}
\end{minted}

Obtain the raw bytes of the \hyperlink{202290709580230708}{\texttt{GitHash}} as a vector of length 20.



\end{adjustwidth}
\hypertarget{8133295290894494359}{} 
\hyperlink{8133295290894494359}{\texttt{LibGit2.read\_tree!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.read_tree!(idx::GitIndex, tree::GitTree)
LibGit2.read_tree!(idx::GitIndex, treehash::AbstractGitHash)
\end{minted}

Read the tree \texttt{tree} (or the tree pointed to by \texttt{treehash} in the repository owned by \texttt{idx}) into the index \texttt{idx}. The current index contents will be replaced.



\end{adjustwidth}
\hypertarget{14810332437858061232}{} 
\hyperlink{14810332437858061232}{\texttt{LibGit2.rebase!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.rebase!(repo::GitRepo, upstream::AbstractString="", newbase::AbstractString="")
\end{minted}

Attempt an automatic merge rebase of the current branch, from \texttt{upstream} if provided, or otherwise from the upstream tracking branch. \texttt{newbase} is the branch to rebase onto. By default this is \texttt{upstream}.

If any conflicts arise which cannot be automatically resolved, the rebase will abort, leaving the repository and working tree in its original state, and the function will throw a \texttt{GitError}. This is roughly equivalent to the following command line statement:


\begin{lstlisting}
git rebase --merge [<upstream>]
if [ -d ".git/rebase-merge" ]; then
    git rebase --abort
fi
\end{lstlisting}



\end{adjustwidth}
\hypertarget{12847926185465464483}{} 
\hyperlink{12847926185465464483}{\texttt{LibGit2.ref\_list}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.ref_list(repo::GitRepo) -> Vector{String}
\end{minted}

Get a list of all reference names in the \texttt{repo} repository.



\end{adjustwidth}
\hypertarget{5156390520855755168}{} 
\hyperlink{5156390520855755168}{\texttt{LibGit2.reftype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.reftype(ref::GitReference) -> Cint
\end{minted}

Return a \texttt{Cint} corresponding to the type of \texttt{ref}:

\begin{itemize}
\item \texttt{0} if the reference is invalid


\item \texttt{1} if the reference is an object id


\item \texttt{2} if the reference is symbolic

\end{itemize}


\end{adjustwidth}
\hypertarget{5507389887346241045}{} 
\hyperlink{5507389887346241045}{\texttt{LibGit2.remotes}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.remotes(repo::GitRepo)
\end{minted}

Return a vector of the names of the remotes of \texttt{repo}.



\end{adjustwidth}
\hypertarget{12673554228490546577}{} 
\hyperlink{12673554228490546577}{\texttt{LibGit2.remove!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
remove!(repo::GitRepo, files::AbstractString...)
remove!(idx::GitIndex, files::AbstractString...)
\end{minted}

Remove all the files with paths specified by \texttt{files} in the index \texttt{idx} (or the index of the \texttt{repo}).



\end{adjustwidth}
\hypertarget{6133575189326240402}{} 
\hyperlink{6133575189326240402}{\texttt{LibGit2.reset}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reset(val::Integer, flag::Integer)
\end{minted}

Unset the bits of \texttt{val} indexed by \texttt{flag}, returning them to \texttt{0}.



\end{adjustwidth}
\hypertarget{6684497681285141047}{} 
\hyperlink{6684497681285141047}{\texttt{LibGit2.reset!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reset!(payload, [config]) -> CredentialPayload
\end{minted}

Reset the \texttt{payload} state back to the initial values so that it can be used again within the credential callback. If a \texttt{config} is provided the configuration will also be updated.



Updates some entries, determined by the \texttt{pathspecs}, in the index from the target commit tree.



Sets the current head to the specified commit oid and optionally resets the index and working tree to match.



git reset [<committish>] [–] <pathspecs>... 




\begin{lstlisting}
reset!(repo::GitRepo, id::GitHash, mode::Cint=Consts.RESET_MIXED)
\end{lstlisting}

Reset the repository \texttt{repo} to its state at \texttt{id}, using one of three modes set by \texttt{mode}:

\begin{itemize}
\item[1. ] \texttt{Consts.RESET\_SOFT} - move HEAD to \texttt{id}.


\item[2. ] \texttt{Consts.RESET\_MIXED} - default, move HEAD to \texttt{id} and reset the index to \texttt{id}.


\item[3. ] \texttt{Consts.RESET\_HARD} - move HEAD to \texttt{id}, reset the index to \texttt{id}, and discard all working changes.

\end{itemize}
\textbf{Examples}


\begin{minted}{julia}
# fetch changes
LibGit2.fetch(repo)
isfile(joinpath(repo_path, our_file)) # will be false

# fastforward merge the changes
LibGit2.merge!(repo, fastforward=true)

# because there was not any file locally, but there is
# a file remotely, we need to reset the branch
head_oid = LibGit2.head_oid(repo)
new_head = LibGit2.reset!(repo, head_oid, LibGit2.Consts.RESET_HARD)
\end{minted}

In this example, the remote which is being fetched from \emph{does} have a file called \texttt{our\_file} in its index, which is why we must reset.

Equivalent to \texttt{git reset [--soft | --mixed | --hard] <id>}.

\textbf{Examples}


\begin{minted}{julia}
repo = LibGit2.GitRepo(repo_path)
head_oid = LibGit2.head_oid(repo)
open(joinpath(repo_path, "file1"), "w") do f
    write(f, "111
")
end
LibGit2.add!(repo, "file1")
mode = LibGit2.Consts.RESET_HARD
# will discard the changes to file1
# and unstage it
new_head = LibGit2.reset!(repo, head_oid, mode)
\end{minted}



\end{adjustwidth}
\hypertarget{1068934750891016732}{} 
\hyperlink{1068934750891016732}{\texttt{LibGit2.restore}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
restore(s::State, repo::GitRepo)
\end{minted}

Return a repository \texttt{repo} to a previous \texttt{State} \texttt{s}, for example the HEAD of a branch before a merge attempt. \texttt{s} can be generated using the \hyperlink{5664620894068288269}{\texttt{snapshot}} function.



\end{adjustwidth}
\hypertarget{3220704891875596639}{} 
\hyperlink{3220704891875596639}{\texttt{LibGit2.revcount}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.revcount(repo::GitRepo, commit1::AbstractString, commit2::AbstractString)
\end{minted}

List the number of revisions between \texttt{commit1} and \texttt{commit2} (committish OIDs in string form). Since \texttt{commit1} and \texttt{commit2} may be on different branches, \texttt{revcount} performs a {\textquotedbl}left-right{\textquotedbl} revision list (and count), returning a tuple of \texttt{Int}s - the number of left and right commits, respectively. A left (or right) commit refers to which side of a symmetric difference in a tree the commit is reachable from.

Equivalent to \texttt{git rev-list --left-right --count <commit1> <commit2>}.

\textbf{Examples}


\begin{minted}{julia}
repo = LibGit2.GitRepo(repo_path)
repo_file = open(joinpath(repo_path, test_file), "a")
println(repo_file, "hello world")
flush(repo_file)
LibGit2.add!(repo, test_file)
commit_oid1 = LibGit2.commit(repo, "commit 1")
println(repo_file, "hello world again")
flush(repo_file)
LibGit2.add!(repo, test_file)
commit_oid2 = LibGit2.commit(repo, "commit 2")
LibGit2.revcount(repo, string(commit_oid1), string(commit_oid2))
\end{minted}

This will return \texttt{(-1, 0)}.



\end{adjustwidth}
\hypertarget{17796350858376315108}{} 
\hyperlink{17796350858376315108}{\texttt{LibGit2.set\_remote\_url}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
set_remote_url(repo::GitRepo, remote_name, url)
set_remote_url(repo::String, remote_name, url)
\end{minted}

Set both the fetch and push \texttt{url} for \texttt{remote\_name} for the \hyperlink{3263346103236484748}{\texttt{GitRepo}} or the git repository located at \texttt{path}. Typically git repos use \texttt{{\textquotedbl}origin{\textquotedbl}} as the remote name.

\textbf{Examples}


\begin{minted}{julia}
repo_path = joinpath(tempdir(), "Example")
repo = LibGit2.init(repo_path)
LibGit2.set_remote_url(repo, "upstream", "https://github.com/JuliaLang/Example.jl")
LibGit2.set_remote_url(repo_path, "upstream2", "https://github.com/JuliaLang/Example2.jl")
\end{minted}



\end{adjustwidth}
\hypertarget{16470264269906288721}{} 
\hyperlink{16470264269906288721}{\texttt{LibGit2.shortname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.shortname(ref::GitReference)
\end{minted}

Return a shortened version of the name of \texttt{ref} that{\textquotesingle}s {\textquotedbl}human-readable{\textquotedbl}.


\begin{minted}{jlcon}
julia> repo = LibGit2.GitRepo(path_to_repo);

julia> branch_ref = LibGit2.head(repo);

julia> LibGit2.name(branch_ref)
"refs/heads/master"

julia> LibGit2.shortname(branch_ref)
"master"
\end{minted}



\end{adjustwidth}
\hypertarget{5664620894068288269}{} 
\hyperlink{5664620894068288269}{\texttt{LibGit2.snapshot}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
snapshot(repo::GitRepo) -> State
\end{minted}

Take a snapshot of the current state of the repository \texttt{repo}, storing the current HEAD, index, and any uncommitted work. The output \texttt{State} can be used later during a call to \hyperlink{1068934750891016732}{\texttt{restore}} to return the repository to the snapshotted state.



\end{adjustwidth}
\hypertarget{709196314204873648}{} 
\hyperlink{709196314204873648}{\texttt{LibGit2.split\_cfg\_entry}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.split_cfg_entry(ce::LibGit2.ConfigEntry) -> Tuple{String,String,String,String}
\end{minted}

Break the \texttt{ConfigEntry} up to the following pieces: section, subsection, name, and value.

\textbf{Examples}

Given the git configuration file containing:


\begin{lstlisting}
[credential "https://example.com"]
    username = me
\end{lstlisting}

The \texttt{ConfigEntry} would look like the following:


\begin{minted}{jlcon}
julia> entry
ConfigEntry("credential.https://example.com.username", "me")

julia> LibGit2.split_cfg_entry(entry)
("credential", "https://example.com", "username", "me")
\end{minted}

Refer to the \href{https://git-scm.com/docs/git-config\#\_syntax}{git config syntax documentation} for more details.



\end{adjustwidth}
\hypertarget{8948863044724673987}{} 
\hyperlink{8948863044724673987}{\texttt{LibGit2.status}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.status(repo::GitRepo, path::String) -> Union{Cuint, Cvoid}
\end{minted}

Lookup the status of the file at \texttt{path} in the git repository \texttt{repo}. For instance, this can be used to check if the file at \texttt{path} has been modified and needs to be staged and committed.



\end{adjustwidth}
\hypertarget{3859390867093299114}{} 
\hyperlink{3859390867093299114}{\texttt{LibGit2.stage}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stage(ie::IndexEntry) -> Cint
\end{minted}

Get the stage number of \texttt{ie}. The stage number \texttt{0} represents the current state of the working tree, but other numbers can be used in the case of a merge conflict. In such a case, the various stage numbers on an \texttt{IndexEntry} describe which side(s) of the conflict the current state of the file belongs to. Stage \texttt{0} is the state before the attempted merge, stage \texttt{1} is the changes which have been made locally, stages \texttt{2} and larger are for changes from other branches (for instance, in the case of a multi-branch {\textquotedbl}octopus{\textquotedbl} merge, stages \texttt{2}, \texttt{3}, and \texttt{4} might be used).



\end{adjustwidth}
\hypertarget{4898692620083276733}{} 
\hyperlink{4898692620083276733}{\texttt{LibGit2.tag\_create}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.tag_create(repo::GitRepo, tag::AbstractString, commit; kwargs...)
\end{minted}

Create a new git tag \texttt{tag} (e.g. \texttt{{\textquotedbl}v0.5{\textquotedbl}}) in the repository \texttt{repo}, at the commit \texttt{commit}.

The keyword arguments are:

\begin{itemize}
\item \texttt{msg::AbstractString={\textquotedbl}{\textquotedbl}}: the message for the tag.


\item \texttt{force::Bool=false}: if \texttt{true}, existing references will be overwritten.


\item \texttt{sig::Signature=Signature(repo)}: the tagger{\textquotesingle}s signature.

\end{itemize}


\end{adjustwidth}
\hypertarget{7680948887680773639}{} 
\hyperlink{7680948887680773639}{\texttt{LibGit2.tag\_delete}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.tag_delete(repo::GitRepo, tag::AbstractString)
\end{minted}

Remove the git tag \texttt{tag} from the repository \texttt{repo}.



\end{adjustwidth}
\hypertarget{7061472492129884254}{} 
\hyperlink{7061472492129884254}{\texttt{LibGit2.tag\_list}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.tag_list(repo::GitRepo) -> Vector{String}
\end{minted}

Get a list of all tags in the git repository \texttt{repo}.



\end{adjustwidth}
\hypertarget{14775566063016633781}{} 
\hyperlink{14775566063016633781}{\texttt{LibGit2.target}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.target(tag::GitTag)
\end{minted}

The \texttt{GitHash} of the target object of \texttt{tag}.



\end{adjustwidth}
\hypertarget{6271025014547744112}{} 
\hyperlink{6271025014547744112}{\texttt{LibGit2.toggle}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
toggle(val::Integer, flag::Integer)
\end{minted}

Flip the bits of \texttt{val} indexed by \texttt{flag}, so that if a bit is \texttt{0} it will be \texttt{1} after the toggle, and vice-versa.



\end{adjustwidth}
\hypertarget{11557958455666787225}{} 
\hyperlink{11557958455666787225}{\texttt{LibGit2.transact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
transact(f::Function, repo::GitRepo)
\end{minted}

Apply function \texttt{f} to the git repository \texttt{repo}, taking a \hyperlink{5664620894068288269}{\texttt{snapshot}} before applying \texttt{f}. If an error occurs within \texttt{f}, \texttt{repo} will be returned to its snapshot state using \hyperlink{1068934750891016732}{\texttt{restore}}. The error which occurred will be rethrown, but the state of \texttt{repo} will not be corrupted.



\end{adjustwidth}
\hypertarget{11991883748960508451}{} 
\hyperlink{11991883748960508451}{\texttt{LibGit2.treewalk}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
treewalk(f, tree::GitTree, post::Bool=false)
\end{minted}

Traverse the entries in \texttt{tree} and its subtrees in post or pre order. Preorder means beginning at the root and then traversing the leftmost subtree (and recursively on down through that subtree{\textquotesingle}s leftmost subtrees) and moving right through the subtrees. Postorder means beginning at the bottom of the leftmost subtree, traversing upwards through it, then traversing the next right subtree (again beginning at the bottom) and finally visiting the tree root last of all.

The function parameter \texttt{f} should have following signature:


\begin{lstlisting}
(String, GitTreeEntry) -> Cint
\end{lstlisting}

A negative value returned from \texttt{f} stops the tree walk. A positive value means that the entry will be skipped if \texttt{post} is \texttt{false}.



\end{adjustwidth}
\hypertarget{14916286790794253178}{} 
\hyperlink{14916286790794253178}{\texttt{LibGit2.upstream}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
upstream(ref::GitReference) -> Union{GitReference, Nothing}
\end{minted}

Determine if the branch containing \texttt{ref} has a specified upstream branch.

Return either a \texttt{GitReference} to the upstream branch if it exists, or \hyperlink{9331422207248206047}{\texttt{nothing}} if the requested branch does not have an upstream counterpart.



\end{adjustwidth}
\hypertarget{3010892674015914384}{} 
\hyperlink{3010892674015914384}{\texttt{LibGit2.update!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
update!(repo::GitRepo, files::AbstractString...)
update!(idx::GitIndex, files::AbstractString...)
\end{minted}

Update all the files with paths specified by \texttt{files} in the index \texttt{idx} (or the index of the \texttt{repo}). Match the state of each file in the index with the current state on disk, removing it if it has been removed on disk, or updating its entry in the object database.



\end{adjustwidth}
\hypertarget{2040666647044196560}{} 
\hyperlink{2040666647044196560}{\texttt{LibGit2.url}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
url(rmt::GitRemote)
\end{minted}

Get the fetch URL of a remote git repository.

\textbf{Examples}


\begin{minted}{jlcon}
julia> repo_url = "https://github.com/JuliaLang/Example.jl";

julia> repo = LibGit2.init(mktempdir());

julia> remote = LibGit2.GitRemote(repo, "origin", repo_url);

julia> LibGit2.url(remote)
"https://github.com/JuliaLang/Example.jl"
\end{minted}



\end{adjustwidth}
\hypertarget{18107764583308594889}{} 
\hyperlink{18107764583308594889}{\texttt{LibGit2.version}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
version() -> VersionNumber
\end{minted}

Return the version of libgit2 in use, as a \hyperlink{12935585355849408291}{\texttt{VersionNumber}}.



\end{adjustwidth}
\hypertarget{11949205828120857817}{} 
\hyperlink{11949205828120857817}{\texttt{LibGit2.with}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
with(f::Function, obj)
\end{minted}

Resource management helper function. Applies \texttt{f} to \texttt{obj}, making sure to call \texttt{close} on \texttt{obj} after \texttt{f} successfully returns or throws an error. Ensures that allocated git resources are finalized as soon as they are no longer needed.



\end{adjustwidth}
\hypertarget{17446520273049220374}{} 
\hyperlink{17446520273049220374}{\texttt{LibGit2.with\_warn}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
with_warn(f::Function, ::Type{T}, args...)
\end{minted}

Resource management helper function. Apply \texttt{f} to \texttt{args}, first constructing an instance of type \texttt{T} from \texttt{args}. Makes sure to call \texttt{close} on the resulting object after \texttt{f} successfully returns or throws an error. Ensures that allocated git resources are finalized as soon as they are no longer needed. If an error is thrown by \texttt{f}, a warning is shown containing the error.



\end{adjustwidth}
\hypertarget{6689577338311178757}{} 
\hyperlink{6689577338311178757}{\texttt{LibGit2.workdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.workdir(repo::GitRepo)
\end{minted}

Return the location of the working directory of \texttt{repo}. This will throw an error for bare repositories.

\begin{quote}
\textbf{Note}

This will typically be the parent directory of \texttt{gitdir(repo)}, but can be different in some cases: e.g. if either the \texttt{core.worktree} configuration variable or the \texttt{GIT\_WORK\_TREE} environment variable is set.

\end{quote}
See also \hyperlink{12125979754140967861}{\texttt{gitdir}}, \hyperlink{7655803558162329563}{\texttt{path}}.



\end{adjustwidth}
\hypertarget{12199863114467893789}{} 
\hyperlink{12199863114467893789}{\texttt{LibGit2.GitObject}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
(::Type{T})(te::GitTreeEntry) where T<:GitObject
\end{minted}

Get the git object to which \texttt{te} refers and return it as its actual type (the type \hyperlink{5430515144387502914}{\texttt{entrytype}} would show), for instance a \texttt{GitBlob} or \texttt{GitTag}.

\textbf{Examples}


\begin{minted}{julia}
tree = LibGit2.GitTree(repo, "HEAD^{tree}")
tree_entry = tree[1]
blob = LibGit2.GitBlob(tree_entry)
\end{minted}



\end{adjustwidth}
\hypertarget{14233399752683117201}{} 
\hyperlink{14233399752683117201}{\texttt{LibGit2.UserPasswordCredential}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

Credential that support only \texttt{user} and \texttt{password} parameters



\end{adjustwidth}
\hypertarget{10065416427289604487}{} 
\hyperlink{10065416427289604487}{\texttt{LibGit2.SSHCredential}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

SSH credential type



\end{adjustwidth}
\hypertarget{10844720204154576193}{} 
\hyperlink{10844720204154576193}{\texttt{LibGit2.isfilled}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isfilled(cred::AbstractCredential) -> Bool
\end{minted}

Verifies that a credential is ready for use in authentication.



\end{adjustwidth}
\hypertarget{8879321221473200614}{} 
\hyperlink{8879321221473200614}{\texttt{LibGit2.CachedCredentials}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

Caches credential information for re-use



\end{adjustwidth}
\hypertarget{10030132349633212983}{} 
\hyperlink{10030132349633212983}{\texttt{LibGit2.CredentialPayload}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.CredentialPayload
\end{minted}

Retains the state between multiple calls to the credential callback for the same URL. A \texttt{CredentialPayload} instance is expected to be \texttt{reset!} whenever it will be used with a different URL.



\end{adjustwidth}
\hypertarget{15851737231324263444}{} 
\hyperlink{15851737231324263444}{\texttt{LibGit2.approve}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
approve(payload::CredentialPayload; shred::Bool=true) -> Nothing
\end{minted}

Store the \texttt{payload} credential for re-use in a future authentication. Should only be called when authentication was successful.

The \texttt{shred} keyword controls whether sensitive information in the payload credential field should be destroyed. Should only be set to \texttt{false} during testing.



\end{adjustwidth}
\hypertarget{17184615468062555134}{} 
\hyperlink{17184615468062555134}{\texttt{LibGit2.reject}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reject(payload::CredentialPayload; shred::Bool=true) -> Nothing
\end{minted}

Discard the \texttt{payload} credential from begin re-used in future authentication. Should only be called when authentication was unsuccessful.

The \texttt{shred} keyword controls whether sensitive information in the payload credential field should be destroyed. Should only be set to \texttt{false} during testing.



\end{adjustwidth}

\hypertarget{13528239852401045842}{}


\chapter{动态链接器}


\hypertarget{8171750449393676854}{} 
\hyperlink{8171750449393676854}{\texttt{Libdl.dlopen}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dlopen(libfile::AbstractString [, flags::Integer]; throw_error:Bool = true)
\end{minted}

Load a shared library, returning an opaque handle.

The extension given by the constant \texttt{dlext} (\texttt{.so}, \texttt{.dll}, or \texttt{.dylib}) can be omitted from the \texttt{libfile} string, as it is automatically appended if needed.   If \texttt{libfile} is not an absolute path name, then the paths in the array \texttt{DL\_LOAD\_PATH} are searched for \texttt{libfile}, followed by the system load path.

The optional flags argument is a bitwise-or of zero or more of \texttt{RTLD\_LOCAL}, \texttt{RTLD\_GLOBAL}, \texttt{RTLD\_LAZY}, \texttt{RTLD\_NOW}, \texttt{RTLD\_NODELETE}, \texttt{RTLD\_NOLOAD}, \texttt{RTLD\_DEEPBIND}, and \texttt{RTLD\_FIRST}. These are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS) dlopen command, if possible, or are ignored if the specified functionality is not available on the current platform. The default flags are platform specific. On MacOS the default \texttt{dlopen} flags are \texttt{RTLD\_LAZY|RTLD\_DEEPBIND|RTLD\_GLOBAL} while on other platforms the defaults are \texttt{RTLD\_LAZY|RTLD\_DEEPBIND|RTLD\_LOCAL}. An important usage of these flags is to specify non default behavior for when the dynamic library loader binds library references to exported symbols and if the bound references are put into process local or global scope. For instance \texttt{RTLD\_LAZY|RTLD\_DEEPBIND|RTLD\_GLOBAL} allows the library{\textquotesingle}s symbols to be available for usage in other shared libraries, addressing situations where there are dependencies between shared libraries.

If the library cannot be found, this method throws an error, unless the keyword argument \texttt{throw\_error} is set to \texttt{false}, in which case this method returns \texttt{nothing}.



\end{adjustwidth}
\hypertarget{10728988161738445989}{} 
\hyperlink{10728988161738445989}{\texttt{Libdl.dlopen\_e}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dlopen_e(libfile::AbstractString [, flags::Integer])
\end{minted}

Similar to \hyperlink{8171750449393676854}{\texttt{dlopen}}, except returns \texttt{C\_NULL} instead of raising errors. This method is now deprecated in favor of \texttt{dlopen(libfile::AbstractString [, flags::Integer]; throw\_error=false)}.



\end{adjustwidth}
\hypertarget{8137158678557353815}{} 
\hyperlink{8137158678557353815}{\texttt{Libdl.RTLD\_NOW}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RTLD_DEEPBIND
RTLD_FIRST
RTLD_GLOBAL
RTLD_LAZY
RTLD_LOCAL
RTLD_NODELETE
RTLD_NOLOAD
RTLD_NOW
\end{minted}

Enum constant for \hyperlink{8171750449393676854}{\texttt{dlopen}}. See your platform man page for details, if applicable.



\end{adjustwidth}
\hypertarget{13057188112538777408}{} 
\hyperlink{13057188112538777408}{\texttt{Libdl.dlsym}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dlsym(handle, sym)
\end{minted}

Look up a symbol from a shared library handle, return callable function pointer on success.



\end{adjustwidth}
\hypertarget{10957545335350379951}{} 
\hyperlink{10957545335350379951}{\texttt{Libdl.dlsym\_e}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dlsym_e(handle, sym)
\end{minted}

Look up a symbol from a shared library handle, silently return \texttt{C\_NULL} on lookup failure. This method is now deprecated in favor of \texttt{dlsym(handle, sym; throw\_error=false)}.



\end{adjustwidth}
\hypertarget{6068064281708498692}{} 
\hyperlink{6068064281708498692}{\texttt{Libdl.dlclose}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dlclose(handle)
\end{minted}

Close shared library referenced by handle.




\begin{lstlisting}
dlclose(::Nothing)
\end{lstlisting}

For the very common pattern usage pattern of


\begin{lstlisting}
try
    hdl = dlopen(library_name)
    ... do something
finally
    dlclose(hdl)
end
\end{lstlisting}

We define a \texttt{dlclose()} method that accepts a parameter of type \texttt{Nothing}, so that user code does not have to change its behavior for the case that \texttt{library\_name} was not found.



\end{adjustwidth}
\hypertarget{8833400024976878033}{} 
\hyperlink{8833400024976878033}{\texttt{Libdl.dlext}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dlext
\end{minted}

File extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.



\end{adjustwidth}
\hypertarget{106077495372504799}{} 
\hyperlink{106077495372504799}{\texttt{Libdl.dllist}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dllist()
\end{minted}

Return the paths of dynamic libraries currently loaded in a \texttt{Vector\{String\}}.



\end{adjustwidth}
\hypertarget{6289250176059967308}{} 
\hyperlink{6289250176059967308}{\texttt{Libdl.dlpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dlpath(handle::Ptr{Cvoid})
\end{minted}

Given a library \texttt{handle} from \texttt{dlopen}, return the full path.




\begin{lstlisting}
dlpath(libname::Union{AbstractString, Symbol})
\end{lstlisting}

Get the full path of the library \texttt{libname}.

\textbf{Example}


\begin{minted}{jlcon}
julia> dlpath("libjulia")
\end{minted}



\end{adjustwidth}
\hypertarget{12933484848758864058}{} 
\hyperlink{12933484848758864058}{\texttt{Libdl.find\_library}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
find_library(names, locations)
\end{minted}

Searches for the first library in \texttt{names} in the paths in the \texttt{locations} list, \texttt{DL\_LOAD\_PATH}, or system library paths (in that order) which can successfully be dlopen{\textquotesingle}d. On success, the return value will be one of the names (potentially prefixed by one of the paths in locations). This string can be assigned to a \texttt{global const} and used as the library name in future \texttt{ccall}{\textquotesingle}s. On failure, it returns the empty string.



\end{adjustwidth}
\hypertarget{617000259211246203}{} 
\hyperlink{617000259211246203}{\texttt{Base.DL\_LOAD\_PATH}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DL_LOAD_PATH
\end{minted}

When calling \hyperlink{8171750449393676854}{\texttt{dlopen}}, the paths in this list will be searched first, in order, before searching the system locations for a valid library handle.



\end{adjustwidth}

\hypertarget{12233296614674559904}{}


\chapter{线性代数}





In addition to (and as part of) its support for multi-dimensional arrays, Julia provides native implementations of many common and useful linear algebra operations which can be loaded with \texttt{using LinearAlgebra}. Basic operations, such as \hyperlink{3355659645971312171}{\texttt{tr}}, \hyperlink{16543378577000914469}{\texttt{det}}, and \hyperlink{13336866048543706848}{\texttt{inv}} are all supported:




\begin{minted}{jlcon}
julia> A = [1 2 3; 4 1 6; 7 8 1]
3×3 Array{Int64,2}:
 1  2  3
 4  1  6
 7  8  1

julia> tr(A)
3

julia> det(A)
104.0

julia> inv(A)
3×3 Array{Float64,2}:
 -0.451923   0.211538    0.0865385
  0.365385  -0.192308    0.0576923
  0.240385   0.0576923  -0.0673077
\end{minted}



还有其它实用的运算，比如寻找特征值或特征向量：




\begin{minted}{jlcon}
julia> A = [-4. -17.; 2. 2.]
2×2 Array{Float64,2}:
 -4.0  -17.0
  2.0    2.0

julia> eigvals(A)
2-element Array{Complex{Float64},1}:
 -1.0 - 5.0im
 -1.0 + 5.0im

julia> eigvecs(A)
2×2 Array{Complex{Float64},2}:
  0.945905-0.0im        0.945905+0.0im
 -0.166924+0.278207im  -0.166924-0.278207im
\end{minted}



此外，Julia 提供了多种\hyperlink{14017178414387426770}{矩阵分解}，它们可用于加快问题的求解，比如线性求解或矩阵或矩阵求幂，这通过将矩阵预先分解成更适合问题的形式（出于性能或内存上的原因）。有关的更多信息，请参阅文档 \hyperlink{7042962205548658937}{\texttt{factorize}}。举个例子：




\begin{minted}{jlcon}
julia> A = [1.5 2 -4; 3 -1 -6; -10 2.3 4]
3×3 Array{Float64,2}:
   1.5   2.0  -4.0
   3.0  -1.0  -6.0
 -10.0   2.3   4.0

julia> factorize(A)
LU{Float64,Array{Float64,2}}
L factor:
3×3 Array{Float64,2}:
  1.0    0.0       0.0
 -0.15   1.0       0.0
 -0.3   -0.132196  1.0
U factor:
3×3 Array{Float64,2}:
 -10.0  2.3     4.0
   0.0  2.345  -3.4
   0.0  0.0    -5.24947
\end{minted}



因为 \texttt{A} 不是埃尔米特、对称、三角、三对角或双对角矩阵，LU 分解也许是我们能做的最好分解。与之相比：




\begin{minted}{jlcon}
julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3×3 Array{Float64,2}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia> factorize(B)
BunchKaufman{Float64,Array{Float64,2}}
D factor:
3×3 Tridiagonal{Float64,Array{Float64,1}}:
 -1.64286   0.0   ⋅
  0.0      -2.8  0.0
   ⋅        0.0  5.0
U factor:
3×3 UnitUpperTriangular{Float64,Array{Float64,2}}:
 1.0  0.142857  -0.8
  ⋅   1.0       -0.6
  ⋅    ⋅         1.0
permutation:
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



在这里，Julia 能够发现 \texttt{B} 确实是对称矩阵，并且使用一种更适当的分解。针对一个具有某些属性的矩阵，比如一个对称或三对角矩阵，往往有可能写出更高效的代码。Julia 提供了一些特殊的类型好让你可以根据矩阵所具有的属性「标记」它们。例如：




\begin{minted}{jlcon}
julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3×3 Array{Float64,2}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia> sB = Symmetric(B)
3×3 Symmetric{Float64,Array{Float64,2}}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0
\end{minted}



\texttt{sB} 已经被标记成（实）对称矩阵，所以对于之后可能在它上面执行的操作，例如特征因子化或矩阵-向量乘积，只引用矩阵的一半可以提高效率。举个例子：




\begin{minted}{jlcon}
julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3×3 Array{Float64,2}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia> sB = Symmetric(B)
3×3 Symmetric{Float64,Array{Float64,2}}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia> x = [1; 2; 3]
3-element Array{Int64,1}:
 1
 2
 3

julia> sB\x
3-element Array{Float64,1}:
 -1.7391304347826084
 -1.1086956521739126
 -1.4565217391304346
\end{minted}



\texttt{{\textbackslash}} 运算在这里执行线性求解。左除运算符相当强大，很容易写出紧凑、可读的代码，它足够灵活，可以求解各种线性方程组。



\hypertarget{16591042520207219529}{}


\section{特殊矩阵}



\href{http://www2.imm.dtu.dk/pubdb/views/publication\_details.php?id=3274}{具有特殊对称性和结构的矩阵}经常在线性代数中出现并且与各种矩阵分解相关。Julia 具有丰富的特殊矩阵类型，可以快速计算专门为特定矩阵类型开发的专用例程。



下表总结了在 Julia 中已经实现的特殊矩阵类型，以及为它们提供各种优化方法的钩子在 LAPACK 中是否可用。




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
类型 & 描述 \\
\hline
\hyperlink{17683454167504168761}{\texttt{Symmetric}} & \href{https://en.wikipedia.org/wiki/Symmetric\_matrix}{对称矩阵} \\
\hline
\hyperlink{938713992181310063}{\texttt{Hermitian}} & \href{https://en.wikipedia.org/wiki/Hermitian\_matrix}{埃尔米特矩阵} \\
\hline
\hyperlink{6344726545165008167}{\texttt{UpperTriangular}} & 上\href{https://en.wikipedia.org/wiki/Triangular\_matrix}{三角矩阵} \\
\hline
\hyperlink{17221720404477798393}{\texttt{UnitUpperTriangular}} & Upper \href{https://en.wikipedia.org/wiki/Triangular\_matrix}{triangular matrix} with unit diagonal \\
\hline
\hyperlink{15116078732779234709}{\texttt{LowerTriangular}} & Lower \href{https://en.wikipedia.org/wiki/Triangular\_matrix}{triangular matrix} \\
\hline
\hyperlink{2163321084999097240}{\texttt{UnitLowerTriangular}} & Lower \href{https://en.wikipedia.org/wiki/Triangular\_matrix}{triangular matrix} with unit diagonal \\
\hline
\hyperlink{6167777885202579792}{\texttt{UpperHessenberg}} & Upper \href{https://en.wikipedia.org/wiki/Hessenberg\_matrix}{Hessenberg matrix} \\
\hline
\hyperlink{17820886359515748171}{\texttt{Tridiagonal}} & \href{https://en.wikipedia.org/wiki/Tridiagonal\_matrix}{Tridiagonal matrix} \\
\hline
\hyperlink{6062797780727203318}{\texttt{SymTridiagonal}} & Symmetric tridiagonal matrix \\
\hline
\hyperlink{6156150905679680892}{\texttt{Bidiagonal}} & Upper/lower \href{https://en.wikipedia.org/wiki/Bidiagonal\_matrix}{bidiagonal matrix} \\
\hline
\hyperlink{3300114559258360989}{\texttt{Diagonal}} & \href{https://en.wikipedia.org/wiki/Diagonal\_matrix}{Diagonal matrix} \\
\hline
\hyperlink{723087258311673942}{\texttt{UniformScaling}} & \href{https://en.wikipedia.org/wiki/Uniform\_scaling}{Uniform scaling operator} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{17944625623829928397}{}


\subsection{Elementary operations}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|}
\hline
Matrix type & \texttt{+} & \texttt{-} & \texttt{*} & \texttt{{\textbackslash}} & Other functions with optimized methods \\
\hline
\hyperlink{17683454167504168761}{\texttt{Symmetric}} &  &  &  & MV & \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{4551113327515323898}{\texttt{sqrt}}, \hyperlink{5801729597955756107}{\texttt{exp}} \\
\hline
\hyperlink{938713992181310063}{\texttt{Hermitian}} &  &  &  & MV & \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{4551113327515323898}{\texttt{sqrt}}, \hyperlink{5801729597955756107}{\texttt{exp}} \\
\hline
\hyperlink{6344726545165008167}{\texttt{UpperTriangular}} &  &  & MV & MV & \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{16543378577000914469}{\texttt{det}} \\
\hline
\hyperlink{17221720404477798393}{\texttt{UnitUpperTriangular}} &  &  & MV & MV & \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{16543378577000914469}{\texttt{det}} \\
\hline
\hyperlink{15116078732779234709}{\texttt{LowerTriangular}} &  &  & MV & MV & \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{16543378577000914469}{\texttt{det}} \\
\hline
\hyperlink{2163321084999097240}{\texttt{UnitLowerTriangular}} &  &  & MV & MV & \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{16543378577000914469}{\texttt{det}} \\
\hline
\hyperlink{6167777885202579792}{\texttt{UpperHessenberg}} &  &  &  & MM & \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{16543378577000914469}{\texttt{det}} \\
\hline
\hyperlink{6062797780727203318}{\texttt{SymTridiagonal}} & M & M & MS & MV & \hyperlink{1568196261511691624}{\texttt{eigmax}}, \hyperlink{658135215942727363}{\texttt{eigmin}} \\
\hline
\hyperlink{17820886359515748171}{\texttt{Tridiagonal}} & M & M & MS & MV &  \\
\hline
\hyperlink{6156150905679680892}{\texttt{Bidiagonal}} & M & M & MS & MV &  \\
\hline
\hyperlink{3300114559258360989}{\texttt{Diagonal}} & M & M & MV & MV & \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{16543378577000914469}{\texttt{det}}, \hyperlink{12765142073947245963}{\texttt{logdet}}, \hyperlink{4103478871488785445}{\texttt{/}} \\
\hline
\hyperlink{723087258311673942}{\texttt{UniformScaling}} & M & M & MVS & MVS & \hyperlink{4103478871488785445}{\texttt{/}} \\
\hline
\end{tabulary}

\end{table}



Legend:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Key & Description \\
\hline
M (matrix) & An optimized method for matrix-matrix operations is available \\
\hline
V (vector) & An optimized method for matrix-vector operations is available \\
\hline
S (scalar) & An optimized method for matrix-scalar operations is available \\
\hline
\end{tabulary}

\end{table}



\hypertarget{9743537278285582026}{}


\subsection{Matrix factorizations}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|L|}
\hline
Matrix type & LAPACK & \hyperlink{11056016707394839114}{\texttt{eigen}} & \hyperlink{12334018763942871611}{\texttt{eigvals}} & \hyperlink{8591842276375230542}{\texttt{eigvecs}} & \hyperlink{6661056220970412040}{\texttt{svd}} & \hyperlink{12905968661134086149}{\texttt{svdvals}} \\
\hline
\hyperlink{17683454167504168761}{\texttt{Symmetric}} & SY &  & ARI &  &  &  \\
\hline
\hyperlink{938713992181310063}{\texttt{Hermitian}} & HE &  & ARI &  &  &  \\
\hline
\hyperlink{6344726545165008167}{\texttt{UpperTriangular}} & TR & A & A & A &  &  \\
\hline
\hyperlink{17221720404477798393}{\texttt{UnitUpperTriangular}} & TR & A & A & A &  &  \\
\hline
\hyperlink{15116078732779234709}{\texttt{LowerTriangular}} & TR & A & A & A &  &  \\
\hline
\hyperlink{2163321084999097240}{\texttt{UnitLowerTriangular}} & TR & A & A & A &  &  \\
\hline
\hyperlink{6062797780727203318}{\texttt{SymTridiagonal}} & ST & A & ARI & AV &  &  \\
\hline
\hyperlink{17820886359515748171}{\texttt{Tridiagonal}} & GT &  &  &  &  &  \\
\hline
\hyperlink{6156150905679680892}{\texttt{Bidiagonal}} & BD &  &  &  & A & A \\
\hline
\hyperlink{3300114559258360989}{\texttt{Diagonal}} & DI &  & A &  &  &  \\
\hline
\end{tabulary}

\end{table}



Legend:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Key & Description & Example \\
\hline
A (all) & An optimized method to find all the characteristic values and/or vectors is available & e.g. \texttt{eigvals(M)} \\
\hline
R (range) & An optimized method to find the \texttt{il}th through the \texttt{ih}th characteristic values are available & \texttt{eigvals(M, il, ih)} \\
\hline
I (interval) & An optimized method to find the characteristic values in the interval [\texttt{vl}, \texttt{vh}] is available & \texttt{eigvals(M, vl, vh)} \\
\hline
V (vectors) & An optimized method to find the characteristic vectors corresponding to the characteristic values \texttt{x=[x1, x2,...]} is available & \texttt{eigvecs(M, x)} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{8735142158345502219}{}


\subsection{The uniform scaling operator}



A \hyperlink{723087258311673942}{\texttt{UniformScaling}} operator represents a scalar times the identity operator, \texttt{λ*I}. The identity operator \texttt{I} is defined as a constant and is an instance of \texttt{UniformScaling}. The size of these operators are generic and match the other matrix in the binary operations \hyperlink{3677358729494553841}{\texttt{+}}, \hyperlink{8228207173393714756}{\texttt{-}}, \hyperlink{7592762607639177347}{\texttt{*}} and \hyperlink{4639577998029770435}{\texttt{{\textbackslash}}}. For \texttt{A+I} and \texttt{A-I} this means that \texttt{A} must be square. Multiplication with the identity operator \texttt{I} is a noop (except for checking that the scaling factor is one) and therefore almost without overhead.



To see the \texttt{UniformScaling} operator in action:




\begin{minted}{jlcon}
julia> U = UniformScaling(2);

julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> a + U
2×2 Array{Int64,2}:
 3  2
 3  6

julia> a * U
2×2 Array{Int64,2}:
 2  4
 6  8

julia> [a U]
2×4 Array{Int64,2}:
 1  2  2  0
 3  4  0  2

julia> b = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia> b - U
ERROR: DimensionMismatch("matrix is not square: dimensions are (2, 3)")
Stacktrace:
[...]
\end{minted}



If you need to solve many systems of the form \texttt{(A+μI)x = b} for the same \texttt{A} and different \texttt{μ}, it might be beneficial to first compute the Hessenberg factorization \texttt{F} of \texttt{A} via the \hyperlink{14451165250498024497}{\texttt{hessenberg}} function. Given \texttt{F}, Julia employs an efficient algorithm for \texttt{(F+μ*I) {\textbackslash} b} (equivalent to \texttt{(A+μ*I)x {\textbackslash} b}) and related operations like determinants.



\hypertarget{12615392115882150758}{}


\section{Matrix factorizations}



\href{https://en.wikipedia.org/wiki/Matrix\_decomposition}{Matrix factorizations (a.k.a. matrix decompositions)} compute the factorization of a matrix into a product of matrices, and are one of the central concepts in linear algebra.



The following table summarizes the types of matrix factorizations that have been implemented in Julia. Details of their associated methods can be found in the \hyperlink{14873423929127000343}{Standard functions} section of the Linear Algebra documentation.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Type & Description \\
\hline
\texttt{BunchKaufman} & Bunch-Kaufman factorization \\
\hline
\texttt{Cholesky} & \href{https://en.wikipedia.org/wiki/Cholesky\_decomposition}{Cholesky factorization} \\
\hline
\texttt{CholeskyPivoted} & \href{https://en.wikipedia.org/wiki/Pivot\_element}{Pivoted} Cholesky factorization \\
\hline
\texttt{LDLt} & \href{https://en.wikipedia.org/wiki/Cholesky\_decomposition\#LDL\_decomposition}{LDL(T) factorization} \\
\hline
\texttt{LU} & \href{https://en.wikipedia.org/wiki/LU\_decomposition}{LU factorization} \\
\hline
\texttt{QR} & \href{https://en.wikipedia.org/wiki/QR\_decomposition}{QR factorization} \\
\hline
\texttt{QRCompactWY} & Compact WY form of the QR factorization \\
\hline
\texttt{QRPivoted} & Pivoted \href{https://en.wikipedia.org/wiki/QR\_decomposition}{QR factorization} \\
\hline
\texttt{LQ} & \href{https://en.wikipedia.org/wiki/QR\_decomposition}{QR factorization} of \texttt{transpose(A)} \\
\hline
\texttt{Hessenberg} & \href{http://mathworld.wolfram.com/HessenbergDecomposition.html}{Hessenberg decomposition} \\
\hline
\texttt{Eigen} & \href{https://en.wikipedia.org/wiki/Eigendecomposition\_of\_a\_matrix}{Spectral decomposition} \\
\hline
\texttt{GeneralizedEigen} & \href{https://en.wikipedia.org/wiki/Eigendecomposition\_of\_a\_matrix\#Generalized\_eigenvalue\_problem}{Generalized spectral decomposition} \\
\hline
\texttt{SVD} & \href{https://en.wikipedia.org/wiki/Singular\_value\_decomposition}{Singular value decomposition} \\
\hline
\texttt{GeneralizedSVD} & \href{https://en.wikipedia.org/wiki/Generalized\_singular\_value\_decomposition\#Higher\_order\_version}{Generalized SVD} \\
\hline
\texttt{Schur} & \href{https://en.wikipedia.org/wiki/Schur\_decomposition}{Schur decomposition} \\
\hline
\texttt{GeneralizedSchur} & \href{https://en.wikipedia.org/wiki/Schur\_decomposition\#Generalized\_Schur\_decomposition}{Generalized Schur decomposition} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{10454442684761744234}{}


\section{Standard functions}



Linear algebra functions in Julia are largely implemented by calling functions from \href{http://www.netlib.org/lapack/}{LAPACK}.  Sparse factorizations call functions from \href{http://faculty.cse.tamu.edu/davis/suitesparse.html}{SuiteSparse}.


\hypertarget{9051502204834048921}{} 
\hyperlink{9051502204834048921}{\texttt{Base.:*}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
*(A::AbstractMatrix, B::AbstractMatrix)
\end{minted}

Matrix multiplication.

\textbf{Examples}


\begin{minted}{jlcon}
julia> [1 1; 0 1] * [1 0; 1 1]
2×2 Array{Int64,2}:
 2  1
 1  1
\end{minted}



\end{adjustwidth}
\hypertarget{9779560736429840808}{} 
\hyperlink{9779560736429840808}{\texttt{Base.:{\textbackslash}}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
\(A, B)
\end{minted}

Matrix division using a polyalgorithm. For input matrices \texttt{A} and \texttt{B}, the result \texttt{X} is such that \texttt{A*X == B} when \texttt{A} is square. The solver that is used depends upon the structure of \texttt{A}.  If \texttt{A} is upper or lower triangular (or diagonal), no factorization of \texttt{A} is required and the system is solved with either forward or backward substitution. For non-triangular square matrices, an LU factorization is used.

For rectangular \texttt{A} the result is the minimum-norm least squares solution computed by a pivoted QR factorization of \texttt{A} and a rank estimate of \texttt{A} based on the R factor.

When \texttt{A} is sparse, a similar polyalgorithm is used. For indefinite matrices, the \texttt{LDLt} factorization does not use pivoting during the numerical factorization and therefore the procedure can fail even for invertible matrices.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 0; 1 -2]; B = [32; -4];

julia> X = A \ B
2-element Array{Float64,1}:
 32.0
 18.0

julia> A * X == B
true
\end{minted}



\end{adjustwidth}
\hypertarget{3093579424646561023}{} 
\hyperlink{3093579424646561023}{\texttt{LinearAlgebra.SingularException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SingularException
\end{minted}

Exception thrown when the input matrix has one or more zero-valued eigenvalues, and is not invertible. A linear solve involving such a matrix cannot be computed. The \texttt{info} field indicates the location of (one of) the singular value(s).



\end{adjustwidth}
\hypertarget{12039872206324733514}{} 
\hyperlink{12039872206324733514}{\texttt{LinearAlgebra.PosDefException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
PosDefException
\end{minted}

Exception thrown when the input matrix was not \href{https://en.wikipedia.org/wiki/Definiteness\_of\_a\_matrix}{positive definite}. Some linear algebra functions and factorizations are only applicable to positive definite matrices. The \texttt{info} field indicates the location of (one of) the eigenvalue(s) which is (are) less than/equal to 0.



\end{adjustwidth}
\hypertarget{5527602249593606173}{} 
\hyperlink{5527602249593606173}{\texttt{LinearAlgebra.ZeroPivotException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ZeroPivotException <: Exception
\end{minted}

Exception thrown when a matrix factorization/solve encounters a zero in a pivot (diagonal) position and cannot proceed.  This may \emph{not} mean that the matrix is singular: it may be fruitful to switch to a diffent factorization such as pivoted LU that can re-order variables to eliminate spurious zero pivots. The \texttt{info} field indicates the location of (one of) the zero pivot(s).



\end{adjustwidth}
\hypertarget{15449777733236645501}{} 
\hyperlink{15449777733236645501}{\texttt{LinearAlgebra.dot}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dot(x, y)
x ⋅ y
\end{minted}

Compute the dot product between two vectors. For complex vectors, the first vector is conjugated.

\texttt{dot} also works on arbitrary iterable objects, including arrays of any dimension, as long as \texttt{dot} is defined on the elements.

\texttt{dot} is semantically equivalent to \texttt{sum(dot(vx,vy) for (vx,vy) in zip(x, y))}, with the added restriction that the arguments must have equal lengths.

\texttt{x ⋅ y} (where \texttt{⋅} can be typed by tab-completing \texttt{{\textbackslash}cdot} in the REPL) is a synonym for \texttt{dot(x, y)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> dot([1; 1], [2; 3])
5

julia> dot([im; im], [1; 1])
0 - 2im

julia> dot(1:5, 2:6)
70

julia> x = fill(2., (5,5));

julia> y = fill(3., (5,5));

julia> dot(x, y)
150.0
\end{minted}



\end{adjustwidth}
\hypertarget{7470245664307242183}{} 
\hyperlink{7470245664307242183}{\texttt{LinearAlgebra.cross}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cross(x, y)
×(x,y)
\end{minted}

Compute the cross product of two 3-vectors.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [0;1;0]
3-element Array{Int64,1}:
 0
 1
 0

julia> b = [0;0;1]
3-element Array{Int64,1}:
 0
 0
 1

julia> cross(a,b)
3-element Array{Int64,1}:
 1
 0
 0
\end{minted}



\end{adjustwidth}
\hypertarget{7042962205548658937}{} 
\hyperlink{7042962205548658937}{\texttt{LinearAlgebra.factorize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
factorize(A)
\end{minted}

Compute a convenient factorization of \texttt{A}, based upon the type of the input matrix. \texttt{factorize} checks \texttt{A} to see if it is symmetric/triangular/etc. if \texttt{A} is passed as a generic matrix. \texttt{factorize} checks every element of \texttt{A} to verify/rule out each property. It will short-circuit as soon as it can rule out symmetry/triangular structure. The return value can be reused for efficient solving of multiple systems. For example: \texttt{A=factorize(A); x=A{\textbackslash}b; y=A{\textbackslash}C}.


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Properties of \texttt{A} & type of factorization \\
\hline
Positive-definite & Cholesky (see \hyperlink{7653413936706994771}{\texttt{cholesky}}) \\
\hline
Dense Symmetric/Hermitian & Bunch-Kaufman (see \hyperlink{17253210517333433448}{\texttt{bunchkaufman}}) \\
\hline
Sparse Symmetric/Hermitian & LDLt (see \hyperlink{8934377864822491393}{\texttt{ldlt}}) \\
\hline
Triangular & Triangular \\
\hline
Diagonal & Diagonal \\
\hline
Bidiagonal & Bidiagonal \\
\hline
Tridiagonal & LU (see \hyperlink{5672569096214810830}{\texttt{lu}}) \\
\hline
Symmetric real tridiagonal & LDLt (see \hyperlink{8934377864822491393}{\texttt{ldlt}}) \\
\hline
General square & LU (see \hyperlink{5672569096214810830}{\texttt{lu}}) \\
\hline
General non-square & QR (see \hyperlink{4122539696772350360}{\texttt{qr}}) \\
\hline
\end{tabulary}

\end{table}

If \texttt{factorize} is called on a Hermitian positive-definite matrix, for instance, then \texttt{factorize} will return a Cholesky factorization.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = Array(Bidiagonal(fill(1.0, (5, 5)), :U))
5×5 Array{Float64,2}:
 1.0  1.0  0.0  0.0  0.0
 0.0  1.0  1.0  0.0  0.0
 0.0  0.0  1.0  1.0  0.0
 0.0  0.0  0.0  1.0  1.0
 0.0  0.0  0.0  0.0  1.0

julia> factorize(A) # factorize will check to see that A is already factorized
5×5 Bidiagonal{Float64,Array{Float64,1}}:
 1.0  1.0   ⋅    ⋅    ⋅
  ⋅   1.0  1.0   ⋅    ⋅
  ⋅    ⋅   1.0  1.0   ⋅
  ⋅    ⋅    ⋅   1.0  1.0
  ⋅    ⋅    ⋅    ⋅   1.0
\end{minted}

This returns a \texttt{5×5 Bidiagonal\{Float64\}}, which can now be passed to other linear algebra functions (e.g. eigensolvers) which will use specialized methods for \texttt{Bidiagonal} types.



\end{adjustwidth}
\hypertarget{3300114559258360989}{} 
\hyperlink{3300114559258360989}{\texttt{LinearAlgebra.Diagonal}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Diagonal(A::AbstractMatrix)
\end{minted}

Construct a matrix from the diagonal of \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia> Diagonal(A)
3×3 Diagonal{Int64,Array{Int64,1}}:
 1  ⋅  ⋅
 ⋅  5  ⋅
 ⋅  ⋅  9
\end{minted}




\begin{lstlisting}
Diagonal(V::AbstractVector)
\end{lstlisting}

Construct a matrix with \texttt{V} as its diagonal.

\textbf{Examples}


\begin{minted}{jlcon}
julia> V = [1, 2]
2-element Array{Int64,1}:
 1
 2

julia> Diagonal(V)
2×2 Diagonal{Int64,Array{Int64,1}}:
 1  ⋅
 ⋅  2
\end{minted}



\end{adjustwidth}
\hypertarget{6156150905679680892}{} 
\hyperlink{6156150905679680892}{\texttt{LinearAlgebra.Bidiagonal}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Bidiagonal(dv::V, ev::V, uplo::Symbol) where V <: AbstractVector
\end{minted}

Constructs an upper (\texttt{uplo=:U}) or lower (\texttt{uplo=:L}) bidiagonal matrix using the given diagonal (\texttt{dv}) and off-diagonal (\texttt{ev}) vectors. The result is of type \texttt{Bidiagonal} and provides efficient specialized linear solvers, but may be converted into a regular matrix with \hyperlink{1846942650946171605}{\texttt{convert(Array, \_)}} (or \texttt{Array(\_)} for short). The length of \texttt{ev} must be one less than the length of \texttt{dv}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> dv = [1, 2, 3, 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> ev = [7, 8, 9]
3-element Array{Int64,1}:
 7
 8
 9

julia> Bu = Bidiagonal(dv, ev, :U) # ev is on the first superdiagonal
4×4 Bidiagonal{Int64,Array{Int64,1}}:
 1  7  ⋅  ⋅
 ⋅  2  8  ⋅
 ⋅  ⋅  3  9
 ⋅  ⋅  ⋅  4

julia> Bl = Bidiagonal(dv, ev, :L) # ev is on the first subdiagonal
4×4 Bidiagonal{Int64,Array{Int64,1}}:
 1  ⋅  ⋅  ⋅
 7  2  ⋅  ⋅
 ⋅  8  3  ⋅
 ⋅  ⋅  9  4
\end{minted}




\begin{lstlisting}
Bidiagonal(A, uplo::Symbol)
\end{lstlisting}

Construct a \texttt{Bidiagonal} matrix from the main diagonal of \texttt{A} and its first super- (if \texttt{uplo=:U}) or sub-diagonal (if \texttt{uplo=:L}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 1 1 1; 2 2 2 2; 3 3 3 3; 4 4 4 4]
4×4 Array{Int64,2}:
 1  1  1  1
 2  2  2  2
 3  3  3  3
 4  4  4  4

julia> Bidiagonal(A, :U) # contains the main diagonal and first superdiagonal of A
4×4 Bidiagonal{Int64,Array{Int64,1}}:
 1  1  ⋅  ⋅
 ⋅  2  2  ⋅
 ⋅  ⋅  3  3
 ⋅  ⋅  ⋅  4

julia> Bidiagonal(A, :L) # contains the main diagonal and first subdiagonal of A
4×4 Bidiagonal{Int64,Array{Int64,1}}:
 1  ⋅  ⋅  ⋅
 2  2  ⋅  ⋅
 ⋅  3  3  ⋅
 ⋅  ⋅  4  4
\end{minted}



\end{adjustwidth}
\hypertarget{6062797780727203318}{} 
\hyperlink{6062797780727203318}{\texttt{LinearAlgebra.SymTridiagonal}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SymTridiagonal(dv::V, ev::V) where V <: AbstractVector
\end{minted}

Construct a symmetric tridiagonal matrix from the diagonal (\texttt{dv}) and first sub/super-diagonal (\texttt{ev}), respectively. The result is of type \texttt{SymTridiagonal} and provides efficient specialized eigensolvers, but may be converted into a regular matrix with \hyperlink{1846942650946171605}{\texttt{convert(Array, \_)}} (or \texttt{Array(\_)} for short).

\textbf{Examples}


\begin{minted}{jlcon}
julia> dv = [1, 2, 3, 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> ev = [7, 8, 9]
3-element Array{Int64,1}:
 7
 8
 9

julia> SymTridiagonal(dv, ev)
4×4 SymTridiagonal{Int64,Array{Int64,1}}:
 1  7  ⋅  ⋅
 7  2  8  ⋅
 ⋅  8  3  9
 ⋅  ⋅  9  4
\end{minted}




\begin{lstlisting}
SymTridiagonal(A::AbstractMatrix)
\end{lstlisting}

Construct a symmetric tridiagonal matrix from the diagonal and first sub/super-diagonal, of the symmetric matrix \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2 3; 2 4 5; 3 5 6]
3×3 Array{Int64,2}:
 1  2  3
 2  4  5
 3  5  6

julia> SymTridiagonal(A)
3×3 SymTridiagonal{Int64,Array{Int64,1}}:
 1  2  ⋅
 2  4  5
 ⋅  5  6
\end{minted}



\end{adjustwidth}
\hypertarget{17820886359515748171}{} 
\hyperlink{17820886359515748171}{\texttt{LinearAlgebra.Tridiagonal}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Tridiagonal(dl::V, d::V, du::V) where V <: AbstractVector
\end{minted}

Construct a tridiagonal matrix from the first subdiagonal, diagonal, and first superdiagonal, respectively. The result is of type \texttt{Tridiagonal} and provides efficient specialized linear solvers, but may be converted into a regular matrix with \hyperlink{1846942650946171605}{\texttt{convert(Array, \_)}} (or \texttt{Array(\_)} for short). The lengths of \texttt{dl} and \texttt{du} must be one less than the length of \texttt{d}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> dl = [1, 2, 3];

julia> du = [4, 5, 6];

julia> d = [7, 8, 9, 0];

julia> Tridiagonal(dl, d, du)
4×4 Tridiagonal{Int64,Array{Int64,1}}:
 7  4  ⋅  ⋅
 1  8  5  ⋅
 ⋅  2  9  6
 ⋅  ⋅  3  0
\end{minted}




\begin{lstlisting}
Tridiagonal(A)
\end{lstlisting}

Construct a tridiagonal matrix from the first sub-diagonal, diagonal and first super-diagonal of the matrix \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2 3 4; 1 2 3 4; 1 2 3 4; 1 2 3 4]
4×4 Array{Int64,2}:
 1  2  3  4
 1  2  3  4
 1  2  3  4
 1  2  3  4

julia> Tridiagonal(A)
4×4 Tridiagonal{Int64,Array{Int64,1}}:
 1  2  ⋅  ⋅
 1  2  3  ⋅
 ⋅  2  3  4
 ⋅  ⋅  3  4
\end{minted}



\end{adjustwidth}
\hypertarget{17683454167504168761}{} 
\hyperlink{17683454167504168761}{\texttt{LinearAlgebra.Symmetric}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Symmetric(A, uplo=:U)
\end{minted}

Construct a \texttt{Symmetric} view of the upper (if \texttt{uplo = :U}) or lower (if \texttt{uplo = :L}) triangle of the matrix \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 0 2 0 3; 0 4 0 5 0; 6 0 7 0 8; 0 9 0 1 0; 2 0 3 0 4]
5×5 Array{Int64,2}:
 1  0  2  0  3
 0  4  0  5  0
 6  0  7  0  8
 0  9  0  1  0
 2  0  3  0  4

julia> Supper = Symmetric(A)
5×5 Symmetric{Int64,Array{Int64,2}}:
 1  0  2  0  3
 0  4  0  5  0
 2  0  7  0  8
 0  5  0  1  0
 3  0  8  0  4

julia> Slower = Symmetric(A, :L)
5×5 Symmetric{Int64,Array{Int64,2}}:
 1  0  6  0  2
 0  4  0  9  0
 6  0  7  0  3
 0  9  0  1  0
 2  0  3  0  4
\end{minted}

Note that \texttt{Supper} will not be equal to \texttt{Slower} unless \texttt{A} is itself symmetric (e.g. if \texttt{A == transpose(A)}).



\end{adjustwidth}
\hypertarget{938713992181310063}{} 
\hyperlink{938713992181310063}{\texttt{LinearAlgebra.Hermitian}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Hermitian(A, uplo=:U)
\end{minted}

Construct a \texttt{Hermitian} view of the upper (if \texttt{uplo = :U}) or lower (if \texttt{uplo = :L}) triangle of the matrix \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 0 2+2im 0 3-3im; 0 4 0 5 0; 6-6im 0 7 0 8+8im; 0 9 0 1 0; 2+2im 0 3-3im 0 4];

julia> Hupper = Hermitian(A)
5×5 Hermitian{Complex{Int64},Array{Complex{Int64},2}}:
 1+0im  0+0im  2+2im  0+0im  3-3im
 0+0im  4+0im  0+0im  5+0im  0+0im
 2-2im  0+0im  7+0im  0+0im  8+8im
 0+0im  5+0im  0+0im  1+0im  0+0im
 3+3im  0+0im  8-8im  0+0im  4+0im

julia> Hlower = Hermitian(A, :L)
5×5 Hermitian{Complex{Int64},Array{Complex{Int64},2}}:
 1+0im  0+0im  6+6im  0+0im  2-2im
 0+0im  4+0im  0+0im  9+0im  0+0im
 6-6im  0+0im  7+0im  0+0im  3+3im
 0+0im  9+0im  0+0im  1+0im  0+0im
 2+2im  0+0im  3-3im  0+0im  4+0im
\end{minted}

Note that \texttt{Hupper} will not be equal to \texttt{Hlower} unless \texttt{A} is itself Hermitian (e.g. if \texttt{A == adjoint(A)}).

All non-real parts of the diagonal will be ignored.


\begin{minted}{julia}
Hermitian(fill(complex(1,1), 1, 1)) == fill(1, 1, 1)
\end{minted}



\end{adjustwidth}
\hypertarget{15116078732779234709}{} 
\hyperlink{15116078732779234709}{\texttt{LinearAlgebra.LowerTriangular}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LowerTriangular(A::AbstractMatrix)
\end{minted}

Construct a \texttt{LowerTriangular} view of the matrix \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia> LowerTriangular(A)
3×3 LowerTriangular{Float64,Array{Float64,2}}:
 1.0   ⋅    ⋅
 4.0  5.0   ⋅
 7.0  8.0  9.0
\end{minted}



\end{adjustwidth}
\hypertarget{6344726545165008167}{} 
\hyperlink{6344726545165008167}{\texttt{LinearAlgebra.UpperTriangular}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UpperTriangular(A::AbstractMatrix)
\end{minted}

Construct an \texttt{UpperTriangular} view of the matrix \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia> UpperTriangular(A)
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 1.0  2.0  3.0
  ⋅   5.0  6.0
  ⋅    ⋅   9.0
\end{minted}



\end{adjustwidth}
\hypertarget{2163321084999097240}{} 
\hyperlink{2163321084999097240}{\texttt{LinearAlgebra.UnitLowerTriangular}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UnitLowerTriangular(A::AbstractMatrix)
\end{minted}

Construct a \texttt{UnitLowerTriangular} view of the matrix \texttt{A}. Such a view has the \hyperlink{2310843180104103470}{\texttt{oneunit}} of the \hyperlink{6396209842929672718}{\texttt{eltype}} of \texttt{A} on its diagonal.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia> UnitLowerTriangular(A)
3×3 UnitLowerTriangular{Float64,Array{Float64,2}}:
 1.0   ⋅    ⋅
 4.0  1.0   ⋅
 7.0  8.0  1.0
\end{minted}



\end{adjustwidth}
\hypertarget{17221720404477798393}{} 
\hyperlink{17221720404477798393}{\texttt{LinearAlgebra.UnitUpperTriangular}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UnitUpperTriangular(A::AbstractMatrix)
\end{minted}

Construct an \texttt{UnitUpperTriangular} view of the matrix \texttt{A}. Such a view has the \hyperlink{2310843180104103470}{\texttt{oneunit}} of the \hyperlink{6396209842929672718}{\texttt{eltype}} of \texttt{A} on its diagonal.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia> UnitUpperTriangular(A)
3×3 UnitUpperTriangular{Float64,Array{Float64,2}}:
 1.0  2.0  3.0
  ⋅   1.0  6.0
  ⋅    ⋅   1.0
\end{minted}



\end{adjustwidth}
\hypertarget{6167777885202579792}{} 
\hyperlink{6167777885202579792}{\texttt{LinearAlgebra.UpperHessenberg}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UpperHessenberg(A::AbstractMatrix)
\end{minted}

Construct an \texttt{UpperHessenberg} view of the matrix \texttt{A}. Entries of \texttt{A} below the first subdiagonal are ignored.

Efficient algorithms are implemented for \texttt{H {\textbackslash} b}, \texttt{det(H)}, and similar.

See also the \hyperlink{14451165250498024497}{\texttt{hessenberg}} function to factor any matrix into a similar upper-Hessenberg matrix.

If \texttt{F::Hessenberg} is the factorization object, the unitary matrix can be accessed with \texttt{F.Q} and the Hessenberg matrix with \texttt{F.H}. When \texttt{Q} is extracted, the resulting type is the \texttt{HessenbergQ} object, and may be converted to a regular matrix with \hyperlink{1846942650946171605}{\texttt{convert(Array, \_)}} (or \texttt{Array(\_)} for short).

Iterating the decomposition produces the factors \texttt{F.Q} and \texttt{F.H}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2 3 4; 5 6 7 8; 9 10 11 12; 13 14 15 16]
4×4 Array{Int64,2}:
  1   2   3   4
  5   6   7   8
  9  10  11  12
 13  14  15  16

julia> UpperHessenberg(A)
4×4 UpperHessenberg{Int64,Array{Int64,2}}:
 1   2   3   4
 5   6   7   8
 ⋅  10  11  12
 ⋅   ⋅  15  16
\end{minted}



\end{adjustwidth}
\hypertarget{723087258311673942}{} 
\hyperlink{723087258311673942}{\texttt{LinearAlgebra.UniformScaling}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UniformScaling{T<:Number}
\end{minted}

Generically sized uniform scaling operator defined as a scalar times the identity operator, \texttt{λ*I}. See also \hyperlink{15346645596018210602}{\texttt{I}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> J = UniformScaling(2.)
UniformScaling{Float64}
2.0*I

julia> A = [1. 2.; 3. 4.]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia> J*A
2×2 Array{Float64,2}:
 2.0  4.0
 6.0  8.0
\end{minted}



\end{adjustwidth}
\hypertarget{15346645596018210602}{} 
\hyperlink{15346645596018210602}{\texttt{LinearAlgebra.I}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
I
\end{minted}

An object of type \hyperlink{723087258311673942}{\texttt{UniformScaling}}, representing an identity matrix of any size.

\textbf{Examples}


\begin{minted}{jlcon}
julia> fill(1, (5,6)) * I == fill(1, (5,6))
true

julia> [1 2im 3; 1im 2 3] * I
2×3 Array{Complex{Int64},2}:
 1+0im  0+2im  3+0im
 0+1im  2+0im  3+0im
\end{minted}



\end{adjustwidth}
\hypertarget{3230130194560201438}{} 
\hyperlink{3230130194560201438}{\texttt{LinearAlgebra.Factorization}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LinearAlgebra.Factorization
\end{minted}

Abstract type for \href{https://en.wikipedia.org/wiki/Matrix\_decomposition}{matrix factorizations} a.k.a. matrix decompositions. See \hyperlink{14017178414387426770}{online documentation} for a list of available matrix factorizations.



\end{adjustwidth}
\hypertarget{9094854913402033490}{} 
\hyperlink{9094854913402033490}{\texttt{LinearAlgebra.LU}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LU <: Factorization
\end{minted}

Matrix factorization type of the \texttt{LU} factorization of a square matrix \texttt{A}. This is the return type of \hyperlink{5672569096214810830}{\texttt{lu}}, the corresponding matrix factorization function.

The individual components of the factorization \texttt{F::LU} can be accessed via \texttt{getproperty}:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Component & Description \\
\hline
\texttt{F.L} & \texttt{L} (unit lower triangular) part of \texttt{LU} \\
\hline
\texttt{F.U} & \texttt{U} (upper triangular) part of \texttt{LU} \\
\hline
\texttt{F.p} & (right) permutation \texttt{Vector} \\
\hline
\texttt{F.P} & (right) permutation \texttt{Matrix} \\
\hline
\end{tabulary}

\end{table}

Iterating the factorization produces the components \texttt{F.L}, \texttt{F.U}, and \texttt{F.p}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4 3; 6 3]
2×2 Array{Int64,2}:
 4  3
 6  3

julia> F = lu(A)
LU{Float64,Array{Float64,2}}
L factor:
2×2 Array{Float64,2}:
 1.0       0.0
 0.666667  1.0
U factor:
2×2 Array{Float64,2}:
 6.0  3.0
 0.0  1.0

julia> F.L * F.U == A[F.p, :]
true

julia> l, u, p = lu(A); # destructuring via iteration

julia> l == F.L && u == F.U && p == F.p
true
\end{minted}



\end{adjustwidth}
\hypertarget{5672569096214810830}{} 
\hyperlink{5672569096214810830}{\texttt{LinearAlgebra.lu}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lu(A, pivot=Val(true); check = true) -> F::LU
\end{minted}

Compute the LU factorization of \texttt{A}.

When \texttt{check = true}, an error is thrown if the decomposition fails. When \texttt{check = false}, responsibility for checking the decomposition{\textquotesingle}s validity (via \hyperlink{10694198281534172656}{\texttt{issuccess}}) lies with the user.

In most cases, if \texttt{A} is a subtype \texttt{S} of \texttt{AbstractMatrix\{T\}} with an element type \texttt{T} supporting \texttt{+}, \texttt{-}, \texttt{*} and \texttt{/}, the return type is \texttt{LU\{T,S\{T\}\}}. If pivoting is chosen (default) the element type should also support \texttt{abs} and \texttt{<}.

The individual components of the factorization \texttt{F} can be accessed via \texttt{getproperty}:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Component & Description \\
\hline
\texttt{F.L} & \texttt{L} (lower triangular) part of \texttt{LU} \\
\hline
\texttt{F.U} & \texttt{U} (upper triangular) part of \texttt{LU} \\
\hline
\texttt{F.p} & (right) permutation \texttt{Vector} \\
\hline
\texttt{F.P} & (right) permutation \texttt{Matrix} \\
\hline
\end{tabulary}

\end{table}

Iterating the factorization produces the components \texttt{F.L}, \texttt{F.U}, and \texttt{F.p}.

The relationship between \texttt{F} and \texttt{A} is

\texttt{F.L*F.U == A[F.p, :]}

\texttt{F} further supports the following functions:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Supported function & \texttt{LU} & \texttt{LU\{T,Tridiagonal\{T\}\}} \\
\hline
\hyperlink{4103478871488785445}{\texttt{/}} & ✓ &  \\
\hline
\hyperlink{4639577998029770435}{\texttt{{\textbackslash}}} & ✓ & ✓ \\
\hline
\hyperlink{13336866048543706848}{\texttt{inv}} & ✓ & ✓ \\
\hline
\hyperlink{16543378577000914469}{\texttt{det}} & ✓ & ✓ \\
\hline
\hyperlink{12765142073947245963}{\texttt{logdet}} & ✓ & ✓ \\
\hline
\hyperlink{11067048979448481853}{\texttt{logabsdet}} & ✓ & ✓ \\
\hline
\hyperlink{17888996102305087038}{\texttt{size}} & ✓ & ✓ \\
\hline
\end{tabulary}

\end{table}

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4 3; 6 3]
2×2 Array{Int64,2}:
 4  3
 6  3

julia> F = lu(A)
LU{Float64,Array{Float64,2}}
L factor:
2×2 Array{Float64,2}:
 1.0       0.0
 0.666667  1.0
U factor:
2×2 Array{Float64,2}:
 6.0  3.0
 0.0  1.0

julia> F.L * F.U == A[F.p, :]
true

julia> l, u, p = lu(A); # destructuring via iteration

julia> l == F.L && u == F.U && p == F.p
true
\end{minted}



\end{adjustwidth}
\hypertarget{3268903080173564842}{} 
\hyperlink{3268903080173564842}{\texttt{LinearAlgebra.lu!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lu!(A, pivot=Val(true); check = true) -> LU
\end{minted}

\texttt{lu!} is the same as \hyperlink{5672569096214810830}{\texttt{lu}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. An \hyperlink{5399118524830636312}{\texttt{InexactError}} exception is thrown if the factorization produces a number not representable by the element type of \texttt{A}, e.g. for integer types.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4. 3.; 6. 3.]
2×2 Array{Float64,2}:
 4.0  3.0
 6.0  3.0

julia> F = lu!(A)
LU{Float64,Array{Float64,2}}
L factor:
2×2 Array{Float64,2}:
 1.0       0.0
 0.666667  1.0
U factor:
2×2 Array{Float64,2}:
 6.0  3.0
 0.0  1.0

julia> iA = [4 3; 6 3]
2×2 Array{Int64,2}:
 4  3
 6  3

julia> lu!(iA)
ERROR: InexactError: Int64(0.6666666666666666)
Stacktrace:
[...]
\end{minted}



\end{adjustwidth}
\hypertarget{17457903574632305101}{} 
\hyperlink{17457903574632305101}{\texttt{LinearAlgebra.Cholesky}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cholesky <: Factorization
\end{minted}

Matrix factorization type of the Cholesky factorization of a dense symmetric/Hermitian positive definite matrix \texttt{A}. This is the return type of \hyperlink{7653413936706994771}{\texttt{cholesky}}, the corresponding matrix factorization function.

The triangular Cholesky factor can be obtained from the factorization \texttt{F::Cholesky} via \texttt{F.L} and \texttt{F.U}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]
3×3 Array{Float64,2}:
   4.0   12.0  -16.0
  12.0   37.0  -43.0
 -16.0  -43.0   98.0

julia> C = cholesky(A)
Cholesky{Float64,Array{Float64,2}}
U factor:
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia> C.U
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia> C.L
3×3 LowerTriangular{Float64,Array{Float64,2}}:
  2.0   ⋅    ⋅
  6.0  1.0   ⋅
 -8.0  5.0  3.0

julia> C.L * C.U == A
true
\end{minted}



\end{adjustwidth}
\hypertarget{9530655262094960367}{} 
\hyperlink{9530655262094960367}{\texttt{LinearAlgebra.CholeskyPivoted}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
CholeskyPivoted
\end{minted}

Matrix factorization type of the pivoted Cholesky factorization of a dense symmetric/Hermitian positive semi-definite matrix \texttt{A}. This is the return type of \hyperlink{7653413936706994771}{\texttt{cholesky(\_, Val(true))}}, the corresponding matrix factorization function.

The triangular Cholesky factor can be obtained from the factorization \texttt{F::CholeskyPivoted} via \texttt{F.L} and \texttt{F.U}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]
3×3 Array{Float64,2}:
   4.0   12.0  -16.0
  12.0   37.0  -43.0
 -16.0  -43.0   98.0

julia> C = cholesky(A, Val(true))
CholeskyPivoted{Float64,Array{Float64,2}}
U factor with rank 3:
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 9.89949  -4.34366  -1.61624
  ⋅        4.25825   1.1694
  ⋅         ⋅        0.142334
permutation:
3-element Array{Int64,1}:
 3
 2
 1
\end{minted}



\end{adjustwidth}
\hypertarget{7653413936706994771}{} 
\hyperlink{7653413936706994771}{\texttt{LinearAlgebra.cholesky}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cholesky(A, Val(false); check = true) -> Cholesky
\end{minted}

Compute the Cholesky factorization of a dense symmetric positive definite matrix \texttt{A} and return a \texttt{Cholesky} factorization. The matrix \texttt{A} can either be a \hyperlink{17683454167504168761}{\texttt{Symmetric}} or \hyperlink{938713992181310063}{\texttt{Hermitian}} \texttt{StridedMatrix} or a \emph{perfectly} symmetric or Hermitian \texttt{StridedMatrix}. The triangular Cholesky factor can be obtained from the factorization \texttt{F} with: \texttt{F.L} and \texttt{F.U}. The following functions are available for \texttt{Cholesky} objects: \hyperlink{17888996102305087038}{\texttt{size}}, \hyperlink{4639577998029770435}{\texttt{{\textbackslash}}}, \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{16543378577000914469}{\texttt{det}}, \hyperlink{12765142073947245963}{\texttt{logdet}} and \hyperlink{13841568437070319804}{\texttt{isposdef}}.

When \texttt{check = true}, an error is thrown if the decomposition fails. When \texttt{check = false}, responsibility for checking the decomposition{\textquotesingle}s validity (via \hyperlink{10694198281534172656}{\texttt{issuccess}}) lies with the user.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]
3×3 Array{Float64,2}:
   4.0   12.0  -16.0
  12.0   37.0  -43.0
 -16.0  -43.0   98.0

julia> C = cholesky(A)
Cholesky{Float64,Array{Float64,2}}
U factor:
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia> C.U
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia> C.L
3×3 LowerTriangular{Float64,Array{Float64,2}}:
  2.0   ⋅    ⋅
  6.0  1.0   ⋅
 -8.0  5.0  3.0

julia> C.L * C.U == A
true
\end{minted}




\begin{lstlisting}
cholesky(A, Val(true); tol = 0.0, check = true) -> CholeskyPivoted
\end{lstlisting}

Compute the pivoted Cholesky factorization of a dense symmetric positive semi-definite matrix \texttt{A} and return a \texttt{CholeskyPivoted} factorization. The matrix \texttt{A} can either be a \hyperlink{17683454167504168761}{\texttt{Symmetric}} or \hyperlink{938713992181310063}{\texttt{Hermitian}} \texttt{StridedMatrix} or a \emph{perfectly} symmetric or Hermitian \texttt{StridedMatrix}. The triangular Cholesky factor can be obtained from the factorization \texttt{F} with: \texttt{F.L} and \texttt{F.U}. The following functions are available for \texttt{CholeskyPivoted} objects: \hyperlink{17888996102305087038}{\texttt{size}}, \hyperlink{4639577998029770435}{\texttt{{\textbackslash}}}, \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{16543378577000914469}{\texttt{det}}, and \hyperlink{439390458422397873}{\texttt{rank}}. The argument \texttt{tol} determines the tolerance for determining the rank. For negative values, the tolerance is the machine precision.

When \texttt{check = true}, an error is thrown if the decomposition fails. When \texttt{check = false}, responsibility for checking the decomposition{\textquotesingle}s validity (via \hyperlink{10694198281534172656}{\texttt{issuccess}}) lies with the user.



\end{adjustwidth}
\hypertarget{3967830962731048730}{} 
\hyperlink{3967830962731048730}{\texttt{LinearAlgebra.cholesky!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cholesky!(A, Val(false); check = true) -> Cholesky
\end{minted}

The same as \hyperlink{7653413936706994771}{\texttt{cholesky}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. An \hyperlink{5399118524830636312}{\texttt{InexactError}} exception is thrown if the factorization produces a number not representable by the element type of \texttt{A}, e.g. for integer types.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 2 50]
2×2 Array{Int64,2}:
 1   2
 2  50

julia> cholesky!(A)
ERROR: InexactError: Int64(6.782329983125268)
Stacktrace:
[...]
\end{minted}




\begin{lstlisting}
cholesky!(A, Val(true); tol = 0.0, check = true) -> CholeskyPivoted
\end{lstlisting}

The same as \hyperlink{7653413936706994771}{\texttt{cholesky}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. An \hyperlink{5399118524830636312}{\texttt{InexactError}} exception is thrown if the factorization produces a number not representable by the element type of \texttt{A}, e.g. for integer types.



\end{adjustwidth}
\hypertarget{11384711924205954768}{} 
\hyperlink{11384711924205954768}{\texttt{LinearAlgebra.lowrankupdate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lowrankupdate(C::Cholesky, v::StridedVector) -> CC::Cholesky
\end{minted}

Update a Cholesky factorization \texttt{C} with the vector \texttt{v}. If \texttt{A = C.U{\textquotesingle}C.U} then \texttt{CC = cholesky(C.U{\textquotesingle}C.U + v*v{\textquotesingle})} but the computation of \texttt{CC} only uses \texttt{O(n{\textasciicircum}2)} operations.



\end{adjustwidth}
\hypertarget{17556419310056499978}{} 
\hyperlink{17556419310056499978}{\texttt{LinearAlgebra.lowrankdowndate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lowrankdowndate(C::Cholesky, v::StridedVector) -> CC::Cholesky
\end{minted}

Downdate a Cholesky factorization \texttt{C} with the vector \texttt{v}. If \texttt{A = C.U{\textquotesingle}C.U} then \texttt{CC = cholesky(C.U{\textquotesingle}C.U - v*v{\textquotesingle})} but the computation of \texttt{CC} only uses \texttt{O(n{\textasciicircum}2)} operations.



\end{adjustwidth}
\hypertarget{2909160594931213214}{} 
\hyperlink{2909160594931213214}{\texttt{LinearAlgebra.lowrankupdate!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lowrankupdate!(C::Cholesky, v::StridedVector) -> CC::Cholesky
\end{minted}

Update a Cholesky factorization \texttt{C} with the vector \texttt{v}. If \texttt{A = C.U{\textquotesingle}C.U} then \texttt{CC = cholesky(C.U{\textquotesingle}C.U + v*v{\textquotesingle})} but the computation of \texttt{CC} only uses \texttt{O(n{\textasciicircum}2)} operations. The input factorization \texttt{C} is updated in place such that on exit \texttt{C == CC}. The vector \texttt{v} is destroyed during the computation.



\end{adjustwidth}
\hypertarget{15152518260640180506}{} 
\hyperlink{15152518260640180506}{\texttt{LinearAlgebra.lowrankdowndate!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lowrankdowndate!(C::Cholesky, v::StridedVector) -> CC::Cholesky
\end{minted}

Downdate a Cholesky factorization \texttt{C} with the vector \texttt{v}. If \texttt{A = C.U{\textquotesingle}C.U} then \texttt{CC = cholesky(C.U{\textquotesingle}C.U - v*v{\textquotesingle})} but the computation of \texttt{CC} only uses \texttt{O(n{\textasciicircum}2)} operations. The input factorization \texttt{C} is updated in place such that on exit \texttt{C == CC}. The vector \texttt{v} is destroyed during the computation.



\end{adjustwidth}
\hypertarget{5189218595453722756}{} 
\hyperlink{5189218595453722756}{\texttt{LinearAlgebra.LDLt}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LDLt <: Factorization
\end{minted}

Matrix factorization type of the \texttt{LDLt} factorization of a real \hyperlink{6062797780727203318}{\texttt{SymTridiagonal}} matrix \texttt{S} such that \texttt{S = L*Diagonal(d)*L{\textquotesingle}}, where \texttt{L} is a \hyperlink{2163321084999097240}{\texttt{UnitLowerTriangular}} matrix and \texttt{d} is a vector. The main use of an \texttt{LDLt} factorization \texttt{F = ldlt(S)} is to solve the linear system of equations \texttt{Sx = b} with \texttt{F{\textbackslash}b}. This is the return type of \hyperlink{8934377864822491393}{\texttt{ldlt}}, the corresponding matrix factorization function.

The individual components of the factorization \texttt{F::LDLt} can be accessed via \texttt{getproperty}:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|C|L|}
\hline
Component & Description \\
\hline
\texttt{F.L} & \texttt{L} (unit lower triangular) part of \texttt{LDLt} \\
\hline
\texttt{F.D} & \texttt{D} (diagonal) part of \texttt{LDLt} \\
\hline
\texttt{F.Lt} & \texttt{Lt} (unit upper triangular) part of \texttt{LDLt} \\
\hline
\texttt{F.d} & diagonal values of \texttt{D} as a \texttt{Vector} \\
\hline
\end{tabulary}

\end{table}

\textbf{Examples}


\begin{minted}{jlcon}
julia> S = SymTridiagonal([3., 4., 5.], [1., 2.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 3.0  1.0   ⋅
 1.0  4.0  2.0
  ⋅   2.0  5.0

julia> F = ldlt(S)
LDLt{Float64,SymTridiagonal{Float64,Array{Float64,1}}}
L factor:
3×3 UnitLowerTriangular{Float64,SymTridiagonal{Float64,Array{Float64,1}}}:
 1.0        ⋅         ⋅
 0.333333  1.0        ⋅
 0.0       0.545455  1.0
D factor:
3×3 Diagonal{Float64,Array{Float64,1}}:
 3.0   ⋅        ⋅
  ⋅   3.66667   ⋅
  ⋅    ⋅       3.90909
\end{minted}



\end{adjustwidth}
\hypertarget{8934377864822491393}{} 
\hyperlink{8934377864822491393}{\texttt{LinearAlgebra.ldlt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ldlt(S::SymTridiagonal) -> LDLt
\end{minted}

Compute an \texttt{LDLt} factorization of the real symmetric tridiagonal matrix \texttt{S} such that \texttt{S = L*Diagonal(d)*L{\textquotesingle}} where \texttt{L} is a unit lower triangular matrix and \texttt{d} is a vector. The main use of an \texttt{LDLt} factorization \texttt{F = ldlt(S)} is to solve the linear system of equations \texttt{Sx = b} with \texttt{F{\textbackslash}b}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> S = SymTridiagonal([3., 4., 5.], [1., 2.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 3.0  1.0   ⋅
 1.0  4.0  2.0
  ⋅   2.0  5.0

julia> ldltS = ldlt(S);

julia> b = [6., 7., 8.];

julia> ldltS \ b
3-element Array{Float64,1}:
 1.7906976744186047
 0.627906976744186
 1.3488372093023255

julia> S \ b
3-element Array{Float64,1}:
 1.7906976744186047
 0.627906976744186
 1.3488372093023255
\end{minted}



\end{adjustwidth}
\hypertarget{9183185033445403339}{} 
\hyperlink{9183185033445403339}{\texttt{LinearAlgebra.ldlt!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ldlt!(S::SymTridiagonal) -> LDLt
\end{minted}

Same as \hyperlink{8934377864822491393}{\texttt{ldlt}}, but saves space by overwriting the input \texttt{S}, instead of creating a copy.

\textbf{Examples}


\begin{minted}{jlcon}
julia> S = SymTridiagonal([3., 4., 5.], [1., 2.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 3.0  1.0   ⋅
 1.0  4.0  2.0
  ⋅   2.0  5.0

julia> ldltS = ldlt!(S);

julia> ldltS === S
false

julia> S
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 3.0       0.333333   ⋅
 0.333333  3.66667   0.545455
  ⋅        0.545455  3.90909
\end{minted}



\end{adjustwidth}
\hypertarget{16913872014958777367}{} 
\hyperlink{16913872014958777367}{\texttt{LinearAlgebra.QR}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
QR <: Factorization
\end{minted}

A QR matrix factorization stored in a packed format, typically obtained from \hyperlink{4122539696772350360}{\texttt{qr}}. If  \(A\)  is an \texttt{m}×\texttt{n} matrix, then

\begin{equation*}
\begin{split}A = Q R\end{split}\end{equation*}
where  \(Q\)  is an orthogonal/unitary matrix and  \(R\)  is upper triangular. The matrix  \(Q\)  is stored as a sequence of Householder reflectors  \(v_i\)  and coefficients  \(\tau_i\)  where:

\begin{equation*}
\begin{split}Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T).\end{split}\end{equation*}
Iterating the decomposition produces the components \texttt{Q} and \texttt{R}.

The object has two fields:

\begin{itemize}
\item \texttt{factors} is an \texttt{m}×\texttt{n} matrix.

\begin{itemize}
\item The upper triangular part contains the elements of  \(R\) , that is \texttt{R = triu(F.factors)} for a \texttt{QR} object \texttt{F}.


\item The subdiagonal part contains the reflectors  \(v_i\)  stored in a packed format where  \(v_i\)  is the  \(i\) th column of the matrix \texttt{V = I + tril(F.factors, -1)}.

\end{itemize}

\item \texttt{τ} is a vector  of length \texttt{min(m,n)} containing the coefficients  \(au_i\) .

\end{itemize}


\end{adjustwidth}
\hypertarget{15814215390089782499}{} 
\hyperlink{15814215390089782499}{\texttt{LinearAlgebra.QRCompactWY}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
QRCompactWY <: Factorization
\end{minted}

A QR matrix factorization stored in a compact blocked format, typically obtained from \hyperlink{4122539696772350360}{\texttt{qr}}. If  \(A\)  is an \texttt{m}×\texttt{n} matrix, then

\begin{equation*}
\begin{split}A = Q R\end{split}\end{equation*}
where  \(Q\)  is an orthogonal/unitary matrix and  \(R\)  is upper triangular. It is similar to the \hyperlink{16913872014958777367}{\texttt{QR}} format except that the orthogonal/unitary matrix  \(Q\)  is stored in \emph{Compact WY} format \footnotemark[1].  For the block size  \(n_b\) , it is stored as a \texttt{m}×\texttt{n} lower trapezoidal matrix  \(V\)  and a matrix  \(T = (T_1 \; T_2 \; ... \; T_{b-1} \; T_b')\)  composed of  \(b = \lceil \min(m,n) / n_b \rceil\)  upper triangular matrices  \(T_j\)  of size  \(n_b\) × \(n_b\)  ( \(j = 1, ..., b-1\) ) and an upper trapezoidal  \(n_b\) × \(\min(m,n) - (b-1) n_b\)  matrix  \(T_b'\)  ( \(j=b\) ) whose upper square part denoted with  \(T_b\)  satisfying

\begin{equation*}
\begin{split}Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T)
= \prod_{j=1}^{b} (I - V_j T_j V_j^T)\end{split}\end{equation*}
such that  \(v_i\)  is the  \(i\) th column of  \(V\) ,  \(\tau_i\)  is the  \(i\) th element of \texttt{[diag(T\_1); diag(T\_2); …; diag(T\_b)]}, and  \((V_1 \; V_2 \; ... \; V_b)\)  is the left \texttt{m}×\texttt{min(m, n)} block of  \(V\) .  When constructed using \hyperlink{4122539696772350360}{\texttt{qr}}, the block size is given by  \(n_b = \min(m, n, 36)\) .

Iterating the decomposition produces the components \texttt{Q} and \texttt{R}.

The object has two fields:

\begin{itemize}
\item \texttt{factors}, as in the \hyperlink{16913872014958777367}{\texttt{QR}} type, is an \texttt{m}×\texttt{n} matrix.

\begin{itemize}
\item The upper triangular part contains the elements of  \(R\) , that is \texttt{R = triu(F.factors)} for a \texttt{QR} object \texttt{F}.


\item The subdiagonal part contains the reflectors  \(v_i\)  stored in a packed format such that \texttt{V = I + tril(F.factors, -1)}.

\end{itemize}

\item \texttt{T} is a  \(n_b\) -by- \(\min(m,n)\)  matrix as described above. The subdiagonal elements for each triangular matrix  \(T_j\)  are ignored.

\end{itemize}
\begin{quote}
\textbf{Note}

This format should not to be confused with the older \emph{WY} representation \footnotemark[2].

\end{quote}
\footnotetext[2]{C Bischof and C Van Loan, {\textquotedbl}The WY representation for products of Householder matrices{\textquotedbl}, SIAM J Sci Stat Comput 8 (1987), s2-s13. \href{https://doi.org/10.1137/0908009}{doi:10.1137/0908009}

}
\footnotetext[1]{R Schreiber and C Van Loan, {\textquotedbl}A storage-efficient WY representation for products of Householder transformations{\textquotedbl}, SIAM J Sci Stat Comput 10 (1989), 53-57. \href{https://doi.org/10.1137/0910005}{doi:10.1137/0910005}

}


\end{adjustwidth}
\hypertarget{1950169381798525185}{} 
\hyperlink{1950169381798525185}{\texttt{LinearAlgebra.QRPivoted}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
QRPivoted <: Factorization
\end{minted}

A QR matrix factorization with column pivoting in a packed format, typically obtained from \hyperlink{4122539696772350360}{\texttt{qr}}. If  \(A\)  is an \texttt{m}×\texttt{n} matrix, then

\begin{equation*}
\begin{split}A P = Q R\end{split}\end{equation*}
where  \(P\)  is a permutation matrix,  \(Q\)  is an orthogonal/unitary matrix and  \(R\)  is upper triangular. The matrix  \(Q\)  is stored as a sequence of Householder reflectors:

\begin{equation*}
\begin{split}Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T).\end{split}\end{equation*}
Iterating the decomposition produces the components \texttt{Q}, \texttt{R}, and \texttt{p}.

The object has three fields:

\begin{itemize}
\item \texttt{factors} is an \texttt{m}×\texttt{n} matrix.

\begin{itemize}
\item The upper triangular part contains the elements of  \(R\) , that is \texttt{R = triu(F.factors)} for a \texttt{QR} object \texttt{F}.


\item The subdiagonal part contains the reflectors  \(v_i\)  stored in a packed format where  \(v_i\)  is the  \(i\) th column of the matrix \texttt{V = I + tril(F.factors, -1)}.

\end{itemize}

\item \texttt{τ} is a vector of length \texttt{min(m,n)} containing the coefficients  \(au_i\) .


\item \texttt{jpvt} is an integer vector of length \texttt{n} corresponding to the permutation  \(P\) .

\end{itemize}


\end{adjustwidth}
\hypertarget{4122539696772350360}{} 
\hyperlink{4122539696772350360}{\texttt{LinearAlgebra.qr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
qr(A, pivot=Val(false); blocksize) -> F
\end{minted}

Compute the QR factorization of the matrix \texttt{A}: an orthogonal (or unitary if \texttt{A} is complex-valued) matrix \texttt{Q}, and an upper triangular matrix \texttt{R} such that

\begin{equation*}
\begin{split}A = Q R\end{split}\end{equation*}
The returned object \texttt{F} stores the factorization in a packed format:

\begin{itemize}
\item if \texttt{pivot == Val(true)} then \texttt{F} is a \hyperlink{1950169381798525185}{\texttt{QRPivoted}} object,


\item otherwise if the element type of \texttt{A} is a BLAS type (\hyperlink{8101639384272933082}{\texttt{Float32}}, \hyperlink{5027751419500983000}{\texttt{Float64}}, \texttt{ComplexF32} or \texttt{ComplexF64}), then \texttt{F} is a \hyperlink{15814215390089782499}{\texttt{QRCompactWY}} object,


\item otherwise \texttt{F} is a \hyperlink{16913872014958777367}{\texttt{QR}} object.

\end{itemize}
The individual components of the decomposition \texttt{F} can be retrieved via property accessors:

\begin{itemize}
\item \texttt{F.Q}: the orthogonal/unitary matrix \texttt{Q}


\item \texttt{F.R}: the upper triangular matrix \texttt{R}


\item \texttt{F.p}: the permutation vector of the pivot (\hyperlink{1950169381798525185}{\texttt{QRPivoted}} only)


\item \texttt{F.P}: the permutation matrix of the pivot (\hyperlink{1950169381798525185}{\texttt{QRPivoted}} only)

\end{itemize}
Iterating the decomposition produces the components \texttt{Q}, \texttt{R}, and if extant \texttt{p}.

The following functions are available for the \texttt{QR} objects: \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{17888996102305087038}{\texttt{size}}, and \hyperlink{4639577998029770435}{\texttt{{\textbackslash}}}. When \texttt{A} is rectangular, \texttt{{\textbackslash}} will return a least squares solution and if the solution is not unique, the one with smallest norm is returned. When \texttt{A} is not full rank, factorization with (column) pivoting is required to obtain a minimum norm solution.

Multiplication with respect to either full/square or non-full/square \texttt{Q} is allowed, i.e. both \texttt{F.Q*F.R} and \texttt{F.Q*A} are supported. A \texttt{Q} matrix can be converted into a regular matrix with \hyperlink{5448927444601277512}{\texttt{Matrix}}.  This operation returns the {\textquotedbl}thin{\textquotedbl} Q factor, i.e., if \texttt{A} is \texttt{m}×\texttt{n} with \texttt{m>=n}, then \texttt{Matrix(F.Q)} yields an \texttt{m}×\texttt{n} matrix with orthonormal columns.  To retrieve the {\textquotedbl}full{\textquotedbl} Q factor, an \texttt{m}×\texttt{m} orthogonal matrix, use \texttt{F.Q*Matrix(I,m,m)}.  If \texttt{m<=n}, then \texttt{Matrix(F.Q)} yields an \texttt{m}×\texttt{m} orthogonal matrix.

The block size for QR decomposition can be specified by keyword argument \texttt{blocksize :: Integer} when \texttt{pivot == Val(false)} and \texttt{A isa StridedMatrix\{<:BlasFloat\}}. It is ignored when \texttt{blocksize > minimum(size(A))}.  See \hyperlink{15814215390089782499}{\texttt{QRCompactWY}}.

\begin{quote}
\textbf{Julia 1.4}

The \texttt{blocksize} keyword argument requires Julia 1.4 or later.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [3.0 -6.0; 4.0 -8.0; 0.0 1.0]
3×2 Array{Float64,2}:
 3.0  -6.0
 4.0  -8.0
 0.0   1.0

julia> F = qr(A)
LinearAlgebra.QRCompactWY{Float64,Array{Float64,2}}
Q factor:
3×3 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}:
 -0.6   0.0   0.8
 -0.8   0.0  -0.6
  0.0  -1.0   0.0
R factor:
2×2 Array{Float64,2}:
 -5.0  10.0
  0.0  -1.0

julia> F.Q * F.R == A
true
\end{minted}

\begin{quote}
\textbf{Note}

\texttt{qr} returns multiple types because LAPACK uses several representations that minimize the memory storage requirements of products of Householder elementary reflectors, so that the \texttt{Q} and \texttt{R} matrices can be stored compactly rather as two separate dense matrices.

\end{quote}


\end{adjustwidth}
\hypertarget{9968830575998743150}{} 
\hyperlink{9968830575998743150}{\texttt{LinearAlgebra.qr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
qr!(A, pivot=Val(false); blocksize)
\end{minted}

\texttt{qr!} is the same as \hyperlink{4122539696772350360}{\texttt{qr}} when \texttt{A} is a subtype of \texttt{StridedMatrix}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. An \hyperlink{5399118524830636312}{\texttt{InexactError}} exception is thrown if the factorization produces a number not representable by the element type of \texttt{A}, e.g. for integer types.

\begin{quote}
\textbf{Julia 1.4}

The \texttt{blocksize} keyword argument requires Julia 1.4 or later.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1. 2.; 3. 4.]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia> qr!(a)
LinearAlgebra.QRCompactWY{Float64,Array{Float64,2}}
Q factor:
2×2 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}:
 -0.316228  -0.948683
 -0.948683   0.316228
R factor:
2×2 Array{Float64,2}:
 -3.16228  -4.42719
  0.0      -0.632456

julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> qr!(a)
ERROR: InexactError: Int64(-3.1622776601683795)
Stacktrace:
[...]
\end{minted}



\end{adjustwidth}
\hypertarget{15372856222060015568}{} 
\hyperlink{15372856222060015568}{\texttt{LinearAlgebra.LQ}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LQ <: Factorization
\end{minted}

Matrix factorization type of the \texttt{LQ} factorization of a matrix \texttt{A}. The \texttt{LQ} decomposition is the \texttt{QR} decomposition of \texttt{transpose(A)}. This is the return type of \hyperlink{1096124289761034610}{\texttt{lq}}, the corresponding matrix factorization function.

If \texttt{S::LQ} is the factorization object, the lower triangular component can be obtained via \texttt{S.L}, and the orthogonal/unitary component via \texttt{S.Q}, such that \texttt{A ≈ S.L*S.Q}.

Iterating the decomposition produces the components \texttt{S.L} and \texttt{S.Q}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [5. 7.; -2. -4.]
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia> S = lq(A)
LQ{Float64,Array{Float64,2}} with factors L and Q:
[-8.60233 0.0; 4.41741 -0.697486]
[-0.581238 -0.813733; -0.813733 0.581238]

julia> S.L * S.Q
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia> l, q = S; # destructuring via iteration

julia> l == S.L &&  q == S.Q
true
\end{minted}



\end{adjustwidth}
\hypertarget{1096124289761034610}{} 
\hyperlink{1096124289761034610}{\texttt{LinearAlgebra.lq}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lq(A) -> S::LQ
\end{minted}

Compute the LQ decomposition of \texttt{A}. The decomposition{\textquotesingle}s lower triangular component can be obtained from the \texttt{LQ} object \texttt{S} via \texttt{S.L}, and the orthogonal/unitary component via \texttt{S.Q}, such that \texttt{A ≈ S.L*S.Q}.

Iterating the decomposition produces the components \texttt{S.L} and \texttt{S.Q}.

The LQ decomposition is the QR decomposition of \texttt{transpose(A)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [5. 7.; -2. -4.]
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia> S = lq(A)
LQ{Float64,Array{Float64,2}} with factors L and Q:
[-8.60233 0.0; 4.41741 -0.697486]
[-0.581238 -0.813733; -0.813733 0.581238]

julia> S.L * S.Q
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia> l, q = S; # destructuring via iteration

julia> l == S.L &&  q == S.Q
true
\end{minted}



\end{adjustwidth}
\hypertarget{11794326565026371502}{} 
\hyperlink{11794326565026371502}{\texttt{LinearAlgebra.lq!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lq!(A) -> LQ
\end{minted}

Compute the LQ factorization of \texttt{A}, using the input matrix as a workspace. See also \hyperlink{1096124289761034610}{\texttt{lq}}.



\end{adjustwidth}
\hypertarget{10272627787201613275}{} 
\hyperlink{10272627787201613275}{\texttt{LinearAlgebra.BunchKaufman}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
BunchKaufman <: Factorization
\end{minted}

Matrix factorization type of the Bunch-Kaufman factorization of a symmetric or Hermitian matrix \texttt{A} as \texttt{P{\textquotesingle}UDU{\textquotesingle}P} or \texttt{P{\textquotesingle}LDL{\textquotesingle}P}, depending on whether the upper (the default) or the lower triangle is stored in \texttt{A}. If \texttt{A} is complex symmetric then \texttt{U{\textquotesingle}} and \texttt{L{\textquotesingle}} denote the unconjugated transposes, i.e. \texttt{transpose(U)} and \texttt{transpose(L)}, respectively. This is the return type of \hyperlink{17253210517333433448}{\texttt{bunchkaufman}}, the corresponding matrix factorization function.

If \texttt{S::BunchKaufman} is the factorization object, the components can be obtained via \texttt{S.D}, \texttt{S.U} or \texttt{S.L} as appropriate given \texttt{S.uplo}, and \texttt{S.p}.

Iterating the decomposition produces the components \texttt{S.D}, \texttt{S.U} or \texttt{S.L} as appropriate given \texttt{S.uplo}, and \texttt{S.p}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 2 3]
2×2 Array{Int64,2}:
 1  2
 2  3

julia> S = bunchkaufman(A) # A gets wrapped internally by Symmetric(A)
BunchKaufman{Float64,Array{Float64,2}}
D factor:
2×2 Tridiagonal{Float64,Array{Float64,1}}:
 -0.333333  0.0
  0.0       3.0
U factor:
2×2 UnitUpperTriangular{Float64,Array{Float64,2}}:
 1.0  0.666667
  ⋅   1.0
permutation:
2-element Array{Int64,1}:
 1
 2

julia> d, u, p = S; # destructuring via iteration

julia> d == S.D && u == S.U && p == S.p
true

julia> S = bunchkaufman(Symmetric(A, :L))
BunchKaufman{Float64,Array{Float64,2}}
D factor:
2×2 Tridiagonal{Float64,Array{Float64,1}}:
 3.0   0.0
 0.0  -0.333333
L factor:
2×2 UnitLowerTriangular{Float64,Array{Float64,2}}:
 1.0        ⋅
 0.666667  1.0
permutation:
2-element Array{Int64,1}:
 2
 1
\end{minted}



\end{adjustwidth}
\hypertarget{17253210517333433448}{} 
\hyperlink{17253210517333433448}{\texttt{LinearAlgebra.bunchkaufman}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
bunchkaufman(A, rook::Bool=false; check = true) -> S::BunchKaufman
\end{minted}

Compute the Bunch-Kaufman \footnotemark[3] factorization of a symmetric or Hermitian matrix \texttt{A} as \texttt{P{\textquotesingle}*U*D*U{\textquotesingle}*P} or \texttt{P{\textquotesingle}*L*D*L{\textquotesingle}*P}, depending on which triangle is stored in \texttt{A}, and return a \texttt{BunchKaufman} object. Note that if \texttt{A} is complex symmetric then \texttt{U{\textquotesingle}} and \texttt{L{\textquotesingle}} denote the unconjugated transposes, i.e. \texttt{transpose(U)} and \texttt{transpose(L)}.

Iterating the decomposition produces the components \texttt{S.D}, \texttt{S.U} or \texttt{S.L} as appropriate given \texttt{S.uplo}, and \texttt{S.p}.

If \texttt{rook} is \texttt{true}, rook pivoting is used. If \texttt{rook} is false, rook pivoting is not used.

When \texttt{check = true}, an error is thrown if the decomposition fails. When \texttt{check = false}, responsibility for checking the decomposition{\textquotesingle}s validity (via \hyperlink{10694198281534172656}{\texttt{issuccess}}) lies with the user.

The following functions are available for \texttt{BunchKaufman} objects: \hyperlink{17888996102305087038}{\texttt{size}}, \texttt{{\textbackslash}}, \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{2326080217547608316}{\texttt{issymmetric}}, \hyperlink{2319981190929881860}{\texttt{ishermitian}}, \hyperlink{13720608614876840481}{\texttt{getindex}}.

\footnotetext[3]{J R Bunch and L Kaufman, Some stable methods for calculating inertia and solving symmetric linear systems, Mathematics of Computation 31:137 (1977), 163-179. \href{http://www.ams.org/journals/mcom/1977-31-137/S0025-5718-1977-0428694-0/}{url}.

}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 2 3]
2×2 Array{Int64,2}:
 1  2
 2  3

julia> S = bunchkaufman(A) # A gets wrapped internally by Symmetric(A)
BunchKaufman{Float64,Array{Float64,2}}
D factor:
2×2 Tridiagonal{Float64,Array{Float64,1}}:
 -0.333333  0.0
  0.0       3.0
U factor:
2×2 UnitUpperTriangular{Float64,Array{Float64,2}}:
 1.0  0.666667
  ⋅   1.0
permutation:
2-element Array{Int64,1}:
 1
 2

julia> d, u, p = S; # destructuring via iteration

julia> d == S.D && u == S.U && p == S.p
true

julia> S = bunchkaufman(Symmetric(A, :L))
BunchKaufman{Float64,Array{Float64,2}}
D factor:
2×2 Tridiagonal{Float64,Array{Float64,1}}:
 3.0   0.0
 0.0  -0.333333
L factor:
2×2 UnitLowerTriangular{Float64,Array{Float64,2}}:
 1.0        ⋅
 0.666667  1.0
permutation:
2-element Array{Int64,1}:
 2
 1
\end{minted}



\end{adjustwidth}
\hypertarget{12377977453211508613}{} 
\hyperlink{12377977453211508613}{\texttt{LinearAlgebra.bunchkaufman!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
bunchkaufman!(A, rook::Bool=false; check = true) -> BunchKaufman
\end{minted}

\texttt{bunchkaufman!} is the same as \hyperlink{17253210517333433448}{\texttt{bunchkaufman}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy.



\end{adjustwidth}
\hypertarget{2476442734611677039}{} 
\hyperlink{2476442734611677039}{\texttt{LinearAlgebra.Eigen}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Eigen <: Factorization
\end{minted}

Matrix factorization type of the eigenvalue/spectral decomposition of a square matrix \texttt{A}. This is the return type of \hyperlink{11056016707394839114}{\texttt{eigen}}, the corresponding matrix factorization function.

If \texttt{F::Eigen} is the factorization object, the eigenvalues can be obtained via \texttt{F.values} and the eigenvectors as the columns of the matrix \texttt{F.vectors}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{F.vectors[:, k]}.)

Iterating the decomposition produces the components \texttt{F.values} and \texttt{F.vectors}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> F = eigen([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
Eigen{Float64,Float64,Array{Float64,2},Array{Float64,1}}
values:
3-element Array{Float64,1}:
  1.0
  3.0
 18.0
vectors:
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia> F.values
3-element Array{Float64,1}:
  1.0
  3.0
 18.0

julia> F.vectors
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia> vals, vecs = F; # destructuring via iteration

julia> vals == F.values && vecs == F.vectors
true
\end{minted}



\end{adjustwidth}
\hypertarget{6969744257762628976}{} 
\hyperlink{6969744257762628976}{\texttt{LinearAlgebra.GeneralizedEigen}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GeneralizedEigen <: Factorization
\end{minted}

Matrix factorization type of the generalized eigenvalue/spectral decomposition of \texttt{A} and \texttt{B}. This is the return type of \hyperlink{11056016707394839114}{\texttt{eigen}}, the corresponding matrix factorization function, when called with two matrix arguments.

If \texttt{F::GeneralizedEigen} is the factorization object, the eigenvalues can be obtained via \texttt{F.values} and the eigenvectors as the columns of the matrix \texttt{F.vectors}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{F.vectors[:, k]}.)

Iterating the decomposition produces the components \texttt{F.values} and \texttt{F.vectors}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia> B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia> F = eigen(A, B)
GeneralizedEigen{Complex{Float64},Complex{Float64},Array{Complex{Float64},2},Array{Complex{Float64},1}}
values:
2-element Array{Complex{Float64},1}:
 0.0 - 1.0im
 0.0 + 1.0im
vectors:
2×2 Array{Complex{Float64},2}:
  0.0+1.0im   0.0-1.0im
 -1.0+0.0im  -1.0-0.0im

julia> F.values
2-element Array{Complex{Float64},1}:
 0.0 - 1.0im
 0.0 + 1.0im

julia> F.vectors
2×2 Array{Complex{Float64},2}:
  0.0+1.0im   0.0-1.0im
 -1.0+0.0im  -1.0-0.0im

julia> vals, vecs = F; # destructuring via iteration

julia> vals == F.values && vecs == F.vectors
true
\end{minted}



\end{adjustwidth}
\hypertarget{12334018763942871611}{} 
\hyperlink{12334018763942871611}{\texttt{LinearAlgebra.eigvals}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eigvals(A; permute::Bool=true, scale::Bool=true, sortby) -> values
\end{minted}

Return the eigenvalues of \texttt{A}.

For general non-symmetric matrices it is possible to specify how the matrix is balanced before the eigenvalue calculation. The \texttt{permute}, \texttt{scale}, and \texttt{sortby} keywords are the same as for \hyperlink{11207008815152064958}{\texttt{eigen!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> diag_matrix = [1 0; 0 4]
2×2 Array{Int64,2}:
 1  0
 0  4

julia> eigvals(diag_matrix)
2-element Array{Float64,1}:
 1.0
 4.0
\end{minted}



For a scalar input, \texttt{eigvals} will return a scalar.

\textbf{Example}


\begin{minted}{jlcon}
julia> eigvals(-2)
-2
\end{minted}




\begin{lstlisting}
eigvals(A, B) -> values
\end{lstlisting}

Computes the generalized eigenvalues of \texttt{A} and \texttt{B}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia> B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia> eigvals(A,B)
2-element Array{Complex{Float64},1}:
 0.0 - 1.0im
 0.0 + 1.0im
\end{minted}




\begin{lstlisting}
eigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> values
\end{lstlisting}

Returns the eigenvalues of \texttt{A}. It is possible to calculate only a subset of the eigenvalues by specifying a \texttt{UnitRange} \texttt{irange} covering indices of the sorted eigenvalues, e.g. the 2nd to 8th eigenvalues.


\begin{minted}{jlcon}
julia> A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia> eigvals(A, 2:2)
1-element Array{Float64,1}:
 0.9999999999999996

julia> eigvals(A)
3-element Array{Float64,1}:
 -2.1400549446402604
  1.0000000000000002
  5.140054944640259
\end{minted}




\begin{lstlisting}
eigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> values
\end{lstlisting}

Returns the eigenvalues of \texttt{A}. It is possible to calculate only a subset of the eigenvalues by specifying a pair \texttt{vl} and \texttt{vu} for the lower and upper boundaries of the eigenvalues.


\begin{minted}{jlcon}
julia> A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia> eigvals(A, -1, 2)
1-element Array{Float64,1}:
 1.0000000000000009

julia> eigvals(A)
3-element Array{Float64,1}:
 -2.1400549446402604
  1.0000000000000002
  5.140054944640259
\end{minted}



\end{adjustwidth}
\hypertarget{10264430947938868113}{} 
\hyperlink{10264430947938868113}{\texttt{LinearAlgebra.eigvals!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eigvals!(A; permute::Bool=true, scale::Bool=true, sortby) -> values
\end{minted}

Same as \hyperlink{12334018763942871611}{\texttt{eigvals}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. The \texttt{permute}, \texttt{scale}, and \texttt{sortby} keywords are the same as for \hyperlink{11056016707394839114}{\texttt{eigen}}.

\begin{quote}
\textbf{Note}

The input matrix \texttt{A} will not contain its eigenvalues after \texttt{eigvals!} is called on it - \texttt{A} is used as a workspace.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1. 2.; 3. 4.]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia> eigvals!(A)
2-element Array{Float64,1}:
 -0.3722813232690143
  5.372281323269014

julia> A
2×2 Array{Float64,2}:
 -0.372281  -1.0
  0.0        5.37228
\end{minted}




\begin{lstlisting}
eigvals!(A, B; sortby) -> values
\end{lstlisting}

Same as \hyperlink{12334018763942871611}{\texttt{eigvals}}, but saves space by overwriting the input \texttt{A} (and \texttt{B}), instead of creating copies.

\begin{quote}
\textbf{Note}

The input matrices \texttt{A} and \texttt{B} will not contain their eigenvalues after \texttt{eigvals!} is called. They are used as workspaces.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1. 0.; 0. -1.]
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia> B = [0. 1.; 1. 0.]
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia> eigvals!(A, B)
2-element Array{Complex{Float64},1}:
 0.0 - 1.0im
 0.0 + 1.0im

julia> A
2×2 Array{Float64,2}:
 -0.0  -1.0
  1.0  -0.0

julia> B
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0
\end{minted}




\begin{lstlisting}
eigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> values
\end{lstlisting}

Same as \hyperlink{12334018763942871611}{\texttt{eigvals}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. \texttt{irange} is a range of eigenvalue \emph{indices} to search for - for instance, the 2nd to 8th eigenvalues.




\begin{lstlisting}
eigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> values
\end{lstlisting}

Same as \hyperlink{12334018763942871611}{\texttt{eigvals}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. \texttt{vl} is the lower bound of the interval to search for eigenvalues, and \texttt{vu} is the upper bound.



\end{adjustwidth}
\hypertarget{1568196261511691624}{} 
\hyperlink{1568196261511691624}{\texttt{LinearAlgebra.eigmax}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eigmax(A; permute::Bool=true, scale::Bool=true)
\end{minted}

Return the largest eigenvalue of \texttt{A}. The option \texttt{permute=true} permutes the matrix to become closer to upper triangular, and \texttt{scale=true} scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of \texttt{A} are complex, this method will fail, since complex numbers cannot be sorted.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [0 im; -im 0]
2×2 Array{Complex{Int64},2}:
 0+0im  0+1im
 0-1im  0+0im

julia> eigmax(A)
1.0

julia> A = [0 im; -1 0]
2×2 Array{Complex{Int64},2}:
  0+0im  0+1im
 -1+0im  0+0im

julia> eigmax(A)
ERROR: DomainError with Complex{Int64}[0+0im 0+1im; -1+0im 0+0im]:
`A` cannot have complex eigenvalues.
Stacktrace:
[...]
\end{minted}



\end{adjustwidth}
\hypertarget{658135215942727363}{} 
\hyperlink{658135215942727363}{\texttt{LinearAlgebra.eigmin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eigmin(A; permute::Bool=true, scale::Bool=true)
\end{minted}

Return the smallest eigenvalue of \texttt{A}. The option \texttt{permute=true} permutes the matrix to become closer to upper triangular, and \texttt{scale=true} scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of \texttt{A} are complex, this method will fail, since complex numbers cannot be sorted.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [0 im; -im 0]
2×2 Array{Complex{Int64},2}:
 0+0im  0+1im
 0-1im  0+0im

julia> eigmin(A)
-1.0

julia> A = [0 im; -1 0]
2×2 Array{Complex{Int64},2}:
  0+0im  0+1im
 -1+0im  0+0im

julia> eigmin(A)
ERROR: DomainError with Complex{Int64}[0+0im 0+1im; -1+0im 0+0im]:
`A` cannot have complex eigenvalues.
Stacktrace:
[...]
\end{minted}



\end{adjustwidth}
\hypertarget{8591842276375230542}{} 
\hyperlink{8591842276375230542}{\texttt{LinearAlgebra.eigvecs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eigvecs(A::SymTridiagonal[, eigvals]) -> Matrix
\end{minted}

Return a matrix \texttt{M} whose columns are the eigenvectors of \texttt{A}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{M[:, k]}.)

If the optional vector of eigenvalues \texttt{eigvals} is specified, \texttt{eigvecs} returns the specific corresponding eigenvectors.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia> eigvals(A)
3-element Array{Float64,1}:
 -2.1400549446402604
  1.0000000000000002
  5.140054944640259

julia> eigvecs(A)
3×3 Array{Float64,2}:
  0.418304  -0.83205      0.364299
 -0.656749  -7.39009e-16  0.754109
  0.627457   0.5547       0.546448

julia> eigvecs(A, [1.])
3×1 Array{Float64,2}:
  0.8320502943378438
  4.263514128092366e-17
 -0.5547001962252291
\end{minted}




\begin{lstlisting}
eigvecs(A; permute::Bool=true, scale::Bool=true, `sortby`) -> Matrix
\end{lstlisting}

Return a matrix \texttt{M} whose columns are the eigenvectors of \texttt{A}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{M[:, k]}.) The \texttt{permute}, \texttt{scale}, and \texttt{sortby} keywords are the same as for \hyperlink{11056016707394839114}{\texttt{eigen}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> eigvecs([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0
\end{minted}




\begin{lstlisting}
eigvecs(A, B) -> Matrix
\end{lstlisting}

Return a matrix \texttt{M} whose columns are the generalized eigenvectors of \texttt{A} and \texttt{B}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{M[:, k]}.)

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia> B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia> eigvecs(A, B)
2×2 Array{Complex{Float64},2}:
  0.0+1.0im   0.0-1.0im
 -1.0+0.0im  -1.0-0.0im
\end{minted}



\end{adjustwidth}
\hypertarget{11056016707394839114}{} 
\hyperlink{11056016707394839114}{\texttt{LinearAlgebra.eigen}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eigen(A; permute::Bool=true, scale::Bool=true, sortby) -> Eigen
\end{minted}

Computes the eigenvalue decomposition of \texttt{A}, returning an \texttt{Eigen} factorization object \texttt{F} which contains the eigenvalues in \texttt{F.values} and the eigenvectors in the columns of the matrix \texttt{F.vectors}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{F.vectors[:, k]}.)

Iterating the decomposition produces the components \texttt{F.values} and \texttt{F.vectors}.

The following functions are available for \texttt{Eigen} objects: \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{16543378577000914469}{\texttt{det}}, and \hyperlink{13841568437070319804}{\texttt{isposdef}}.

For general nonsymmetric matrices it is possible to specify how the matrix is balanced before the eigenvector calculation. The option \texttt{permute=true} permutes the matrix to become closer to upper triangular, and \texttt{scale=true} scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is \texttt{true} for both options.

By default, the eigenvalues and vectors are sorted lexicographically by \texttt{(real(λ),imag(λ))}. A different comparison function \texttt{by(λ)} can be passed to \texttt{sortby}, or you can pass \texttt{sortby=nothing} to leave the eigenvalues in an arbitrary order.   Some special matrix types (e.g. \texttt{Diagonal} or \texttt{SymTridiagonal}) may implement their own sorting convention and not accept a \texttt{sortby} keyword.

\textbf{Examples}


\begin{minted}{jlcon}
julia> F = eigen([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
Eigen{Float64,Float64,Array{Float64,2},Array{Float64,1}}
values:
3-element Array{Float64,1}:
  1.0
  3.0
 18.0
vectors:
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia> F.values
3-element Array{Float64,1}:
  1.0
  3.0
 18.0

julia> F.vectors
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia> vals, vecs = F; # destructuring via iteration

julia> vals == F.values && vecs == F.vectors
true
\end{minted}




\begin{lstlisting}
eigen(A, B) -> GeneralizedEigen
\end{lstlisting}

Computes the generalized eigenvalue decomposition of \texttt{A} and \texttt{B}, returning a \texttt{GeneralizedEigen} factorization object \texttt{F} which contains the generalized eigenvalues in \texttt{F.values} and the generalized eigenvectors in the columns of the matrix \texttt{F.vectors}. (The \texttt{k}th generalized eigenvector can be obtained from the slice \texttt{F.vectors[:, k]}.)

Iterating the decomposition produces the components \texttt{F.values} and \texttt{F.vectors}.

Any keyword arguments passed to \texttt{eigen} are passed through to the lower-level \hyperlink{11207008815152064958}{\texttt{eigen!}} function.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia> B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia> F = eigen(A, B);

julia> F.values
2-element Array{Complex{Float64},1}:
 0.0 - 1.0im
 0.0 + 1.0im

julia> F.vectors
2×2 Array{Complex{Float64},2}:
  0.0+1.0im   0.0-1.0im
 -1.0+0.0im  -1.0-0.0im

julia> vals, vecs = F; # destructuring via iteration

julia> vals == F.values && vecs == F.vectors
true
\end{minted}




\begin{lstlisting}
eigen(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> Eigen
\end{lstlisting}

Computes the eigenvalue decomposition of \texttt{A}, returning an \texttt{Eigen} factorization object \texttt{F} which contains the eigenvalues in \texttt{F.values} and the eigenvectors in the columns of the matrix \texttt{F.vectors}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{F.vectors[:, k]}.)

Iterating the decomposition produces the components \texttt{F.values} and \texttt{F.vectors}.

The following functions are available for \texttt{Eigen} objects: \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{16543378577000914469}{\texttt{det}}, and \hyperlink{13841568437070319804}{\texttt{isposdef}}.

The \texttt{UnitRange} \texttt{irange} specifies indices of the sorted eigenvalues to search for.

\begin{quote}
\textbf{Note}

If \texttt{irange} is not \texttt{1:n}, where \texttt{n} is the dimension of \texttt{A}, then the returned factorization will be a \emph{truncated} factorization.

\end{quote}



\begin{lstlisting}
eigen(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> Eigen
\end{lstlisting}

Computes the eigenvalue decomposition of \texttt{A}, returning an \texttt{Eigen} factorization object \texttt{F} which contains the eigenvalues in \texttt{F.values} and the eigenvectors in the columns of the matrix \texttt{F.vectors}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{F.vectors[:, k]}.)

Iterating the decomposition produces the components \texttt{F.values} and \texttt{F.vectors}.

The following functions are available for \texttt{Eigen} objects: \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{16543378577000914469}{\texttt{det}}, and \hyperlink{13841568437070319804}{\texttt{isposdef}}.

\texttt{vl} is the lower bound of the window of eigenvalues to search for, and \texttt{vu} is the upper bound.

\begin{quote}
\textbf{Note}

If [\texttt{vl}, \texttt{vu}] does not contain all eigenvalues of \texttt{A}, then the returned factorization will be a \emph{truncated} factorization.

\end{quote}


\end{adjustwidth}
\hypertarget{11207008815152064958}{} 
\hyperlink{11207008815152064958}{\texttt{LinearAlgebra.eigen!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eigen!(A, [B]; permute, scale, sortby)
\end{minted}

Same as \hyperlink{11056016707394839114}{\texttt{eigen}}, but saves space by overwriting the input \texttt{A} (and \texttt{B}), instead of creating a copy.



\end{adjustwidth}
\hypertarget{17562496283230520715}{} 
\hyperlink{17562496283230520715}{\texttt{LinearAlgebra.Hessenberg}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Hessenberg <: Factorization
\end{minted}

A \texttt{Hessenberg} object represents the Hessenberg factorization \texttt{QHQ{\textquotesingle}} of a square matrix, or a shift \texttt{Q(H+μI)Q{\textquotesingle}} thereof, which is produced by the \hyperlink{14451165250498024497}{\texttt{hessenberg}} function.



\end{adjustwidth}
\hypertarget{14451165250498024497}{} 
\hyperlink{14451165250498024497}{\texttt{LinearAlgebra.hessenberg}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hessenberg(A) -> Hessenberg
\end{minted}

Compute the Hessenberg decomposition of \texttt{A} and return a \texttt{Hessenberg} object. If \texttt{F} is the factorization object, the unitary matrix can be accessed with \texttt{F.Q} (of type \texttt{LinearAlgebra.HessenbergQ}) and the Hessenberg matrix with \texttt{F.H} (of type \hyperlink{6167777885202579792}{\texttt{UpperHessenberg}}), either of which may be converted to a regular matrix with \texttt{Matrix(F.H)} or \texttt{Matrix(F.Q)}.

If \texttt{A} is \hyperlink{938713992181310063}{\texttt{Hermitian}} or real-\hyperlink{17683454167504168761}{\texttt{Symmetric}}, then the Hessenberg decomposition produces a real-symmetric tridiagonal matrix and \texttt{F.H} is of type \hyperlink{6062797780727203318}{\texttt{SymTridiagonal}}.

Note that the shifted factorization \texttt{A+μI = Q (H+μI) Q{\textquotesingle}} can be constructed efficiently by \texttt{F + μ*I} using the \hyperlink{723087258311673942}{\texttt{UniformScaling}} object \hyperlink{15346645596018210602}{\texttt{I}}, which creates a new \texttt{Hessenberg} object with shared storage and a modified shift.   The shift of a given \texttt{F} is obtained by \texttt{F.μ}. This is useful because multiple shifted solves \texttt{(F + μ*I) {\textbackslash} b} (for different \texttt{μ} and/or \texttt{b}) can be performed efficiently once \texttt{F} is created.

Iterating the decomposition produces the factors \texttt{F.Q, F.H, F.μ}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4. 9. 7.; 4. 4. 1.; 4. 3. 2.]
3×3 Array{Float64,2}:
 4.0  9.0  7.0
 4.0  4.0  1.0
 4.0  3.0  2.0

julia> F = hessenberg(A)
Hessenberg{Float64,UpperHessenberg{Float64,Array{Float64,2}},Array{Float64,2},Array{Float64,1},Bool}
Q factor:
3×3 LinearAlgebra.HessenbergQ{Float64,Array{Float64,2},Array{Float64,1},false}:
 1.0   0.0        0.0
 0.0  -0.707107  -0.707107
 0.0  -0.707107   0.707107
H factor:
3×3 UpperHessenberg{Float64,Array{Float64,2}}:
  4.0      -11.3137       -1.41421
 -5.65685    5.0           2.0
   ⋅        -8.88178e-16   1.0

julia> F.Q * F.H * F.Q'
3×3 Array{Float64,2}:
 4.0  9.0  7.0
 4.0  4.0  1.0
 4.0  3.0  2.0

julia> q, h = F; # destructuring via iteration

julia> q == F.Q && h == F.H
true
\end{minted}



\end{adjustwidth}
\hypertarget{6911141030439555603}{} 
\hyperlink{6911141030439555603}{\texttt{LinearAlgebra.hessenberg!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hessenberg!(A) -> Hessenberg
\end{minted}

\texttt{hessenberg!} is the same as \hyperlink{14451165250498024497}{\texttt{hessenberg}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy.



\end{adjustwidth}
\hypertarget{9412476259327688170}{} 
\hyperlink{9412476259327688170}{\texttt{LinearAlgebra.Schur}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Schur <: Factorization
\end{minted}

Matrix factorization type of the Schur factorization of a matrix \texttt{A}. This is the return type of \hyperlink{17132870828407138368}{\texttt{schur(\_)}}, the corresponding matrix factorization function.

If \texttt{F::Schur} is the factorization object, the (quasi) triangular Schur factor can be obtained via either \texttt{F.Schur} or \texttt{F.T} and the orthogonal/unitary Schur vectors via \texttt{F.vectors} or \texttt{F.Z} such that \texttt{A = F.vectors * F.Schur * F.vectors{\textquotesingle}}. The eigenvalues of \texttt{A} can be obtained with \texttt{F.values}.

Iterating the decomposition produces the components \texttt{F.T}, \texttt{F.Z}, and \texttt{F.values}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [5. 7.; -2. -4.]
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia> F = schur(A)
Schur{Float64,Array{Float64,2}}
T factor:
2×2 Array{Float64,2}:
 3.0   9.0
 0.0  -2.0
Z factor:
2×2 Array{Float64,2}:
  0.961524  0.274721
 -0.274721  0.961524
eigenvalues:
2-element Array{Float64,1}:
  3.0
 -2.0

julia> F.vectors * F.Schur * F.vectors'
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia> t, z, vals = F; # destructuring via iteration

julia> t == F.T && z == F.Z && vals == F.values
true
\end{minted}



\end{adjustwidth}
\hypertarget{6518772096850576950}{} 
\hyperlink{6518772096850576950}{\texttt{LinearAlgebra.GeneralizedSchur}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GeneralizedSchur <: Factorization
\end{minted}

Matrix factorization type of the generalized Schur factorization of two matrices \texttt{A} and \texttt{B}. This is the return type of \hyperlink{17132870828407138368}{\texttt{schur(\_, \_)}}, the corresponding matrix factorization function.

If \texttt{F::GeneralizedSchur} is the factorization object, the (quasi) triangular Schur factors can be obtained via \texttt{F.S} and \texttt{F.T}, the left unitary/orthogonal Schur vectors via \texttt{F.left} or \texttt{F.Q}, and the right unitary/orthogonal Schur vectors can be obtained with \texttt{F.right} or \texttt{F.Z} such that \texttt{A=F.left*F.S*F.right{\textquotesingle}} and \texttt{B=F.left*F.T*F.right{\textquotesingle}}. The generalized eigenvalues of \texttt{A} and \texttt{B} can be obtained with \texttt{F.α./F.β}.

Iterating the decomposition produces the components \texttt{F.S}, \texttt{F.T}, \texttt{F.Q}, \texttt{F.Z}, \texttt{F.α}, and \texttt{F.β}.



\end{adjustwidth}
\hypertarget{17132870828407138368}{} 
\hyperlink{17132870828407138368}{\texttt{LinearAlgebra.schur}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
schur(A::StridedMatrix) -> F::Schur
\end{minted}

Computes the Schur factorization of the matrix \texttt{A}. The (quasi) triangular Schur factor can be obtained from the \texttt{Schur} object \texttt{F} with either \texttt{F.Schur} or \texttt{F.T} and the orthogonal/unitary Schur vectors can be obtained with \texttt{F.vectors} or \texttt{F.Z} such that \texttt{A = F.vectors * F.Schur * F.vectors{\textquotesingle}}. The eigenvalues of \texttt{A} can be obtained with \texttt{F.values}.

Iterating the decomposition produces the components \texttt{F.T}, \texttt{F.Z}, and \texttt{F.values}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [5. 7.; -2. -4.]
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia> F = schur(A)
Schur{Float64,Array{Float64,2}}
T factor:
2×2 Array{Float64,2}:
 3.0   9.0
 0.0  -2.0
Z factor:
2×2 Array{Float64,2}:
  0.961524  0.274721
 -0.274721  0.961524
eigenvalues:
2-element Array{Float64,1}:
  3.0
 -2.0

julia> F.vectors * F.Schur * F.vectors'
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia> t, z, vals = F; # destructuring via iteration

julia> t == F.T && z == F.Z && vals == F.values
true
\end{minted}




\begin{lstlisting}
schur(A::StridedMatrix, B::StridedMatrix) -> F::GeneralizedSchur
\end{lstlisting}

Computes the Generalized Schur (or QZ) factorization of the matrices \texttt{A} and \texttt{B}. The (quasi) triangular Schur factors can be obtained from the \texttt{Schur} object \texttt{F} with \texttt{F.S} and \texttt{F.T}, the left unitary/orthogonal Schur vectors can be obtained with \texttt{F.left} or \texttt{F.Q} and the right unitary/orthogonal Schur vectors can be obtained with \texttt{F.right} or \texttt{F.Z} such that \texttt{A=F.left*F.S*F.right{\textquotesingle}} and \texttt{B=F.left*F.T*F.right{\textquotesingle}}. The generalized eigenvalues of \texttt{A} and \texttt{B} can be obtained with \texttt{F.α./F.β}.

Iterating the decomposition produces the components \texttt{F.S}, \texttt{F.T}, \texttt{F.Q}, \texttt{F.Z}, \texttt{F.α}, and \texttt{F.β}.



\end{adjustwidth}
\hypertarget{17231330544698367907}{} 
\hyperlink{17231330544698367907}{\texttt{LinearAlgebra.schur!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
schur!(A::StridedMatrix) -> F::Schur
\end{minted}

Same as \hyperlink{17132870828407138368}{\texttt{schur}} but uses the input argument \texttt{A} as workspace.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [5. 7.; -2. -4.]
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia> F = schur!(A)
Schur{Float64,Array{Float64,2}}
T factor:
2×2 Array{Float64,2}:
 3.0   9.0
 0.0  -2.0
Z factor:
2×2 Array{Float64,2}:
  0.961524  0.274721
 -0.274721  0.961524
eigenvalues:
2-element Array{Float64,1}:
  3.0
 -2.0

julia> A
2×2 Array{Float64,2}:
 3.0   9.0
 0.0  -2.0
\end{minted}




\begin{lstlisting}
schur!(A::StridedMatrix, B::StridedMatrix) -> F::GeneralizedSchur
\end{lstlisting}

Same as \hyperlink{17132870828407138368}{\texttt{schur}} but uses the input matrices \texttt{A} and \texttt{B} as workspace.



\end{adjustwidth}
\hypertarget{4329711108255537481}{} 
\hyperlink{4329711108255537481}{\texttt{LinearAlgebra.ordschur}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ordschur(F::Schur, select::Union{Vector{Bool},BitVector}) -> F::Schur
\end{minted}

Reorders the Schur factorization \texttt{F} of a matrix \texttt{A = Z*T*Z{\textquotesingle}} according to the logical array \texttt{select} returning the reordered factorization \texttt{F} object. The selected eigenvalues appear in the leading diagonal of \texttt{F.Schur} and the corresponding leading columns of \texttt{F.vectors} form an orthogonal/unitary basis of the corresponding right invariant subspace. In the real case, a complex conjugate pair of eigenvalues must be either both included or both excluded via \texttt{select}.




\begin{lstlisting}
ordschur(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -> F::GeneralizedSchur
\end{lstlisting}

Reorders the Generalized Schur factorization \texttt{F} of a matrix pair \texttt{(A, B) = (Q*S*Z{\textquotesingle}, Q*T*Z{\textquotesingle})} according to the logical array \texttt{select} and returns a GeneralizedSchur object \texttt{F}. The selected eigenvalues appear in the leading diagonal of both \texttt{F.S} and \texttt{F.T}, and the left and right orthogonal/unitary Schur vectors are also reordered such that \texttt{(A, B) = F.Q*(F.S, F.T)*F.Z{\textquotesingle}} still holds and the generalized eigenvalues of \texttt{A} and \texttt{B} can still be obtained with \texttt{F.α./F.β}.



\end{adjustwidth}
\hypertarget{871218922691469554}{} 
\hyperlink{871218922691469554}{\texttt{LinearAlgebra.ordschur!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ordschur!(F::Schur, select::Union{Vector{Bool},BitVector}) -> F::Schur
\end{minted}

Same as \hyperlink{4329711108255537481}{\texttt{ordschur}} but overwrites the factorization \texttt{F}.




\begin{lstlisting}
ordschur!(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -> F::GeneralizedSchur
\end{lstlisting}

Same as \texttt{ordschur} but overwrites the factorization \texttt{F}.



\end{adjustwidth}
\hypertarget{10448068302163375703}{} 
\hyperlink{10448068302163375703}{\texttt{LinearAlgebra.SVD}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SVD <: Factorization
\end{minted}

Matrix factorization type of the singular value decomposition (SVD) of a matrix \texttt{A}. This is the return type of \hyperlink{6661056220970412040}{\texttt{svd(\_)}}, the corresponding matrix factorization function.

If \texttt{F::SVD} is the factorization object, \texttt{U}, \texttt{S}, \texttt{V} and \texttt{Vt} can be obtained via \texttt{F.U}, \texttt{F.S}, \texttt{F.V} and \texttt{F.Vt}, such that \texttt{A = U * Diagonal(S) * Vt}. The singular values in \texttt{S} are sorted in descending order.

Iterating the decomposition produces the components \texttt{U}, \texttt{S}, and \texttt{V}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia> F = svd(A)
SVD{Float64,Float64,Array{Float64,2}}
U factor:
4×4 Array{Float64,2}:
 0.0  1.0  0.0   0.0
 1.0  0.0  0.0   0.0
 0.0  0.0  0.0  -1.0
 0.0  0.0  1.0   0.0
singular values:
4-element Array{Float64,1}:
 3.0
 2.23606797749979
 2.0
 0.0
Vt factor:
4×5 Array{Float64,2}:
 -0.0       0.0  1.0  -0.0  0.0
  0.447214  0.0  0.0   0.0  0.894427
 -0.0       1.0  0.0  -0.0  0.0
  0.0       0.0  0.0   1.0  0.0

julia> F.U * Diagonal(F.S) * F.Vt
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia> u, s, v = F; # destructuring via iteration

julia> u == F.U && s == F.S && v == F.V
true
\end{minted}



\end{adjustwidth}
\hypertarget{16156328526785145806}{} 
\hyperlink{16156328526785145806}{\texttt{LinearAlgebra.GeneralizedSVD}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GeneralizedSVD <: Factorization
\end{minted}

Matrix factorization type of the generalized singular value decomposition (SVD) of two matrices \texttt{A} and \texttt{B}, such that \texttt{A = F.U*F.D1*F.R0*F.Q{\textquotesingle}} and \texttt{B = F.V*F.D2*F.R0*F.Q{\textquotesingle}}. This is the return type of \hyperlink{6661056220970412040}{\texttt{svd(\_, \_)}}, the corresponding matrix factorization function.

For an M-by-N matrix \texttt{A} and P-by-N matrix \texttt{B},

\begin{itemize}
\item \texttt{U} is a M-by-M orthogonal matrix,


\item \texttt{V} is a P-by-P orthogonal matrix,


\item \texttt{Q} is a N-by-N orthogonal matrix,


\item \texttt{D1} is a M-by-(K+L) diagonal matrix with 1s in the first K entries,


\item \texttt{D2} is a P-by-(K+L) matrix whose top right L-by-L block is diagonal,


\item \texttt{R0} is a (K+L)-by-N matrix whose rightmost (K+L)-by-(K+L) block is          nonsingular upper block triangular,

\end{itemize}
\texttt{K+L} is the effective numerical rank of the matrix \texttt{[A; B]}.

Iterating the decomposition produces the components \texttt{U}, \texttt{V}, \texttt{Q}, \texttt{D1}, \texttt{D2}, and \texttt{R0}.

The entries of \texttt{F.D1} and \texttt{F.D2} are related, as explained in the LAPACK documentation for the \href{http://www.netlib.org/lapack/lug/node36.html}{generalized SVD} and the \href{http://www.netlib.org/lapack/explore-html/d6/db3/dggsvd3\_8f.html}{xGGSVD3} routine which is called underneath (in LAPACK 3.6.0 and newer).

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1. 0.; 0. -1.]
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia> B = [0. 1.; 1. 0.]
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia> F = svd(A, B)
GeneralizedSVD{Float64,Array{Float64,2}}
U factor:
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0
V factor:
2×2 Array{Float64,2}:
 -0.0  -1.0
  1.0   0.0
Q factor:
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0
D1 factor:
2×2 SparseArrays.SparseMatrixCSC{Float64,Int64} with 2 stored entries:
  [1, 1]  =  0.707107
  [2, 2]  =  0.707107
D2 factor:
2×2 SparseArrays.SparseMatrixCSC{Float64,Int64} with 2 stored entries:
  [1, 1]  =  0.707107
  [2, 2]  =  0.707107
R0 factor:
2×2 Array{Float64,2}:
 1.41421   0.0
 0.0      -1.41421

julia> F.U*F.D1*F.R0*F.Q'
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia> F.V*F.D2*F.R0*F.Q'
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0
\end{minted}



\end{adjustwidth}
\hypertarget{6661056220970412040}{} 
\hyperlink{6661056220970412040}{\texttt{LinearAlgebra.svd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
svd(A; full::Bool = false, alg::Algorithm = default_svd_alg(A)) -> SVD
\end{minted}

Compute the singular value decomposition (SVD) of \texttt{A} and return an \texttt{SVD} object.

\texttt{U}, \texttt{S}, \texttt{V} and \texttt{Vt} can be obtained from the factorization \texttt{F} with \texttt{F.U}, \texttt{F.S}, \texttt{F.V} and \texttt{F.Vt}, such that \texttt{A = U * Diagonal(S) * Vt}. The algorithm produces \texttt{Vt} and hence \texttt{Vt} is more efficient to extract than \texttt{V}. The singular values in \texttt{S} are sorted in descending order.

Iterating the decomposition produces the components \texttt{U}, \texttt{S}, and \texttt{V}.

If \texttt{full = false} (default), a {\textquotedbl}thin{\textquotedbl} SVD is returned. For a  \(M \times N\)  matrix \texttt{A}, in the full factorization \texttt{U} is \texttt{M {\textbackslash}times M} and \texttt{V} is \texttt{N {\textbackslash}times N}, while in the thin factorization \texttt{U} is \texttt{M {\textbackslash}times K} and \texttt{V} is \texttt{N {\textbackslash}times K}, where \texttt{K = {\textbackslash}min(M,N)} is the number of singular values.

If \texttt{alg = DivideAndConquer()} a divide-and-conquer algorithm is used to calculate the SVD. Another (typically slower but more accurate) option is \texttt{alg = QRIteration()}.

\begin{quote}
\textbf{Julia 1.3}

The \texttt{alg} keyword argument requires Julia 1.3 or later.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = rand(4,3);

julia> F = svd(A); # Store the Factorization Object

julia> A ≈ F.U * Diagonal(F.S) * F.Vt
true

julia> U, S, V = F; # destructuring via iteration

julia> A ≈ U * Diagonal(S) * V'
true

julia> Uonly, = svd(A); # Store U only

julia> Uonly == U
true
\end{minted}




\begin{lstlisting}
svd(A, B) -> GeneralizedSVD
\end{lstlisting}

Compute the generalized SVD of \texttt{A} and \texttt{B}, returning a \texttt{GeneralizedSVD} factorization object \texttt{F} such that \texttt{[A;B] = [F.U * F.D1; F.V * F.D2] * F.R0 * F.Q{\textquotesingle}}

\begin{itemize}
\item \texttt{U} is a M-by-M orthogonal matrix,


\item \texttt{V} is a P-by-P orthogonal matrix,


\item \texttt{Q} is a N-by-N orthogonal matrix,


\item \texttt{D1} is a M-by-(K+L) diagonal matrix with 1s in the first K entries,


\item \texttt{D2} is a P-by-(K+L) matrix whose top right L-by-L block is diagonal,


\item \texttt{R0} is a (K+L)-by-N matrix whose rightmost (K+L)-by-(K+L) block is          nonsingular upper block triangular,

\end{itemize}
\texttt{K+L} is the effective numerical rank of the matrix \texttt{[A; B]}.

Iterating the decomposition produces the components \texttt{U}, \texttt{V}, \texttt{Q}, \texttt{D1}, \texttt{D2}, and \texttt{R0}.

The generalized SVD is used in applications such as when one wants to compare how much belongs to \texttt{A} vs. how much belongs to \texttt{B}, as in human vs yeast genome, or signal vs noise, or between clusters vs within clusters. (See Edelman and Wang for discussion: https://arxiv.org/abs/1901.00485)

It decomposes \texttt{[A; B]} into \texttt{[UC; VS]H}, where \texttt{[UC; VS]} is a natural orthogonal basis for the column space of \texttt{[A; B]}, and \texttt{H = RQ{\textquotesingle}} is a natural non-orthogonal basis for the rowspace of \texttt{[A;B]}, where the top rows are most closely attributed to the \texttt{A} matrix, and the bottom to the \texttt{B} matrix. The multi-cosine/sine matrices \texttt{C} and \texttt{S} provide a multi-measure of how much \texttt{A} vs how much \texttt{B}, and \texttt{U} and \texttt{V} provide directions in which these are measured.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = randn(3,2); B=randn(4,2);

julia> F = svd(A, B);

julia> U,V,Q,C,S,R = F;

julia> H = R*Q';

julia> [A; B] ≈ [U*C; V*S]*H
true

julia> [A; B] ≈ [F.U*F.D1; F.V*F.D2]*F.R0*F.Q'
true

julia> Uonly, = svd(A,B);

julia> U == Uonly
true
\end{minted}



\end{adjustwidth}
\hypertarget{7585497127906495351}{} 
\hyperlink{7585497127906495351}{\texttt{LinearAlgebra.svd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
svd!(A; full::Bool = false, alg::Algorithm = default_svd_alg(A)) -> SVD
\end{minted}

\texttt{svd!} is the same as \hyperlink{6661056220970412040}{\texttt{svd}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. See documentation of \hyperlink{6661056220970412040}{\texttt{svd}} for details. ```




\begin{lstlisting}
svd!(A, B) -> GeneralizedSVD
\end{lstlisting}

\texttt{svd!} is the same as \hyperlink{6661056220970412040}{\texttt{svd}}, but modifies the arguments \texttt{A} and \texttt{B} in-place, instead of making copies. See documentation of \hyperlink{6661056220970412040}{\texttt{svd}} for details. ```



\end{adjustwidth}
\hypertarget{12905968661134086149}{} 
\hyperlink{12905968661134086149}{\texttt{LinearAlgebra.svdvals}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
svdvals(A)
\end{minted}

Return the singular values of \texttt{A} in descending order.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia> svdvals(A)
4-element Array{Float64,1}:
 3.0
 2.23606797749979
 2.0
 0.0
\end{minted}




\begin{lstlisting}
svdvals(A, B)
\end{lstlisting}

Return the generalized singular values from the generalized singular value decomposition of \texttt{A} and \texttt{B}. See also \hyperlink{6661056220970412040}{\texttt{svd}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1. 0.; 0. -1.]
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia> B = [0. 1.; 1. 0.]
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia> svdvals(A, B)
2-element Array{Float64,1}:
 1.0
 1.0
\end{minted}



\end{adjustwidth}
\hypertarget{590278903094160607}{} 
\hyperlink{590278903094160607}{\texttt{LinearAlgebra.svdvals!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
svdvals!(A)
\end{minted}

Return the singular values of \texttt{A}, saving space by overwriting the input. See also \hyperlink{12905968661134086149}{\texttt{svdvals}} and \hyperlink{6661056220970412040}{\texttt{svd}}. ```




\begin{lstlisting}
svdvals!(A, B)
\end{lstlisting}

Return the generalized singular values from the generalized singular value decomposition of \texttt{A} and \texttt{B}, saving space by overwriting \texttt{A} and \texttt{B}. See also \hyperlink{6661056220970412040}{\texttt{svd}} and \hyperlink{12905968661134086149}{\texttt{svdvals}}. ```



\end{adjustwidth}
\hypertarget{7608839947605749416}{} 
\hyperlink{7608839947605749416}{\texttt{LinearAlgebra.Givens}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LinearAlgebra.Givens(i1,i2,c,s) -> G
\end{minted}

A Givens rotation linear operator. The fields \texttt{c} and \texttt{s} represent the cosine and sine of the rotation angle, respectively. The \texttt{Givens} type supports left multiplication \texttt{G*A} and conjugated transpose right multiplication \texttt{A*G{\textquotesingle}}. The type doesn{\textquotesingle}t have a \texttt{size} and can therefore be multiplied with matrices of arbitrary size as long as \texttt{i2<=size(A,2)} for \texttt{G*A} or \texttt{i2<=size(A,1)} for \texttt{A*G{\textquotesingle}}.

See also: \hyperlink{16453376059429157444}{\texttt{givens}}



\end{adjustwidth}
\hypertarget{16453376059429157444}{} 
\hyperlink{16453376059429157444}{\texttt{LinearAlgebra.givens}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
givens(f::T, g::T, i1::Integer, i2::Integer) where {T} -> (G::Givens, r::T)
\end{minted}

Computes the Givens rotation \texttt{G} and scalar \texttt{r} such that for any vector \texttt{x} where


\begin{lstlisting}
x[i1] = f
x[i2] = g
\end{lstlisting}

the result of the multiplication


\begin{lstlisting}
y = G*x
\end{lstlisting}

has the property that


\begin{lstlisting}
y[i1] = r
y[i2] = 0
\end{lstlisting}

See also: \hyperlink{7608839947605749416}{\texttt{LinearAlgebra.Givens}}




\begin{lstlisting}
givens(A::AbstractArray, i1::Integer, i2::Integer, j::Integer) -> (G::Givens, r)
\end{lstlisting}

Computes the Givens rotation \texttt{G} and scalar \texttt{r} such that the result of the multiplication


\begin{lstlisting}
B = G*A
\end{lstlisting}

has the property that


\begin{lstlisting}
B[i1,j] = r
B[i2,j] = 0
\end{lstlisting}

See also: \hyperlink{7608839947605749416}{\texttt{LinearAlgebra.Givens}}




\begin{lstlisting}
givens(x::AbstractVector, i1::Integer, i2::Integer) -> (G::Givens, r)
\end{lstlisting}

Computes the Givens rotation \texttt{G} and scalar \texttt{r} such that the result of the multiplication


\begin{lstlisting}
B = G*x
\end{lstlisting}

has the property that


\begin{lstlisting}
B[i1] = r
B[i2] = 0
\end{lstlisting}

See also: \hyperlink{7608839947605749416}{\texttt{LinearAlgebra.Givens}}



\end{adjustwidth}
\hypertarget{13861148483706203681}{} 
\hyperlink{13861148483706203681}{\texttt{LinearAlgebra.triu}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
triu(M)
\end{minted}

Upper triangle of a matrix.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = fill(1.0, (4,4))
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia> triu(a)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 0.0  1.0  1.0  1.0
 0.0  0.0  1.0  1.0
 0.0  0.0  0.0  1.0
\end{minted}




\begin{lstlisting}
triu(M, k::Integer)
\end{lstlisting}

Returns the upper triangle of \texttt{M} starting from the \texttt{k}th superdiagonal.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = fill(1.0, (4,4))
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia> triu(a,3)
4×4 Array{Float64,2}:
 0.0  0.0  0.0  1.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0

julia> triu(a,-3)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
\end{minted}



\end{adjustwidth}
\hypertarget{17824694935904725032}{} 
\hyperlink{17824694935904725032}{\texttt{LinearAlgebra.triu!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
triu!(M)
\end{minted}

Upper triangle of a matrix, overwriting \texttt{M} in the process. See also \hyperlink{13861148483706203681}{\texttt{triu}}.




\begin{lstlisting}
triu!(M, k::Integer)
\end{lstlisting}

Return the upper triangle of \texttt{M} starting from the \texttt{k}th superdiagonal, overwriting \texttt{M} in the process.

\textbf{Examples}


\begin{minted}{jlcon}
julia> M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]
5×5 Array{Int64,2}:
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5

julia> triu!(M, 1)
5×5 Array{Int64,2}:
 0  2  3  4  5
 0  0  3  4  5
 0  0  0  4  5
 0  0  0  0  5
 0  0  0  0  0
\end{minted}



\end{adjustwidth}
\hypertarget{6919124555890239966}{} 
\hyperlink{6919124555890239966}{\texttt{LinearAlgebra.tril}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tril(M)
\end{minted}

Lower triangle of a matrix.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = fill(1.0, (4,4))
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia> tril(a)
4×4 Array{Float64,2}:
 1.0  0.0  0.0  0.0
 1.0  1.0  0.0  0.0
 1.0  1.0  1.0  0.0
 1.0  1.0  1.0  1.0
\end{minted}




\begin{lstlisting}
tril(M, k::Integer)
\end{lstlisting}

Returns the lower triangle of \texttt{M} starting from the \texttt{k}th superdiagonal.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = fill(1.0, (4,4))
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia> tril(a,3)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia> tril(a,-3)
4×4 Array{Float64,2}:
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 1.0  0.0  0.0  0.0
\end{minted}



\end{adjustwidth}
\hypertarget{579033117422555588}{} 
\hyperlink{579033117422555588}{\texttt{LinearAlgebra.tril!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tril!(M)
\end{minted}

Lower triangle of a matrix, overwriting \texttt{M} in the process. See also \hyperlink{6919124555890239966}{\texttt{tril}}.




\begin{lstlisting}
tril!(M, k::Integer)
\end{lstlisting}

Return the lower triangle of \texttt{M} starting from the \texttt{k}th superdiagonal, overwriting \texttt{M} in the process.

\textbf{Examples}


\begin{minted}{jlcon}
julia> M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]
5×5 Array{Int64,2}:
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5

julia> tril!(M, 2)
5×5 Array{Int64,2}:
 1  2  3  0  0
 1  2  3  4  0
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
\end{minted}



\end{adjustwidth}
\hypertarget{16168870718733561340}{} 
\hyperlink{16168870718733561340}{\texttt{LinearAlgebra.diagind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
diagind(M, k::Integer=0)
\end{minted}

An \texttt{AbstractRange} giving the indices of the \texttt{k}th diagonal of the matrix \texttt{M}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia> diagind(A,-1)
2:4:6
\end{minted}



\end{adjustwidth}
\hypertarget{17079356950356685026}{} 
\hyperlink{17079356950356685026}{\texttt{LinearAlgebra.diag}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
diag(M, k::Integer=0)
\end{minted}

The \texttt{k}th diagonal of a matrix, as a vector.

See also: \hyperlink{18133091318829836689}{\texttt{diagm}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia> diag(A,1)
2-element Array{Int64,1}:
 2
 6
\end{minted}



\end{adjustwidth}
\hypertarget{18133091318829836689}{} 
\hyperlink{18133091318829836689}{\texttt{LinearAlgebra.diagm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
diagm(kv::Pair{<:Integer,<:AbstractVector}...)
diagm(m::Integer, n::Integer, kv::Pair{<:Integer,<:AbstractVector}...)
\end{minted}

Construct a matrix from \texttt{Pair}s of diagonals and vectors. Vector \texttt{kv.second} will be placed on the \texttt{kv.first} diagonal. By default the matrix is square and its size is inferred from \texttt{kv}, but a non-square size \texttt{m}×\texttt{n} (padded with zeros as needed) can be specified by passing \texttt{m,n} as the first arguments.

\texttt{diagm} constructs a full matrix; if you want storage-efficient versions with fast arithmetic, see \hyperlink{3300114559258360989}{\texttt{Diagonal}}, \hyperlink{6156150905679680892}{\texttt{Bidiagonal}} \hyperlink{17820886359515748171}{\texttt{Tridiagonal}} and \hyperlink{6062797780727203318}{\texttt{SymTridiagonal}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> diagm(1 => [1,2,3])
4×4 Array{Int64,2}:
 0  1  0  0
 0  0  2  0
 0  0  0  3
 0  0  0  0

julia> diagm(1 => [1,2,3], -1 => [4,5])
4×4 Array{Int64,2}:
 0  1  0  0
 4  0  2  0
 0  5  0  3
 0  0  0  0
\end{minted}




\begin{lstlisting}
diagm(v::AbstractVector)
diagm(m::Integer, n::Integer, v::AbstractVector)
\end{lstlisting}

Construct a matrix with elements of the vector as diagonal elements. By default (if \texttt{size=nothing}), the matrix is square and its size is given by \texttt{length(v)}, but a non-square size \texttt{m}×\texttt{n} can be specified by passing \texttt{m,n} as the first arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> diagm([1,2,3])
3×3 Array{Int64,2}:
 1  0  0
 0  2  0
 0  0  3
\end{minted}



\end{adjustwidth}
\hypertarget{439390458422397873}{} 
\hyperlink{439390458422397873}{\texttt{LinearAlgebra.rank}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rank(A::AbstractMatrix; atol::Real=0, rtol::Real=atol>0 ? 0 : n*ϵ)
rank(A::AbstractMatrix, rtol::Real)
\end{minted}

Compute the rank of a matrix by counting how many singular values of \texttt{A} have magnitude greater than \texttt{max(atol, rtol*σ₁)} where \texttt{σ₁} is \texttt{A}{\textquotesingle}s largest singular value. \texttt{atol} and \texttt{rtol} are the absolute and relative tolerances, respectively. The default relative tolerance is \texttt{n*ϵ}, where \texttt{n} is the size of the smallest dimension of \texttt{A}, and \texttt{ϵ} is the \hyperlink{4594213520310841636}{\texttt{eps}} of the element type of \texttt{A}.

\begin{quote}
\textbf{Julia 1.1}

The \texttt{atol} and \texttt{rtol} keyword arguments requires at least Julia 1.1. In Julia 1.0 \texttt{rtol} is available as a positional argument, but this will be deprecated in Julia 2.0.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> rank(Matrix(I, 3, 3))
3

julia> rank(diagm(0 => [1, 0, 2]))
2

julia> rank(diagm(0 => [1, 0.001, 2]), rtol=0.1)
2

julia> rank(diagm(0 => [1, 0.001, 2]), rtol=0.00001)
3

julia> rank(diagm(0 => [1, 0.001, 2]), atol=1.5)
1
\end{minted}



\end{adjustwidth}
\hypertarget{898926013064269707}{} 
\hyperlink{898926013064269707}{\texttt{LinearAlgebra.norm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
norm(A, p::Real=2)
\end{minted}

For any iterable container \texttt{A} (including arrays of any dimension) of numbers (or any element type for which \texttt{norm} is defined), compute the \texttt{p}-norm (defaulting to \texttt{p=2}) as if \texttt{A} were a vector of the corresponding length.

The \texttt{p}-norm is defined as

\begin{equation*}
\begin{split}\|A\|_p = \left( \sum_{i=1}^n | a_i | ^p \right)^{1/p}\end{split}\end{equation*}
with  \(a_i\)  the entries of  \(A\) ,  \(| a_i |\)  the \hyperlink{898926013064269707}{\texttt{norm}} of  \(a_i\) , and  \(n\)  the length of  \(A\) . Since the \texttt{p}-norm is computed using the \hyperlink{898926013064269707}{\texttt{norm}}s of the entries of \texttt{A}, the \texttt{p}-norm of a vector of vectors is not compatible with the interpretation of it as a block vector in general if \texttt{p != 2}.

\texttt{p} can assume any numeric value (even though not all values produce a mathematically valid vector norm). In particular, \texttt{norm(A, Inf)} returns the largest value in \texttt{abs.(A)}, whereas \texttt{norm(A, -Inf)} returns the smallest. If \texttt{A} is a matrix and \texttt{p=2}, then this is equivalent to the Frobenius norm.

The second argument \texttt{p} is not necessarily a part of the interface for \texttt{norm}, i.e. a custom type may only implement \texttt{norm(A)} without second argument.

Use \hyperlink{4740175223212326101}{\texttt{opnorm}} to compute the operator norm of a matrix.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [3, -2, 6]
3-element Array{Int64,1}:
  3
 -2
  6

julia> norm(v)
7.0

julia> norm(v, 1)
11.0

julia> norm(v, Inf)
6.0

julia> norm([1 2 3; 4 5 6; 7 8 9])
16.881943016134134

julia> norm([1 2 3 4 5 6 7 8 9])
16.881943016134134

julia> norm(1:9)
16.881943016134134

julia> norm(hcat(v,v), 1) == norm(vcat(v,v), 1) != norm([v,v], 1)
true

julia> norm(hcat(v,v), 2) == norm(vcat(v,v), 2) == norm([v,v], 2)
true

julia> norm(hcat(v,v), Inf) == norm(vcat(v,v), Inf) != norm([v,v], Inf)
true
\end{minted}




\begin{lstlisting}
norm(x::Number, p::Real=2)
\end{lstlisting}

For numbers, return  \(\left( |x|^p \right)^{1/p}\) .

\textbf{Examples}


\begin{minted}{jlcon}
julia> norm(2, 1)
2.0

julia> norm(-2, 1)
2.0

julia> norm(2, 2)
2.0

julia> norm(-2, 2)
2.0

julia> norm(2, Inf)
2.0

julia> norm(-2, Inf)
2.0
\end{minted}



\end{adjustwidth}
\hypertarget{4740175223212326101}{} 
\hyperlink{4740175223212326101}{\texttt{LinearAlgebra.opnorm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
opnorm(A::AbstractMatrix, p::Real=2)
\end{minted}

Compute the operator norm (or matrix norm) induced by the vector \texttt{p}-norm, where valid values of \texttt{p} are \texttt{1}, \texttt{2}, or \texttt{Inf}. (Note that for sparse matrices, \texttt{p=2} is currently not implemented.) Use \hyperlink{898926013064269707}{\texttt{norm}} to compute the Frobenius norm.

When \texttt{p=1}, the operator norm is the maximum absolute column sum of \texttt{A}:

\begin{equation*}
\begin{split}\|A\|_1 = \max_{1 ≤ j ≤ n} \sum_{i=1}^m | a_{ij} |\end{split}\end{equation*}
with  \(a_{ij}\)  the entries of  \(A\) , and  \(m\)  and  \(n\)  its dimensions.

When \texttt{p=2}, the operator norm is the spectral norm, equal to the largest singular value of \texttt{A}.

When \texttt{p=Inf}, the operator norm is the maximum absolute row sum of \texttt{A}:

\begin{equation*}
\begin{split}\|A\|_\infty = \max_{1 ≤ i ≤ m} \sum _{j=1}^n | a_{ij} |\end{split}\end{equation*}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 -2 -3; 2 3 -1]
2×3 Array{Int64,2}:
 1  -2  -3
 2   3  -1

julia> opnorm(A, Inf)
6.0

julia> opnorm(A, 1)
5.0
\end{minted}




\begin{lstlisting}
opnorm(x::Number, p::Real=2)
\end{lstlisting}

For numbers, return  \(\left( |x|^p \right)^{1/p}\) . This is equivalent to \hyperlink{898926013064269707}{\texttt{norm}}.




\begin{lstlisting}
opnorm(A::Adjoint{<:Any,<:AbstracVector}, q::Real=2)
opnorm(A::Transpose{<:Any,<:AbstracVector}, q::Real=2)
\end{lstlisting}

For Adjoint/Transpose-wrapped vectors, return the operator  \(q\) -norm of \texttt{A}, which is equivalent to the \texttt{p}-norm with value \texttt{p = q/(q-1)}. They coincide at \texttt{p = q = 2}. Use \hyperlink{898926013064269707}{\texttt{norm}} to compute the \texttt{p} norm of \texttt{A} as a vector.

The difference in norm between a vector space and its dual arises to preserve the relationship between duality and the dot product, and the result is consistent with the operator \texttt{p}-norm of a \texttt{1 × n} matrix.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [1; im];

julia> vc = v';

julia> opnorm(vc, 1)
1.0

julia> norm(vc, 1)
2.0

julia> norm(v, 1)
2.0

julia> opnorm(vc, 2)
1.4142135623730951

julia> norm(vc, 2)
1.4142135623730951

julia> norm(v, 2)
1.4142135623730951

julia> opnorm(vc, Inf)
2.0

julia> norm(vc, Inf)
1.0

julia> norm(v, Inf)
1.0
\end{minted}



\end{adjustwidth}
\hypertarget{7806117778219468080}{} 
\hyperlink{7806117778219468080}{\texttt{LinearAlgebra.normalize!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
normalize!(v::AbstractVector, p::Real=2)
\end{minted}

Normalize the vector \texttt{v} in-place so that its \texttt{p}-norm equals unity, i.e. \texttt{norm(v, p) == 1}. See also \hyperlink{10731692832589480792}{\texttt{normalize}} and \hyperlink{898926013064269707}{\texttt{norm}}.



\end{adjustwidth}
\hypertarget{10731692832589480792}{} 
\hyperlink{10731692832589480792}{\texttt{LinearAlgebra.normalize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
normalize(v::AbstractVector, p::Real=2)
\end{minted}

Normalize the vector \texttt{v} so that its \texttt{p}-norm equals unity, i.e. \texttt{norm(v, p) == 1}. See also \hyperlink{7806117778219468080}{\texttt{normalize!}} and \hyperlink{898926013064269707}{\texttt{norm}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1,2,4];

julia> b = normalize(a)
3-element Array{Float64,1}:
 0.2182178902359924
 0.4364357804719848
 0.8728715609439696

julia> norm(b)
1.0

julia> c = normalize(a, 1)
3-element Array{Float64,1}:
 0.14285714285714285
 0.2857142857142857
 0.5714285714285714

julia> norm(c, 1)
1.0
\end{minted}



\end{adjustwidth}
\hypertarget{875685967830602736}{} 
\hyperlink{875685967830602736}{\texttt{LinearAlgebra.cond}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cond(M, p::Real=2)
\end{minted}

Condition number of the matrix \texttt{M}, computed using the operator \texttt{p}-norm. Valid values for \texttt{p} are \texttt{1}, \texttt{2} (default), or \texttt{Inf}.



\end{adjustwidth}
\hypertarget{11563712892597655531}{} 
\hyperlink{11563712892597655531}{\texttt{LinearAlgebra.condskeel}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
condskeel(M, [x, p::Real=Inf])
\end{minted}

\begin{equation*}
\begin{split}\kappa_S(M, p) = \left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert \right\Vert_p \\
\kappa_S(M, x, p) = \left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert \left\vert x \right\vert \right\Vert_p\end{split}\end{equation*}
Skeel condition number  \(\kappa_S\)  of the matrix \texttt{M}, optionally with respect to the vector \texttt{x}, as computed using the operator \texttt{p}-norm.  \(\left\vert M \right\vert\)  denotes the matrix of (entry wise) absolute values of  \(M\) ;  \(\left\vert M \right\vert_{ij} = \left\vert M_{ij} \right\vert\) . Valid values for \texttt{p} are \texttt{1}, \texttt{2} and \texttt{Inf} (default).

This quantity is also known in the literature as the Bauer condition number, relative condition number, or componentwise relative condition number.



\end{adjustwidth}
\hypertarget{3355659645971312171}{} 
\hyperlink{3355659645971312171}{\texttt{LinearAlgebra.tr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tr(M)
\end{minted}

Matrix trace. Sums the diagonal elements of \texttt{M}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> tr(A)
5
\end{minted}



\end{adjustwidth}
\hypertarget{16543378577000914469}{} 
\hyperlink{16543378577000914469}{\texttt{LinearAlgebra.det}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
det(M)
\end{minted}

Matrix determinant.

\textbf{Examples}


\begin{minted}{jlcon}
julia> M = [1 0; 2 2]
2×2 Array{Int64,2}:
 1  0
 2  2

julia> det(M)
2.0
\end{minted}



\end{adjustwidth}
\hypertarget{12765142073947245963}{} 
\hyperlink{12765142073947245963}{\texttt{LinearAlgebra.logdet}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
logdet(M)
\end{minted}

Log of matrix determinant. Equivalent to \texttt{log(det(M))}, but may provide increased accuracy and/or speed.

\textbf{Examples}


\begin{minted}{jlcon}
julia> M = [1 0; 2 2]
2×2 Array{Int64,2}:
 1  0
 2  2

julia> logdet(M)
0.6931471805599453

julia> logdet(Matrix(I, 3, 3))
0.0
\end{minted}



\end{adjustwidth}
\hypertarget{11067048979448481853}{} 
\hyperlink{11067048979448481853}{\texttt{LinearAlgebra.logabsdet}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
logabsdet(M)
\end{minted}

Log of absolute value of matrix determinant. Equivalent to \texttt{(log(abs(det(M))), sign(det(M)))}, but may provide increased accuracy and/or speed.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [-1. 0.; 0. 1.]
2×2 Array{Float64,2}:
 -1.0  0.0
  0.0  1.0

julia> det(A)
-1.0

julia> logabsdet(A)
(0.0, -1.0)

julia> B = [2. 0.; 0. 1.]
2×2 Array{Float64,2}:
 2.0  0.0
 0.0  1.0

julia> det(B)
2.0

julia> logabsdet(B)
(0.6931471805599453, 1.0)
\end{minted}



\end{adjustwidth}
\hypertarget{3073938155232622368}{} 
\hyperlink{3073938155232622368}{\texttt{Base.inv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
inv(M)
\end{minted}

Matrix inverse. Computes matrix \texttt{N} such that \texttt{M * N = I}, where \texttt{I} is the identity matrix. Computed by solving the left-division \texttt{N = M {\textbackslash} I}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> M = [2 5; 1 3]
2×2 Array{Int64,2}:
 2  5
 1  3

julia> N = inv(M)
2×2 Array{Float64,2}:
  3.0  -5.0
 -1.0   2.0

julia> M*N == N*M == Matrix(I, 2, 2)
true
\end{minted}



\end{adjustwidth}
\hypertarget{15549768004641518126}{} 
\hyperlink{15549768004641518126}{\texttt{LinearAlgebra.pinv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pinv(M; atol::Real=0, rtol::Real=atol>0 ? 0 : n*ϵ)
pinv(M, rtol::Real) = pinv(M; rtol=rtol) # to be deprecated in Julia 2.0
\end{minted}

Computes the Moore-Penrose pseudoinverse.

For matrices \texttt{M} with floating point elements, it is convenient to compute the pseudoinverse by inverting only singular values greater than \texttt{max(atol, rtol*σ₁)} where \texttt{σ₁} is the largest singular value of \texttt{M}.

The optimal choice of absolute (\texttt{atol}) and relative tolerance (\texttt{rtol}) varies both with the value of \texttt{M} and the intended application of the pseudoinverse. The default relative tolerance is \texttt{n*ϵ}, where \texttt{n} is the size of the smallest dimension of \texttt{M}, and \texttt{ϵ} is the \hyperlink{4594213520310841636}{\texttt{eps}} of the element type of \texttt{M}.

For inverting dense ill-conditioned matrices in a least-squares sense, \texttt{rtol = sqrt(eps(real(float(one(eltype(M))))))} is recommended.

For more information, see \footnotemark[4], \footnotemark[5], \footnotemark[6], \footnotemark[7].

\textbf{Examples}


\begin{minted}{jlcon}
julia> M = [1.5 1.3; 1.2 1.9]
2×2 Array{Float64,2}:
 1.5  1.3
 1.2  1.9

julia> N = pinv(M)
2×2 Array{Float64,2}:
  1.47287   -1.00775
 -0.930233   1.16279

julia> M * N
2×2 Array{Float64,2}:
 1.0          -2.22045e-16
 4.44089e-16   1.0
\end{minted}

\footnotetext[4]{Issue 8859, {\textquotedbl}Fix least squares{\textquotedbl}, \href{https://github.com/JuliaLang/julia/pull/8859}{https://github.com/JuliaLang/julia/pull/8859}

}
\footnotetext[5]{Åke Björck, {\textquotedbl}Numerical Methods for Least Squares Problems{\textquotedbl},  SIAM Press, Philadelphia, 1996, {\textquotedbl}Other Titles in Applied Mathematics{\textquotedbl}, Vol. 51. \href{http://epubs.siam.org/doi/book/10.1137/1.9781611971484}{doi:10.1137/1.9781611971484}

}
\footnotetext[6]{G. W. Stewart, {\textquotedbl}Rank Degeneracy{\textquotedbl}, SIAM Journal on Scientific and Statistical Computing, 5(2), 1984, 403-413. \href{http://epubs.siam.org/doi/abs/10.1137/0905030}{doi:10.1137/0905030}

}
\footnotetext[7]{Konstantinos Konstantinides and Kung Yao, {\textquotedbl}Statistical analysis of effective singular values in matrix rank determination{\textquotedbl}, IEEE Transactions on Acoustics, Speech and Signal Processing, 36(5), 1988, 757-763. \href{https://doi.org/10.1109/29.1585}{doi:10.1109/29.1585}

}


\end{adjustwidth}
\hypertarget{13997374044866220350}{} 
\hyperlink{13997374044866220350}{\texttt{LinearAlgebra.nullspace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nullspace(M; atol::Real=0, rtol::Real=atol>0 ? 0 : n*ϵ)
nullspace(M, rtol::Real) = nullspace(M; rtol=rtol) # to be deprecated in Julia 2.0
\end{minted}

Computes a basis for the nullspace of \texttt{M} by including the singular vectors of \texttt{M} whose singular values have magnitudes greater than \texttt{max(atol, rtol*σ₁)}, where \texttt{σ₁} is \texttt{M}{\textquotesingle}s largest singular value.

By default, the relative tolerance \texttt{rtol} is \texttt{n*ϵ}, where \texttt{n} is the size of the smallest dimension of \texttt{M}, and \texttt{ϵ} is the \hyperlink{4594213520310841636}{\texttt{eps}} of the element type of \texttt{M}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> M = [1 0 0; 0 1 0; 0 0 0]
3×3 Array{Int64,2}:
 1  0  0
 0  1  0
 0  0  0

julia> nullspace(M)
3×1 Array{Float64,2}:
 0.0
 0.0
 1.0

julia> nullspace(M, rtol=3)
3×3 Array{Float64,2}:
 0.0  1.0  0.0
 1.0  0.0  0.0
 0.0  0.0  1.0

julia> nullspace(M, atol=0.95)
3×1 Array{Float64,2}:
 0.0
 0.0
 1.0
\end{minted}



\end{adjustwidth}
\hypertarget{14153417388267953812}{} 
\hyperlink{14153417388267953812}{\texttt{Base.kron}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
kron(A, B)
\end{minted}

Kronecker tensor product of two vectors or two matrices.

For vectors v and w, the Kronecker product is related to the outer product by \texttt{kron(v,w) == vec(w*transpose(v))} or \texttt{w*transpose(v) == reshape(kron(v,w), (length(w), length(v)))}. Note how the ordering of \texttt{v} and \texttt{w} differs on the left and right of these expressions (due to column-major storage).

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> B = [im 1; 1 -im]
2×2 Array{Complex{Int64},2}:
 0+1im  1+0im
 1+0im  0-1im

julia> kron(A, B)
4×4 Array{Complex{Int64},2}:
 0+1im  1+0im  0+2im  2+0im
 1+0im  0-1im  2+0im  0-2im
 0+3im  3+0im  0+4im  4+0im
 3+0im  0-3im  4+0im  0-4im

julia> v = [1, 2]; w = [3, 4, 5];

julia> w*transpose(v)
3×2 Array{Int64,2}:
 3   6
 4   8
 5  10

julia> reshape(kron(v,w), (length(w), length(v)))
3×2 Array{Int64,2}:
 3   6
 4   8
 5  10
\end{minted}



\end{adjustwidth}
\hypertarget{18285859961980795328}{} 
\hyperlink{18285859961980795328}{\texttt{Base.exp}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
exp(A::AbstractMatrix)
\end{minted}

Compute the matrix exponential of \texttt{A}, defined by

\begin{equation*}
\begin{split}e^A = \sum_{n=0}^{\infty} \frac{A^n}{n!}.\end{split}\end{equation*}
For symmetric or Hermitian \texttt{A}, an eigendecomposition (\hyperlink{11056016707394839114}{\texttt{eigen}}) is used, otherwise the scaling and squaring algorithm (see \footnotemark[8]) is chosen.

\footnotetext[8]{Nicholas J. Higham, {\textquotedbl}The squaring and scaling method for the matrix exponential revisited{\textquotedbl}, SIAM Journal on Matrix Analysis and Applications, 26(4), 2005, 1179-1193. \href{https://doi.org/10.1137/090768539}{doi:10.1137/090768539}

}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = Matrix(1.0I, 2, 2)
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0

julia> exp(A)
2×2 Array{Float64,2}:
 2.71828  0.0
 0.0      2.71828
\end{minted}



\end{adjustwidth}
\hypertarget{13815303599818670515}{} 
\hyperlink{13815303599818670515}{\texttt{Base.:{\textasciicircum}}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
^(A::AbstractMatrix, p::Number)
\end{minted}

Matrix power, equivalent to  \(\exp(p\log(A))\) 

\textbf{Examples}


\begin{minted}{jlcon}
julia> [1 2; 0 3]^3
2×2 Array{Int64,2}:
 1  26
 0  27
\end{minted}



\end{adjustwidth}
\hypertarget{7435396726429142215}{} 
\hyperlink{7435396726429142215}{\texttt{Base.:{\textasciicircum}}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
^(b::Number, A::AbstractMatrix)
\end{minted}

Matrix exponential, equivalent to  \(\exp(\log(b)A)\) .

\begin{quote}
\textbf{Julia 1.1}

Support for raising \texttt{Irrational} numbers (like \texttt{ℯ}) to a matrix was added in Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> 2^[1 2; 0 3]
2×2 Array{Float64,2}:
 2.0  6.0
 0.0  8.0

julia> ℯ^[1 2; 0 3]
2×2 Array{Float64,2}:
 2.71828  17.3673
 0.0      20.0855
\end{minted}



\end{adjustwidth}
\hypertarget{3808986897558314383}{} 
\hyperlink{3808986897558314383}{\texttt{Base.log}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
log(A{T}::StridedMatrix{T})
\end{minted}

If \texttt{A} has no negative real eigenvalue, compute the principal matrix logarithm of \texttt{A}, i.e. the unique matrix  \(X\)  such that  \(e^X = A\)  and  \(-\pi < Im(\lambda) < \pi\)  for all the eigenvalues  \(\lambda\)  of  \(X\) . If \texttt{A} has nonpositive eigenvalues, a nonprincipal matrix function is returned whenever possible.

If \texttt{A} is symmetric or Hermitian, its eigendecomposition (\hyperlink{11056016707394839114}{\texttt{eigen}}) is used, if \texttt{A} is triangular an improved version of the inverse scaling and squaring method is employed (see \footnotemark[9] and \footnotemark[10]). For general matrices, the complex Schur form (\hyperlink{17132870828407138368}{\texttt{schur}}) is computed and the triangular algorithm is used on the triangular factor.

\footnotetext[9]{Awad H. Al-Mohy and Nicholas J. Higham, {\textquotedbl}Improved inverse  scaling and squaring algorithms for the matrix logarithm{\textquotedbl}, SIAM Journal on Scientific Computing, 34(4), 2012, C153-C169. \href{https://doi.org/10.1137/110852553}{doi:10.1137/110852553}

}
\footnotetext[10]{Awad H. Al-Mohy, Nicholas J. Higham and Samuel D. Relton, {\textquotedbl}Computing the Fréchet derivative of the matrix logarithm and estimating the condition number{\textquotedbl}, SIAM Journal on Scientific Computing, 35(4), 2013, C394-C410. \href{https://doi.org/10.1137/120885991}{doi:10.1137/120885991}

}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = Matrix(2.7182818*I, 2, 2)
2×2 Array{Float64,2}:
 2.71828  0.0
 0.0      2.71828

julia> log(A)
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0
\end{minted}



\end{adjustwidth}
\hypertarget{2764611134083270926}{} 
\hyperlink{2764611134083270926}{\texttt{Base.sqrt}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sqrt(A::AbstractMatrix)
\end{minted}

If \texttt{A} has no negative real eigenvalues, compute the principal matrix square root of \texttt{A}, that is the unique matrix  \(X\)  with eigenvalues having positive real part such that  \(X^2 = A\) . Otherwise, a nonprincipal square root is returned.

If \texttt{A} is symmetric or Hermitian, its eigendecomposition (\hyperlink{11056016707394839114}{\texttt{eigen}}) is used to compute the square root. Otherwise, the square root is determined by means of the Björck-Hammarling method \footnotemark[11], which computes the complex Schur form (\hyperlink{17132870828407138368}{\texttt{schur}}) and then the complex square root of the triangular factor.

\footnotetext[11]{Åke Björck and Sven Hammarling, {\textquotedbl}A Schur method for the square root of a matrix{\textquotedbl}, Linear Algebra and its Applications, 52-53, 1983, 127-140. \href{https://doi.org/10.1016/0024-3795(83)80010-X}{doi:10.1016/0024-3795(83)80010-X}

}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4 0; 0 4]
2×2 Array{Int64,2}:
 4  0
 0  4

julia> sqrt(A)
2×2 Array{Float64,2}:
 2.0  0.0
 0.0  2.0
\end{minted}



\end{adjustwidth}
\hypertarget{11601410820050169124}{} 
\hyperlink{11601410820050169124}{\texttt{Base.cos}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cos(A::AbstractMatrix)
\end{minted}

Compute the matrix cosine of a square matrix \texttt{A}.

If \texttt{A} is symmetric or Hermitian, its eigendecomposition (\hyperlink{11056016707394839114}{\texttt{eigen}}) is used to compute the cosine. Otherwise, the cosine is determined by calling \hyperlink{5801729597955756107}{\texttt{exp}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> cos(fill(1.0, (2,2)))
2×2 Array{Float64,2}:
  0.291927  -0.708073
 -0.708073   0.291927
\end{minted}



\end{adjustwidth}
\hypertarget{14039855138661767630}{} 
\hyperlink{14039855138661767630}{\texttt{Base.sin}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sin(A::AbstractMatrix)
\end{minted}

Compute the matrix sine of a square matrix \texttt{A}.

If \texttt{A} is symmetric or Hermitian, its eigendecomposition (\hyperlink{11056016707394839114}{\texttt{eigen}}) is used to compute the sine. Otherwise, the sine is determined by calling \hyperlink{5801729597955756107}{\texttt{exp}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sin(fill(1.0, (2,2)))
2×2 Array{Float64,2}:
 0.454649  0.454649
 0.454649  0.454649
\end{minted}



\end{adjustwidth}
\hypertarget{10476266945170887002}{} 
\hyperlink{10476266945170887002}{\texttt{Base.Math.sincos}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sincos(A::AbstractMatrix)
\end{minted}

Compute the matrix sine and cosine of a square matrix \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> S, C = sincos(fill(1.0, (2,2)));

julia> S
2×2 Array{Float64,2}:
 0.454649  0.454649
 0.454649  0.454649

julia> C
2×2 Array{Float64,2}:
  0.291927  -0.708073
 -0.708073   0.291927
\end{minted}



\end{adjustwidth}
\hypertarget{16475848931771819970}{} 
\hyperlink{16475848931771819970}{\texttt{Base.tan}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tan(A::AbstractMatrix)
\end{minted}

Compute the matrix tangent of a square matrix \texttt{A}.

If \texttt{A} is symmetric or Hermitian, its eigendecomposition (\hyperlink{11056016707394839114}{\texttt{eigen}}) is used to compute the tangent. Otherwise, the tangent is determined by calling \hyperlink{5801729597955756107}{\texttt{exp}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> tan(fill(1.0, (2,2)))
2×2 Array{Float64,2}:
 -1.09252  -1.09252
 -1.09252  -1.09252
\end{minted}



\end{adjustwidth}
\hypertarget{2627941190173499283}{} 
\hyperlink{2627941190173499283}{\texttt{Base.Math.sec}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sec(A::AbstractMatrix)
\end{minted}

Compute the matrix secant of a square matrix \texttt{A}.



\end{adjustwidth}
\hypertarget{14836994396551644362}{} 
\hyperlink{14836994396551644362}{\texttt{Base.Math.csc}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
csc(A::AbstractMatrix)
\end{minted}

Compute the matrix cosecant of a square matrix \texttt{A}.



\end{adjustwidth}
\hypertarget{3756551817451989074}{} 
\hyperlink{3756551817451989074}{\texttt{Base.Math.cot}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cot(A::AbstractMatrix)
\end{minted}

Compute the matrix cotangent of a square matrix \texttt{A}.



\end{adjustwidth}
\hypertarget{3831542837693533832}{} 
\hyperlink{3831542837693533832}{\texttt{Base.cosh}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cosh(A::AbstractMatrix)
\end{minted}

Compute the matrix hyperbolic cosine of a square matrix \texttt{A}.



\end{adjustwidth}
\hypertarget{10621922578961083459}{} 
\hyperlink{10621922578961083459}{\texttt{Base.sinh}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sinh(A::AbstractMatrix)
\end{minted}

Compute the matrix hyperbolic sine of a square matrix \texttt{A}.



\end{adjustwidth}
\hypertarget{1859383072068909395}{} 
\hyperlink{1859383072068909395}{\texttt{Base.tanh}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tanh(A::AbstractMatrix)
\end{minted}

Compute the matrix hyperbolic tangent of a square matrix \texttt{A}.



\end{adjustwidth}
\hypertarget{12898765534995911506}{} 
\hyperlink{12898765534995911506}{\texttt{Base.Math.sech}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sech(A::AbstractMatrix)
\end{minted}

Compute the matrix hyperbolic secant of square matrix \texttt{A}.



\end{adjustwidth}
\hypertarget{14098493345003221932}{} 
\hyperlink{14098493345003221932}{\texttt{Base.Math.csch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
csch(A::AbstractMatrix)
\end{minted}

Compute the matrix hyperbolic cosecant of square matrix \texttt{A}.



\end{adjustwidth}
\hypertarget{2675030789857212222}{} 
\hyperlink{2675030789857212222}{\texttt{Base.Math.coth}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
coth(A::AbstractMatrix)
\end{minted}

Compute the matrix hyperbolic cotangent of square matrix \texttt{A}.



\end{adjustwidth}
\hypertarget{13124751178617899053}{} 
\hyperlink{13124751178617899053}{\texttt{Base.acos}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acos(A::AbstractMatrix)
\end{minted}

Compute the inverse matrix cosine of a square matrix \texttt{A}.

If \texttt{A} is symmetric or Hermitian, its eigendecomposition (\hyperlink{11056016707394839114}{\texttt{eigen}}) is used to compute the inverse cosine. Otherwise, the inverse cosine is determined by using \hyperlink{17317607370922767936}{\texttt{log}} and \hyperlink{4551113327515323898}{\texttt{sqrt}}.  For the theory and logarithmic formulas used to compute this function, see \footnotemark[12].

\footnotetext[12]{Mary Aprahamian and Nicholas J. Higham, {\textquotedbl}Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms{\textquotedbl}, MIMS EPrint: 2016.4. \href{https://doi.org/10.1137/16M1057577}{https://doi.org/10.1137/16M1057577}

}
\textbf{Examples}


\begin{minted}{jlcon}
julia> acos(cos([0.5 0.1; -0.2 0.3]))
2×2 Array{Complex{Float64},2}:
  0.5-8.32667e-17im  0.1+0.0im
 -0.2+2.63678e-16im  0.3-3.46945e-16im
\end{minted}



\end{adjustwidth}
\hypertarget{13323825159284566975}{} 
\hyperlink{13323825159284566975}{\texttt{Base.asin}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asin(A::AbstractMatrix)
\end{minted}

Compute the inverse matrix sine of a square matrix \texttt{A}.

If \texttt{A} is symmetric or Hermitian, its eigendecomposition (\hyperlink{11056016707394839114}{\texttt{eigen}}) is used to compute the inverse sine. Otherwise, the inverse sine is determined by using \hyperlink{17317607370922767936}{\texttt{log}} and \hyperlink{4551113327515323898}{\texttt{sqrt}}.  For the theory and logarithmic formulas used to compute this function, see \footnotemark[13].

\footnotetext[13]{Mary Aprahamian and Nicholas J. Higham, {\textquotedbl}Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms{\textquotedbl}, MIMS EPrint: 2016.4. \href{https://doi.org/10.1137/16M1057577}{https://doi.org/10.1137/16M1057577}

}
\textbf{Examples}


\begin{minted}{jlcon}
julia> asin(sin([0.5 0.1; -0.2 0.3]))
2×2 Array{Complex{Float64},2}:
  0.5-4.16334e-17im  0.1-5.55112e-17im
 -0.2+9.71445e-17im  0.3-1.249e-16im
\end{minted}



\end{adjustwidth}
\hypertarget{16602871865924174581}{} 
\hyperlink{16602871865924174581}{\texttt{Base.atan}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
atan(A::AbstractMatrix)
\end{minted}

Compute the inverse matrix tangent of a square matrix \texttt{A}.

If \texttt{A} is symmetric or Hermitian, its eigendecomposition (\hyperlink{11056016707394839114}{\texttt{eigen}}) is used to compute the inverse tangent. Otherwise, the inverse tangent is determined by using \hyperlink{17317607370922767936}{\texttt{log}}.  For the theory and logarithmic formulas used to compute this function, see \footnotemark[14].

\footnotetext[14]{Mary Aprahamian and Nicholas J. Higham, {\textquotedbl}Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms{\textquotedbl}, MIMS EPrint: 2016.4. \href{https://doi.org/10.1137/16M1057577}{https://doi.org/10.1137/16M1057577}

}
\textbf{Examples}


\begin{minted}{jlcon}
julia> atan(tan([0.5 0.1; -0.2 0.3]))
2×2 Array{Complex{Float64},2}:
  0.5+1.38778e-17im  0.1-2.77556e-17im
 -0.2+6.93889e-17im  0.3-4.16334e-17im
\end{minted}



\end{adjustwidth}
\hypertarget{18059102985382682628}{} 
\hyperlink{18059102985382682628}{\texttt{Base.Math.asec}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asec(A::AbstractMatrix)
\end{minted}

Compute the inverse matrix secant of \texttt{A}. 



\end{adjustwidth}
\hypertarget{1996732052493549393}{} 
\hyperlink{1996732052493549393}{\texttt{Base.Math.acsc}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acsc(A::AbstractMatrix)
\end{minted}

Compute the inverse matrix cosecant of \texttt{A}. 



\end{adjustwidth}
\hypertarget{10418731786659005321}{} 
\hyperlink{10418731786659005321}{\texttt{Base.Math.acot}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acot(A::AbstractMatrix)
\end{minted}

Compute the inverse matrix cotangent of \texttt{A}. 



\end{adjustwidth}
\hypertarget{8148684206205068128}{} 
\hyperlink{8148684206205068128}{\texttt{Base.acosh}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acosh(A::AbstractMatrix)
\end{minted}

Compute the inverse hyperbolic matrix cosine of a square matrix \texttt{A}.  For the theory and logarithmic formulas used to compute this function, see \footnotemark[15].

\footnotetext[15]{Mary Aprahamian and Nicholas J. Higham, {\textquotedbl}Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms{\textquotedbl}, MIMS EPrint: 2016.4. \href{https://doi.org/10.1137/16M1057577}{https://doi.org/10.1137/16M1057577}

}


\end{adjustwidth}
\hypertarget{7556135416358066324}{} 
\hyperlink{7556135416358066324}{\texttt{Base.asinh}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asinh(A::AbstractMatrix)
\end{minted}

Compute the inverse hyperbolic matrix sine of a square matrix \texttt{A}.  For the theory and logarithmic formulas used to compute this function, see \footnotemark[16].

\footnotetext[16]{Mary Aprahamian and Nicholas J. Higham, {\textquotedbl}Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms{\textquotedbl}, MIMS EPrint: 2016.4. \href{https://doi.org/10.1137/16M1057577}{https://doi.org/10.1137/16M1057577}

}


\end{adjustwidth}
\hypertarget{631136805929918109}{} 
\hyperlink{631136805929918109}{\texttt{Base.atanh}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
atanh(A::AbstractMatrix)
\end{minted}

Compute the inverse hyperbolic matrix tangent of a square matrix \texttt{A}.  For the theory and logarithmic formulas used to compute this function, see \footnotemark[17].

\footnotetext[17]{Mary Aprahamian and Nicholas J. Higham, {\textquotedbl}Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms{\textquotedbl}, MIMS EPrint: 2016.4. \href{https://doi.org/10.1137/16M1057577}{https://doi.org/10.1137/16M1057577}

}


\end{adjustwidth}
\hypertarget{2354446395483966696}{} 
\hyperlink{2354446395483966696}{\texttt{Base.Math.asech}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asech(A::AbstractMatrix)
\end{minted}

Compute the inverse matrix hyperbolic secant of \texttt{A}. 



\end{adjustwidth}
\hypertarget{1360680038198884316}{} 
\hyperlink{1360680038198884316}{\texttt{Base.Math.acsch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acsch(A::AbstractMatrix)
\end{minted}

Compute the inverse matrix hyperbolic cosecant of \texttt{A}. 



\end{adjustwidth}
\hypertarget{12006952808365013482}{} 
\hyperlink{12006952808365013482}{\texttt{Base.Math.acoth}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acoth(A::AbstractMatrix)
\end{minted}

Compute the inverse matrix hyperbolic cotangent of \texttt{A}. 



\end{adjustwidth}
\hypertarget{13191775510498989455}{} 
\hyperlink{13191775510498989455}{\texttt{LinearAlgebra.lyap}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lyap(A, C)
\end{minted}

Computes the solution \texttt{X} to the continuous Lyapunov equation \texttt{AX + XA{\textquotesingle} + C = 0}, where no eigenvalue of \texttt{A} has a zero real part and no two eigenvalues are negative complex conjugates of each other.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [3. 4.; 5. 6]
2×2 Array{Float64,2}:
 3.0  4.0
 5.0  6.0

julia> B = [1. 1.; 1. 2.]
2×2 Array{Float64,2}:
 1.0  1.0
 1.0  2.0

julia> X = lyap(A, B)
2×2 Array{Float64,2}:
  0.5  -0.5
 -0.5   0.25

julia> A*X + X*A' + B
2×2 Array{Float64,2}:
 0.0          6.66134e-16
 6.66134e-16  8.88178e-16
\end{minted}



\end{adjustwidth}
\hypertarget{1947738214979807634}{} 
\hyperlink{1947738214979807634}{\texttt{LinearAlgebra.sylvester}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sylvester(A, B, C)
\end{minted}

Computes the solution \texttt{X} to the Sylvester equation \texttt{AX + XB + C = 0}, where \texttt{A}, \texttt{B} and \texttt{C} have compatible dimensions and \texttt{A} and \texttt{-B} have no eigenvalues with equal real part.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [3. 4.; 5. 6]
2×2 Array{Float64,2}:
 3.0  4.0
 5.0  6.0

julia> B = [1. 1.; 1. 2.]
2×2 Array{Float64,2}:
 1.0  1.0
 1.0  2.0

julia> C = [1. 2.; -2. 1]
2×2 Array{Float64,2}:
  1.0  2.0
 -2.0  1.0

julia> X = sylvester(A, B, C)
2×2 Array{Float64,2}:
 -4.46667   1.93333
  3.73333  -1.8

julia> A*X + X*B + C
2×2 Array{Float64,2}:
  2.66454e-15  1.77636e-15
 -3.77476e-15  4.44089e-16
\end{minted}



\end{adjustwidth}
\hypertarget{10694198281534172656}{} 
\hyperlink{10694198281534172656}{\texttt{LinearAlgebra.issuccess}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issuccess(F::Factorization)
\end{minted}

Test that a factorization of a matrix succeeded.


\begin{minted}{jlcon}
julia> F = cholesky([1 0; 0 1]);

julia> LinearAlgebra.issuccess(F)
true

julia> F = lu([1 0; 0 0]; check = false);

julia> LinearAlgebra.issuccess(F)
false
\end{minted}



\end{adjustwidth}
\hypertarget{2326080217547608316}{} 
\hyperlink{2326080217547608316}{\texttt{LinearAlgebra.issymmetric}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issymmetric(A) -> Bool
\end{minted}

Test whether a matrix is symmetric.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia> issymmetric(a)
true

julia> b = [1 im; -im 1]
2×2 Array{Complex{Int64},2}:
 1+0im  0+1im
 0-1im  1+0im

julia> issymmetric(b)
false
\end{minted}



\end{adjustwidth}
\hypertarget{13841568437070319804}{} 
\hyperlink{13841568437070319804}{\texttt{LinearAlgebra.isposdef}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isposdef(A) -> Bool
\end{minted}

Test whether a matrix is positive definite (and Hermitian) by trying to perform a Cholesky factorization of \texttt{A}. See also \hyperlink{15124613555733932079}{\texttt{isposdef!}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 2 50]
2×2 Array{Int64,2}:
 1   2
 2  50

julia> isposdef(A)
true
\end{minted}



\end{adjustwidth}
\hypertarget{15124613555733932079}{} 
\hyperlink{15124613555733932079}{\texttt{LinearAlgebra.isposdef!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isposdef!(A) -> Bool
\end{minted}

Test whether a matrix is positive definite (and Hermitian) by trying to perform a Cholesky factorization of \texttt{A}, overwriting \texttt{A} in the process. See also \hyperlink{13841568437070319804}{\texttt{isposdef}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1. 2.; 2. 50.];

julia> isposdef!(A)
true

julia> A
2×2 Array{Float64,2}:
 1.0  2.0
 2.0  6.78233
\end{minted}



\end{adjustwidth}
\hypertarget{14402064054856945387}{} 
\hyperlink{14402064054856945387}{\texttt{LinearAlgebra.istril}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
istril(A::AbstractMatrix, k::Integer = 0) -> Bool
\end{minted}

Test whether \texttt{A} is lower triangular starting from the \texttt{k}th superdiagonal.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia> istril(a)
false

julia> istril(a, 1)
true

julia> b = [1 0; -im -1]
2×2 Array{Complex{Int64},2}:
 1+0im   0+0im
 0-1im  -1+0im

julia> istril(b)
true

julia> istril(b, -1)
false
\end{minted}



\end{adjustwidth}
\hypertarget{15000310211103088559}{} 
\hyperlink{15000310211103088559}{\texttt{LinearAlgebra.istriu}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
istriu(A::AbstractMatrix, k::Integer = 0) -> Bool
\end{minted}

Test whether \texttt{A} is upper triangular starting from the \texttt{k}th superdiagonal.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia> istriu(a)
false

julia> istriu(a, -1)
true

julia> b = [1 im; 0 -1]
2×2 Array{Complex{Int64},2}:
 1+0im   0+1im
 0+0im  -1+0im

julia> istriu(b)
true

julia> istriu(b, 1)
false
\end{minted}



\end{adjustwidth}
\hypertarget{13562995326026471446}{} 
\hyperlink{13562995326026471446}{\texttt{LinearAlgebra.isdiag}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isdiag(A) -> Bool
\end{minted}

Test whether a matrix is diagonal.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia> isdiag(a)
false

julia> b = [im 0; 0 -im]
2×2 Array{Complex{Int64},2}:
 0+1im  0+0im
 0+0im  0-1im

julia> isdiag(b)
true
\end{minted}



\end{adjustwidth}
\hypertarget{2319981190929881860}{} 
\hyperlink{2319981190929881860}{\texttt{LinearAlgebra.ishermitian}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ishermitian(A) -> Bool
\end{minted}

Test whether a matrix is Hermitian.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia> ishermitian(a)
true

julia> b = [1 im; -im 1]
2×2 Array{Complex{Int64},2}:
 1+0im  0+1im
 0-1im  1+0im

julia> ishermitian(b)
true
\end{minted}



\end{adjustwidth}
\hypertarget{12700837529519091997}{} 
\hyperlink{12700837529519091997}{\texttt{Base.transpose}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
transpose(A)
\end{minted}

Lazy transpose. Mutating the returned object should appropriately mutate \texttt{A}. Often, but not always, yields \texttt{Transpose(A)}, where \texttt{Transpose} is a lazy transpose wrapper. Note that this operation is recursive.

This operation is intended for linear algebra usage - for general data manipulation see \hyperlink{10913801624539723467}{\texttt{permutedims}}, which is non-recursive.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia> transpose(A)
2×2 Transpose{Complex{Int64},Array{Complex{Int64},2}}:
 3+2im  8+7im
 9+2im  4+6im
\end{minted}



\end{adjustwidth}
\hypertarget{11048480146030319791}{} 
\hyperlink{11048480146030319791}{\texttt{LinearAlgebra.transpose!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
transpose!(dest,src)
\end{minted}

Transpose array \texttt{src} and store the result in the preallocated array \texttt{dest}, which should have a size corresponding to \texttt{(size(src,2),size(src,1))}. No in-place transposition is supported and unexpected results will happen if \texttt{src} and \texttt{dest} have overlapping memory regions.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia> B = zeros(Complex{Int64}, 2, 2)
2×2 Array{Complex{Int64},2}:
 0+0im  0+0im
 0+0im  0+0im

julia> transpose!(B, A);

julia> B
2×2 Array{Complex{Int64},2}:
 3+2im  8+7im
 9+2im  4+6im

julia> A
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im
\end{minted}



\end{adjustwidth}
\hypertarget{14692313863932962816}{} 
\hyperlink{14692313863932962816}{\texttt{LinearAlgebra.Transpose}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Transpose
\end{minted}

Lazy wrapper type for a transpose view of the underlying linear algebra object, usually an \texttt{AbstractVector}/\texttt{AbstractMatrix}, but also some \texttt{Factorization}, for instance. Usually, the \texttt{Transpose} constructor should not be called directly, use \hyperlink{12700837529519091997}{\texttt{transpose}} instead. To materialize the view use \hyperlink{15665284441316555522}{\texttt{copy}}.

This type is intended for linear algebra usage - for general data manipulation see \hyperlink{10913801624539723467}{\texttt{permutedims}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia> transpose(A)
2×2 Transpose{Complex{Int64},Array{Complex{Int64},2}}:
 3+2im  8+7im
 9+2im  4+6im
\end{minted}



\end{adjustwidth}
\hypertarget{10565518144285607255}{} 
\hyperlink{10565518144285607255}{\texttt{Base.adjoint}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
adjoint(A)
\end{minted}

Lazy adjoint (conjugate transposition) (also postfix \texttt{{\textquotesingle}}). Note that \texttt{adjoint} is applied recursively to elements.

This operation is intended for linear algebra usage - for general data manipulation see \hyperlink{10913801624539723467}{\texttt{permutedims}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia> adjoint(A)
2×2 Adjoint{Complex{Int64},Array{Complex{Int64},2}}:
 3-2im  8-7im
 9-2im  4-6im
\end{minted}



\end{adjustwidth}
\hypertarget{9871500626629337445}{} 
\hyperlink{9871500626629337445}{\texttt{LinearAlgebra.adjoint!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
adjoint!(dest,src)
\end{minted}

Conjugate transpose array \texttt{src} and store the result in the preallocated array \texttt{dest}, which should have a size corresponding to \texttt{(size(src,2),size(src,1))}. No in-place transposition is supported and unexpected results will happen if \texttt{src} and \texttt{dest} have overlapping memory regions.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia> B = zeros(Complex{Int64}, 2, 2)
2×2 Array{Complex{Int64},2}:
 0+0im  0+0im
 0+0im  0+0im

julia> adjoint!(B, A);

julia> B
2×2 Array{Complex{Int64},2}:
 3-2im  8-7im
 9-2im  4-6im

julia> A
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im
\end{minted}



\end{adjustwidth}
\hypertarget{10784859587547982593}{} 
\hyperlink{10784859587547982593}{\texttt{LinearAlgebra.Adjoint}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Adjoint
\end{minted}

Lazy wrapper type for an adjoint view of the underlying linear algebra object, usually an \texttt{AbstractVector}/\texttt{AbstractMatrix}, but also some \texttt{Factorization}, for instance. Usually, the \texttt{Adjoint} constructor should not be called directly, use \hyperlink{10565518144285607255}{\texttt{adjoint}} instead. To materialize the view use \hyperlink{15665284441316555522}{\texttt{copy}}.

This type is intended for linear algebra usage - for general data manipulation see \hyperlink{10913801624539723467}{\texttt{permutedims}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia> adjoint(A)
2×2 Adjoint{Complex{Int64},Array{Complex{Int64},2}}:
 3-2im  8-7im
 9-2im  4-6im
\end{minted}



\end{adjustwidth}
\hypertarget{16739145811029380235}{} 
\hyperlink{16739145811029380235}{\texttt{Base.copy}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
copy(A::Transpose)
copy(A::Adjoint)
\end{minted}

Eagerly evaluate the lazy matrix transpose/adjoint. Note that the transposition is applied recursively to elements.

This operation is intended for linear algebra usage - for general data manipulation see \hyperlink{10913801624539723467}{\texttt{permutedims}}, which is non-recursive.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2im; -3im 4]
2×2 Array{Complex{Int64},2}:
 1+0im  0+2im
 0-3im  4+0im

julia> T = transpose(A)
2×2 Transpose{Complex{Int64},Array{Complex{Int64},2}}:
 1+0im  0-3im
 0+2im  4+0im

julia> copy(T)
2×2 Array{Complex{Int64},2}:
 1+0im  0-3im
 0+2im  4+0im
\end{minted}



\end{adjustwidth}
\hypertarget{17430342268269872501}{} 
\hyperlink{17430342268269872501}{\texttt{LinearAlgebra.stride1}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stride1(A) -> Int
\end{minted}

Return the distance between successive array elements in dimension 1 in units of element size.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1,2,3,4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> LinearAlgebra.stride1(A)
1

julia> B = view(A, 2:2:4)
2-element view(::Array{Int64,1}, 2:2:4) with eltype Int64:
 2
 4

julia> LinearAlgebra.stride1(B)
2
\end{minted}



\end{adjustwidth}
\hypertarget{3700476694218805076}{} 
\hyperlink{3700476694218805076}{\texttt{LinearAlgebra.checksquare}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LinearAlgebra.checksquare(A)
\end{minted}

Check that a matrix is square, then return its common dimension. For multiple arguments, return a vector.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = fill(1, (4,4)); B = fill(1, (5,5));

julia> LinearAlgebra.checksquare(A, B)
2-element Array{Int64,1}:
 4
 5
\end{minted}



\end{adjustwidth}
\hypertarget{2023980161110391079}{} 
\hyperlink{2023980161110391079}{\texttt{LinearAlgebra.peakflops}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LinearAlgebra.peakflops(n::Integer=2000; parallel::Bool=false)
\end{minted}

\texttt{peakflops} computes the peak flop rate of the computer by using double precision \hyperlink{8173170876588438683}{\texttt{gemm!}}. By default, if no arguments are specified, it multiplies a matrix of size \texttt{n x n}, where \texttt{n = 2000}. If the underlying BLAS is using multiple threads, higher flop rates are realized. The number of BLAS threads can be set with \hyperlink{2145233402822007277}{\texttt{BLAS.set\_num\_threads(n)}}.

If the keyword argument \texttt{parallel} is set to \texttt{true}, \texttt{peakflops} is run in parallel on all the worker processors. The flop rate of the entire parallel computer is returned. When running in parallel, only 1 BLAS thread is used. The argument \texttt{n} still refers to the size of the problem that is solved on each processor.

\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1. In Julia 1.0 it is available from the standard library \texttt{InteractiveUtils}.

\end{quote}


\end{adjustwidth}

\hypertarget{4687212954685590607}{}


\section{Low-level matrix operations}



In many cases there are in-place versions of matrix operations that allow you to supply a pre-allocated output vector or matrix.  This is useful when optimizing critical code in order to avoid the overhead of repeated allocations. These in-place operations are suffixed with \texttt{!} below (e.g. \texttt{mul!}) according to the usual Julia convention.


\hypertarget{364008531309780709}{} 
\hyperlink{364008531309780709}{\texttt{LinearAlgebra.mul!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mul!(Y, A, B) -> Y
\end{minted}

Calculates the matrix-matrix or matrix-vector product  \(AB\)  and stores the result in \texttt{Y}, overwriting the existing value of \texttt{Y}. Note that \texttt{Y} must not be aliased with either \texttt{A} or \texttt{B}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A=[1.0 2.0; 3.0 4.0]; B=[1.0 1.0; 1.0 1.0]; Y = similar(B); mul!(Y, A, B);

julia> Y
2×2 Array{Float64,2}:
 3.0  3.0
 7.0  7.0
\end{minted}

\textbf{Implementation}

For custom matrix and vector types, it is recommended to implement 5-argument \texttt{mul!} rather than implementing 3-argument \texttt{mul!} directly if possible.




\begin{lstlisting}
mul!(C, A, B, α, β) -> C
\end{lstlisting}

Combined inplace matrix-matrix or matrix-vector multiply-add  \(A B α + C β\) . The result is stored in \texttt{C} by overwriting it.  Note that \texttt{C} must not be aliased with either \texttt{A} or \texttt{B}.

\begin{quote}
\textbf{Julia 1.3}

Five-argument \texttt{mul!} requires at least Julia 1.3.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A=[1.0 2.0; 3.0 4.0]; B=[1.0 1.0; 1.0 1.0]; C=[1.0 2.0; 3.0 4.0];

julia> mul!(C, A, B, 100.0, 10.0) === C
true

julia> C
2×2 Array{Float64,2}:
 310.0  320.0
 730.0  740.0
\end{minted}



\end{adjustwidth}
\hypertarget{12404459690324241452}{} 
\hyperlink{12404459690324241452}{\texttt{LinearAlgebra.lmul!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lmul!(a::Number, B::AbstractArray)
\end{minted}

Scale an array \texttt{B} by a scalar \texttt{a} overwriting \texttt{B} in-place.  Use \hyperlink{11562785155463579477}{\texttt{rmul!}} to multiply scalar from right.  The scaling operation respects the semantics of the multiplication \hyperlink{7592762607639177347}{\texttt{*}} between \texttt{a} and an element of \texttt{B}.  In particular, this also applies to multiplication involving non-finite numbers such as \texttt{NaN} and \texttt{±Inf}.

\begin{quote}
\textbf{Julia 1.1}

Prior to Julia 1.1, \texttt{NaN} and \texttt{±Inf} entries in \texttt{B} were treated inconsistently.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> B = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> lmul!(2, B)
2×2 Array{Int64,2}:
 2  4
 6  8

julia> lmul!(0.0, [Inf])
1-element Array{Float64,1}:
 NaN
\end{minted}




\begin{lstlisting}
lmul!(A, B)
\end{lstlisting}

Calculate the matrix-matrix product  \(AB\) , overwriting \texttt{B}, and return the result. Here, \texttt{A} must be of special matrix type, like, e.g., \hyperlink{3300114559258360989}{\texttt{Diagonal}}, \hyperlink{6344726545165008167}{\texttt{UpperTriangular}} or \hyperlink{15116078732779234709}{\texttt{LowerTriangular}}, or of some orthogonal type, see \hyperlink{16913872014958777367}{\texttt{QR}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> B = [0 1; 1 0];

julia> A = LinearAlgebra.UpperTriangular([1 2; 0 3]);

julia> LinearAlgebra.lmul!(A, B);

julia> B
2×2 Array{Int64,2}:
 2  1
 3  0

julia> B = [1.0 2.0; 3.0 4.0];

julia> F = qr([0 1; -1 0]);

julia> lmul!(F.Q, B)
2×2 Array{Float64,2}:
 3.0  4.0
 1.0  2.0
\end{minted}



\end{adjustwidth}
\hypertarget{11562785155463579477}{} 
\hyperlink{11562785155463579477}{\texttt{LinearAlgebra.rmul!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rmul!(A::AbstractArray, b::Number)
\end{minted}

Scale an array \texttt{A} by a scalar \texttt{b} overwriting \texttt{A} in-place.  Use \hyperlink{12404459690324241452}{\texttt{lmul!}} to multiply scalar from left.  The scaling operation respects the semantics of the multiplication \hyperlink{7592762607639177347}{\texttt{*}} between an element of \texttt{A} and \texttt{b}.  In particular, this also applies to multiplication involving non-finite numbers such as \texttt{NaN} and \texttt{±Inf}.

\begin{quote}
\textbf{Julia 1.1}

Prior to Julia 1.1, \texttt{NaN} and \texttt{±Inf} entries in \texttt{A} were treated inconsistently.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rmul!(A, 2)
2×2 Array{Int64,2}:
 2  4
 6  8

julia> rmul!([NaN], 0.0)
1-element Array{Float64,1}:
 NaN
\end{minted}




\begin{lstlisting}
rmul!(A, B)
\end{lstlisting}

Calculate the matrix-matrix product  \(AB\) , overwriting \texttt{A}, and return the result. Here, \texttt{B} must be of special matrix type, like, e.g., \hyperlink{3300114559258360989}{\texttt{Diagonal}}, \hyperlink{6344726545165008167}{\texttt{UpperTriangular}} or \hyperlink{15116078732779234709}{\texttt{LowerTriangular}}, or of some orthogonal type, see \hyperlink{16913872014958777367}{\texttt{QR}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [0 1; 1 0];

julia> B = LinearAlgebra.UpperTriangular([1 2; 0 3]);

julia> LinearAlgebra.rmul!(A, B);

julia> A
2×2 Array{Int64,2}:
 0  3
 1  2

julia> A = [1.0 2.0; 3.0 4.0];

julia> F = qr([0 1; -1 0]);

julia> rmul!(A, F.Q)
2×2 Array{Float64,2}:
 2.0  1.0
 4.0  3.0
\end{minted}



\end{adjustwidth}
\hypertarget{11817740014578453690}{} 
\hyperlink{11817740014578453690}{\texttt{LinearAlgebra.ldiv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ldiv!(Y, A, B) -> Y
\end{minted}

Compute \texttt{A {\textbackslash} B} in-place and store the result in \texttt{Y}, returning the result.

The argument \texttt{A} should \emph{not} be a matrix.  Rather, instead of matrices it should be a factorization object (e.g. produced by \hyperlink{7042962205548658937}{\texttt{factorize}} or \hyperlink{7653413936706994771}{\texttt{cholesky}}). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., \hyperlink{3268903080173564842}{\texttt{lu!}}), and performance-critical situations requiring \texttt{ldiv!} usually also require fine-grained control over the factorization of \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2.2 4; 3.1 0.2 3; 4 1 2];

julia> X = [1; 2.5; 3];

julia> Y = zero(X);

julia> ldiv!(Y, qr(A), X);

julia> Y
3-element Array{Float64,1}:
  0.7128099173553719
 -0.051652892561983674
  0.10020661157024757

julia> A\X
3-element Array{Float64,1}:
  0.7128099173553719
 -0.05165289256198333
  0.10020661157024785
\end{minted}




\begin{lstlisting}
ldiv!(A, B)
\end{lstlisting}

Compute \texttt{A {\textbackslash} B} in-place and overwriting \texttt{B} to store the result.

The argument \texttt{A} should \emph{not} be a matrix.  Rather, instead of matrices it should be a factorization object (e.g. produced by \hyperlink{7042962205548658937}{\texttt{factorize}} or \hyperlink{7653413936706994771}{\texttt{cholesky}}). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., \hyperlink{3268903080173564842}{\texttt{lu!}}), and performance-critical situations requiring \texttt{ldiv!} usually also require fine-grained control over the factorization of \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2.2 4; 3.1 0.2 3; 4 1 2];

julia> X = [1; 2.5; 3];

julia> Y = copy(X);

julia> ldiv!(qr(A), X);

julia> X
3-element Array{Float64,1}:
  0.7128099173553719
 -0.051652892561983674
  0.10020661157024757

julia> A\Y
3-element Array{Float64,1}:
  0.7128099173553719
 -0.05165289256198333
  0.10020661157024785
\end{minted}




\begin{lstlisting}
ldiv!(a::Number, B::AbstractArray)
\end{lstlisting}

Divide each entry in an array \texttt{B} by a scalar \texttt{a} overwriting \texttt{B} in-place.  Use \hyperlink{14949618513077509248}{\texttt{rdiv!}} to divide scalar from right.

\textbf{Examples}


\begin{minted}{jlcon}
julia> B = [1.0 2.0; 3.0 4.0]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia> ldiv!(2.0, B)
2×2 Array{Float64,2}:
 0.5  1.0
 1.5  2.0
\end{minted}



\end{adjustwidth}
\hypertarget{14949618513077509248}{} 
\hyperlink{14949618513077509248}{\texttt{LinearAlgebra.rdiv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rdiv!(A, B)
\end{minted}

Compute \texttt{A / B} in-place and overwriting \texttt{A} to store the result.

The argument \texttt{B} should \emph{not} be a matrix.  Rather, instead of matrices it should be a factorization object (e.g. produced by \hyperlink{7042962205548658937}{\texttt{factorize}} or \hyperlink{7653413936706994771}{\texttt{cholesky}}). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., \hyperlink{3268903080173564842}{\texttt{lu!}}), and performance-critical situations requiring \texttt{rdiv!} usually also require fine-grained control over the factorization of \texttt{B}.




\begin{lstlisting}
rdiv!(A::AbstractArray, b::Number)
\end{lstlisting}

Divide each entry in an array \texttt{A} by a scalar \texttt{b} overwriting \texttt{A} in-place.  Use \hyperlink{11817740014578453690}{\texttt{ldiv!}} to divide scalar from left.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1.0 2.0; 3.0 4.0]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia> rdiv!(A, 2.0)
2×2 Array{Float64,2}:
 0.5  1.0
 1.5  2.0
\end{minted}



\end{adjustwidth}

\hypertarget{11716155958635895745}{}


\section{BLAS functions}



In Julia (as in much of scientific computation), dense linear-algebra operations are based on the \href{http://www.netlib.org/lapack/}{LAPACK library}, which in turn is built on top of basic linear-algebra building-blocks known as the \href{http://www.netlib.org/blas/}{BLAS}. There are highly optimized implementations of BLAS available for every computer architecture, and sometimes in high-performance linear algebra routines it is useful to call the BLAS functions directly.



\texttt{LinearAlgebra.BLAS} provides wrappers for some of the BLAS functions. Those BLAS functions that overwrite one of the input arrays have names ending in \texttt{{\textquotesingle}!{\textquotesingle}}.  Usually, a BLAS function has four methods defined, for \hyperlink{5027751419500983000}{\texttt{Float64}}, \hyperlink{8101639384272933082}{\texttt{Float32}}, \texttt{ComplexF64}, and \texttt{ComplexF32} arrays.



\hypertarget{11073177327200670825}{}


\subsection{BLAS character arguments}



Many BLAS functions accept arguments that determine whether to transpose an argument (\texttt{trans}), which triangle of a matrix to reference (\texttt{uplo} or \texttt{ul}), whether the diagonal of a triangular matrix can be assumed to be all ones (\texttt{dA}) or which side of a matrix multiplication the input argument belongs on (\texttt{side}). The possibilities are:



\hypertarget{1714685266370616361}{}


\subsubsection{Multiplication order}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\texttt{side} & Meaning \\
\hline
\texttt{{\textquotesingle}L{\textquotesingle}} & The argument goes on the \emph{left} side of a matrix-matrix operation. \\
\hline
\texttt{{\textquotesingle}R{\textquotesingle}} & The argument goes on the \emph{right} side of a matrix-matrix operation. \\
\hline
\end{tabulary}

\end{table}



\hypertarget{5558887752259302145}{}


\subsubsection{Triangle referencing}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\texttt{uplo}/\texttt{ul} & Meaning \\
\hline
\texttt{{\textquotesingle}U{\textquotesingle}} & Only the \emph{upper} triangle of the matrix will be used. \\
\hline
\texttt{{\textquotesingle}L{\textquotesingle}} & Only the \emph{lower} triangle of the matrix will be used. \\
\hline
\end{tabulary}

\end{table}



\hypertarget{13285421231458545876}{}


\subsubsection{Transposition operation}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\texttt{trans}/\texttt{tX} & Meaning \\
\hline
\texttt{{\textquotesingle}N{\textquotesingle}} & The input matrix \texttt{X} is not transposed or conjugated. \\
\hline
\texttt{{\textquotesingle}T{\textquotesingle}} & The input matrix \texttt{X} will be transposed. \\
\hline
\texttt{{\textquotesingle}C{\textquotesingle}} & The input matrix \texttt{X} will be conjugated and transposed. \\
\hline
\end{tabulary}

\end{table}



\hypertarget{11643333471578083521}{}


\subsubsection{Unit diagonal}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\texttt{diag}/\texttt{dX} & Meaning \\
\hline
\texttt{{\textquotesingle}N{\textquotesingle}} & The diagonal values of the matrix \texttt{X} will be read. \\
\hline
\texttt{{\textquotesingle}U{\textquotesingle}} & The diagonal of the matrix \texttt{X} is assumed to be all ones. \\
\hline
\end{tabulary}

\end{table}


\hypertarget{16764328874035557229}{} 
\hyperlink{16764328874035557229}{\texttt{LinearAlgebra.BLAS}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}

Interface to BLAS subroutines.



\end{adjustwidth}
\hypertarget{18272264626945379268}{} 
\hyperlink{18272264626945379268}{\texttt{LinearAlgebra.BLAS.dot}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dot(n, X, incx, Y, incy)
\end{minted}

Dot product of two vectors consisting of \texttt{n} elements of array \texttt{X} with stride \texttt{incx} and \texttt{n} elements of array \texttt{Y} with stride \texttt{incy}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> BLAS.dot(10, fill(1.0, 10), 1, fill(1.0, 20), 2)
10.0
\end{minted}



\end{adjustwidth}
\hypertarget{17189447686500977816}{} 
\hyperlink{17189447686500977816}{\texttt{LinearAlgebra.BLAS.dotu}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dotu(n, X, incx, Y, incy)
\end{minted}

Dot function for two complex vectors consisting of \texttt{n} elements of array \texttt{X} with stride \texttt{incx} and \texttt{n} elements of array \texttt{Y} with stride \texttt{incy}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> BLAS.dotu(10, fill(1.0im, 10), 1, fill(1.0+im, 20), 2)
-10.0 + 10.0im
\end{minted}



\end{adjustwidth}
\hypertarget{14215820815183043302}{} 
\hyperlink{14215820815183043302}{\texttt{LinearAlgebra.BLAS.dotc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dotc(n, X, incx, U, incy)
\end{minted}

Dot function for two complex vectors, consisting of \texttt{n} elements of array \texttt{X} with stride \texttt{incx} and \texttt{n} elements of array \texttt{U} with stride \texttt{incy}, conjugating the first vector.

\textbf{Examples}


\begin{minted}{jlcon}
julia> BLAS.dotc(10, fill(1.0im, 10), 1, fill(1.0+im, 20), 2)
10.0 - 10.0im
\end{minted}



\end{adjustwidth}
\hypertarget{18067085143510999712}{} 
\hyperlink{18067085143510999712}{\texttt{LinearAlgebra.BLAS.blascopy!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
blascopy!(n, X, incx, Y, incy)
\end{minted}

Copy \texttt{n} elements of array \texttt{X} with stride \texttt{incx} to array \texttt{Y} with stride \texttt{incy}. Returns \texttt{Y}.



\end{adjustwidth}
\hypertarget{16054338457942758080}{} 
\hyperlink{16054338457942758080}{\texttt{LinearAlgebra.BLAS.nrm2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nrm2(n, X, incx)
\end{minted}

2-norm of a vector consisting of \texttt{n} elements of array \texttt{X} with stride \texttt{incx}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> BLAS.nrm2(4, fill(1.0, 8), 2)
2.0

julia> BLAS.nrm2(1, fill(1.0, 8), 2)
1.0
\end{minted}



\end{adjustwidth}
\hypertarget{17921796148467908168}{} 
\hyperlink{17921796148467908168}{\texttt{LinearAlgebra.BLAS.asum}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asum(n, X, incx)
\end{minted}

Sum of the absolute values of the first \texttt{n} elements of array \texttt{X} with stride \texttt{incx}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> BLAS.asum(5, fill(1.0im, 10), 2)
5.0

julia> BLAS.asum(2, fill(1.0im, 10), 5)
2.0
\end{minted}



\end{adjustwidth}
\hypertarget{1249554703870980233}{} 
\hyperlink{1249554703870980233}{\texttt{LinearAlgebra.axpy!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
axpy!(a, X, Y)
\end{minted}

Overwrite \texttt{Y} with \texttt{X*a + Y}, where \texttt{a} is a scalar. Return \texttt{Y}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = [1; 2; 3];

julia> y = [4; 5; 6];

julia> BLAS.axpy!(2, x, y)
3-element Array{Int64,1}:
  6
  9
 12
\end{minted}



\end{adjustwidth}
\hypertarget{15769382652026820442}{} 
\hyperlink{15769382652026820442}{\texttt{LinearAlgebra.axpby!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
axpby!(a, X, b, Y)
\end{minted}

Overwrite \texttt{Y} with \texttt{X*a + Y*b}, where \texttt{a} and \texttt{b} are scalars. Return \texttt{Y}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = [1., 2, 3];

julia> y = [4., 5, 6];

julia> BLAS.axpby!(2., x, 3., y)
3-element Array{Float64,1}:
 14.0
 19.0
 24.0
\end{minted}



\end{adjustwidth}
\hypertarget{1309689219983162396}{} 
\hyperlink{1309689219983162396}{\texttt{LinearAlgebra.BLAS.scal!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
scal!(n, a, X, incx)
\end{minted}

Overwrite \texttt{X} with \texttt{a*X} for the first \texttt{n} elements of array \texttt{X} with stride \texttt{incx}. Returns \texttt{X}.



\end{adjustwidth}
\hypertarget{12895642275868597015}{} 
\hyperlink{12895642275868597015}{\texttt{LinearAlgebra.BLAS.scal}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
scal(n, a, X, incx)
\end{minted}

Return \texttt{X} scaled by \texttt{a} for the first \texttt{n} elements of array \texttt{X} with stride \texttt{incx}.



\end{adjustwidth}
\hypertarget{7368077295193322508}{} 
\hyperlink{7368077295193322508}{\texttt{LinearAlgebra.BLAS.iamax}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
iamax(n, dx, incx)
iamax(dx)
\end{minted}

Find the index of the element of \texttt{dx} with the maximum absolute value. \texttt{n} is the length of \texttt{dx}, and \texttt{incx} is the stride. If \texttt{n} and \texttt{incx} are not provided, they assume default values of \texttt{n=length(dx)} and \texttt{incx=stride1(dx)}.



\end{adjustwidth}
\hypertarget{15218685048281144798}{} 
\hyperlink{15218685048281144798}{\texttt{LinearAlgebra.BLAS.ger!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ger!(alpha, x, y, A)
\end{minted}

Rank-1 update of the matrix \texttt{A} with vectors \texttt{x} and \texttt{y} as \texttt{alpha*x*y{\textquotesingle} + A}.



\end{adjustwidth}
\hypertarget{12739496223053575792}{} 
\hyperlink{12739496223053575792}{\texttt{LinearAlgebra.BLAS.syr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
syr!(uplo, alpha, x, A)
\end{minted}

Rank-1 update of the symmetric matrix \texttt{A} with vector \texttt{x} as \texttt{alpha*x*transpose(x) + A}. \hyperlink{13880289478825450693}{\texttt{uplo}} controls which triangle of \texttt{A} is updated. Returns \texttt{A}.



\end{adjustwidth}
\hypertarget{17626560315865992019}{} 
\hyperlink{17626560315865992019}{\texttt{LinearAlgebra.BLAS.syrk!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
syrk!(uplo, trans, alpha, A, beta, C)
\end{minted}

Rank-k update of the symmetric matrix \texttt{C} as \texttt{alpha*A*transpose(A) + beta*C} or \texttt{alpha*transpose(A)*A + beta*C} according to \hyperlink{15951037910221396131}{\texttt{trans}}. Only the \hyperlink{13880289478825450693}{\texttt{uplo}} triangle of \texttt{C} is used. Returns \texttt{C}.



\end{adjustwidth}
\hypertarget{13051593926705442778}{} 
\hyperlink{13051593926705442778}{\texttt{LinearAlgebra.BLAS.syrk}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
syrk(uplo, trans, alpha, A)
\end{minted}

Returns either the upper triangle or the lower triangle of \texttt{A}, according to \hyperlink{13880289478825450693}{\texttt{uplo}}, of \texttt{alpha*A*transpose(A)} or \texttt{alpha*transpose(A)*A}, according to \hyperlink{15951037910221396131}{\texttt{trans}}.



\end{adjustwidth}
\hypertarget{4077074915146270084}{} 
\hyperlink{4077074915146270084}{\texttt{LinearAlgebra.BLAS.syr2k!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
syr2k!(uplo, trans, alpha, A, B, beta, C)
\end{minted}

Rank-2k update of the symmetric matrix \texttt{C} as \texttt{alpha*A*transpose(B) + alpha*B*transpose(A) + beta*C} or \texttt{alpha*transpose(A)*B + alpha*transpose(B)*A + beta*C} according to \hyperlink{15951037910221396131}{\texttt{trans}}. Only the \hyperlink{13880289478825450693}{\texttt{uplo}} triangle of \texttt{C} is used. Returns \texttt{C}.



\end{adjustwidth}
\hypertarget{8760875486589937064}{} 
\hyperlink{8760875486589937064}{\texttt{LinearAlgebra.BLAS.syr2k}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
syr2k(uplo, trans, alpha, A, B)
\end{minted}

Returns the \hyperlink{13880289478825450693}{\texttt{uplo}} triangle of \texttt{alpha*A*transpose(B) + alpha*B*transpose(A)} or \texttt{alpha*transpose(A)*B + alpha*transpose(B)*A}, according to \hyperlink{15951037910221396131}{\texttt{trans}}.




\begin{lstlisting}
syr2k(uplo, trans, A, B)
\end{lstlisting}

Returns the \hyperlink{13880289478825450693}{\texttt{uplo}} triangle of \texttt{A*transpose(B) + B*transpose(A)} or \texttt{transpose(A)*B + transpose(B)*A}, according to \hyperlink{15951037910221396131}{\texttt{trans}}.



\end{adjustwidth}
\hypertarget{13391948874280376128}{} 
\hyperlink{13391948874280376128}{\texttt{LinearAlgebra.BLAS.her!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
her!(uplo, alpha, x, A)
\end{minted}

Methods for complex arrays only. Rank-1 update of the Hermitian matrix \texttt{A} with vector \texttt{x} as \texttt{alpha*x*x{\textquotesingle} + A}. \hyperlink{13880289478825450693}{\texttt{uplo}} controls which triangle of \texttt{A} is updated. Returns \texttt{A}.



\end{adjustwidth}
\hypertarget{13961548415194246627}{} 
\hyperlink{13961548415194246627}{\texttt{LinearAlgebra.BLAS.herk!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
herk!(uplo, trans, alpha, A, beta, C)
\end{minted}

Methods for complex arrays only. Rank-k update of the Hermitian matrix \texttt{C} as \texttt{alpha*A*A{\textquotesingle} + beta*C} or \texttt{alpha*A{\textquotesingle}*A + beta*C} according to \hyperlink{15951037910221396131}{\texttt{trans}}. Only the \hyperlink{13880289478825450693}{\texttt{uplo}} triangle of \texttt{C} is updated. Returns \texttt{C}.



\end{adjustwidth}
\hypertarget{10248669546555807730}{} 
\hyperlink{10248669546555807730}{\texttt{LinearAlgebra.BLAS.herk}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
herk(uplo, trans, alpha, A)
\end{minted}

Methods for complex arrays only. Returns the \hyperlink{13880289478825450693}{\texttt{uplo}} triangle of \texttt{alpha*A*A{\textquotesingle}} or \texttt{alpha*A{\textquotesingle}*A}, according to \hyperlink{15951037910221396131}{\texttt{trans}}.



\end{adjustwidth}
\hypertarget{7429214484576657213}{} 
\hyperlink{7429214484576657213}{\texttt{LinearAlgebra.BLAS.her2k!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
her2k!(uplo, trans, alpha, A, B, beta, C)
\end{minted}

Rank-2k update of the Hermitian matrix \texttt{C} as \texttt{alpha*A*B{\textquotesingle} + alpha*B*A{\textquotesingle} + beta*C} or \texttt{alpha*A{\textquotesingle}*B + alpha*B{\textquotesingle}*A + beta*C} according to \hyperlink{15951037910221396131}{\texttt{trans}}. The scalar \texttt{beta} has to be real. Only the \hyperlink{13880289478825450693}{\texttt{uplo}} triangle of \texttt{C} is used. Returns \texttt{C}.



\end{adjustwidth}
\hypertarget{1414422633857793327}{} 
\hyperlink{1414422633857793327}{\texttt{LinearAlgebra.BLAS.her2k}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
her2k(uplo, trans, alpha, A, B)
\end{minted}

Returns the \hyperlink{13880289478825450693}{\texttt{uplo}} triangle of \texttt{alpha*A*B{\textquotesingle} + alpha*B*A{\textquotesingle}} or \texttt{alpha*A{\textquotesingle}*B + alpha*B{\textquotesingle}*A}, according to \hyperlink{15951037910221396131}{\texttt{trans}}.




\begin{lstlisting}
her2k(uplo, trans, A, B)
\end{lstlisting}

Returns the \hyperlink{13880289478825450693}{\texttt{uplo}} triangle of \texttt{A*B{\textquotesingle} + B*A{\textquotesingle}} or \texttt{A{\textquotesingle}*B + B{\textquotesingle}*A}, according to \hyperlink{15951037910221396131}{\texttt{trans}}.



\end{adjustwidth}
\hypertarget{8676615954581837341}{} 
\hyperlink{8676615954581837341}{\texttt{LinearAlgebra.BLAS.gbmv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gbmv!(trans, m, kl, ku, alpha, A, x, beta, y)
\end{minted}

Update vector \texttt{y} as \texttt{alpha*A*x + beta*y} or \texttt{alpha*A{\textquotesingle}*x + beta*y} according to \hyperlink{15951037910221396131}{\texttt{trans}}. The matrix \texttt{A} is a general band matrix of dimension \texttt{m} by \texttt{size(A,2)} with \texttt{kl} sub-diagonals and \texttt{ku} super-diagonals. \texttt{alpha} and \texttt{beta} are scalars. Return the updated \texttt{y}.



\end{adjustwidth}
\hypertarget{12471388286549789624}{} 
\hyperlink{12471388286549789624}{\texttt{LinearAlgebra.BLAS.gbmv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gbmv(trans, m, kl, ku, alpha, A, x)
\end{minted}

Return \texttt{alpha*A*x} or \texttt{alpha*A{\textquotesingle}*x} according to \hyperlink{15951037910221396131}{\texttt{trans}}. The matrix \texttt{A} is a general band matrix of dimension \texttt{m} by \texttt{size(A,2)} with \texttt{kl} sub-diagonals and \texttt{ku} super-diagonals, and \texttt{alpha} is a scalar.



\end{adjustwidth}
\hypertarget{321677349067447286}{} 
\hyperlink{321677349067447286}{\texttt{LinearAlgebra.BLAS.sbmv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sbmv!(uplo, k, alpha, A, x, beta, y)
\end{minted}

Update vector \texttt{y} as \texttt{alpha*A*x + beta*y} where \texttt{A} is a a symmetric band matrix of order \texttt{size(A,2)} with \texttt{k} super-diagonals stored in the argument \texttt{A}. The storage layout for \texttt{A} is described the reference BLAS module, level-2 BLAS at \href{http://www.netlib.org/lapack/explore-html/}{http://www.netlib.org/lapack/explore-html/}. Only the \hyperlink{13880289478825450693}{\texttt{uplo}} triangle of \texttt{A} is used.

Return the updated \texttt{y}.



\end{adjustwidth}
\hypertarget{17387012353031396238}{} 
\hyperlink{17387012353031396238}{\texttt{LinearAlgebra.BLAS.sbmv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sbmv(uplo, k, alpha, A, x)
\end{minted}

Return \texttt{alpha*A*x} where \texttt{A} is a symmetric band matrix of order \texttt{size(A,2)} with \texttt{k} super-diagonals stored in the argument \texttt{A}. Only the \hyperlink{13880289478825450693}{\texttt{uplo}} triangle of \texttt{A} is used.



\end{adjustwidth}
\hypertarget{7451827779071390643}{} 
\hyperlink{7451827779071390643}{\texttt{LinearAlgebra.BLAS.sbmv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sbmv(uplo, k, A, x)
\end{minted}

Return \texttt{A*x} where \texttt{A} is a symmetric band matrix of order \texttt{size(A,2)} with \texttt{k} super-diagonals stored in the argument \texttt{A}. Only the \hyperlink{13880289478825450693}{\texttt{uplo}} triangle of \texttt{A} is used.



\end{adjustwidth}
\hypertarget{8173170876588438683}{} 
\hyperlink{8173170876588438683}{\texttt{LinearAlgebra.BLAS.gemm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gemm!(tA, tB, alpha, A, B, beta, C)
\end{minted}

Update \texttt{C} as \texttt{alpha*A*B + beta*C} or the other three variants according to \hyperlink{15951037910221396131}{\texttt{tA}} and \texttt{tB}. Return the updated \texttt{C}.



\end{adjustwidth}
\hypertarget{12935993568670314935}{} 
\hyperlink{12935993568670314935}{\texttt{LinearAlgebra.BLAS.gemm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gemm(tA, tB, alpha, A, B)
\end{minted}

Return \texttt{alpha*A*B} or the other three variants according to \hyperlink{15951037910221396131}{\texttt{tA}} and \texttt{tB}.



\end{adjustwidth}
\hypertarget{10789182689496100432}{} 
\hyperlink{10789182689496100432}{\texttt{LinearAlgebra.BLAS.gemm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gemm(tA, tB, A, B)
\end{minted}

Return \texttt{A*B} or the other three variants according to \hyperlink{15951037910221396131}{\texttt{tA}} and \texttt{tB}.



\end{adjustwidth}
\hypertarget{11474194682797565787}{} 
\hyperlink{11474194682797565787}{\texttt{LinearAlgebra.BLAS.gemv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gemv!(tA, alpha, A, x, beta, y)
\end{minted}

Update the vector \texttt{y} as \texttt{alpha*A*x + beta*y} or \texttt{alpha*A{\textquotesingle}x + beta*y} according to \hyperlink{15951037910221396131}{\texttt{tA}}. \texttt{alpha} and \texttt{beta} are scalars. Return the updated \texttt{y}.



\end{adjustwidth}
\hypertarget{1491593334980744629}{} 
\hyperlink{1491593334980744629}{\texttt{LinearAlgebra.BLAS.gemv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gemv(tA, alpha, A, x)
\end{minted}

Return \texttt{alpha*A*x} or \texttt{alpha*A{\textquotesingle}x} according to \hyperlink{15951037910221396131}{\texttt{tA}}. \texttt{alpha} is a scalar.



\end{adjustwidth}
\hypertarget{10250669589948467576}{} 
\hyperlink{10250669589948467576}{\texttt{LinearAlgebra.BLAS.gemv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gemv(tA, A, x)
\end{minted}

Return \texttt{A*x} or \texttt{A{\textquotesingle}x} according to \hyperlink{15951037910221396131}{\texttt{tA}}.



\end{adjustwidth}
\hypertarget{8132740051631912637}{} 
\hyperlink{8132740051631912637}{\texttt{LinearAlgebra.BLAS.symm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
symm!(side, ul, alpha, A, B, beta, C)
\end{minted}

Update \texttt{C} as \texttt{alpha*A*B + beta*C} or \texttt{alpha*B*A + beta*C} according to \hyperlink{3128026147631247774}{\texttt{side}}. \texttt{A} is assumed to be symmetric. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used. Return the updated \texttt{C}.



\end{adjustwidth}
\hypertarget{14160843903859790944}{} 
\hyperlink{14160843903859790944}{\texttt{LinearAlgebra.BLAS.symm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
symm(side, ul, alpha, A, B)
\end{minted}

Return \texttt{alpha*A*B} or \texttt{alpha*B*A} according to \hyperlink{3128026147631247774}{\texttt{side}}. \texttt{A} is assumed to be symmetric. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used.



\end{adjustwidth}
\hypertarget{16069722670191405715}{} 
\hyperlink{16069722670191405715}{\texttt{LinearAlgebra.BLAS.symm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
symm(side, ul, A, B)
\end{minted}

Return \texttt{A*B} or \texttt{B*A} according to \hyperlink{3128026147631247774}{\texttt{side}}. \texttt{A} is assumed to be symmetric. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used.



\end{adjustwidth}
\hypertarget{11756106038468185414}{} 
\hyperlink{11756106038468185414}{\texttt{LinearAlgebra.BLAS.symv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
symv!(ul, alpha, A, x, beta, y)
\end{minted}

Update the vector \texttt{y} as \texttt{alpha*A*x + beta*y}. \texttt{A} is assumed to be symmetric. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used. \texttt{alpha} and \texttt{beta} are scalars. Return the updated \texttt{y}.



\end{adjustwidth}
\hypertarget{9719310770398023656}{} 
\hyperlink{9719310770398023656}{\texttt{LinearAlgebra.BLAS.symv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
symv(ul, alpha, A, x)
\end{minted}

Return \texttt{alpha*A*x}. \texttt{A} is assumed to be symmetric. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used. \texttt{alpha} is a scalar.



\end{adjustwidth}
\hypertarget{5603412151724289616}{} 
\hyperlink{5603412151724289616}{\texttt{LinearAlgebra.BLAS.symv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
symv(ul, A, x)
\end{minted}

Return \texttt{A*x}. \texttt{A} is assumed to be symmetric. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used.



\end{adjustwidth}
\hypertarget{16247072505934468966}{} 
\hyperlink{16247072505934468966}{\texttt{LinearAlgebra.BLAS.hemm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hemm!(side, ul, alpha, A, B, beta, C)
\end{minted}

Update \texttt{C} as \texttt{alpha*A*B + beta*C} or \texttt{alpha*B*A + beta*C} according to \hyperlink{3128026147631247774}{\texttt{side}}. \texttt{A} is assumed to be Hermitian. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used. Return the updated \texttt{C}.



\end{adjustwidth}
\hypertarget{6201781936415538210}{} 
\hyperlink{6201781936415538210}{\texttt{LinearAlgebra.BLAS.hemm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hemm(side, ul, alpha, A, B)
\end{minted}

Return \texttt{alpha*A*B} or \texttt{alpha*B*A} according to \hyperlink{3128026147631247774}{\texttt{side}}. \texttt{A} is assumed to be Hermitian. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used.



\end{adjustwidth}
\hypertarget{4698646581937392256}{} 
\hyperlink{4698646581937392256}{\texttt{LinearAlgebra.BLAS.hemm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hemm(side, ul, A, B)
\end{minted}

Return \texttt{A*B} or \texttt{B*A} according to \hyperlink{3128026147631247774}{\texttt{side}}. \texttt{A} is assumed to be Hermitian. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used.



\end{adjustwidth}
\hypertarget{9920007331130447492}{} 
\hyperlink{9920007331130447492}{\texttt{LinearAlgebra.BLAS.hemv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hemv!(ul, alpha, A, x, beta, y)
\end{minted}

Update the vector \texttt{y} as \texttt{alpha*A*x + beta*y}. \texttt{A} is assumed to be Hermitian. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used. \texttt{alpha} and \texttt{beta} are scalars. Return the updated \texttt{y}.



\end{adjustwidth}
\hypertarget{6944896949603577091}{} 
\hyperlink{6944896949603577091}{\texttt{LinearAlgebra.BLAS.hemv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hemv(ul, alpha, A, x)
\end{minted}

Return \texttt{alpha*A*x}. \texttt{A} is assumed to be Hermitian. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used. \texttt{alpha} is a scalar.



\end{adjustwidth}
\hypertarget{9526750005879662729}{} 
\hyperlink{9526750005879662729}{\texttt{LinearAlgebra.BLAS.hemv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hemv(ul, A, x)
\end{minted}

Return \texttt{A*x}. \texttt{A} is assumed to be Hermitian. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used.



\end{adjustwidth}
\hypertarget{8591334681358631512}{} 
\hyperlink{8591334681358631512}{\texttt{LinearAlgebra.BLAS.trmm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trmm!(side, ul, tA, dA, alpha, A, B)
\end{minted}

Update \texttt{B} as \texttt{alpha*A*B} or one of the other three variants determined by \hyperlink{3128026147631247774}{\texttt{side}} and \hyperlink{15951037910221396131}{\texttt{tA}}. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used. \hyperlink{285101993251198425}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones. Returns the updated \texttt{B}.



\end{adjustwidth}
\hypertarget{1143998968915321685}{} 
\hyperlink{1143998968915321685}{\texttt{LinearAlgebra.BLAS.trmm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trmm(side, ul, tA, dA, alpha, A, B)
\end{minted}

Returns \texttt{alpha*A*B} or one of the other three variants determined by \hyperlink{3128026147631247774}{\texttt{side}} and \hyperlink{15951037910221396131}{\texttt{tA}}. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used. \hyperlink{285101993251198425}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones.



\end{adjustwidth}
\hypertarget{3732597007619096495}{} 
\hyperlink{3732597007619096495}{\texttt{LinearAlgebra.BLAS.trsm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trsm!(side, ul, tA, dA, alpha, A, B)
\end{minted}

Overwrite \texttt{B} with the solution to \texttt{A*X = alpha*B} or one of the other three variants determined by \hyperlink{3128026147631247774}{\texttt{side}} and \hyperlink{15951037910221396131}{\texttt{tA}}. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used. \hyperlink{285101993251198425}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones. Returns the updated \texttt{B}.



\end{adjustwidth}
\hypertarget{5446048787435487351}{} 
\hyperlink{5446048787435487351}{\texttt{LinearAlgebra.BLAS.trsm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trsm(side, ul, tA, dA, alpha, A, B)
\end{minted}

Return the solution to \texttt{A*X = alpha*B} or one of the other three variants determined by determined by \hyperlink{3128026147631247774}{\texttt{side}} and \hyperlink{15951037910221396131}{\texttt{tA}}. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used. \hyperlink{285101993251198425}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones.



\end{adjustwidth}
\hypertarget{12526002304770163470}{} 
\hyperlink{12526002304770163470}{\texttt{LinearAlgebra.BLAS.trmv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trmv!(ul, tA, dA, A, b)
\end{minted}

Return \texttt{op(A)*b}, where \texttt{op} is determined by \hyperlink{15951037910221396131}{\texttt{tA}}. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used. \hyperlink{285101993251198425}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones. The multiplication occurs in-place on \texttt{b}.



\end{adjustwidth}
\hypertarget{17600708624629588635}{} 
\hyperlink{17600708624629588635}{\texttt{LinearAlgebra.BLAS.trmv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trmv(ul, tA, dA, A, b)
\end{minted}

Return \texttt{op(A)*b}, where \texttt{op} is determined by \hyperlink{15951037910221396131}{\texttt{tA}}. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used. \hyperlink{285101993251198425}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones.



\end{adjustwidth}
\hypertarget{10791367515297146957}{} 
\hyperlink{10791367515297146957}{\texttt{LinearAlgebra.BLAS.trsv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trsv!(ul, tA, dA, A, b)
\end{minted}

Overwrite \texttt{b} with the solution to \texttt{A*x = b} or one of the other two variants determined by \hyperlink{15951037910221396131}{\texttt{tA}} and \hyperlink{13880289478825450693}{\texttt{ul}}. \hyperlink{285101993251198425}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones. Return the updated \texttt{b}.



\end{adjustwidth}
\hypertarget{14529375247847983227}{} 
\hyperlink{14529375247847983227}{\texttt{LinearAlgebra.BLAS.trsv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trsv(ul, tA, dA, A, b)
\end{minted}

Return the solution to \texttt{A*x = b} or one of the other two variants determined by \hyperlink{15951037910221396131}{\texttt{tA}} and \hyperlink{13880289478825450693}{\texttt{ul}}. \hyperlink{285101993251198425}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones.



\end{adjustwidth}
\hypertarget{2145233402822007277}{} 
\hyperlink{2145233402822007277}{\texttt{LinearAlgebra.BLAS.set\_num\_threads}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
set_num_threads(n)
\end{minted}

Set the number of threads the BLAS library should use.



\end{adjustwidth}

\hypertarget{12227093091679014988}{}


\section{LAPACK functions}



\texttt{LinearAlgebra.LAPACK} provides wrappers for some of the LAPACK functions for linear algebra.  Those functions that overwrite one of the input arrays have names ending in \texttt{{\textquotesingle}!{\textquotesingle}}.



Usually a function has 4 methods defined, one each for \hyperlink{5027751419500983000}{\texttt{Float64}}, \hyperlink{8101639384272933082}{\texttt{Float32}}, \texttt{ComplexF64} and \texttt{ComplexF32} arrays.



Note that the LAPACK API provided by Julia can and will change in the future. Since this API is not user-facing, there is no commitment to support/deprecate this specific set of functions in future releases.


\hypertarget{5713679047114421298}{} 
\hyperlink{5713679047114421298}{\texttt{LinearAlgebra.LAPACK}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}

Interfaces to LAPACK subroutines.



\end{adjustwidth}
\hypertarget{4626964766607452194}{} 
\hyperlink{4626964766607452194}{\texttt{LinearAlgebra.LAPACK.gbtrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gbtrf!(kl, ku, m, AB) -> (AB, ipiv)
\end{minted}

Compute the LU factorization of a banded matrix \texttt{AB}. \texttt{kl} is the first subdiagonal containing a nonzero band, \texttt{ku} is the last superdiagonal containing one, and \texttt{m} is the first dimension of the matrix \texttt{AB}. Returns the LU factorization in-place and \texttt{ipiv}, the vector of pivots used.



\end{adjustwidth}
\hypertarget{6545699816764482655}{} 
\hyperlink{6545699816764482655}{\texttt{LinearAlgebra.LAPACK.gbtrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gbtrs!(trans, kl, ku, m, AB, ipiv, B)
\end{minted}

Solve the equation \texttt{AB * X = B}. \texttt{trans} determines the orientation of \texttt{AB}. It may be \texttt{N} (no transpose), \texttt{T} (transpose), or \texttt{C} (conjugate transpose). \texttt{kl} is the first subdiagonal containing a nonzero band, \texttt{ku} is the last superdiagonal containing one, and \texttt{m} is the first dimension of the matrix \texttt{AB}. \texttt{ipiv} is the vector of pivots returned from \texttt{gbtrf!}. Returns the vector or matrix \texttt{X}, overwriting \texttt{B} in-place.



\end{adjustwidth}
\hypertarget{16195720455630892558}{} 
\hyperlink{16195720455630892558}{\texttt{LinearAlgebra.LAPACK.gebal!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gebal!(job, A) -> (ilo, ihi, scale)
\end{minted}

Balance the matrix \texttt{A} before computing its eigensystem or Schur factorization. \texttt{job} can be one of \texttt{N} (\texttt{A} will not be permuted or scaled), \texttt{P} (\texttt{A} will only be permuted), \texttt{S} (\texttt{A} will only be scaled), or \texttt{B} (\texttt{A} will be both permuted and scaled). Modifies \texttt{A} in-place and returns \texttt{ilo}, \texttt{ihi}, and \texttt{scale}. If permuting was turned on, \texttt{A[i,j] = 0} if \texttt{j > i} and \texttt{1 < j < ilo} or \texttt{j > ihi}. \texttt{scale} contains information about the scaling/permutations performed.



\end{adjustwidth}
\hypertarget{6051699672892129595}{} 
\hyperlink{6051699672892129595}{\texttt{LinearAlgebra.LAPACK.gebak!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gebak!(job, side, ilo, ihi, scale, V)
\end{minted}

Transform the eigenvectors \texttt{V} of a matrix balanced using \texttt{gebal!} to the unscaled/unpermuted eigenvectors of the original matrix. Modifies \texttt{V} in-place. \texttt{side} can be \texttt{L} (left eigenvectors are transformed) or \texttt{R} (right eigenvectors are transformed).



\end{adjustwidth}
\hypertarget{12871648146516835346}{} 
\hyperlink{12871648146516835346}{\texttt{LinearAlgebra.LAPACK.gebrd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gebrd!(A) -> (A, d, e, tauq, taup)
\end{minted}

Reduce \texttt{A} in-place to bidiagonal form \texttt{A = QBP{\textquotesingle}}. Returns \texttt{A}, containing the bidiagonal matrix \texttt{B}; \texttt{d}, containing the diagonal elements of \texttt{B}; \texttt{e}, containing the off-diagonal elements of \texttt{B}; \texttt{tauq}, containing the elementary reflectors representing \texttt{Q}; and \texttt{taup}, containing the elementary reflectors representing \texttt{P}.



\end{adjustwidth}
\hypertarget{13832119342643409982}{} 
\hyperlink{13832119342643409982}{\texttt{LinearAlgebra.LAPACK.gelqf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gelqf!(A, tau)
\end{minted}

Compute the \texttt{LQ} factorization of \texttt{A}, \texttt{A = LQ}. \texttt{tau} contains scalars which parameterize the elementary reflectors of the factorization. \texttt{tau} must have length greater than or equal to the smallest dimension of \texttt{A}.

Returns \texttt{A} and \texttt{tau} modified in-place.




\begin{lstlisting}
gelqf!(A) -> (A, tau)
\end{lstlisting}

Compute the \texttt{LQ} factorization of \texttt{A}, \texttt{A = LQ}.

Returns \texttt{A}, modified in-place, and \texttt{tau}, which contains scalars which parameterize the elementary reflectors of the factorization.



\end{adjustwidth}
\hypertarget{870700918778332837}{} 
\hyperlink{870700918778332837}{\texttt{LinearAlgebra.LAPACK.geqlf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
geqlf!(A, tau)
\end{minted}

Compute the \texttt{QL} factorization of \texttt{A}, \texttt{A = QL}. \texttt{tau} contains scalars which parameterize the elementary reflectors of the factorization. \texttt{tau} must have length greater than or equal to the smallest dimension of \texttt{A}.

Returns \texttt{A} and \texttt{tau} modified in-place.




\begin{lstlisting}
geqlf!(A) -> (A, tau)
\end{lstlisting}

Compute the \texttt{QL} factorization of \texttt{A}, \texttt{A = QL}.

Returns \texttt{A}, modified in-place, and \texttt{tau}, which contains scalars which parameterize the elementary reflectors of the factorization.



\end{adjustwidth}
\hypertarget{1667844416130160920}{} 
\hyperlink{1667844416130160920}{\texttt{LinearAlgebra.LAPACK.geqrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
geqrf!(A, tau)
\end{minted}

Compute the \texttt{QR} factorization of \texttt{A}, \texttt{A = QR}. \texttt{tau} contains scalars which parameterize the elementary reflectors of the factorization. \texttt{tau} must have length greater than or equal to the smallest dimension of \texttt{A}.

Returns \texttt{A} and \texttt{tau} modified in-place.




\begin{lstlisting}
geqrf!(A) -> (A, tau)
\end{lstlisting}

Compute the \texttt{QR} factorization of \texttt{A}, \texttt{A = QR}.

Returns \texttt{A}, modified in-place, and \texttt{tau}, which contains scalars which parameterize the elementary reflectors of the factorization.



\end{adjustwidth}
\hypertarget{18183103848385216109}{} 
\hyperlink{18183103848385216109}{\texttt{LinearAlgebra.LAPACK.geqp3!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
geqp3!(A, jpvt, tau)
\end{minted}

Compute the pivoted \texttt{QR} factorization of \texttt{A}, \texttt{AP = QR} using BLAS level 3. \texttt{P} is a pivoting matrix, represented by \texttt{jpvt}. \texttt{tau} stores the elementary reflectors. \texttt{jpvt} must have length length greater than or equal to \texttt{n} if \texttt{A} is an \texttt{(m x n)} matrix. \texttt{tau} must have length greater than or equal to the smallest dimension of \texttt{A}.

\texttt{A}, \texttt{jpvt}, and \texttt{tau} are modified in-place.




\begin{lstlisting}
geqp3!(A, jpvt) -> (A, jpvt, tau)
\end{lstlisting}

Compute the pivoted \texttt{QR} factorization of \texttt{A}, \texttt{AP = QR} using BLAS level 3. \texttt{P} is a pivoting matrix, represented by \texttt{jpvt}. \texttt{jpvt} must have length greater than or equal to \texttt{n} if \texttt{A} is an \texttt{(m x n)} matrix.

Returns \texttt{A} and \texttt{jpvt}, modified in-place, and \texttt{tau}, which stores the elementary reflectors.




\begin{lstlisting}
geqp3!(A) -> (A, jpvt, tau)
\end{lstlisting}

Compute the pivoted \texttt{QR} factorization of \texttt{A}, \texttt{AP = QR} using BLAS level 3.

Returns \texttt{A}, modified in-place, \texttt{jpvt}, which represents the pivoting matrix \texttt{P}, and \texttt{tau}, which stores the elementary reflectors.



\end{adjustwidth}
\hypertarget{1345086231036394133}{} 
\hyperlink{1345086231036394133}{\texttt{LinearAlgebra.LAPACK.gerqf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gerqf!(A, tau)
\end{minted}

Compute the \texttt{RQ} factorization of \texttt{A}, \texttt{A = RQ}. \texttt{tau} contains scalars which parameterize the elementary reflectors of the factorization. \texttt{tau} must have length greater than or equal to the smallest dimension of \texttt{A}.

Returns \texttt{A} and \texttt{tau} modified in-place.




\begin{lstlisting}
gerqf!(A) -> (A, tau)
\end{lstlisting}

Compute the \texttt{RQ} factorization of \texttt{A}, \texttt{A = RQ}.

Returns \texttt{A}, modified in-place, and \texttt{tau}, which contains scalars which parameterize the elementary reflectors of the factorization.



\end{adjustwidth}
\hypertarget{6324071823423584289}{} 
\hyperlink{6324071823423584289}{\texttt{LinearAlgebra.LAPACK.geqrt!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
geqrt!(A, T)
\end{minted}

Compute the blocked \texttt{QR} factorization of \texttt{A}, \texttt{A = QR}. \texttt{T} contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization. The first dimension of \texttt{T} sets the block size and it must be between 1 and \texttt{n}. The second dimension of \texttt{T} must equal the smallest dimension of \texttt{A}.

Returns \texttt{A} and \texttt{T} modified in-place.




\begin{lstlisting}
geqrt!(A, nb) -> (A, T)
\end{lstlisting}

Compute the blocked \texttt{QR} factorization of \texttt{A}, \texttt{A = QR}. \texttt{nb} sets the block size and it must be between 1 and \texttt{n}, the second dimension of \texttt{A}.

Returns \texttt{A}, modified in-place, and \texttt{T}, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.



\end{adjustwidth}
\hypertarget{12471188723051727334}{} 
\hyperlink{12471188723051727334}{\texttt{LinearAlgebra.LAPACK.geqrt3!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
geqrt3!(A, T)
\end{minted}

Recursively computes the blocked \texttt{QR} factorization of \texttt{A}, \texttt{A = QR}. \texttt{T} contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.  The first dimension of \texttt{T} sets the block size and it must be between 1 and \texttt{n}. The second dimension of \texttt{T} must equal the smallest dimension of \texttt{A}.

Returns \texttt{A} and \texttt{T} modified in-place.




\begin{lstlisting}
geqrt3!(A) -> (A, T)
\end{lstlisting}

Recursively computes the blocked \texttt{QR} factorization of \texttt{A}, \texttt{A = QR}.

Returns \texttt{A}, modified in-place, and \texttt{T}, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.



\end{adjustwidth}
\hypertarget{2351778938398249720}{} 
\hyperlink{2351778938398249720}{\texttt{LinearAlgebra.LAPACK.getrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getrf!(A) -> (A, ipiv, info)
\end{minted}

Compute the pivoted \texttt{LU} factorization of \texttt{A}, \texttt{A = LU}.

Returns \texttt{A}, modified in-place, \texttt{ipiv}, the pivoting information, and an \texttt{info} code which indicates success (\texttt{info = 0}), a singular value in \texttt{U} (\texttt{info = i}, in which case \texttt{U[i,i]} is singular), or an error code (\texttt{info < 0}).



\end{adjustwidth}
\hypertarget{8099284094733410089}{} 
\hyperlink{8099284094733410089}{\texttt{LinearAlgebra.LAPACK.tzrzf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tzrzf!(A) -> (A, tau)
\end{minted}

Transforms the upper trapezoidal matrix \texttt{A} to upper triangular form in-place. Returns \texttt{A} and \texttt{tau}, the scalar parameters for the elementary reflectors of the transformation.



\end{adjustwidth}
\hypertarget{15550486828362807519}{} 
\hyperlink{15550486828362807519}{\texttt{LinearAlgebra.LAPACK.ormrz!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ormrz!(side, trans, A, tau, C)
\end{minted}

Multiplies the matrix \texttt{C} by \texttt{Q} from the transformation supplied by \texttt{tzrzf!}. Depending on \texttt{side} or \texttt{trans} the multiplication can be left-sided (\texttt{side = L, Q*C}) or right-sided (\texttt{side = R, C*Q}) and \texttt{Q} can be unmodified (\texttt{trans = N}), transposed (\texttt{trans = T}), or conjugate transposed (\texttt{trans = C}). Returns matrix \texttt{C} which is modified in-place with the result of the multiplication.



\end{adjustwidth}
\hypertarget{18299455515085793306}{} 
\hyperlink{18299455515085793306}{\texttt{LinearAlgebra.LAPACK.gels!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gels!(trans, A, B) -> (F, B, ssr)
\end{minted}

Solves the linear equation \texttt{A * X = B}, \texttt{transpose(A) * X = B}, or \texttt{adjoint(A) * X = B} using a QR or LQ factorization. Modifies the matrix/vector \texttt{B} in place with the solution. \texttt{A} is overwritten with its \texttt{QR} or \texttt{LQ} factorization. \texttt{trans} may be one of \texttt{N} (no modification), \texttt{T} (transpose), or \texttt{C} (conjugate transpose). \texttt{gels!} searches for the minimum norm/least squares solution. \texttt{A} may be under or over determined. The solution is returned in \texttt{B}.



\end{adjustwidth}
\hypertarget{1148095264829123239}{} 
\hyperlink{1148095264829123239}{\texttt{LinearAlgebra.LAPACK.gesv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gesv!(A, B) -> (B, A, ipiv)
\end{minted}

Solves the linear equation \texttt{A * X = B} where \texttt{A} is a square matrix using the \texttt{LU} factorization of \texttt{A}. \texttt{A} is overwritten with its \texttt{LU} factorization and \texttt{B} is overwritten with the solution \texttt{X}. \texttt{ipiv} contains the pivoting information for the \texttt{LU} factorization of \texttt{A}.



\end{adjustwidth}
\hypertarget{16091201483800894861}{} 
\hyperlink{16091201483800894861}{\texttt{LinearAlgebra.LAPACK.getrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getrs!(trans, A, ipiv, B)
\end{minted}

Solves the linear equation \texttt{A * X = B}, \texttt{transpose(A) * X = B}, or \texttt{adjoint(A) * X = B} for square \texttt{A}. Modifies the matrix/vector \texttt{B} in place with the solution. \texttt{A} is the \texttt{LU} factorization from \texttt{getrf!}, with \texttt{ipiv} the pivoting information. \texttt{trans} may be one of \texttt{N} (no modification), \texttt{T} (transpose), or \texttt{C} (conjugate transpose).



\end{adjustwidth}
\hypertarget{14980283213207275035}{} 
\hyperlink{14980283213207275035}{\texttt{LinearAlgebra.LAPACK.getri!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getri!(A, ipiv)
\end{minted}

Computes the inverse of \texttt{A}, using its \texttt{LU} factorization found by \texttt{getrf!}. \texttt{ipiv} is the pivot information output and \texttt{A} contains the \texttt{LU} factorization of \texttt{getrf!}. \texttt{A} is overwritten with its inverse.



\end{adjustwidth}
\hypertarget{11990298428229663507}{} 
\hyperlink{11990298428229663507}{\texttt{LinearAlgebra.LAPACK.gesvx!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gesvx!(fact, trans, A, AF, ipiv, equed, R, C, B) -> (X, equed, R, C, B, rcond, ferr, berr, work)
\end{minted}

Solves the linear equation \texttt{A * X = B} (\texttt{trans = N}), \texttt{transpose(A) * X = B} (\texttt{trans = T}), or \texttt{adjoint(A) * X = B} (\texttt{trans = C}) using the \texttt{LU} factorization of \texttt{A}. \texttt{fact} may be \texttt{E}, in which case \texttt{A} will be equilibrated and copied to \texttt{AF}; \texttt{F}, in which case \texttt{AF} and \texttt{ipiv} from a previous \texttt{LU} factorization are inputs; or \texttt{N}, in which case \texttt{A} will be copied to \texttt{AF} and then factored. If \texttt{fact = F}, \texttt{equed} may be \texttt{N}, meaning \texttt{A} has not been equilibrated; \texttt{R}, meaning \texttt{A} was multiplied by \texttt{Diagonal(R)} from the left; \texttt{C}, meaning \texttt{A} was multiplied by \texttt{Diagonal(C)} from the right; or \texttt{B}, meaning \texttt{A} was multiplied by \texttt{Diagonal(R)} from the left and \texttt{Diagonal(C)} from the right. If \texttt{fact = F} and \texttt{equed = R} or \texttt{B} the elements of \texttt{R} must all be positive. If \texttt{fact = F} and \texttt{equed = C} or \texttt{B} the elements of \texttt{C} must all be positive.

Returns the solution \texttt{X}; \texttt{equed}, which is an output if \texttt{fact} is not \texttt{N}, and describes the equilibration that was performed; \texttt{R}, the row equilibration diagonal; \texttt{C}, the column equilibration diagonal; \texttt{B}, which may be overwritten with its equilibrated form \texttt{Diagonal(R)*B} (if \texttt{trans = N} and \texttt{equed = R,B}) or \texttt{Diagonal(C)*B} (if \texttt{trans = T,C} and \texttt{equed = C,B}); \texttt{rcond}, the reciprocal condition number of \texttt{A} after equilbrating; \texttt{ferr}, the forward error bound for each solution vector in \texttt{X}; \texttt{berr}, the forward error bound for each solution vector in \texttt{X}; and \texttt{work}, the reciprocal pivot growth factor.




\begin{lstlisting}
gesvx!(A, B)
\end{lstlisting}

The no-equilibration, no-transpose simplification of \texttt{gesvx!}.



\end{adjustwidth}
\hypertarget{9350383558985209547}{} 
\hyperlink{9350383558985209547}{\texttt{LinearAlgebra.LAPACK.gelsd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gelsd!(A, B, rcond) -> (B, rnk)
\end{minted}

Computes the least norm solution of \texttt{A * X = B} by finding the \texttt{SVD} factorization of \texttt{A}, then dividing-and-conquering the problem. \texttt{B} is overwritten with the solution \texttt{X}. Singular values below \texttt{rcond} will be treated as zero. Returns the solution in \texttt{B} and the effective rank of \texttt{A} in \texttt{rnk}.



\end{adjustwidth}
\hypertarget{4643805579678817866}{} 
\hyperlink{4643805579678817866}{\texttt{LinearAlgebra.LAPACK.gelsy!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gelsy!(A, B, rcond) -> (B, rnk)
\end{minted}

Computes the least norm solution of \texttt{A * X = B} by finding the full \texttt{QR} factorization of \texttt{A}, then dividing-and-conquering the problem. \texttt{B} is overwritten with the solution \texttt{X}. Singular values below \texttt{rcond} will be treated as zero. Returns the solution in \texttt{B} and the effective rank of \texttt{A} in \texttt{rnk}.



\end{adjustwidth}
\hypertarget{6779153008628150661}{} 
\hyperlink{6779153008628150661}{\texttt{LinearAlgebra.LAPACK.gglse!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gglse!(A, c, B, d) -> (X,res)
\end{minted}

Solves the equation \texttt{A * x = c} where \texttt{x} is subject to the equality constraint \texttt{B * x = d}. Uses the formula \texttt{||c - A*x||{\textasciicircum}2 = 0} to solve. Returns \texttt{X} and the residual sum-of-squares.



\end{adjustwidth}
\hypertarget{6944763016389470144}{} 
\hyperlink{6944763016389470144}{\texttt{LinearAlgebra.LAPACK.geev!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
geev!(jobvl, jobvr, A) -> (W, VL, VR)
\end{minted}

Finds the eigensystem of \texttt{A}. If \texttt{jobvl = N}, the left eigenvectors of \texttt{A} aren{\textquotesingle}t computed. If \texttt{jobvr = N}, the right eigenvectors of \texttt{A} aren{\textquotesingle}t computed. If \texttt{jobvl = V} or \texttt{jobvr = V}, the corresponding eigenvectors are computed. Returns the eigenvalues in \texttt{W}, the right eigenvectors in \texttt{VR}, and the left eigenvectors in \texttt{VL}.



\end{adjustwidth}
\hypertarget{15765350085042341790}{} 
\hyperlink{15765350085042341790}{\texttt{LinearAlgebra.LAPACK.gesdd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gesdd!(job, A) -> (U, S, VT)
\end{minted}

Finds the singular value decomposition of \texttt{A}, \texttt{A = U * S * V{\textquotesingle}}, using a divide and conquer approach. If \texttt{job = A}, all the columns of \texttt{U} and the rows of \texttt{V{\textquotesingle}} are computed. If \texttt{job = N}, no columns of \texttt{U} or rows of \texttt{V{\textquotesingle}} are computed. If \texttt{job = O}, \texttt{A} is overwritten with the columns of (thin) \texttt{U} and the rows of (thin) \texttt{V{\textquotesingle}}. If \texttt{job = S}, the columns of (thin) \texttt{U} and the rows of (thin) \texttt{V{\textquotesingle}} are computed and returned separately.



\end{adjustwidth}
\hypertarget{12815780161722855374}{} 
\hyperlink{12815780161722855374}{\texttt{LinearAlgebra.LAPACK.gesvd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gesvd!(jobu, jobvt, A) -> (U, S, VT)
\end{minted}

Finds the singular value decomposition of \texttt{A}, \texttt{A = U * S * V{\textquotesingle}}. If \texttt{jobu = A}, all the columns of \texttt{U} are computed. If \texttt{jobvt = A} all the rows of \texttt{V{\textquotesingle}} are computed. If \texttt{jobu = N}, no columns of \texttt{U} are computed. If \texttt{jobvt = N} no rows of \texttt{V{\textquotesingle}} are computed. If \texttt{jobu = O}, \texttt{A} is overwritten with the columns of (thin) \texttt{U}. If \texttt{jobvt = O}, \texttt{A} is overwritten with the rows of (thin) \texttt{V{\textquotesingle}}. If \texttt{jobu = S}, the columns of (thin) \texttt{U} are computed and returned separately. If \texttt{jobvt = S} the rows of (thin) \texttt{V{\textquotesingle}} are computed and returned separately. \texttt{jobu} and \texttt{jobvt} can{\textquotesingle}t both be \texttt{O}.

Returns \texttt{U}, \texttt{S}, and \texttt{Vt}, where \texttt{S} are the singular values of \texttt{A}.



\end{adjustwidth}
\hypertarget{1835214761811297196}{} 
\hyperlink{1835214761811297196}{\texttt{LinearAlgebra.LAPACK.ggsvd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ggsvd!(jobu, jobv, jobq, A, B) -> (U, V, Q, alpha, beta, k, l, R)
\end{minted}

Finds the generalized singular value decomposition of \texttt{A} and \texttt{B}, \texttt{U{\textquotesingle}*A*Q = D1*R} and \texttt{V{\textquotesingle}*B*Q = D2*R}. \texttt{D1} has \texttt{alpha} on its diagonal and \texttt{D2} has \texttt{beta} on its diagonal. If \texttt{jobu = U}, the orthogonal/unitary matrix \texttt{U} is computed. If \texttt{jobv = V} the orthogonal/unitary matrix \texttt{V} is computed. If \texttt{jobq = Q}, the orthogonal/unitary matrix \texttt{Q} is computed. If \texttt{jobu}, \texttt{jobv} or \texttt{jobq} is \texttt{N}, that matrix is not computed. This function is only available in LAPACK versions prior to 3.6.0.



\end{adjustwidth}
\hypertarget{14749391167207110611}{} 
\hyperlink{14749391167207110611}{\texttt{LinearAlgebra.LAPACK.ggsvd3!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ggsvd3!(jobu, jobv, jobq, A, B) -> (U, V, Q, alpha, beta, k, l, R)
\end{minted}

Finds the generalized singular value decomposition of \texttt{A} and \texttt{B}, \texttt{U{\textquotesingle}*A*Q = D1*R} and \texttt{V{\textquotesingle}*B*Q = D2*R}. \texttt{D1} has \texttt{alpha} on its diagonal and \texttt{D2} has \texttt{beta} on its diagonal. If \texttt{jobu = U}, the orthogonal/unitary matrix \texttt{U} is computed. If \texttt{jobv = V} the orthogonal/unitary matrix \texttt{V} is computed. If \texttt{jobq = Q}, the orthogonal/unitary matrix \texttt{Q} is computed. If \texttt{jobu}, \texttt{jobv}, or \texttt{jobq} is \texttt{N}, that matrix is not computed. This function requires LAPACK 3.6.0.



\end{adjustwidth}
\hypertarget{13160568642977439323}{} 
\hyperlink{13160568642977439323}{\texttt{LinearAlgebra.LAPACK.geevx!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
geevx!(balanc, jobvl, jobvr, sense, A) -> (A, w, VL, VR, ilo, ihi, scale, abnrm, rconde, rcondv)
\end{minted}

Finds the eigensystem of \texttt{A} with matrix balancing. If \texttt{jobvl = N}, the left eigenvectors of \texttt{A} aren{\textquotesingle}t computed. If \texttt{jobvr = N}, the right eigenvectors of \texttt{A} aren{\textquotesingle}t computed. If \texttt{jobvl = V} or \texttt{jobvr = V}, the corresponding eigenvectors are computed. If \texttt{balanc = N}, no balancing is performed. If \texttt{balanc = P}, \texttt{A} is permuted but not scaled. If \texttt{balanc = S}, \texttt{A} is scaled but not permuted. If \texttt{balanc = B}, \texttt{A} is permuted and scaled. If \texttt{sense = N}, no reciprocal condition numbers are computed. If \texttt{sense = E}, reciprocal condition numbers are computed for the eigenvalues only. If \texttt{sense = V}, reciprocal condition numbers are computed for the right eigenvectors only. If \texttt{sense = B}, reciprocal condition numbers are computed for the right eigenvectors and the eigenvectors. If \texttt{sense = E,B}, the right and left eigenvectors must be computed.



\end{adjustwidth}
\hypertarget{11158917129247885932}{} 
\hyperlink{11158917129247885932}{\texttt{LinearAlgebra.LAPACK.ggev!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ggev!(jobvl, jobvr, A, B) -> (alpha, beta, vl, vr)
\end{minted}

Finds the generalized eigendecomposition of \texttt{A} and \texttt{B}. If \texttt{jobvl = N}, the left eigenvectors aren{\textquotesingle}t computed. If \texttt{jobvr = N}, the right eigenvectors aren{\textquotesingle}t computed. If \texttt{jobvl = V} or \texttt{jobvr = V}, the corresponding eigenvectors are computed.



\end{adjustwidth}
\hypertarget{445174240052873549}{} 
\hyperlink{445174240052873549}{\texttt{LinearAlgebra.LAPACK.gtsv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gtsv!(dl, d, du, B)
\end{minted}

Solves the equation \texttt{A * X = B} where \texttt{A} is a tridiagonal matrix with \texttt{dl} on the subdiagonal, \texttt{d} on the diagonal, and \texttt{du} on the superdiagonal.

Overwrites \texttt{B} with the solution \texttt{X} and returns it.



\end{adjustwidth}
\hypertarget{9597724514453362317}{} 
\hyperlink{9597724514453362317}{\texttt{LinearAlgebra.LAPACK.gttrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gttrf!(dl, d, du) -> (dl, d, du, du2, ipiv)
\end{minted}

Finds the \texttt{LU} factorization of a tridiagonal matrix with \texttt{dl} on the subdiagonal, \texttt{d} on the diagonal, and \texttt{du} on the superdiagonal.

Modifies \texttt{dl}, \texttt{d}, and \texttt{du} in-place and returns them and the second superdiagonal \texttt{du2} and the pivoting vector \texttt{ipiv}.



\end{adjustwidth}
\hypertarget{3087963688650638106}{} 
\hyperlink{3087963688650638106}{\texttt{LinearAlgebra.LAPACK.gttrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gttrs!(trans, dl, d, du, du2, ipiv, B)
\end{minted}

Solves the equation \texttt{A * X = B} (\texttt{trans = N}), \texttt{transpose(A) * X = B} (\texttt{trans = T}), or \texttt{adjoint(A) * X = B} (\texttt{trans = C}) using the \texttt{LU} factorization computed by \texttt{gttrf!}. \texttt{B} is overwritten with the solution \texttt{X}.



\end{adjustwidth}
\hypertarget{1878598872812530666}{} 
\hyperlink{1878598872812530666}{\texttt{LinearAlgebra.LAPACK.orglq!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
orglq!(A, tau, k = length(tau))
\end{minted}

Explicitly finds the matrix \texttt{Q} of a \texttt{LQ} factorization after calling \texttt{gelqf!} on \texttt{A}. Uses the output of \texttt{gelqf!}. \texttt{A} is overwritten by \texttt{Q}.



\end{adjustwidth}
\hypertarget{17543646888056798280}{} 
\hyperlink{17543646888056798280}{\texttt{LinearAlgebra.LAPACK.orgqr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
orgqr!(A, tau, k = length(tau))
\end{minted}

Explicitly finds the matrix \texttt{Q} of a \texttt{QR} factorization after calling \texttt{geqrf!} on \texttt{A}. Uses the output of \texttt{geqrf!}. \texttt{A} is overwritten by \texttt{Q}.



\end{adjustwidth}
\hypertarget{15842803237247761842}{} 
\hyperlink{15842803237247761842}{\texttt{LinearAlgebra.LAPACK.orgql!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
orgql!(A, tau, k = length(tau))
\end{minted}

Explicitly finds the matrix \texttt{Q} of a \texttt{QL} factorization after calling \texttt{geqlf!} on \texttt{A}. Uses the output of \texttt{geqlf!}. \texttt{A} is overwritten by \texttt{Q}.



\end{adjustwidth}
\hypertarget{9300570426687705008}{} 
\hyperlink{9300570426687705008}{\texttt{LinearAlgebra.LAPACK.orgrq!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
orgrq!(A, tau, k = length(tau))
\end{minted}

Explicitly finds the matrix \texttt{Q} of a \texttt{RQ} factorization after calling \texttt{gerqf!} on \texttt{A}. Uses the output of \texttt{gerqf!}. \texttt{A} is overwritten by \texttt{Q}.



\end{adjustwidth}
\hypertarget{6791415432360539771}{} 
\hyperlink{6791415432360539771}{\texttt{LinearAlgebra.LAPACK.ormlq!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ormlq!(side, trans, A, tau, C)
\end{minted}

Computes \texttt{Q * C} (\texttt{trans = N}), \texttt{transpose(Q) * C} (\texttt{trans = T}), \texttt{adjoint(Q) * C} (\texttt{trans = C}) for \texttt{side = L} or the equivalent right-sided multiplication for \texttt{side = R} using \texttt{Q} from a \texttt{LQ} factorization of \texttt{A} computed using \texttt{gelqf!}. \texttt{C} is overwritten.



\end{adjustwidth}
\hypertarget{4642443581739897648}{} 
\hyperlink{4642443581739897648}{\texttt{LinearAlgebra.LAPACK.ormqr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ormqr!(side, trans, A, tau, C)
\end{minted}

Computes \texttt{Q * C} (\texttt{trans = N}), \texttt{transpose(Q) * C} (\texttt{trans = T}), \texttt{adjoint(Q) * C} (\texttt{trans = C}) for \texttt{side = L} or the equivalent right-sided multiplication for \texttt{side = R} using \texttt{Q} from a \texttt{QR} factorization of \texttt{A} computed using \texttt{geqrf!}. \texttt{C} is overwritten.



\end{adjustwidth}
\hypertarget{8769001276299575898}{} 
\hyperlink{8769001276299575898}{\texttt{LinearAlgebra.LAPACK.ormql!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ormql!(side, trans, A, tau, C)
\end{minted}

Computes \texttt{Q * C} (\texttt{trans = N}), \texttt{transpose(Q) * C} (\texttt{trans = T}), \texttt{adjoint(Q) * C} (\texttt{trans = C}) for \texttt{side = L} or the equivalent right-sided multiplication for \texttt{side = R} using \texttt{Q} from a \texttt{QL} factorization of \texttt{A} computed using \texttt{geqlf!}. \texttt{C} is overwritten.



\end{adjustwidth}
\hypertarget{5502331798377291988}{} 
\hyperlink{5502331798377291988}{\texttt{LinearAlgebra.LAPACK.ormrq!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ormrq!(side, trans, A, tau, C)
\end{minted}

Computes \texttt{Q * C} (\texttt{trans = N}), \texttt{transpose(Q) * C} (\texttt{trans = T}), \texttt{adjoint(Q) * C} (\texttt{trans = C}) for \texttt{side = L} or the equivalent right-sided multiplication for \texttt{side = R} using \texttt{Q} from a \texttt{RQ} factorization of \texttt{A} computed using \texttt{gerqf!}. \texttt{C} is overwritten.



\end{adjustwidth}
\hypertarget{15151573161204836324}{} 
\hyperlink{15151573161204836324}{\texttt{LinearAlgebra.LAPACK.gemqrt!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gemqrt!(side, trans, V, T, C)
\end{minted}

Computes \texttt{Q * C} (\texttt{trans = N}), \texttt{transpose(Q) * C} (\texttt{trans = T}), \texttt{adjoint(Q) * C} (\texttt{trans = C}) for \texttt{side = L} or the equivalent right-sided multiplication for \texttt{side = R} using \texttt{Q} from a \texttt{QR} factorization of \texttt{A} computed using \texttt{geqrt!}. \texttt{C} is overwritten.



\end{adjustwidth}
\hypertarget{7595784839671568962}{} 
\hyperlink{7595784839671568962}{\texttt{LinearAlgebra.LAPACK.posv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
posv!(uplo, A, B) -> (A, B)
\end{minted}

Finds the solution to \texttt{A * X = B} where \texttt{A} is a symmetric or Hermitian positive definite matrix. If \texttt{uplo = U} the upper Cholesky decomposition of \texttt{A} is computed. If \texttt{uplo = L} the lower Cholesky decomposition of \texttt{A} is computed. \texttt{A} is overwritten by its Cholesky decomposition. \texttt{B} is overwritten with the solution \texttt{X}.



\end{adjustwidth}
\hypertarget{15056431266921985441}{} 
\hyperlink{15056431266921985441}{\texttt{LinearAlgebra.LAPACK.potrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
potrf!(uplo, A)
\end{minted}

Computes the Cholesky (upper if \texttt{uplo = U}, lower if \texttt{uplo = L}) decomposition of positive-definite matrix \texttt{A}. \texttt{A} is overwritten and returned with an info code.



\end{adjustwidth}
\hypertarget{17784788688709608363}{} 
\hyperlink{17784788688709608363}{\texttt{LinearAlgebra.LAPACK.potri!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
potri!(uplo, A)
\end{minted}

Computes the inverse of positive-definite matrix \texttt{A} after calling \texttt{potrf!} to find its (upper if \texttt{uplo = U}, lower if \texttt{uplo = L}) Cholesky decomposition.

\texttt{A} is overwritten by its inverse and returned.



\end{adjustwidth}
\hypertarget{13026081165818770600}{} 
\hyperlink{13026081165818770600}{\texttt{LinearAlgebra.LAPACK.potrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
potrs!(uplo, A, B)
\end{minted}

Finds the solution to \texttt{A * X = B} where \texttt{A} is a symmetric or Hermitian positive definite matrix whose Cholesky decomposition was computed by \texttt{potrf!}. If \texttt{uplo = U} the upper Cholesky decomposition of \texttt{A} was computed. If \texttt{uplo = L} the lower Cholesky decomposition of \texttt{A} was computed. \texttt{B} is overwritten with the solution \texttt{X}.



\end{adjustwidth}
\hypertarget{15908768904043509489}{} 
\hyperlink{15908768904043509489}{\texttt{LinearAlgebra.LAPACK.pstrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pstrf!(uplo, A, tol) -> (A, piv, rank, info)
\end{minted}

Computes the (upper if \texttt{uplo = U}, lower if \texttt{uplo = L}) pivoted Cholesky decomposition of positive-definite matrix \texttt{A} with a user-set tolerance \texttt{tol}. \texttt{A} is overwritten by its Cholesky decomposition.

Returns \texttt{A}, the pivots \texttt{piv}, the rank of \texttt{A}, and an \texttt{info} code. If \texttt{info = 0}, the factorization succeeded. If \texttt{info = i > 0}, then \texttt{A} is indefinite or rank-deficient.



\end{adjustwidth}
\hypertarget{10214325419469953635}{} 
\hyperlink{10214325419469953635}{\texttt{LinearAlgebra.LAPACK.ptsv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ptsv!(D, E, B)
\end{minted}

Solves \texttt{A * X = B} for positive-definite tridiagonal \texttt{A}. \texttt{D} is the diagonal of \texttt{A} and \texttt{E} is the off-diagonal. \texttt{B} is overwritten with the solution \texttt{X} and returned.



\end{adjustwidth}
\hypertarget{9537322497705664212}{} 
\hyperlink{9537322497705664212}{\texttt{LinearAlgebra.LAPACK.pttrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pttrf!(D, E)
\end{minted}

Computes the LDLt factorization of a positive-definite tridiagonal matrix with \texttt{D} as diagonal and \texttt{E} as off-diagonal. \texttt{D} and \texttt{E} are overwritten and returned.



\end{adjustwidth}
\hypertarget{17187703179587619260}{} 
\hyperlink{17187703179587619260}{\texttt{LinearAlgebra.LAPACK.pttrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pttrs!(D, E, B)
\end{minted}

Solves \texttt{A * X = B} for positive-definite tridiagonal \texttt{A} with diagonal \texttt{D} and off-diagonal \texttt{E} after computing \texttt{A}{\textquotesingle}s LDLt factorization using \texttt{pttrf!}. \texttt{B} is overwritten with the solution \texttt{X}.



\end{adjustwidth}
\hypertarget{16492831209199043329}{} 
\hyperlink{16492831209199043329}{\texttt{LinearAlgebra.LAPACK.trtri!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trtri!(uplo, diag, A)
\end{minted}

Finds the inverse of (upper if \texttt{uplo = U}, lower if \texttt{uplo = L}) triangular matrix \texttt{A}. If \texttt{diag = N}, \texttt{A} has non-unit diagonal elements. If \texttt{diag = U}, all diagonal elements of \texttt{A} are one. \texttt{A} is overwritten with its inverse.



\end{adjustwidth}
\hypertarget{1291729511408073349}{} 
\hyperlink{1291729511408073349}{\texttt{LinearAlgebra.LAPACK.trtrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trtrs!(uplo, trans, diag, A, B)
\end{minted}

Solves \texttt{A * X = B} (\texttt{trans = N}), \texttt{transpose(A) * X = B} (\texttt{trans = T}), or \texttt{adjoint(A) * X = B} (\texttt{trans = C}) for (upper if \texttt{uplo = U}, lower if \texttt{uplo = L}) triangular matrix \texttt{A}. If \texttt{diag = N}, \texttt{A} has non-unit diagonal elements. If \texttt{diag = U}, all diagonal elements of \texttt{A} are one. \texttt{B} is overwritten with the solution \texttt{X}.



\end{adjustwidth}
\hypertarget{9926413427788620088}{} 
\hyperlink{9926413427788620088}{\texttt{LinearAlgebra.LAPACK.trcon!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trcon!(norm, uplo, diag, A)
\end{minted}

Finds the reciprocal condition number of (upper if \texttt{uplo = U}, lower if \texttt{uplo = L}) triangular matrix \texttt{A}. If \texttt{diag = N}, \texttt{A} has non-unit diagonal elements. If \texttt{diag = U}, all diagonal elements of \texttt{A} are one. If \texttt{norm = I}, the condition number is found in the infinity norm. If \texttt{norm = O} or \texttt{1}, the condition number is found in the one norm.



\end{adjustwidth}
\hypertarget{7491620034849793338}{} 
\hyperlink{7491620034849793338}{\texttt{LinearAlgebra.LAPACK.trevc!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trevc!(side, howmny, select, T, VL = similar(T), VR = similar(T))
\end{minted}

Finds the eigensystem of an upper triangular matrix \texttt{T}. If \texttt{side = R}, the right eigenvectors are computed. If \texttt{side = L}, the left eigenvectors are computed. If \texttt{side = B}, both sets are computed. If \texttt{howmny = A}, all eigenvectors are found. If \texttt{howmny = B}, all eigenvectors are found and backtransformed using \texttt{VL} and \texttt{VR}. If \texttt{howmny = S}, only the eigenvectors corresponding to the values in \texttt{select} are computed.



\end{adjustwidth}
\hypertarget{17047065310014133867}{} 
\hyperlink{17047065310014133867}{\texttt{LinearAlgebra.LAPACK.trrfs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trrfs!(uplo, trans, diag, A, B, X, Ferr, Berr) -> (Ferr, Berr)
\end{minted}

Estimates the error in the solution to \texttt{A * X = B} (\texttt{trans = N}), \texttt{transpose(A) * X = B} (\texttt{trans = T}), \texttt{adjoint(A) * X = B} (\texttt{trans = C}) for \texttt{side = L}, or the equivalent equations a right-handed \texttt{side = R} \texttt{X * A} after computing \texttt{X} using \texttt{trtrs!}. If \texttt{uplo = U}, \texttt{A} is upper triangular. If \texttt{uplo = L}, \texttt{A} is lower triangular. If \texttt{diag = N}, \texttt{A} has non-unit diagonal elements. If \texttt{diag = U}, all diagonal elements of \texttt{A} are one. \texttt{Ferr} and \texttt{Berr} are optional inputs. \texttt{Ferr} is the forward error and \texttt{Berr} is the backward error, each component-wise.



\end{adjustwidth}
\hypertarget{14670728896781161925}{} 
\hyperlink{14670728896781161925}{\texttt{LinearAlgebra.LAPACK.stev!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stev!(job, dv, ev) -> (dv, Zmat)
\end{minted}

Computes the eigensystem for a symmetric tridiagonal matrix with \texttt{dv} as diagonal and \texttt{ev} as off-diagonal. If \texttt{job = N} only the eigenvalues are found and returned in \texttt{dv}. If \texttt{job = V} then the eigenvectors are also found and returned in \texttt{Zmat}.



\end{adjustwidth}
\hypertarget{10865649637100518709}{} 
\hyperlink{10865649637100518709}{\texttt{LinearAlgebra.LAPACK.stebz!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stebz!(range, order, vl, vu, il, iu, abstol, dv, ev) -> (dv, iblock, isplit)
\end{minted}

Computes the eigenvalues for a symmetric tridiagonal matrix with \texttt{dv} as diagonal and \texttt{ev} as off-diagonal. If \texttt{range = A}, all the eigenvalues are found. If \texttt{range = V}, the eigenvalues in the half-open interval \texttt{(vl, vu]} are found. If \texttt{range = I}, the eigenvalues with indices between \texttt{il} and \texttt{iu} are found. If \texttt{order = B}, eigvalues are ordered within a block. If \texttt{order = E}, they are ordered across all the blocks. \texttt{abstol} can be set as a tolerance for convergence.



\end{adjustwidth}
\hypertarget{18007684687736525555}{} 
\hyperlink{18007684687736525555}{\texttt{LinearAlgebra.LAPACK.stegr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stegr!(jobz, range, dv, ev, vl, vu, il, iu) -> (w, Z)
\end{minted}

Computes the eigenvalues (\texttt{jobz = N}) or eigenvalues and eigenvectors (\texttt{jobz = V}) for a symmetric tridiagonal matrix with \texttt{dv} as diagonal and \texttt{ev} as off-diagonal. If \texttt{range = A}, all the eigenvalues are found. If \texttt{range = V}, the eigenvalues in the half-open interval \texttt{(vl, vu]} are found. If \texttt{range = I}, the eigenvalues with indices between \texttt{il} and \texttt{iu} are found. The eigenvalues are returned in \texttt{w} and the eigenvectors in \texttt{Z}.



\end{adjustwidth}
\hypertarget{4475992932708638755}{} 
\hyperlink{4475992932708638755}{\texttt{LinearAlgebra.LAPACK.stein!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stein!(dv, ev_in, w_in, iblock_in, isplit_in)
\end{minted}

Computes the eigenvectors for a symmetric tridiagonal matrix with \texttt{dv} as diagonal and \texttt{ev\_in} as off-diagonal. \texttt{w\_in} specifies the input eigenvalues for which to find corresponding eigenvectors. \texttt{iblock\_in} specifies the submatrices corresponding to the eigenvalues in \texttt{w\_in}. \texttt{isplit\_in} specifies the splitting points between the submatrix blocks.



\end{adjustwidth}
\hypertarget{7330295151672323275}{} 
\hyperlink{7330295151672323275}{\texttt{LinearAlgebra.LAPACK.syconv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
syconv!(uplo, A, ipiv) -> (A, work)
\end{minted}

Converts a symmetric matrix \texttt{A} (which has been factorized into a triangular matrix) into two matrices \texttt{L} and \texttt{D}. If \texttt{uplo = U}, \texttt{A} is upper triangular. If \texttt{uplo = L}, it is lower triangular. \texttt{ipiv} is the pivot vector from the triangular factorization. \texttt{A} is overwritten by \texttt{L} and \texttt{D}.



\end{adjustwidth}
\hypertarget{9619199705618830828}{} 
\hyperlink{9619199705618830828}{\texttt{LinearAlgebra.LAPACK.sysv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sysv!(uplo, A, B) -> (B, A, ipiv)
\end{minted}

Finds the solution to \texttt{A * X = B} for symmetric matrix \texttt{A}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored. \texttt{B} is overwritten by the solution \texttt{X}. \texttt{A} is overwritten by its Bunch-Kaufman factorization. \texttt{ipiv} contains pivoting information about the factorization.



\end{adjustwidth}
\hypertarget{4323538288339311968}{} 
\hyperlink{4323538288339311968}{\texttt{LinearAlgebra.LAPACK.sytrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sytrf!(uplo, A) -> (A, ipiv, info)
\end{minted}

Computes the Bunch-Kaufman factorization of a symmetric matrix \texttt{A}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored.

Returns \texttt{A}, overwritten by the factorization, a pivot vector \texttt{ipiv}, and the error code \texttt{info} which is a non-negative integer. If \texttt{info} is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position \texttt{info}.



\end{adjustwidth}
\hypertarget{16079738955302816092}{} 
\hyperlink{16079738955302816092}{\texttt{LinearAlgebra.LAPACK.sytri!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sytri!(uplo, A, ipiv)
\end{minted}

Computes the inverse of a symmetric matrix \texttt{A} using the results of \texttt{sytrf!}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored. \texttt{A} is overwritten by its inverse.



\end{adjustwidth}
\hypertarget{1871905390771924166}{} 
\hyperlink{1871905390771924166}{\texttt{LinearAlgebra.LAPACK.sytrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sytrs!(uplo, A, ipiv, B)
\end{minted}

Solves the equation \texttt{A * X = B} for a symmetric matrix \texttt{A} using the results of \texttt{sytrf!}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored. \texttt{B} is overwritten by the solution \texttt{X}.



\end{adjustwidth}
\hypertarget{4935444719459229500}{} 
\hyperlink{4935444719459229500}{\texttt{LinearAlgebra.LAPACK.hesv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hesv!(uplo, A, B) -> (B, A, ipiv)
\end{minted}

Finds the solution to \texttt{A * X = B} for Hermitian matrix \texttt{A}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored. \texttt{B} is overwritten by the solution \texttt{X}. \texttt{A} is overwritten by its Bunch-Kaufman factorization. \texttt{ipiv} contains pivoting information about the factorization.



\end{adjustwidth}
\hypertarget{13823783742790511702}{} 
\hyperlink{13823783742790511702}{\texttt{LinearAlgebra.LAPACK.hetrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hetrf!(uplo, A) -> (A, ipiv, info)
\end{minted}

Computes the Bunch-Kaufman factorization of a Hermitian matrix \texttt{A}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored.

Returns \texttt{A}, overwritten by the factorization, a pivot vector \texttt{ipiv}, and the error code \texttt{info} which is a non-negative integer. If \texttt{info} is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position \texttt{info}.



\end{adjustwidth}
\hypertarget{3196814042515994361}{} 
\hyperlink{3196814042515994361}{\texttt{LinearAlgebra.LAPACK.hetri!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hetri!(uplo, A, ipiv)
\end{minted}

Computes the inverse of a Hermitian matrix \texttt{A} using the results of \texttt{sytrf!}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored. \texttt{A} is overwritten by its inverse.



\end{adjustwidth}
\hypertarget{16647495205297911695}{} 
\hyperlink{16647495205297911695}{\texttt{LinearAlgebra.LAPACK.hetrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hetrs!(uplo, A, ipiv, B)
\end{minted}

Solves the equation \texttt{A * X = B} for a Hermitian matrix \texttt{A} using the results of \texttt{sytrf!}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored. \texttt{B} is overwritten by the solution \texttt{X}.



\end{adjustwidth}
\hypertarget{9979432299825280284}{} 
\hyperlink{9979432299825280284}{\texttt{LinearAlgebra.LAPACK.syev!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
syev!(jobz, uplo, A)
\end{minted}

Finds the eigenvalues (\texttt{jobz = N}) or eigenvalues and eigenvectors (\texttt{jobz = V}) of a symmetric matrix \texttt{A}. If \texttt{uplo = U}, the upper triangle of \texttt{A} is used. If \texttt{uplo = L}, the lower triangle of \texttt{A} is used.



\end{adjustwidth}
\hypertarget{9325824410810690137}{} 
\hyperlink{9325824410810690137}{\texttt{LinearAlgebra.LAPACK.syevr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
syevr!(jobz, range, uplo, A, vl, vu, il, iu, abstol) -> (W, Z)
\end{minted}

Finds the eigenvalues (\texttt{jobz = N}) or eigenvalues and eigenvectors (\texttt{jobz = V}) of a symmetric matrix \texttt{A}. If \texttt{uplo = U}, the upper triangle of \texttt{A} is used. If \texttt{uplo = L}, the lower triangle of \texttt{A} is used. If \texttt{range = A}, all the eigenvalues are found. If \texttt{range = V}, the eigenvalues in the half-open interval \texttt{(vl, vu]} are found. If \texttt{range = I}, the eigenvalues with indices between \texttt{il} and \texttt{iu} are found. \texttt{abstol} can be set as a tolerance for convergence.

The eigenvalues are returned in \texttt{W} and the eigenvectors in \texttt{Z}.



\end{adjustwidth}
\hypertarget{8632196472915375761}{} 
\hyperlink{8632196472915375761}{\texttt{LinearAlgebra.LAPACK.sygvd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sygvd!(itype, jobz, uplo, A, B) -> (w, A, B)
\end{minted}

Finds the generalized eigenvalues (\texttt{jobz = N}) or eigenvalues and eigenvectors (\texttt{jobz = V}) of a symmetric matrix \texttt{A} and symmetric positive-definite matrix \texttt{B}. If \texttt{uplo = U}, the upper triangles of \texttt{A} and \texttt{B} are used. If \texttt{uplo = L}, the lower triangles of \texttt{A} and \texttt{B} are used. If \texttt{itype = 1}, the problem to solve is \texttt{A * x = lambda * B * x}. If \texttt{itype = 2}, the problem to solve is \texttt{A * B * x = lambda * x}. If \texttt{itype = 3}, the problem to solve is \texttt{B * A * x = lambda * x}.



\end{adjustwidth}
\hypertarget{13657736097940764011}{} 
\hyperlink{13657736097940764011}{\texttt{LinearAlgebra.LAPACK.bdsqr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
bdsqr!(uplo, d, e_, Vt, U, C) -> (d, Vt, U, C)
\end{minted}

Computes the singular value decomposition of a bidiagonal matrix with \texttt{d} on the diagonal and \texttt{e\_} on the off-diagonal. If \texttt{uplo = U}, \texttt{e\_} is the superdiagonal. If \texttt{uplo = L}, \texttt{e\_} is the subdiagonal. Can optionally also compute the product \texttt{Q{\textquotesingle} * C}.

Returns the singular values in \texttt{d}, and the matrix \texttt{C} overwritten with \texttt{Q{\textquotesingle} * C}.



\end{adjustwidth}
\hypertarget{2117266507846761835}{} 
\hyperlink{2117266507846761835}{\texttt{LinearAlgebra.LAPACK.bdsdc!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
bdsdc!(uplo, compq, d, e_) -> (d, e, u, vt, q, iq)
\end{minted}

Computes the singular value decomposition of a bidiagonal matrix with \texttt{d} on the diagonal and \texttt{e\_} on the off-diagonal using a divide and conqueq method. If \texttt{uplo = U}, \texttt{e\_} is the superdiagonal. If \texttt{uplo = L}, \texttt{e\_} is the subdiagonal. If \texttt{compq = N}, only the singular values are found. If \texttt{compq = I}, the singular values and vectors are found. If \texttt{compq = P}, the singular values and vectors are found in compact form. Only works for real types.

Returns the singular values in \texttt{d}, and if \texttt{compq = P}, the compact singular vectors in \texttt{iq}.



\end{adjustwidth}
\hypertarget{3277861361503147277}{} 
\hyperlink{3277861361503147277}{\texttt{LinearAlgebra.LAPACK.gecon!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gecon!(normtype, A, anorm)
\end{minted}

Finds the reciprocal condition number of matrix \texttt{A}. If \texttt{normtype = I}, the condition number is found in the infinity norm. If \texttt{normtype = O} or \texttt{1}, the condition number is found in the one norm. \texttt{A} must be the result of \texttt{getrf!} and \texttt{anorm} is the norm of \texttt{A} in the relevant norm.



\end{adjustwidth}
\hypertarget{14367369116295032587}{} 
\hyperlink{14367369116295032587}{\texttt{LinearAlgebra.LAPACK.gehrd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gehrd!(ilo, ihi, A) -> (A, tau)
\end{minted}

Converts a matrix \texttt{A} to Hessenberg form. If \texttt{A} is balanced with \texttt{gebal!} then \texttt{ilo} and \texttt{ihi} are the outputs of \texttt{gebal!}. Otherwise they should be \texttt{ilo = 1} and \texttt{ihi = size(A,2)}. \texttt{tau} contains the elementary reflectors of the factorization.



\end{adjustwidth}
\hypertarget{17531257454072185780}{} 
\hyperlink{17531257454072185780}{\texttt{LinearAlgebra.LAPACK.orghr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
orghr!(ilo, ihi, A, tau)
\end{minted}

Explicitly finds \texttt{Q}, the orthogonal/unitary matrix from \texttt{gehrd!}. \texttt{ilo}, \texttt{ihi}, \texttt{A}, and \texttt{tau} must correspond to the input/output to \texttt{gehrd!}.



\end{adjustwidth}
\hypertarget{7554800805540125473}{} 
\hyperlink{7554800805540125473}{\texttt{LinearAlgebra.LAPACK.gees!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gees!(jobvs, A) -> (A, vs, w)
\end{minted}

Computes the eigenvalues (\texttt{jobvs = N}) or the eigenvalues and Schur vectors (\texttt{jobvs = V}) of matrix \texttt{A}. \texttt{A} is overwritten by its Schur form.

Returns \texttt{A}, \texttt{vs} containing the Schur vectors, and \texttt{w}, containing the eigenvalues.



\end{adjustwidth}
\hypertarget{9858205807823882594}{} 
\hyperlink{9858205807823882594}{\texttt{LinearAlgebra.LAPACK.gges!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gges!(jobvsl, jobvsr, A, B) -> (A, B, alpha, beta, vsl, vsr)
\end{minted}

Computes the generalized eigenvalues, generalized Schur form, left Schur vectors (\texttt{jobsvl = V}), or right Schur vectors (\texttt{jobvsr = V}) of \texttt{A} and \texttt{B}.

The generalized eigenvalues are returned in \texttt{alpha} and \texttt{beta}. The left Schur vectors are returned in \texttt{vsl} and the right Schur vectors are returned in \texttt{vsr}.



\end{adjustwidth}
\hypertarget{16392841550634697146}{} 
\hyperlink{16392841550634697146}{\texttt{LinearAlgebra.LAPACK.trexc!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trexc!(compq, ifst, ilst, T, Q) -> (T, Q)
\end{minted}

Reorder the Schur factorization of a matrix. If \texttt{compq = V}, the Schur vectors \texttt{Q} are reordered. If \texttt{compq = N} they are not modified. \texttt{ifst} and \texttt{ilst} specify the reordering of the vectors.



\end{adjustwidth}
\hypertarget{14222318539033253394}{} 
\hyperlink{14222318539033253394}{\texttt{LinearAlgebra.LAPACK.trsen!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trsen!(compq, job, select, T, Q) -> (T, Q, w, s, sep)
\end{minted}

Reorder the Schur factorization of a matrix and optionally finds reciprocal condition numbers. If \texttt{job = N}, no condition numbers are found. If \texttt{job = E}, only the condition number for this cluster of eigenvalues is found. If \texttt{job = V}, only the condition number for the invariant subspace is found. If \texttt{job = B} then the condition numbers for the cluster and subspace are found. If \texttt{compq = V} the Schur vectors \texttt{Q} are updated. If \texttt{compq = N} the Schur vectors are not modified. \texttt{select} determines which eigenvalues are in the cluster.

Returns \texttt{T}, \texttt{Q}, reordered eigenvalues in \texttt{w}, the condition number of the cluster of eigenvalues \texttt{s}, and the condition number of the invariant subspace \texttt{sep}.



\end{adjustwidth}
\hypertarget{4226534331460521506}{} 
\hyperlink{4226534331460521506}{\texttt{LinearAlgebra.LAPACK.tgsen!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tgsen!(select, S, T, Q, Z) -> (S, T, alpha, beta, Q, Z)
\end{minted}

Reorders the vectors of a generalized Schur decomposition. \texttt{select} specifies the eigenvalues in each cluster.



\end{adjustwidth}
\hypertarget{853281004697696312}{} 
\hyperlink{853281004697696312}{\texttt{LinearAlgebra.LAPACK.trsyl!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trsyl!(transa, transb, A, B, C, isgn=1) -> (C, scale)
\end{minted}

Solves the Sylvester matrix equation \texttt{A * X +/- X * B = scale*C} where \texttt{A} and \texttt{B} are both quasi-upper triangular. If \texttt{transa = N}, \texttt{A} is not modified. If \texttt{transa = T}, \texttt{A} is transposed. If \texttt{transa = C}, \texttt{A} is conjugate transposed. Similarly for \texttt{transb} and \texttt{B}. If \texttt{isgn = 1}, the equation \texttt{A * X + X * B = scale * C} is solved. If \texttt{isgn = -1}, the equation \texttt{A * X - X * B = scale * C} is solved.

Returns \texttt{X} (overwriting \texttt{C}) and \texttt{scale}.



\end{adjustwidth}



\hypertarget{16565866334883334127}{}


\chapter{日志记录}



The \hyperlink{1488091939099076420}{\texttt{Logging}} module provides a way to record the history and progress of a computation as a log of events.  Events are created by inserting a logging statement into the source code, for example:




\begin{minted}{julia}
@warn "Abandon printf debugging, all ye who enter here!"
┌ Warning: Abandon printf debugging, all ye who enter here!
└ @ Main REPL[1]:1
\end{minted}



The system provides several advantages over peppering your source code with calls to \texttt{println()}.  First, it allows you to control the visibility and presentation of messages without editing the source code.  For example, in contrast to the \texttt{@warn} above




\begin{minted}{julia}
@debug "The sum of some values $(sum(rand(100)))"
\end{minted}



will produce no output by default.  Furthermore, it{\textquotesingle}s very cheap to leave debug statements like this in the source code because the system avoids evaluating the message if it would later be ignored.  In this case \texttt{sum(rand(100))} and the associated string processing will never be executed unless debug logging is enabled.



Second, the logging tools allow you to attach arbitrary data to each event as a set of key–value pairs. This allows you to capture local variables and other program state for later analysis. For example, to attach the local array variable \texttt{A} and the sum of a vector \texttt{v} as the key \texttt{s} you can use




\begin{minted}{julia}
A = ones(Int, 4, 4)
v = ones(100)
@info "Some variables"  A  s=sum(v)

# 输出：
┌ Info: Some variables
│   A =
│    4×4 Array{Int64,2}:
│     1  1  1  1
│     1  1  1  1
│     1  1  1  1
│     1  1  1  1
└   s = 100.0
\end{minted}



All of the logging macros \texttt{@debug}, \texttt{@info}, \texttt{@warn} and \texttt{@error} share common features that are described in detail in the documentation for the more general macro \hyperlink{2787319849348710857}{\texttt{@logmsg}}.



\hypertarget{16412881529124994328}{}


\section{日志事件结构}



Each event generates several pieces of data, some provided by the user and some automatically extracted. Let{\textquotesingle}s examine the user-defined data first:



\begin{itemize}
\item The \emph{log level} is a broad category for the message that is used for early filtering. There are several standard levels of type \hyperlink{10879938884267981707}{\texttt{LogLevel}}; user-defined levels are also possible. Each is distinct in purpose:

\begin{itemize}
\item \texttt{Debug} is information intended for the developer of the program.

\end{itemize}
These events are disabled by default.

\begin{itemize}
\item \texttt{Info} is for general information to the user.

\end{itemize}
Think of it as an alternative to using \texttt{println} directly.

\begin{itemize}
\item \texttt{Warn} means something is wrong and action is likely required

\end{itemize}
but that for now the program is still working.

\begin{itemize}
\item \texttt{Error} means something is wrong and it is unlikely to be recovered,

\end{itemize}
at least by this part of the code. Often this log-level is unneeded as throwing an exception can convey all the required information.


\item The \emph{message}  is an object describing the event. By convention \texttt{AbstractString}s passed as messages are assumed to be in markdown format. Other types will be displayed using \texttt{print(io, obj)} or \texttt{string(obj)} for text-based output and possibly \texttt{show(io,mime,obj)} for other multimedia displays used in the installed logger.


\item Optional \emph{key–value pairs} allow arbitrary data to be attached to each event. Some keys have conventional meaning that can affect the way an event is interpreted (see \hyperlink{2787319849348710857}{\texttt{@logmsg}}).

\end{itemize}


The system also generates some standard information for each event:



\begin{itemize}
\item The \texttt{module} in which the logging macro was expanded.


\item The \texttt{file} and \texttt{line} where the logging macro occurs in the source code.


\item A message \texttt{id} that is a unique, fixed identifier for the \emph{source code statement} where the logging macro appears. This identifier is designed to be fairly stable even if the source code of the file changes, as long as the logging statement itself remains the same.


\item A \texttt{group} for the event, which is set to the base name of the file by default, without extension.  This can be used to group messages into categories more finely than the log level (for example, all deprecation warnings have group \texttt{:depwarn}), or into logical groupings across or within modules.

\end{itemize}


Notice that some useful information such as the event time is not included by default. This is because such information can be expensive to extract and is also \emph{dynamically} available to the current logger. It{\textquotesingle}s simple to define a \hyperlink{8132992094414010061}{custom logger} to augment event data with the time, backtrace, values of global variables and other useful information as required.



\hypertarget{1246485954867051804}{}


\section{Processing log events}



As you can see in the examples, logging statements make no mention of where log events go or how they are processed. This is a key design feature that makes the system composable and natural for concurrent use. It does this by separating two different concerns:



\begin{itemize}
\item \emph{Creating} log events is the concern of the module author who needs to decide where events are triggered and which information to include.


\item \emph{Processing} of log events — that is, display, filtering, aggregation and recording — is the concern of the application author who needs to bring multiple modules together into a cooperating application.

\end{itemize}


\hypertarget{9118034371113309221}{}


\subsection{Loggers}



Processing of events is performed by a \emph{logger}, which is the first piece of user configurable code to see the event. All loggers must be subtypes of \hyperlink{16983066617679297643}{\texttt{AbstractLogger}}.



When an event is triggered, the appropriate logger is found by looking for a task-local logger with the global logger as fallback.  The idea here is that the application code knows how log events should be processed and exists somewhere at the top of the call stack. So we should look up through the call stack to discover the logger — that is, the logger should be \emph{dynamically scoped}. (This is a point of contrast with logging frameworks where the logger is \emph{lexically scoped}; provided explicitly by the module author or as a simple global variable. In such a system it{\textquotesingle}s awkward to control logging while composing functionality from multiple modules.)



The global logger may be set with \hyperlink{4306559652149699055}{\texttt{global\_logger}}, and task-local loggers controlled using \hyperlink{14383079235362132941}{\texttt{with\_logger}}.  Newly spawned tasks inherit the logger of the parent task.



There are three logger types provided by the library.  \hyperlink{14105182192150729642}{\texttt{ConsoleLogger}} is the default logger you see when starting the REPL.  It displays events in a readable text format and tries to give simple but user friendly control over formatting and filtering.  \hyperlink{15508205197393226825}{\texttt{NullLogger}} is a convenient way to drop all messages where necessary; it is the logging equivalent of the \hyperlink{13412111234074215621}{\texttt{devnull}} stream.  \hyperlink{206724342092815568}{\texttt{SimpleLogger}} is a very simplistic text formatting logger, mainly useful for debugging the logging system itself.



Custom loggers should come with overloads for the functions described in the \hyperlink{8132992094414010061}{reference section}.



\hypertarget{6918254684898348274}{}


\subsection{Early filtering and message handling}



When an event occurs, a few steps of early filtering occur to avoid generating messages that will be discarded:



\begin{itemize}
\item[1. ] The message log level is checked against a global minimum level (set via \hyperlink{10677278458507378523}{\texttt{disable\_logging}}).  This is a crude but extremely cheap global setting.


\item[2. ] The current logger state is looked up and the message level checked against the logger{\textquotesingle}s cached minimum level, as found by calling \hyperlink{1177702033979282781}{\texttt{Logging.min\_enabled\_level}}. This behavior can be overridden via environment variables (more on this later).


\item[3. ] The \hyperlink{10642364941499317938}{\texttt{Logging.shouldlog}} function is called with the current logger, taking some minimal information (level, module, group, id) which can be computed statically.  Most usefully, \texttt{shouldlog} is passed an event \texttt{id} which can be used to discard events early based on a cached predicate.

\end{itemize}


If all these checks pass, the message and key–value pairs are evaluated in full and passed to the current logger via the \hyperlink{1528450952930149457}{\texttt{Logging.handle\_message}} function. \texttt{handle\_message()} may perform additional filtering as required and display the event to the screen, save it to a file, etc.



Exceptions that occur while generating the log event are captured and logged by default.  This prevents individual broken events from crashing the application, which is helpful when enabling little-used debug events in a production system.  This behavior can be customized per logger type by extending \hyperlink{13546483368377724892}{\texttt{Logging.catch\_exceptions}}.



\hypertarget{5760891326467658260}{}


\section{Testing log events}



Log events are a side effect of running normal code, but you might find yourself wanting to test particular informational messages and warnings. The \texttt{Test} module provides a \hyperlink{1395021091279173086}{\texttt{@test\_logs}} macro that can be used to pattern match against the log event stream.



\hypertarget{2137823180188774840}{}


\section{Environment variables}



Message filtering can be influenced through the \texttt{JULIA\_DEBUG} environment variable, and serves as an easy way to enable debug logging for a file or module. For example, loading julia with \texttt{JULIA\_DEBUG=loading} will activate \texttt{@debug} log messages in \texttt{loading.jl}:




\begin{lstlisting}
$ JULIA_DEBUG=loading julia -e 'using OhMyREPL'
┌ Debug: Rejecting cache file /home/user/.julia/compiled/v0.7/OhMyREPL.ji due to it containing an invalid cache header
└ @ Base loading.jl:1328
[ Info: Recompiling stale cache file /home/user/.julia/compiled/v0.7/OhMyREPL.ji for module OhMyREPL
┌ Debug: Rejecting cache file /home/user/.julia/compiled/v0.7/Tokenize.ji due to it containing an invalid cache header
└ @ Base loading.jl:1328
...
\end{lstlisting}



Similarly, the environment variable can be used to enable debug logging of modules, such as \texttt{Pkg}, or module roots (see \hyperlink{10679300263900972054}{\texttt{Base.moduleroot}}). To enable all debug logging, use the special value \texttt{all}.



To turn debug logging on from the REPL, set \texttt{ENV[{\textquotedbl}JULIA\_DEBUG{\textquotedbl}]} to the name of the module of interest. Functions defined in the REPL belong to module \texttt{Main}; logging for them can be enabled like this:




\begin{minted}{jlcon}
julia> foo() = @debug "foo"
foo (generic function with 1 method)

julia> foo()

julia> ENV["JULIA_DEBUG"] = Main
Main

julia> foo()
┌ Debug: foo
└ @ Main REPL[1]:1

\end{minted}



\hypertarget{13723157150790493828}{}


\section{Writing log events to a file}



Sometimes it can be useful to write log events to a file. Here is an example of how to use a task-local and global logger to write information to a text file:




\begin{minted}{jlcon}
# Load the logging module
julia> using Logging

# Open a textfile for writing
julia> io = open("log.txt", "w+")
IOStream(<file log.txt>)

# Create a simple logger
julia> logger = SimpleLogger(io)
SimpleLogger(IOStream(<file log.txt>), Info, Dict{Any,Int64}())

# Log a task-specific message
julia> with_logger(logger) do
           @info("a context specific log message")
       end

# Write all buffered messages to the file
julia> flush(io)

# Set the global logger to logger
julia> global_logger(logger)
SimpleLogger(IOStream(<file log.txt>), Info, Dict{Any,Int64}())

# This message will now also be written to the file
julia> @info("a global log message")

# Close the file
julia> close(io)
\end{minted}



\hypertarget{15956208855154540711}{}


\section{Reference}



\hypertarget{9952495786425959332}{}


\subsection{Logging module}


\hypertarget{1488091939099076420}{} 
\hyperlink{1488091939099076420}{\texttt{Logging.Logging}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}

Utilities for capturing, filtering and presenting streams of log events. Normally you don{\textquotesingle}t need to import \texttt{Logging} to create log events; for this the standard logging macros such as \texttt{@info} are already exported by \texttt{Base} and available by default.



\end{adjustwidth}

\hypertarget{16245113775601037343}{}


\subsection{Creating events}


\hypertarget{2787319849348710857}{} 
\hyperlink{2787319849348710857}{\texttt{Logging.@logmsg}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@debug message  [key=value | value ...]
@info  message  [key=value | value ...]
@warn  message  [key=value | value ...]
@error message  [key=value | value ...]

@logmsg level message [key=value | value ...]
\end{minted}

Create a log record with an informational \texttt{message}.  For convenience, four logging macros \texttt{@debug}, \texttt{@info}, \texttt{@warn} and \texttt{@error} are defined which log at the standard severity levels \texttt{Debug}, \texttt{Info}, \texttt{Warn} and \texttt{Error}.  \texttt{@logmsg} allows \texttt{level} to be set programmatically to any \texttt{LogLevel} or custom log level types.

\texttt{message} should be an expression which evaluates to a string which is a human readable description of the log event.  By convention, this string will be formatted as markdown when presented.

The optional list of \texttt{key=value} pairs supports arbitrary user defined metadata which will be passed through to the logging backend as part of the log record.  If only a \texttt{value} expression is supplied, a key representing the expression will be generated using \hyperlink{18332791376992528422}{\texttt{Symbol}}. For example, \texttt{x} becomes \texttt{x=x}, and \texttt{foo(10)} becomes \texttt{Symbol({\textquotedbl}foo(10){\textquotedbl})=foo(10)}.  For splatting a list of key value pairs, use the normal splatting syntax, \texttt{@info {\textquotedbl}blah{\textquotedbl} kws...}.

There are some keys which allow automatically generated log data to be overridden:

\begin{itemize}
\item \texttt{\_module=mod} can be used to specify a different originating module from the source location of the message.


\item \texttt{\_group=symbol} can be used to override the message group (this is normally derived from the base name of the source file).


\item \texttt{\_id=symbol} can be used to override the automatically generated unique message identifier.  This is useful if you need to very closely associate messages generated on different source lines.


\item \texttt{\_file=string} and \texttt{\_line=integer} can be used to override the apparent source location of a log message.

\end{itemize}
There{\textquotesingle}s also some key value pairs which have conventional meaning:

\begin{itemize}
\item \texttt{maxlog=integer} should be used as a hint to the backend that the message should be displayed no more than \texttt{maxlog} times.


\item \texttt{exception=ex} should be used to transport an exception with a log message, often used with \texttt{@error}. An associated backtrace \texttt{bt} may be attached using the tuple \texttt{exception=(ex,bt)}.

\end{itemize}
\textbf{Examples}


\begin{lstlisting}
@debug "Verbose debugging information.  Invisible by default"
@info  "An informational message"
@warn  "Something was odd.  You should pay attention"
@error "A non fatal error occurred"

x = 10
@info "Some variables attached to the message" x a=42.0

@debug begin
    sA = sum(A)
    "sum(A) = $sA is an expensive operation, evaluated only when `shouldlog` returns true"
end

for i=1:10000
    @info "With the default backend, you will only see (i = $i) ten times"  maxlog=10
    @debug "Algorithm1" i progress=i/10000
end
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L219-L286}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10879938884267981707}{} 
\hyperlink{10879938884267981707}{\texttt{Logging.LogLevel}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LogLevel(level)
\end{minted}

Severity/verbosity of a log record.

The log level provides a key against which potential log records may be filtered, before any other work is done to construct the log record data structure itself.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L91-L99}{\texttt{source}}


\end{adjustwidth}

\hypertarget{10335028777960461011}{}


\subsection{Processing events with AbstractLogger}



Event processing is controlled by overriding functions associated with \texttt{AbstractLogger}:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Methods to implement &  & Brief description \\
\hline
\hyperlink{1528450952930149457}{\texttt{Logging.handle\_message}} &  & Handle a log event \\
\hline
\hyperlink{10642364941499317938}{\texttt{Logging.shouldlog}} &  & Early filtering of events \\
\hline
\hyperlink{1177702033979282781}{\texttt{Logging.min\_enabled\_level}} &  & Lower bound for log level of accepted events \\
\hline
\textbf{Optional methods} & \textbf{Default definition} & \textbf{Brief description} \\
\hline
\hyperlink{13546483368377724892}{\texttt{Logging.catch\_exceptions}} & \texttt{true} & Catch exceptions during event evaluation \\
\hline
\end{tabulary}

\end{table}


\hypertarget{16983066617679297643}{} 
\hyperlink{16983066617679297643}{\texttt{Logging.AbstractLogger}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

A logger controls how log records are filtered and dispatched.  When a log record is generated, the logger is the first piece of user configurable code which gets to inspect the record and decide what to do with it.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L24-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1528450952930149457}{} 
\hyperlink{1528450952930149457}{\texttt{Logging.handle\_message}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
handle_message(logger, level, message, _module, group, id, file, line; key1=val1, ...)
\end{minted}

Log a message to \texttt{logger} at \texttt{level}.  The logical location at which the message was generated is given by module \texttt{\_module} and \texttt{group}; the source location by \texttt{file} and \texttt{line}. \texttt{id} is an arbitrary unique value (typically a \hyperlink{18332791376992528422}{\texttt{Symbol}}) to be used as a key to identify the log statement when filtering.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L31-L39}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10642364941499317938}{} 
\hyperlink{10642364941499317938}{\texttt{Logging.shouldlog}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
shouldlog(logger, level, _module, group, id)
\end{minted}

Return true when \texttt{logger} accepts a message at \texttt{level}, generated for \texttt{\_module}, \texttt{group} and with unique log identifier \texttt{id}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L42-L47}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1177702033979282781}{} 
\hyperlink{1177702033979282781}{\texttt{Logging.min\_enabled\_level}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
min_enabled_level(logger)
\end{minted}

Return the minimum enabled level for \texttt{logger} for early filtering.  That is, the log level below or equal to which all messages are filtered.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L50-L55}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13546483368377724892}{} 
\hyperlink{13546483368377724892}{\texttt{Logging.catch\_exceptions}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
catch_exceptions(logger)
\end{minted}

Return true if the logger should catch exceptions which happen during log record construction.  By default, messages are caught

By default all exceptions are caught to prevent log message generation from crashing the program.  This lets users confidently toggle little-used functionality - such as debug logging - in a production system.

If you want to use logging as an audit trail you should disable this for your logger type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L58-L70}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10677278458507378523}{} 
\hyperlink{10677278458507378523}{\texttt{Logging.disable\_logging}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
disable_logging(level)
\end{minted}

Disable all log messages at log levels equal to or less than \texttt{level}.  This is a \emph{global} setting, intended to make debug logging extremely cheap when disabled.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L408-L414}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14824596935687234191}{}


\subsection{Using Loggers}



Logger installation and inspection:


\hypertarget{4306559652149699055}{} 
\hyperlink{4306559652149699055}{\texttt{Logging.global\_logger}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
global_logger()
\end{minted}

Return the global logger, used to receive messages when no specific logger exists for the current task.


\begin{lstlisting}
global_logger(logger)
\end{lstlisting}

Set the global logger to \texttt{logger}, and return the previous global logger.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L469-L478}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14383079235362132941}{} 
\hyperlink{14383079235362132941}{\texttt{Logging.with\_logger}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
with_logger(function, logger)
\end{minted}

Execute \texttt{function}, directing all log messages to \texttt{logger}.

\textbf{Example}


\begin{minted}{julia}
function test(x)
    @info "x = $x"
end

with_logger(logger) do
    test(1)
    test([1,2])
end
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L487-L504}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1207364331935599285}{} 
\hyperlink{1207364331935599285}{\texttt{Logging.current\_logger}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
current_logger()
\end{minted}

Return the logger for the current task, or the global logger if none is attached to the task.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L507-L512}{\texttt{source}}


\end{adjustwidth}

Loggers that are supplied with the system:


\hypertarget{15508205197393226825}{} 
\hyperlink{15508205197393226825}{\texttt{Logging.NullLogger}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
NullLogger()
\end{minted}

Logger which disables all messages and produces no output - the logger equivalent of /dev/null.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L75-L80}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14105182192150729642}{} 
\hyperlink{14105182192150729642}{\texttt{Logging.ConsoleLogger}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ConsoleLogger(stream=stderr, min_level=Info; meta_formatter=default_metafmt,
              show_limited=true, right_justify=0)
\end{minted}

Logger with formatting optimized for readability in a text console, for example interactive work with the Julia REPL.

Log levels less than \texttt{min\_level} are filtered out.

Message formatting can be controlled by setting keyword arguments:

\begin{itemize}
\item \texttt{meta\_formatter} is a function which takes the log event metadata \texttt{(level, \_module, group, id, file, line)} and returns a color (as would be passed to printstyled), prefix and suffix for the log message.  The default is to prefix with the log level and a suffix containing the module, file and line location.


\item \texttt{show\_limited} limits the printing of large data structures to something which can fit on the screen by setting the \texttt{:limit} \texttt{IOContext} key during formatting.


\item \texttt{right\_justify} is the integer column which log metadata is right justified at. The default is zero (metadata goes on its own line).

\end{itemize}


\end{adjustwidth}
\hypertarget{206724342092815568}{} 
\hyperlink{206724342092815568}{\texttt{Logging.SimpleLogger}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SimpleLogger(stream=stderr, min_level=Info)
\end{minted}

Simplistic logger for logging all messages with level greater than or equal to \texttt{min\_level} to \texttt{stream}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L518-L523}{\texttt{source}}


\end{adjustwidth}

\hypertarget{6677165778934209668}{}


\chapter{Markdown}



This section describes Julia{\textquotesingle}s markdown syntax, which is enabled by the Markdown standard library. The following Markdown elements are supported:



\hypertarget{8063626144587397226}{}


\section{Inline elements}



Here {\textquotedbl}inline{\textquotedbl} refers to elements that can be found within blocks of text, i.e. paragraphs. These include the following elements.



\hypertarget{10166533682417016306}{}


\subsection{Bold}



Surround words with two asterisks, \texttt{**}, to display the enclosed text in boldface.




\begin{lstlisting}
A paragraph containing a **bold** word.
\end{lstlisting}



\hypertarget{4277603997710742460}{}


\subsection{Italics}



Surround words with one asterisk, \texttt{*}, to display the enclosed text in italics.




\begin{lstlisting}
A paragraph containing an *italicized* word.
\end{lstlisting}



\hypertarget{6850088772867679045}{}


\subsection{Literals}



Surround text that should be displayed exactly as written with single backticks, \texttt{`} .




\begin{lstlisting}
A paragraph containing a `literal` word.
\end{lstlisting}



Literals should be used when writing text that refers to names of variables, functions, or other parts of a Julia program.



\begin{quote}
\textbf{Tip}

To include a backtick character within literal text use three backticks rather than one to enclose the text.


\begin{lstlisting}
A paragraph containing ``` `backtick` characters ```.
\end{lstlisting}

By extension any odd number of backticks may be used to enclose a lesser number of backticks.

\end{quote}


\hypertarget{6917271240677862304}{}


\subsection{ \LaTeX }



Surround text that should be displayed as mathematics using  \LaTeX  syntax with double backticks, \texttt{``} .




\begin{lstlisting}
A paragraph containing some ``\LaTeX`` markup.
\end{lstlisting}



\begin{quote}
\textbf{Tip}

As with literals in the previous section, if literal backticks need to be written within double backticks use an even number greater than two. Note that if a single literal backtick needs to be included within  \LaTeX  markup then two enclosing backticks is sufficient.

\end{quote}


\begin{quote}
\textbf{Note}

The \texttt{{\textbackslash}} character should be escaped appropriately if the text is embedded in a Julia source code, for example, \texttt{{\textquotedbl}``{\textbackslash}{\textbackslash}LaTeX`` syntax in a docstring.{\textquotedbl}}, since it is interpreted as a string literal. Alternatively, in order to avoid escaping, it is possible to use the \texttt{raw} string macro together with the \texttt{@doc} macro:


\begin{lstlisting}
@doc raw"``\LaTeX`` syntax in a docstring." functionname
\end{lstlisting}

\end{quote}


\hypertarget{10395937766942848638}{}


\subsection{Links}



Links to either external or internal targets can be written using the following syntax, where the text enclosed in square brackets, \texttt{[ ]}, is the name of the link and the text enclosed in parentheses, \texttt{( )}, is the URL.




\begin{lstlisting}
A paragraph containing a link to [Julia](http://www.julialang.org).
\end{lstlisting}



It{\textquotesingle}s also possible to add cross-references to other documented functions/methods/variables within the Julia documentation itself. For example:




\begin{minted}{julia}
"""
    tryparse(type, str; base)

Like [`parse`](@ref), but returns either a value of the requested type,
or [`nothing`](@ref) if the string does not contain a valid number.
"""
\end{minted}



This will create a link in the generated docs to the \hyperlink{14207407853646164654}{\texttt{parse}} documentation (which has more information about what this function actually does), and to the \hyperlink{9331422207248206047}{\texttt{nothing}} documentation. It{\textquotesingle}s good to include cross references to mutating/non-mutating versions of a function, or to highlight a difference between two similar-seeming functions.



\begin{quote}
\textbf{Note}

The above cross referencing is \emph{not} a Markdown feature, and relies on \href{https://github.com/JuliaDocs/Documenter.jl}{Documenter.jl}, which is used to build base Julia{\textquotesingle}s documentation.

\end{quote}


\hypertarget{1886176754537713588}{}


\subsection{Footnote references}



Named and numbered footnote references can be written using the following syntax. A footnote name must be a single alphanumeric word containing no punctuation.




\begin{lstlisting}
A paragraph containing a numbered footnote [^1] and a named one [^named].
\end{lstlisting}



\begin{quote}
\textbf{Note}

The text associated with a footnote can be written anywhere within the same page as the footnote reference. The syntax used to define the footnote text is discussed in the \hyperlink{16845496644619434430}{Footnotes} section below.

\end{quote}


\hypertarget{1299449328577314863}{}


\section{Toplevel elements}



The following elements can be written either at the {\textquotedbl}toplevel{\textquotedbl} of a document or within another {\textquotedbl}toplevel{\textquotedbl} element.



\hypertarget{7653906193491884111}{}


\subsection{Paragraphs}



A paragraph is a block of plain text, possibly containing any number of inline elements defined in the \hyperlink{17997341109973101587}{Inline elements} section above, with one or more blank lines above and below it.




\begin{lstlisting}
This is a paragraph.

And this is *another* paragraph containing some emphasized text.
A new line, but still part of the same paragraph.
\end{lstlisting}



\hypertarget{14939650886219602329}{}


\subsection{Headers}



A document can be split up into different sections using headers. Headers use the following syntax:




\begin{minted}{julia}
# Level One
## Level Two
### Level Three
#### Level Four
##### Level Five
###### Level Six
\end{minted}



A header line can contain any inline syntax in the same way as a paragraph can.



\begin{quote}
\textbf{Tip}

Try to avoid using too many levels of header within a single document. A heavily nested document may be indicative of a need to restructure it or split it into several pages covering separate topics.

\end{quote}


\hypertarget{9246544299434150790}{}


\subsection{Code blocks}



Source code can be displayed as a literal block using an indent of four spaces as shown in the following example.




\begin{lstlisting}
This is a paragraph.

    function func(x)
        # ...
    end

Another paragraph.
\end{lstlisting}



Additionally, code blocks can be enclosed using triple backticks with an optional {\textquotedbl}language{\textquotedbl} to specify how a block of code should be highlighted.




\begin{lstlisting}
A code block without a "language":

```
function func(x)
    # ...
end
```

and another one with the "language" specified as `julia`:

```julia
function func(x)
    # ...
end
```
\end{lstlisting}



\begin{quote}
\textbf{Note}

{\textquotedbl}Fenced{\textquotedbl} code blocks, as shown in the last example, should be preferred over indented code blocks since there is no way to specify what language an indented code block is written in.

\end{quote}


\hypertarget{12305052721486916392}{}


\subsection{Block quotes}



Text from external sources, such as quotations from books or websites, can be quoted using \texttt{>} characters prepended to each line of the quote as follows.




\begin{lstlisting}
Here's a quote:

> Julia is a high-level, high-performance dynamic programming language for
> technical computing, with syntax that is familiar to users of other
> technical computing environments.
\end{lstlisting}



Note that a single space must appear after the \texttt{>} character on each line. Quoted blocks may themselves contain other toplevel or inline elements.



\hypertarget{9122787766607047979}{}


\subsection{Images}



The syntax for images is similar to the link syntax mentioned above. Prepending a \texttt{!} character to a link will display an image from the specified URL rather than a link to it.




\begin{minted}{julia}
![alternative text](link/to/image.png)
\end{minted}



\hypertarget{5671077042730580546}{}


\subsection{Lists}



Unordered lists can be written by prepending each item in a list with either \texttt{*}, \texttt{+}, or \texttt{-}.




\begin{lstlisting}
A list of items:

  * item one
  * item two
  * item three
\end{lstlisting}



Note the two spaces before each \texttt{*} and the single space after each one.



Lists can contain other nested toplevel elements such as lists, code blocks, or quoteblocks. A blank line should be left between each list item when including any toplevel elements within a list.




\begin{lstlisting}
Another list:

  * item one

  * item two

    ```
    f(x) = x
    ```

  * And a sublist:

      + sub-item one
      + sub-item two
\end{lstlisting}



\begin{quote}
\textbf{Note}

The contents of each item in the list must line up with the first line of the item. In the above example the fenced code block must be indented by four spaces to align with the \texttt{i} in \texttt{item two}.

\end{quote}


Ordered lists are written by replacing the {\textquotedbl}bullet{\textquotedbl} character, either \texttt{*}, \texttt{+}, or \texttt{-}, with a positive integer followed by either \texttt{.} or \texttt{)}.




\begin{lstlisting}
Two ordered lists:

 1. item one
 2. item two
 3. item three

 5) item five
 6) item six
 7) item seven
\end{lstlisting}



An ordered list may start from a number other than one, as in the second list of the above example, where it is numbered from five. As with unordered lists, ordered lists can contain nested toplevel elements.



\hypertarget{8249559303631128892}{}


\subsection{Display equations}



Large  \LaTeX  equations that do not fit inline within a paragraph may be written as display equations using a fenced code block with the {\textquotedbl}language{\textquotedbl} \texttt{math} as in the example below.




\begin{minted}{julia}
```math
f(a) = \frac{1}{2\pi}\int_{0}^{2\pi} (\alpha+R\cos(\theta))d\theta
```
\end{minted}



\hypertarget{1021238270223877775}{}


\subsection{Footnotes}



This syntax is paired with the inline syntax for \hyperlink{1545049731521220959}{Footnote references}. Make sure to read that section as well.



Footnote text is defined using the following syntax, which is similar to footnote reference syntax, aside from the \texttt{:} character that is appended to the footnote label.




\begin{lstlisting}
[^1]: Numbered footnote text.

[^note]:

    Named footnote text containing several toplevel elements.

      * item one
      * item two
      * item three

    ```julia
    function func(x)
        # ...
    end
    ```
\end{lstlisting}



\begin{quote}
\textbf{Note}

No checks are done during parsing to make sure that all footnote references have matching footnotes.

\end{quote}


\hypertarget{5663489325501471007}{}


\subsection{Horizontal rules}



The equivalent of an \texttt{<hr>} HTML tag can be achieved using three hyphens (\texttt{---}). For example:




\begin{lstlisting}
Text above the line.

---

And text below the line.
\end{lstlisting}



\hypertarget{13092196581825070152}{}


\subsection{Tables}



Basic tables can be written using the syntax described below. Note that markdown tables have limited features and cannot contain nested toplevel elements unlike other elements discussed above – only inline elements are allowed. Tables must always contain a header row with column names. Cells cannot span multiple rows or columns of the table.




\begin{lstlisting}
| Column One | Column Two | Column Three |
|:---------- | ---------- |:------------:|
| Row `1`    | Column `2` |              |
| *Row* 2    | **Row** 2  | Column ``3`` |
\end{lstlisting}



\begin{quote}
\textbf{Note}

As illustrated in the above example each column of \texttt{|} characters must be aligned vertically.

A \texttt{:} character on either end of a column{\textquotesingle}s header separator (the row containing \texttt{-} characters) specifies whether the row is left-aligned, right-aligned, or (when \texttt{:} appears on both ends) center-aligned. Providing no \texttt{:} characters will default to right-aligning the column.

\end{quote}


\hypertarget{7215905182614360565}{}


\subsection{Admonitions}



Specially formatted blocks, known as admonitions, can be used to highlight particular remarks. They can be defined using the following \texttt{!!!} syntax:




\begin{lstlisting}
!!! note

    This is the content of the note.

!!! warning "Beware!"

    And this is another one.

    This warning admonition has a custom title: `"Beware!"`.
\end{lstlisting}



The type of the admonition can be any word made up of only lowercase Latin characters (a-z), but some types produce special styling, namely (in order of decreasing severity): \texttt{danger}, \texttt{warning}, \texttt{info}, \texttt{note}, and \texttt{tip}.



A custom title for the box can be provided as a string (in double quotes) after the admonition type. For that standard types (\texttt{danger}, \texttt{warning}... etc\_, if no title text is specified after the admonition type, then the type title used will be the type of the block. E.g. \texttt{{\textquotedbl}Note{\textquotedbl}} in the case of the \texttt{note} admonition.



If you would like to define your own block, for example a \texttt{terminology}  block used like so:




\begin{lstlisting}
!!! terminology "julia vs Julia"
    Strictly speaking, Julia refers to the language,
    and julia the standard implementation.
\end{lstlisting}



Admonitions, like most other toplevel elements, can contain other toplevel elements.



\hypertarget{10627994621615977524}{}


\section{Markdown Syntax Extensions}



Julia{\textquotesingle}s markdown supports interpolation in a very similar way to basic string literals, with the difference that it will store the object itself in the Markdown tree (as opposed to converting it to a string). When the Markdown content is rendered the usual \texttt{show} methods will be called, and these can be overridden as usual. This design allows the Markdown to be extended with arbitrarily complex features (such as references) without cluttering the basic syntax.



In principle, the Markdown parser itself can also be arbitrarily extended by packages, or an entirely custom flavour of Markdown can be used, but this should generally be unnecessary.



\hypertarget{1528138219436012362}{}


\chapter{内存映射 I/O}


\hypertarget{8426825172443272214}{} 
\hyperlink{8426825172443272214}{\texttt{Mmap.Anonymous}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Mmap.Anonymous(name::AbstractString="", readonly::Bool=false, create::Bool=true)
\end{minted}

Create an \texttt{IO}-like object for creating zeroed-out mmapped-memory that is not tied to a file for use in \hyperlink{1028440884226576897}{\texttt{Mmap.mmap}}. Used by \texttt{SharedArray} for creating shared memory arrays.

\textbf{Examples}


\begin{minted}{jlcon}
julia> anon = Mmap.Anonymous();

julia> isreadable(anon)
true

julia> iswritable(anon)
true

julia> isopen(anon)
true
\end{minted}



\end{adjustwidth}
\hypertarget{1028440884226576897}{} 
\hyperlink{1028440884226576897}{\texttt{Mmap.mmap}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Mmap.mmap(io::Union{IOStream,AbstractString,Mmap.AnonymousMmap}[, type::Type{Array{T,N}}, dims, offset]; grow::Bool=true, shared::Bool=true)
Mmap.mmap(type::Type{Array{T,N}}, dims)
\end{minted}

Create an \texttt{Array} whose values are linked to a file, using memory-mapping. This provides a convenient way of working with data too large to fit in the computer{\textquotesingle}s memory.

The type is an \texttt{Array\{T,N\}} with a bits-type element of \texttt{T} and dimension \texttt{N} that determines how the bytes of the array are interpreted. Note that the file must be stored in binary format, and no format conversions are possible (this is a limitation of operating systems, not Julia).

\texttt{dims} is a tuple or single \hyperlink{8469131683393450448}{\texttt{Integer}} specifying the size or length of the array.

The file is passed via the stream argument, either as an open \hyperlink{12496894737220238417}{\texttt{IOStream}} or filename string. When you initialize the stream, use \texttt{{\textquotedbl}r{\textquotedbl}} for a {\textquotedbl}read-only{\textquotedbl} array, and \texttt{{\textquotedbl}w+{\textquotedbl}} to create a new array used to write values to disk.

If no \texttt{type} argument is specified, the default is \texttt{Vector\{UInt8\}}.

Optionally, you can specify an offset (in bytes) if, for example, you want to skip over a header in the file. The default value for the offset is the current stream position for an \texttt{IOStream}.

The \texttt{grow} keyword argument specifies whether the disk file should be grown to accommodate the requested size of array (if the total file size is < requested array size). Write privileges are required to grow the file.

The \texttt{shared} keyword argument specifies whether the resulting \texttt{Array} and changes made to it will be visible to other processes mapping the same file.

For example, the following code


\begin{minted}{julia}
# Create a file for mmapping
# (you could alternatively use mmap to do this step, too)
A = rand(1:20, 5, 30)
s = open("/tmp/mmap.bin", "w+")
# We'll write the dimensions of the array as the first two Ints in the file
write(s, size(A,1))
write(s, size(A,2))
# Now write the data
write(s, A)
close(s)

# Test by reading it back in
s = open("/tmp/mmap.bin")   # default is read-only
m = read(s, Int)
n = read(s, Int)
A2 = Mmap.mmap(s, Matrix{Int}, (m,n))
\end{minted}

creates a \texttt{m}-by-\texttt{n} \texttt{Matrix\{Int\}}, linked to the file associated with stream \texttt{s}.

A more portable file would need to encode the word size – 32 bit or 64 bit – and endianness information in the header. In practice, consider encoding binary data using standard formats like HDF5 (which can be used with memory-mapping).




\begin{lstlisting}
Mmap.mmap(io, BitArray, [dims, offset])
\end{lstlisting}

Create a \hyperlink{18015155802543401629}{\texttt{BitArray}} whose values are linked to a file, using memory-mapping; it has the same purpose, works in the same way, and has the same arguments, as \hyperlink{1028440884226576897}{\texttt{mmap}}, but the byte representation is different.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = open("mmap.bin", "w+");

julia> B = Mmap.mmap(io, BitArray, (25,30000));

julia> B[3, 4000] = true;

julia> Mmap.sync!(B);

julia> close(io);

julia> io = open("mmap.bin", "r+");

julia> C = Mmap.mmap(io, BitArray, (25,30000));

julia> C[3, 4000]
true

julia> C[2, 4000]
false

julia> close(io)

julia> rm("mmap.bin")
\end{minted}

This creates a 25-by-30000 \texttt{BitArray}, linked to the file associated with stream \texttt{io}.



\end{adjustwidth}
\hypertarget{10364432000624675045}{} 
\hyperlink{10364432000624675045}{\texttt{Mmap.sync!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Mmap.sync!(array)
\end{minted}

Forces synchronization between the in-memory version of a memory-mapped \texttt{Array} or \hyperlink{18015155802543401629}{\texttt{BitArray}} and the on-disk version.



\end{adjustwidth}

\hypertarget{16222174321033129856}{}


\chapter{Pkg}



\hypertarget{7253998760451691688}{}


\section{介绍}



Pkg 是 Julia 1.0 及后续新版本的标准包管理器。与那些安装和管理单个全局软件包集的传统包管理器不同，Pkg 是围绕「环境」设计的。每个项目都有一套独立与其他项目的软件包集合。同一个软件包也可以在多个项目中通过名字共享。项目环境的软件包信息是保存在 \emph{清单文件} 里的。清单文件确切的描述了每一个依赖软件包和它的版本。清单文件可以检入项目存储库并在版本控制中进行跟踪，从而显着提高项目的可重复性。如果你曾经试图运行一段时间未曾使用过的代码，但发现其完全无法工作，而这只是因为你更新或卸载了项目使用的一些软件包，那么你会理解这种方法的意图。在 Pkg 中，由于每个项目都维护着各自独立的软件包集，你再也不会遇到这个问题了。 此外，如果你签出项目到新系统中，搭建出其清单文件所描述的环境将会非常地简单，并且你可以立即启动和并运行该项目，因为我们知道项目依赖项是好的。



由于项目包环境是彼此独立地进行管理和更新的， Pkg 显著地缓解了「依赖地狱」问题。你如果想在新项目中使用最新、最棒的包，但在另一个项目中却卡在了使用旧版本的包，那也没问题——因为它们的环境是彼此分离的，不同项目可以使用装在系统的不同位置的不同版本的包。每个版本的包的位置都是规范的，所以当多个环境使用的包版本相同时，它们可以共享同一安装包，这就避免不必要的重复安装。不被任何环境使用的老旧版本的包，会被包管理器定期「垃圾收集」掉。



Pkg 对本地环境的处理方法可能让曾经使用过 Python 的 \texttt{virtualenv} 或 Ruby 的 \texttt{bundler} 的人感到熟悉。在 Julia 中，我们不仅没有通过破解语言的代码加载机制来支持环境，而且还有 Julia 本身就理解它们的好处。此外，Julia 环境是「可堆叠的」：你可以将一个环境叠加在另一个环境上，从而可以访问主环境之外的其它包。这使得更容易在提供主环境的项目上工作，同时依然访问所有你常用的开发工具，如分析器、调试器等，这只需在加载路径中更后地包含具有这些开发环境的路径。



Last but not least, Pkg is designed to support federated package registries. This means that it allows multiple registries managed by different parties to interact seamlessly. In particular, this includes private registries which can live behind corporate firewalls. You can install and update your own packages from a private registry with exactly the same tools and workflows that you use to install and manage official Julia packages. If you urgently need to apply a hotfix for a public package that’s critical to your company’s product, you can tag a private version of it in your company’s internal registry and get a fix to your developers and ops teams quickly and easily without having to wait for an upstream patch to be accepted and published. Once an official fix is published, however, you can just upgrade your dependencies and you{\textquotesingle}ll be back on an official release again.



\hypertarget{11820197359252038124}{}


\section{词汇表}



\textbf{项目（Project）：}一个具有标准布局的源代码树，包括了用来放置主要的 Julia 代码的 \texttt{src} 目录、用来放置测试的 \texttt{test} 目录、用来放置文档的 \texttt{docs} 目录和可选的用来放置构建脚本及其输出的 \texttt{deps} 目录。项目通常有一个项目文件和一个可选的清单文件：



\begin{itemize}
\item \textbf{项目文件（Project file）：}一个在项目根目录下的文件，叫做 \texttt{Project.toml}（或 \texttt{JuliaProject.toml}），用来描述项目的元数据，包括项目的名称、UUID（针对包）、作者、许可证和它所依赖的包和库的名称及 UUID。


\item \textbf{清单文件（Manifest file）：}一个在项目根目录下的文件，叫做 \texttt{Manifest.toml}（或 \texttt{JuliaManifest.toml}），用来描述完整的依赖关系图、每个包的确切版本以及项目使用的库。

\end{itemize}


\textbf{包（Package）：}一个提供可重用功能的项目，其它 Julia 项目可以同 \texttt{import X} 或 \texttt{using X} 使用它。一个包应该包含一个具有 \texttt{uuid} 条目（此条目给出该包 UUID）的项目文件。此 UUID 用于在依赖它的项目中标识该包。



\begin{quote}
\textbf{Note}

由于历史原因，可以在 REPL 或脚本的顶级中加载没有项目文件或 UUID 的包。但是，无法在具有项目文件或 UUID 的项目中加载没有它们的包。一旦你曾从项目文件加载包，所有包就都需要项目文件和 UUID。

\end{quote}


\textbf{应用（application）：}一个提供独立功能的项目，不打算被其它 Julia 项目重用。例如，Web 应用、命令行工具或者科学论文附带的模拟或分析代码。应用可以有 UUID 但也可以没有。应用还可以为其所依赖的包提供全局配置选项。另一方面，包不可能提供全局配置，因为这可能与主应用的配置相冲突。



\begin{quote}
\textbf{Note}

\textbf{项目 \emph{vs.} 包 \emph{vs.} 应用：}

\begin{itemize}
\item[1. ] \textbf{项目}是一个总称：包和应用都是一种项目。


\item[2. ] \textbf{包}应该有 UUID，而应用可以有也可以没有。


\item[3. ] \textbf{应用}可以提供全局的配置，而包不行。

\end{itemize}
\end{quote}


\textbf{Library (future work):} a compiled binary dependency (not written in Julia) packaged to be used by a Julia project. These are currently typically built in- place by a \texttt{deps/build.jl} script in a project’s source tree, but in the future we plan to make libraries first-class entities directly installed and upgraded by the package manager.



\textbf{环境（Environment）：}项目文件和清单文件的组合，项目文件与依赖关系图相结合后提供了顶级名称映射，而清单文件提供了包到它们入口点的映射。有关的详细信息，请参阅手册中代码加载的相关章节。



\begin{itemize}
\item \textbf{显式环境（Explicit environment）：}在同一目录下具有显式的项目文件和可选的与其对应的清单文件。如果清单文件不存在，那么隐含的依赖关系图和位置映射为空。


\item \textbf{隐式环境（Implicit environment）：}作为目录提供的环境（没有项目文件或清单文件），此目录包含包且包含的包具有形式为 \texttt{X.jl}、\texttt{X.jl/src/X.jl} 或 \texttt{X/src/X.jl} 的入口点，这些包的入口点隐含了顶级名称映射。依赖关系图隐含在这些包所在目录的项目文件里，例如 \texttt{X.jl/Project.toml} 或 \texttt{X/Project.toml}。如果 \texttt{X} 存在对应的项目文件，则其依赖关系就是其项目文件的依赖关系。入口点本身就隐含了位置映射。

\end{itemize}


\textbf{Registry:} a source tree with a standard layout recording metadata about a registered set of packages, the tagged versions of them which are available, and which versions of packages are compatible or incompatible with each other. A registry is indexed by package name and UUID, and has a directory for each registered package providing the following metadata about it:



\begin{itemize}
\item name——例如 \texttt{DataFrames}


\item UUID——例如 \texttt{a93c6f00-e57d-5684-b7b6-d8193f3e46c0}


\item authors——例如 \texttt{Jane Q. Developer <jane@example.com>}


\item license——例如 MIT，BSD3 或 GPLv2


\item repository——例如 \texttt{https://github.com/JuliaData/DataFrames.jl.git}


\item description——一个总结包功能的文本块


\item keywords——例如 \texttt{data}，\texttt{tabular}，\texttt{analysis}，\texttt{statistics}


\item versions——所有已注册版本的标签列表

\end{itemize}


每个包的已注册版本都会提供以下信息：



\begin{itemize}
\item its semantic version number – e.g. \texttt{v1.2.3}


\item its git tree SHA-1 hash – e.g. \texttt{7ffb18ea3245ef98e368b02b81e8a86543a11103}


\item a map from names to UUIDs of dependencies


\item which versions of other packages it is compatible/incompatible with

\end{itemize}


Dependencies and compatibility are stored in a compressed but human-readable format using ranges of package versions.



\textbf{Depot:} a directory on a system where various package-related resources live, including:



\begin{itemize}
\item \texttt{environments}: shared named environments (e.g. \texttt{v0.7}, \texttt{devtools})


\item \texttt{clones}: bare clones of package repositories


\item \texttt{compiled}: cached compiled package images (\texttt{.ji} files)


\item \texttt{config}: global configuration files (e.g. \texttt{startup.jl})


\item \texttt{dev}: default directory for package development


\item \texttt{logs}: log files (e.g. \texttt{manifest\_usage.toml}, \texttt{repl\_history.jl})


\item \texttt{packages}: installed package versions


\item \texttt{registries}: clones of registries (e.g. \texttt{General})

\end{itemize}


\textbf{Load path:} a stack of environments where package identities, their dependencies, and entry-points are searched for. The load path is controlled in Julia by the \texttt{LOAD\_PATH} global variable which is populated at startup based on the value of the \texttt{JULIA\_LOAD\_PATH} environment variable. The first entry is your primary environment, often the current project, while later entries provide additional packages one may want to use from the REPL or top-level scripts.



\textbf{Depot path:} a stack of depot locations where the package manager, as well as Julia{\textquotesingle}s code loading mechanisms, look for registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files. The depot path is controlled by the Julia \texttt{DEPOT\_PATH} global variable which is populated at startup based on the value of the \texttt{JULIA\_DEPOT\_PATH} environment variable. The first entry is the “user depot” and should be writable by and owned by the current user. The user depot is where: registries are cloned, new package versions are installed, named environments are created and updated, package repos are cloned, newly compiled package image files are saved, log files are written, development packages are checked out by default, and global configuration data is saved. Later entries in the depot path are treated as read-only and are appropriate for registries, packages, etc. installed and managed by system administrators.



\hypertarget{4066476927559720001}{}


\section{入门}



在 Julia REPL 中使用 \texttt{]} 键即可进入 Pkg 模式。




\begin{lstlisting}
(v0.7) pkg>
\end{lstlisting}



提示符括号内的部分显示当前项目的名称。由于我们尚未创建自己的项目，我们正处于默认项目中，其位于 \texttt{{\textasciitilde}/.julia/environments/v0.7}（或任何你恰巧在运行的 Julia 版本）。



要返回 \texttt{julia>} 提示符，请在输入行为空时按退格键或直接按 Ctrl+C。可通过调用 \texttt{pkg>help} 获得帮助。如果你所处的环境无法访问 PEPL，你仍可以通过字符串宏 \texttt{pkg}（其在 \texttt{using Pkg} 后可用）使用 REPL 模式的命令。命令 \texttt{pkg{\textquotedbl}cms{\textquotedbl}} 将等价于在 RPEL 模式中执行 \texttt{cmd}。



此处的文档介绍了如何使用 REPL 的 Pkg 模式。使用 Pkg API（通过调用 \texttt{Pkg.} 函数）的文档正在编写中。



\hypertarget{17544737972677030323}{}


\subsection{添加包}



有两种方法可以添加包，分别是使用 \texttt{add} 命令和 \texttt{dev} 命令。最常用的是 \texttt{add}，我们首先介绍它的用法。



\hypertarget{8492524675297016695}{}


\subsubsection{添加已注册的包}



在 REPL 的 Pkg 模式中，添加包可以使用 \texttt{add} 命令，其后接包的名称，例如：




\begin{lstlisting}
(v0.7) pkg> add Example
   Cloning default registries into /Users/kristoffer/.julia/registries
   Cloning registry General from "https://github.com/JuliaRegistries/General.git"
  Updating registry at `~/.julia/registries/General`
  Updating git-repo `https://github.com/JuliaRegistries/General.git`
 Resolving package versions...
  Updating `~/.julia/environments/v0.7/Project.toml`
  [7876af07] + Example v0.5.1
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [7876af07] + Example v0.5.1
  [8dfed614] + Test
\end{lstlisting}



在这里，我们将包 Example 添加到当前项目中。此例中，我们使用的是全新的 Julia 安装，并且这是我们第一次使用 Pkg 添加包。默认情况下，Pkg 会克隆 Julia 的 General 注册表，并使用此注册表来查找需要包含在当前环境中的包。状态更新在左侧显示了简短形式的包 UUID，接着是包名称和版本号。因为标准库（例如 \texttt{Test}）随 Julia 一起提供，所以它们没有版本号。项目状态包含你自己添加的包，在此例中为 \texttt{Example}：




\begin{lstlisting}
(v0.7) pkg> st
    Status `Project.toml`
  [7876af07] Example v0.5.1
\end{lstlisting}



此外，清单状态包含了显式添加的包的依赖项。




\begin{lstlisting}
(v0.7) pkg> st --manifest
    Status `Manifest.toml`
  [7876af07] Example v0.5.1
  [8dfed614] Test
\end{lstlisting}



可以在一次命令中添加多个包，例如 \texttt{pkg> add A B C}。



在包已添加进项目中后，可在 Julia 中加载它：




\begin{lstlisting}
julia> using Example

julia> Example.hello("User")
"Hello, User"
\end{lstlisting}



可以通过在 \texttt{@} 符号后附加版本号来安装特定版本，例如在包名称后附加 \texttt{@v0.4}：




\begin{lstlisting}
(v0.7) pkg> add Example@0.4
 Resolving package versions...
  Updating `~/.julia/environments/v0.7/Project.toml`
  [7876af07] + Example v0.4.1
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [7876af07] + Example v0.4.1
\end{lstlisting}



如果 \texttt{Example} 的主分支（或某个提交 SHA）有尚未包含在已注册版本中的修补程序，我们可以通过在包名称后附加 \texttt{\#branch}（或 \texttt{\#commit}）来显式跟踪该分支（或提交）：




\begin{lstlisting}
(v0.7) pkg> add Example#master
  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`
 Resolving package versions...
  Updating `~/.julia/environments/v0.7/Project.toml`
  [7876af07] ~ Example v0.5.1 ⇒ v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git)
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [7876af07] ~ Example v0.5.1 ⇒ v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git)
\end{lstlisting}



状态输出现在显示我们正在跟踪 \texttt{Example} 的 \texttt{master} 分支。在更新包时，我们将从该分支中拉取更新。



要返回到跟踪 \texttt{Example} 的注册表版本，请使用 \texttt{free} 命令：




\begin{lstlisting}
(v0.7) pkg> free Example
 Resolving package versions...
  Updating `~/.julia/environments/v0.7/Project.toml`
  [7876af07] ~ Example v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git) ⇒ v0.5.1
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [7876af07] ~ Example v0.5.1+ #master )https://github.com/JuliaLang/Example.jl.git) ⇒ v0.5.1
\end{lstlisting}



\hypertarget{16019413810897191556}{}


\subsubsection{添加未注册包}



如果某个包不在注册表中，通过将其存储库的 URL 传给 \texttt{add} 而不是包名称，仍然可以添加它。




\begin{lstlisting}
(v0.7) pkg> add https://github.com/fredrikekre/ImportMacros.jl
  Updating git-repo `https://github.com/fredrikekre/ImportMacros.jl`
 Resolving package versions...
Downloaded MacroTools ─ v0.4.1
  Updating `~/.julia/environments/v0.7/Project.toml`
  [e6797606] + ImportMacros v0.0.0 # (https://github.com/fredrikekre/ImportMacros.jl)
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [e6797606] + ImportMacros v0.0.0 # (https://github.com/fredrikekre/ImportMacros.jl)
  [1914dd2f] + MacroTools v0.4.1
\end{lstlisting}



可以看到，未注册包的依赖项（此处为 \texttt{MacroTools}）已被添加。对于未注册包，我们可以使用 \texttt{\#} 来给定一个分支（或 commit SHA）来进行跟踪，就像已注册包一样。



\hypertarget{7534124019894702517}{}


\subsubsection{添加本地包}



我们可以将一个 git 存储库的本地路径传给 \texttt{add} 而不是其 URL，其效果类似于传 URL。该本地存储库（的某个分支）会被跟踪，并在包更新时从已拉取的本地存储库中获取更新。请注意，本地包存储库中的文件更改不会在包加载时立即反映出来。为了拉取更改，必须提交该更改并更新包。



\hypertarget{14425308659963754723}{}


\subsubsection{开发包}



仅使用 \texttt{add} 会让你的清单始终为「可再现状态」，换句话说，只要所使用的存储库和注册表仍然可以访问，就可以检索出项目中所有依赖项的确切状态。这样做的好处是你可以将你的项目（\texttt{Project.toml} 和 \texttt{Manifest.toml}）发送该其他人，然后他们可以该项目「实例化」到与你本地项目相同的状态。但是，当你在开发包时，在某个路径上以当前状态加载包会更方便。因此，命令 \texttt{dev} 有存在必要。



让我们来尝试 \texttt{dev} 一个已注册的包：




\begin{lstlisting}
(v0.7) pkg> dev Example
  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`
 Resolving package versions...
  Updating `~/.julia/environments/v0.7/Project.toml`
  [7876af07] + Example v0.5.1+ [`~/.julia/dev/Example`]
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [7876af07] + Example v0.5.1+ [`~/.julia/dev/Example`]
\end{lstlisting}



\texttt{dev} 命令会获取包的完整克隆到 \texttt{{\textasciitilde}/.julia/dev/} 目录下（可通过设置环境变量 \texttt{JULIA\_PKG\_DEVDIR} 来更改此路径）。在导入 \texttt{Example} 时，julia 现在将从 \texttt{{\textasciitilde}/.julia/dev/Example} 导入它，并且该路径下文件的所有本地更改都将反映在加载的代码中。在使用 \texttt{add} 时，我们说我们跟踪了包存储库，在这里则说我们跟踪了路径本身。请注意，包管理器永远不会触碰已跟踪路径上的任何文件。因此，需要你自己拉取更新、更改分支等。如果我们尝试 \texttt{dev} 包的某个已经存在于 \texttt{{\textasciitilde}/.julia/dev/} 里的分支，则包管理器只会使用已存在的路径。例如：




\begin{lstlisting}
(v0.7) pkg> dev Example
  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`
[ Info: Path `/Users/kristoffer/.julia/dev/Example` exists and looks like the correct package, using existing path instead of cloning
\end{lstlisting}



请注意，info 信息表明它正在使用现有路径。一般来说，包管理器不会触碰正在跟踪的路径文件。



如果在本地路径上使用 \texttt{dev}，则该包的路径会被记录并在该包加载时使用之。除非该路径以绝对路径的形式给出，否则它会以相对于项目文件的形式记录下来。



要停止跟踪路径并再次使用已注册版本，请使用 \texttt{free}




\begin{lstlisting}
(v0.7) pkg> free Example
 Resolving package versions...
  Updating `~/.julia/environments/v0.7/Project.toml`
  [7876af07] ↓ Example v0.5.1+ [`~/.julia/dev/Example`] ⇒ v0.5.1
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [7876af07] ↓ Example v0.5.1+ [`~/.julia/dev/Example`] ⇒ v0.5.1
\end{lstlisting}



值得提及的是，通过使用 \texttt{dev}，你的项目现在具有其内在状态。其状态取决于该路径中文件的当前内容，并且在不知道所跟踪路径中所有包的确切内容的情况下，其他人无法「实例化」清单。



Note that if you add a dependency to a package that tracks a local path, the Manifest (which contains the whole dependency graph) will become out of sync with the actual dependency graph. This means that the package will not be able to load that dependency since it is not recorded in the Manifest. To update sync the Manifest, use the REPL command \texttt{resolve}.



\hypertarget{11999055779830288138}{}


\subsection{删除包}



通过使用 \texttt{pkg> rm Package}，可从当前项目中删除包。这只会删除已存在于项目中的包，要删除仅作为依赖项的包，请使用 \texttt{pkg> rm --manifest DepPackage}。请注意，这会删除所有依赖于 \texttt{DepPackage} 的包。



\hypertarget{682348977546152420}{}


\subsection{更新包}



当项目正在使用的包发布新版本时，最好进行更新。简单地调用 \texttt{up} 会尝试将项目的\emph{所有}依赖项更新到最新的兼容版本。有时这并不是你想要的。通过将依赖项子集作为参数传给 \texttt{up}，你可以指定要升级的依赖项，例如




\begin{lstlisting}
(v0.7) pkg> up Example
\end{lstlisting}



所有其他包直接依赖项的版本会保持不变。如果你为了降低项目中断的风险，只想要更新包的次版本号，你可以加上 \texttt{--minor} 标志，例如：




\begin{lstlisting}
(v0.7) pkg> up --minor Example
\end{lstlisting}



跟踪存储库的包在进行次要更新时不会被更新，而跟踪路径的包永远不会被包管理器所触及。



\hypertarget{2188017839608631681}{}


\subsection{Pinning a package}



A pinned package will never be updated. A package can be pinned using \texttt{pin} as for example




\begin{lstlisting}
(v0.7) pkg> pin Example
 Resolving package versions...
  Updating `~/.julia/environments/v0.7/Project.toml`
  [7876af07] ~ Example v0.5.1 ⇒ v0.5.1 ⚲
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [7876af07] ~ Example v0.5.1 ⇒ v0.5.1 ⚲
\end{lstlisting}



Note the pin symbol \texttt{⚲} showing that the package is pinned. Removing the pin is done using \texttt{free}




\begin{lstlisting}
(v0.7) pkg> free Example
  Updating `~/.julia/environments/v0.7/Project.toml`
  [7876af07] ~ Example v0.5.1 ⚲ ⇒ v0.5.1
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [7876af07] ~ Example v0.5.1 ⚲ ⇒ v0.5.1
\end{lstlisting}



\hypertarget{6952888041784542494}{}


\subsection{测试包}



包的测试可通过 \texttt{test} 命令来运行：




\begin{lstlisting}
(v0.7) pkg> test Example
   Testing Example
   Testing Example tests passed
\end{lstlisting}



\hypertarget{1142310729597694114}{}


\subsection{构建包}



第一次安装某个包时，会自动执行该包的构建步骤。构建过程的输出会被重定向到文件中。要显式执行包的构建步骤，请使用 \texttt{build} 命令：




\begin{lstlisting}
(v0.7) pkg> build MbedTLS
  Building MbedTLS → `~/.julia/packages/MbedTLS/h1Vu/deps/build.log`

shell> cat ~/.julia/packages/MbedTLS/h1Vu/deps/build.log
┌ Warning: `wait(t::Task)` is deprecated, use `fetch(t)` instead.
│   caller = macro expansion at OutputCollector.jl:63 [inlined]
└ @ Core OutputCollector.jl:63
...
[ Info: using prebuilt binaries
\end{lstlisting}



\hypertarget{9268299237854436907}{}


\section{Creating your own projects}



So far we have added packages to the default project at \texttt{{\textasciitilde}/.julia/environments/v0.7}, it is, however, easy to create other, independent, projects. It should be pointed out if two projects uses the same package at the same version, the content of this package is not duplicated. In order to create a new project, create a directory for it and then activate that directory to make it the {\textquotedbl}active project{\textquotedbl} which package operations manipulate:




\begin{lstlisting}
shell> mkdir MyProject

shell> cd MyProject
/Users/kristoffer/MyProject

(v0.7) pkg> activate .

(MyProject) pkg> st
    Status `Project.toml`
\end{lstlisting}



Note that the REPL prompt changed when the new project is activated. Since this is a newly created project, the status command show it contains no packages, and in fact, it has no project or manifest file until we add a package to it:




\begin{lstlisting}
shell> ls -l
total 0

(MyProject) pkg> add Example
  Updating registry at `~/.julia/registries/General`
  Updating git-repo `https://github.com/JuliaRegistries/General.git`
 Resolving package versions...
  Updating `Project.toml`
  [7876af07] + Example v0.5.1
  Updating `Manifest.toml`
  [7876af07] + Example v0.5.1
  [8dfed614] + Test

shell> ls -l
total 8
-rw-r--r-- 1 stefan staff 207 Jul  3 16:35 Manifest.toml
-rw-r--r-- 1 stefan staff  56 Jul  3 16:35 Project.toml

shell> cat Project.toml
[deps]
Example = "7876af07-990d-54b4-ab0e-23690620f79a"

shell> cat Manifest.toml
[[Example]]
deps = ["Test"]
git-tree-sha1 = "8eb7b4d4ca487caade9ba3e85932e28ce6d6e1f8"
uuid = "7876af07-990d-54b4-ab0e-23690620f79a"
version = "0.5.1"

[[Test]]
uuid = "8dfed614-e22c-5e08-85e1-65c5234f0b40"
\end{lstlisting}



This new environment is completely separate from the one we used earlier.



\hypertarget{5812058120249017191}{}


\section{垃圾收集旧的、不再使用的包}



随着包的更新和项目被删除，曾经使用的已安装的包将不可避免地变旧，并且不被用于任何现有项目。Pkg 会记录所有已使用项目的日志，这样便可通过遍历日志，明确知道哪些项目仍然存在以及这些项目使用了哪些包，剩下的包则会被删除。命令 \texttt{gc} 可执行此操作：




\begin{lstlisting}
(v0.7) pkg> gc
    Active manifests at:
        `/Users/kristoffer/BinaryProvider/Manifest.toml`
        ...
        `/Users/kristoffer/Compat.jl/Manifest.toml`
   Deleted /Users/kristoffer/.julia/packages/BenchmarkTools/1cAj: 146.302 KiB
   Deleted /Users/kristoffer/.julia/packages/Cassette/BXVB: 795.557 KiB
   ...
   Deleted /Users/kristoffer/.julia/packages/WeakRefStrings/YrK6: 27.328 KiB
   Deleted 36 package installations: 113.205 MiB
\end{lstlisting}



请注意，只有在 \texttt{{\textasciitilde}/.julia/packages} 中的包才会被删除。



\hypertarget{5867084990704441204}{}


\section{Creating your own packages}



A package is a project with a \texttt{name}, \texttt{uuid} and \texttt{version} entry in the \texttt{Project.toml} file \texttt{src/PackageName.jl} file that defines the module \texttt{PackageName}. This file is executed when the package is loaded.



\hypertarget{14149589589287981755}{}


\subsection{Generating files for a package}



To generate files for a new package, use \texttt{pkg> generate}.




\begin{lstlisting}
(v0.7) pkg> generate HelloWorld
\end{lstlisting}



This creates a new project \texttt{HelloWorld} with the following files (visualized with the external \href{https://linux.die.net/man/1/tree}{\texttt{tree} command}):




\begin{lstlisting}
shell> cd HelloWorld

shell> tree .
.
├── Project.toml
└── src
    └── HelloWorld.jl

1 directory, 2 files
\end{lstlisting}



The \texttt{Project.toml} file contains the name of the package, its unique UUID, its version, the author and eventual dependencies:




\begin{lstlisting}
name = "HelloWorld"
uuid = "b4cd1eb8-1e24-11e8-3319-93036a3eb9f3"
version = "0.1.0"
author = ["Some One <someone@email.com>"]

[deps]
\end{lstlisting}



The content of \texttt{src/HelloWorld.jl} is:




\begin{lstlisting}
module HelloWorld

greet() = print("Hello World!")

end # module
\end{lstlisting}



We can now activate the project and load the package:




\begin{lstlisting}
pkg> activate .

julia> import HelloWorld

julia> HelloWorld.greet()
Hello World!
\end{lstlisting}



\hypertarget{15262021635183704764}{}


\subsection{Adding dependencies to the project}



Let’s say we want to use the standard library package \texttt{Random} and the registered package \texttt{JSON} in our project. We simply \texttt{add} these packages (note how the prompt now shows the name of the newly generated project, since we are inside the \texttt{HelloWorld} project directory):




\begin{lstlisting}
(HelloWorld) pkg> add Random JSON
 Resolving package versions...
  Updating "~/Documents/HelloWorld/Project.toml"
 [682c06a0] + JSON v0.17.1
 [9a3f8284] + Random
  Updating "~/Documents/HelloWorld/Manifest.toml"
 [34da2185] + Compat v0.57.0
 [682c06a0] + JSON v0.17.1
 [4d1e1d77] + Nullables v0.0.4
 ...
\end{lstlisting}



Both \texttt{Random} and \texttt{JSON} got added to the project’s \texttt{Project.toml} file, and the resulting dependencies got added to the \texttt{Manifest.toml} file. The resolver has installed each package with the highest possible version, while still respecting the compatibility that each package enforce on its dependencies.



We can now use both \texttt{Random} and \texttt{JSON} in our project. Changing \texttt{src/HelloWorld.jl} to




\begin{lstlisting}
module HelloWorld

import Random
import JSON

greet() = print("Hello World!")
greet_alien() = print("Hello ", Random.randstring(8))

end # module
\end{lstlisting}



and reloading the package, the new \texttt{greet\_alien} function that uses \texttt{Random} can be used:




\begin{lstlisting}
julia> HelloWorld.greet_alien()
Hello aT157rHV
\end{lstlisting}



\hypertarget{7089821536805504415}{}


\subsection{Adding a build step to the package.}



The build step is executed the first time a package is installed or when explicitly invoked with \texttt{build}. A package is built by executing the file \texttt{deps/build.jl}.




\begin{lstlisting}
shell> cat deps/build.log
I am being built...

(HelloWorld) pkg> build
  Building HelloWorld → `deps/build.log`
 Resolving package versions...

shell> cat deps/build.log
I am being built...
\end{lstlisting}



If the build step fails, the output of the build step is printed to the console




\begin{lstlisting}
shell> cat deps/build.jl
error("Ooops")

(HelloWorld) pkg> build
  Building HelloWorld → `deps/build.log`
 Resolving package versions...
┌ Error: Error building `HelloWorld`:
│ ERROR: LoadError: Ooops
│ Stacktrace:
│  [1] error(::String) at ./error.jl:33
│  [2] top-level scope at none:0
│  [3] include at ./boot.jl:317 [inlined]
│  [4] include_relative(::Module, ::String) at ./loading.jl:1071
│  [5] include(::Module, ::String) at ./sysimg.jl:29
│  [6] include(::String) at ./client.jl:393
│  [7] top-level scope at none:0
│ in expression starting at /Users/kristoffer/.julia/dev/Pkg/HelloWorld/deps/build.jl:1
└ @ Pkg.Operations Operations.jl:938
\end{lstlisting}



\hypertarget{4923930195335946322}{}


\subsection{Adding tests to the package}



When a package is tested the file \texttt{test/runtests.jl} is executed.




\begin{lstlisting}
shell> cat test/runtests.jl
println("Testing...")
(HelloWorld) pkg> test
   Testing HelloWorld
 Resolving package versions...
Testing...
   Testing HelloWorld tests passed
\end{lstlisting}



\hypertarget{3762020746930282199}{}


\subsubsection{Test-specific dependencies}



Sometimes one might want to use some packages only at testing time but not enforce a dependency on them when the package is used. This is possible by adding dependencies to \texttt{[extras]} and a \texttt{test} target in \texttt{[targets]} to the Project file. Here we add the \texttt{Test} standard library as a test-only dependency by adding the following to the Project file:




\begin{lstlisting}
[extras]
Test = "8dfed614-e22c-5e08-85e1-65c5234f0b40"

[targets]
test = ["Test"]
\end{lstlisting}



We can now use \texttt{Test} in the test script and we can see that it gets installed on testing:




\begin{lstlisting}
shell> cat test/runtests.jl
using Test
@test 1 == 1

(HelloWorld) pkg> test
   Testing HelloWorld
 Resolving package versions...
  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Project.toml`
  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]
  [8dfed614] + Test
  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Manifest.toml`
  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]
   Testing HelloWorld tests passed```
\end{lstlisting}



\hypertarget{16280680646707854087}{}


\subsection{Compatibility}



Compatibility refers to the ability to restrict what version of the dependencies that your project is compatible with. If the compatibility for a dependency is not given, the project is assumed to be compatible with all versions of that dependency.



Compatibility for a dependency is entered in the \texttt{Project.toml} file as for example:




\begin{lstlisting}
[compat]
Example = "0.4.3"
\end{lstlisting}



After a compatibility entry is put into the project file, \texttt{up} can be used to apply it.



The format of the version specifier is described in detail below.



\begin{quote}
\textbf{Info}

There is currently no way to give compatibility from the Pkg REPL mode so for now, one has to manually edit the project file.

\end{quote}


\hypertarget{15488851848435252363}{}


\subsubsection{Version specifier format}



Similar to other package managers, the Julia package manager respects \href{https://semver.org/}{semantic versioning} (semver). As an example, a version specifier is given as e.g. \texttt{1.2.3} is therefore assumed to be compatible with the versions \texttt{[1.2.3 - 2.0.0)} where \texttt{)} is a non-inclusive upper bound. More specifically, a version specifier is either given as a \textbf{caret specifier}, e.g. \texttt{{\textasciicircum}1.2.3}  or a \textbf{tilde specifier} \texttt{{\textasciitilde}1.2.3}. Caret specifiers are the default and hence \texttt{1.2.3 == {\textasciicircum}1.2.3}. The difference between a caret and tilde is described in the next section. The intersection of multiple version specifiers can be formed by comma separating indiviual version specifiers.



\hypertarget{15797390643720760817}{}


\paragraph{Caret specifiers}



A caret specifier allows upgrade that would be compatible according to semver. An updated dependency is considered compatible if the new version does not modify the left-most non zero digit in the version specifier.



Some examples are shown below.




\begin{lstlisting}
^1.2.3 = [1.2.3, 2.0.0)
^1.2 = [1.2.0, 2.0.0)
^1 =  [1.0.0, 2.0.0)
^0.2.3 = [0.2.3, 0.3.0)
^0.0.3 = [0.0.3, 0.0.4)
^0.0 = [0.0.0, 0.1.0)
^0 = [0.0.0, 1.0.0)
\end{lstlisting}



While the semver specification says that all versions with a major version of 0 are incompatible with each other, we have made that choice that a version given as \texttt{0.a.b} is considered compatible with \texttt{0.a.c} if \texttt{a != 0} and  \texttt{c >= b}.



\hypertarget{15862646148226490878}{}


\paragraph{Tilde specifiers}



A tilde specifier provides more limited upgrade possibilities. With a tilde, only the last specified digit is allowed to increment by one. This gives the following example.




\begin{lstlisting}
~1.2.3 = [1.2.3, 1.2.4)
~1.2 = [1.2.0, 1.3.0)
~1 = [1.0.0, 2.0.0)
\end{lstlisting}



\hypertarget{3271687203032681122}{}


\subsubsection{Inequality specifiers}



Inequalities can also be used to specify version ranges:




\begin{lstlisting}
>= 1.2.3 = [1.2.3,  ∞)
≥ 1.2.3 = [1.2.3,  ∞)
= 1.2.3 = [1.2.3, 1.2.3]
< 1.2.3 = [0.0.0, 1.2.2]
\end{lstlisting}



\hypertarget{11268172833265643313}{}


\section{预编译项目}



REPL 命令 \texttt{precompile} 可用于预编译项目中的所有依赖。例如，这样做可以




\begin{lstlisting}
(HelloWorld) pkg> update; precompile
\end{lstlisting}



更新依赖项，然后预编译它们。



\hypertarget{1315229974566698548}{}


\section{预览模式}



如果你只想查看某个命令运行的效果，但不想更改包的状态，则可以 \texttt{preview} 该命令。例如：




\begin{lstlisting}
(HelloWorld) pkg> preview add Plots
\end{lstlisting}



或




\begin{lstlisting}
(HelloWorld) pkg> preview up
\end{lstlisting}



将向你展示添加 \texttt{Plots}、或者进行完全升级分别会对你的项目产生的影响。但是，这没有安装任何东西，也不会触及你的 \texttt{Project.toml} 和 \texttt{Manifest.toml}。



\hypertarget{6833241097141421015}{}


\section{使用别人的项目}



只需使用诸如 \texttt{git clone} 来克隆项目，接着 \texttt{cd} 到项目目录并调用




\begin{lstlisting}
(v0.7) pkg> activate .

(SomeProject) pkg> instantiate
\end{lstlisting}



如果该项目包含了清单，则会以与该清单给定的相同状态安装包。否则，它将解析为与项目兼容的最新版本的依赖项。



\hypertarget{13487828328085508990}{}


\section{References}



This section describes the {\textquotedbl}API mode{\textquotedbl} of interacting with Pkg.jl which is recommended for non-interactive usage, in i.e. scripts. In the REPL mode packages (with associated version, UUID, URL etc) are parsed from strings, for example, \texttt{{\textquotedbl}Package\#master{\textquotedbl}},\texttt{{\textquotedbl}Package@v0.1{\textquotedbl}}, \texttt{{\textquotedbl}www.mypkg.com/MyPkg\#my/feature{\textquotedbl}}. It is possible to use strings as arguments for simple commands in the API mode (like \texttt{Pkg.add([{\textquotedbl}PackageA{\textquotedbl}, {\textquotedbl}PackageB{\textquotedbl}])}, more complicated commands, that e.g. specify URLs or version range, uses a more structured format over strings. This is done by creating an instance of a \hyperlink{7769325907319883786}{\texttt{PackageSpec}} which are passed in to functions.


\hypertarget{7769325907319883786}{} 
\hyperlink{7769325907319883786}{\texttt{Pkg.PackageSpec}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
PackageSpec(name::String, [uuid::UUID, version::VersionNumber])
PackageSpec(; name, url, path, rev, version, mode, level)
\end{minted}

A \texttt{PackageSpec} is a representation of a package with various metadata. This includes:

\begin{itemize}
\item The \texttt{name} of the package.


\item The package{\textquotesingle}s unique \texttt{uuid}.


\item A \texttt{version} (for example when adding a package). When upgrading, can also be an instance of

\end{itemize}
the enum \hyperlink{13785530562686832335}{\texttt{UpgradeLevel}}.

\begin{itemize}
\item A \texttt{url} and an optional git \texttt{rev}ision. \texttt{rev} can be a branch name or a git commit SHA1.


\item A local \texttt{path}. This is equivalent to using the \texttt{url} argument but can be more descriptive.


\item A \texttt{mode}, which is an instance of the enum \hyperlink{3271836720350904911}{\texttt{PackageMode}}, with possible values \texttt{PKGMODE\_PROJECT}

\end{itemize}
(the default) or \texttt{PKGMODE\_MANIFEST}. Used in e.g. \hyperlink{4147981366221469810}{\texttt{Pkg.rm}}.

Most functions in Pkg take a \texttt{Vector} of \texttt{PackageSpec} and do the operation on all the packages in the vector.

Below is a comparison between the REPL version and the API version:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\texttt{REPL} & \texttt{API} \\
\hline
\texttt{Package} & \texttt{PackageSpec({\textquotedbl}Package{\textquotedbl})} \\
\hline
\texttt{Package@0.2} & \texttt{PackageSpec(name={\textquotedbl}Package{\textquotedbl}, version={\textquotedbl}0.2{\textquotedbl})} \\
\hline
\texttt{Package=a67d...} & \texttt{PackageSpec(name={\textquotedbl}Package{\textquotedbl}, uuid={\textquotedbl}a67d...{\textquotedbl})} \\
\hline
\texttt{Package\#master} & \texttt{PackageSpec(name={\textquotedbl}Package{\textquotedbl}, rev={\textquotedbl}master{\textquotedbl})} \\
\hline
\texttt{local/path\#feature} & \texttt{PackageSpec(path={\textquotedbl}local/path{\textquotedbl}; rev={\textquotedbl}feature{\textquotedbl})} \\
\hline
\texttt{www.mypkg.com} & \texttt{PackageSpec(url={\textquotedbl}www.mypkg.com{\textquotedbl})} \\
\hline
\texttt{--manifest Package} & \texttt{PackageSpec(name={\textquotedbl}Package{\textquotedbl}, mode=PKGSPEC\_MANIFEST)} \\
\hline
\texttt{--major Package} & \texttt{PackageSpec(name={\textquotedbl}Package{\textquotedbl}, version=PKGLEVEL\_MAJOR)} \\
\hline
\end{tabulary}

\end{table}



\end{adjustwidth}
\hypertarget{3271836720350904911}{} 
\hyperlink{3271836720350904911}{\texttt{Pkg.PackageMode}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
PackageMode
\end{minted}

An enum with the instances

\begin{itemize}
\item \texttt{PKGMODE\_MANIFEST}


\item \texttt{PKGMODE\_PROJECT}

\end{itemize}
Determines if operations should be made on a project or manifest level. Used as an argument to  \hyperlink{7769325907319883786}{\texttt{PackageSpec}} or as an argument to \hyperlink{4147981366221469810}{\texttt{Pkg.rm}}.



\end{adjustwidth}
\hypertarget{13785530562686832335}{} 
\hyperlink{13785530562686832335}{\texttt{Pkg.UpgradeLevel}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UpgradeLevel
\end{minted}

An enum with the instances

\begin{itemize}
\item \texttt{UPLEVEL\_FIXED}


\item \texttt{UPLEVEL\_PATCH}


\item \texttt{UPLEVEL\_MINOR}


\item \texttt{UPLEVEL\_MAJOR}

\end{itemize}
Determines how much a package is allowed to be updated. Used as an argument to  \hyperlink{7769325907319883786}{\texttt{PackageSpec}} or as an argument to \hyperlink{10543171283952432470}{\texttt{Pkg.update}}.



\end{adjustwidth}
\hypertarget{8338790878119011265}{} 
\hyperlink{8338790878119011265}{\texttt{Pkg.add}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Pkg.add(pkg::Union{String, Vector{String}}; preserve=PRESERVE_TIERED)
Pkg.add(pkg::Union{PackageSpec, Vector{PackageSpec}}; preserve=PRESERVE_TIERED)
\end{minted}

Add a package to the current project. This package will be available by using the \texttt{import} and \texttt{using} keywords in the Julia REPL, and if the current project is a package, also inside that package.

\textbf{Resolution Tiers}

\texttt{Pkg} resolves the set of packages in your environment using a tiered algorithm. The \texttt{preserve} keyword argument allows you to key into a specific tier in the resolve algorithm. The following table describes the argument values for \texttt{preserve} (in order of strictness):


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Value & Description \\
\hline
\texttt{PRESERVE\_ALL} & Preserve the state of all existing dependencies (including recursive dependencies) \\
\hline
\texttt{PRESERVE\_DIRECT} & Preserve the state of all existing direct dependencies \\
\hline
\texttt{PRESERVE\_SEMVER} & Preserve semver-compatible versions of direct dependencies \\
\hline
\texttt{PRESERVE\_NONE} & Do not attempt to preserve any version information \\
\hline
\texttt{PRESERVE\_TIERED} & Use the tier which will preserve the most version information (this is the default) \\
\hline
\end{tabulary}

\end{table}

\textbf{Examples}


\begin{minted}{julia}
Pkg.add("Example") # Add a package from registry
Pkg.add("Example"; preserve=Pkg.PRESERVE_ALL) # Add the `Example` package and preserve existing dependencies
Pkg.add(PackageSpec(name="Example", version="0.3")) # Specify version; latest release in the 0.3 series
Pkg.add(PackageSpec(name="Example", version="0.3.1")) # Specify version; exact release
Pkg.add(PackageSpec(url="https://github.com/JuliaLang/Example.jl", rev="master")) # From url to remote gitrepo
Pkg.add(PackageSpec(url="/remote/mycompany/juliapackages/OurPackage")) # From path to local gitrepo
\end{minted}

See also \hyperlink{7769325907319883786}{\texttt{PackageSpec}}.



\end{adjustwidth}
\hypertarget{9095967362638559586}{} 
\hyperlink{9095967362638559586}{\texttt{Pkg.develop}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Pkg.develop(pkg::Union{String, Vector{String}})
Pkg.develop(pkgs::Union{Packagespec, Vector{Packagespec}})
\end{minted}

Make a package available for development by tracking it by path. If \texttt{pkg} is given with only a name or by a URL, the package will be downloaded to the location specified by the environment variable \texttt{JULIA\_PKG\_DEVDIR}, with \texttt{.julia/dev} as the default.

If \texttt{pkg} is given as a local path, the package at that path will be tracked.

\textbf{Examples}


\begin{minted}{julia}
# By name
Pkg.develop("Example")

# By url
Pkg.develop(PackageSpec(url="https://github.com/JuliaLang/Compat.jl"))

# By path
Pkg.develop(PackageSpec(path="MyJuliaPackages/Package.jl"))
\end{minted}

See also \hyperlink{7769325907319883786}{\texttt{PackageSpec}}



\end{adjustwidth}
\hypertarget{16970816085069386648}{} 
\hyperlink{16970816085069386648}{\texttt{Pkg.activate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Pkg.activate([s::String]; shared::Bool=false)
\end{minted}

Activate the environment at \texttt{s}. The active environment is the environment that is modified by executing package commands. The logic for what path is activated is as follows:

\begin{itemize}
\item If \texttt{shared} is \texttt{true}, the first existing environment named \texttt{s} from the depots in the depot stack will be activated. If no such environment exists, create and activate that environment in the first depot.


\item If \texttt{s} is an existing path, then activate the environment at that path.


\item If \texttt{s} is a package in the current project and \texttt{s} is tracking a path, then activate the environment at the tracked path.


\item Otherwise, \texttt{s} is interpreted as a non-existing path, which is then activated.

\end{itemize}
If no argument is given to \texttt{activate}, then activate the home project. The home project is specified by either the \texttt{--project} command line option to the julia executable, or the \texttt{JULIA\_PROJECT} environment variable.

\textbf{Examples}


\begin{lstlisting}
Pkg.activate()
Pkg.activate("local/path")
Pkg.activate("MyDependency")
\end{lstlisting}



\end{adjustwidth}
\hypertarget{4147981366221469810}{} 
\hyperlink{4147981366221469810}{\texttt{Pkg.rm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Pkg.rm(pkg::Union{String, Vector{String}})
Pkg.rm(pkg::Union{PackageSpec, Vector{PackageSpec}})
\end{minted}

Remove a package from the current project. If the \texttt{mode} of \texttt{pkg} is \texttt{PKGMODE\_MANIFEST} also remove it from the manifest including all recursive dependencies of \texttt{pkg}.

See also \hyperlink{7769325907319883786}{\texttt{PackageSpec}}, \hyperlink{3271836720350904911}{\texttt{PackageMode}}.



\end{adjustwidth}
\hypertarget{10543171283952432470}{} 
\hyperlink{10543171283952432470}{\texttt{Pkg.update}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Pkg.update(; level::UpgradeLevel=UPLEVEL_MAJOR, mode::PackageMode = PKGMODE_PROJECT)
Pkg.update(pkg::Union{String, Vector{String}})
Pkg.update(pkg::Union{PackageSpec, Vector{PackageSpec}})
\end{minted}

Update a package \texttt{pkg}. If no posistional argument is given, update all packages in the manifest if \texttt{mode} is \texttt{PKGMODE\_MANIFEST} and packages in both manifest and project if \texttt{mode} is \texttt{PKGMODE\_PROJECT}. If no positional argument is given, \texttt{level} can be used to control by how much packages are allowed to be upgraded (major, minor, patch, fixed).

See also \hyperlink{7769325907319883786}{\texttt{PackageSpec}}, \hyperlink{3271836720350904911}{\texttt{PackageMode}}, \hyperlink{13785530562686832335}{\texttt{UpgradeLevel}}.



\end{adjustwidth}
\hypertarget{7033600981039054461}{} 
\hyperlink{7033600981039054461}{\texttt{Pkg.test}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Pkg.test(; kwargs...)
Pkg.test(pkg::Union{String, Vector{String}; kwargs...)
Pkg.test(pkgs::Union{PackageSpec, Vector{PackageSpec}}; kwargs...)
\end{minted}

\textbf{Keyword arguments:}

\begin{itemize}
\item \texttt{coverage::Bool=false}: enable or disable generation of coverage statistics.


\item \texttt{julia\_args::Union\{Cmd, Vector\{String\}\}}: options to be passed the test process.


\item \texttt{test\_args::Union\{Cmd, Vector\{String\}\}}: test arguments (\texttt{ARGS}) available in the test process.

\end{itemize}
\begin{quote}
\textbf{Julia 1.3}

\texttt{julia\_args} and \texttt{test\_args} requires at least Julia 1.3.

\end{quote}
Run the tests for package \texttt{pkg}, or for the current project (which thus needs to be a package) if no positional argument is given to \texttt{Pkg.test}. A package is tested by running its \texttt{test/runtests.jl} file.

The tests are run by generating a temporary environment with only \texttt{pkg} and its (recursive) dependencies in it. If a manifest exists, the versions in that manifest are used, otherwise a feasible set of packages is resolved and installed.

During the tests, test-specific dependencies are active, which are given in the project file as e.g.


\begin{lstlisting}
[extras]
Test = "8dfed614-e22c-5e08-85e1-65c5234f0b40"

[targets]
test = ["Test"]
\end{lstlisting}

The tests are executed in a new process with \texttt{check-bounds=yes} and by default \texttt{startup-file=no}. If using the startup file (\texttt{{\textasciitilde}/.julia/config/startup.jl}) is desired, start julia with \texttt{--startup-file=yes}. Inlining of functions during testing can be disabled (for better coverage accuracy) by starting julia with \texttt{--inline=no}.



\end{adjustwidth}
\hypertarget{1343006981993025790}{} 
\hyperlink{1343006981993025790}{\texttt{Pkg.build}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Pkg.build(; verbose = false)
Pkg.build(pkg::Union{String, Vector{String}}; verbose = false)
Pkg.build(pkgs::Union{PackageSpec, Vector{PackageSpec}}; verbose = false)
\end{minted}

Run the build script in \texttt{deps/build.jl} for \texttt{pkg} and all of its dependencies in depth-first recursive order. If no argument is given to \texttt{build}, the current project is built, which thus needs to be a package. This function is called automatically on any package that gets installed for the first time. \texttt{verbose = true} prints the build output to \texttt{stdout}/\texttt{stderr} instead of redirecting to the \texttt{build.log} file.



\end{adjustwidth}
\hypertarget{9776080518771630101}{} 
\hyperlink{9776080518771630101}{\texttt{Pkg.pin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Pkg.pin(pkg::Union{String, Vector{String}})
Pkg.pin(pkgs::Union{PackageSpec, Vector{PackageSpec}})
\end{minted}

Pin a package to the current version (or the one given in the \texttt{PackageSpec}) or to a certain git revision. A pinned package is never updated.

\textbf{Examples}


\begin{minted}{julia}
Pkg.pin("Example")
Pkg.pin(PackageSpec(name="Example", version="0.3.1"))
\end{minted}



\end{adjustwidth}
\hypertarget{11960612719163184326}{} 
\hyperlink{11960612719163184326}{\texttt{Pkg.free}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Pkg.free(pkg::Union{String, Vector{String}})
Pkg.free(pkgs::Union{PackageSpec, Vector{PackageSpec}})
\end{minted}

If \texttt{pkg} is pinned, remove the pin. If \texttt{pkg} is tracking a path, e.g. after \hyperlink{9095967362638559586}{\texttt{Pkg.develop}}, go back to tracking registered versions.

\textbf{Examples}


\begin{minted}{julia}
Pkg.free("Package")
Pkg.free(PackageSpec("Package"))
\end{minted}



\end{adjustwidth}
\hypertarget{14292589817666425387}{} 
\hyperlink{14292589817666425387}{\texttt{Pkg.instantiate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Pkg.instantiate(; verbose = false)
\end{minted}

If a \texttt{Manifest.toml} file exists in the active project, download all the packages declared in that manifest. Otherwise, resolve a set of feasible packages from the \texttt{Project.toml} files and install them. \texttt{verbose = true} prints the build output to \texttt{stdout}/\texttt{stderr} instead of redirecting to the \texttt{build.log} file. If no \texttt{Project.toml} exist in the current active project, create one with all the dependencies in the manifest and instantiate the resulting project.



\end{adjustwidth}
\hypertarget{13977221485522627510}{} 
\hyperlink{13977221485522627510}{\texttt{Pkg.resolve}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Pkg.resolve()
\end{minted}

Update the current manifest with potential changes to the dependency graph from packages that are tracking a path.



\end{adjustwidth}
\hypertarget{1574626393961447104}{} 
\hyperlink{1574626393961447104}{\texttt{Pkg.setprotocol!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
setprotocol!(;
    domain::AbstractString = "github.com",
    protocol::Union{Nothing, AbstractString}=nothing
)
\end{minted}

Set the protocol used to access hosted packages when \texttt{add}ing a url or \texttt{develop}ing a package. Defaults to delegating the choice to the package developer (\texttt{protocol === nothing}). Other choices for \texttt{protocol} are \texttt{{\textquotedbl}https{\textquotedbl}} or \texttt{{\textquotedbl}git{\textquotedbl}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Pkg.setprotocol!(domain = "github.com", protocol = "ssh")

julia> Pkg.setprotocol!(domain = "gitlab.mycompany.com")
\end{minted}



\end{adjustwidth}

\hypertarget{5039001780758746770}{}


\chapter{Printf}


\hypertarget{13954719910189591998}{} 
\hyperlink{13954719910189591998}{\texttt{Printf.@printf}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@printf([io::IOStream], "%Fmt", args...)
\end{minted}

Print \texttt{args} using C \texttt{printf} style format specification string, with some caveats: \texttt{Inf} and \texttt{NaN} are printed consistently as \texttt{Inf} and \texttt{NaN} for flags \texttt{\%a}, \texttt{\%A}, \texttt{\%e}, \texttt{\%E}, \texttt{\%f}, \texttt{\%F}, \texttt{\%g}, and \texttt{\%G}. Furthermore, if a floating point number is equally close to the numeric values of two possible output strings, the output string further away from zero is chosen.

Optionally, an \hyperlink{12496894737220238417}{\texttt{IOStream}} may be passed as the first argument to redirect output.

See also: \hyperlink{13977800180580695709}{\texttt{@sprintf}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> @printf("%f %F %f %F\n", Inf, Inf, NaN, NaN)
Inf Inf NaN NaN


julia> @printf "%.0f %.1f %f\n" 0.5 0.025 -0.0078125
1 0.0 -0.007813
\end{minted}



\end{adjustwidth}
\hypertarget{13977800180580695709}{} 
\hyperlink{13977800180580695709}{\texttt{Printf.@sprintf}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@sprintf("%Fmt", args...)
\end{minted}

Return \texttt{@printf} formatted output as string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> s = @sprintf "this is a %s %15.1f" "test" 34.567;

julia> println(s)
this is a test            34.6
\end{minted}



\end{adjustwidth}

\hypertarget{13446659783021526147}{}


\chapter{性能分析}


\hypertarget{9691715859147716436}{} 
\hyperlink{9691715859147716436}{\texttt{Profile.@profile}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@profile
\end{minted}

\texttt{@profile <expression>} runs your expression while taking periodic backtraces. These are appended to an internal buffer of backtraces.



\end{adjustwidth}

\texttt{Profile} 里的方法均未导出，需要通过 \texttt{Profile.print()} 的方式调用。


\hypertarget{15414823368700214048}{} 
\hyperlink{15414823368700214048}{\texttt{Profile.clear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
clear()
\end{minted}

Clear any existing backtraces from the internal buffer.



\end{adjustwidth}
\hypertarget{2955792207246042270}{} 
\hyperlink{2955792207246042270}{\texttt{Profile.print}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
print([io::IO = stdout,] [data::Vector]; kwargs...)
\end{minted}

Prints profiling results to \texttt{io} (by default, \texttt{stdout}). If you do not supply a \texttt{data} vector, the internal buffer of accumulated backtraces will be used.

The keyword arguments can be any combination of:

\begin{itemize}
\item \texttt{format} – Determines whether backtraces are printed with (default, \texttt{:tree}) or without (\texttt{:flat}) indentation indicating tree structure.


\item \texttt{C} – If \texttt{true}, backtraces from C and Fortran code are shown (normally they are excluded).


\item \texttt{combine} – If \texttt{true} (default), instruction pointers are merged that correspond to the same line of code.


\item \texttt{maxdepth} – Limits the depth higher than \texttt{maxdepth} in the \texttt{:tree} format.


\item \texttt{sortedby} – Controls the order in \texttt{:flat} format. \texttt{:filefuncline} (default) sorts by the source  line, \texttt{:count} sorts in order of number of collected samples, and \texttt{:overhead} sorts by the number of samples  incurred by each function by itself.


\item \texttt{noisefloor} – Limits frames that exceed the heuristic noise floor of the sample (only applies to format \texttt{:tree}).  A suggested value to try for this is 2.0 (the default is 0). This parameter hides samples for which \texttt{n <= noisefloor * √N},  where \texttt{n} is the number of samples on this line, and \texttt{N} is the number of samples for the callee.


\item \texttt{mincount} – Limits the printout to only those lines with at least \texttt{mincount} occurrences.


\item \texttt{recur} – Controls the recursion handling in \texttt{:tree} format. \texttt{:off} (default) prints the tree as normal. \texttt{:flat} instead  compresses any recursion (by ip), showing the approximate effect of converting any self-recursion into an iterator.  \texttt{:flatc} does the same but also includes collapsing of C frames (may do odd things around \texttt{jl\_apply}).

\end{itemize}



\begin{lstlisting}
print([io::IO = stdout,] data::Vector, lidict::LineInfoDict; kwargs...)
\end{lstlisting}

Prints profiling results to \texttt{io}. This variant is used to examine results exported by a previous call to \hyperlink{10202508103131430980}{\texttt{retrieve}}. Supply the vector \texttt{data} of backtraces and a dictionary \texttt{lidict} of line information.

See \texttt{Profile.print([io], data)} for an explanation of the valid keyword arguments.



\end{adjustwidth}
\hypertarget{11074776852943687092}{} 
\hyperlink{11074776852943687092}{\texttt{Profile.init}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
init(; n::Integer, delay::Real))
\end{minted}

Configure the \texttt{delay} between backtraces (measured in seconds), and the number \texttt{n} of instruction pointers that may be stored. Each instruction pointer corresponds to a single line of code; backtraces generally consist of a long list of instruction pointers. Default settings can be obtained by calling this function with no arguments, and each can be set independently using keywords or in the order \texttt{(n, delay)}.



\end{adjustwidth}
\hypertarget{3578108280181558112}{} 
\hyperlink{3578108280181558112}{\texttt{Profile.fetch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fetch() -> data
\end{minted}

Returns a copy of the buffer of profile backtraces. Note that the values in \texttt{data} have meaning only on this machine in the current session, because it depends on the exact memory addresses used in JIT-compiling. This function is primarily for internal use; \hyperlink{10202508103131430980}{\texttt{retrieve}} may be a better choice for most users.



\end{adjustwidth}
\hypertarget{10202508103131430980}{} 
\hyperlink{10202508103131430980}{\texttt{Profile.retrieve}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
retrieve() -> data, lidict
\end{minted}

{\textquotedbl}Exports{\textquotedbl} profiling results in a portable format, returning the set of all backtraces (\texttt{data}) and a dictionary that maps the (session-specific) instruction pointers in \texttt{data} to \texttt{LineInfo} values that store the file name, function name, and line number. This function allows you to save profiling results for future analysis.



\end{adjustwidth}
\hypertarget{14497996294492518181}{} 
\hyperlink{14497996294492518181}{\texttt{Profile.callers}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
callers(funcname, [data, lidict], [filename=<filename>], [linerange=<start:stop>]) -> Vector{Tuple{count, lineinfo}}
\end{minted}

Given a previous profiling run, determine who called a particular function. Supplying the filename (and optionally, range of line numbers over which the function is defined) allows you to disambiguate an overloaded method. The returned value is a vector containing a count of the number of calls and line information about the caller. One can optionally supply backtrace \texttt{data} obtained from \hyperlink{10202508103131430980}{\texttt{retrieve}}; otherwise, the current internal profile buffer is used.



\end{adjustwidth}
\hypertarget{12697816172521511938}{} 
\hyperlink{12697816172521511938}{\texttt{Profile.clear\_malloc\_data}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
clear_malloc_data()
\end{minted}

Clears any stored memory allocation data when running julia with \texttt{--track-allocation}. Execute the command(s) you want to test (to force JIT-compilation), then call \hyperlink{12697816172521511938}{\texttt{clear\_malloc\_data}}. Then execute your command(s) again, quit Julia, and examine the resulting \texttt{*.mem} files.



\end{adjustwidth}

\hypertarget{2176533558823998019}{}


\chapter{Julia REPL}



Julia 附带了一个全功能的交互式命令行 REPL（read-eval-print loop），其内置于 \texttt{julia} 可执行文件中。它除了允许快速简便地执行 Julia 语句外，还具有可搜索的历史记录，tab 补全，许多有用的按键绑定以及专用的 help 和 shell 模式。只需不附带任何参数地调用 \texttt{julia} 或双击可执行文件即可启动 REPL：




\begin{lstlisting}
$ julia

               _
   _       _ _(_)_     |  Documentation: https://docs.julialang.org
  (_)     | (_) (_)    |
   _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 1.4.2 (2020-05-23)
 _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release
|__/                   |


julia>
\end{lstlisting}



To exit the interactive session, type \texttt{{\textasciicircum}D} – the control key together with the \texttt{d} key on a blank line – or type \texttt{exit()} followed by the return or enter key. The REPL greets you with a banner and a \texttt{julia>} prompt.



\hypertarget{13843805802306265376}{}


\section{不同的提示符模式}



\hypertarget{2631446594844418165}{}


\subsection{Julian 模式}



REPL 有四种主要的操作模式。第一个也是最常见的是 Julian 提示符。这是默认的操作模式；每个新行最初都以 \texttt{julia>} 开头。就在这里，你可以输入 Julia 表达式。在输入完整表达式后按下 return 或 enter 将执行该表达式，并显示最后一个表达式的结果。




\begin{minted}{jlcon}
julia> string(1 + 2)
"3"
\end{minted}



交互式运行有许多独特的实用功能。除了显示结果外，REPL 还将结果绑定到变量 \texttt{ans} 上。一行的尾随分号可用作禁止显示结果的标志。




\begin{minted}{jlcon}
julia> string(3 * 4);

julia> ans
"12"
\end{minted}



In Julia mode, the REPL supports something called \emph{prompt pasting}. This activates when pasting text that starts with \texttt{julia>} into the REPL. In that case, only expressions starting with \texttt{julia>} are parsed, others are removed. This makes it is possible to paste a chunk of code that has been copied from a REPL session without having to scrub away prompts and outputs. This feature is enabled by default but can be disabled or enabled at will with \texttt{REPL.enable\_promptpaste(::Bool)}. If it is enabled, you can try it out by pasting the code block above this paragraph straight into the REPL. This feature does not work on the standard Windows command prompt due to its limitation at detecting when a paste occurs.



Objects are printed at the REPL using the \hyperlink{14071376285304310153}{\texttt{show}} function with a specific \hyperlink{13454403377667762339}{\texttt{IOContext}}. In particular, the \texttt{:limit} attribute is set to \texttt{true}. Other attributes can receive in certain \texttt{show} methods a default value if it{\textquotesingle}s not already set, like \texttt{:compact}. It{\textquotesingle}s possible, as an experimental feature, to specify the attributes used by the REPL via the \texttt{Base.active\_repl.options.iocontext} dictionary (associating values to attributes). For example:




\begin{minted}{jlcon}
julia> rand(2, 2)
2×2 Array{Float64,2}:
 0.8833    0.329197
 0.719708  0.59114

julia> show(IOContext(stdout, :compact => false), "text/plain", rand(2, 2))
 0.43540323669187075  0.15759787870609387
 0.2540832269192739   0.4597637838786053
julia> Base.active_repl.options.iocontext[:compact] = false;

julia> rand(2, 2)
2×2 Array{Float64,2}:
 0.2083967319174056  0.13330606013126012
 0.6244375177790158  0.9777957560761545
\end{minted}



In order to define automatically the values of this dictionary at startup time, one can use the \hyperlink{1741947168860119796}{\texttt{atreplinit}} function in the \texttt{{\textasciitilde}/.julia/config/startup.jl} file, for example:




\begin{minted}{julia}
atreplinit() do repl
    repl.options.iocontext[:compact] = false
end
\end{minted}



\hypertarget{8090123169740528583}{}


\subsection{Help mode}



When the cursor is at the beginning of the line, the prompt can be changed to a help mode by typing \texttt{?}. Julia will attempt to print help or documentation for anything entered in help mode:




\begin{minted}{jlcon}
julia> ? # upon typing ?, the prompt changes (in place) to: help?>

help?> string
search: string String Cstring Cwstring RevString randstring bytestring SubString

  string(xs...)

  Create a string from any values using the print function.
\end{minted}



Macros, types and variables can also be queried:




\begin{lstlisting}
help?> @time
  @time

  A macro to execute an expression, printing the time it took to execute, the number of allocations,
  and the total number of bytes its execution caused to be allocated, before returning the value of the
  expression.

  See also @timev, @timed, @elapsed, and @allocated.

help?> Int32
search: Int32 UInt32

  Int32 <: Signed

  32-bit signed integer type.
\end{lstlisting}



Help mode can be exited by pressing backspace at the beginning of the line.



\hypertarget{17654100848947676892}{}


\subsection{Shell mode}



Just as help mode is useful for quick access to documentation, another common task is to use the system shell to execute system commands. Just as \texttt{?} entered help mode when at the beginning of the line, a semicolon (\texttt{;}) will enter the shell mode. And it can be exited by pressing backspace at the beginning of the line.




\begin{minted}{jlcon}
julia> ; # upon typing ;, the prompt changes (in place) to: shell>

shell> echo hello
hello
\end{minted}



\begin{quote}
\textbf{Note}

For Windows users, Julia{\textquotesingle}s shell mode does not expose windows shell commands. Hence, this will fail:

\end{quote}



\begin{minted}{jlcon}
julia> ; # upon typing ;, the prompt changes (in place) to: shell>

shell> dir
ERROR: IOError: could not spawn `dir`: no such file or directory (ENOENT)
Stacktrace!
.......
\end{minted}



However, you can get access to \texttt{PowerShell} like this:




\begin{minted}{jlcon}
julia> ; # upon typing ;, the prompt changes (in place) to: shell>

shell> powershell
Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.
PS C:\Users\elm>
\end{minted}



... and to \texttt{cmd.exe} like that (see the \texttt{dir} command):




\begin{minted}{jlcon}
julia> ; # upon typing ;, the prompt changes (in place) to: shell>

shell> cmd
Microsoft Windows [version 10.0.17763.973]
(c) 2018 Microsoft Corporation. All rights reserved.
C:\Users\elm>dir
 Volume in drive C has no label
 Volume Serial Number is 1643-0CD7
  Directory of C:\Users\elm

29/01/2020  22:15    <DIR>          .
29/01/2020  22:15    <DIR>          ..
02/02/2020  08:06    <DIR>          .atom
\end{minted}



\hypertarget{13961930499248375782}{}


\subsection{Search modes}



In all of the above modes, the executed lines get saved to a history file, which can be searched.  To initiate an incremental search through the previous history, type \texttt{{\textasciicircum}R} – the control key together with the \texttt{r} key. The prompt will change to \texttt{(reverse-i-search)`{\textquotesingle}:}, and as you type the search query will appear in the quotes. The most recent result that matches the query will dynamically update to the right of the colon as more is typed. To find an older result using the same query, simply type \texttt{{\textasciicircum}R} again.



Just as \texttt{{\textasciicircum}R} is a reverse search, \texttt{{\textasciicircum}S} is a forward search, with the prompt \texttt{(i-search)`{\textquotesingle}:}.  The two may be used in conjunction with each other to move through the previous or next matching results, respectively.



\hypertarget{11229238099061625177}{}


\section{Key bindings}



The Julia REPL makes great use of key bindings. Several control-key bindings were already introduced above (\texttt{{\textasciicircum}D} to exit, \texttt{{\textasciicircum}R} and \texttt{{\textasciicircum}S} for searching), but there are many more. In addition to the control-key, there are also meta-key bindings. These vary more by platform, but most terminals default to using alt- or option- held down with a key to send the meta-key (or can be configured to do so), or pressing Esc and then the key.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Keybinding & Description \\
\hline
\textbf{Program control} &  \\
\hline
\texttt{{\textasciicircum}D} & Exit (when buffer is empty) \\
\hline
\texttt{{\textasciicircum}C} & Interrupt or cancel \\
\hline
\texttt{{\textasciicircum}L} & Clear console screen \\
\hline
Return/Enter, \texttt{{\textasciicircum}J} & New line, executing if it is complete \\
\hline
meta-Return/Enter & Insert new line without executing it \\
\hline
\texttt{?} or \texttt{;} & Enter help or shell mode (when at start of a line) \\
\hline
\texttt{{\textasciicircum}R}, \texttt{{\textasciicircum}S} & Incremental history search, described above \\
\hline
\textbf{Cursor movement} &  \\
\hline
Right arrow, \texttt{{\textasciicircum}F} & Move right one character \\
\hline
Left arrow, \texttt{{\textasciicircum}B} & Move left one character \\
\hline
ctrl-Right, \texttt{meta-F} & Move right one word \\
\hline
ctrl-Left, \texttt{meta-B} & Move left one word \\
\hline
Home, \texttt{{\textasciicircum}A} & Move to beginning of line \\
\hline
End, \texttt{{\textasciicircum}E} & Move to end of line \\
\hline
Up arrow, \texttt{{\textasciicircum}P} & Move up one line (or change to the previous history entry that matches the text before the cursor) \\
\hline
Down arrow, \texttt{{\textasciicircum}N} & Move down one line (or change to the next history entry that matches the text before the cursor) \\
\hline
Shift-Arrow Key & Move cursor according to the direction of the Arrow key, while activating the region ({\textquotedbl}shift selection{\textquotedbl}) \\
\hline
Page-up, \texttt{meta-P} & Change to the previous history entry \\
\hline
Page-down, \texttt{meta-N} & Change to the next history entry \\
\hline
\texttt{meta-<} & Change to the first history entry (of the current session if it is before the current position in history) \\
\hline
\texttt{meta->} & Change to the last history entry \\
\hline
\texttt{{\textasciicircum}-Space} & Set the {\textquotedbl}mark{\textquotedbl} in the editing region (and de-activate the region if it{\textquotesingle}s active) \\
\hline
\texttt{{\textasciicircum}-Space {\textasciicircum}-Space} & Set the {\textquotedbl}mark{\textquotedbl} in the editing region and make the region {\textquotedbl}active{\textquotedbl}, i.e. highlighted \\
\hline
\texttt{{\textasciicircum}G} & De-activate the region (i.e. make it not highlighted) \\
\hline
\texttt{{\textasciicircum}X{\textasciicircum}X} & Exchange the current position with the mark \\
\hline
\textbf{Editing} &  \\
\hline
Backspace, \texttt{{\textasciicircum}H} & Delete the previous character, or the whole region when it{\textquotesingle}s active \\
\hline
Delete, \texttt{{\textasciicircum}D} & Forward delete one character (when buffer has text) \\
\hline
meta-Backspace & Delete the previous word \\
\hline
\texttt{meta-d} & Forward delete the next word \\
\hline
\texttt{{\textasciicircum}W} & Delete previous text up to the nearest whitespace \\
\hline
\texttt{meta-w} & Copy the current region in the kill ring \\
\hline
\texttt{meta-W} & {\textquotedbl}Kill{\textquotedbl} the current region, placing the text in the kill ring \\
\hline
\texttt{{\textasciicircum}K} & {\textquotedbl}Kill{\textquotedbl} to end of line, placing the text in the kill ring \\
\hline
\texttt{{\textasciicircum}Y} & {\textquotedbl}Yank{\textquotedbl} insert the text from the kill ring \\
\hline
\texttt{meta-y} & Replace a previously yanked text with an older entry from the kill ring \\
\hline
\texttt{{\textasciicircum}T} & Transpose the characters about the cursor \\
\hline
\texttt{meta-Up arrow} & Transpose current line with line above \\
\hline
\texttt{meta-Down arrow} & Transpose current line with line below \\
\hline
\texttt{meta-u} & Change the next word to uppercase \\
\hline
\texttt{meta-c} & Change the next word to titlecase \\
\hline
\texttt{meta-l} & Change the next word to lowercase \\
\hline
\texttt{{\textasciicircum}/}, \texttt{{\textasciicircum}\_} & Undo previous editing action \\
\hline
\texttt{{\textasciicircum}Q} & Write a number in REPL and press \texttt{{\textasciicircum}Q} to open editor at corresponding stackframe or method \\
\hline
\texttt{meta-Left Arrow} & indent the current line on the left \\
\hline
\texttt{meta-Right Arrow} & indent the current line on the right \\
\hline
\texttt{meta-.} & insert last word from previous history entry \\
\hline
\end{tabulary}

\end{table}



\hypertarget{12600332236460824227}{}


\subsection{Customizing keybindings}



Julia{\textquotesingle}s REPL keybindings may be fully customized to a user{\textquotesingle}s preferences by passing a dictionary to \texttt{REPL.setup\_interface}. The keys of this dictionary may be characters or strings. The key \texttt{{\textquotesingle}*{\textquotesingle}} refers to the default action. Control plus character \texttt{x} bindings are indicated with \texttt{{\textquotedbl}{\textasciicircum}x{\textquotedbl}}. Meta plus \texttt{x} can be written \texttt{{\textquotedbl}{\textbackslash}{\textbackslash}M-x{\textquotedbl}} or \texttt{{\textquotedbl}{\textbackslash}ex{\textquotedbl}}, and Control plus \texttt{x} can be written \texttt{{\textquotedbl}{\textbackslash}{\textbackslash}C-x{\textquotedbl}} or \texttt{{\textquotedbl}{\textasciicircum}x{\textquotedbl}}. The values of the custom keymap must be \texttt{nothing} (indicating that the input should be ignored) or functions that accept the signature \texttt{(PromptState, AbstractREPL, Char)}. The \texttt{REPL.setup\_interface} function must be called before the REPL is initialized, by registering the operation with \hyperlink{1741947168860119796}{\texttt{atreplinit}} . For example, to bind the up and down arrow keys to move through history without prefix search, one could put the following code in \texttt{{\textasciitilde}/.julia/config/startup.jl}:




\begin{minted}{julia}
import REPL
import REPL.LineEdit

const mykeys = Dict{Any,Any}(
    # Up Arrow
    "\e[A" => (s,o...)->(LineEdit.edit_move_up(s) || LineEdit.history_prev(s, LineEdit.mode(s).hist)),
    # Down Arrow
    "\e[B" => (s,o...)->(LineEdit.edit_move_down(s) || LineEdit.history_next(s, LineEdit.mode(s).hist))
)

function customize_keys(repl)
    repl.interface = REPL.setup_interface(repl; extra_repl_keymap = mykeys)
end

atreplinit(customize_keys)
\end{minted}



Users should refer to \texttt{LineEdit.jl} to discover the available actions on key input.



\hypertarget{9567689438493430677}{}


\section{Tab completion}



In both the Julian and help modes of the REPL, one can enter the first few characters of a function or type and then press the tab key to get a list all matches:




\begin{minted}{jlcon}
julia> stri[TAB]
stride     strides     string      strip

julia> Stri[TAB]
StridedArray    StridedMatrix    StridedVecOrMat  StridedVector    String
\end{minted}



The tab key can also be used to substitute LaTeX math symbols with their Unicode equivalents, and get a list of LaTeX matches as well:




\begin{minted}{jlcon}
julia> \pi[TAB]
julia> π
π = 3.1415926535897...

julia> e\_1[TAB] = [1,0]
julia> e₁ = [1,0]
2-element Array{Int64,1}:
 1
 0

julia> e\^1[TAB] = [1 0]
julia> e¹ = [1 0]
1×2 Array{Int64,2}:
 1  0

julia> \sqrt[TAB]2     # √ is equivalent to the sqrt function
julia> √2
1.4142135623730951

julia> \hbar[TAB](h) = h / 2\pi[TAB]
julia> ħ(h) = h / 2π
ħ (generic function with 1 method)

julia> \h[TAB]
\hat              \hermitconjmatrix  \hkswarow          \hrectangle
\hatapprox        \hexagon           \hookleftarrow     \hrectangleblack
\hbar             \hexagonblack      \hookrightarrow    \hslash
\heartsuit        \hksearow          \house             \hspace

julia> α="\alpha[TAB]"   # LaTeX completion also works in strings
julia> α="α"
\end{minted}



A full list of tab-completions can be found in the \href{@ref}{Unicode Input} section of the manual.



Completion of paths works for strings and julia{\textquotesingle}s shell mode:




\begin{minted}{jlcon}
julia> path="/[TAB]"
.dockerenv  .juliabox/   boot/        etc/         lib/         media/       opt/         root/        sbin/        sys/         usr/
.dockerinit bin/         dev/         home/        lib64/       mnt/         proc/        run/         srv/         tmp/         var/
shell> /[TAB]
.dockerenv  .juliabox/   boot/        etc/         lib/         media/       opt/         root/        sbin/        sys/         usr/
.dockerinit bin/         dev/         home/        lib64/       mnt/         proc/        run/         srv/         tmp/         var/
\end{minted}



Tab completion can help with investigation of the available methods matching the input arguments:




\begin{minted}{jlcon}
julia> max([TAB] # All methods are displayed, not shown here due to size of the list

julia> max([1, 2], [TAB] # All methods where `Vector{Int}` matches as first argument
max(x, y) in Base at operators.jl:215
max(a, b, c, xs...) in Base at operators.jl:281

julia> max([1, 2], max(1, 2), [TAB] # All methods matching the arguments.
max(x, y) in Base at operators.jl:215
max(a, b, c, xs...) in Base at operators.jl:281
\end{minted}



Keywords are also displayed in the suggested methods after \texttt{;}, see below line where \texttt{limit} and \texttt{keepempty} are keyword arguments:




\begin{minted}{jlcon}
julia> split("1 1 1", [TAB]
split(str::AbstractString; limit, keepempty) in Base at strings/util.jl:302
split(str::T, splitter; limit, keepempty) where T<:AbstractString in Base at strings/util.jl:277
\end{minted}



The completion of the methods uses type inference and can therefore see if the arguments match even if the arguments are output from functions. The function needs to be type stable for the completion to be able to remove non-matching methods.



Tab completion can also help completing fields:




\begin{minted}{jlcon}
julia> import UUIDs

julia> UUIDs.uuid[TAB]
uuid1        uuid4         uuid_version
\end{minted}



Fields for output from functions can also be completed:




\begin{minted}{jlcon}
julia> split("","")[1].[TAB]
lastindex  offset  string
\end{minted}



The completion of fields for output from functions uses type inference, and it can only suggest fields if the function is type stable.



Dictionary keys can also be tab completed:




\begin{minted}{jlcon}
julia> foo = Dict("qwer1"=>1, "qwer2"=>2, "asdf"=>3)
Dict{String,Int64} with 3 entries:
  "qwer2" => 2
  "asdf"  => 3
  "qwer1" => 1

julia> foo["q[TAB]

"qwer1" "qwer2"
julia> foo["qwer
\end{minted}



\hypertarget{17268458035861597176}{}


\section{Customizing Colors}



The colors used by Julia and the REPL can be customized, as well. To change the color of the Julia prompt you can add something like the following to your \texttt{{\textasciitilde}/.julia/config/startup.jl} file, which is to be placed inside your home directory:




\begin{minted}{julia}
function customize_colors(repl)
    repl.prompt_color = Base.text_colors[:cyan]
end

atreplinit(customize_colors)
\end{minted}



The available color keys can be seen by typing \texttt{Base.text\_colors} in the help mode of the REPL. In addition, the integers 0 to 255 can be used as color keys for terminals with 256 color support.



You can also change the colors for the help and shell prompts and input and answer text by setting the appropriate field of \texttt{repl} in the \texttt{customize\_colors} function above (respectively, \texttt{help\_color}, \texttt{shell\_color}, \texttt{input\_color}, and \texttt{answer\_color}). For the latter two, be sure that the \texttt{envcolors} field is also set to false.



It is also possible to apply boldface formatting by using \texttt{Base.text\_colors[:bold]} as a color. For instance, to print answers in boldface font, one can use the following as a \texttt{{\textasciitilde}/.julia/config/startup.jl}:




\begin{minted}{julia}
function customize_colors(repl)
    repl.envcolors = false
    repl.answer_color = Base.text_colors[:bold]
end

atreplinit(customize_colors)
\end{minted}



You can also customize the color used to render warning and informational messages by setting the appropriate environment variables. For instance, to render error, warning, and informational messages respectively in magenta, yellow, and cyan you can add the following to your \texttt{{\textasciitilde}/.julia/config/startup.jl} file:




\begin{minted}{julia}
ENV["JULIA_ERROR_COLOR"] = :magenta
ENV["JULIA_WARN_COLOR"] = :yellow
ENV["JULIA_INFO_COLOR"] = :cyan
\end{minted}



\hypertarget{12083895020192706202}{}


\section{TerminalMenus}



TerminalMenus is a submodule of the Julia REPL and enables small, low-profile interactive menus in the terminal.



\hypertarget{15337950170852396133}{}


\subsection{Examples}




\begin{minted}{julia}
import REPL
using REPL.TerminalMenus

options = ["apple", "orange", "grape", "strawberry",
            "blueberry", "peach", "lemon", "lime"]

\end{minted}



\hypertarget{10421324822656120463}{}


\subsubsection{RadioMenu}



The RadioMenu allows the user to select one option from the list. The \texttt{request} function displays the interactive menu and returns the index of the selected choice. If a user presses {\textquotesingle}q{\textquotesingle} or \texttt{ctrl-c}, \texttt{request} will return a \texttt{-1}.




\begin{minted}{julia}
# `pagesize` is the number of items to be displayed at a time.
#  The UI will scroll if the number of options is greater
#   than the `pagesize`
menu = RadioMenu(options, pagesize=4)

# `request` displays the menu and returns the index after the
#   user has selected a choice
choice = request("Choose your favorite fruit:", menu)

if choice != -1
    println("Your favorite fruit is ", options[choice], "!")
else
    println("Menu canceled.")
end

\end{minted}



Output:




\begin{lstlisting}
Choose your favorite fruit:
^  grape
   strawberry
 > blueberry
v  peach
Your favorite fruit is blueberry!
\end{lstlisting}



\hypertarget{6295927836435212296}{}


\subsubsection{MultiSelectMenu}



The MultiSelectMenu allows users to select many choices from a list.




\begin{minted}{julia}
# here we use the default `pagesize` 10
menu = MultiSelectMenu(options)

# `request` returns a `Set` of selected indices
# if the menu us canceled (ctrl-c or q), return an empty set
choices = request("Select the fruits you like:", menu)

if length(choices) > 0
    println("You like the following fruits:")
    for i in choices
        println("  - ", options[i])
    end
else
    println("Menu canceled.")
end
\end{minted}



Output:




\begin{lstlisting}
Select the fruits you like:
[press: d=done, a=all, n=none]
   [ ] apple
 > [X] orange
   [X] grape
   [ ] strawberry
   [ ] blueberry
   [X] peach
   [ ] lemon
   [ ] lime
You like the following fruits:
  - orange
  - grape
  - peach
\end{lstlisting}



\hypertarget{664736390801158626}{}


\subsection{Customization / Configuration}



All interface customization is done through the keyword only \texttt{TerminalMenus.config()} function.



\hypertarget{10322653734691696332}{}


\subsubsection{Arguments}



\begin{itemize}
\item \texttt{charset::Symbol=:na}: ui characters to use (\texttt{:ascii} or \texttt{:unicode}); overridden by other arguments


\item \texttt{cursor::Char={\textquotesingle}>{\textquotesingle}|{\textquotesingle}→{\textquotesingle}}: character to use for cursor


\item \texttt{up\_arrow::Char={\textquotesingle}{\textasciicircum}{\textquotesingle}|{\textquotesingle}↑{\textquotesingle}}: character to use for up arrow


\item \texttt{down\_arrow::Char={\textquotesingle}v{\textquotesingle}|{\textquotesingle}↓{\textquotesingle}}: character to use for down arrow


\item \texttt{checked::String={\textquotedbl}[X]{\textquotedbl}|{\textquotedbl}✓{\textquotedbl}}: string to use for checked


\item \texttt{unchecked::String={\textquotedbl}[ ]{\textquotedbl}|{\textquotedbl}⬚{\textquotedbl})}: string to use for unchecked


\item \texttt{scroll::Symbol=:na}: If \texttt{:wrap} then wrap the cursor around top and bottom, if :\texttt{nowrap} do not wrap cursor


\item \texttt{supress\_output::Bool=false}: For testing. If true, menu will not be printed to console.


\item \texttt{ctrl\_c\_interrupt::Bool=true}: If \texttt{false}, return empty on {\textasciicircum}C, if \texttt{true} throw InterruptException() on {\textasciicircum}C

\end{itemize}


\hypertarget{18222617908278532347}{}


\subsubsection{Examples}




\begin{minted}{julia}
julia> menu = MultiSelectMenu(options, pagesize=5);

julia> request(menu) # ASCII is used by default
[press: d=done, a=all, n=none]
   [ ] apple
   [X] orange
   [ ] grape
 > [X] strawberry
v  [ ] blueberry
Set([4, 2])

julia> TerminalMenus.config(charset=:unicode)

julia> request(menu)
[press: d=done, a=all, n=none]
   ⬚ apple
   ✓ orange
   ⬚ grape
 → ✓ strawberry
↓  ⬚ blueberry
Set([4, 2])

julia> TerminalMenus.config(checked="YEP!", unchecked="NOPE", cursor='⧐')

julia> request(menu)
[press: d=done, a=all, n=none]
   NOPE apple
   YEP! orange
   NOPE grape
 ⧐ YEP! strawberry
↓  NOPE blueberry
Set([4, 2])

\end{minted}



\hypertarget{13487828328085508990}{}


\section{References}


\hypertarget{1741947168860119796}{} 
\hyperlink{1741947168860119796}{\texttt{Base.atreplinit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
atreplinit(f)
\end{minted}

Register a one-argument function to be called before the REPL interface is initialized in interactive sessions; this is useful to customize the interface. The argument of \texttt{f} is the REPL object. This function should be called from within the \texttt{.julia/config/startup.jl} initialization file.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/client.jl#L326-L333}{\texttt{source}}


\end{adjustwidth}

\hypertarget{686205674013349701}{}


\chapter{随机数}





Random number generation in Julia uses the \href{http://www.math.sci.hiroshima-u.ac.jp/{\textasciitilde}m-mat/MT/SFMT/\#dSFMT}{Mersenne Twister library} via \texttt{MersenneTwister} objects. Julia has a global RNG, which is used by default. Other RNG types can be plugged in by inheriting the \texttt{AbstractRNG} type; they can then be used to have multiple streams of random numbers. Besides \texttt{MersenneTwister}, Julia also provides the \texttt{RandomDevice} RNG type, which is a wrapper over the OS provided entropy.



大部分与随机数生成相关的函数都接受一个可选的 \texttt{AbstractRNG} 对象作为第一个参数，如果不指定则使用全局默认的。此外，某些函数还接受一个可选的维度参数 \texttt{dims...} (可以是元组）来生成随机数组。



一个 \texttt{MersenneTwister} 或 \texttt{RandomDevice} RNG 能够生成如下类型的随机数： \hyperlink{2727296760866702904}{\texttt{Float16}}, \hyperlink{8101639384272933082}{\texttt{Float32}}, \hyperlink{5027751419500983000}{\texttt{Float64}}, \hyperlink{749816618809421837}{\texttt{BigFloat}}, \hyperlink{46725311238864537}{\texttt{Bool}}, \hyperlink{5857518405103968275}{\texttt{Int8}}, \hyperlink{6609065134969660118}{\texttt{UInt8}}, \hyperlink{6667287249103968645}{\texttt{Int16}}, \hyperlink{7018610346698168012}{\texttt{UInt16}}, \hyperlink{10103694114785108551}{\texttt{Int32}}, \hyperlink{8690996847580776341}{\texttt{UInt32}}, \hyperlink{7720564657383125058}{\texttt{Int64}}, \hyperlink{5500998675195555601}{\texttt{UInt64}}, \hyperlink{8012327724714767060}{\texttt{Int128}}, \hyperlink{14811222188335428522}{\texttt{UInt128}}, \hyperlink{423405808990690832}{\texttt{BigInt}} （或者这些类型的复数）。 随机浮点数在  \([0, 1)\)  区间均匀生成。由于 \texttt{BigInt} 代表无界的整数，必须要指定区间（如 \texttt{rand(big.(1:6))}）。



另外，正态和指数分布是针对某些 \texttt{AbstractFloat} 和 \texttt{Complex} 类型，详细内容见 \hyperlink{7347069443766288058}{\texttt{randn}} 和 \hyperlink{17131026676213441996}{\texttt{randexp}}。



\begin{quote}
\textbf{Warn}

Because the precise way in which random numbers are generated is considered an implementation detail, bug fixes and speed improvements may change the stream of numbers that are generated after a version change. Relying on a specific seed or generated stream of numbers during unit testing is thus discouraged - consider testing properties of the methods in question instead.

\end{quote}


\hypertarget{4356963021367801788}{}


\section{Random numbers module}


\hypertarget{10183586789119175812}{} 
\hyperlink{10183586789119175812}{\texttt{Random.Random}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Random
\end{minted}

Support for generating random numbers. Provides \hyperlink{7668863842145012694}{\texttt{rand}}, \hyperlink{7347069443766288058}{\texttt{randn}}, \hyperlink{17421972100838426566}{\texttt{AbstractRNG}}, \hyperlink{4960058165975837552}{\texttt{MersenneTwister}}, and \hyperlink{14367539717133476780}{\texttt{RandomDevice}}.



\end{adjustwidth}

\hypertarget{17130229276474091458}{}


\section{Random generation functions}


\hypertarget{7668863842145012694}{} 
\hyperlink{7668863842145012694}{\texttt{Base.rand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rand([rng=GLOBAL_RNG], [S], [dims...])
\end{minted}

Pick a random element or array of random elements from the set of values specified by \texttt{S}; \texttt{S} can be

\begin{itemize}
\item an indexable collection (for example \texttt{1:9} or \texttt{({\textquotesingle}x{\textquotesingle}, {\textquotedbl}y{\textquotedbl}, :z)}),


\item an \texttt{AbstractDict} or \texttt{AbstractSet} object,


\item a string (considered as a collection of characters), or


\item a type: the set of values to pick from is then equivalent to \texttt{typemin(S):typemax(S)} for integers (this is not applicable to \hyperlink{423405808990690832}{\texttt{BigInt}}), to  \([0, 1)\)  for floating point numbers and to  \([0, 1)+i[0, 1)]\)  for complex floating point numbers;

\end{itemize}
\texttt{S} defaults to \hyperlink{5027751419500983000}{\texttt{Float64}}. When only one argument is passed besides the optional \texttt{rng} and is a \texttt{Tuple}, it is interpreted as a collection of values (\texttt{S}) and not as \texttt{dims}.

\begin{quote}
\textbf{Julia 1.1}

Support for \texttt{S} as a tuple requires at least Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> rand(Int, 2)
2-element Array{Int64,1}:
 1339893410598768192
 1575814717733606317

julia> using Random

julia> rand(MersenneTwister(0), Dict(1=>2, 3=>4))
1=>2

julia> rand((2, 3))
3

julia> rand(Float64, (2, 3))
2×3 Array{Float64,2}:
 0.999717  0.0143835  0.540787
 0.696556  0.783855   0.938235
\end{minted}

\begin{quote}
\textbf{Note}

The complexity of \texttt{rand(rng, s::Union\{AbstractDict,AbstractSet\})} is linear in the length of \texttt{s}, unless an optimized method with constant complexity is available, which is the case for \texttt{Dict}, \texttt{Set} and \texttt{BitSet}. For more than a few calls, use \texttt{rand(rng, collect(s))} instead, or either \texttt{rand(rng, Dict(s))} or \texttt{rand(rng, Set(s))} as appropriate.

\end{quote}


\end{adjustwidth}
\hypertarget{7078395971362144272}{} 
\hyperlink{7078395971362144272}{\texttt{Random.rand!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rand!([rng=GLOBAL_RNG], A, [S=eltype(A)])
\end{minted}

Populate the array \texttt{A} with random values. If \texttt{S} is specified (\texttt{S} can be a type or a collection, cf. \hyperlink{7668863842145012694}{\texttt{rand}} for details), the values are picked randomly from \texttt{S}. This is equivalent to \texttt{copyto!(A, rand(rng, S, size(A)))} but without allocating a new array.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> rand!(rng, zeros(5))
5-element Array{Float64,1}:
 0.5908446386657102
 0.7667970365022592
 0.5662374165061859
 0.4600853424625171
 0.7940257103317943
\end{minted}



\end{adjustwidth}
\hypertarget{6994846923428691074}{} 
\hyperlink{6994846923428691074}{\texttt{Random.bitrand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
bitrand([rng=GLOBAL_RNG], [dims...])
\end{minted}

Generate a \texttt{BitArray} of random boolean values.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> bitrand(rng, 10)
10-element BitArray{1}:
 0
 1
 1
 1
 1
 0
 1
 0
 0
 1
\end{minted}



\end{adjustwidth}
\hypertarget{7347069443766288058}{} 
\hyperlink{7347069443766288058}{\texttt{Base.randn}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
randn([rng=GLOBAL_RNG], [T=Float64], [dims...])
\end{minted}

Generate a normally-distributed random number of type \texttt{T} with mean 0 and standard deviation 1. Optionally generate an array of normally-distributed random numbers. The \texttt{Base} module currently provides an implementation for the types \hyperlink{2727296760866702904}{\texttt{Float16}}, \hyperlink{8101639384272933082}{\texttt{Float32}}, and \hyperlink{5027751419500983000}{\texttt{Float64}} (the default), and their \hyperlink{11302502367029942782}{\texttt{Complex}} counterparts. When the type argument is complex, the values are drawn from the circularly symmetric complex normal distribution of variance 1 (corresponding to real and imaginary part having independent normal distribution with mean zero and variance \texttt{1/2}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> using Random

julia> rng = MersenneTwister(1234);

julia> randn(rng, ComplexF64)
0.6133070881429037 - 0.6376291670853887im

julia> randn(rng, ComplexF32, (2, 3))
2×3 Array{Complex{Float32},2}:
 -0.349649-0.638457im  0.376756-0.192146im  -0.396334-0.0136413im
  0.611224+1.56403im   0.355204-0.365563im  0.0905552+1.31012im
\end{minted}



\end{adjustwidth}
\hypertarget{15194943605954659727}{} 
\hyperlink{15194943605954659727}{\texttt{Random.randn!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
randn!([rng=GLOBAL_RNG], A::AbstractArray) -> A
\end{minted}

Fill the array \texttt{A} with normally-distributed (mean 0, standard deviation 1) random numbers. Also see the \hyperlink{7668863842145012694}{\texttt{rand}} function.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> randn!(rng, zeros(5))
5-element Array{Float64,1}:
  0.8673472019512456
 -0.9017438158568171
 -0.4944787535042339
 -0.9029142938652416
  0.8644013132535154
\end{minted}



\end{adjustwidth}
\hypertarget{17131026676213441996}{} 
\hyperlink{17131026676213441996}{\texttt{Random.randexp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
randexp([rng=GLOBAL_RNG], [T=Float64], [dims...])
\end{minted}

Generate a random number of type \texttt{T} according to the exponential distribution with scale 1. Optionally generate an array of such random numbers. The \texttt{Base} module currently provides an implementation for the types \hyperlink{2727296760866702904}{\texttt{Float16}}, \hyperlink{8101639384272933082}{\texttt{Float32}}, and \hyperlink{5027751419500983000}{\texttt{Float64}} (the default).

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> randexp(rng, Float32)
2.4835055f0

julia> randexp(rng, 3, 3)
3×3 Array{Float64,2}:
 1.5167    1.30652   0.344435
 0.604436  2.78029   0.418516
 0.695867  0.693292  0.643644
\end{minted}



\end{adjustwidth}
\hypertarget{3451932378818354751}{} 
\hyperlink{3451932378818354751}{\texttt{Random.randexp!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
randexp!([rng=GLOBAL_RNG], A::AbstractArray) -> A
\end{minted}

Fill the array \texttt{A} with random numbers following the exponential distribution (with scale 1).

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> randexp!(rng, zeros(5))
5-element Array{Float64,1}:
 2.4835053723904896
 1.516703605376473
 0.6044364871025417
 0.6958665886385867
 1.3065196315496677
\end{minted}



\end{adjustwidth}
\hypertarget{3465524779478434258}{} 
\hyperlink{3465524779478434258}{\texttt{Random.randstring}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
randstring([rng=GLOBAL_RNG], [chars], [len=8])
\end{minted}

Create a random string of length \texttt{len}, consisting of characters from \texttt{chars}, which defaults to the set of upper- and lower-case letters and the digits 0-9. The optional \texttt{rng} argument specifies a random number generator, see \href{@ref}{Random Numbers}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Random.seed!(0); randstring()
"0IPrGg0J"

julia> randstring(MersenneTwister(0), 'a':'z', 6)
"aszvqk"

julia> randstring("ACGT")
"TATCGGTC"
\end{minted}

\begin{quote}
\textbf{Note}

\texttt{chars} can be any collection of characters, of type \texttt{Char} or \texttt{UInt8} (more efficient), provided \hyperlink{7668863842145012694}{\texttt{rand}} can randomly pick characters from it.

\end{quote}


\end{adjustwidth}

\hypertarget{1694954649783113139}{}


\section{Subsequences, permutations and shuffling}


\hypertarget{10454370655022505544}{} 
\hyperlink{10454370655022505544}{\texttt{Random.randsubseq}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
randsubseq([rng=GLOBAL_RNG,] A, p) -> Vector
\end{minted}

Return a vector consisting of a random subsequence of the given array \texttt{A}, where each element of \texttt{A} is included (in order) with independent probability \texttt{p}. (Complexity is linear in \texttt{p*length(A)}, so this function is efficient even if \texttt{p} is small and \texttt{A} is large.) Technically, this process is known as {\textquotedbl}Bernoulli sampling{\textquotedbl} of \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> randsubseq(rng, collect(1:8), 0.3)
2-element Array{Int64,1}:
 7
 8
\end{minted}



\end{adjustwidth}
\hypertarget{16120735695998231549}{} 
\hyperlink{16120735695998231549}{\texttt{Random.randsubseq!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
randsubseq!([rng=GLOBAL_RNG,] S, A, p)
\end{minted}

Like \hyperlink{10454370655022505544}{\texttt{randsubseq}}, but the results are stored in \texttt{S} (which is resized as needed).

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> S = Int64[];

julia> randsubseq!(rng, S, collect(1:8), 0.3);

julia> S
2-element Array{Int64,1}:
 7
 8
\end{minted}



\end{adjustwidth}
\hypertarget{7342203624124611352}{} 
\hyperlink{7342203624124611352}{\texttt{Random.randperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
randperm([rng=GLOBAL_RNG,] n::Integer)
\end{minted}

Construct a random permutation of length \texttt{n}. The optional \texttt{rng} argument specifies a random number generator (see \href{@ref}{Random Numbers}). The element type of the result is the same as the type of \texttt{n}.

To randomly permute an arbitrary vector, see \hyperlink{16742615893822221762}{\texttt{shuffle}} or \hyperlink{15315300334019616632}{\texttt{shuffle!}}.

\begin{quote}
\textbf{Julia 1.1}

In Julia 1.1 \texttt{randperm} returns a vector \texttt{v} with \texttt{eltype(v) == typeof(n)} while in Julia 1.0 \texttt{eltype(v) == Int}.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> randperm(MersenneTwister(1234), 4)
4-element Array{Int64,1}:
 2
 1
 4
 3
\end{minted}



\end{adjustwidth}
\hypertarget{9956290992837499502}{} 
\hyperlink{9956290992837499502}{\texttt{Random.randperm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
randperm!([rng=GLOBAL_RNG,] A::Array{<:Integer})
\end{minted}

Construct in \texttt{A} a random permutation of length \texttt{length(A)}. The optional \texttt{rng} argument specifies a random number generator (see \href{@ref}{Random Numbers}). To randomly permute an arbitrary vector, see \hyperlink{16742615893822221762}{\texttt{shuffle}} or \hyperlink{15315300334019616632}{\texttt{shuffle!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> randperm!(MersenneTwister(1234), Vector{Int}(undef, 4))
4-element Array{Int64,1}:
 2
 1
 4
 3
\end{minted}



\end{adjustwidth}
\hypertarget{8716855906711617057}{} 
\hyperlink{8716855906711617057}{\texttt{Random.randcycle}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
randcycle([rng=GLOBAL_RNG,] n::Integer)
\end{minted}

Construct a random cyclic permutation of length \texttt{n}. The optional \texttt{rng} argument specifies a random number generator, see \href{@ref}{Random Numbers}. The element type of the result is the same as the type of \texttt{n}.

\begin{quote}
\textbf{Julia 1.1}

In Julia 1.1 \texttt{randcycle} returns a vector \texttt{v} with \texttt{eltype(v) == typeof(n)} while in Julia 1.0 \texttt{eltype(v) == Int}.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> randcycle(MersenneTwister(1234), 6)
6-element Array{Int64,1}:
 3
 5
 4
 6
 1
 2
\end{minted}



\end{adjustwidth}
\hypertarget{6946208329788361422}{} 
\hyperlink{6946208329788361422}{\texttt{Random.randcycle!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
randcycle!([rng=GLOBAL_RNG,] A::Array{<:Integer})
\end{minted}

Construct in \texttt{A} a random cyclic permutation of length \texttt{length(A)}. The optional \texttt{rng} argument specifies a random number generator, see \href{@ref}{Random Numbers}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> randcycle!(MersenneTwister(1234), Vector{Int}(undef, 6))
6-element Array{Int64,1}:
 3
 5
 4
 6
 1
 2
\end{minted}



\end{adjustwidth}
\hypertarget{16742615893822221762}{} 
\hyperlink{16742615893822221762}{\texttt{Random.shuffle}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
shuffle([rng=GLOBAL_RNG,] v::AbstractArray)
\end{minted}

Return a randomly permuted copy of \texttt{v}. The optional \texttt{rng} argument specifies a random number generator (see \href{@ref}{Random Numbers}). To permute \texttt{v} in-place, see \hyperlink{15315300334019616632}{\texttt{shuffle!}}. To obtain randomly permuted indices, see \hyperlink{7342203624124611352}{\texttt{randperm}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> shuffle(rng, Vector(1:10))
10-element Array{Int64,1}:
  6
  1
 10
  2
  3
  9
  5
  7
  4
  8
\end{minted}



\end{adjustwidth}
\hypertarget{15315300334019616632}{} 
\hyperlink{15315300334019616632}{\texttt{Random.shuffle!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
shuffle!([rng=GLOBAL_RNG,] v::AbstractArray)
\end{minted}

In-place version of \hyperlink{16742615893822221762}{\texttt{shuffle}}: randomly permute \texttt{v} in-place, optionally supplying the random-number generator \texttt{rng}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> shuffle!(rng, Vector(1:16))
16-element Array{Int64,1}:
  2
 15
  5
 14
  1
  9
 10
  6
 11
  3
 16
  7
  4
 12
  8
 13
\end{minted}



\end{adjustwidth}

\hypertarget{16600936393177391619}{}


\section{Generators (creation and seeding)}


\hypertarget{9373195541397142847}{} 
\hyperlink{9373195541397142847}{\texttt{Random.seed!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
seed!([rng=GLOBAL_RNG], seed) -> rng
seed!([rng=GLOBAL_RNG]) -> rng
\end{minted}

Reseed the random number generator: \texttt{rng} will give a reproducible sequence of numbers if and only if a \texttt{seed} is provided. Some RNGs don{\textquotesingle}t accept a seed, like \texttt{RandomDevice}. After the call to \texttt{seed!}, \texttt{rng} is equivalent to a newly created object initialized with the same seed.

If \texttt{rng} is not specified, it defaults to seeding the state of the shared thread-local generator.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Random.seed!(1234);

julia> x1 = rand(2)
2-element Array{Float64,1}:
 0.590845
 0.766797

julia> Random.seed!(1234);

julia> x2 = rand(2)
2-element Array{Float64,1}:
 0.590845
 0.766797

julia> x1 == x2
true

julia> rng = MersenneTwister(1234); rand(rng, 2) == x1
true

julia> MersenneTwister(1) == Random.seed!(rng, 1)
true

julia> rand(Random.seed!(rng), Bool) # not reproducible
true

julia> rand(Random.seed!(rng), Bool)
false

julia> rand(MersenneTwister(), Bool) # not reproducible either
true
\end{minted}



\end{adjustwidth}
\hypertarget{17421972100838426566}{} 
\hyperlink{17421972100838426566}{\texttt{Random.AbstractRNG}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractRNG
\end{minted}

Supertype for random number generators such as \hyperlink{4960058165975837552}{\texttt{MersenneTwister}} and \hyperlink{14367539717133476780}{\texttt{RandomDevice}}.



\end{adjustwidth}
\hypertarget{4960058165975837552}{} 
\hyperlink{4960058165975837552}{\texttt{Random.MersenneTwister}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
MersenneTwister(seed)
MersenneTwister()
\end{minted}

Create a \texttt{MersenneTwister} RNG object. Different RNG objects can have their own seeds, which may be useful for generating different streams of random numbers. The \texttt{seed} may be a non-negative integer or a vector of \texttt{UInt32} integers. If no seed is provided, a randomly generated one is created (using entropy from the system). See the \hyperlink{9373195541397142847}{\texttt{seed!}} function for reseeding an already existing \texttt{MersenneTwister} object.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> x1 = rand(rng, 2)
2-element Array{Float64,1}:
 0.5908446386657102
 0.7667970365022592

julia> rng = MersenneTwister(1234);

julia> x2 = rand(rng, 2)
2-element Array{Float64,1}:
 0.5908446386657102
 0.7667970365022592

julia> x1 == x2
true
\end{minted}



\end{adjustwidth}
\hypertarget{14367539717133476780}{} 
\hyperlink{14367539717133476780}{\texttt{Random.RandomDevice}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RandomDevice()
\end{minted}

Create a \texttt{RandomDevice} RNG object. Two such objects will always generate different streams of random numbers. The entropy is obtained from the operating system.



\end{adjustwidth}

\hypertarget{17771818288641906623}{}


\section{Hooking into the \texttt{Random} API}



There are two mostly orthogonal ways to extend \texttt{Random} functionalities:



\begin{itemize}
\item[1. ] generating random values of custom types


\item[2. ] creating new generators

\end{itemize}


The API for 1) is quite functional, but is relatively recent so it may still have to evolve in subsequent releases of the \texttt{Random} module. For example, it{\textquotesingle}s typically sufficient to implement one \texttt{rand} method in order to have all other usual methods work automatically.



The API for 2) is still rudimentary, and may require more work than strictly necessary from the implementor, in order to support usual types of generated values.



\hypertarget{7184618023384207012}{}


\subsection{Generating random values of custom types}



Generating random values for some distributions may involve various trade-offs. \emph{Pre-computed} values, such as an \href{https://en.wikipedia.org/wiki/Alias\_method}{alias table} for discrete distributions, or \href{https://en.wikipedia.org/wiki/Rejection\_sampling}{“squeezing” functions} for univariate distributions, can speed up sampling considerably. How much information should be pre-computed can depend on the number of values we plan to draw from a distribution. Also, some random number generators can have certain properties that various algorithms may want to exploit.



The \texttt{Random} module defines a customizable framework for obtaining random values that can address these issues. Each invocation of \texttt{rand} generates a \emph{sampler} which can be customized with the above trade-offs in mind, by adding methods to \texttt{Sampler}, which in turn can dispatch on the random number generator, the object that characterizes the distribution, and a suggestion for the number of repetitions. Currently, for the latter, \texttt{Val\{1\}} (for a single sample) and \texttt{Val\{Inf\}} (for an arbitrary number) are used, with \texttt{Random.Repetition} an alias for both.



The object returned by \texttt{Sampler} is then used to generate the random values. When implementing the random generation interface for a value \texttt{X} that can be sampled from, the implementor should define the method




\begin{minted}{julia}
rand(rng, sampler)
\end{minted}



for the particular \texttt{sampler} returned by \texttt{Sampler(rng, X, repetition)}.



Samplers can be arbitrary values that implement \texttt{rand(rng, sampler)}, but for most applications the following predefined samplers may be sufficient:



\begin{itemize}
\item[1. ] \texttt{SamplerType\{T\}()} can be used for implementing samplers that draw from type \texttt{T} (e.g. \texttt{rand(Int)}). This is the default returned by \texttt{Sampler} for \emph{types}.


\item[2. ] \texttt{SamplerTrivial(self)} is a simple wrapper for \texttt{self}, which can be accessed with \texttt{[]}. This is the recommended sampler when no pre-computed information is needed (e.g. \texttt{rand(1:3)}), and is the default returned by \texttt{Sampler} for \emph{values}.


\item[3. ] \texttt{SamplerSimple(self, data)} also contains the additional \texttt{data} field, which can be used to store arbitrary pre-computed values, which should be computed in a \emph{custom method} of \texttt{Sampler}.

\end{itemize}


We provide examples for each of these. We assume here that the choice of algorithm is independent of the RNG, so we use \texttt{AbstractRNG} in our signatures.


\hypertarget{6931553397315604036}{} 
\hyperlink{6931553397315604036}{\texttt{Random.Sampler}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sampler(rng, x, repetition = Val(Inf))
\end{minted}

Return a sampler object that can be used to generate random values from \texttt{rng} for \texttt{x}.

When \texttt{sp = Sampler(rng, x, repetition)}, \texttt{rand(rng, sp)} will be used to draw random values, and should be defined accordingly.

\texttt{repetition} can be \texttt{Val(1)} or \texttt{Val(Inf)}, and should be used as a suggestion for deciding the amount of precomputation, if applicable.

\hyperlink{2169729397706095790}{\texttt{Random.SamplerType}} and \hyperlink{2575204551890994411}{\texttt{Random.SamplerTrivial}} are default fallbacks for \emph{types} and \emph{values}, respectively. \hyperlink{17949645161476858061}{\texttt{Random.SamplerSimple}} can be used to store pre-computed values without defining extra types for only this purpose.



\end{adjustwidth}
\hypertarget{2169729397706095790}{} 
\hyperlink{2169729397706095790}{\texttt{Random.SamplerType}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SamplerType{T}()
\end{minted}

A sampler for types, containing no other information. The default fallback for \texttt{Sampler} when called with types.



\end{adjustwidth}
\hypertarget{2575204551890994411}{} 
\hyperlink{2575204551890994411}{\texttt{Random.SamplerTrivial}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SamplerTrivial(x)
\end{minted}

Create a sampler that just wraps the given value \texttt{x}. This is the default fall-back for values. The \texttt{eltype} of this sampler is equal to \texttt{eltype(x)}.

The recommended use case is sampling from values without precomputed data.



\end{adjustwidth}
\hypertarget{17949645161476858061}{} 
\hyperlink{17949645161476858061}{\texttt{Random.SamplerSimple}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SamplerSimple(x, data)
\end{minted}

Create a sampler that wraps the given value \texttt{x} and the \texttt{data}. The \texttt{eltype} of this sampler is equal to \texttt{eltype(x)}.

The recommended use case is sampling from values with precomputed data.



\end{adjustwidth}

Decoupling pre-computation from actually generating the values is part of the API, and is also available to the user. As an example, assume that \texttt{rand(rng, 1:20)} has to be called repeatedly in a loop: the way to take advantage of this decoupling is as follows:




\begin{minted}{julia}
rng = MersenneTwister()
sp = Random.Sampler(rng, 1:20) # or Random.Sampler(MersenneTwister, 1:20)
for x in X
    n = rand(rng, sp) # similar to n = rand(rng, 1:20)
    # use n
end
\end{minted}



This is the mechanism that is also used in the standard library, e.g. by the default implementation of random array generation (like in \texttt{rand(1:20, 10)}).



\hypertarget{15852577436081724496}{}


\subsubsection{Generating values from a type}



Given a type \texttt{T}, it{\textquotesingle}s currently assumed that if \texttt{rand(T)} is defined, an object of type \texttt{T} will be produced. \texttt{SamplerType} is the \emph{default sampler for types}. In order to define random generation of values of type \texttt{T}, the \texttt{rand(rng::AbstractRNG, ::Random.SamplerType\{T\})} method should be defined, and should return values what \texttt{rand(rng, T)} is expected to return.



Let{\textquotesingle}s take the following example: we implement a \texttt{Die} type, with a variable number \texttt{n} of sides, numbered from \texttt{1} to \texttt{n}. We want \texttt{rand(Die)} to produce a \texttt{Die} with a random number of up to 20 sides (and at least 4):




\begin{minted}{julia}
struct Die
    nsides::Int # number of sides
end

Random.rand(rng::AbstractRNG, ::Random.SamplerType{Die}) = Die(rand(rng, 4:20))

# output

\end{minted}



Scalar and array methods for \texttt{Die} now work as expected:




\begin{minted}{jlcon}
julia> rand(Die)
Die(10)

julia> rand(MersenneTwister(0), Die)
Die(16)

julia> rand(Die, 3)
3-element Array{Die,1}:
 Die(5)
 Die(20)
 Die(9)

julia> a = Vector{Die}(undef, 3); rand!(a)
3-element Array{Die,1}:
 Die(11)
 Die(20)
 Die(10)
\end{minted}



\hypertarget{14351717451744151937}{}


\subsubsection{A simple sampler without pre-computed data}



Here we define a sampler for a collection. If no pre-computed data is required, it can be implemented with a \texttt{SamplerTrivial} sampler, which is in fact the \emph{default fallback for values}.



In order to define random generation out of objects of type \texttt{S}, the following method should be defined: \texttt{rand(rng::AbstractRNG, sp::Random.SamplerTrivial\{S\})}. Here, \texttt{sp} simply wraps an object of type \texttt{S}, which can be accessed via \texttt{sp[]}. Continuing the \texttt{Die} example, we want now to define \texttt{rand(d::Die)} to produce an \texttt{Int} corresponding to one of \texttt{d}{\textquotesingle}s sides:




\begin{minted}{jlcon}
julia> Random.rand(rng::AbstractRNG, d::Random.SamplerTrivial{Die}) = rand(rng, 1:d[].nsides);

julia> rand(Die(4))
2

julia> rand(Die(4), 3)
3-element Array{Any,1}:
 1
 4
 2
\end{minted}



Given a collection type \texttt{S}, it{\textquotesingle}s currently assumed that if \texttt{rand(::S)} is defined, an object of type \texttt{eltype(S)} will be produced. In the last example, a \texttt{Vector\{Any\}} is produced; the reason is that \texttt{eltype(Die) == Any}. The remedy is to define \texttt{Base.eltype(::Type\{Die\}) = Int}.



\hypertarget{1884287946239364410}{}


\subsubsection{Generating values for an \texttt{AbstractFloat} type}



\texttt{AbstractFloat} types are special-cased, because by default random values are not produced in the whole type domain, but rather in \texttt{[0,1)}. The following method should be implemented for \texttt{T <: AbstractFloat}: \texttt{Random.rand(::AbstractRNG, ::Random.SamplerTrivial\{Random.CloseOpen01\{T\}\})}



\hypertarget{11354689514356683227}{}


\subsubsection{An optimized sampler with pre-computed data}



Consider a discrete distribution, where numbers \texttt{1:n} are drawn with given probabilities that sum to one. When many values are needed from this distribution, the fastest method is using an \href{https://en.wikipedia.org/wiki/Alias\_method}{alias table}. We don{\textquotesingle}t provide the algorithm for building such a table here, but suppose it is available in \texttt{make\_alias\_table(probabilities)} instead, and \texttt{draw\_number(rng, alias\_table)} can be used to draw a random number from it.



Suppose that the distribution is described by




\begin{minted}{julia}
struct DiscreteDistribution{V <: AbstractVector}
    probabilities::V
end
\end{minted}



and that we \emph{always} want to build an alias table, regardless of the number of values needed (we learn how to customize this below). The methods




\begin{minted}{julia}
Random.eltype(::Type{<:DiscreteDistribution}) = Int

function Random.Sampler(::Type{<:AbstractRNG}, distribution::DiscreteDistribution, ::Repetition)
    SamplerSimple(disribution, make_alias_table(distribution.probabilities))
end
\end{minted}



should be defined to return a sampler with pre-computed data, then




\begin{minted}{julia}
function rand(rng::AbstractRNG, sp::SamplerSimple{<:DiscreteDistribution})
    draw_number(rng, sp.data)
end
\end{minted}



will be used to draw the values.



\hypertarget{4100919623062869062}{}


\subsubsection{Custom sampler types}



The \texttt{SamplerSimple} type is sufficient for most use cases with precomputed data. However, in order to demonstrate how to use custom sampler types, here we implement something similar to \texttt{SamplerSimple}.



Going back to our \texttt{Die} example: \texttt{rand(::Die)} uses random generation from a range, so there is an opportunity for this optimization. We call our custom sampler \texttt{SamplerDie}.




\begin{minted}{julia}
import Random: Sampler, rand

struct SamplerDie <: Sampler{Int} # generates values of type Int
    die::Die
    sp::Sampler{Int} # this is an abstract type, so this could be improved
end

Sampler(RNG::Type{<:AbstractRNG}, die::Die, r::Random.Repetition) =
    SamplerDie(die, Sampler(RNG, 1:die.nsides, r))
# the `r` parameter will be explained later on

rand(rng::AbstractRNG, sp::SamplerDie) = rand(rng, sp.sp)
\end{minted}



It{\textquotesingle}s now possible to get a sampler with \texttt{sp = Sampler(rng, die)}, and use \texttt{sp} instead of \texttt{die} in any \texttt{rand} call involving \texttt{rng}. In the simplistic example above, \texttt{die} doesn{\textquotesingle}t need to be stored in \texttt{SamplerDie} but this is often the case in practice.



Of course, this pattern is so frequent that the helper type used above, namely \texttt{Random.SamplerSimple}, is available, saving us the definition of \texttt{SamplerDie}: we could have implemented our decoupling with:




\begin{minted}{julia}
Sampler(RNG::Type{<:AbstractRNG}, die::Die, r::Random.Repetition) =
    SamplerSimple(die, Sampler(RNG, 1:die.nsides, r))

rand(rng::AbstractRNG, sp::SamplerSimple{Die}) = rand(rng, sp.data)
\end{minted}



Here, \texttt{sp.data} refers to the second parameter in the call to the \texttt{SamplerSimple} constructor (in this case equal to \texttt{Sampler(rng, 1:die.nsides, r)}), while the \texttt{Die} object can be accessed via \texttt{sp[]}.



Like \texttt{SamplerDie}, any custom sampler must be a subtype of \texttt{Sampler\{T\}} where \texttt{T} is the type of the generated values. Note that \texttt{SamplerSimple(x, data) isa Sampler\{eltype(x)\}}, so this constrains what the first argument to \texttt{SamplerSimple} can be (it{\textquotesingle}s recommended to use \texttt{SamplerSimple} like in the \texttt{Die} example, where \texttt{x} is simply forwarded while defining a \texttt{Sampler} method). Similarly, \texttt{SamplerTrivial(x) isa Sampler\{eltype(x)\}}.



Another helper type is currently available for other cases, \texttt{Random.SamplerTag}, but is considered as internal API, and can break at any time without proper deprecations.



\hypertarget{6227859827856272297}{}


\subsubsection{Using distinct algorithms for scalar or array generation}



In some cases, whether one wants to generate only a handful of values or a large number of values will have an impact on the choice of algorithm. This is handled with the third parameter of the \texttt{Sampler} constructor. Let{\textquotesingle}s assume we defined two helper types for \texttt{Die}, say \texttt{SamplerDie1} which should be used to generate only few random values, and \texttt{SamplerDieMany} for many values. We can use those types as follows:




\begin{minted}{julia}
Sampler(RNG::Type{<:AbstractRNG}, die::Die, ::Val{1}) = SamplerDie1(...)
Sampler(RNG::Type{<:AbstractRNG}, die::Die, ::Val{Inf}) = SamplerDieMany(...)
\end{minted}



Of course, \texttt{rand} must also be defined on those types (i.e. \texttt{rand(::AbstractRNG, ::SamplerDie1)} and \texttt{rand(::AbstractRNG, ::SamplerDieMany)}). Note that, as usual, \texttt{SamplerTrivial} and \texttt{SamplerSimple} can be used if custom types are not necessary.



Note: \texttt{Sampler(rng, x)} is simply a shorthand for \texttt{Sampler(rng, x, Val(Inf))}, and \texttt{Random.Repetition} is an alias for \texttt{Union\{Val\{1\}, Val\{Inf\}\}}.



\hypertarget{17633591859123150}{}


\subsection{Creating new generators}



The API is not clearly defined yet, but as a rule of thumb:



\begin{itemize}
\item[1. ] any \texttt{rand} method producing {\textquotedbl}basic{\textquotedbl} types (\texttt{isbitstype} integer and floating types in \texttt{Base}) should be defined for this specific RNG, if they are needed;


\item[2. ] other documented \texttt{rand} methods accepting an \texttt{AbstractRNG} should work out of the box, (provided the methods from 1) what are relied on are implemented), but can of course be specialized for this RNG if there is room for optimization;


\item[3. ] \texttt{copy} for pseudo-RNGs should return an independent copy that generates the exact same random sequence as the original from that point when called in the same way. When this is not feasible (e.g. hardware-based RNGs), \texttt{copy} must not be implemented.

\end{itemize}


Concerning 1), a \texttt{rand} method may happen to work automatically, but it{\textquotesingle}s not officially supported and may break without warnings in a subsequent release.



To define a new \texttt{rand} method for an hypothetical \texttt{MyRNG} generator, and a value specification \texttt{s} (e.g. \texttt{s == Int}, or \texttt{s == 1:10}) of type \texttt{S==typeof(s)} or \texttt{S==Type\{s\}} if \texttt{s} is a type, the same two methods as we saw before must be defined:



\begin{itemize}
\item[1. ] \texttt{Sampler(::Type\{MyRNG\}, ::S, ::Repetition)}, which returns an object of type say \texttt{SamplerS}


\item[2. ] \texttt{rand(rng::MyRNG, sp::SamplerS)}

\end{itemize}


It can happen that \texttt{Sampler(rng::AbstractRNG, ::S, ::Repetition)} is already defined in the \texttt{Random} module. It would then be possible to skip step 1) in practice (if one wants to specialize generation for this particular RNG type), but the corresponding \texttt{SamplerS} type is considered as internal detail, and may be changed without warning.



\hypertarget{9194362945868125985}{}


\subsubsection{Specializing array generation}



In some cases, for a given RNG type, generating an array of random values can be more efficient with a specialized method than by merely using the decoupling technique explained before. This is for example the case for \texttt{MersenneTwister}, which natively writes random values in an array.



To implement this specialization for \texttt{MyRNG} and for a specification \texttt{s}, producing elements of type \texttt{S}, the following method can be defined: \texttt{rand!(rng::MyRNG, a::AbstractArray\{S\}, ::SamplerS)}, where \texttt{SamplerS} is the type of the sampler returned by \texttt{Sampler(MyRNG, s, Val(Inf))}. Instead of \texttt{AbstractArray}, it{\textquotesingle}s possible to implement the functionality only for a subtype, e.g. \texttt{Array\{S\}}. The non-mutating array method of \texttt{rand} will automatically call this specialization internally.





\hypertarget{3655118098996655995}{}


\chapter{Reproducibility}



By using an RNG parameter initialized with a given seed, you can reproduce the same pseudorandom number sequence when running your program multiple times.  However, a minor release of Julia (e.g. 1.3 to 1.4) \emph{may change} the sequence of pseudorandom numbers generated from a specific seed.  (Even if the sequence produced by a low-level function like \hyperlink{7668863842145012694}{\texttt{rand}} does not change, the output of higher-level functions like \hyperlink{10454370655022505544}{\texttt{randsubseq}} may change due to algorithm updates.)   Rationale: guaranteeing that pseudorandom streams never change prohibits many algorithmic improvements.



If you need to guarantee exact reproducibility of random data, it is advisable to simply \emph{save the data} (e.g. as a supplementary attachment in a scientific publication).  (You can also, of course, specify a particular Julia version and package manifest, especially if you require bit reproducibility.)



Software tests that rely on \emph{specific} {\textquotedbl}random{\textquotedbl} data should also generally save the data or embed it into the test code.  On the other hand, tests that should pass for \emph{most} random data (e.g. testing \texttt{A {\textbackslash} (A*x) ≈ x} for a random matrix \texttt{A = randn(n,n)}) can use an RNG with a fixed seed to ensure that simply running the test many times does not encounter a failure due to very improbable data (e.g. an extremely ill-conditioned matrix).



The statistical \emph{distribution} from which random samples are drawn \emph{is} guaranteed to be the same across any minor Julia releases.



\hypertarget{15457917914318839048}{}


\chapter{SHA}



用法非常直接：




\begin{minted}{julia}
julia> using SHA

julia> bytes2hex(sha256("test"))
"9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08"
\end{minted}



每个导出函数（SHA-1, SHA-2 224, 256, 384, 512, 以及 SHA-3 224, 256, 384, 512 函数在本文撰写时都已实现）都可以接受 \texttt{Array\{UInt8\}}, \texttt{ByteString} 或 \texttt{IO} 对象。这使计算文件校验和变得轻而易举：




\begin{minted}{julia}
shell> cat /tmp/test.txt
test
julia> using SHA

julia> open("/tmp/test.txt") do f
           sha2_256(f)
       end
32-element Array{UInt8,1}:
 0x9f
 0x86
 0xd0
 0x81
 0x88
 0x4c
 0x7d
 0x65
    ⋮
 0x5d
 0x6c
 0x15
 0xb0
 0xf0
 0x0a
 0x08
\end{minted}



注意 \texttt{/tmp/text.txt} 文件结尾缺少换行符。Julia 会自动在 \texttt{julia>} 提示符前插入换行符。



由于 \texttt{sha256} 通常指的是 \texttt{sha2\_256}，因此提供了函数名简写，将 \texttt{shaxxx()} 函数调用映射到 \texttt{sha2\_xxx()}。SHA-3 不存在这样的俗称，用户必须使用完整的函数名 \texttt{sha3\_xxx()}。



\texttt{shaxxx()} 接受 \texttt{UInt8} 类型的 \texttt{AbstractString} 和类数组对象（\texttt{NTuple} 和 \texttt{Array}）。



请注意，在本文撰写时，SHA-3 代码还未进行优化，因此会比 SHA-2 慢大约一个数量级。



\hypertarget{13724487893001117879}{}


\chapter{序列化}


\hypertarget{17931089632175850899}{} 
\hyperlink{17931089632175850899}{\texttt{Serialization.serialize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
serialize(stream::IO, value)
\end{minted}

Write an arbitrary value to a stream in an opaque format, such that it can be read back by \hyperlink{5889257128684048834}{\texttt{deserialize}}. The read-back value will be as identical as possible to the original. In general, this process will not work if the reading and writing are done by different versions of Julia, or an instance of Julia with a different system image. \texttt{Ptr} values are serialized as all-zero bit patterns (\texttt{NULL}).

An 8-byte identifying header is written to the stream first. To avoid writing the header, construct a \texttt{Serializer} and use it as the first argument to \texttt{serialize} instead. See also \hyperlink{165660671771374050}{\texttt{Serialization.writeheader}}.




\begin{lstlisting}
serialize(filename::AbstractString, value)
\end{lstlisting}

Open a file and serialize the given value to it.

\begin{quote}
\textbf{Julia 1.1}

This method is available as of Julia 1.1.

\end{quote}


\end{adjustwidth}
\hypertarget{5889257128684048834}{} 
\hyperlink{5889257128684048834}{\texttt{Serialization.deserialize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
deserialize(stream)
\end{minted}

Read a value written by \hyperlink{17931089632175850899}{\texttt{serialize}}. \texttt{deserialize} assumes the binary data read from \texttt{stream} is correct and has been serialized by a compatible implementation of \hyperlink{17931089632175850899}{\texttt{serialize}}. It has been designed with simplicity and performance as a goal and does not validate the data read. Malformed data can result in process termination. The caller has to ensure the integrity and correctness of data read from \texttt{stream}.




\begin{lstlisting}
deserialize(filename::AbstractString)
\end{lstlisting}

Open a file and deserialize its contents.

\begin{quote}
\textbf{Julia 1.1}

This method is available as of Julia 1.1.

\end{quote}


\end{adjustwidth}
\hypertarget{165660671771374050}{} 
\hyperlink{165660671771374050}{\texttt{Serialization.writeheader}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Serialization.writeheader(s::AbstractSerializer)
\end{minted}

Write an identifying header to the specified serializer. The header consists of 8 bytes as follows:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Offset & Description \\
\hline
0 & tag byte (0x37) \\
\hline
1-2 & signature bytes {\textquotedbl}JL{\textquotedbl} \\
\hline
3 & protocol version \\
\hline
4 & bits 0-1: endianness: 0 = little, 1 = big \\
\hline
4 & bits 2-3: platform: 0 = 32-bit, 1 = 64-bit \\
\hline
5-7 & reserved \\
\hline
\end{tabulary}

\end{table}



\end{adjustwidth}

\hypertarget{3058127117657456394}{}


\chapter{共享数组}


\hypertarget{15069300442338861576}{} 
\hyperlink{15069300442338861576}{\texttt{SharedArrays.SharedArray}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SharedArray{T}(dims::NTuple; init=false, pids=Int[])
SharedArray{T,N}(...)
\end{minted}

Construct a \texttt{SharedArray} of a bits type \texttt{T} and size \texttt{dims} across the processes specified by \texttt{pids} - all of which have to be on the same host.  If \texttt{N} is specified by calling \texttt{SharedArray\{T,N\}(dims)}, then \texttt{N} must match the length of \texttt{dims}.

If \texttt{pids} is left unspecified, the shared array will be mapped across all processes on the current host, including the master. But, \texttt{localindices} and \texttt{indexpids} will only refer to worker processes. This facilitates work distribution code to use workers for actual computation with the master process acting as a driver.

If an \texttt{init} function of the type \texttt{initfn(S::SharedArray)} is specified, it is called on all the participating workers.

The shared array is valid as long as a reference to the \texttt{SharedArray} object exists on the node which created the mapping.


\begin{lstlisting}
SharedArray{T}(filename::AbstractString, dims::NTuple, [offset=0]; mode=nothing, init=false, pids=Int[])
SharedArray{T,N}(...)
\end{lstlisting}

Construct a \texttt{SharedArray} backed by the file \texttt{filename}, with element type \texttt{T} (must be a bits type) and size \texttt{dims}, across the processes specified by \texttt{pids} - all of which have to be on the same host. This file is mmapped into the host memory, with the following consequences:

\begin{itemize}
\item The array data must be represented in binary format (e.g., an ASCII format like CSV cannot be supported)


\item Any changes you make to the array values (e.g., \texttt{A[3] = 0}) will also change the values on disk

\end{itemize}
If \texttt{pids} is left unspecified, the shared array will be mapped across all processes on the current host, including the master. But, \texttt{localindices} and \texttt{indexpids} will only refer to worker processes. This facilitates work distribution code to use workers for actual computation with the master process acting as a driver.

\texttt{mode} must be one of \texttt{{\textquotedbl}r{\textquotedbl}}, \texttt{{\textquotedbl}r+{\textquotedbl}}, \texttt{{\textquotedbl}w+{\textquotedbl}}, or \texttt{{\textquotedbl}a+{\textquotedbl}}, and defaults to \texttt{{\textquotedbl}r+{\textquotedbl}} if the file specified by \texttt{filename} already exists, or \texttt{{\textquotedbl}w+{\textquotedbl}} if not. If an \texttt{init} function of the type \texttt{initfn(S::SharedArray)} is specified, it is called on all the participating workers. You cannot specify an \texttt{init} function if the file is not writable.

\texttt{offset} allows you to skip the specified number of bytes at the beginning of the file.



\end{adjustwidth}
\hypertarget{7409079308721392752}{} 
\hyperlink{7409079308721392752}{\texttt{SharedArrays.SharedVector}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SharedVector
\end{minted}

A one-dimensional \hyperlink{15069300442338861576}{\texttt{SharedArray}}.



\end{adjustwidth}
\hypertarget{4014464484316382916}{} 
\hyperlink{4014464484316382916}{\texttt{SharedArrays.SharedMatrix}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SharedMatrix
\end{minted}

A two-dimensional \hyperlink{15069300442338861576}{\texttt{SharedArray}}.



\end{adjustwidth}
\hypertarget{379512234313781053}{} 
\hyperlink{379512234313781053}{\texttt{Distributed.procs}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
procs(S::SharedArray)
\end{minted}

Get the vector of processes mapping the shared array.



\end{adjustwidth}
\hypertarget{5828642841105091437}{} 
\hyperlink{5828642841105091437}{\texttt{SharedArrays.sdata}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sdata(S::SharedArray)
\end{minted}

Returns the actual \texttt{Array} object backing \texttt{S}.



\end{adjustwidth}
\hypertarget{6331641514330199981}{} 
\hyperlink{6331641514330199981}{\texttt{SharedArrays.indexpids}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
indexpids(S::SharedArray)
\end{minted}

Returns the current worker{\textquotesingle}s index in the list of workers mapping the \texttt{SharedArray} (i.e. in the same list returned by \texttt{procs(S)}), or 0 if the \texttt{SharedArray} is not mapped locally.



\end{adjustwidth}
\hypertarget{12447667054613272081}{} 
\hyperlink{12447667054613272081}{\texttt{SharedArrays.localindices}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
localindices(S::SharedArray)
\end{minted}

Returns a range describing the {\textquotedbl}default{\textquotedbl} indices to be handled by the current process.  This range should be interpreted in the sense of linear indexing, i.e., as a sub-range of \texttt{1:length(S)}.  In multi-process contexts, returns an empty range in the parent process (or any process for which \hyperlink{6331641514330199981}{\texttt{indexpids}} returns 0).

It{\textquotesingle}s worth emphasizing that \texttt{localindices} exists purely as a convenience, and you can partition work on the array among workers any way you wish. For a \texttt{SharedArray}, all indices should be equally fast for each worker process.



\end{adjustwidth}

\hypertarget{16962550433784269272}{}


\chapter{套接字}


\hypertarget{16889258743067172297}{} 
\hyperlink{16889258743067172297}{\texttt{Sockets.Sockets}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}

Support for sockets. Provides \hyperlink{8098410990676145612}{\texttt{IPAddr}} and subtypes, \hyperlink{5453047654537213204}{\texttt{TCPSocket}}, and \hyperlink{5627851531738059255}{\texttt{UDPSocket}}.



\end{adjustwidth}
\hypertarget{9905777280350118583}{} 
\hyperlink{9905777280350118583}{\texttt{Sockets.connect}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
connect([host], port::Integer) -> TCPSocket
\end{minted}

Connect to the host \texttt{host} on port \texttt{port}.



\end{adjustwidth}
\hypertarget{15285016070454152057}{} 
\hyperlink{15285016070454152057}{\texttt{Sockets.connect}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
connect(path::AbstractString) -> PipeEndpoint
\end{minted}

Connect to the named pipe / UNIX domain socket at \texttt{path}.



\end{adjustwidth}
\hypertarget{780704944207038170}{} 
\hyperlink{780704944207038170}{\texttt{Sockets.listen}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
listen([addr, ]port::Integer; backlog::Integer=BACKLOG_DEFAULT) -> TCPServer
\end{minted}

Listen on port on the address specified by \texttt{addr}. By default this listens on \texttt{localhost} only. To listen on all interfaces pass \texttt{IPv4(0)} or \texttt{IPv6(0)} as appropriate. \texttt{backlog} determines how many connections can be pending (not having called \hyperlink{1426793569216032849}{\texttt{accept}}) before the server will begin to reject them. The default value of \texttt{backlog} is 511.



\end{adjustwidth}
\hypertarget{10346115046291513570}{} 
\hyperlink{10346115046291513570}{\texttt{Sockets.listen}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
listen(path::AbstractString) -> PipeServer
\end{minted}

Create and listen on a named pipe / UNIX domain socket.



\end{adjustwidth}
\hypertarget{10301989504197190983}{} 
\hyperlink{10301989504197190983}{\texttt{Sockets.getaddrinfo}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getaddrinfo(host::AbstractString, IPAddr=IPv4) -> IPAddr
\end{minted}

Gets the first IP address of the \texttt{host} of the specified \texttt{IPAddr} type. Uses the operating system{\textquotesingle}s underlying getaddrinfo implementation, which may do a DNS lookup.



\end{adjustwidth}
\hypertarget{11265435361532665287}{} 
\hyperlink{11265435361532665287}{\texttt{Sockets.getipaddr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getipaddr() -> IPAddr
\end{minted}

Get an IP address of the local machine, preferring IPv4 over IPv6. Throws if no addresses are available.


\begin{lstlisting}
getipaddr(addr_type::Type{T}) where T<:IPAddr -> T
\end{lstlisting}

Get an IP address of the local machine of the specified type. Throws if no addresses of the specified type are available.

\textbf{Examples}


\begin{minted}{jlcon}
julia> getipaddr()
ip"192.168.1.28"

julia> getipaddr(IPv6)
ip"fe80::9731:35af:e1c5:6e49"
\end{minted}



\end{adjustwidth}
\hypertarget{11225054155479915290}{} 
\hyperlink{11225054155479915290}{\texttt{Sockets.getipaddrs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getipaddrs(; loopback::Bool=false) -> Vector{IPAddr}
\end{minted}

Get the IPv4 addresses of the local machine.


\begin{lstlisting}
getipaddrs(addr_type::Type{T}; loopback::Bool=false) where T<:IPAddr -> Vector{T}
\end{lstlisting}

Get the IP addresses of the local machine of the specified type.

The \texttt{loopback} keyword argument dictates whether loopback addresses are included.

\begin{quote}
\textbf{Julia 1.2}

This function is available as of Julia 1.2.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> getipaddrs()
2-element Array{IPv4,1}:
 ip"10.255.0.183"
 ip"172.17.0.1"

julia> getipaddrs(IPv6)
2-element Array{IPv6,1}:
 ip"fe80::9731:35af:e1c5:6e49"
 ip"fe80::445e:5fff:fe5d:5500"
\end{minted}



\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Sockets.islinklocaladdr}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{14820421424669368163}{} 
\hyperlink{14820421424669368163}{\texttt{Sockets.getalladdrinfo}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getalladdrinfo(host::AbstractString) -> Vector{IPAddr}
\end{minted}

Gets all of the IP addresses of the \texttt{host}. Uses the operating system{\textquotesingle}s underlying \texttt{getaddrinfo} implementation, which may do a DNS lookup.

\textbf{Example}


\begin{minted}{jlcon}
julia> getalladdrinfo("google.com")
2-element Array{IPAddr,1}:
 ip"172.217.6.174"
 ip"2607:f8b0:4000:804::200e"
\end{minted}



\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Sockets.DNSError}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{8933801763213702510}{} 
\hyperlink{8933801763213702510}{\texttt{Sockets.getnameinfo}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getnameinfo(host::IPAddr) -> String
\end{minted}

Performs a reverse-lookup for IP address to return a hostname and service using the operating system{\textquotesingle}s underlying \texttt{getnameinfo} implementation.

\textbf{Examples}


\begin{minted}{jlcon}
julia> getnameinfo(Sockets.IPv4("8.8.8.8"))
"google-public-dns-a.google.com"
\end{minted}



\end{adjustwidth}
\hypertarget{16393779334284193287}{} 
\hyperlink{16393779334284193287}{\texttt{Sockets.getsockname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getsockname(sock::Union{TCPServer, TCPSocket}) -> (IPAddr, UInt16)
\end{minted}

Get the IP address and port that the given socket is bound to.



\end{adjustwidth}
\hypertarget{3342627656847235889}{} 
\hyperlink{3342627656847235889}{\texttt{Sockets.getpeername}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getpeername(sock::TCPSocket) -> (IPAddr, UInt16)
\end{minted}

Get the IP address and port of the remote endpoint that the given socket is connected to. Valid only for connected TCP sockets.



\end{adjustwidth}
\hypertarget{8098410990676145612}{} 
\hyperlink{8098410990676145612}{\texttt{Sockets.IPAddr}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IPAddr
\end{minted}

Abstract supertype for IP addresses. \hyperlink{3367105148999996858}{\texttt{IPv4}} and \hyperlink{14863381148391509384}{\texttt{IPv6}} are subtypes of this.



\end{adjustwidth}
\hypertarget{3367105148999996858}{} 
\hyperlink{3367105148999996858}{\texttt{Sockets.IPv4}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IPv4(host::Integer) -> IPv4
\end{minted}

Returns an IPv4 object from ip address \texttt{host} formatted as an \hyperlink{8469131683393450448}{\texttt{Integer}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> IPv4(3223256218)
ip"192.30.252.154"
\end{minted}



\end{adjustwidth}
\hypertarget{14863381148391509384}{} 
\hyperlink{14863381148391509384}{\texttt{Sockets.IPv6}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IPv6(host::Integer) -> IPv6
\end{minted}

Returns an IPv6 object from ip address \texttt{host} formatted as an \hyperlink{8469131683393450448}{\texttt{Integer}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> IPv6(3223256218)
ip"::c01e:fc9a"
\end{minted}



\end{adjustwidth}
\hypertarget{5293313767861803133}{} 
\hyperlink{5293313767861803133}{\texttt{Sockets.@ip\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@ip_str str -> IPAddr
\end{minted}

Parse \texttt{str} as an IP address.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ip"127.0.0.1"
ip"127.0.0.1"

julia> @ip_str "2001:db8:0:0:0:0:2:1"
ip"2001:db8::2:1"
\end{minted}



\end{adjustwidth}
\hypertarget{5453047654537213204}{} 
\hyperlink{5453047654537213204}{\texttt{Sockets.TCPSocket}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
TCPSocket(; delay=true)
\end{minted}

Open a TCP socket using libuv. If \texttt{delay} is true, libuv delays creation of the socket{\textquotesingle}s file descriptor till the first \hyperlink{13811388816704022260}{\texttt{bind}} call. \texttt{TCPSocket} has various fields to denote the state of the socket as well as its send/receive buffers.



\end{adjustwidth}
\hypertarget{5627851531738059255}{} 
\hyperlink{5627851531738059255}{\texttt{Sockets.UDPSocket}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UDPSocket()
\end{minted}

Open a UDP socket using libuv. \texttt{UDPSocket} has various fields to denote the state of the socket.



\end{adjustwidth}
\hypertarget{1426793569216032849}{} 
\hyperlink{1426793569216032849}{\texttt{Sockets.accept}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
accept(server[, client])
\end{minted}

Accepts a connection on the given server and returns a connection to the client. An uninitialized client stream may be provided, in which case it will be used instead of creating a new stream.



\end{adjustwidth}
\hypertarget{9909318444396548981}{} 
\hyperlink{9909318444396548981}{\texttt{Sockets.listenany}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
listenany([host::IPAddr,] port_hint) -> (UInt16, TCPServer)
\end{minted}

Create a \texttt{TCPServer} on any port, using hint as a starting point. Returns a tuple of the actual port that the server was created on and the server itself.



\end{adjustwidth}
\hypertarget{13811388816704022260}{} 
\hyperlink{13811388816704022260}{\texttt{Base.bind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
bind(socket::Union{UDPSocket, TCPSocket}, host::IPAddr, port::Integer; ipv6only=false, reuseaddr=false, kws...)
\end{minted}

Bind \texttt{socket} to the given \texttt{host:port}. Note that \texttt{0.0.0.0} will listen on all devices.

\begin{itemize}
\item The \texttt{ipv6only} parameter disables dual stack mode. If \texttt{ipv6only=true}, only an IPv6 stack is created.


\item If \texttt{reuseaddr=true}, multiple threads or processes can bind to the same address without error if they all set \texttt{reuseaddr=true}, but only the last to bind will receive any traffic.

\end{itemize}



\begin{minted}{julia}
bind(chnl::Channel, task::Task)
\end{minted}

Associate the lifetime of \texttt{chnl} with a task. \texttt{Channel} \texttt{chnl} is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on \texttt{chnl}.

The \texttt{chnl} object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed \texttt{Channel} objects.

When a channel is bound to multiple tasks, the first task to terminate will close the channel. When multiple channels are bound to the same task, termination of the task will close all of the bound channels.

\textbf{Examples}


\begin{minted}{jlcon}
julia> c = Channel(0);

julia> task = @async foreach(i->put!(c, i), 1:4);

julia> bind(c,task);

julia> for i in c
           @show i
       end;
i = 1
i = 2
i = 3
i = 4

julia> isopen(c)
false
\end{minted}


\begin{minted}{jlcon}
julia> c = Channel(0);

julia> task = @async (put!(c,1);error("foo"));

julia> bind(c,task);

julia> take!(c)
1

julia> put!(c,1);
ERROR: foo
Stacktrace:
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/channels.jl#L194-L243}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14996317088638800111}{} 
\hyperlink{14996317088638800111}{\texttt{Sockets.send}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
send(socket::UDPSocket, host::IPAddr, port::Integer, msg)
\end{minted}

Send \texttt{msg} over \texttt{socket} to \texttt{host:port}.



\end{adjustwidth}
\hypertarget{8720184196970920051}{} 
\hyperlink{8720184196970920051}{\texttt{Sockets.recv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
recv(socket::UDPSocket)
\end{minted}

Read a UDP packet from the specified socket, and return the bytes received. This call blocks.



\end{adjustwidth}
\hypertarget{10286416413585635173}{} 
\hyperlink{10286416413585635173}{\texttt{Sockets.recvfrom}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
recvfrom(socket::UDPSocket) -> (host_port, data)
\end{minted}

Read a UDP packet from the specified socket, returning a tuple of \texttt{(host\_port, data)}, where \texttt{host\_port} will be an InetAddr\{IPv4\} or InetAddr\{IPv6\}, as appropriate.

\begin{quote}
\textbf{Julia 1.3}

Prior to Julia version 1.3, the first returned value was an address (\texttt{IPAddr}). In version 1.3 it was changed to an \texttt{InetAddr}.

\end{quote}


\end{adjustwidth}
\hypertarget{16113505891345104473}{} 
\hyperlink{16113505891345104473}{\texttt{Sockets.setopt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
setopt(sock::UDPSocket; multicast_loop=nothing, multicast_ttl=nothing, enable_broadcast=nothing, ttl=nothing)
\end{minted}

Set UDP socket options.

\begin{itemize}
\item \texttt{multicast\_loop}: loopback for multicast packets (default: \texttt{true}).


\item \texttt{multicast\_ttl}: TTL for multicast packets (default: \texttt{nothing}).


\item \texttt{enable\_broadcast}: flag must be set to \texttt{true} if socket will be used for broadcast messages, or else the UDP system will return an access error (default: \texttt{false}).


\item \texttt{ttl}: Time-to-live of packets sent on the socket (default: \texttt{nothing}).

\end{itemize}


\end{adjustwidth}
\hypertarget{6421218738057495658}{} 
\hyperlink{6421218738057495658}{\texttt{Sockets.nagle}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nagle(socket::Union{TCPServer, TCPSocket}, enable::Bool)
\end{minted}

Enables or disables Nagle{\textquotesingle}s algorithm on a given TCP server or socket.



\end{adjustwidth}
\hypertarget{14774922472341203206}{} 
\hyperlink{14774922472341203206}{\texttt{Sockets.quickack}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
quickack(socket::Union{TCPServer, TCPSocket}, enable::Bool)
\end{minted}

On Linux systems, the TCP\_QUICKACK is disabled or enabled on \texttt{socket}.



\end{adjustwidth}

\hypertarget{13048400462292431190}{}


\chapter{稀疏数组}





Julia 在 \texttt{SparseArrays} 标准库模块中提供了对稀疏向量和\href{https://en.wikipedia.org/wiki/Sparse\_matrix}{稀疏矩阵}的支持。与稠密数组相比，包含足够多零值的稀疏数组在以特殊的数据结构存储时可以节省大量的空间和运算时间。



\hypertarget{4438718230137239554}{}


\section{压缩稀疏列(CSC)稀疏矩阵存储}



在Julia中，稀疏矩阵是按照\href{https://en.wikipedia.org/wiki/Sparse\_matrix\#Compressed\_sparse\_column\_.28CSC\_or\_CCS.29}{压缩稀疏列(CSC)格式}存储的。Julia稀疏矩阵具有\hyperlink{15099699527958384292}{\texttt{SparseMatrixCSC\{Tv,Ti\}}}类型，其中\texttt{Tv}是存储值的类型，\texttt{Ti}是存储列指针和行索引的整型类型。\texttt{SparseMatrixCSC}的内部表示如下所示：




\begin{minted}{julia}
struct SparseMatrixCSC{Tv,Ti<:Integer} <: AbstractSparseMatrix{Tv,Ti}
    m::Int                  # Number of rows
    n::Int                  # Number of columns
    colptr::Vector{Ti}      # Column j is in colptr[j]:(colptr[j+1]-1)
    rowval::Vector{Ti}      # Row indices of stored values
    nzval::Vector{Tv}       # Stored values, typically nonzeros
end
\end{minted}



压缩稀疏列存储格式使得访问稀疏矩阵的列元素非常简单快速，而访问稀疏矩阵的行会非常缓慢。在CSC稀疏矩阵中执行类似插入新元素的操作也会非常慢。这是由于在稀疏矩阵中插入新元素时，在插入点之后的所有元素都要向后移动一位。



All operations on sparse matrices are carefully implemented to exploit the CSC data structure for performance, and to avoid expensive operations.



If you have data in CSC format from a different application or library, and wish to import it in Julia, make sure that you use 1-based indexing. The row indices in every column need to be sorted. If your \texttt{SparseMatrixCSC} object contains unsorted row indices, one quick way to sort them is by doing a double transpose.



In some applications, it is convenient to store explicit zero values in a \texttt{SparseMatrixCSC}. These \emph{are} accepted by functions in \texttt{Base} (but there is no guarantee that they will be preserved in mutating operations). Such explicitly stored zeros are treated as structural nonzeros by many routines. The \hyperlink{4231069364201374387}{\texttt{nnz}} function returns the number of elements explicitly stored in the sparse data structure, including structural nonzeros. In order to count the exact number of numerical nonzeros, use \hyperlink{4123799324867706690}{\texttt{count(!iszero, x)}}, which inspects every stored element of a sparse matrix. \hyperlink{10222793754853330762}{\texttt{dropzeros}}, and the in-place \hyperlink{13132808383029320263}{\texttt{dropzeros!}}, can be used to remove stored zeros from the sparse matrix.




\begin{minted}{jlcon}
julia> A = sparse([1, 1, 2, 3], [1, 3, 2, 3], [0, 1, 2, 0])
3×3 SparseMatrixCSC{Int64,Int64} with 4 stored entries:
  [1, 1]  =  0
  [2, 2]  =  2
  [1, 3]  =  1
  [3, 3]  =  0

julia> dropzeros(A)
3×3 SparseMatrixCSC{Int64,Int64} with 2 stored entries:
  [2, 2]  =  2
  [1, 3]  =  1
\end{minted}



\hypertarget{6464897929371876878}{}


\section{稀疏向量储存}



Sparse vectors are stored in a close analog to compressed sparse column format for sparse matrices. In Julia, sparse vectors have the type \hyperlink{17594730109701296640}{\texttt{SparseVector\{Tv,Ti\}}} where \texttt{Tv} is the type of the stored values and \texttt{Ti} the integer type for the indices. The internal representation is as follows:




\begin{minted}{julia}
struct SparseVector{Tv,Ti<:Integer} <: AbstractSparseVector{Tv,Ti}
    n::Int              # Length of the sparse vector
    nzind::Vector{Ti}   # Indices of stored values
    nzval::Vector{Tv}   # Stored values, typically nonzeros
end
\end{minted}



As for \hyperlink{15099699527958384292}{\texttt{SparseMatrixCSC}}, the \texttt{SparseVector} type can also contain explicitly stored zeros. (See \hyperlink{4286524230912717228}{Sparse Matrix Storage}.).



\hypertarget{2715559278970050628}{}


\section{稀疏向量与矩阵构造函数}



The simplest way to create a sparse array is to use a function equivalent to the \hyperlink{13837674686090348619}{\texttt{zeros}} function that Julia provides for working with dense arrays. To produce a sparse array instead, you can use the same name with an \texttt{sp} prefix:




\begin{minted}{jlcon}
julia> spzeros(3)
3-element SparseVector{Float64,Int64} with 0 stored entries
\end{minted}



The \hyperlink{10167157011990389788}{\texttt{sparse}} function is often a handy way to construct sparse arrays. For example, to construct a sparse matrix we can input a vector \texttt{I} of row indices, a vector \texttt{J} of column indices, and a vector \texttt{V} of stored values (this is also known as the \href{https://en.wikipedia.org/wiki/Sparse\_matrix\#Coordinate\_list\_.28COO.29}{COO (coordinate) format}). \texttt{sparse(I,J,V)} then constructs a sparse matrix such that \texttt{S[I[k], J[k]] = V[k]}. The equivalent sparse vector constructor is \hyperlink{13364181309585533450}{\texttt{sparsevec}}, which takes the (row) index vector \texttt{I} and the vector \texttt{V} with the stored values and constructs a sparse vector \texttt{R} such that \texttt{R[I[k]] = V[k]}.




\begin{minted}{jlcon}
julia> I = [1, 4, 3, 5]; J = [4, 7, 18, 9]; V = [1, 2, -5, 3];

julia> S = sparse(I,J,V)
5×18 SparseMatrixCSC{Int64,Int64} with 4 stored entries:
  [1,  4]  =  1
  [4,  7]  =  2
  [5,  9]  =  3
  [3, 18]  =  -5

julia> R = sparsevec(I,V)
5-element SparseVector{Int64,Int64} with 4 stored entries:
  [1]  =  1
  [3]  =  -5
  [4]  =  2
  [5]  =  3
\end{minted}



The inverse of the \hyperlink{10167157011990389788}{\texttt{sparse}} and \hyperlink{13364181309585533450}{\texttt{sparsevec}} functions is \hyperlink{15430174447643444721}{\texttt{findnz}}, which retrieves the inputs used to create the sparse array. \hyperlink{16067208921941164599}{\texttt{findall(!iszero, x)}} returns the cartesian indices of non-zero entries in \texttt{x} (including stored entries equal to zero).




\begin{minted}{jlcon}
julia> findnz(S)
([1, 4, 5, 3], [4, 7, 9, 18], [1, 2, 3, -5])

julia> findall(!iszero, S)
4-element Array{CartesianIndex{2},1}:
 CartesianIndex(1, 4)
 CartesianIndex(4, 7)
 CartesianIndex(5, 9)
 CartesianIndex(3, 18)

julia> findnz(R)
([1, 3, 4, 5], [1, -5, 2, 3])

julia> findall(!iszero, R)
4-element Array{Int64,1}:
 1
 3
 4
 5
\end{minted}



Another way to create a sparse array is to convert a dense array into a sparse array using the \hyperlink{10167157011990389788}{\texttt{sparse}} function:




\begin{minted}{jlcon}
julia> sparse(Matrix(1.0I, 5, 5))
5×5 SparseMatrixCSC{Float64,Int64} with 5 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0
  [4, 4]  =  1.0
  [5, 5]  =  1.0

julia> sparse([1.0, 0.0, 1.0])
3-element SparseVector{Float64,Int64} with 2 stored entries:
  [1]  =  1.0
  [3]  =  1.0
\end{minted}



You can go in the other direction using the \hyperlink{15492651498431872487}{\texttt{Array}} constructor. The \hyperlink{14062776301471954766}{\texttt{issparse}} function can be used to query if a matrix is sparse.




\begin{minted}{jlcon}
julia> issparse(spzeros(5))
true
\end{minted}



\hypertarget{16554788793770073287}{}


\section{稀疏矩阵的操作}



Arithmetic operations on sparse matrices also work as they do on dense matrices. Indexing of, assignment into, and concatenation of sparse matrices work in the same way as dense matrices. Indexing operations, especially assignment, are expensive, when carried out one element at a time. In many cases it may be better to convert the sparse matrix into \texttt{(I,J,V)} format using \hyperlink{15430174447643444721}{\texttt{findnz}}, manipulate the values or the structure in the dense vectors \texttt{(I,J,V)}, and then reconstruct the sparse matrix.



\hypertarget{3328350436064607795}{}


\section{Correspondence of dense and sparse methods}



The following table gives a correspondence between built-in methods on sparse matrices and their corresponding methods on dense matrix types. In general, methods that generate sparse matrices differ from their dense counterparts in that the resulting matrix follows the same sparsity pattern as a given sparse matrix \texttt{S}, or that the resulting sparse matrix has density \texttt{d}, i.e. each matrix element has a probability \texttt{d} of being non-zero.



Details can be found in the \hyperlink{2592358466672034664}{Sparse Vectors and Matrices} section of the standard library reference.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
构造函数 & 密度 & 说明 \\
\hline
\hyperlink{10306793690101482847}{\texttt{spzeros(m,n)}} & \hyperlink{13837674686090348619}{\texttt{zeros(m,n)}} & Creates a \emph{m}-by-\emph{n} matrix of zeros. (\hyperlink{10306793690101482847}{\texttt{spzeros(m,n)}} is empty.) \\
\hline
\hyperlink{10167157011990389788}{\texttt{sparse(I, n, n)}} & \hyperlink{5448927444601277512}{\texttt{Matrix(I,n,n)}} & Creates a \emph{n}-by-\emph{n} identity matrix. \\
\hline
\hyperlink{15492651498431872487}{\texttt{Array(S)}} & \hyperlink{10167157011990389788}{\texttt{sparse(A)}} & Interconverts between dense and sparse formats. \\
\hline
\hyperlink{10437881912081266792}{\texttt{sprand(m,n,d)}} & \hyperlink{7668863842145012694}{\texttt{rand(m,n)}} & Creates a \emph{m}-by-\emph{n} random matrix (of density \emph{d}) with iid non-zero elements distributed uniformly on the half-open interval  \([0, 1)\) . \\
\hline
\hyperlink{3588082437273281277}{\texttt{sprandn(m,n,d)}} & \hyperlink{7347069443766288058}{\texttt{randn(m,n)}} & Creates a \emph{m}-by-\emph{n} random matrix (of density \emph{d}) with iid non-zero elements distributed according to the standard normal (Gaussian) distribution. \\
\hline
\hyperlink{3588082437273281277}{\texttt{sprandn(rng,m,n,d)}} & \hyperlink{7347069443766288058}{\texttt{randn(rng,m,n)}} & Creates a \emph{m}-by-\emph{n} random matrix (of density \emph{d}) with iid non-zero elements generated with the \texttt{rng} random number generator \\
\hline
\end{tabulary}

\end{table}



\hypertarget{2402954669804328212}{}


\chapter{Sparse Arrays}


\hypertarget{428748181300158251}{} 
\hyperlink{428748181300158251}{\texttt{SparseArrays.AbstractSparseArray}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractSparseArray{Tv,Ti,N}
\end{minted}

Supertype for \texttt{N}-dimensional sparse arrays (or array-like types) with elements of type \texttt{Tv} and index type \texttt{Ti}. \hyperlink{15099699527958384292}{\texttt{SparseMatrixCSC}}, \hyperlink{17594730109701296640}{\texttt{SparseVector}} and \texttt{SuiteSparse.CHOLMOD.Sparse} are subtypes of this.



\end{adjustwidth}
\hypertarget{7311510774978482969}{} 
\hyperlink{7311510774978482969}{\texttt{SparseArrays.AbstractSparseVector}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractSparseVector{Tv,Ti}
\end{minted}

Supertype for one-dimensional sparse arrays (or array-like types) with elements of type \texttt{Tv} and index type \texttt{Ti}. Alias for \texttt{AbstractSparseArray\{Tv,Ti,1\}}.



\end{adjustwidth}
\hypertarget{7507379576530105001}{} 
\hyperlink{7507379576530105001}{\texttt{SparseArrays.AbstractSparseMatrix}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractSparseMatrix{Tv,Ti}
\end{minted}

Supertype for two-dimensional sparse arrays (or array-like types) with elements of type \texttt{Tv} and index type \texttt{Ti}. Alias for \texttt{AbstractSparseArray\{Tv,Ti,2\}}.



\end{adjustwidth}
\hypertarget{17594730109701296640}{} 
\hyperlink{17594730109701296640}{\texttt{SparseArrays.SparseVector}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SparseVector{Tv,Ti<:Integer} <: AbstractSparseVector{Tv,Ti}
\end{minted}

Vector type for storing sparse vectors.



\end{adjustwidth}
\hypertarget{15099699527958384292}{} 
\hyperlink{15099699527958384292}{\texttt{SparseArrays.SparseMatrixCSC}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SparseMatrixCSC{Tv,Ti<:Integer} <: AbstractSparseMatrixCSC{Tv,Ti}
\end{minted}

Matrix type for storing sparse matrices in the \hyperlink{4286524230912717228}{Compressed Sparse Column} format. The standard way of constructing SparseMatrixCSC is through the \hyperlink{10167157011990389788}{\texttt{sparse}} function. See also \hyperlink{10306793690101482847}{\texttt{spzeros}}, \hyperlink{10407455986460913397}{\texttt{spdiagm}} and \hyperlink{10437881912081266792}{\texttt{sprand}}.



\end{adjustwidth}
\hypertarget{10167157011990389788}{} 
\hyperlink{10167157011990389788}{\texttt{SparseArrays.sparse}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sparse(A)
\end{minted}

Convert an AbstractMatrix \texttt{A} into a sparse matrix.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = Matrix(1.0I, 3, 3)
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia> sparse(A)
3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0
\end{minted}




\begin{lstlisting}
sparse(I, J, V,[ m, n, combine])
\end{lstlisting}

Create a sparse matrix \texttt{S} of dimensions \texttt{m x n} such that \texttt{S[I[k], J[k]] = V[k]}. The \texttt{combine} function is used to combine duplicates. If \texttt{m} and \texttt{n} are not specified, they are set to \texttt{maximum(I)} and \texttt{maximum(J)} respectively. If the \texttt{combine} function is not supplied, \texttt{combine} defaults to \texttt{+} unless the elements of \texttt{V} are Booleans in which case \texttt{combine} defaults to \texttt{|}. All elements of \texttt{I} must satisfy \texttt{1 <= I[k] <= m}, and all elements of \texttt{J} must satisfy \texttt{1 <= J[k] <= n}. Numerical zeros in (\texttt{I}, \texttt{J}, \texttt{V}) are retained as structural nonzeros; to drop numerical zeros, use \hyperlink{13132808383029320263}{\texttt{dropzeros!}}.

For additional documentation and an expert driver, see \texttt{SparseArrays.sparse!}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Is = [1; 2; 3];

julia> Js = [1; 2; 3];

julia> Vs = [1; 2; 3];

julia> sparse(Is, Js, Vs)
3×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:
  [1, 1]  =  1
  [2, 2]  =  2
  [3, 3]  =  3
\end{minted}



\end{adjustwidth}
\hypertarget{13364181309585533450}{} 
\hyperlink{13364181309585533450}{\texttt{SparseArrays.sparsevec}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sparsevec(I, V, [m, combine])
\end{minted}

Create a sparse vector \texttt{S} of length \texttt{m} such that \texttt{S[I[k]] = V[k]}. Duplicates are combined using the \texttt{combine} function, which defaults to \texttt{+} if no \texttt{combine} argument is provided, unless the elements of \texttt{V} are Booleans in which case \texttt{combine} defaults to \texttt{|}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> II = [1, 3, 3, 5]; V = [0.1, 0.2, 0.3, 0.2];

julia> sparsevec(II, V)
5-element SparseVector{Float64,Int64} with 3 stored entries:
  [1]  =  0.1
  [3]  =  0.5
  [5]  =  0.2

julia> sparsevec(II, V, 8, -)
8-element SparseVector{Float64,Int64} with 3 stored entries:
  [1]  =  0.1
  [3]  =  -0.1
  [5]  =  0.2

julia> sparsevec([1, 3, 1, 2, 2], [true, true, false, false, false])
3-element SparseVector{Bool,Int64} with 3 stored entries:
  [1]  =  1
  [2]  =  0
  [3]  =  1
\end{minted}




\begin{lstlisting}
sparsevec(d::Dict, [m])
\end{lstlisting}

Create a sparse vector of length \texttt{m} where the nonzero indices are keys from the dictionary, and the nonzero values are the values from the dictionary.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sparsevec(Dict(1 => 3, 2 => 2))
2-element SparseVector{Int64,Int64} with 2 stored entries:
  [1]  =  3
  [2]  =  2
\end{minted}




\begin{lstlisting}
sparsevec(A)
\end{lstlisting}

Convert a vector \texttt{A} into a sparse vector of length \texttt{m}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sparsevec([1.0, 2.0, 0.0, 0.0, 3.0, 0.0])
6-element SparseVector{Float64,Int64} with 3 stored entries:
  [1]  =  1.0
  [2]  =  2.0
  [5]  =  3.0
\end{minted}



\end{adjustwidth}
\hypertarget{14062776301471954766}{} 
\hyperlink{14062776301471954766}{\texttt{SparseArrays.issparse}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issparse(S)
\end{minted}

Returns \texttt{true} if \texttt{S} is sparse, and \texttt{false} otherwise.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sv = sparsevec([1, 4], [2.3, 2.2], 10)
10-element SparseVector{Float64,Int64} with 2 stored entries:
  [1 ]  =  2.3
  [4 ]  =  2.2

julia> issparse(sv)
true

julia> issparse(Array(sv))
false
\end{minted}



\end{adjustwidth}
\hypertarget{4231069364201374387}{} 
\hyperlink{4231069364201374387}{\texttt{SparseArrays.nnz}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nnz(A)
\end{minted}

Returns the number of stored (filled) elements in a sparse array.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = sparse(2I, 3, 3)
3×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:
  [1, 1]  =  2
  [2, 2]  =  2
  [3, 3]  =  2

julia> nnz(A)
3
\end{minted}



\end{adjustwidth}
\hypertarget{15430174447643444721}{} 
\hyperlink{15430174447643444721}{\texttt{SparseArrays.findnz}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findnz(A)
\end{minted}

Return a tuple \texttt{(I, J, V)} where \texttt{I} and \texttt{J} are the row and column indices of the stored ({\textquotedbl}structurally non-zero{\textquotedbl}) values in sparse matrix \texttt{A}, and \texttt{V} is a vector of the values.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = sparse([1 2 0; 0 0 3; 0 4 0])
3×3 SparseMatrixCSC{Int64,Int64} with 4 stored entries:
  [1, 1]  =  1
  [1, 2]  =  2
  [3, 2]  =  4
  [2, 3]  =  3

julia> findnz(A)
([1, 1, 3, 2], [1, 2, 2, 3], [1, 2, 4, 3])
\end{minted}



\end{adjustwidth}
\hypertarget{10306793690101482847}{} 
\hyperlink{10306793690101482847}{\texttt{SparseArrays.spzeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
spzeros([type,]m[,n])
\end{minted}

Create a sparse vector of length \texttt{m} or sparse matrix of size \texttt{m x n}. This sparse array will not contain any nonzero values. No storage will be allocated for nonzero values during construction. The type defaults to \hyperlink{5027751419500983000}{\texttt{Float64}} if not specified.

\textbf{Examples}


\begin{minted}{jlcon}
julia> spzeros(3, 3)
3×3 SparseMatrixCSC{Float64,Int64} with 0 stored entries

julia> spzeros(Float32, 4)
4-element SparseVector{Float32,Int64} with 0 stored entries
\end{minted}



\end{adjustwidth}
\hypertarget{10407455986460913397}{} 
\hyperlink{10407455986460913397}{\texttt{SparseArrays.spdiagm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
spdiagm(kv::Pair{<:Integer,<:AbstractVector}...)
spdiagm(m::Integer, n::Ingeger, kv::Pair{<:Integer,<:AbstractVector}...)
\end{minted}

Construct a sparse diagonal matrix from \texttt{Pair}s of vectors and diagonals. Each vector \texttt{kv.second} will be placed on the \texttt{kv.first} diagonal.  By default (if \texttt{size=nothing}), the matrix is square and its size is inferred from \texttt{kv}, but a non-square size \texttt{m}×\texttt{n} (padded with zeros as needed) can be specified by passing \texttt{m,n} as the first arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> spdiagm(-1 => [1,2,3,4], 1 => [4,3,2,1])
5×5 SparseMatrixCSC{Int64,Int64} with 8 stored entries:
  [2, 1]  =  1
  [1, 2]  =  4
  [3, 2]  =  2
  [2, 3]  =  3
  [4, 3]  =  3
  [3, 4]  =  2
  [5, 4]  =  4
  [4, 5]  =  1
\end{minted}



\end{adjustwidth}
\hypertarget{12222128005156653307}{} 
\hyperlink{12222128005156653307}{\texttt{SparseArrays.blockdiag}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
blockdiag(A...)
\end{minted}

Concatenate matrices block-diagonally. Currently only implemented for sparse matrices.

\textbf{Examples}


\begin{minted}{jlcon}
julia> blockdiag(sparse(2I, 3, 3), sparse(4I, 2, 2))
5×5 SparseMatrixCSC{Int64,Int64} with 5 stored entries:
  [1, 1]  =  2
  [2, 2]  =  2
  [3, 3]  =  2
  [4, 4]  =  4
  [5, 5]  =  4
\end{minted}



\end{adjustwidth}
\hypertarget{10437881912081266792}{} 
\hyperlink{10437881912081266792}{\texttt{SparseArrays.sprand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sprand([rng],[type],m,[n],p::AbstractFloat,[rfn])
\end{minted}

Create a random length \texttt{m} sparse vector or \texttt{m} by \texttt{n} sparse matrix, in which the probability of any element being nonzero is independently given by \texttt{p} (and hence the mean density of nonzeros is also exactly \texttt{p}). Nonzero values are sampled from the distribution specified by \texttt{rfn} and have the type \texttt{type}. The uniform distribution is used in case \texttt{rfn} is not specified. The optional \texttt{rng} argument specifies a random number generator, see \href{@ref}{Random Numbers}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sprand(Bool, 2, 2, 0.5)
2×2 SparseMatrixCSC{Bool,Int64} with 1 stored entry:
  [2, 2]  =  1

julia> sprand(Float64, 3, 0.75)
3-element SparseVector{Float64,Int64} with 1 stored entry:
  [3]  =  0.298614
\end{minted}



\end{adjustwidth}
\hypertarget{3588082437273281277}{} 
\hyperlink{3588082437273281277}{\texttt{SparseArrays.sprandn}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sprandn([rng][,Type],m[,n],p::AbstractFloat)
\end{minted}

Create a random sparse vector of length \texttt{m} or sparse matrix of size \texttt{m} by \texttt{n} with the specified (independent) probability \texttt{p} of any entry being nonzero, where nonzero values are sampled from the normal distribution. The optional \texttt{rng} argument specifies a random number generator, see \href{@ref}{Random Numbers}.

\begin{quote}
\textbf{Julia 1.1}

Specifying the output element type \texttt{Type} requires at least Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> sprandn(2, 2, 0.75)
2×2 SparseMatrixCSC{Float64,Int64} with 2 stored entries:
  [1, 2]  =  0.586617
  [2, 2]  =  0.297336
\end{minted}



\end{adjustwidth}
\hypertarget{2553509978651134823}{} 
\hyperlink{2553509978651134823}{\texttt{SparseArrays.nonzeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nonzeros(A)
\end{minted}

Return a vector of the structural nonzero values in sparse array \texttt{A}. This includes zeros that are explicitly stored in the sparse array. The returned vector points directly to the internal nonzero storage of \texttt{A}, and any modifications to the returned vector will mutate \texttt{A} as well. See \hyperlink{11529930160190690800}{\texttt{rowvals}} and \hyperlink{4192027552568489301}{\texttt{nzrange}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = sparse(2I, 3, 3)
3×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:
  [1, 1]  =  2
  [2, 2]  =  2
  [3, 3]  =  2

julia> nonzeros(A)
3-element Array{Int64,1}:
 2
 2
 2
\end{minted}



\end{adjustwidth}
\hypertarget{11529930160190690800}{} 
\hyperlink{11529930160190690800}{\texttt{SparseArrays.rowvals}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rowvals(A::AbstractSparseMatrixCSC)
\end{minted}

Return a vector of the row indices of \texttt{A}. Any modifications to the returned vector will mutate \texttt{A} as well. Providing access to how the row indices are stored internally can be useful in conjunction with iterating over structural nonzero values. See also \hyperlink{2553509978651134823}{\texttt{nonzeros}} and \hyperlink{4192027552568489301}{\texttt{nzrange}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = sparse(2I, 3, 3)
3×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:
  [1, 1]  =  2
  [2, 2]  =  2
  [3, 3]  =  2

julia> rowvals(A)
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



\end{adjustwidth}
\hypertarget{4192027552568489301}{} 
\hyperlink{4192027552568489301}{\texttt{SparseArrays.nzrange}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nzrange(A::AbstractSparseMatrixCSC, col::Integer)
\end{minted}

Return the range of indices to the structural nonzero values of a sparse matrix column. In conjunction with \hyperlink{2553509978651134823}{\texttt{nonzeros}} and \hyperlink{11529930160190690800}{\texttt{rowvals}}, this allows for convenient iterating over a sparse matrix :


\begin{lstlisting}
A = sparse(I,J,V)
rows = rowvals(A)
vals = nonzeros(A)
m, n = size(A)
for j = 1:n
   for i in nzrange(A, j)
      row = rows[i]
      val = vals[i]
      # perform sparse wizardry...
   end
end
\end{lstlisting}



\end{adjustwidth}
\hypertarget{10473482629417875992}{} 
\hyperlink{10473482629417875992}{\texttt{SparseArrays.droptol!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
droptol!(A::AbstractSparseMatrixCSC, tol; trim::Bool = true)
\end{minted}

Removes stored values from \texttt{A} whose absolute value is less than or equal to \texttt{tol}, optionally trimming resulting excess space from \texttt{rowvals(A)} and \texttt{nonzeros(A)} when \texttt{trim} is \texttt{true}.




\begin{lstlisting}
droptol!(x::SparseVector, tol; trim::Bool = true)
\end{lstlisting}

Removes stored values from \texttt{x} whose absolute value is less than or equal to \texttt{tol}, optionally trimming resulting excess space from \texttt{nonzeroinds(x)} and \texttt{nonzeros(x)} when \texttt{trim} is \texttt{true}.



\end{adjustwidth}
\hypertarget{13132808383029320263}{} 
\hyperlink{13132808383029320263}{\texttt{SparseArrays.dropzeros!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dropzeros!(A::AbstractSparseMatrixCSC; trim::Bool = true)
\end{minted}

Removes stored numerical zeros from \texttt{A}, optionally trimming resulting excess space from \texttt{rowvals(A)} and \texttt{nonzeros(A)} when \texttt{trim} is \texttt{true}.

For an out-of-place version, see \hyperlink{10222793754853330762}{\texttt{dropzeros}}. For algorithmic information, see \texttt{fkeep!}.




\begin{lstlisting}
dropzeros!(x::SparseVector; trim::Bool = true)
\end{lstlisting}

Removes stored numerical zeros from \texttt{x}, optionally trimming resulting excess space from \texttt{nonzeroinds(x)} and \texttt{nonzeros(x)} when \texttt{trim} is \texttt{true}.

For an out-of-place version, see \hyperlink{10222793754853330762}{\texttt{dropzeros}}. For algorithmic information, see \texttt{fkeep!}.



\end{adjustwidth}
\hypertarget{10222793754853330762}{} 
\hyperlink{10222793754853330762}{\texttt{SparseArrays.dropzeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dropzeros(A::AbstractSparseMatrixCSC; trim::Bool = true)
\end{minted}

Generates a copy of \texttt{A} and removes stored numerical zeros from that copy, optionally trimming excess space from the result{\textquotesingle}s \texttt{rowval} and \texttt{nzval} arrays when \texttt{trim} is \texttt{true}.

For an in-place version and algorithmic information, see \hyperlink{13132808383029320263}{\texttt{dropzeros!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = sparse([1, 2, 3], [1, 2, 3], [1.0, 0.0, 1.0])
3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  0.0
  [3, 3]  =  1.0

julia> dropzeros(A)
3×3 SparseMatrixCSC{Float64,Int64} with 2 stored entries:
  [1, 1]  =  1.0
  [3, 3]  =  1.0
\end{minted}




\begin{lstlisting}
dropzeros(x::SparseVector; trim::Bool = true)
\end{lstlisting}

Generates a copy of \texttt{x} and removes numerical zeros from that copy, optionally trimming excess space from the result{\textquotesingle}s \texttt{nzind} and \texttt{nzval} arrays when \texttt{trim} is \texttt{true}.

For an in-place version and algorithmic information, see \hyperlink{13132808383029320263}{\texttt{dropzeros!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = sparsevec([1, 2, 3], [1.0, 0.0, 1.0])
3-element SparseVector{Float64,Int64} with 3 stored entries:
  [1]  =  1.0
  [2]  =  0.0
  [3]  =  1.0

julia> dropzeros(A)
3-element SparseVector{Float64,Int64} with 2 stored entries:
  [1]  =  1.0
  [3]  =  1.0
\end{minted}



\end{adjustwidth}
\hypertarget{12003442917636022234}{} 
\hyperlink{12003442917636022234}{\texttt{SparseArrays.permute}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
permute(A::AbstractSparseMatrixCSC{Tv,Ti}, p::AbstractVector{<:Integer},
        q::AbstractVector{<:Integer}) where {Tv,Ti}
\end{minted}

Bilaterally permute \texttt{A}, returning \texttt{PAQ} (\texttt{A[p,q]}). Column-permutation \texttt{q}{\textquotesingle}s length must match \texttt{A}{\textquotesingle}s column count (\texttt{length(q) == size(A, 2)}). Row-permutation \texttt{p}{\textquotesingle}s length must match \texttt{A}{\textquotesingle}s row count (\texttt{length(p) == size(A, 1)}).

For expert drivers and additional information, see \hyperlink{17157632988142440888}{\texttt{permute!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = spdiagm(0 => [1, 2, 3, 4], 1 => [5, 6, 7])
4×4 SparseMatrixCSC{Int64,Int64} with 7 stored entries:
  [1, 1]  =  1
  [1, 2]  =  5
  [2, 2]  =  2
  [2, 3]  =  6
  [3, 3]  =  3
  [3, 4]  =  7
  [4, 4]  =  4

julia> permute(A, [4, 3, 2, 1], [1, 2, 3, 4])
4×4 SparseMatrixCSC{Int64,Int64} with 7 stored entries:
  [4, 1]  =  1
  [3, 2]  =  2
  [4, 2]  =  5
  [2, 3]  =  3
  [3, 3]  =  6
  [1, 4]  =  4
  [2, 4]  =  7

julia> permute(A, [1, 2, 3, 4], [4, 3, 2, 1])
4×4 SparseMatrixCSC{Int64,Int64} with 7 stored entries:
  [3, 1]  =  7
  [4, 1]  =  4
  [2, 2]  =  6
  [3, 2]  =  3
  [1, 3]  =  5
  [2, 3]  =  2
  [1, 4]  =  1
\end{minted}



\end{adjustwidth}
\hypertarget{10817887949404037920}{} 
\hyperlink{10817887949404037920}{\texttt{Base.permute!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
permute!(X::AbstractSparseMatrixCSC{Tv,Ti}, A::AbstractSparseMatrixCSC{Tv,Ti},
         p::AbstractVector{<:Integer}, q::AbstractVector{<:Integer},
         [C::AbstractSparseMatrixCSC{Tv,Ti}]) where {Tv,Ti}
\end{minted}

Bilaterally permute \texttt{A}, storing result \texttt{PAQ} (\texttt{A[p,q]}) in \texttt{X}. Stores intermediate result \texttt{(AQ){\textasciicircum}T} (\texttt{transpose(A[:,q])}) in optional argument \texttt{C} if present. Requires that none of \texttt{X}, \texttt{A}, and, if present, \texttt{C} alias each other; to store result \texttt{PAQ} back into \texttt{A}, use the following method lacking \texttt{X}:


\begin{lstlisting}
permute!(A::AbstractSparseMatrixCSC{Tv,Ti}, p::AbstractVector{<:Integer},
         q::AbstractVector{<:Integer}[, C::AbstractSparseMatrixCSC{Tv,Ti},
         [workcolptr::Vector{Ti}]]) where {Tv,Ti}
\end{lstlisting}

\texttt{X}{\textquotesingle}s dimensions must match those of \texttt{A} (\texttt{size(X, 1) == size(A, 1)} and \texttt{size(X, 2) == size(A, 2)}), and \texttt{X} must have enough storage to accommodate all allocated entries in \texttt{A} (\texttt{length(rowvals(X)) >= nnz(A)} and \texttt{length(nonzeros(X)) >= nnz(A)}). Column-permutation \texttt{q}{\textquotesingle}s length must match \texttt{A}{\textquotesingle}s column count (\texttt{length(q) == size(A, 2)}). Row-permutation \texttt{p}{\textquotesingle}s length must match \texttt{A}{\textquotesingle}s row count (\texttt{length(p) == size(A, 1)}).

\texttt{C}{\textquotesingle}s dimensions must match those of \texttt{transpose(A)} (\texttt{size(C, 1) == size(A, 2)} and \texttt{size(C, 2) == size(A, 1)}), and \texttt{C} must have enough storage to accommodate all allocated entries in \texttt{A} (\texttt{length(rowvals(C)) >= nnz(A)} and \texttt{length(nonzeros(C)) >= nnz(A)}).

For additional (algorithmic) information, and for versions of these methods that forgo argument checking, see (unexported) parent methods \texttt{unchecked\_noalias\_permute!} and \texttt{unchecked\_aliasing\_permute!}.

See also: \hyperlink{12003442917636022234}{\texttt{permute}}.



\end{adjustwidth}



\hypertarget{3919294208060022612}{}


\chapter{统计}





统计模块包含了基本的统计函数。


\hypertarget{1955374586742019663}{} 
\hyperlink{1955374586742019663}{\texttt{Statistics.std}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
std(itr; corrected::Bool=true, mean=nothing[, dims])
\end{minted}

Compute the sample standard deviation of collection \texttt{itr}.

The algorithm returns an estimator of the generative distribution{\textquotesingle}s standard deviation under the assumption that each entry of \texttt{itr} is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating \texttt{sqrt(sum((itr .- mean(itr)).{\textasciicircum}2) / (length(itr) - 1))}. If \texttt{corrected} is \texttt{true}, then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} with \texttt{n} the number of elements in \texttt{itr}.

A pre-computed \texttt{mean} may be provided.

If \texttt{itr} is an \texttt{AbstractArray}, \texttt{dims} can be provided to compute the standard deviation over dimensions, and \texttt{means} may contain means for each dimension of \texttt{itr}.

\begin{quote}
\textbf{Note}

If array contains \texttt{NaN} or \hyperlink{14596725676261444434}{\texttt{missing}} values, the result is also \texttt{NaN} or \texttt{missing} (\texttt{missing} takes precedence if array contains both). Use the \hyperlink{2012470681884771400}{\texttt{skipmissing}} function to omit \texttt{missing} entries and compute the standard deviation of non-missing values.

\end{quote}


\end{adjustwidth}
\hypertarget{11197607150486088950}{} 
\hyperlink{11197607150486088950}{\texttt{Statistics.stdm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stdm(itr, m; corrected::Bool=true)
\end{minted}

Compute the sample standard deviation of collection \texttt{itr}, with known mean(s) \texttt{m}.

The algorithm returns an estimator of the generative distribution{\textquotesingle}s standard deviation under the assumption that each entry of \texttt{itr} is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating \texttt{sqrt(sum((itr .- mean(itr)).{\textasciicircum}2) / (length(itr) - 1))}. If \texttt{corrected} is \texttt{true}, then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} with \texttt{n} the number of elements in \texttt{itr}.

A pre-computed \texttt{mean} may be provided.

If \texttt{itr} is an \texttt{AbstractArray}, \texttt{dims} can be provided to compute the standard deviation over dimensions, and \texttt{m} may contain means for each dimension of \texttt{itr}.

\begin{quote}
\textbf{Note}

If array contains \texttt{NaN} or \hyperlink{14596725676261444434}{\texttt{missing}} values, the result is also \texttt{NaN} or \texttt{missing} (\texttt{missing} takes precedence if array contains both). Use the \hyperlink{2012470681884771400}{\texttt{skipmissing}} function to omit \texttt{missing} entries and compute the standard deviation of non-missing values.

\end{quote}


\end{adjustwidth}
\hypertarget{3113715888143479678}{} 
\hyperlink{3113715888143479678}{\texttt{Statistics.var}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
var(itr; dims, corrected::Bool=true, mean=nothing)
\end{minted}

Compute the sample variance of collection \texttt{itr}.

The algorithm returns an estimator of the generative distribution{\textquotesingle}s variance under the assumption that each entry of \texttt{itr} is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating \texttt{sum((itr .- mean(itr)).{\textasciicircum}2) / (length(itr) - 1)). If}corrected\texttt{is}true\texttt{, then the sum is scaled with}n-1\texttt{, whereas the sum is scaled with}n\texttt{if}corrected\texttt{is}false\texttt{with}n\texttt{the number of elements in}itr`.

A pre-computed \texttt{mean} may be provided.

If \texttt{itr} is an \texttt{AbstractArray}, \texttt{dims} can be provided to compute the variance over dimensions, and \texttt{mean} may contain means for each dimension of \texttt{itr}.

\begin{quote}
\textbf{Note}

If array contains \texttt{NaN} or \hyperlink{14596725676261444434}{\texttt{missing}} values, the result is also \texttt{NaN} or \texttt{missing} (\texttt{missing} takes precedence if array contains both). Use the \hyperlink{2012470681884771400}{\texttt{skipmissing}} function to omit \texttt{missing} entries and compute the variance of non-missing values.

\end{quote}


\end{adjustwidth}
\hypertarget{11347311999392006255}{} 
\hyperlink{11347311999392006255}{\texttt{Statistics.varm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
varm(itr, m; dims, corrected::Bool=true)
\end{minted}

Compute the sample variance of collection \texttt{itr}, with known mean(s) \texttt{m}.

The algorithm returns an estimator of the generative distribution{\textquotesingle}s variance under the assumption that each entry of \texttt{itr} is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating \texttt{sum((itr .- mean(itr)).{\textasciicircum}2) / (length(itr) - 1)}. If \texttt{corrected} is \texttt{true}, then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} with \texttt{n} the number of elements in \texttt{itr}.

If \texttt{itr} is an \texttt{AbstractArray}, \texttt{dims} can be provided to compute the variance over dimensions, and \texttt{m} may contain means for each dimension of \texttt{itr}.

\begin{quote}
\textbf{Note}

If array contains \texttt{NaN} or \hyperlink{14596725676261444434}{\texttt{missing}} values, the result is also \texttt{NaN} or \texttt{missing} (\texttt{missing} takes precedence if array contains both). Use the \hyperlink{2012470681884771400}{\texttt{skipmissing}} function to omit \texttt{missing} entries and compute the variance of non-missing values.

\end{quote}


\end{adjustwidth}
\hypertarget{16231972474237968518}{} 
\hyperlink{16231972474237968518}{\texttt{Statistics.cor}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cor(x::AbstractVector)
\end{minted}

Return the number one.




\begin{lstlisting}
cor(X::AbstractMatrix; dims::Int=1)
\end{lstlisting}

Compute the Pearson correlation matrix of the matrix \texttt{X} along the dimension \texttt{dims}.




\begin{lstlisting}
cor(x::AbstractVector, y::AbstractVector)
\end{lstlisting}

Compute the Pearson correlation between the vectors \texttt{x} and \texttt{y}.




\begin{lstlisting}
cor(X::AbstractVecOrMat, Y::AbstractVecOrMat; dims=1)
\end{lstlisting}

Compute the Pearson correlation between the vectors or matrices \texttt{X} and \texttt{Y} along the dimension \texttt{dims}.



\end{adjustwidth}
\hypertarget{7202855476046698513}{} 
\hyperlink{7202855476046698513}{\texttt{Statistics.cov}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cov(x::AbstractVector; corrected::Bool=true)
\end{minted}

Compute the variance of the vector \texttt{x}. If \texttt{corrected} is \texttt{true} (the default) then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} where \texttt{n = length(x)}.




\begin{lstlisting}
cov(X::AbstractMatrix; dims::Int=1, corrected::Bool=true)
\end{lstlisting}

Compute the covariance matrix of the matrix \texttt{X} along the dimension \texttt{dims}. If \texttt{corrected} is \texttt{true} (the default) then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} where \texttt{n = size(X, dims)}.




\begin{lstlisting}
cov(x::AbstractVector, y::AbstractVector; corrected::Bool=true)
\end{lstlisting}

Compute the covariance between the vectors \texttt{x} and \texttt{y}. If \texttt{corrected} is \texttt{true} (the default), computes  \(\frac{1}{n-1}\sum_{i=1}^n (x_i-\bar x) (y_i-\bar y)^*\)  where  \(*\)  denotes the complex conjugate and \texttt{n = length(x) = length(y)}. If \texttt{corrected} is \texttt{false}, computes  \(\frac{1}{n}\sum_{i=1}^n (x_i-\bar x) (y_i-\bar y)^*\) .




\begin{lstlisting}
cov(X::AbstractVecOrMat, Y::AbstractVecOrMat; dims::Int=1, corrected::Bool=true)
\end{lstlisting}

Compute the covariance between the vectors or matrices \texttt{X} and \texttt{Y} along the dimension \texttt{dims}. If \texttt{corrected} is \texttt{true} (the default) then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} where \texttt{n = size(X, dims) = size(Y, dims)}.



\end{adjustwidth}
\hypertarget{9852865620009351869}{} 
\hyperlink{9852865620009351869}{\texttt{Statistics.mean!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mean!(r, v)
\end{minted}

Compute the mean of \texttt{v} over the singleton dimensions of \texttt{r}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> mean!([1., 1.], v)
2-element Array{Float64,1}:
 1.5
 3.5

julia> mean!([1. 1.], v)
1×2 Array{Float64,2}:
 2.0  3.0
\end{minted}



\end{adjustwidth}
\hypertarget{15061550543970113934}{} 
\hyperlink{15061550543970113934}{\texttt{Statistics.mean}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mean(itr)
\end{minted}

Compute the mean of all elements in a collection.

\begin{quote}
\textbf{Note}

If \texttt{itr} contains \texttt{NaN} or \hyperlink{14596725676261444434}{\texttt{missing}} values, the result is also \texttt{NaN} or \texttt{missing} (\texttt{missing} takes precedence if array contains both). Use the \hyperlink{2012470681884771400}{\texttt{skipmissing}} function to omit \texttt{missing} entries and compute the mean of non-missing values.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> mean(1:20)
10.5

julia> mean([1, missing, 3])
missing

julia> mean(skipmissing([1, missing, 3]))
2.0
\end{minted}




\begin{lstlisting}
mean(f::Function, itr)
\end{lstlisting}

Apply the function \texttt{f} to each element of collection \texttt{itr} and take the mean.


\begin{minted}{jlcon}
julia> mean(√, [1, 2, 3])
1.3820881233139908

julia> mean([√1, √2, √3])
1.3820881233139908
\end{minted}




\begin{lstlisting}
mean(f::Function, A::AbstractArray; dims)
\end{lstlisting}

Apply the function \texttt{f} to each element of array \texttt{A} and take the mean over dimensions \texttt{dims}.

\begin{quote}
\textbf{Julia 1.3}

This method requires at least Julia 1.3.

\end{quote}

\begin{minted}{jlcon}
julia> mean(√, [1, 2, 3])
1.3820881233139908

julia> mean([√1, √2, √3])
1.3820881233139908

julia> mean(√, [1 2 3; 4 5 6], dims=2)
2×1 Array{Float64,2}:
 1.3820881233139908
 2.2285192400943226
\end{minted}




\begin{lstlisting}
mean(A::AbstractArray; dims)
\end{lstlisting}

Compute the mean of an array over the given dimensions.

\begin{quote}
\textbf{Julia 1.1}

\texttt{mean} for empty arrays requires at least Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> mean(A, dims=1)
1×2 Array{Float64,2}:
 2.0  3.0

julia> mean(A, dims=2)
2×1 Array{Float64,2}:
 1.5
 3.5
\end{minted}



\end{adjustwidth}
\hypertarget{5238557773914917939}{} 
\hyperlink{5238557773914917939}{\texttt{Statistics.median!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
median!(v)
\end{minted}

Like \hyperlink{7663137055249909841}{\texttt{median}}, but may overwrite the input vector.



\end{adjustwidth}
\hypertarget{7663137055249909841}{} 
\hyperlink{7663137055249909841}{\texttt{Statistics.median}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
median(itr)
\end{minted}

Compute the median of all elements in a collection. For an even number of elements no exact median element exists, so the result is equivalent to calculating mean of two median elements.

\begin{quote}
\textbf{Note}

If \texttt{itr} contains \texttt{NaN} or \hyperlink{14596725676261444434}{\texttt{missing}} values, the result is also \texttt{NaN} or \texttt{missing} (\texttt{missing} takes precedence if \texttt{itr} contains both). Use the \hyperlink{2012470681884771400}{\texttt{skipmissing}} function to omit \texttt{missing} entries and compute the median of non-missing values.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> median([1, 2, 3])
2.0

julia> median([1, 2, 3, 4])
2.5

julia> median([1, 2, missing, 4])
missing

julia> median(skipmissing([1, 2, missing, 4]))
2.0
\end{minted}




\begin{lstlisting}
median(A::AbstractArray; dims)
\end{lstlisting}

Compute the median of an array along the given dimensions.

\textbf{Examples}


\begin{minted}{jlcon}
julia> median([1 2; 3 4], dims=1)
1×2 Array{Float64,2}:
 2.0  3.0
\end{minted}



\end{adjustwidth}
\hypertarget{14662071173540942276}{} 
\hyperlink{14662071173540942276}{\texttt{Statistics.middle}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
middle(x)
\end{minted}

Compute the middle of a scalar value, which is equivalent to \texttt{x} itself, but of the type of \texttt{middle(x, x)} for consistency.




\begin{lstlisting}
middle(x, y)
\end{lstlisting}

Compute the middle of two reals \texttt{x} and \texttt{y}, which is equivalent in both value and type to computing their mean (\texttt{(x + y) / 2}).




\begin{lstlisting}
middle(range)
\end{lstlisting}

Compute the middle of a range, which consists of computing the mean of its extrema. Since a range is sorted, the mean is performed with the first and last element.


\begin{minted}{jlcon}
julia> middle(1:10)
5.5
\end{minted}




\begin{lstlisting}
middle(a)
\end{lstlisting}

Compute the middle of an array \texttt{a}, which consists of finding its extrema and then computing their mean.


\begin{minted}{jlcon}
julia> a = [1,2,3.6,10.9]
4-element Array{Float64,1}:
  1.0
  2.0
  3.6
 10.9

julia> middle(a)
5.95
\end{minted}



\end{adjustwidth}
\hypertarget{14611219682884062063}{} 
\hyperlink{14611219682884062063}{\texttt{Statistics.quantile!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
quantile!([q::AbstractArray, ] v::AbstractVector, p; sorted=false)
\end{minted}

Compute the quantile(s) of a vector \texttt{v} at a specified probability or vector or tuple of probabilities \texttt{p} on the interval [0,1]. If \texttt{p} is a vector, an optional output array \texttt{q} may also be specified. (If not provided, a new output array is created.) The keyword argument \texttt{sorted} indicates whether \texttt{v} can be assumed to be sorted; if \texttt{false} (the default), then the elements of \texttt{v} will be partially sorted in-place.

Quantiles are computed via linear interpolation between the points \texttt{((k-1)/(n-1), v[k])}, for \texttt{k = 1:n} where \texttt{n = length(v)}. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R default.

\begin{quote}
\textbf{Note}

An \texttt{ArgumentError} is thrown if \texttt{v} contains \texttt{NaN} or \hyperlink{14596725676261444434}{\texttt{missing}} values.

\end{quote}
\begin{itemize}
\item Hyndman, R.J and Fan, Y. (1996) {\textquotedbl}Sample Quantiles in Statistical Packages{\textquotedbl}, \emph{The American Statistician}, Vol. 50, No. 4, pp. 361-365

\end{itemize}
\textbf{Examples}


\begin{minted}{jlcon}
julia> x = [3, 2, 1];

julia> quantile!(x, 0.5)
2.0

julia> x
3-element Array{Int64,1}:
 1
 2
 3

julia> y = zeros(3);

julia> quantile!(y, x, [0.1, 0.5, 0.9]) === y
true

julia> y
3-element Array{Float64,1}:
 1.2
 2.0
 2.8
\end{minted}



\end{adjustwidth}
\hypertarget{1313193106257799062}{} 
\hyperlink{1313193106257799062}{\texttt{Statistics.quantile}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
quantile(itr, p; sorted=false)
\end{minted}

Compute the quantile(s) of a collection \texttt{itr} at a specified probability or vector or tuple of probabilities \texttt{p} on the interval [0,1]. The keyword argument \texttt{sorted} indicates whether \texttt{itr} can be assumed to be sorted.

Quantiles are computed via linear interpolation between the points \texttt{((k-1)/(n-1), v[k])}, for \texttt{k = 1:n} where \texttt{n = length(itr)}. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R default.

\begin{quote}
\textbf{Note}

An \texttt{ArgumentError} is thrown if \texttt{itr} contains \texttt{NaN} or \hyperlink{14596725676261444434}{\texttt{missing}} values. Use the \hyperlink{2012470681884771400}{\texttt{skipmissing}} function to omit \texttt{missing} entries and compute the quantiles of non-missing values.

\end{quote}
\begin{itemize}
\item Hyndman, R.J and Fan, Y. (1996) {\textquotedbl}Sample Quantiles in Statistical Packages{\textquotedbl}, \emph{The American Statistician}, Vol. 50, No. 4, pp. 361-365

\end{itemize}
\textbf{Examples}


\begin{minted}{jlcon}
julia> quantile(0:20, 0.5)
10.0

julia> quantile(0:20, [0.1, 0.5, 0.9])
3-element Array{Float64,1}:
  2.0
 10.0
 18.0

julia> quantile(skipmissing([1, 10, missing]), 0.5)
5.5
\end{minted}



\end{adjustwidth}



\hypertarget{17778253023886211260}{}


\chapter{单元测试}





\hypertarget{10440826130497106701}{}


\section{测试 Julia Base 库}



Julia is under rapid development and has an extensive test suite to verify functionality across multiple platforms. If you build Julia from source, you can run this test suite with \texttt{make test}. In a binary install, you can run the test suite using \texttt{Base.runtests()}.


\hypertarget{2272377293323848310}{} 
\hyperlink{2272377293323848310}{\texttt{Base.runtests}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.runtests(tests=["all"]; ncores=ceil(Int, Sys.CPU_THREADS / 2),
              exit_on_error=false, [seed])
\end{minted}

Run the Julia unit tests listed in \texttt{tests}, which can be either a string or an array of strings, using \texttt{ncores} processors. If \texttt{exit\_on\_error} is \texttt{false}, when one test fails, all remaining tests in other files will still be run; they are otherwise discarded, when \texttt{exit\_on\_error == true}. If a seed is provided via the keyword argument, it is used to seed the global RNG in the context where the tests are run; otherwise the seed is chosen randomly.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/util.jl#L811-L821}{\texttt{source}}


\end{adjustwidth}

\hypertarget{7988833292242463234}{}


\section{基本的单元测试}



The \texttt{Test} module provides simple \emph{unit testing} functionality. Unit testing is a way to see if your code is correct by checking that the results are what you expect. It can be helpful to ensure your code still works after you make changes, and can be used when developing as a way of specifying the behaviors your code should have when complete.



Simple unit testing can be performed with the \texttt{@test} and \texttt{@test\_throws} macros:


\hypertarget{1038355522981819767}{} 
\hyperlink{1038355522981819767}{\texttt{Test.@test}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@test ex
@test f(args...) key=val ...
\end{minted}

Tests that the expression \texttt{ex} evaluates to \texttt{true}. Returns a \texttt{Pass} \texttt{Result} if it does, a \texttt{Fail} \texttt{Result} if it is \texttt{false}, and an \texttt{Error} \texttt{Result} if it could not be evaluated.

\textbf{Examples}


\begin{minted}{jlcon}
julia> @test true
Test Passed

julia> @test [1, 2] + [2, 1] == [3, 3]
Test Passed
\end{minted}

The \texttt{@test f(args...) key=val...} form is equivalent to writing \texttt{@test f(args..., key=val...)} which can be useful when the expression is a call using infix syntax such as approximate comparisons:


\begin{minted}{jlcon}
julia> @test π ≈ 3.14 atol=0.01
Test Passed
\end{minted}

This is equivalent to the uglier test \texttt{@test ≈(π, 3.14, atol=0.01)}. It is an error to supply more than one expression unless the first is a call expression and the rest are assignments (\texttt{k=v}).



\end{adjustwidth}
\hypertarget{5527166796157013832}{} 
\hyperlink{5527166796157013832}{\texttt{Test.@test\_throws}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@test_throws exception expr
\end{minted}

Tests that the expression \texttt{expr} throws \texttt{exception}. The exception may specify either a type, or a value (which will be tested for equality by comparing fields). Note that \texttt{@test\_throws} does not support a trailing keyword form.

\textbf{Examples}


\begin{minted}{jlcon}
julia> @test_throws BoundsError [1, 2, 3][4]
Test Passed
      Thrown: BoundsError

julia> @test_throws DimensionMismatch [1, 2, 3] + [1, 2]
Test Passed
      Thrown: DimensionMismatch
\end{minted}



\end{adjustwidth}

For example, suppose we want to check our new function \texttt{foo(x)} works as expected:




\begin{minted}{jlcon}
julia> using Test

julia> foo(x) = length(x)^2
foo (generic function with 1 method)
\end{minted}



如果条件为真，则返回 \texttt{Pass}：




\begin{minted}{jlcon}
julia> @test foo("bar") == 9
Test Passed

julia> @test foo("fizz") >= 10
Test Passed
\end{minted}



如果条件为假，则返回 \texttt{Fail} 并抛出异常。




\begin{minted}{jlcon}
julia> @test foo("f") == 20
Test Failed at none:1
  Expression: foo("f") == 20
   Evaluated: 1 == 20
ERROR: There was an error during testing
\end{minted}



If the condition could not be evaluated because an exception was thrown, which occurs in this case because \texttt{length} is not defined for symbols, an \texttt{Error} object is returned and an exception is thrown:




\begin{minted}{jlcon}
julia> @test foo(:cat) == 1
Error During Test
  Test threw an exception of type MethodError
  Expression: foo(:cat) == 1
  MethodError: no method matching length(::Symbol)
  Closest candidates are:
    length(::SimpleVector) at essentials.jl:256
    length(::Base.MethodList) at reflection.jl:521
    length(::MethodTable) at reflection.jl:597
    ...
  Stacktrace:
  [...]
ERROR: There was an error during testing
\end{minted}



If we expect that evaluating an expression \emph{should} throw an exception, then we can use \texttt{@test\_throws} to check that this occurs:




\begin{minted}{jlcon}
julia> @test_throws MethodError foo(:cat)
Test Passed
      Thrown: MethodError
\end{minted}



\hypertarget{12305239832165996459}{}


\section{Working with Test Sets}



Typically a large number of tests are used to make sure functions work correctly over a range of inputs. In the event a test fails, the default behavior is to throw an exception immediately. However, it is normally preferable to run the rest of the tests first to get a better picture of how many errors there are in the code being tested.



The \texttt{@testset} macro can be used to group tests into \emph{sets}. All the tests in a test set will be run, and at the end of the test set a summary will be printed. If any of the tests failed, or could not be evaluated due to an error, the test set will then throw a \texttt{TestSetException}.


\hypertarget{6603917731228482697}{} 
\hyperlink{6603917731228482697}{\texttt{Test.@testset}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@testset [CustomTestSet] [option=val  ...] ["description"] begin ... end
@testset [CustomTestSet] [option=val  ...] ["description $v"] for v in (...) ... end
@testset [CustomTestSet] [option=val  ...] ["description $v, $w"] for v in (...), w in (...) ... end
\end{minted}

Starts a new test set, or multiple test sets if a \texttt{for} loop is provided.

If no custom testset type is given it defaults to creating a \texttt{DefaultTestSet}. \texttt{DefaultTestSet} records all the results and, if there are any \texttt{Fail}s or \texttt{Error}s, throws an exception at the end of the top-level (non-nested) test set, along with a summary of the test results.

Any custom testset type (subtype of \texttt{AbstractTestSet}) can be given and it will also be used for any nested \texttt{@testset} invocations. The given options are only applied to the test set where they are given. The default test set type does not take any options.

The description string accepts interpolation from the loop indices. If no description is provided, one is constructed based on the variables.

By default the \texttt{@testset} macro will return the testset object itself, though this behavior can be customized in other testset types. If a \texttt{for} loop is used then the macro collects and returns a list of the return values of the \texttt{finish} method, which by default will return a list of the testset objects used in each iteration.

Before the execution of the body of a \texttt{@testset}, there is an implicit call to \texttt{Random.seed!(seed)} where \texttt{seed} is the current seed of the global RNG. Moreover, after the execution of the body, the state of the global RNG is restored to what it was before the \texttt{@testset}. This is meant to ease reproducibility in case of failure, and to allow seamless re-arrangements of \texttt{@testset}s regardless of their side-effect on the global RNG state.

\textbf{Examples}


\begin{minted}{jlcon}
julia> @testset "trigonometric identities" begin
           θ = 2/3*π
           @test sin(-θ) ≈ -sin(θ)
           @test cos(-θ) ≈ cos(θ)
           @test sin(2θ) ≈ 2*sin(θ)*cos(θ)
           @test cos(2θ) ≈ cos(θ)^2 - sin(θ)^2
       end;
Test Summary:            | Pass  Total
trigonometric identities |    4      4
\end{minted}



\end{adjustwidth}

We can put our tests for the \texttt{foo(x)} function in a test set:




\begin{minted}{jlcon}
julia> @testset "Foo Tests" begin
           @test foo("a")   == 1
           @test foo("ab")  == 4
           @test foo("abc") == 9
       end;
Test Summary: | Pass  Total
Foo Tests     |    3      3
\end{minted}



测试集可以嵌套：




\begin{minted}{jlcon}
julia> @testset "Foo Tests" begin
           @testset "Animals" begin
               @test foo("cat") == 9
               @test foo("dog") == foo("cat")
           end
           @testset "Arrays $i" for i in 1:3
               @test foo(zeros(i)) == i^2
               @test foo(fill(1.0, i)) == i^2
           end
       end;
Test Summary: | Pass  Total
Foo Tests     |    8      8
\end{minted}



In the event that a nested test set has no failures, as happened here, it will be hidden in the summary. If we do have a test failure, only the details for the failed test sets will be shown:




\begin{minted}{jlcon}
julia> @testset "Foo Tests" begin
           @testset "Animals" begin
               @testset "Felines" begin
                   @test foo("cat") == 9
               end
               @testset "Canines" begin
                   @test foo("dog") == 9
               end
           end
           @testset "Arrays" begin
               @test foo(zeros(2)) == 4
               @test foo(fill(1.0, 4)) == 15
           end
       end

Arrays: Test Failed
  Expression: foo(fill(1.0, 4)) == 15
   Evaluated: 16 == 15
[...]
Test Summary: | Pass  Fail  Total
Foo Tests     |    3     1      4
  Animals     |    2            2
  Arrays      |    1     1      2
ERROR: Some tests did not pass: 3 passed, 1 failed, 0 errored, 0 broken.
\end{minted}



\hypertarget{13684669007939877444}{}


\section{其他测试宏}



As calculations on floating-point values can be imprecise, you can perform approximate equality checks using either \texttt{@test a ≈ b} (where \texttt{≈}, typed via tab completion of \texttt{{\textbackslash}approx}, is the \hyperlink{12499503887608197213}{\texttt{isapprox}} function) or use \hyperlink{12499503887608197213}{\texttt{isapprox}} directly.




\begin{minted}{jlcon}
julia> @test 1 ≈ 0.999999999
Test Passed

julia> @test 1 ≈ 0.999999
Test Failed at none:1
  Expression: 1 ≈ 0.999999
   Evaluated: 1 ≈ 0.999999
ERROR: There was an error during testing
\end{minted}


\hypertarget{14660196658788499514}{} 
\hyperlink{14660196658788499514}{\texttt{Test.@inferred}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@inferred [AllowedType] f(x)
\end{minted}

Tests that the call expression \texttt{f(x)} returns a value of the same type inferred by the compiler. It is useful to check for type stability.

\texttt{f(x)} can be any call expression. Returns the result of \texttt{f(x)} if the types match, and an \texttt{Error} \texttt{Result} if it finds different types.

Optionally, \texttt{AllowedType} relaxes the test, by making it pass when either the type of \texttt{f(x)} matches the inferred type modulo \texttt{AllowedType}, or when the return type is a subtype of \texttt{AllowedType}. This is useful when testing type stability of functions returning a small union such as \texttt{Union\{Nothing, T\}} or \texttt{Union\{Missing, T\}}.


\begin{minted}{jlcon}
julia> f(a) = a > 1 ? 1 : 1.0
f (generic function with 1 method)

julia> typeof(f(2))
Int64

julia> @code_warntype f(2)
Variables
  #self#::Core.Compiler.Const(f, false)
  a::Int64

Body::UNION{FLOAT64, INT64}
1 ─ %1 = (a > 1)::Bool
└──      goto #3 if not %1
2 ─      return 1
3 ─      return 1.0

julia> @inferred f(2)
ERROR: return type Int64 does not match inferred return type Union{Float64, Int64}
[...]

julia> @inferred max(1, 2)
2

julia> g(a) = a < 10 ? missing : 1.0
g (generic function with 1 method)

julia> @inferred g(20)
ERROR: return type Float64 does not match inferred return type Union{Missing, Float64}
[...]

julia> @inferred Missing g(20)
1.0

julia> h(a) = a < 10 ? missing : f(a)
h (generic function with 1 method)

julia> @inferred Missing h(20)
ERROR: return type Int64 does not match inferred return type Union{Missing, Float64, Int64}
[...]
\end{minted}



\end{adjustwidth}
\hypertarget{1395021091279173086}{} 
\hyperlink{1395021091279173086}{\texttt{Test.@test\_logs}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@test_logs [log_patterns...] [keywords] expression
\end{minted}

Collect a list of log records generated by \texttt{expression} using \texttt{collect\_test\_logs}, check that they match the sequence \texttt{log\_patterns}, and return the value of \texttt{expression}.  The \texttt{keywords} provide some simple filtering of log records: the \texttt{min\_level} keyword controls the minimum log level which will be collected for the test, the \texttt{match\_mode} keyword defines how matching will be performed (the default \texttt{:all} checks that all logs and patterns match pairwise; use \texttt{:any} to check that the pattern matches at least once somewhere in the sequence.)

The most useful log pattern is a simple tuple of the form \texttt{(level,message)}. A different number of tuple elements may be used to match other log metadata, corresponding to the arguments to passed to \texttt{AbstractLogger} via the \texttt{handle\_message} function: \texttt{(level,message,module,group,id,file,line)}. Elements which are present will be matched pairwise with the log record fields using \texttt{==} by default, with the special cases that \texttt{Symbol}s may be used for the standard log levels, and \texttt{Regex}s in the pattern will match string or Symbol fields using \texttt{occursin}.

\textbf{Examples}

Consider a function which logs a warning, and several debug messages:


\begin{lstlisting}
function foo(n)
    @info "Doing foo with n=$n"
    for i=1:n
        @debug "Iteration $i"
    end
    42
end
\end{lstlisting}

We can test the info message using


\begin{lstlisting}
@test_logs (:info,"Doing foo with n=2") foo(2)
\end{lstlisting}

If we also wanted to test the debug messages, these need to be enabled with the \texttt{min\_level} keyword:


\begin{lstlisting}
@test_logs (:info,"Doing foo with n=2") (:debug,"Iteration 1") (:debug,"Iteration 2") min_level=Debug foo(2)
\end{lstlisting}

If you want to test that some particular messages are generated while ignoring the rest, you can set the keyword \texttt{match\_mode=:any}:


\begin{lstlisting}
@test_logs (:info,) (:debug,"Iteration 42") min_level=Debug match_mode=:any foo(100)
\end{lstlisting}

The macro may be chained with \texttt{@test} to also test the returned value:


\begin{lstlisting}
@test (@test_logs (:info,"Doing foo with n=2") foo(2)) == 42
\end{lstlisting}



\end{adjustwidth}
\hypertarget{3450176127005416215}{} 
\hyperlink{3450176127005416215}{\texttt{Test.@test\_deprecated}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@test_deprecated [pattern] expression
\end{minted}

When \texttt{--depwarn=yes}, test that \texttt{expression} emits a deprecation warning and return the value of \texttt{expression}.  The log message string will be matched against \texttt{pattern} which defaults to \texttt{r{\textquotedbl}deprecated{\textquotedbl}i}.

When \texttt{--depwarn=no}, simply return the result of executing \texttt{expression}.  When \texttt{--depwarn=error}, check that an ErrorException is thrown.

\textbf{Examples}


\begin{lstlisting}
# Deprecated in julia 0.7
@test_deprecated num2hex(1)

# The returned value can be tested by chaining with @test:
@test (@test_deprecated num2hex(1)) == "0000000000000001"
\end{lstlisting}



\end{adjustwidth}
\hypertarget{12478857733960407392}{} 
\hyperlink{12478857733960407392}{\texttt{Test.@test\_warn}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@test_warn msg expr
\end{minted}

Test whether evaluating \texttt{expr} results in \hyperlink{6150355911915549172}{\texttt{stderr}} output that contains the \texttt{msg} string or matches the \texttt{msg} regular expression.  If \texttt{msg} is a boolean function, tests whether \texttt{msg(output)} returns \texttt{true}.  If \texttt{msg} is a tuple or array, checks that the error output contains/matches each item in \texttt{msg}. Returns the result of evaluating \texttt{expr}.

See also \hyperlink{14168562674427079535}{\texttt{@test\_nowarn}} to check for the absence of error output.

Note: Warnings generated by \texttt{@warn} cannot be tested with this macro. Use \texttt{@test\_logs} instead.



\end{adjustwidth}
\hypertarget{14168562674427079535}{} 
\hyperlink{14168562674427079535}{\texttt{Test.@test\_nowarn}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@test_nowarn expr
\end{minted}

Test whether evaluating \texttt{expr} results in empty \hyperlink{6150355911915549172}{\texttt{stderr}} output (no warnings or other messages).  Returns the result of evaluating \texttt{expr}.

Note: The absence of warnings generated by \texttt{@warn} cannot be tested with this macro. Use \texttt{@test\_logs expr} instead.



\end{adjustwidth}

\hypertarget{17956725815872473676}{}


\section{损坏的测试}



If a test fails consistently it can be changed to use the \texttt{@test\_broken} macro. This will denote the test as \texttt{Broken} if the test continues to fail and alerts the user via an \texttt{Error} if the test succeeds.


\hypertarget{5668051953647432783}{} 
\hyperlink{5668051953647432783}{\texttt{Test.@test\_broken}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@test_broken ex
@test_broken f(args...) key=val ...
\end{minted}

Indicates a test that should pass but currently consistently fails. Tests that the expression \texttt{ex} evaluates to \texttt{false} or causes an exception. Returns a \texttt{Broken} \texttt{Result} if it does, or an \texttt{Error} \texttt{Result} if the expression evaluates to \texttt{true}.

The \texttt{@test\_broken f(args...) key=val...} form works as for the \texttt{@test} macro.

\textbf{Examples}


\begin{minted}{jlcon}
julia> @test_broken 1 == 2
Test Broken
  Expression: 1 == 2

julia> @test_broken 1 == 2 atol=0.1
Test Broken
  Expression: ==(1, 2, atol = 0.1)
\end{minted}



\end{adjustwidth}

\texttt{@test\_skip} is also available to skip a test without evaluation, but counting the skipped test in the test set reporting. The test will not run but gives a \texttt{Broken} \texttt{Result}.


\hypertarget{612751920735042674}{} 
\hyperlink{612751920735042674}{\texttt{Test.@test\_skip}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@test_skip ex
@test_skip f(args...) key=val ...
\end{minted}

Marks a test that should not be executed but should be included in test summary reporting as \texttt{Broken}. This can be useful for tests that intermittently fail, or tests of not-yet-implemented functionality.

The \texttt{@test\_skip f(args...) key=val...} form works as for the \texttt{@test} macro.

\textbf{Examples}


\begin{minted}{jlcon}
julia> @test_skip 1 == 2
Test Broken
  Skipped: 1 == 2

julia> @test_skip 1 == 2 atol=0.1
Test Broken
  Skipped: ==(1, 2, atol = 0.1)
\end{minted}



\end{adjustwidth}

\hypertarget{641042127845318623}{}


\section{自定义 \texttt{AbstractTestSet} 类型}



Packages can create their own \texttt{AbstractTestSet} subtypes by implementing the \texttt{record} and \texttt{finish} methods. The subtype should have a one-argument constructor taking a description string, with any options passed in as keyword arguments.


\hypertarget{5358474705981864018}{} 
\hyperlink{5358474705981864018}{\texttt{Test.record}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
record(ts::AbstractTestSet, res::Result)
\end{minted}

Record a result to a testset. This function is called by the \texttt{@testset} infrastructure each time a contained \texttt{@test} macro completes, and is given the test result (which could be an \texttt{Error}). This will also be called with an \texttt{Error} if an exception is thrown inside the test block but outside of a \texttt{@test} context.



\end{adjustwidth}
\hypertarget{3045207246411142824}{} 
\hyperlink{3045207246411142824}{\texttt{Test.finish}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
finish(ts::AbstractTestSet)
\end{minted}

Do any final processing necessary for the given testset. This is called by the \texttt{@testset} infrastructure after a test block executes. One common use for this function is to record the testset to the parent{\textquotesingle}s results list, using \texttt{get\_testset}.



\end{adjustwidth}

\texttt{Test} takes responsibility for maintaining a stack of nested testsets as they are executed, but any result accumulation is the responsibility of the \texttt{AbstractTestSet} subtype. You can access this stack with the \texttt{get\_testset} and \texttt{get\_testset\_depth} methods. Note that these functions are not exported.


\hypertarget{16535119297156519849}{} 
\hyperlink{16535119297156519849}{\texttt{Test.get\_testset}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
get_testset()
\end{minted}

Retrieve the active test set from the task{\textquotesingle}s local storage. If no test set is active, use the fallback default test set.



\end{adjustwidth}
\hypertarget{6664474132755078304}{} 
\hyperlink{6664474132755078304}{\texttt{Test.get\_testset\_depth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
get_testset_depth()
\end{minted}

Returns the number of active test sets, not including the default test set



\end{adjustwidth}

\texttt{Test} also makes sure that nested \texttt{@testset} invocations use the same \texttt{AbstractTestSet} subtype as their parent unless it is set explicitly. It does not propagate any properties of the testset. Option inheritance behavior can be implemented by packages using the stack infrastructure that \texttt{Test} provides.



定义一个基本的 \texttt{AbstractTestSet} 子类：




\begin{minted}{julia}
import Test: Test, record, finish
using Test: AbstractTestSet, Result, Pass, Fail, Error
using Test: get_testset_depth, get_testset
struct CustomTestSet <: Test.AbstractTestSet
    description::AbstractString
    foo::Int
    results::Vector
    # constructor takes a description string and options keyword arguments
    CustomTestSet(desc; foo=1) = new(desc, foo, [])
end

record(ts::CustomTestSet, child::AbstractTestSet) = push!(ts.results, child)
record(ts::CustomTestSet, res::Result) = push!(ts.results, res)
function finish(ts::CustomTestSet)
    # just record if we're not the top-level parent
    if get_testset_depth() > 0
        record(get_testset(), ts)
    end
    ts
end
\end{minted}



使用测试集：




\begin{minted}{julia}
@testset CustomTestSet foo=4 "custom testset inner 2" begin
    # this testset should inherit the type, but not the argument.
    @testset "custom testset inner" begin
        @test true
    end
end
\end{minted}





\hypertarget{2767829618755343548}{}


\chapter{UUIDs}


\hypertarget{16892127995397163681}{} 
\hyperlink{16892127995397163681}{\texttt{UUIDs.uuid1}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
uuid1([rng::AbstractRNG=GLOBAL_RNG]) -> UUID
\end{minted}

Generates a version 1 (time-based) universally unique identifier (UUID), as specified by RFC 4122. Note that the Node ID is randomly generated (does not identify the host) according to section 4.5 of the RFC.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> uuid1(rng)
UUID("cfc395e8-590f-11e8-1f13-43a2532b2fa8")
\end{minted}



\end{adjustwidth}
\hypertarget{15125074142528432744}{} 
\hyperlink{15125074142528432744}{\texttt{UUIDs.uuid4}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
uuid4([rng::AbstractRNG=GLOBAL_RNG]) -> UUID
\end{minted}

Generates a version 4 (random or pseudo-random) universally unique identifier (UUID), as specified by RFC 4122.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> uuid4(rng)
UUID("196f2941-2d58-45ba-9f13-43a2532b2fa8")
\end{minted}



\end{adjustwidth}
\hypertarget{16798189732863707215}{} 
\hyperlink{16798189732863707215}{\texttt{UUIDs.uuid5}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
uuid5(ns::UUID, name::String) -> UUID
\end{minted}

Generates a version 5 (namespace and domain-based) universally unique identifier (UUID), as specified by RFC 4122.

\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> u4 = uuid4(rng)
UUID("196f2941-2d58-45ba-9f13-43a2532b2fa8")

julia> u5 = uuid5(u4, "julia")
UUID("b37756f8-b0c0-54cd-a466-19b3d25683bc")
\end{minted}



\end{adjustwidth}
\hypertarget{2328416264059500569}{} 
\hyperlink{2328416264059500569}{\texttt{UUIDs.uuid\_version}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
uuid_version(u::UUID) -> Int
\end{minted}

Inspects the given UUID and returns its version (see \href{https://www.ietf.org/rfc/rfc4122}{RFC 4122}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> uuid_version(uuid4())
4
\end{minted}



\end{adjustwidth}

\hypertarget{1111253146082274876}{}


\chapter{Unicode}


\hypertarget{3408928680045716107}{} 
\hyperlink{3408928680045716107}{\texttt{Unicode.isassigned}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Unicode.isassigned(c) -> Bool
\end{minted}

Returns \texttt{true} if the given char or integer is an assigned Unicode code point.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Unicode.isassigned(101)
true

julia> Unicode.isassigned('\x01')
true
\end{minted}



\end{adjustwidth}
\hypertarget{6168731775693095830}{} 
\hyperlink{6168731775693095830}{\texttt{Unicode.normalize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Unicode.normalize(s::AbstractString, normalform::Symbol)
\end{minted}

Normalize the string \texttt{s} according to one of the four {\textquotedbl}normal forms{\textquotedbl} of the Unicode standard: \texttt{normalform} can be \texttt{:NFC}, \texttt{:NFD}, \texttt{:NFKC}, or \texttt{:NFKD}.  Normal forms C (canonical composition) and D (canonical decomposition) convert different visually identical representations of the same abstract string into a single canonical form, with form C being more compact.  Normal forms KC and KD additionally canonicalize {\textquotedbl}compatibility equivalents{\textquotedbl}: they convert characters that are abstractly similar but visually distinct into a single canonical choice (e.g. they expand ligatures into the individual characters), with form KC being more compact.

Alternatively, finer control and additional transformations may be be obtained by calling \texttt{Unicode.normalize(s; keywords...)}, where any number of the following boolean keywords options (which all default to \texttt{false} except for \texttt{compose}) are specified:

\begin{itemize}
\item \texttt{compose=false}: do not perform canonical composition


\item \texttt{decompose=true}: do canonical decomposition instead of canonical composition (\texttt{compose=true} is ignored if present)


\item \texttt{compat=true}: compatibility equivalents are canonicalized


\item \texttt{casefold=true}: perform Unicode case folding, e.g. for case-insensitive string comparison


\item \texttt{newline2lf=true}, \texttt{newline2ls=true}, or \texttt{newline2ps=true}: convert various newline sequences (LF, CRLF, CR, NEL) into a linefeed (LF), line-separation (LS), or paragraph-separation (PS) character, respectively


\item \texttt{stripmark=true}: strip diacritical marks (e.g. accents)


\item \texttt{stripignore=true}: strip Unicode{\textquotesingle}s {\textquotedbl}default ignorable{\textquotedbl} characters (e.g. the soft hyphen or the left-to-right marker)


\item \texttt{stripcc=true}: strip control characters; horizontal tabs and form feeds are converted to spaces; newlines are also converted to spaces unless a newline-conversion flag was specified


\item \texttt{rejectna=true}: throw an error if unassigned code points are found


\item \texttt{stable=true}: enforce Unicode Versioning Stability

\end{itemize}
For example, NFKC corresponds to the options \texttt{compose=true, compat=true, stable=true}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> "μ" == Unicode.normalize("µ", compat=true) #LHS: Unicode U+03bc, RHS: Unicode U+00b5
true

julia> Unicode.normalize("JuLiA", casefold=true)
"julia"

julia> Unicode.normalize("JúLiA", stripmark=true)
"JuLiA"
\end{minted}



\end{adjustwidth}
\hypertarget{15282403158595139101}{} 
\hyperlink{15282403158595139101}{\texttt{Unicode.graphemes}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
graphemes(s::AbstractString) -> GraphemeIterator
\end{minted}

Returns an iterator over substrings of \texttt{s} that correspond to the extended graphemes in the string, as defined by Unicode UAX \#29. (Roughly, these are what users would perceive as single characters, even though they may contain more than one codepoint; for example a letter combined with an accent mark is a single grapheme.)



\end{adjustwidth}

\part{Developer Documentation}


\hypertarget{10788491312865149564}{}


\chapter{反射 与 自我检查}



Julia 提供了多种运行时的反射功能。



\hypertarget{14842331990094437788}{}


\section{模块绑定}



由 \texttt{Module} 导出的名称可用 \hyperlink{6473328671144201991}{\texttt{names(m::Module)}} 获得，它会返回一个元素为 \hyperlink{18332791376992528422}{\texttt{Symbol}} 的数组来表示模块导出的绑定。不管导出状态如何，\texttt{names(m::Module, all = true)} 返回 \texttt{m} 中所有绑定的符号。



\hypertarget{3191587172542435875}{}


\section{DateType 字段}



\texttt{DataType} 的所有字段名称可以使用 \hyperlink{17481253338332315021}{\texttt{fieldnames}} 来获取。例如，对于下面给定的类型，\texttt{fieldnames(Point)} 会返回一个表示字段名称的 \hyperlink{18332791376992528422}{\texttt{Symbol}} 元组：




\begin{minted}{jlcon}
julia> struct Point
           x::Int
           y
       end

julia> fieldnames(Point)
(:x, :y)
\end{minted}



\texttt{Point} 对象中每个字段的类型存储在 \texttt{Point} 本身的 \texttt{types} 变量中：




\begin{minted}{jlcon}
julia> Point.types
svec(Int64, Any)
\end{minted}



虽然 \texttt{x} 被注释为 \texttt{Int}，但 \texttt{y} 在类型定义里没有注释，因此 \texttt{y} 默认为 \texttt{Any} 类型。



类型本身表示为一个叫做 \texttt{DataType} 的结构：




\begin{minted}{jlcon}
julia> typeof(Point)
DataType
\end{minted}



注意 \texttt{fieldnames(DataType)} 给出了 \texttt{DataType} 本身的每个字段的名称，其中的一个字段是上面示例中提到的 \texttt{types} 字段。



\hypertarget{13277644863207512265}{}


\section{子类型}



任何 \texttt{DataType} 的\emph{直接}子类型都可以通过使用 \hyperlink{13112219412833772146}{\texttt{subtypes}} 来列出。 例如抽象 \texttt{DataType} \hyperlink{11465394427882483091}{\texttt{AbstractFloat}} 有四个（具体的）子类型：




\begin{minted}{jlcon}
julia> subtypes(AbstractFloat)
4-element Array{Any,1}:
 BigFloat
 Float16
 Float32
 Float64
\end{minted}



任何抽象子类型也包括此列表中，但子类型的子类型不在其中。递归使用 \hyperlink{13112219412833772146}{\texttt{subtypes}} 可以遍历出整个类型树。



\hypertarget{7724659828636149961}{}


\section{DataType 布局}



用 C 代码接口时，\texttt{DataType} 的内部表现非常重要。有几个函数可以检查这些细节。



\hyperlink{12980593021531333073}{\texttt{isbits(T::DataType)}} 如果 \texttt{T} 类型是以 C 兼容的对齐方式存储，则为 true。    \hyperlink{6956980533195055227}{\texttt{fieldoffset(T::DataType, i::Integer)}} 返回字段 \emph{i} 相对于类型开始的 (字节) 偏移量。



\hypertarget{15829703883389410283}{}


\section{函数方法}



任何泛型函数的方法都可以使用 \hyperlink{3025953302266245919}{\texttt{methods}} 来列出。用 \hyperlink{1845157398882896709}{\texttt{methodswith}} 搜索 方法调度表 来查找 接收给定类型的方法。



\hypertarget{12369440035598215363}{}


\section{扩展和更底层}



As discussed in the \href{@ref}{Metaprogramming} section, the \hyperlink{8018172489611994488}{\texttt{macroexpand}} function gives the unquoted and interpolated expression (\hyperlink{17120496304147995299}{\texttt{Expr}}) form for a given macro. To use \texttt{macroexpand}, \texttt{quote} the expression block itself (otherwise, the macro will be evaluated and the result will be passed instead!). For example:




\begin{minted}{jlcon}
julia> macroexpand(@__MODULE__, :(@edit println("")) )
:(InteractiveUtils.edit(println, (Base.typesof)("")))
\end{minted}



The functions \texttt{Base.Meta.show\_sexpr} and \hyperlink{15981569052160951906}{\texttt{dump}} are used to display S-expr style views and depth-nested detail views for any expression.



Finally, the \hyperlink{6644553029841096787}{\texttt{Meta.lower}} function gives the \texttt{lowered} form of any expression and is of particular interest for understanding how language constructs map to primitive operations such as assignments, branches, and calls:




\begin{minted}{jlcon}
julia> Meta.lower(@__MODULE__, :( [1+2, sin(0.5)] ))
:($(Expr(:thunk, CodeInfo(
    @ none within `top-level scope'
1 ─ %1 = 1 + 2
│   %2 = sin(0.5)
│   %3 = Base.vect(%1, %2)
└──      return %3
))))
\end{minted}



\hypertarget{12950313890789848047}{}


\section{中间表示和编译后表示}



检查函数的底层形式 需要选择所要显示的特定方法，因为泛型函数可能会有许多具有不同类型签名的方法。为此， 用 \hyperlink{18235967286596219009}{\texttt{code\_lowered}} 可以指定代码底层中的方法。 并且可以用  \hyperlink{14801595959157535515}{\texttt{code\_typed}} 来进行类型推断。 \hyperlink{5565852192659724503}{\texttt{code\_warntype}} 增加 \hyperlink{14801595959157535515}{\texttt{code\_typed}} 输出的高亮。



更加接近于机器， 一个函数的 LLVM-IR 可以通过使用 \hyperlink{1749471484368489435}{\texttt{code\_llvm}} 打印出。 最终编译的机器码使用 \hyperlink{2534314152947301270}{\texttt{code\_native}} 查看（这将触发 之前未调用过的任何函数的 JIT 编译/代码生成）。



为方便起见，上述函数有 宏的版本，它们接受标准函数调用并自动展开参数类型：




\begin{minted}{jlcon}
julia> @code_llvm +(1,1)

define i64 @"julia_+_130862"(i64, i64) {
top:
    %2 = add i64 %1, %0
    ret i64 %2
}
\end{minted}



For more informations see \hyperlink{1376948972689074219}{\texttt{@code\_lowered}}, \hyperlink{6823997547688846780}{\texttt{@code\_typed}}, \hyperlink{8092893264277772840}{\texttt{@code\_warntype}}, \hyperlink{18039596607712979441}{\texttt{@code\_llvm}}, and \hyperlink{2629340111434042067}{\texttt{@code\_native}}.



\hypertarget{4254640328057635583}{}


\subsection{Printing of debug information}



The aforementioned functions and macros take the keyword argument \texttt{debuginfo} that controls the level debug information printed.




\begin{lstlisting}
julia> @code_typed debuginfo=:source +(1,1)
CodeInfo(
    @ int.jl:53 within `+'
1 ─ %1 = Base.add_int(x, y)::Int64
└──      return %1
) => Int64
\end{lstlisting}



Possible values for \texttt{debuginfo} are: \texttt{:none}, \texttt{:source}, and\texttt{:default}. Per default debug information is not printed, but that can be changed by setting \texttt{Base.IRShow.default\_debuginfo[] = :source}.



\chapter{Documentation of Julia's Internals}


\hypertarget{4805065256470472206}{}


\section{Julia 运行时的初始化}



How does the Julia runtime execute \texttt{julia -e {\textquotesingle}println({\textquotedbl}Hello World!{\textquotedbl}){\textquotesingle}} ?



\hypertarget{6651980781302015874}{}


\subsection{\texttt{main()}}



Execution starts at \href{https://github.com/JuliaLang/julia/blob/master/ui/repl.c}{\texttt{main()} in \texttt{ui/repl.c}}.



\texttt{main()} calls \href{https://github.com/JuliaLang/julia/blob/master/src/support/libsupportinit.c}{\texttt{libsupport\_init()}} to set the C library locale and to initialize the {\textquotedbl}ios{\textquotedbl} library (see \href{https://github.com/JuliaLang/julia/blob/master/src/support/ios.c}{\texttt{ios\_init\_stdstreams()}} and \hyperlink{3841537160196121279}{Legacy \texttt{ios.c} library}).



Next \href{https://github.com/JuliaLang/julia/blob/master/src/jloptions.c}{\texttt{jl\_parse\_opts()}} is called to process command line options. Note that \texttt{jl\_parse\_opts()} only deals with options that affect code generation or early initialization. Other options are handled later by \href{https://github.com/JuliaLang/julia/blob/master/base/client.jl}{\texttt{process\_options()} in \texttt{base/client.jl}}.



\texttt{jl\_parse\_opts()} stores command line options in the \href{https://github.com/JuliaLang/julia/blob/master/src/julia.h}{global \texttt{jl\_options} struct}.



\hypertarget{10951200599627901176}{}


\subsection{\texttt{julia\_init()}}



\href{https://github.com/JuliaLang/julia/blob/master/src/task.c}{\texttt{julia\_init()} in \texttt{task.c}} is called by \texttt{main()} and calls \href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{\texttt{\_julia\_init()} in \texttt{init.c}}.



\texttt{\_julia\_init()} begins by calling \texttt{libsupport\_init()} again (it does nothing the second time).



\href{https://github.com/JuliaLang/julia/blob/master/src/signals-unix.c}{\texttt{restore\_signals()}} is called to zero the signal handler mask.



\href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{\texttt{jl\_resolve\_sysimg\_location()}} searches configured paths for the base system image. See \hyperlink{15513456349900674098}{Building the Julia system image}.



\href{https://github.com/JuliaLang/julia/blob/master/src/gc.c}{\texttt{jl\_gc\_init()}} sets up allocation pools and lists for weak refs, preserved values and finalization.



\href{https://github.com/JuliaLang/julia/blob/master/src/ast.c}{\texttt{jl\_init\_frontend()}} loads and initializes a pre-compiled femtolisp image containing the scanner/parser.



\href{https://github.com/JuliaLang/julia/blob/master/src/jltypes.c}{\texttt{jl\_init\_types()}} creates \texttt{jl\_datatype\_t} type description objects for the \href{https://github.com/JuliaLang/julia/blob/master/src/julia.h}{built-in types defined in \texttt{julia.h}}. e.g.




\begin{lstlisting}
jl_any_type = jl_new_abstracttype(jl_symbol("Any"), core, NULL, jl_emptysvec);
jl_any_type->super = jl_any_type;

jl_type_type = jl_new_abstracttype(jl_symbol("Type"), core, jl_any_type, jl_emptysvec);

jl_int32_type = jl_new_primitivetype(jl_symbol("Int32"), core,
                                     jl_any_type, jl_emptysvec, 32);
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/blob/master/src/task.c}{\texttt{jl\_init\_tasks()}} creates the \texttt{jl\_datatype\_t* jl\_task\_type} object; initializes the global \texttt{jl\_root\_task} struct; and sets \texttt{jl\_current\_task} to the root task.



\href{https://github.com/JuliaLang/julia/blob/master/src/codegen.cpp}{\texttt{jl\_init\_codegen()}} initializes the \href{http://llvm.org}{LLVM library}.



\href{https://github.com/JuliaLang/julia/blob/master/src/staticdata.c}{\texttt{jl\_init\_serializer()}} initializes 8-bit serialization tags for builtin \texttt{jl\_value\_t} values.



If there is no sysimg file (\texttt{!jl\_options.image\_file}) then the \texttt{Core} and \texttt{Main} modules are created and \texttt{boot.jl} is evaluated:



\texttt{jl\_core\_module = jl\_new\_module(jl\_symbol({\textquotedbl}Core{\textquotedbl}))} creates the Julia \texttt{Core} module.



\href{https://github.com/JuliaLang/julia/blob/master/src/intrinsics.cpp}{\texttt{jl\_init\_intrinsic\_functions()}} creates a new Julia module \texttt{Intrinsics} containing constant \texttt{jl\_intrinsic\_type} symbols. These define an integer code for each \href{https://github.com/JuliaLang/julia/blob/master/src/intrinsics.cpp}{intrinsic function}. \href{https://github.com/JuliaLang/julia/blob/master/src/intrinsics.cpp}{\texttt{emit\_intrinsic()}} translates these symbols into LLVM instructions during code generation.



\href{https://github.com/JuliaLang/julia/blob/master/src/builtins.c}{\texttt{jl\_init\_primitives()}} hooks C functions up to Julia function symbols. e.g. the symbol \texttt{Core.:(===)()} is bound to C function pointer \texttt{jl\_f\_is()} by calling \texttt{add\_builtin\_func({\textquotedbl}==={\textquotedbl}, jl\_f\_is)}.



\href{https://github.com/JuliaLang/julia/blob/master/src/toplevel.c}{\texttt{jl\_new\_main\_module()}} creates the global {\textquotedbl}Main{\textquotedbl} module and sets \texttt{jl\_current\_task->current\_module = jl\_main\_module}.



Note: \texttt{\_julia\_init()} \href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{then sets} \texttt{jl\_root\_task->current\_module = jl\_core\_module}. \texttt{jl\_root\_task} is an alias of \texttt{jl\_current\_task} at this point, so the \texttt{current\_module} set by \texttt{jl\_new\_main\_module()} above is overwritten.



\href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{\texttt{jl\_load({\textquotedbl}boot.jl{\textquotedbl}, sizeof({\textquotedbl}boot.jl{\textquotedbl}))}} calls \href{https://github.com/JuliaLang/julia/blob/master/src/ast.c}{\texttt{jl\_parse\_eval\_all}} which repeatedly calls \href{https://github.com/JuliaLang/julia/blob/master/src/toplevel.c}{\texttt{jl\_toplevel\_eval\_flex()}} to execute \href{https://github.com/JuliaLang/julia/blob/master/base/boot.jl}{\texttt{boot.jl}}. <!– TODO – drill down into eval? –>



\href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{\texttt{jl\_get\_builtin\_hooks()}} initializes global C pointers to Julia globals defined in \texttt{boot.jl}.



\href{https://github.com/JuliaLang/julia/blob/master/src/datatype.c}{\texttt{jl\_init\_box\_caches()}} pre-allocates global boxed integer value objects for values up to 1024. This speeds up allocation of boxed ints later on. e.g.:




\begin{lstlisting}
jl_value_t *jl_box_uint8(uint32_t x)
{
    return boxed_uint8_cache[(uint8_t)x];
}
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{\texttt{\_julia\_init()} iterates} over the \texttt{jl\_core\_module->bindings.table} looking for \texttt{jl\_datatype\_t} values and sets the type name{\textquotesingle}s module prefix to \texttt{jl\_core\_module}.



\href{https://github.com/JuliaLang/julia/blob/master/src/toplevel.c}{\texttt{jl\_add\_standard\_imports(jl\_main\_module)}} does {\textquotedbl}using Base{\textquotedbl} in the {\textquotedbl}Main{\textquotedbl} module.



Note: \texttt{\_julia\_init()} now reverts to \texttt{jl\_root\_task->current\_module = jl\_main\_module} as it was before being set to \texttt{jl\_core\_module} above.



Platform specific signal handlers are initialized for \texttt{SIGSEGV} (OSX, Linux), and \texttt{SIGFPE} (Windows).



Other signals (\texttt{SIGINFO, SIGBUS, SIGILL, SIGTERM, SIGABRT, SIGQUIT, SIGSYS} and \texttt{SIGPIPE}) are hooked up to \href{https://github.com/JuliaLang/julia/blob/master/src/signals-unix.c}{\texttt{sigdie\_handler()}} which prints a backtrace.



\href{https://github.com/JuliaLang/julia/blob/master/src/staticdata.c}{\texttt{jl\_init\_restored\_modules()}} calls \href{https://github.com/JuliaLang/julia/blob/master/src/module.c}{\texttt{jl\_module\_run\_initializer()}} for each deserialized module to run the \texttt{\_\_init\_\_()} function.



Finally \href{https://github.com/JuliaLang/julia/blob/master/src/signals-unix.c}{\texttt{sigint\_handler()}} is hooked up to \texttt{SIGINT} and calls \texttt{jl\_throw(jl\_interrupt\_exception)}.



\texttt{\_julia\_init()} then returns \href{https://github.com/JuliaLang/julia/blob/master/ui/repl.c}{back to \texttt{main()} in \texttt{ui/repl.c}} and \texttt{main()} calls \texttt{true\_main(argc, (char**)argv)}.



\begin{quote}
\textbf{sysimg}

If there is a sysimg file, it contains a pre-cooked image of the \texttt{Core} and \texttt{Main} modules (and whatever else is created by \texttt{boot.jl}). See \hyperlink{15513456349900674098}{Building the Julia system image}.

\href{https://github.com/JuliaLang/julia/blob/master/src/staticdata.c}{\texttt{jl\_restore\_system\_image()}} deserializes the saved sysimg into the current Julia runtime environment and initialization continues after \texttt{jl\_init\_box\_caches()} below...

Note: \href{https://github.com/JuliaLang/julia/blob/master/src/staticdata.c}{\texttt{jl\_restore\_system\_image()} (and \texttt{staticdata.c} in general)} uses the \hyperlink{3841537160196121279}{Legacy \texttt{ios.c} library}.

\end{quote}


\hypertarget{8052465870854670365}{}


\subsection{\texttt{true\_main()}}



\href{https://github.com/JuliaLang/julia/blob/master/ui/repl.c}{\texttt{true\_main()}} loads the contents of \texttt{argv[]} into \hyperlink{2567473177880607455}{\texttt{Base.ARGS}}.



If a \texttt{.jl} {\textquotedbl}program{\textquotedbl} file was supplied on the command line, then \href{https://github.com/JuliaLang/julia/blob/master/ui/repl.c}{\texttt{exec\_program()}} calls \href{https://github.com/JuliaLang/julia/blob/master/src/toplevel.c}{\texttt{jl\_load(program,len)}} which calls \href{https://github.com/JuliaLang/julia/blob/master/src/ast.c}{\texttt{jl\_parse\_eval\_all}} which repeatedly calls \href{https://github.com/JuliaLang/julia/blob/master/src/toplevel.c}{\texttt{jl\_toplevel\_eval\_flex()}} to execute the program.



However, in our example (\texttt{julia -e {\textquotesingle}println({\textquotedbl}Hello World!{\textquotedbl}){\textquotesingle}}), \href{https://github.com/JuliaLang/julia/blob/master/src/module.c}{\texttt{jl\_get\_global(jl\_base\_module, jl\_symbol({\textquotedbl}\_start{\textquotedbl}))}} looks up \href{https://github.com/JuliaLang/julia/blob/master/base/client.jl}{\texttt{Base.\_start}} and \href{https://github.com/JuliaLang/julia/blob/master/src/julia.h}{\texttt{jl\_apply()}} executes it.



\hypertarget{12561163861893339364}{}


\subsection{\texttt{Base.\_start}}



\href{https://github.com/JuliaLang/julia/blob/master/base/client.jl}{\texttt{Base.\_start}} calls \href{https://github.com/JuliaLang/julia/blob/master/base/client.jl}{\texttt{Base.process\_options}} which calls \href{https://github.com/JuliaLang/julia/blob/master/src/ast.c}{\texttt{jl\_parse\_input\_line({\textquotedbl}println({\textquotedbl}Hello World!{\textquotedbl}){\textquotedbl})}} to create an expression object and \hyperlink{7507639810592563424}{\texttt{Base.eval()}} to execute it.



\hypertarget{5161519074100035363}{}


\subsection{\texttt{Base.eval}}



\hyperlink{7507639810592563424}{\texttt{Base.eval()}} was \href{https://github.com/JuliaLang/julia/blob/master/src/builtins.c}{mapped to \texttt{jl\_f\_top\_eval}} by \texttt{jl\_init\_primitives()}.



\href{https://github.com/JuliaLang/julia/blob/master/src/builtins.c}{\texttt{jl\_f\_top\_eval()}} calls \href{https://github.com/JuliaLang/julia/blob/master/src/builtins.c}{\texttt{jl\_toplevel\_eval\_in(jl\_main\_module, ex)}}, where \texttt{ex} is the parsed expression \texttt{println({\textquotedbl}Hello World!{\textquotedbl})}.



\href{https://github.com/JuliaLang/julia/blob/master/src/builtins.c}{\texttt{jl\_toplevel\_eval\_in()}} calls \href{https://github.com/JuliaLang/julia/blob/master/src/toplevel.c}{\texttt{jl\_toplevel\_eval\_flex()}} which calls \href{https://github.com/JuliaLang/julia/blob/master/src/interpreter.c}{\texttt{eval()} in \texttt{interpreter.c}}.



The stack dump below shows how the interpreter works its way through various methods of \hyperlink{783803254548423222}{\texttt{Base.println()}} and \hyperlink{8248717042415202230}{\texttt{Base.print()}} before arriving at \href{https://github.com/JuliaLang/julia/blob/master/base/stream.jl}{\texttt{write(s::IO, a::Array\{T\}) where T}}  which does \texttt{ccall(jl\_uv\_write())}.



\href{https://github.com/JuliaLang/julia/blob/master/src/jl\_uv.c}{\texttt{jl\_uv\_write()}} calls \texttt{uv\_write()} to write {\textquotedbl}Hello World!{\textquotedbl} to \texttt{JL\_STDOUT}. See \hyperlink{11668969309999094552}{Libuv wrappers for stdio}.:




\begin{lstlisting}
Hello World!
\end{lstlisting}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Stack frame & Source code & Notes \\
\hline
\texttt{jl\_uv\_write()} & \texttt{jl\_uv.c} & called though \hyperlink{14245046751182637566}{\texttt{ccall}} \\
\hline
\texttt{julia\_write\_282942} & \texttt{stream.jl} & function \texttt{write!(s::IO, a::Array\{T\}) where T} \\
\hline
\texttt{julia\_print\_284639} & \texttt{ascii.jl} & \texttt{print(io::IO, s::String) = (write(io, s); nothing)} \\
\hline
\texttt{jlcall\_print\_284639} &  &  \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &  \\
\hline
\texttt{jl\_trampoline()} & \texttt{builtins.c} &  \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &  \\
\hline
\texttt{jl\_apply\_generic()} & \texttt{gf.c} & \texttt{Base.print(Base.TTY, String)} \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &  \\
\hline
\texttt{jl\_trampoline()} & \texttt{builtins.c} &  \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &  \\
\hline
\texttt{jl\_apply\_generic()} & \texttt{gf.c} & \texttt{Base.print(Base.TTY, String, Char, Char...)} \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &  \\
\hline
\texttt{jl\_f\_apply()} & \texttt{builtins.c} &  \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &  \\
\hline
\texttt{jl\_trampoline()} & \texttt{builtins.c} &  \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &  \\
\hline
\texttt{jl\_apply\_generic()} & \texttt{gf.c} & \texttt{Base.println(Base.TTY, String, String...)} \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &  \\
\hline
\texttt{jl\_trampoline()} & \texttt{builtins.c} &  \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &  \\
\hline
\texttt{jl\_apply\_generic()} & \texttt{gf.c} & \texttt{Base.println(String,)} \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &  \\
\hline
\texttt{do\_call()} & \texttt{interpreter.c} &  \\
\hline
\texttt{eval()} & \texttt{interpreter.c} &  \\
\hline
\texttt{jl\_interpret\_toplevel\_expr()} & \texttt{interpreter.c} &  \\
\hline
\texttt{jl\_toplevel\_eval\_flex()} & \texttt{toplevel.c} &  \\
\hline
\texttt{jl\_toplevel\_eval()} & \texttt{toplevel.c} &  \\
\hline
\texttt{jl\_toplevel\_eval\_in()} & \texttt{builtins.c} &  \\
\hline
\texttt{jl\_f\_top\_eval()} & \texttt{builtins.c} &  \\
\hline
\end{tabulary}

\end{table}



Since our example has just one function call, which has done its job of printing {\textquotedbl}Hello World!{\textquotedbl}, the stack now rapidly unwinds back to \texttt{main()}.



\hypertarget{8766302654766843311}{}


\subsection{\texttt{jl\_atexit\_hook()}}



\texttt{main()} calls \href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{\texttt{jl\_atexit\_hook()}}. This calls \texttt{Base.\_atexit}, then calls \href{https://github.com/JuliaLang/julia/blob/master/src/gc.c}{\texttt{jl\_gc\_run\_all\_finalizers()}} and cleans up libuv handles.



\hypertarget{6367994784846959684}{}


\subsection{\texttt{julia\_save()}}



Finally, \texttt{main()} calls \href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{\texttt{julia\_save()}}, which if requested on the command line, saves the runtime state to a new system image. See \href{https://github.com/JuliaLang/julia/blob/master/src/gf.c}{\texttt{jl\_compile\_all()}} and \href{https://github.com/JuliaLang/julia/blob/master/src/staticdata.c}{\texttt{jl\_save\_system\_image()}}.



\hypertarget{13955728449382648563}{}


\section{Julia 的 AST}



Julia 有两种代码的表现形式。 第一种是解析器返回的表面语法 AST （例如 \hyperlink{10422957797582368651}{\texttt{Meta.parse}} 函数），由宏来操控。是代码编写时的结构化表示，由 \texttt{julia-parser.scm} 用字符流构造而成。 另一种则是底层形式，或者 IR（中间表示），这种形式在进行类型推导和代码生成的时候被使用。在这种底层形式中结点的类型相对更少，所有的宏都会被展开，所有的控制流会被转化成显式的分支和语句的序列。底层的形式由 \texttt{julia-syntax.scm} 构建。



First we will focus on the AST, since it is needed to write macros.



\hypertarget{6198433338459689204}{}


\subsection{Surface syntax AST}



Front end ASTs consist almost entirely of \hyperlink{17120496304147995299}{\texttt{Expr}}s and atoms (e.g. symbols, numbers). There is generally a different expression head for each visually distinct syntactic form. Examples will be given in s-expression syntax. Each parenthesized list corresponds to an Expr, where the first element is the head. For example \texttt{(call f x)} corresponds to \texttt{Expr(:call, :f, :x)} in Julia.



\hypertarget{13191950853363974893}{}


\subsubsection{Calls}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Input & AST \\
\hline
\texttt{f(x)} & \texttt{(call f x)} \\
\hline
\texttt{f(x, y=1, z=2)} & \texttt{(call f x (kw y 1) (kw z 2))} \\
\hline
\texttt{f(x; y=1)} & \texttt{(call f (parameters (kw y 1)) x)} \\
\hline
\texttt{f(x...)} & \texttt{(call f (... x))} \\
\hline
\end{tabulary}

\end{table}



\texttt{do} syntax:




\begin{minted}{julia}
f(x) do a,b
    body
end
\end{minted}



parses as \texttt{(do (call f x) (-> (tuple a b) (block body)))}.



\hypertarget{16991843071018324380}{}


\subsubsection{Operators}



Most uses of operators are just function calls, so they are parsed with the head \texttt{call}. However some operators are special forms (not necessarily function calls), and in those cases the operator itself is the expression head. In julia-parser.scm these are referred to as {\textquotedbl}syntactic operators{\textquotedbl}. Some operators (\texttt{+} and \texttt{*}) use N-ary parsing; chained calls are parsed as a single N-argument call. Finally, chains of comparisons have their own special expression structure.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Input & AST \\
\hline
\texttt{x+y} & \texttt{(call + x y)} \\
\hline
\texttt{a+b+c+d} & \texttt{(call + a b c d)} \\
\hline
\texttt{2x} & \texttt{(call * 2 x)} \\
\hline
\texttt{a\&\&b} & \texttt{(\&\& a b)} \\
\hline
\texttt{x += 1} & \texttt{(+= x 1)} \\
\hline
\texttt{a ? 1 : 2} & \texttt{(if a 1 2)} \\
\hline
\texttt{a:b} & \texttt{(: a b)} \\
\hline
\texttt{a:b:c} & \texttt{(: a b c)} \\
\hline
\texttt{a,b} & \texttt{(tuple a b)} \\
\hline
\texttt{a==b} & \texttt{(call == a b)} \\
\hline
\texttt{1<i<=n} & \texttt{(comparison 1 < i <= n)} \\
\hline
\texttt{a.b} & \texttt{(. a (quote b))} \\
\hline
\texttt{a.(b)} & \texttt{(. a (tuple b))} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{15884526073773577025}{}


\subsubsection{Bracketed forms}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Input & AST \\
\hline
\texttt{a[i]} & \texttt{(ref a i)} \\
\hline
\texttt{t[i;j]} & \texttt{(typed\_vcat t i j)} \\
\hline
\texttt{t[i j]} & \texttt{(typed\_hcat t i j)} \\
\hline
\texttt{t[a b; c d]} & \texttt{(typed\_vcat t (row a b) (row c d))} \\
\hline
\texttt{a\{b\}} & \texttt{(curly a b)} \\
\hline
\texttt{a\{b;c\}} & \texttt{(curly a (parameters c) b)} \\
\hline
\texttt{[x]} & \texttt{(vect x)} \\
\hline
\texttt{[x,y]} & \texttt{(vect x y)} \\
\hline
\texttt{[x;y]} & \texttt{(vcat x y)} \\
\hline
\texttt{[x y]} & \texttt{(hcat x y)} \\
\hline
\texttt{[x y; z t]} & \texttt{(vcat (row x y) (row z t))} \\
\hline
\texttt{[x for y in z, a in b]} & \texttt{(comprehension x (= y z) (= a b))} \\
\hline
\texttt{T[x for y in z]} & \texttt{(typed\_comprehension T x (= y z))} \\
\hline
\texttt{(a, b, c)} & \texttt{(tuple a b c)} \\
\hline
\texttt{(a; b; c)} & \texttt{(block a (block b c))} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{7735912728489467540}{}


\subsubsection{Macros}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Input & AST \\
\hline
\texttt{@m x y} & \texttt{(macrocall @m (line) x y)} \\
\hline
\texttt{Base.@m x y} & \texttt{(macrocall (. Base (quote @m)) (line) x y)} \\
\hline
\texttt{@Base.m x y} & \texttt{(macrocall (. Base (quote @m)) (line) x y)} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{5278796056388981234}{}


\subsubsection{Strings}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Input & AST \\
\hline
\texttt{{\textquotedbl}a{\textquotedbl}} & \texttt{{\textquotedbl}a{\textquotedbl}} \\
\hline
\texttt{x{\textquotedbl}y{\textquotedbl}} & \texttt{(macrocall @x\_str (line) {\textquotedbl}y{\textquotedbl})} \\
\hline
\texttt{x{\textquotedbl}y{\textquotedbl}z} & \texttt{(macrocall @x\_str (line) {\textquotedbl}y{\textquotedbl} {\textquotedbl}z{\textquotedbl})} \\
\hline
\texttt{{\textquotedbl}x = \$x{\textquotedbl}} & \texttt{(string {\textquotedbl}x = {\textquotedbl} x)} \\
\hline
\texttt{`a b c`} & \texttt{(macrocall @cmd (line) {\textquotedbl}a b c{\textquotedbl})} \\
\hline
\end{tabulary}

\end{table}



Doc string syntax:




\begin{minted}{julia}
"some docs"
f(x) = x
\end{minted}



parses as \texttt{(macrocall (|.| Core {\textquotesingle}@doc) (line) {\textquotedbl}some docs{\textquotedbl} (= (call f x) (block x)))}.



\hypertarget{13863161852089184826}{}


\subsubsection{Imports and such}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Input & AST \\
\hline
\texttt{import a} & \texttt{(import (. a))} \\
\hline
\texttt{import a.b.c} & \texttt{(import (. a b c))} \\
\hline
\texttt{import ...a} & \texttt{(import (. . . . a))} \\
\hline
\texttt{import a.b, c.d} & \texttt{(import (. a b) (. c d))} \\
\hline
\texttt{import Base: x} & \texttt{(import (: (. Base) (. x)))} \\
\hline
\texttt{import Base: x, y} & \texttt{(import (: (. Base) (. x) (. y)))} \\
\hline
\texttt{export a, b} & \texttt{(export a b)} \\
\hline
\end{tabulary}

\end{table}



\texttt{using} has the same representation as \texttt{import}, but with expression head \texttt{:using} instead of \texttt{:import}.



\hypertarget{13439801024488074381}{}


\subsubsection{Numbers}



Julia supports more number types than many scheme implementations, so not all numbers are represented directly as scheme numbers in the AST.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Input & AST \\
\hline
\texttt{11111111111111111111} & \texttt{(macrocall @int128\_str (null) {\textquotedbl}11111111111111111111{\textquotedbl})} \\
\hline
\texttt{0xfffffffffffffffff} & \texttt{(macrocall @uint128\_str (null) {\textquotedbl}0xfffffffffffffffff{\textquotedbl})} \\
\hline
\texttt{1111...many digits...} & \texttt{(macrocall @big\_str (null) {\textquotedbl}1111....{\textquotedbl})} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{12573206411049142153}{}


\subsubsection{Block forms}



A block of statements is parsed as \texttt{(block stmt1 stmt2 ...)}.



If statement:




\begin{minted}{julia}
if a
    b
elseif c
    d
else
    e
end
\end{minted}



parses as:




\begin{lstlisting}
(if a (block (line 2) b)
    (elseif (block (line 3) c) (block (line 4) d)
            (block (line 5 e))))
\end{lstlisting}



A \texttt{while} loop parses as \texttt{(while condition body)}.



A \texttt{for} loop parses as \texttt{(for (= var iter) body)}. If there is more than one iteration specification, they are parsed as a block: \texttt{(for (block (= v1 iter1) (= v2 iter2)) body)}.



\texttt{break} and \texttt{continue} are parsed as 0-argument expressions \texttt{(break)} and \texttt{(continue)}.



\texttt{let} is parsed as \texttt{(let (= var val) body)} or \texttt{(let (block (= var1 val1) (= var2 val2) ...) body)}, like \texttt{for} loops.



A basic function definition is parsed as \texttt{(function (call f x) body)}. A more complex example:




\begin{minted}{julia}
function f(x::T; k = 1) where T
    return x+1
end
\end{minted}



parses as:




\begin{lstlisting}
(function (where (call f (parameters (kw k 1))
                       (:: x T))
                 T)
          (block (line 2) (return (call + x 1))))
\end{lstlisting}



Type definition:




\begin{minted}{julia}
mutable struct Foo{T<:S}
    x::T
end
\end{minted}



parses as:




\begin{lstlisting}
(struct true (curly Foo (<: T S))
        (block (line 2) (:: x T)))
\end{lstlisting}



The first argument is a boolean telling whether the type is mutable.



\texttt{try} blocks parse as \texttt{(try try\_block var catch\_block finally\_block)}. If no variable is present after \texttt{catch}, \texttt{var} is \texttt{\#f}. If there is no \texttt{finally} clause, then the last argument is not present.



\hypertarget{15188092119950048030}{}


\subsubsection{Quote expressions}



Julia source syntax forms for code quoting (\texttt{quote} and \texttt{:( )}) support interpolation with \texttt{\$}. In Lisp terminology, this means they are actually {\textquotedbl}backquote{\textquotedbl} or {\textquotedbl}quasiquote{\textquotedbl} forms. Internally, there is also a need for code quoting without interpolation. In Julia{\textquotesingle}s scheme code, non-interpolating quote is represented with the expression head \texttt{inert}.



\texttt{inert} expressions are converted to Julia \texttt{QuoteNode} objects. These objects wrap a single value of any type, and when evaluated simply return that value.



A \texttt{quote} expression whose argument is an atom also gets converted to a \texttt{QuoteNode}.



\hypertarget{9438599814670899276}{}


\subsubsection{Line numbers}



Source location information is represented as \texttt{(line line\_num file\_name)} where the third component is optional (and omitted when the current line number, but not file name, changes).



These expressions are represented as \texttt{LineNumberNode}s in Julia.



\hypertarget{8143615541033323666}{}


\subsubsection{Macros}



Macro hygiene is represented through the expression head pair \texttt{escape} and \texttt{hygienic-scope}. The result of a macro expansion is automatically wrapped in \texttt{(hygienic-scope block module)}, to represent the result of the new scope. The user can insert \texttt{(escape block)} inside to interpolate code from the caller.



\hypertarget{16818744617880081407}{}


\subsection{Lowered form}



Lowered form (IR) is more important to the compiler, since it is used for type inference, optimizations like inlining, and code generation. It is also less obvious to the human, since it results from a significant rearrangement of the input syntax.



In addition to \texttt{Symbol}s and some number types, the following data types exist in lowered form:



\begin{itemize}
\item \texttt{Expr}

Has a node type indicated by the \texttt{head} field, and an \texttt{args} field which is a \texttt{Vector\{Any\}} of subexpressions. While almost every part of a surface AST is represented by an \texttt{Expr}, the IR uses only a limited number of \texttt{Expr}s, mostly for calls, conditional branches (\texttt{gotoifnot}), and returns.


\item \texttt{Slot}

Identifies arguments and local variables by consecutive numbering. \texttt{Slot} is an abstract type with subtypes \texttt{SlotNumber} and \texttt{TypedSlot}. Both types have an integer-valued \texttt{id} field giving the slot index. Most slots have the same type at all uses, and so are represented with \texttt{SlotNumber}. The types of these slots are found in the \texttt{slottypes} field of their \texttt{MethodInstance} object. Slots that require per-use type annotations are represented with \texttt{TypedSlot}, which has a \texttt{typ} field.


\item \texttt{CodeInfo}

Wraps the IR of a group of statements. Its \texttt{code} field is an array of expressions to execute.


\item \texttt{GotoNode}

Unconditional branch. The argument is the branch target, represented as an index in the code array to jump to.


\item \texttt{QuoteNode}

Wraps an arbitrary value to reference as data. For example, the function \texttt{f() = :a} contains a \texttt{QuoteNode} whose \texttt{value} field is the symbol \texttt{a}, in order to return the symbol itself instead of evaluating it.


\item \texttt{GlobalRef}

Refers to global variable \texttt{name} in module \texttt{mod}.


\item \texttt{SSAValue}

Refers to a consecutively-numbered (starting at 1) static single assignment (SSA) variable inserted by the compiler. The number (\texttt{id}) of an \texttt{SSAValue} is the code array index of the expression whose value it represents.


\item \texttt{NewvarNode}

Marks a point where a variable (slot) is created. This has the effect of resetting a variable to undefined.

\end{itemize}


\hypertarget{15302433068188215381}{}


\subsubsection{\texttt{Expr} types}



These symbols appear in the \texttt{head} field of \hyperlink{17120496304147995299}{\texttt{Expr}}s in lowered form.



\begin{itemize}
\item \texttt{call}

Function call (dynamic dispatch). \texttt{args[1]} is the function to call, \texttt{args[2:end]} are the arguments.


\item \texttt{invoke}

Function call (static dispatch). \texttt{args[1]} is the MethodInstance to call, \texttt{args[2:end]} are the arguments (including the function that is being called, at \texttt{args[2]}).


\item \texttt{static\_parameter}

Reference a static parameter by index.


\item \texttt{gotoifnot}

Conditional branch. If \texttt{args[1]} is false, goes to the index identified in \texttt{args[2]}.


\item \texttt{=}

Assignment. In the IR, the first argument is always a Slot or a GlobalRef.


\item \texttt{method}

Adds a method to a generic function and assigns the result if necessary.

Has a 1-argument form and a 3-argument form. The 1-argument form arises from the syntax \texttt{function foo end}. In the 1-argument form, the argument is a symbol. If this symbol already names a function in the current scope, nothing happens. If the symbol is undefined, a new function is created and assigned to the identifier specified by the symbol. If the symbol is defined but names a non-function, an error is raised. The definition of {\textquotedbl}names a function{\textquotedbl} is that the binding is constant, and refers to an object of singleton type. The rationale for this is that an instance of a singleton type uniquely identifies the type to add the method to. When the type has fields, it wouldn{\textquotesingle}t be clear whether the method was being added to the instance or its type.

The 3-argument form has the following arguments:

\begin{itemize}
\item \texttt{args[1]}

A function name, or \texttt{false} if unknown. If a symbol, then the expression first behaves like the 1-argument form above. This argument is ignored from then on. When this is \texttt{false}, it means a method is being added strictly by type, \texttt{(::T)(x) = x}.


\item \texttt{args[2]}

A \texttt{SimpleVector} of argument type data. \texttt{args[2][1]} is a \texttt{SimpleVector} of the argument types, and \texttt{args[2][2]} is a \texttt{SimpleVector} of type variables corresponding to the method{\textquotesingle}s static parameters.


\item \texttt{args[3]}

A \texttt{CodeInfo} of the method itself. For {\textquotedbl}out of scope{\textquotedbl} method definitions (adding a method to a function that also has methods defined in different scopes) this is an expression that evaluates to a \texttt{:lambda} expression.

\end{itemize}

\item \texttt{struct\_type}

A 7-argument expression that defines a new \texttt{struct}:

\begin{itemize}
\item \texttt{args[1]}

The name of the \texttt{struct}


\item \texttt{args[2]}

A \texttt{call} expression that creates a \texttt{SimpleVector} specifying its parameters


\item \texttt{args[3]}

A \texttt{call} expression that creates a \texttt{SimpleVector} specifying its fieldnames


\item \texttt{args[4]}

A \texttt{Symbol}, \texttt{GlobalRef}, or \texttt{Expr} specifying the supertype (e.g., \texttt{:Integer}, \texttt{GlobalRef(Core, :Any)}, or \texttt{:(Core.apply\_type(AbstractArray, T, N))})


\item \texttt{args[5]}

A \texttt{call} expression that creates a \texttt{SimpleVector} specifying its fieldtypes


\item \texttt{args[6]}

A Bool, true if \texttt{mutable}


\item \texttt{args[7]}

The number of arguments to initialize. This will be the number of fields, or the minimum number of fields called by an inner constructor{\textquotesingle}s \texttt{new} statement.

\end{itemize}

\item \texttt{abstract\_type}

A 3-argument expression that defines a new abstract type. The arguments are the same as arguments 1, 2, and 4 of \texttt{struct\_type} expressions.


\item \texttt{primitive\_type}

A 4-argument expression that defines a new primitive type. Arguments 1, 2, and 4 are the same as \texttt{struct\_type}. Argument 3 is the number of bits.

\begin{quote}
\textbf{Julia 1.5}

\texttt{struct\_type}, \texttt{abstract\_type}, and \texttt{primitive\_type} were removed in Julia 1.5 and replaced by calls to new builtins.

\end{quote}

\item \texttt{global}

Declares a global binding.


\item \texttt{const}

Declares a (global) variable as constant.


\item \texttt{new}

Allocates a new struct-like object. First argument is the type. The \hyperlink{13888762393600028594}{\texttt{new}} pseudo-function is lowered to this, and the type is always inserted by the compiler.  This is very much an internal-only feature, and does no checking. Evaluating arbitrary \texttt{new} expressions can easily segfault.


\item \texttt{splatnew}

Similar to \texttt{new}, except field values are passed as a single tuple. Works similarly to \texttt{Base.splat(new)} if \texttt{new} were a first-class function, hence the name.


\item \texttt{return}

Returns its argument as the value of the enclosing function.


\item \texttt{isdefined}

\texttt{Expr(:isdefined, :x)} returns a Bool indicating whether \texttt{x} has already been defined in the current scope.


\item \texttt{the\_exception}

Yields the caught exception inside a \texttt{catch} block, as returned by \texttt{jl\_current\_exception()}.


\item \texttt{enter}

Enters an exception handler (\texttt{setjmp}). \texttt{args[1]} is the label of the catch block to jump to on error.  Yields a token which is consumed by \texttt{pop\_exception}.


\item \texttt{leave}

Pop exception handlers. \texttt{args[1]} is the number of handlers to pop.


\item \texttt{pop\_exception}

Pop the stack of current exceptions back to the state at the associated \texttt{enter} when leaving a catch block. \texttt{args[1]} contains the token from the associated \texttt{enter}.

\begin{quote}
\textbf{Julia 1.1}

\texttt{pop\_exception} is new in Julia 1.1.

\end{quote}

\item \texttt{inbounds}

Controls turning bounds checks on or off. A stack is maintained; if the first argument of this expression is true or false (\texttt{true} means bounds checks are disabled), it is pushed onto the stack. If the first argument is \texttt{:pop}, the stack is popped.


\item \texttt{boundscheck}

Has the value \texttt{false} if inlined into a section of code marked with \texttt{@inbounds}, otherwise has the value \texttt{true}.


\item \texttt{loopinfo}

Marks the end of the a loop. Contains metadata that is passed to \texttt{LowerSimdLoop} to either mark the inner loop of \texttt{@simd} expression, or to propagate information to LLVM loop passes.


\item \texttt{copyast}

Part of the implementation of quasi-quote. The argument is a surface syntax AST that is simply copied recursively and returned at run time.


\item \texttt{meta}

Metadata. \texttt{args[1]} is typically a symbol specifying the kind of metadata, and the rest of the arguments are free-form. The following kinds of metadata are commonly used:

\begin{itemize}
\item \texttt{:inline} and \texttt{:noinline}: Inlining hints.

\end{itemize}

\item \texttt{foreigncall}

Statically-computed container for \texttt{ccall} information. The fields are:

\begin{itemize}
\item \texttt{args[1]} : name

The expression that{\textquotesingle}ll be parsed for the foreign function.


\item \texttt{args[2]::Type} : RT

The (literal) return type, computed statically when the containing method was defined.


\item \texttt{args[3]::SimpleVector} (of Types) : AT

The (literal) vector of argument types, computed statically when the containing method was defined.


\item \texttt{args[4]::Int} : nreq

The number of required arguments for a varargs function definition.


\item \texttt{args[5]::QuoteNode\{Symbol\}} : calling convention

The calling convention for the call.


\item \texttt{args[6:length(args[3])]} : arguments

The values for all the arguments (with types of each given in args[3]).


\item \texttt{args[(length(args[3]) + 1):end]} : gc-roots

The additional objects that may need to be gc-rooted for the duration of the call. See \hyperlink{16487312531471662451}{Working with LLVM} for where these are derived from and how they get handled.

\end{itemize}
\end{itemize}


\hypertarget{10862348325946528961}{}


\subsubsection{Method}



A unique{\textquotesingle}d container describing the shared metadata for a single method.



\begin{itemize}
\item \texttt{name}, \texttt{module}, \texttt{file}, \texttt{line}, \texttt{sig}

Metadata to uniquely identify the method for the computer and the human.


\item \texttt{ambig}

Cache of other methods that may be ambiguous with this one.


\item \texttt{specializations}

Cache of all MethodInstance ever created for this Method, used to ensure uniqueness. Uniqueness is required for efficiency, especially for incremental precompile and tracking of method invalidation.


\item \texttt{source}

The original source code (if available, usually compressed).


\item \texttt{generator}

A callable object which can be executed to get specialized source for a specific method signature.


\item \texttt{roots}

Pointers to non-AST things that have been interpolated into the AST, required by compression of the AST, type-inference, or the generation of native code.


\item \texttt{nargs}, \texttt{isva}, \texttt{called}, \texttt{isstaged}, \texttt{pure}

Descriptive bit-fields for the source code of this Method.


\item \texttt{primary\_world}

The world age that {\textquotedbl}owns{\textquotedbl} this Method.

\end{itemize}


\hypertarget{2584833319372808594}{}


\subsubsection{MethodInstance}



A unique{\textquotesingle}d container describing a single callable signature for a Method. See especially \hyperlink{17047801949293328593}{Proper maintenance and care of multi-threading locks} for important details on how to modify these fields safely.



\begin{itemize}
\item \texttt{specTypes}

The primary key for this MethodInstance. Uniqueness is guaranteed through a \texttt{def.specializations} lookup.


\item \texttt{def}

The \texttt{Method} that this function describes a specialization of. Or a \texttt{Module}, if this is a top-level Lambda expanded in Module, and which is not part of a Method.


\item \texttt{sparam\_vals}

The values of the static parameters in \texttt{specTypes} indexed by \texttt{def.sparam\_syms}. For the \texttt{MethodInstance} at \texttt{Method.unspecialized}, this is the empty \texttt{SimpleVector}. But for a runtime \texttt{MethodInstance} from the \texttt{MethodTable} cache, this will always be defined and indexable.


\item \texttt{uninferred}

The uncompressed source code for a toplevel thunk. Additionally, for a generated function, this is one of many places that the source code might be found.


\item \texttt{backedges}

We store the reverse-list of cache dependencies for efficient tracking of incremental reanalysis/recompilation work that may be needed after a new method definitions. This works by keeping a list of the other \texttt{MethodInstance} that have been inferred or optimized to contain a possible call to this \texttt{MethodInstance}. Those optimization results might be stored somewhere in the \texttt{cache}, or it might have been the result of something we didn{\textquotesingle}t want to cache, such as constant propagation. Thus we merge all of those backedges to various cache entries here (there{\textquotesingle}s almost always only the one applicable cache entry with a sentinal value for max\_world anyways).


\item \texttt{cache}

Cache of \texttt{CodeInstance} objects that share this template instantiation.

\end{itemize}


\hypertarget{17684444820224515276}{}


\subsubsection{CodeInstance}



\begin{itemize}
\item \texttt{def}

The \texttt{MethodInstance} that this cache entry is derived from.

\end{itemize}


\begin{itemize}
\item \texttt{rettype}/\texttt{rettype\_const}

The inferred return type for the \texttt{specFunctionObject} field, which (in most cases) is also the computed return type for the function in general.


\item \texttt{inferred}

May contain a cache of the inferred source for this function, or it could be set to \texttt{nothing} to just indicate \texttt{rettype} is inferred.


\item \texttt{ftpr}

The generic jlcall entry point.


\item \texttt{jlcall\_api}

The ABI to use when calling \texttt{fptr}. Some significant ones include:

\begin{itemize}
\item 0 - Not compiled yet


\item 1 - JL\emph{CALLABLE `jl}value\emph{t \emph{(})(jl}function\emph{t *f, jl}value\emph{t *args[nargs], uint32}t nargs)`


\item 2 - Constant (value stored in \texttt{rettype\_const})


\item 3 - With Static-parameters forwarded \texttt{jl\_value\_t *(*)(jl\_svec\_t *sparams, jl\_function\_t *f, jl\_value\_t *args[nargs], uint32\_t nargs)}


\item 4 - Run in interpreter \texttt{jl\_value\_t *(*)(jl\_method\_instance\_t *meth, jl\_function\_t *f, jl\_value\_t *args[nargs], uint32\_t nargs)}

\end{itemize}

\item \texttt{min\_world} / \texttt{max\_world}

The range of world ages for which this method instance is valid to be called. If max\_world is the special token value \texttt{-1}, the value is not yet known. It may continue to be used until we encounter a backedge that requires us to reconsider.

\end{itemize}


\hypertarget{15595975163128328315}{}


\subsubsection{CodeInfo}



A (usually temporary) container for holding lowered source code.



\begin{itemize}
\item \texttt{code}

An \texttt{Any} array of statements


\item \texttt{slotnames}

An array of symbols giving names for each slot (argument or local variable).


\item \texttt{slotflags}

A \texttt{UInt8} array of slot properties, represented as bit flags:

\begin{itemize}
\item 2  - assigned (only false if there are \emph{no} assignment statements with this var on the left)


\item 8  - const (currently unused for local variables)


\item 16 - statically assigned once


\item 32 - might be used before assigned. This flag is only valid after type inference.

\end{itemize}

\item \texttt{ssavaluetypes}

Either an array or an \texttt{Int}.

If an \texttt{Int}, it gives the number of compiler-inserted temporary locations in the function (the length of \texttt{code} array). If an array, specifies a type for each location.


\item \texttt{ssaflags}

Statement-level flags for each expression in the function. Many of these are reserved, but not yet implemented:

\begin{itemize}
\item 0 = inbounds


\item 1,2 = <reserved> inlinehint,always-inline,noinline


\item 3 = <reserved> strict-ieee (strictfp)


\item 4-6 = <unused>


\item 7 = <reserved> has out-of-band info

\end{itemize}

\item \texttt{linetable}

An array of source location objects


\item \texttt{codelocs}

An array of integer indices into the \texttt{linetable}, giving the location associated with each statement.

\end{itemize}


Optional Fields:



\begin{itemize}
\item \texttt{slottypes}

An array of types for the slots.


\item \texttt{rettype}

The inferred return type of the lowered form (IR). Default value is \texttt{Any}.


\item \texttt{method\_for\_inference\_limit\_heuristics}

The \texttt{method\_for\_inference\_heuristics} will expand the given method{\textquotesingle}s generator if necessary during inference.


\item \texttt{parent}

The \texttt{MethodInstance} that {\textquotedbl}owns{\textquotedbl} this object (if applicable).


\item \texttt{min\_world}/\texttt{max\_world}

The range of world ages for which this code was valid at the time when it had been inferred.

\end{itemize}


Boolean properties:



\begin{itemize}
\item \texttt{inferred}

Whether this has been produced by type inference.


\item \texttt{inlineable}

Whether this should be eligible for inlining.


\item \texttt{propagate\_inbounds}

Whether this should propagate \texttt{@inbounds} when inlined for the purpose of eliding \texttt{@boundscheck} blocks.


\item \texttt{pure}

Whether this is known to be a pure function of its arguments, without respect to the state of the method caches or other mutable global state.

\end{itemize}


\hypertarget{4038509094133832716}{}


\section{More about types}



If you{\textquotesingle}ve used Julia for a while, you understand the fundamental role that types play.  Here we try to get under the hood, focusing particularly on \href{@ref}{Parametric Types}.



\hypertarget{8213772846516553388}{}


\subsection{Types and sets (and \texttt{Any} and \texttt{Union\{\}}/\texttt{Bottom})}



It{\textquotesingle}s perhaps easiest to conceive of Julia{\textquotesingle}s type system in terms of sets. While programs manipulate individual values, a type refers to a set of values. This is not the same thing as a collection; for example a \hyperlink{1143189053501747033}{\texttt{Set}} of values is itself a single \texttt{Set} value. Rather, a type describes a set of \emph{possible} values, expressing uncertainty about which value we have.



A \emph{concrete} type \texttt{T} describes the set of values whose direct tag, as returned by the \hyperlink{13440452181855594120}{\texttt{typeof}} function, is \texttt{T}. An \emph{abstract} type describes some possibly-larger set of values.



\hyperlink{15014186392807667022}{\texttt{Any}} describes the entire universe of possible values. \hyperlink{8469131683393450448}{\texttt{Integer}} is a subset of \texttt{Any} that includes \texttt{Int}, \hyperlink{5857518405103968275}{\texttt{Int8}}, and other concrete types. Internally, Julia also makes heavy use of another type known as \texttt{Bottom}, which can also be written as \texttt{Union\{\}}. This corresponds to the empty set.



Julia{\textquotesingle}s types support the standard operations of set theory: you can ask whether \texttt{T1} is a {\textquotedbl}subset{\textquotedbl} (subtype) of \texttt{T2} with \texttt{T1 <: T2}. Likewise, you intersect two types using \hyperlink{1869272868531275554}{\texttt{typeintersect}}, take their union with \hyperlink{5087820771052303592}{\texttt{Union}}, and compute a type that contains their union with \hyperlink{6895589781245489183}{\texttt{typejoin}}:




\begin{minted}{jlcon}
julia> typeintersect(Int, Float64)
Union{}

julia> Union{Int, Float64}
Union{Float64, Int64}

julia> typejoin(Int, Float64)
Real

julia> typeintersect(Signed, Union{UInt8, Int8})
Int8

julia> Union{Signed, Union{UInt8, Int8}}
Union{UInt8, Signed}

julia> typejoin(Signed, Union{UInt8, Int8})
Integer

julia> typeintersect(Tuple{Integer,Float64}, Tuple{Int,Real})
Tuple{Int64,Float64}

julia> Union{Tuple{Integer,Float64}, Tuple{Int,Real}}
Union{Tuple{Int64,Real}, Tuple{Integer,Float64}}

julia> typejoin(Tuple{Integer,Float64}, Tuple{Int,Real})
Tuple{Integer,Real}
\end{minted}



While these operations may seem abstract, they lie at the heart of Julia.  For example, method dispatch is implemented by stepping through the items in a method list until reaching one for which the type of the argument tuple is a subtype of the method signature. For this algorithm to work, it{\textquotesingle}s important that methods be sorted by their specificity, and that the search begins with the most specific methods. Consequently, Julia also implements a partial order on types; this is achieved by functionality that is similar to \texttt{<:}, but with differences that will be discussed below.



\hypertarget{11911810306869937851}{}


\subsection{UnionAll types}



Julia{\textquotesingle}s type system can also express an \emph{iterated union} of types: a union of types over all values of some variable. This is needed to describe parametric types where the values of some parameters are not known.



For example, \hyperlink{15492651498431872487}{\texttt{Array}} has two parameters as in \texttt{Array\{Int,2\}}. If we did not know the element type, we could write \texttt{Array\{T,2\} where T}, which is the union of \texttt{Array\{T,2\}} for all values of \texttt{T}: \texttt{Union\{Array\{Int8,2\}, Array\{Int16,2\}, ...\}}.



Such a type is represented by a \texttt{UnionAll} object, which contains a variable (\texttt{T} in this example, of type \texttt{TypeVar}), and a wrapped type (\texttt{Array\{T,2\}} in this example).



Consider the following methods:




\begin{minted}{julia}
f1(A::Array) = 1
f2(A::Array{Int}) = 2
f3(A::Array{T}) where {T<:Any} = 3
f4(A::Array{Any}) = 4
\end{minted}



The signature - as described in \href{@ref}{Function calls} - of \texttt{f3} is a \texttt{UnionAll} type wrapping a tuple type: \texttt{Tuple\{typeof(f3), Array\{T\}\} where T}. All but \texttt{f4} can be called with \texttt{a = [1,2]}; all but \texttt{f2} can be called with \texttt{b = Any[1,2]}.



Let{\textquotesingle}s look at these types a little more closely:




\begin{minted}{jlcon}
julia> dump(Array)
UnionAll
  var: TypeVar
    name: Symbol T
    lb: Union{}
    ub: Any
  body: UnionAll
    var: TypeVar
      name: Symbol N
      lb: Union{}
      ub: Any
    body: Array{T,N} <: DenseArray{T,N}
\end{minted}



This indicates that \texttt{Array} actually names a \texttt{UnionAll} type. There is one \texttt{UnionAll} type for each parameter, nested. The syntax \texttt{Array\{Int,2\}} is equivalent to \texttt{Array\{Int\}\{2\}}; internally each \texttt{UnionAll} is instantiated with a particular variable value, one at a time, outermost-first. This gives a natural meaning to the omission of trailing type parameters; \texttt{Array\{Int\}} gives a type equivalent to \texttt{Array\{Int,N\} where N}.



A \texttt{TypeVar} is not itself a type, but rather should be considered part of the structure of a \texttt{UnionAll} type. Type variables have lower and upper bounds on their values (in the fields \texttt{lb} and \texttt{ub}). The symbol \texttt{name} is purely cosmetic. Internally, \texttt{TypeVar}s are compared by address, so they are defined as mutable types to ensure that {\textquotedbl}different{\textquotedbl} type variables can be distinguished. However, by convention they should not be mutated.



One can construct \texttt{TypeVar}s manually:




\begin{minted}{jlcon}
julia> TypeVar(:V, Signed, Real)
Signed<:V<:Real
\end{minted}



There are convenience versions that allow you to omit any of these arguments except the \texttt{name} symbol.



The syntax \texttt{Array\{T\} where T<:Integer} is lowered to




\begin{minted}{julia}
let T = TypeVar(:T,Integer)
    UnionAll(T, Array{T})
end
\end{minted}



so it is seldom necessary to construct a \texttt{TypeVar} manually (indeed, this is to be avoided).



\hypertarget{10862279169779752699}{}


\subsection{Free variables}



The concept of a \emph{free} type variable is extremely important in the type system. We say that a variable \texttt{V} is free in type \texttt{T} if \texttt{T} does not contain the \texttt{UnionAll} that introduces variable \texttt{V}. For example, the type \texttt{Array\{Array\{V\} where V<:Integer\}} has no free variables, but the \texttt{Array\{V\}} part inside of it does have a free variable, \texttt{V}.



A type with free variables is, in some sense, not really a type at all. Consider the type \texttt{Array\{Array\{T\}\} where T}, which refers to all homogeneous arrays of arrays. The inner type \texttt{Array\{T\}}, seen by itself, might seem to refer to any kind of array. However, every element of the outer array must have the \emph{same} array type, so \texttt{Array\{T\}} cannot refer to just any old array. One could say that \texttt{Array\{T\}} effectively {\textquotedbl}occurs{\textquotedbl} multiple times, and \texttt{T} must have the same value each {\textquotedbl}time{\textquotedbl}.



For this reason, the function \texttt{jl\_has\_free\_typevars} in the C API is very important. Types for which it returns true will not give meaningful answers in subtyping and other type functions.



\hypertarget{9475610527503799038}{}


\subsection{TypeNames}



The following two \hyperlink{15492651498431872487}{\texttt{Array}} types are functionally equivalent, yet print differently:




\begin{minted}{jlcon}
julia> TV, NV = TypeVar(:T), TypeVar(:N)
(T, N)

julia> Array
Array

julia> Array{TV,NV}
Array{T,N}
\end{minted}



These can be distinguished by examining the \texttt{name} field of the type, which is an object of type \texttt{TypeName}:




\begin{minted}{jlcon}
julia> dump(Array{Int,1}.name)
TypeName
  name: Symbol Array
  module: Module Core
  names: empty SimpleVector
  wrapper: UnionAll
    var: TypeVar
      name: Symbol T
      lb: Union{}
      ub: Any
    body: UnionAll
      var: TypeVar
        name: Symbol N
        lb: Union{}
        ub: Any
      body: Array{T,N} <: DenseArray{T,N}
  cache: SimpleVector
    ...

  linearcache: SimpleVector
    ...

  hash: Int64 -7900426068641098781
  mt: MethodTable
    name: Symbol Array
    defs: Nothing nothing
    cache: Nothing nothing
    max_args: Int64 0
    kwsorter: #undef
    module: Module Core
    : Int64 0
    : Int64 0
\end{minted}



In this case, the relevant field is \texttt{wrapper}, which holds a reference to the top-level type used to make new \texttt{Array} types.




\begin{minted}{jlcon}
julia> pointer_from_objref(Array)
Ptr{Cvoid} @0x00007fcc7de64850

julia> pointer_from_objref(Array.body.body.name.wrapper)
Ptr{Cvoid} @0x00007fcc7de64850

julia> pointer_from_objref(Array{TV,NV})
Ptr{Cvoid} @0x00007fcc80c4d930

julia> pointer_from_objref(Array{TV,NV}.name.wrapper)
Ptr{Cvoid} @0x00007fcc7de64850
\end{minted}



The \texttt{wrapper} field of \hyperlink{15492651498431872487}{\texttt{Array}} points to itself, but for \texttt{Array\{TV,NV\}} it points back to the original definition of the type.



What about the other fields? \texttt{hash} assigns an integer to each type.  To examine the \texttt{cache} field, it{\textquotesingle}s helpful to pick a type that is less heavily used than Array. Let{\textquotesingle}s first create our own type:




\begin{minted}{jlcon}
julia> struct MyType{T,N} end

julia> MyType{Int,2}
MyType{Int64,2}

julia> MyType{Float32, 5}
MyType{Float32,5}
\end{minted}



When you instantiate a parametric type, each concrete type gets saved in a type cache (\texttt{MyType.body.body.name.cache}). However, instances containing free type variables are not cached.



\hypertarget{15137612054834825471}{}


\subsection{Tuple types}



Tuple types constitute an interesting special case.  For dispatch to work on declarations like \texttt{x::Tuple}, the type has to be able to accommodate any tuple.  Let{\textquotesingle}s check the parameters:




\begin{minted}{jlcon}
julia> Tuple
Tuple

julia> Tuple.parameters
svec(Vararg{Any,N} where N)
\end{minted}



Unlike other types, tuple types are covariant in their parameters, so this definition permits \texttt{Tuple} to match any type of tuple:




\begin{minted}{jlcon}
julia> typeintersect(Tuple, Tuple{Int,Float64})
Tuple{Int64,Float64}

julia> typeintersect(Tuple{Vararg{Any}}, Tuple{Int,Float64})
Tuple{Int64,Float64}
\end{minted}



However, if a variadic (\texttt{Vararg}) tuple type has free variables it can describe different kinds of tuples:




\begin{minted}{jlcon}
julia> typeintersect(Tuple{Vararg{T} where T}, Tuple{Int,Float64})
Tuple{Int64,Float64}

julia> typeintersect(Tuple{Vararg{T}} where T, Tuple{Int,Float64})
Union{}
\end{minted}



Notice that when \texttt{T} is free with respect to the \texttt{Tuple} type (i.e. its binding \texttt{UnionAll} type is outside the \texttt{Tuple} type), only one \texttt{T} value must work over the whole type. Therefore a heterogeneous tuple does not match.



Finally, it{\textquotesingle}s worth noting that \texttt{Tuple\{\}} is distinct:




\begin{minted}{jlcon}
julia> Tuple{}
Tuple{}

julia> Tuple{}.parameters
svec()

julia> typeintersect(Tuple{}, Tuple{Int})
Union{}
\end{minted}



What is the {\textquotedbl}primary{\textquotedbl} tuple-type?




\begin{minted}{jlcon}
julia> pointer_from_objref(Tuple)
Ptr{Cvoid} @0x00007f5998a04370

julia> pointer_from_objref(Tuple{})
Ptr{Cvoid} @0x00007f5998a570d0

julia> pointer_from_objref(Tuple.name.wrapper)
Ptr{Cvoid} @0x00007f5998a04370

julia> pointer_from_objref(Tuple{}.name.wrapper)
Ptr{Cvoid} @0x00007f5998a04370
\end{minted}



so \texttt{Tuple == Tuple\{Vararg\{Any\}\}} is indeed the primary type.



\hypertarget{5206945150982308765}{}


\subsection{Diagonal types}



Consider the type \texttt{Tuple\{T,T\} where T}. A method with this signature would look like:




\begin{minted}{julia}
f(x::T, y::T) where {T} = ...
\end{minted}



According to the usual interpretation of a \texttt{UnionAll} type, this \texttt{T} ranges over all types, including \texttt{Any}, so this type should be equivalent to \texttt{Tuple\{Any,Any\}}. However, this interpretation causes some practical problems.



First, a value of \texttt{T} needs to be available inside the method definition. For a call like \texttt{f(1, 1.0)}, it{\textquotesingle}s not clear what \texttt{T} should be. It could be \texttt{Union\{Int,Float64\}}, or perhaps \hyperlink{6175959395021454412}{\texttt{Real}}. Intuitively, we expect the declaration \texttt{x::T} to mean \texttt{T === typeof(x)}. To make sure that invariant holds, we need \texttt{typeof(x) === typeof(y) === T} in this method. That implies the method should only be called for arguments of the exact same type.



It turns out that being able to dispatch on whether two values have the same type is very useful (this is used by the promotion system for example), so we have multiple reasons to want a different interpretation of \texttt{Tuple\{T,T\} where T}. To make this work we add the following rule to subtyping: if a variable occurs more than once in covariant position, it is restricted to ranging over only concrete types. ({\textquotedbl}Covariant position{\textquotedbl} means that only \texttt{Tuple} and \texttt{Union} types occur between an occurrence of a variable and the \texttt{UnionAll} type that introduces it.) Such variables are called {\textquotedbl}diagonal variables{\textquotedbl} or {\textquotedbl}concrete variables{\textquotedbl}.



So for example, \texttt{Tuple\{T,T\} where T} can be seen as \texttt{Union\{Tuple\{Int8,Int8\}, Tuple\{Int16,Int16\}, ...\}}, where \texttt{T} ranges over all concrete types. This gives rise to some interesting subtyping results. For example \texttt{Tuple\{Real,Real\}} is not a subtype of \texttt{Tuple\{T,T\} where T}, because it includes some types like \texttt{Tuple\{Int8,Int16\}} where the two elements have different types. \texttt{Tuple\{Real,Real\}} and \texttt{Tuple\{T,T\} where T} have the non-trivial intersection \texttt{Tuple\{T,T\} where T<:Real}. However, \texttt{Tuple\{Real\}} \emph{is} a subtype of \texttt{Tuple\{T\} where T}, because in that case \texttt{T} occurs only once and so is not diagonal.



Next consider a signature like the following:




\begin{minted}{julia}
f(a::Array{T}, x::T, y::T) where {T} = ...
\end{minted}



In this case, \texttt{T} occurs in invariant position inside \texttt{Array\{T\}}. That means whatever type of array is passed unambiguously determines the value of \texttt{T} – we say \texttt{T} has an \emph{equality constraint} on it. Therefore in this case the diagonal rule is not really necessary, since the array determines \texttt{T} and we can then allow \texttt{x} and \texttt{y} to be of any subtypes of \texttt{T}. So variables that occur in invariant position are never considered diagonal. This choice of behavior is slightly controversial –- some feel this definition should be written as




\begin{minted}{julia}
f(a::Array{T}, x::S, y::S) where {T, S<:T} = ...
\end{minted}



to clarify whether \texttt{x} and \texttt{y} need to have the same type. In this version of the signature they would, or we could introduce a third variable for the type of \texttt{y} if \texttt{x} and \texttt{y} can have different types.



The next complication is the interaction of unions and diagonal variables, e.g.




\begin{minted}{julia}
f(x::Union{Nothing,T}, y::T) where {T} = ...
\end{minted}



Consider what this declaration means. \texttt{y} has type \texttt{T}. \texttt{x} then can have either the same type \texttt{T}, or else be of type \hyperlink{13508459519898889544}{\texttt{Nothing}}. So all of the following calls should match:




\begin{minted}{julia}
f(1, 1)
f("", "")
f(2.0, 2.0)
f(nothing, 1)
f(nothing, "")
f(nothing, 2.0)
\end{minted}



These examples are telling us something: when \texttt{x} is \texttt{nothing::Nothing}, there are no extra constraints on \texttt{y}. It is as if the method signature had \texttt{y::Any}. Indeed, we have the following type equivalence:




\begin{minted}{julia}
(Tuple{Union{Nothing,T},T} where T) == Union{Tuple{Nothing,Any}, Tuple{T,T} where T}
\end{minted}



The general rule is: a concrete variable in covariant position acts like it{\textquotesingle}s not concrete if the subtyping algorithm only \emph{uses} it once. When \texttt{x} has type \texttt{Nothing}, we don{\textquotesingle}t need to use the \texttt{T} in \texttt{Union\{Nothing,T\}}; we only use it in the second slot. This arises naturally from the observation that in \texttt{Tuple\{T\} where T} restricting \texttt{T} to concrete types makes no difference; the type is equal to \texttt{Tuple\{Any\}} either way.



However, appearing in \emph{invariant} position disqualifies a variable from being concrete whether that appearance of the variable is used or not. Otherwise types can behave differently depending on which other types they are compared to, making subtyping not transitive. For example, consider



Tuple\{Int,Int8,Vector\{Integer\}\} <: Tuple\{T,T,Vector\{Union\{Integer,T\}\}\} where T



If the \texttt{T} inside the Union is ignored, then \texttt{T} is concrete and the answer is {\textquotedbl}false{\textquotedbl} since the first two types aren{\textquotesingle}t the same. But consider instead



Tuple\{Int,Int8,Vector\{Any\}\} <: Tuple\{T,T,Vector\{Union\{Integer,T\}\}\} where T



Now we cannot ignore the \texttt{T} in the Union (we must have T == Any), so \texttt{T} is not concrete and the answer is {\textquotedbl}true{\textquotedbl}. That would make the concreteness of \texttt{T} depend on the other type, which is not acceptable since a type must have a clear meaning on its own. Therefore the appearance of \texttt{T} inside \texttt{Vector} is considered in both cases.



\hypertarget{12600482412457091491}{}


\subsection{Subtyping diagonal variables}



The subtyping algorithm for diagonal variables has two components: (1) identifying variable occurrences, and (2) ensuring that diagonal variables range over concrete types only.



The first task is accomplished by keeping counters \texttt{occurs\_inv} and \texttt{occurs\_cov} (in \texttt{src/subtype.c}) for each variable in the environment, tracking the number of invariant and covariant occurrences, respectively. A variable is diagonal when \texttt{occurs\_inv == 0 \&\& occurs\_cov > 1}.



The second task is accomplished by imposing a condition on a variable{\textquotesingle}s lower bound. As the subtyping algorithm runs, it narrows the bounds of each variable (raising lower bounds and lowering upper bounds) to keep track of the range of variable values for which the subtype relation would hold. When we are done evaluating the body of a \texttt{UnionAll} type whose variable is diagonal, we look at the final values of the bounds. Since the variable must be concrete, a contradiction occurs if its lower bound could not be a subtype of a concrete type. For example, an abstract type like \hyperlink{6514416309183787338}{\texttt{AbstractArray}} cannot be a subtype of a concrete type, but a concrete type like \texttt{Int} can be, and the empty type \texttt{Bottom} can be as well. If a lower bound fails this test the algorithm stops with the answer \texttt{false}.



For example, in the problem \texttt{Tuple\{Int,String\} <: Tuple\{T,T\} where T}, we derive that this would be true if \texttt{T} were a supertype of \texttt{Union\{Int,String\}}. However, \texttt{Union\{Int,String\}} is an abstract type, so the relation does not hold.



This concreteness test is done by the function \texttt{is\_leaf\_bound}. Note that this test is slightly different from \texttt{jl\_is\_leaf\_type}, since it also returns \texttt{true} for \texttt{Bottom}. Currently this function is heuristic, and does not catch all possible concrete types. The difficulty is that whether a lower bound is concrete might depend on the values of other type variable bounds. For example, \texttt{Vector\{T\}} is equivalent to the concrete type \texttt{Vector\{Int\}} only if both the upper and lower bounds of \texttt{T} equal \texttt{Int}. We have not yet worked out a complete algorithm for this.



\hypertarget{37604590457653524}{}


\subsection{Introduction to the internal machinery}



Most operations for dealing with types are found in the files \texttt{jltypes.c} and \texttt{subtype.c}. A good way to start is to watch subtyping in action. Build Julia with \texttt{make debug} and fire up Julia within a debugger. \href{@ref}{gdb debugging tips} has some tips which may be useful.



Because the subtyping code is used heavily in the REPL itself–and hence breakpoints in this code get triggered often–it will be easiest if you make the following definition:




\begin{minted}{jlcon}
julia> function mysubtype(a,b)
           ccall(:jl_breakpoint, Cvoid, (Any,), nothing)
           a <: b
       end
\end{minted}



and then set a breakpoint in \texttt{jl\_breakpoint}.  Once this breakpoint gets triggered, you can set breakpoints in other functions.



As a warm-up, try the following:




\begin{minted}{julia}
mysubtype(Tuple{Int,Float64}, Tuple{Integer,Real})
\end{minted}



We can make it more interesting by trying a more complex case:




\begin{minted}{julia}
mysubtype(Tuple{Array{Int,2}, Int8}, Tuple{Array{T}, T} where T)
\end{minted}



\hypertarget{9271541181781970079}{}


\subsection{Subtyping and method sorting}



The \texttt{type\_morespecific} functions are used for imposing a partial order on functions in method tables (from most-to-least specific). Specificity is strict; if \texttt{a} is more specific than \texttt{b}, then \texttt{a} does not equal \texttt{b} and \texttt{b} is not more specific than \texttt{a}.



If \texttt{a} is a strict subtype of \texttt{b}, then it is automatically considered more specific. From there, \texttt{type\_morespecific} employs some less formal rules. For example, \texttt{subtype} is sensitive to the number of arguments, but \texttt{type\_morespecific} may not be. In particular, \texttt{Tuple\{Int,AbstractFloat\}} is more specific than \texttt{Tuple\{Integer\}}, even though it is not a subtype.  (Of \texttt{Tuple\{Int,AbstractFloat\}} and \texttt{Tuple\{Integer,Float64\}}, neither is more specific than the other.)  Likewise, \texttt{Tuple\{Int,Vararg\{Int\}\}} is not a subtype of \texttt{Tuple\{Integer\}}, but it is considered more specific. However, \texttt{morespecific} does get a bonus for length: in particular, \texttt{Tuple\{Int,Int\}} is more specific than \texttt{Tuple\{Int,Vararg\{Int\}\}}.



If you{\textquotesingle}re debugging how methods get sorted, it can be convenient to define the function:




\begin{minted}{julia}
type_morespecific(a, b) = ccall(:jl_type_morespecific, Cint, (Any,Any), a, b)
\end{minted}



which allows you to test whether tuple type \texttt{a} is more specific than tuple type \texttt{b}.



\hypertarget{5831288113328207392}{}


\section{Memory layout of Julia Objects}



\hypertarget{9050896398576860708}{}


\subsection{Object layout (\texttt{jl\_value\_t})}



The \texttt{jl\_value\_t} struct is the name for a block of memory owned by the Julia Garbage Collector, representing the data associated with a Julia object in memory. Absent any type information, it is simply an opaque pointer:




\begin{lstlisting}
typedef struct jl_value_t* jl_pvalue_t;
\end{lstlisting}



Each \texttt{jl\_value\_t} struct is contained in a \texttt{jl\_typetag\_t} struct that contains metadata information about the Julia object, such as its type and garbage collector (gc) reachability:




\begin{lstlisting}
typedef struct {
    opaque metadata;
    jl_value_t value;
} jl_typetag_t;
\end{lstlisting}



The type of any Julia object is an instance of a leaf \texttt{jl\_datatype\_t} object. The \texttt{jl\_typeof()} function can be used to query for it:




\begin{lstlisting}
jl_value_t *jl_typeof(jl_value_t *v);
\end{lstlisting}



The layout of the object depends on its type. Reflection methods can be used to inspect that layout. A field can be accessed by calling one of the get-field methods:




\begin{lstlisting}
jl_value_t *jl_get_nth_field_checked(jl_value_t *v, size_t i);
jl_value_t *jl_get_field(jl_value_t *o, char *fld);
\end{lstlisting}



If the field types are known, a priori, to be all pointers, the values can also be extracted directly as an array access:




\begin{lstlisting}
jl_value_t *v = value->fieldptr[n];
\end{lstlisting}



As an example, a {\textquotedbl}boxed{\textquotedbl} \texttt{uint16\_t} is stored as follows:




\begin{lstlisting}
struct {
    opaque metadata;
    struct {
        uint16_t data;        // -- 2 bytes
    } jl_value_t;
};
\end{lstlisting}



This object is created by \texttt{jl\_box\_uint16()}. Note that the \texttt{jl\_value\_t} pointer references the data portion, not the metadata at the top of the struct.



A value may be stored {\textquotedbl}unboxed{\textquotedbl} in many circumstances (just the data, without the metadata, and possibly not even stored but just kept in registers), so it is unsafe to assume that the address of a box is a unique identifier. The {\textquotedbl}egal{\textquotedbl} test (corresponding to the \texttt{===} function in Julia), should instead be used to compare two unknown objects for equivalence:




\begin{lstlisting}
int jl_egal(jl_value_t *a, jl_value_t *b);
\end{lstlisting}



This optimization should be relatively transparent to the API, since the object will be {\textquotedbl}boxed{\textquotedbl} on-demand, whenever a \texttt{jl\_value\_t} pointer is needed.



Note that modification of a \texttt{jl\_value\_t} pointer in memory is permitted only if the object is mutable. Otherwise, modification of the value may corrupt the program and the result will be undefined. The mutability property of a value can be queried for with:




\begin{lstlisting}
int jl_is_mutable(jl_value_t *v);
\end{lstlisting}



If the object being stored is a \texttt{jl\_value\_t}, the Julia garbage collector must be notified also:




\begin{lstlisting}
void jl_gc_wb(jl_value_t *parent, jl_value_t *ptr);
\end{lstlisting}



However, the \href{@ref}{Embedding Julia} section of the manual is also required reading at this point, for covering other details of boxing and unboxing various types, and understanding the gc interactions.



Mirror structs for some of the built-in types are \href{https://github.com/JuliaLang/julia/blob/master/src/julia.h}{defined in \texttt{julia.h}}. The corresponding global \texttt{jl\_datatype\_t} objects are created by \href{https://github.com/JuliaLang/julia/blob/master/src/jltypes.c}{\texttt{jl\_init\_types} in \texttt{jltypes.c}}.



\hypertarget{660883080955975432}{}


\subsection{Garbage collector mark bits}



The garbage collector uses several bits from the metadata portion of the \texttt{jl\_typetag\_t} to track each object in the system. Further details about this algorithm can be found in the comments of the \href{https://github.com/JuliaLang/julia/blob/master/src/gc.c}{garbage collector implementation in \texttt{gc.c}}.



\hypertarget{14420252243983980472}{}


\subsection{Object allocation}



Most new objects are allocated by \texttt{jl\_new\_structv()}:




\begin{lstlisting}
jl_value_t *jl_new_struct(jl_datatype_t *type, ...);
jl_value_t *jl_new_structv(jl_datatype_t *type, jl_value_t **args, uint32_t na);
\end{lstlisting}



Although, \hyperlink{12980593021531333073}{\texttt{isbits}} objects can be also constructed directly from memory:




\begin{lstlisting}
jl_value_t *jl_new_bits(jl_value_t *bt, void *data)
\end{lstlisting}



And some objects have special constructors that must be used instead of the above functions:



Types:




\begin{lstlisting}
jl_datatype_t *jl_apply_type(jl_datatype_t *tc, jl_tuple_t *params);
jl_datatype_t *jl_apply_array_type(jl_datatype_t *type, size_t dim);
\end{lstlisting}



While these are the most commonly used options, there are more low-level constructors too, which you can find declared in \href{https://github.com/JuliaLang/julia/blob/master/src/julia.h}{\texttt{julia.h}}. These are used in \texttt{jl\_init\_types()} to create the initial types needed to bootstrap the creation of the Julia system image.



Tuples:




\begin{lstlisting}
jl_tuple_t *jl_tuple(size_t n, ...);
jl_tuple_t *jl_tuplev(size_t n, jl_value_t **v);
jl_tuple_t *jl_alloc_tuple(size_t n);
\end{lstlisting}



The representation of tuples is highly unique in the Julia object representation ecosystem. In some cases, a \hyperlink{12342862450082530092}{\texttt{Base.tuple()}} object may be an array of pointers to the objects contained by the tuple equivalent to:




\begin{lstlisting}
typedef struct {
    size_t length;
    jl_value_t *data[length];
} jl_tuple_t;
\end{lstlisting}



However, in other cases, the tuple may be converted to an anonymous \hyperlink{12980593021531333073}{\texttt{isbits}} type and stored unboxed, or it may not stored at all (if it is not being used in a generic context as a \texttt{jl\_value\_t*}).



Symbols:




\begin{lstlisting}
jl_sym_t *jl_symbol(const char *str);
\end{lstlisting}



Functions and MethodInstance:




\begin{lstlisting}
jl_function_t *jl_new_generic_function(jl_sym_t *name);
jl_method_instance_t *jl_new_method_instance(jl_value_t *ast, jl_tuple_t *sparams);
\end{lstlisting}



Arrays:




\begin{lstlisting}
jl_array_t *jl_new_array(jl_value_t *atype, jl_tuple_t *dims);
jl_array_t *jl_new_arrayv(jl_value_t *atype, ...);
jl_array_t *jl_alloc_array_1d(jl_value_t *atype, size_t nr);
jl_array_t *jl_alloc_array_2d(jl_value_t *atype, size_t nr, size_t nc);
jl_array_t *jl_alloc_array_3d(jl_value_t *atype, size_t nr, size_t nc, size_t z);
jl_array_t *jl_alloc_vec_any(size_t n);
\end{lstlisting}



Note that many of these have alternative allocation functions for various special-purposes. The list here reflects the more common usages, but a more complete list can be found by reading the \href{https://github.com/JuliaLang/julia/blob/master/src/julia.h}{\texttt{julia.h} header file}.



Internal to Julia, storage is typically allocated by \texttt{newstruct()} (or \texttt{newobj()} for the special types):




\begin{lstlisting}
jl_value_t *newstruct(jl_value_t *type);
jl_value_t *newobj(jl_value_t *type, size_t nfields);
\end{lstlisting}



And at the lowest level, memory is getting allocated by a call to the garbage collector (in \texttt{gc.c}), then tagged with its type:




\begin{lstlisting}
jl_value_t *jl_gc_allocobj(size_t nbytes);
void jl_set_typeof(jl_value_t *v, jl_datatype_t *type);
\end{lstlisting}



Note that all objects are allocated in multiples of 4 bytes and aligned to the platform pointer size. Memory is allocated from a pool for smaller objects, or directly with \texttt{malloc()} for large objects.



\begin{quote}
\textbf{Singleton Types}

Singleton types have only one instance and no data fields. Singleton instances have a size of 0 bytes, and consist only of their metadata. e.g. \texttt{nothing::Nothing}.

See \hyperlink{14008188290941962431}{Singleton Types} and \href{@ref}{Nothingness and missing values}

\end{quote}


\hypertarget{10481677756025410412}{}


\section{Julia 代码的 eval}



学习 Julia 语言如何运行代码的最难的一部分是 学习如何让所有的小部分工作协同工作来执行一段代码。 



每个代码块通常会通过许多步骤来执行，在转变为期望的结果之前（但愿如此）。并且你可能不熟悉它们的名称，例如（非特定顺序）： flisp，AST，C++，LLVM，\texttt{eval}，\texttt{typeinf}，\texttt{macroexpand}，sysimg（或 system image），启动，变异，解析，执行，即时编译器，解释器解释，装箱，拆箱，内部函数，原始函数



\begin{quote}
\textbf{Definitions}

\begin{itemize}
\item REPL

REPL 表示 读取-求值-输出-循环（Read-Eval-Print Loop）。 我们管这个命令行环境的简称就叫REPL。


\item AST

抽象语法树（Abstract Syntax Tree）是代码结构的数据表现。在这种表现形式下代码被符号化，因此更加方便操作和执行。

\end{itemize}
\end{quote}


\hypertarget{12349293482799060845}{}


\subsection{Julia Execution}



整个进程的千里之行如下：



\begin{itemize}
\item[1.  ] 用户打开了 \texttt{julia}。


\item[2.  ] The C function \texttt{main()} from \texttt{ui/repl.c} gets called. This function processes the command line arguments, filling in the \texttt{jl\_options} struct and setting the variable \texttt{ARGS}. It then initializes 在 \texttt{ui/repl.c} 中的 C 语言的函数 \texttt{main()} 被调用。这个函数处理命令行参数，填充到 \texttt{jl\_options} 结构图并且设置变了 \texttt{ARGS} 。接下来初始化 Julia (通过调用  \href{https://github.com/JuliaLang/julia/blob/master/src/task.c}{\texttt{julia\_init} in \texttt{task.c}} which may load a previously compiled \hyperlink{6082338945993475185}{sysimg}). Finally, it passes off control to Julia by calling \href{https://github.com/JuliaLang/julia/blob/master/base/client.jl}{\texttt{Base.\_start()}}.


\item[3.  ] When \texttt{\_start()} takes over control, the subsequent sequence of commands depends on the command line arguments given. For example, if a filename was supplied, it will proceed to execute that file. Otherwise, it will start an interactive REPL.


\item[4.  ] Skipping the details about how the REPL interacts with the user, let{\textquotesingle}s just say the program ends up with a block of code that it wants to run.


\item[5.  ] If the block of code to run is in a file, \href{https://github.com/JuliaLang/julia/blob/master/src/toplevel.c}{\texttt{jl\_load(char *filename)}} gets invoked to load the file and \hyperlink{14838640034628506824}{parse} it. Each fragment of code is then passed to \texttt{eval} to execute.


\item[6.  ] Each fragment of code (or AST), is handed off to \hyperlink{7507639810592563424}{\texttt{eval()}} to turn into results.


\item[7.  ] \hyperlink{7507639810592563424}{\texttt{eval()}} takes each code fragment and tries to run it in \href{https://github.com/JuliaLang/julia/blob/master/src/toplevel.c}{\texttt{jl\_toplevel\_eval\_flex()}}.


\item[8.  ] \texttt{jl\_toplevel\_eval\_flex()} decides whether the code is a {\textquotedbl}toplevel{\textquotedbl} action (such as \texttt{using} or \texttt{module}), which would be invalid inside a function. If so, it passes off the code to the toplevel interpreter.


\item[9.  ] \texttt{jl\_toplevel\_eval\_flex()} then \hyperlink{16669853702383402486}{expands} the code to eliminate any macros and to {\textquotedbl}lower{\textquotedbl} the AST to make it simpler to execute.


\item[10. ] \texttt{jl\_toplevel\_eval\_flex()} then uses some simple heuristics to decide whether to JIT compiler the  AST or to interpret it directly.


\item[11. ] The bulk of the work to interpret code is handled by \href{https://github.com/JuliaLang/julia/blob/master/src/interpreter.c}{\texttt{eval} in \texttt{interpreter.c}}.


\item[12. ] If instead, the code is compiled, the bulk of the work is handled by \texttt{codegen.cpp}. Whenever a  Julia function is called for the first time with a given set of argument types, \hyperlink{6510123671388929580}{type inference}  will be run on that function. This information is used by the \hyperlink{526576549562645049}{codegen} step to generate  faster code.


\item[13. ] Eventually, the user quits the REPL, or the end of the program is reached, and the \texttt{\_start()}  method returns.


\item[14. ] Just before exiting, \texttt{main()} calls \href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{\texttt{jl\_atexit\_hook(exit\_code)}}.  This calls \texttt{Base.\_atexit()} (which calls any functions registered to \hyperlink{17479944696971324992}{\texttt{atexit()}} inside  Julia). Then it calls \href{https://github.com/JuliaLang/julia/blob/master/src/gc.c}{\texttt{jl\_gc\_run\_all\_finalizers()}}.  Finally, it gracefully cleans up all \texttt{libuv} handles and waits for them to flush and close.

\end{itemize}


\hypertarget{6801832859572424777}{}


\subsection{Parsing}



The Julia parser is a small lisp program written in femtolisp, the source-code for which is distributed inside Julia in \href{https://github.com/JuliaLang/julia/tree/master/src/flisp}{src/flisp}.



The interface functions for this are primarily defined in \href{https://github.com/JuliaLang/julia/blob/master/src/jlfrontend.scm}{\texttt{jlfrontend.scm}}. The code in \href{https://github.com/JuliaLang/julia/blob/master/src/ast.c}{\texttt{ast.c}} handles this handoff on the Julia side.



The other relevant files at this stage are \href{https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm}{\texttt{julia-parser.scm}}, which handles tokenizing Julia code and turning it into an AST, and \href{https://github.com/JuliaLang/julia/blob/master/src/julia-syntax.scm}{\texttt{julia-syntax.scm}}, which handles transforming complex AST representations into simpler, {\textquotedbl}lowered{\textquotedbl} AST representations which are more suitable for analysis and execution.



If you want to test the parser without re-building Julia in its entirety, you can run the frontend on its own as follows:




\begin{lstlisting}
$ cd src
$ flisp/flisp
> (load "jlfrontend.scm")
> (jl-parse-file "<filename>")
\end{lstlisting}



\hypertarget{13925460440315781353}{}


\subsection{Macro Expansion}



When \hyperlink{7507639810592563424}{\texttt{eval()}} encounters a macro, it expands that AST node before attempting to evaluate the expression. Macro expansion involves a handoff from \hyperlink{7507639810592563424}{\texttt{eval()}} (in Julia), to the parser function \texttt{jl\_macroexpand()} (written in \texttt{flisp}) to the Julia macro itself (written in - what else - Julia) via \texttt{fl\_invoke\_julia\_macro()}, and back.



Typically, macro expansion is invoked as a first step during a call to \hyperlink{6644553029841096787}{\texttt{Meta.lower()}}/\texttt{jl\_expand()}, although it can also be invoked directly by a call to \hyperlink{8018172489611994488}{\texttt{macroexpand()}}/\texttt{jl\_macroexpand()}.



\hypertarget{5553247398724394157}{}


\subsection{Type Inference}



Type inference is implemented in Julia by \href{https://github.com/JuliaLang/julia/blob/master/base/compiler/typeinfer.jl}{\texttt{typeinf()} in \texttt{compiler/typeinfer.jl}}. Type inference is the process of examining a Julia function and determining bounds for the types of each of its variables, as well as bounds on the type of the return value from the function. This enables many future optimizations, such as unboxing of known immutable values, and compile-time hoisting of various run-time operations such as computing field offsets and function pointers. Type inference may also include other steps such as constant propagation and inlining.



\begin{quote}
\textbf{More Definitions}

\begin{itemize}
\item JIT

Just-In-Time Compilation The process of generating native-machine code into memory right when it is needed.


\item LLVM

Low-Level Virtual Machine (a compiler) The Julia JIT compiler is a program/library called libLLVM. Codegen in Julia refers both to the process of taking a Julia AST and turning it into LLVM instructions, and the process of LLVM optimizing that and turning it into native assembly instructions.


\item C++

The programming language that LLVM is implemented in, which means that codegen is also implemented in this language. The rest of Julia{\textquotesingle}s library is implemented in C, in part because its smaller feature set makes it more usable as a cross-language interface layer.


\item box

This term is used to describe the process of taking a value and allocating a wrapper around the data that is tracked by the garbage collector (gc) and is tagged with the object{\textquotesingle}s type.


\item unbox

The reverse of boxing a value. This operation enables more efficient manipulation of data when the type of that data is fully known at compile-time (through type inference).


\item generic function

A Julia function composed of multiple {\textquotedbl}methods{\textquotedbl} that are selected for dynamic dispatch based on the argument type-signature


\item anonymous function or {\textquotedbl}method{\textquotedbl}

A Julia function without a name and without type-dispatch capabilities


\item primitive function

A function implemented in C but exposed in Julia as a named function {\textquotedbl}method{\textquotedbl} (albeit without generic function dispatch capabilities, similar to a anonymous function)


\item intrinsic function

A low-level operation exposed as a function in Julia. These pseudo-functions implement operations on raw bits such as add and sign extend that cannot be expressed directly in any other way. Since they operate on bits directly, they must be compiled into a function and surrounded by a call to \texttt{Core.Intrinsics.box(T, ...)} to reassign type information to the value.

\end{itemize}
\end{quote}


\hypertarget{16251221274618963128}{}


\subsection{JIT Code Generation}



Codegen is the process of turning a Julia AST into native machine code.



The JIT environment is initialized by an early call to \href{https://github.com/JuliaLang/julia/blob/master/src/codegen.cpp}{\texttt{jl\_init\_codegen} in \texttt{codegen.cpp}}.



On demand, a Julia method is converted into a native function by the function \texttt{emit\_function(jl\_method\_instance\_t*)}. (note, when using the MCJIT (in LLVM v3.4+), each function must be JIT into a new module.) This function recursively calls \texttt{emit\_expr()} until the entire function has been emitted.



Much of the remaining bulk of this file is devoted to various manual optimizations of specific code patterns. For example, \texttt{emit\_known\_call()} knows how to inline many of the primitive functions (defined in \href{https://github.com/JuliaLang/julia/blob/master/src/builtins.c}{\texttt{builtins.c}}) for various combinations of argument types.



Other parts of codegen are handled by various helper files:



\begin{itemize}
\item \href{https://github.com/JuliaLang/julia/blob/master/src/debuginfo.cpp}{\texttt{debuginfo.cpp}}

Handles backtraces for JIT functions


\item \href{https://github.com/JuliaLang/julia/blob/master/src/ccall.cpp}{\texttt{ccall.cpp}}

Handles the ccall and llvmcall FFI, along with various \texttt{abi\_*.cpp} files


\item \href{https://github.com/JuliaLang/julia/blob/master/src/intrinsics.cpp}{\texttt{intrinsics.cpp}}

Handles the emission of various low-level intrinsic functions

\end{itemize}


\begin{quote}
\textbf{Bootstrapping}

The process of creating a new system image is called {\textquotedbl}bootstrapping{\textquotedbl}.

The etymology of this word comes from the phrase {\textquotedbl}pulling oneself up by the bootstraps{\textquotedbl}, and refers to the idea of starting from a very limited set of available functions and definitions and ending with the creation of a full-featured environment.

\end{quote}


\hypertarget{9959120445934014648}{}


\subsection{System Image}



The system image is a precompiled archive of a set of Julia files. The \texttt{sys.ji} file distributed with Julia is one such system image, generated by executing the file \href{https://github.com/JuliaLang/julia/blob/master/base/sysimg.jl}{\texttt{sysimg.jl}}, and serializing the resulting environment (including Types, Functions, Modules, and all other defined values) into a file. Therefore, it contains a frozen version of the \texttt{Main}, \texttt{Core}, and \texttt{Base} modules (and whatever else was in the environment at the end of bootstrapping). This serializer/deserializer is implemented by \href{https://github.com/JuliaLang/julia/blob/master/src/staticdata.c}{\texttt{jl\_save\_system\_image}/\texttt{jl\_restore\_system\_image} in \texttt{staticdata.c}}.



If there is no sysimg file (\texttt{jl\_options.image\_file == NULL}), this also implies that \texttt{--build} was given on the command line, so the final result should be a new sysimg file. During Julia initialization, minimal \texttt{Core} and \texttt{Main} modules are created. Then a file named \texttt{boot.jl} is evaluated from the current directory. Julia then evaluates any file given as a command line argument until it reaches the end. Finally, it saves the resulting environment to a {\textquotedbl}sysimg{\textquotedbl} file for use as a starting point for a future Julia run.



\hypertarget{290466951415325789}{}


\section{Calling Conventions}



Julia uses three calling conventions for four distinct purposes:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Name & Prefix & Purpose \\
\hline
Native & \texttt{julia\_} & Speed via specialized signatures \\
\hline
JL Call & \texttt{jlcall\_} & Wrapper for generic calls \\
\hline
JL Call & \texttt{jl\_} & Builtins \\
\hline
C ABI & \texttt{jlcapi\_} & Wrapper callable from C \\
\hline
\end{tabulary}

\end{table}



\hypertarget{4788166660204734834}{}


\subsection{Julia Native Calling Convention}



The native calling convention is designed for fast non-generic calls. It usually uses a specialized signature.



\begin{itemize}
\item LLVM ghosts (zero-length types) are omitted.


\item LLVM scalars and vectors are passed by value.


\item LLVM aggregates (arrays and structs) are passed by reference.

\end{itemize}


A small return values is returned as LLVM return values. A large return values is returned via the {\textquotedbl}structure return{\textquotedbl} (\texttt{sret}) convention, where the caller provides a pointer to a return slot.



An argument or return values that is a homogeneous tuple is sometimes represented as an LLVM vector instead of an LLVM array.



\hypertarget{10962628785392118342}{}


\subsection{JL Call Convention}



The JL Call convention is for builtins and generic dispatch. Hand-written functions using this convention are declared via the macro \texttt{JL\_CALLABLE}. The convention uses exactly 3 parameters:



\begin{itemize}
\item \texttt{F}  - Julia representation of function that is being applied


\item \texttt{args} - pointer to array of pointers to boxes


\item \texttt{nargs} - length of the array

\end{itemize}


The return value is a pointer to a box.



\hypertarget{16764615067045412370}{}


\subsection{C ABI}



C ABI wrappers enable calling Julia from C. The wrapper calls a function using the native calling convention.



Tuples are always represented as C arrays.



\hypertarget{7542203617935209330}{}


\section{High-level Overview of the Native-Code Generation Process}



\hypertarget{6164157073495091365}{}


\subsection{Representation of Pointers}



When emitting code to an object file, pointers will be emitted as relocations. The deserialization code will ensure any object that pointed to one of these constants gets recreated and contains the right runtime pointer.



Otherwise, they will be emitted as literal constants.



To emit one of these objects, call \texttt{literal\_pointer\_val}. It{\textquotesingle}ll handle tracking the Julia value and the LLVM global, ensuring they are valid both for the current runtime and after deserialization.



When emitted into the object file, these globals are stored as references in a large \texttt{gvals} table. This allows the deserializer to reference them by index, and implement a custom manual mechanism similar to a Global Offset Table (GOT) to restore them.



Function pointers are handled similarly. They are stored as values in a large \texttt{fvals} table. Like globals, this allows the deserializer to reference them by index.



Note that \texttt{extern} functions are handled separately, with names, via the usual symbol resolution mechanism in the linker.



Note too that \texttt{ccall} functions are also handled separately, via a manual GOT and Procedure Linkage Table (PLT).



\hypertarget{9352283582715079729}{}


\subsection{Representation of Intermediate Values}



Values are passed around in a \texttt{jl\_cgval\_t} struct. This represents an R-value, and includes enough information to determine how to assign or pass it somewhere.



They are created via one of the helper constructors, usually: \texttt{mark\_julia\_type} (for immediate values) and \texttt{mark\_julia\_slot} (for pointers to values).



The function \texttt{convert\_julia\_type} can transform between any two types. It returns an R-value with \texttt{cgval.typ} set to \texttt{typ}. It{\textquotesingle}ll cast the object to the requested representation, making heap boxes, allocating stack copies, and computing tagged unions as needed to change the representation.



By contrast \texttt{update\_julia\_type} will change \texttt{cgval.typ} to \texttt{typ}, only if it can be done at zero-cost (i.e. without emitting any code).



\hypertarget{3738811278233217209}{}


\subsection{Union representation}



Inferred union types may be stack allocated via a tagged type representation.



The primitive routines that need to be able to handle tagged unions are:



\begin{itemize}
\item mark-type


\item load-local


\item store-local


\item isa


\item is


\item emit\_typeof


\item emit\_sizeof


\item boxed


\item unbox


\item specialized cc-ret

\end{itemize}


Everything else should be possible to handle in inference by using these primitives to implement union-splitting.



The representation of the tagged-union is as a pair of \texttt{< void* union, byte selector >}. The selector is fixed-size as \texttt{byte \& 0x7f}, and will union-tag the first 126 isbits. It records the one-based depth-first count into the type-union of the isbits objects inside. An index of zero indicates that the \texttt{union*} is actually a tagged heap-allocated \texttt{jl\_value\_t*}, and needs to be treated as normal for a boxed object rather than as a tagged union.



The high bit of the selector (\texttt{byte \& 0x80}) can be tested to determine if the \texttt{void*} is actually a heap-allocated (\texttt{jl\_value\_t*}) box, thus avoiding the cost of re-allocating a box, while maintaining the ability to efficiently handle union-splitting based on the low bits.



It is guaranteed that \texttt{byte \& 0x7f} is an exact test for the type, if the value can be represented by a tag – it will never be marked \texttt{byte = 0x80}. It is not necessary to also test the type-tag when testing \texttt{isa}.



The \texttt{union*} memory region may be allocated at \emph{any} size. The only constraint is that it is big enough to contain the data currently specified by \texttt{selector}. It might not be big enough to contain the union of all types that could be stored there according to the associated Union type field. Use appropriate care when copying.



\hypertarget{5801902447580234191}{}


\subsection{Specialized Calling Convention Signature Representation}



A \texttt{jl\_returninfo\_t} object describes the calling convention details of any callable.



If any of the arguments or return type of a method can be represented unboxed, and the method is not varargs, it{\textquotesingle}ll be given an optimized calling convention signature based on its \texttt{specTypes} and \texttt{rettype} fields.



The general principles are that:



\begin{itemize}
\item Primitive types get passed in int/float registers.


\item Tuples of VecElement types get passed in vector registers.


\item Structs get passed on the stack.


\item Return values are handle similarly to arguments, with a size-cutoff at which they will instead be returned via a hidden sret argument.

\end{itemize}


The total logic for this is implemented by \texttt{get\_specsig\_function} and \texttt{deserves\_sret}.



Additionally, if the return type is a union, it may be returned as a pair of values (a pointer and a tag). If the union values can be stack-allocated, then sufficient space to store them will also be passed as a hidden first argument. It is up to the callee whether the returned pointer will point to this space, a boxed object, or even other constant memory.



\hypertarget{3539827185509825766}{}


\section{Julia 函数}



本文档将解释函数、方法定义以及方法表是如何工作的。



\hypertarget{6316722227009052903}{}


\subsection{方法表}



Julia 中的每个函数都是泛型函数。泛型函数在概念上是单个函数，但由许多定义或方法组成。泛型函数的方法储存在方法表中。方法表（类型 \texttt{MethodTable}）与 \texttt{TypeName} 相关。\texttt{TypeName} 描述了一系列参数化类型。例如，\texttt{Complex\{Float32\}} 和 \texttt{Complex\{Float64\}} 共享相同的 type name 对象 \texttt{Complex}。



Julia 中的所有对象都可能是可调用的，因为每个对象都有类型，而类型又有 \texttt{TypeName}。



\hypertarget{13252419531822255004}{}


\subsection{函数调用}



给定调用 \texttt{f(x,y)}，会执行以下步骤：首先，用 \texttt{typeof(f).name.mt} 访问要使用的方法表。其次，生成一个参数元组类型 \texttt{Tuple\{typeof(f), typeof(x), typeof(y)\}}。请注意，函数本身的类型是第一个元素。这因为该类型可能有参数，所以需要参与派发。这个元组类型会在方法表中查找。



这个派发过程由 \texttt{jl\_apply\_generic} 执行，它有两个参数：一个指向由值 f、x 和 y 组成的数组的指针，以及值的数量（此例中是 3）。



在整个系统中，处理函数和参数列表的 API 有两种：一种单独接收函数和参数，一种接收一个单独的参数结构。在第一种 API 中，「参数」部分\emph{不}包含函数的相关信息，因为它是单独传递的。在第二种 API 中，函数是参数结构的第一个元素。



例如，以下用于执行调用的函数只接收 \texttt{args} 指针，因此 args 数组的第一个元素将会是要调用的函数：




\begin{lstlisting}
jl_value_t *jl_apply(jl_value_t **args, uint32_t nargs)
\end{lstlisting}



这个用于相同功能的入口点单独接收该函数，因此 \texttt{args} 数组中不包含该函数：




\begin{lstlisting}
jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs);
\end{lstlisting}



\hypertarget{12335264465348807608}{}


\subsection{添加方法}



在上述派发过程中，添加一个新方法在概念上所需的只是（1）一个元组类型，以及（2）方法体的代码。\texttt{jl\_method\_def} 实现了此操作。\texttt{jl\_first\_argument\_datatype} 会被调用，用来从第一个参数的类型中提取相关的方法表。这比派发期间的相应过程复杂得多，因为参数元组类型可能是抽象类型。例如，我们可以定义：




\begin{minted}{julia}
(::Union{Foo{Int},Foo{Int8}})(x) = 0
\end{minted}



这是可行的，因为所有可能的匹配方法都属于同一方法表。



\hypertarget{4974882052749632871}{}


\subsection{创建泛型函数}



因为每个对象都是可调用的，所以创建泛型函数不需要特殊的东西。因此，\texttt{jl\_new\_generic\_function} 只是创建一个新的 \texttt{Function} 的单态类型（大小为 0）并返回它的实例。函数可有一个帮助记忆的「显示名称」，用于调试信息和打印对象。例如，\texttt{Base.sin} 的名称为 \texttt{sin}。按照约定，所创建\emph{类型}的名称与函数名称相同，带前缀 \texttt{\#}。所以 \texttt{typeof(sin)} 即 \texttt{Base.\#sin}。



\hypertarget{2172965036514898807}{}


\subsection{闭包}



闭包只是一个可调用对象，其字段名称对应于被捕获的变量。例如，以下代码：




\begin{minted}{julia}
function adder(x)
    return y->x+y
end
\end{minted}



（大致）降低为：




\begin{minted}{julia}
struct ##1{T}
    x::T
end

(_::##1)(y) = _.x + y

function adder(x)
    return ##1(x)
end
\end{minted}



\hypertarget{5490460475085720426}{}


\subsection{构造函数}



构造函数调用只是对类型的调用。\texttt{Type} 的方法表包含所有的构造函数定义。\texttt{Type} 的所有子类型（\texttt{Type}、\texttt{UnionAll}、\texttt{Union} 和 \texttt{DataType}）目前通过特殊的安排方式共享一个方法表。



\hypertarget{3874805480384047373}{}


\subsection{内置函数}



「内置」函数定义在 \texttt{Core} 模块中，有：




\begin{lstlisting}
=== typeof sizeof <: isa typeassert throw tuple getfield setfield! fieldtype
nfields isdefined arrayref arrayset arraysize applicable invoke apply_type _apply
_expr svec
\end{lstlisting}



这些都是单态对象，其类型为 \texttt{Builtin} 的子类型，而或后者为 \texttt{Function} 的子类型。它们的用处是在运行时暴露遵循「jlcall」调用约定的入口点。




\begin{lstlisting}
jl_value_t *(jl_value_t*, jl_value_t**, uint32_t)
\end{lstlisting}



内建函数的方法表是空的。相反地，它们具有单独的 catch-all 方法缓存条目（\texttt{Tuple\{Vararg\{Any\}\}}），其 jlcall fptr 指向正确的函数。这是一种 hack，但效果相当不错。



\hypertarget{8084690442149965313}{}


\subsection{关键字参数}



关键字参数的工作方式是将每个具有关键字参数的方法表与一个特殊的隐藏函数对象相关联。该函数称为「keyword argument sorter」、「keyword sorter」或「kwsorter」，存储在 \texttt{MethodTable} 对象的 \texttt{kwsorter} 字段中。在 kwsorter 函数的每个定义与通常的方法表中的某个函数具有相同的参数，除了前面还有一个 \texttt{NamedTuple} 参数，该参数给出所传递关键字参数的名称和值。kwsorter 的作用是根据名称将关键字参数移到预先要求的位置，并对任何所需的默认值表达式进行求值和替换。其返回结果是一个通常的位置参数列表，接着会被传递给另一个由编译器生成的函数。



理解该过程的最简单方法是查看关键字参数方法的定义的降低方式。代码：




\begin{minted}{julia}
function circle(center, radius; color = black, fill::Bool = true, options...)
    # draw
end
\end{minted}



实际上生成\emph{三个}方法定义。第一个方法是一个接收所有参数（包括关键字参数）作为其位置参数的函数，其代码包含该方法体。它有一个自动生成的名称：




\begin{minted}{julia}
function #circle#1(color, fill::Bool, options, circle, center, radius)
    # draw
end
\end{minted}



第二个方法是原始 \texttt{circle} 函数的普通定义，负责处理没有传递关键字参数的情况：




\begin{minted}{julia}
function circle(center, radius)
    #circle#1(black, true, pairs(NamedTuple()), circle, center, radius)
end
\end{minted}



这只是派发到第一个方法，传递默认值。\texttt{pairs} 应用于其余的参数组成的具名元组，以提供键值对迭代。请注意，如果方法不接受其余的关键字参数，那么此参数不存在。



最后，kwsorter 定义为：




\begin{lstlisting}
function (::Core.kwftype(typeof(circle)))(kws, circle, center, radius)
    if haskey(kws, :color)
        color = kws.color
    else
        color = black
    end
    # etc.

    # put remaining kwargs in `options`
    options = structdiff(kws, NamedTuple{(:color, :fill)})

    # if the method doesn't accept rest keywords, throw an error
    # unless `options` is empty

    #circle#1(color, fill, pairs(options), circle, center, radius)
end
\end{lstlisting}



函数 \texttt{Core.kwftype(t)} 创建字段 \texttt{t.name.mt.kwsorter}（如果它未被创建），并返回该函数的类型。



此设计的特点是不使用关键字参数的调用点不需要特殊处理；这一切的工作方式好像它们根本不是语言的一部分。不使用关键字参数的调用点直接派发到被调用函数的 kwsorter。例如，调用：




\begin{minted}{julia}
circle((0,0), 1.0, color = red; other...)
\end{minted}



降低为：




\begin{minted}{julia}
kwfunc(circle)(merge((color = red,), other), circle, (0,0), 1.0)
\end{minted}



\texttt{kwfunc}（也在 \texttt{Core} 中）可获取被调用函数的 kwsorter。关键字 splatting 函数（编写为 \texttt{other...}）调用具名元组 \texttt{merge} 函数。此函数进一步解包了 \texttt{other} 的每个\emph{元素}，预期中每个元素包含两个值（一个符号和一个值）。当然，如果所有 splatted 参数都是具名元组，则可使用更高效的实现。请注意，原来的 \texttt{circle} 被传递，以处理闭包。



\hypertarget{1871194914272945034}{}


\subsection{Compiler efficiency issues}



为每个函数生成新类型在与 Julia 的「默认专门化所有参数」这一设计理念结合使用时，可能对编译器资源的使用产生严重后果。实际上，此设计的初始实现经历了更长的测试和构造时间、高内存占用以及比基线大近乎 2 倍的系统镜像。在一个幼稚的实现中，该问题非常严重，以至于系统几乎无法使用。需要进行几项重要的优化才能使设计变得可行。



第一个问题是函数值参数的不同值导致函数的过度专门化。许多函数只是将参数「传递」到其它地方，例如，到另一个函数或存储位置。这种函数不需要为每个可能传入的闭包专门化。幸运的是，这种情况很容易区分，只需考虑函数是否\emph{调用}它的某个参数（即，参数出现在某处的「头部位置」）。性能关键的高阶函数，如 \texttt{map}，肯定会直接调用它们的参数函数，因此仍然会按预期进行专门化。此优化通过在前端记录 \texttt{analyze-variables} 传递期间所调用的参数来实现。当 \texttt{cache\_method} 看到某个在 \texttt{Function} 类型层次结构的参数传递到声明为 \texttt{Any} 或 \texttt{Function} 的槽时，它的行为就好像应用了 \texttt{@nospecialize} 注释一样。这种启发式方法在实践中似乎非常有效。



下一个问题涉及方法缓存哈希表的结构。经验研究表明，绝大多数动态分派调用只涉及一个或两个元素。反过来看，只考虑第一个元素便可解决许多这些情况。（旁白：单派发的支持者根本不会对此感到惊讶。但是，这个观点意味着「多重派发在实践中很容易优化」，因此我们应该使用它，而\emph{不是}「我们应该使用单派发」！）因此，方法缓存使用第一个参数作为其主键。但请注意，这对应于函数调用的元组类型的\emph{第二个}元素（第一个元素是函数本身的类型）。通常，头部位置的类型非常少变化——实际上，大多数函数属于没有参数的单态类型。但是，构造函数不是这种情况，一个方法表便保存了所有类型的构造函数。因此，\texttt{Type} 方法表是特殊的，使用元组类型的\emph{第一个}元素而不是第二个。



前端为所有闭包生成类型声明。起初，这通过生成通常的类型声明来实现。但是，这产生了大量的构造函数，这些构造函数全都很简单（只是将所有参数传递给 \hyperlink{13888762393600028594}{\texttt{new}}）。因为方法是部分排序的，所以插入所有这些方法是 O(n{\textasciicircum}2)，此外要保留的方法实在太多了。这可通过直接生成 \texttt{struct\_type} 表达式（绕过默认的构造函数生成）并直接使用 \texttt{new} 来创建闭包的实例来优化。这事并不漂亮，但你需要做你该做的。



下个问题是 \texttt{@test} 宏，它为每个测试用例生成一个 0 参数闭包。这不是必需的，因为每个用例只需运行一次。因此，\texttt{@test} 被改写以展开到一个 try-catch 块中，该块记录测试结果（true、false 或所引发的异常）并对它调用测试套件处理程序。



\hypertarget{3626588894035984514}{}


\section{笛卡尔}



The (non-exported) Cartesian module provides macros that facilitate writing multidimensional algorithms. Most often you can write such algorithms with \href{https://julialang.org/blog/2016/02/iteration}{straightforward techniques}; however, there are a few cases where \texttt{Base.Cartesian} is still useful or necessary.



\hypertarget{10560451956896766301}{}


\subsection{Principles of usage}



A simple example of usage is:




\begin{minted}{julia}
@nloops 3 i A begin
    s += @nref 3 A i
end
\end{minted}



which generates the following code:




\begin{minted}{julia}
for i_3 = axes(A, 3)
    for i_2 = axes(A, 2)
        for i_1 = axes(A, 1)
            s += A[i_1, i_2, i_3]
        end
    end
end
\end{minted}



In general, Cartesian allows you to write generic code that contains repetitive elements, like the nested loops in this example.  Other applications include repeated expressions (e.g., loop unwinding) or creating function calls with variable numbers of arguments without using the {\textquotedbl}splat{\textquotedbl} construct (\texttt{i...}).



\hypertarget{3961768779038303546}{}


\subsection{基本语法}



The (basic) syntax of \texttt{@nloops} is as follows:



\begin{itemize}
\item The first argument must be an integer (\emph{not} a variable) specifying the number of loops.


\item The second argument is the symbol-prefix used for the iterator variable. Here we used \texttt{i}, and variables \texttt{i\_1, i\_2, i\_3} were generated.


\item The third argument specifies the range for each iterator variable. If you use a variable (symbol) here, it{\textquotesingle}s taken as \texttt{axes(A, dim)}. More flexibly, you can use the anonymous-function expression syntax described below.


\item The last argument is the body of the loop. Here, that{\textquotesingle}s what appears between the \texttt{begin...end}.

\end{itemize}


There are some additional features of \texttt{@nloops} described in the \hyperlink{6401299442402093832}{reference section}.



\texttt{@nref} follows a similar pattern, generating \texttt{A[i\_1,i\_2,i\_3]} from \texttt{@nref 3 A i}. The general practice is to read from left to right, which is why \texttt{@nloops} is \texttt{@nloops 3 i A expr} (as in \texttt{for i\_2 = axes(A, 2)}, where \texttt{i\_2} is to the left and the range is to the right) whereas \texttt{@nref} is \texttt{@nref 3 A i} (as in \texttt{A[i\_1,i\_2,i\_3]}, where the array comes first).



If you{\textquotesingle}re developing code with Cartesian, you may find that debugging is easier when you examine the generated code, using \texttt{@macroexpand}:






\begin{minted}{jlcon}
julia> @macroexpand @nref 2 A i
:(A[i_1, i_2])
\end{minted}





\hypertarget{13048573846185312344}{}


\subsubsection{Supplying the number of expressions}



The first argument to both of these macros is the number of expressions, which must be an integer. When you{\textquotesingle}re writing a function that you intend to work in multiple dimensions, this may not be something you want to hard-code. The recommended approach is to use a \texttt{@generated function}.  Here{\textquotesingle}s an example:




\begin{minted}{julia}
@generated function mysum(A::Array{T,N}) where {T,N}
    quote
        s = zero(T)
        @nloops $N i A begin
            s += @nref $N A i
        end
        s
    end
end
\end{minted}



Naturally, you can also prepare expressions or perform calculations before the \texttt{quote} block.



\hypertarget{10509900364879728464}{}


\subsubsection{Anonymous-function expressions as macro arguments}



Perhaps the single most powerful feature in \texttt{Cartesian} is the ability to supply anonymous-function expressions that get evaluated at parsing time.  Let{\textquotesingle}s consider a simple example:




\begin{minted}{julia}
@nexprs 2 j->(i_j = 1)
\end{minted}



\texttt{@nexprs} generates \texttt{n} expressions that follow a pattern. This code would generate the following statements:




\begin{minted}{julia}
i_1 = 1
i_2 = 1
\end{minted}



In each generated statement, an {\textquotedbl}isolated{\textquotedbl} \texttt{j} (the variable of the anonymous function) gets replaced by values in the range \texttt{1:2}. Generally speaking, Cartesian employs a LaTeX-like syntax.  This allows you to do math on the index \texttt{j}.  Here{\textquotesingle}s an example computing the strides of an array:




\begin{minted}{julia}
s_1 = 1
@nexprs 3 j->(s_{j+1} = s_j * size(A, j))
\end{minted}



would generate expressions




\begin{minted}{julia}
s_1 = 1
s_2 = s_1 * size(A, 1)
s_3 = s_2 * size(A, 2)
s_4 = s_3 * size(A, 3)
\end{minted}



Anonymous-function expressions have many uses in practice.



\hypertarget{908996570436533510}{}


\paragraph{Macro reference}


\hypertarget{4938945836201444124}{} 
\hyperlink{4938945836201444124}{\texttt{Base.Cartesian.@nloops}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@nloops N itersym rangeexpr bodyexpr
@nloops N itersym rangeexpr preexpr bodyexpr
@nloops N itersym rangeexpr preexpr postexpr bodyexpr
\end{minted}

Generate \texttt{N} nested loops, using \texttt{itersym} as the prefix for the iteration variables. \texttt{rangeexpr} may be an anonymous-function expression, or a simple symbol \texttt{var} in which case the range is \texttt{axes(var, d)} for dimension \texttt{d}.

Optionally, you can provide {\textquotedbl}pre{\textquotedbl} and {\textquotedbl}post{\textquotedbl} expressions. These get executed first and last, respectively, in the body of each loop. For example:


\begin{lstlisting}
@nloops 2 i A d -> j_d = min(i_d, 5) begin
    s += @nref 2 A j
end
\end{lstlisting}

would generate:


\begin{lstlisting}
for i_2 = axes(A, 2)
    j_2 = min(i_2, 5)
    for i_1 = axes(A, 1)
        j_1 = min(i_1, 5)
        s += A[j_1, j_2]
    end
end
\end{lstlisting}

If you want just a post-expression, supply \hyperlink{9331422207248206047}{\texttt{nothing}} for the pre-expression. Using parentheses and semicolons, you can supply multi-statement expressions.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/cartesian.jl#L9-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5318613607184308860}{} 
\hyperlink{5318613607184308860}{\texttt{Base.Cartesian.@nref}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@nref N A indexexpr
\end{minted}

Generate expressions like \texttt{A[i\_1, i\_2, ...]}. \texttt{indexexpr} can either be an iteration-symbol prefix, or an anonymous-function expression.

\textbf{Examples}


\begin{minted}{jlcon}
julia> @macroexpand Base.Cartesian.@nref 3 A i
:(A[i_1, i_2, i_3])
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/cartesian.jl#L72-L83}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5592996802344748158}{} 
\hyperlink{5592996802344748158}{\texttt{Base.Cartesian.@nextract}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@nextract N esym isym
\end{minted}

Generate \texttt{N} variables \texttt{esym\_1}, \texttt{esym\_2}, ..., \texttt{esym\_N} to extract values from \texttt{isym}. \texttt{isym} can be either a \texttt{Symbol} or anonymous-function expression.

\texttt{@nextract 2 x y} would generate


\begin{lstlisting}
x_1 = y[1]
x_2 = y[2]
\end{lstlisting}

while \texttt{@nextract 3 x d->y[2d-1]} yields


\begin{lstlisting}
x_1 = y[1]
x_2 = y[3]
x_3 = y[5]
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/cartesian.jl#L132-L149}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17386123129446980507}{} 
\hyperlink{17386123129446980507}{\texttt{Base.Cartesian.@nexprs}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@nexprs N expr
\end{minted}

Generate \texttt{N} expressions. \texttt{expr} should be an anonymous-function expression.

\textbf{Examples}


\begin{minted}{jlcon}
julia> @macroexpand Base.Cartesian.@nexprs 4 i -> y[i] = A[i+j]
quote
    y[1] = A[1 + j]
    y[2] = A[2 + j]
    y[3] = A[3 + j]
    y[4] = A[4 + j]
end
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/cartesian.jl#L111-L126}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16431416314224139891}{} 
\hyperlink{16431416314224139891}{\texttt{Base.Cartesian.@ncall}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@ncall N f sym...
\end{minted}

Generate a function call expression. \texttt{sym} represents any number of function arguments, the last of which may be an anonymous-function expression and is expanded into \texttt{N} arguments.

For example, \texttt{@ncall 3 func a} generates


\begin{lstlisting}
func(a_1, a_2, a_3)
\end{lstlisting}

while \texttt{@ncall 2 func a b i->c[i]} yields


\begin{lstlisting}
func(a, b, c[1], c[2])
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/cartesian.jl#L89-L103}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4425932542618492714}{} 
\hyperlink{4425932542618492714}{\texttt{Base.Cartesian.@ntuple}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@ntuple N expr
\end{minted}

Generates an \texttt{N}-tuple. \texttt{@ntuple 2 i} would generate \texttt{(i\_1, i\_2)}, and \texttt{@ntuple 2 k->k+1} would generate \texttt{(2,3)}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/cartesian.jl#L193-L198}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5463798602076286002}{} 
\hyperlink{5463798602076286002}{\texttt{Base.Cartesian.@nall}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@nall N expr
\end{minted}

Check whether all of the expressions generated by the anonymous-function expression \texttt{expr} evaluate to \texttt{true}.

\texttt{@nall 3 d->(i\_d > 1)} would generate the expression \texttt{(i\_1 > 1 \&\& i\_2 > 1 \&\& i\_3 > 1)}. This can be convenient for bounds-checking.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/cartesian.jl#L160-L168}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11114957141394185901}{} 
\hyperlink{11114957141394185901}{\texttt{Base.Cartesian.@nany}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@nany N expr
\end{minted}

Check whether any of the expressions generated by the anonymous-function expression \texttt{expr} evaluate to \texttt{true}.

\texttt{@nany 3 d->(i\_d > 1)} would generate the expression \texttt{(i\_1 > 1 || i\_2 > 1 || i\_3 > 1)}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/cartesian.jl#L177-L184}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2428714678347040919}{} 
\hyperlink{2428714678347040919}{\texttt{Base.Cartesian.@nif}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@nif N conditionexpr expr
@nif N conditionexpr expr elseexpr
\end{minted}

Generates a sequence of \texttt{if ... elseif ... else ... end} statements. For example:


\begin{lstlisting}
@nif 3 d->(i_d >= size(A,d)) d->(error("Dimension ", d, " too big")) d->println("All OK")
\end{lstlisting}

would generate:


\begin{lstlisting}
if i_1 > size(A, 1)
    error("Dimension ", 1, " too big")
elseif i_2 > size(A, 2)
    error("Dimension ", 2, " too big")
else
    println("All OK")
end
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/cartesian.jl#L204-L221}{\texttt{source}}


\end{adjustwidth}

\hypertarget{8046590092133914049}{}


\section{Talking to the compiler (the \texttt{:meta} mechanism)}



In some circumstances, one might wish to provide hints or instructions that a given block of code has special properties: you might always want to inline it, or you might want to turn on special compiler optimization passes.  Starting with version 0.4, Julia has a convention that these instructions can be placed inside a \texttt{:meta} expression, which is typically (but not necessarily) the first expression in the body of a function.



\texttt{:meta} expressions are created with macros. As an example, consider the implementation of the \texttt{@inline} macro:




\begin{minted}{julia}
macro inline(ex)
    esc(isa(ex, Expr) ? pushmeta!(ex, :inline) : ex)
end
\end{minted}



Here, \texttt{ex} is expected to be an expression defining a function. A statement like this:




\begin{minted}{julia}
@inline function myfunction(x)
    x*(x+3)
end
\end{minted}



gets turned into an expression like this:




\begin{minted}{julia}
quote
    function myfunction(x)
        Expr(:meta, :inline)
        x*(x+3)
    end
end
\end{minted}



\texttt{Base.pushmeta!(ex, :symbol, args...)} appends \texttt{:symbol} to the end of the \texttt{:meta} expression, creating a new \texttt{:meta} expression if necessary. If \texttt{args} is specified, a nested expression containing \texttt{:symbol} and these arguments is appended instead, which can be used to specify additional information.



To use the metadata, you have to parse these \texttt{:meta} expressions. If your implementation can be performed within Julia, \texttt{Base.popmeta!} is very handy: \texttt{Base.popmeta!(body, :symbol)} will scan a function \emph{body} expression (one without the function signature) for the first \texttt{:meta} expression containing \texttt{:symbol}, extract any arguments, and return a tuple \texttt{(found::Bool, args::Array\{Any\})}. If the metadata did not have any arguments, or \texttt{:symbol} was not found, the \texttt{args} array will be empty.



Not yet provided is a convenient infrastructure for parsing \texttt{:meta} expressions from C++.



\hypertarget{9937121124855315153}{}


\section{子数组}



Julia 的 \texttt{SubArray} 类型是编码父类型 \hyperlink{6514416309183787338}{\texttt{AbstractArray}} 的“视图”的一个容器。本页介绍了 \texttt{SubArray} 的一些设计原则和实现。



One of the major design goals is to ensure high performance for views of both \hyperlink{1761039776681330940}{\texttt{IndexLinear}} and \hyperlink{4052302263500310575}{\texttt{IndexCartesian}} arrays. Furthermore, views of \texttt{IndexLinear} arrays should themselves be \texttt{IndexLinear} to the extent that it is possible.



\hypertarget{5581126844733696350}{}


\subsection{Index replacement}



Consider making 2d slices of a 3d array:






\begin{minted}{jlcon}
julia> A = rand(2,3,4);

julia> S1 = view(A, :, 1, 2:3)
2×2 view(::Array{Float64,3}, :, 1, 2:3) with eltype Float64:
 0.200586  0.066423
 0.298614  0.956753

julia> S2 = view(A, 1, :, 2:3)
3×2 view(::Array{Float64,3}, 1, :, 2:3) with eltype Float64:
 0.200586  0.066423
 0.246837  0.646691
 0.648882  0.276021
\end{minted}





\texttt{view} drops {\textquotedbl}singleton{\textquotedbl} dimensions (ones that are specified by an \texttt{Int}), so both \texttt{S1} and \texttt{S2} are two-dimensional \texttt{SubArray}s. Consequently, the natural way to index these is with \texttt{S1[i,j]}. To extract the value from the parent array \texttt{A}, the natural approach is to replace \texttt{S1[i,j]} with \texttt{A[i,1,(2:3)[j]]} and \texttt{S2[i,j]} with \texttt{A[1,i,(2:3)[j]]}.



The key feature of the design of SubArrays is that this index replacement can be performed without any runtime overhead.



\hypertarget{2778530023624514912}{}


\subsection{SubArray design}



\hypertarget{13587272900516328040}{}


\subsubsection{Type parameters and fields}



The strategy adopted is first and foremost expressed in the definition of the type:




\begin{minted}{julia}
struct SubArray{T,N,P,I,L} <: AbstractArray{T,N}
    parent::P
    indices::I
    offset1::Int       # for linear indexing and pointer, only valid when L==true
    stride1::Int       # used only for linear indexing
    ...
end
\end{minted}



\texttt{SubArray} has 5 type parameters.  The first two are the standard element type and dimensionality.  The next is the type of the parent \texttt{AbstractArray}.  The most heavily-used is the fourth parameter, a \texttt{Tuple} of the types of the indices for each dimension. The final one, \texttt{L}, is only provided as a convenience for dispatch; it{\textquotesingle}s a boolean that represents whether the index types support fast linear indexing. More on that later.



If in our example above \texttt{A} is a \texttt{Array\{Float64, 3\}}, our \texttt{S1} case above would be a \texttt{SubArray\{Float64,2,Array\{Float64,3\},Tuple\{Base.Slice\{Base.OneTo\{Int64\}\},Int64,UnitRange\{Int64\}\},false\}}. Note in particular the tuple parameter, which stores the types of the indices used to create \texttt{S1}. Likewise,




\begin{minted}{jlcon}
julia> S1.indices
(Base.Slice(Base.OneTo(2)), 1, 2:3)
\end{minted}



Storing these values allows index replacement, and having the types encoded as parameters allows one to dispatch to efficient algorithms.



\hypertarget{7039991064739471489}{}


\subsubsection{Index translation}



Performing index translation requires that you do different things for different concrete \texttt{SubArray} types.  For example, for \texttt{S1}, one needs to apply the \texttt{i,j} indices to the first and third dimensions of the parent array, whereas for \texttt{S2} one needs to apply them to the second and third.  The simplest approach to indexing would be to do the type-analysis at runtime:




\begin{minted}{julia}
parentindices = Vector{Any}()
for thisindex in S.indices
    ...
    if isa(thisindex, Int)
        # Don't consume one of the input indices
        push!(parentindices, thisindex)
    elseif isa(thisindex, AbstractVector)
        # Consume an input index
        push!(parentindices, thisindex[inputindex[j]])
        j += 1
    elseif isa(thisindex, AbstractMatrix)
        # Consume two input indices
        push!(parentindices, thisindex[inputindex[j], inputindex[j+1]])
        j += 2
    elseif ...
end
S.parent[parentindices...]
\end{minted}



Unfortunately, this would be disastrous in terms of performance: each element access would allocate memory, and involves the running of a lot of poorly-typed code.



The better approach is to dispatch to specific methods to handle each type of stored index. That{\textquotesingle}s what \texttt{reindex} does: it dispatches on the type of the first stored index and consumes the appropriate number of input indices, and then it recurses on the remaining indices. In the case of \texttt{S1}, this expands to




\begin{minted}{julia}
Base.reindex(S1, S1.indices, (i, j)) == (i, S1.indices[2], S1.indices[3][j])
\end{minted}



for any pair of indices \texttt{(i,j)} (except \hyperlink{4571802376991525093}{\texttt{CartesianIndex}}s and arrays thereof, see below).



This is the core of a \texttt{SubArray}; indexing methods depend upon \texttt{reindex} to do this index translation. Sometimes, though, we can avoid the indirection and make it even faster.



\hypertarget{18413909182716267462}{}


\subsubsection{Linear indexing}



Linear indexing can be implemented efficiently when the entire array has a single stride that separates successive elements, starting from some offset. This means that we can pre-compute these values and represent linear indexing simply as an addition and multiplication, avoiding the indirection of \texttt{reindex} and (more importantly) the slow computation of the cartesian coordinates entirely.



For \texttt{SubArray} types, the availability of efficient linear indexing is based purely on the types of the indices, and does not depend on values like the size of the parent array. You can ask whether a given set of indices supports fast linear indexing with the internal \texttt{Base.viewindexing} function:




\begin{minted}{jlcon}
julia> Base.viewindexing(S1.indices)
IndexCartesian()

julia> Base.viewindexing(S2.indices)
IndexLinear()
\end{minted}



This is computed during construction of the \texttt{SubArray} and stored in the \texttt{L} type parameter as a boolean that encodes fast linear indexing support. While not strictly necessary, it means that we can define dispatch directly on \texttt{SubArray\{T,N,A,I,true\}} without any intermediaries.



Since this computation doesn{\textquotesingle}t depend on runtime values, it can miss some cases in which the stride happens to be uniform:




\begin{minted}{jlcon}
julia> A = reshape(1:4*2, 4, 2)
4×2 reshape(::UnitRange{Int64}, 4, 2) with eltype Int64:
 1  5
 2  6
 3  7
 4  8

julia> diff(A[2:2:4,:][:])
3-element Array{Int64,1}:
 2
 2
 2
\end{minted}



A view constructed as \texttt{view(A, 2:2:4, :)} happens to have uniform stride, and therefore linear indexing indeed could be performed efficiently.  However, success in this case depends on the size of the array: if the first dimension instead were odd,




\begin{minted}{jlcon}
julia> A = reshape(1:5*2, 5, 2)
5×2 reshape(::UnitRange{Int64}, 5, 2) with eltype Int64:
 1   6
 2   7
 3   8
 4   9
 5  10

julia> diff(A[2:2:4,:][:])
3-element Array{Int64,1}:
 2
 3
 2
\end{minted}



then \texttt{A[2:2:4,:]} does not have uniform stride, so we cannot guarantee efficient linear indexing.  Since we have to base this decision based purely on types encoded in the parameters of the \texttt{SubArray}, \texttt{S = view(A, 2:2:4, :)} cannot implement efficient linear indexing.



\hypertarget{6217885754113158897}{}


\subsubsection{A few details}



\begin{itemize}
\item Note that the \texttt{Base.reindex} function is agnostic to the types of the input indices; it simply determines how and where the stored indices should be reindexed. It not only supports integer indices, but it supports non-scalar indexing, too. This means that views of views don{\textquotesingle}t need two levels of indirection; they can simply re-compute the indices into the original parent array!


\item Hopefully by now it{\textquotesingle}s fairly clear that supporting slices means that the dimensionality, given by the parameter \texttt{N}, is not necessarily equal to the dimensionality of the parent array or the length of the \texttt{indices} tuple.  Neither do user-supplied indices necessarily line up with entries in the \texttt{indices} tuple (e.g., the second user-supplied index might correspond to the third dimension of the parent array, and the third element in the \texttt{indices} tuple).

What might be less obvious is that the dimensionality of the stored parent array must be equal to the number of effective indices in the \texttt{indices} tuple. Some examples:


\begin{minted}{julia}
A = reshape(1:35, 5, 7) # A 2d parent Array
S = view(A, 2:7)         # A 1d view created by linear indexing
S = view(A, :, :, 1:1)   # Appending extra indices is supported
\end{minted}

Naively, you{\textquotesingle}d think you could just set \texttt{S.parent = A} and \texttt{S.indices = (:,:,1:1)}, but supporting this dramatically complicates the reindexing process, especially for views of views. Not only do you need to dispatch on the types of the stored indices, but you need to examine whether a given index is the final one and {\textquotedbl}merge{\textquotedbl} any remaining stored indices together. This is not an easy task, and even worse: it{\textquotesingle}s slow since it implicitly depends upon linear indexing.

Fortunately, this is precisely the computation that \texttt{ReshapedArray} performs, and it does so linearly if possible. Consequently, \texttt{view} ensures that the parent array is the appropriate dimensionality for the given indices by reshaping it if needed. The inner \texttt{SubArray} constructor ensures that this invariant is satisfied.


\item \hyperlink{4571802376991525093}{\texttt{CartesianIndex}} and arrays thereof throw a nasty wrench into the \texttt{reindex} scheme. Recall that \texttt{reindex} simply dispatches on the type of the stored indices in order to determine how many passed indices should be used and where they should go. But with \texttt{CartesianIndex}, there{\textquotesingle}s no longer a one-to-one correspondence between the number of passed arguments and the number of dimensions that they index into. If we return to the above example of \texttt{Base.reindex(S1, S1.indices, (i, j))}, you can see that the expansion is incorrect for \texttt{i, j = CartesianIndex(), CartesianIndex(2,1)}. It should \emph{skip} the \texttt{CartesianIndex()} entirely and return:


\begin{minted}{julia}
(CartesianIndex(2,1)[1], S1.indices[2], S1.indices[3][CartesianIndex(2,1)[2]])
\end{minted}

Instead, though, we get:


\begin{minted}{julia}
(CartesianIndex(), S1.indices[2], S1.indices[3][CartesianIndex(2,1)])
\end{minted}

Doing this correctly would require \emph{combined} dispatch on both the stored and passed indices across all combinations of dimensionalities in an intractable manner. As such, \texttt{reindex} must never be called with \texttt{CartesianIndex} indices. Fortunately, the scalar case is easily handled by first flattening the \texttt{CartesianIndex} arguments to plain integers. Arrays of \texttt{CartesianIndex}, however, cannot be split apart into orthogonal pieces so easily. Before attempting to use \texttt{reindex}, \texttt{view} must ensure that there are no arrays of \texttt{CartesianIndex} in the argument list. If there are, it can simply {\textquotedbl}punt{\textquotedbl} by avoiding the \texttt{reindex} calculation entirely, constructing a nested \texttt{SubArray} with two levels of indirection instead.

\end{itemize}


\hypertarget{9194487374122863540}{}


\section{isbits Union Optimizations}



In Julia, the \texttt{Array} type holds both {\textquotedbl}bits{\textquotedbl} values as well as heap-allocated {\textquotedbl}boxed{\textquotedbl} values. The distinction is whether the value itself is stored inline (in the direct allocated memory of the array), or if the memory of the array is simply a collection of pointers to objects allocated elsewhere. In terms of performance, accessing values inline is clearly an advantage over having to follow a pointer to the actual value. The definition of {\textquotedbl}isbits{\textquotedbl} generally means any Julia type with a fixed, determinate size, meaning no {\textquotedbl}pointer{\textquotedbl} fields, see \texttt{?isbitstype}.



Julia also supports Union types, quite literally the union of a set of types. Custom Union type definitions can be extremely handy for applications wishing to {\textquotedbl}cut across{\textquotedbl} the nominal type system (i.e. explicit subtype relationships) and define methods or functionality on these, otherwise unrelated, set of types. A compiler challenge, however, is in determining how to treat these Union types. The naive approach (and indeed, what Julia itself did pre-0.7), is to simply make a {\textquotedbl}box{\textquotedbl} and then a pointer in the box to the actual value, similar to the previously mentioned {\textquotedbl}boxed{\textquotedbl} values. This is unfortunate, however, because of the number of small, primitive {\textquotedbl}bits{\textquotedbl} types (think \texttt{UInt8}, \texttt{Int32}, \texttt{Float64}, etc.) that would easily fit themselves inline in this {\textquotedbl}box{\textquotedbl} without needing any indirection for value access. There are two main ways Julia can take advantage of this optimization as of 0.7: isbits Union fields in types, and isbits Union Arrays.



\hypertarget{4239563333738868441}{}


\subsection{isbits Union Structs}



Julia now includes an optimization wherein {\textquotedbl}isbits Union{\textquotedbl} fields in types (\texttt{mutable struct}, \texttt{struct}, etc.) will be stored inline. This is accomplished by determining the {\textquotedbl}inline size{\textquotedbl} of the Union type (e.g. \texttt{Union\{UInt8, Int16\}} will have a size of two bytes, which represents the size needed of the largest Union type \texttt{Int16}), and in addition, allocating an extra {\textquotedbl}type tag byte{\textquotedbl} (\texttt{UInt8}), whose value signals the type of the actual value stored inline of the {\textquotedbl}Union bytes{\textquotedbl}. The type tag byte value is the index of the actual value{\textquotesingle}s type in the Union type{\textquotesingle}s order of types. For example, a type tag value of \texttt{0x02} for a field with type \texttt{Union\{Nothing, UInt8, Int16\}} would indicate that an \texttt{Int16} value is stored in the 16 bits of the field in the structure{\textquotesingle}s memory; a \texttt{0x01} value would indicate that a \texttt{UInt8} value was stored in the first 8 bits of the 16 bits of the field{\textquotesingle}s memory. Lastly, a value of \texttt{0x00} signals that the \texttt{nothing} value will be returned for this field, even though, as a singleton type with a single type instance, it technically has a size of 0. The type tag byte for a type{\textquotesingle}s Union field is stored directly after the field{\textquotesingle}s computed Union memory.



\hypertarget{3119783438553475290}{}


\subsection{isbits Union Arrays}



Julia can now also store {\textquotedbl}isbits Union{\textquotedbl} values inline in an Array, as opposed to requiring an indirection box. The optimization is accomplished by storing an extra {\textquotedbl}type tag array{\textquotedbl} of bytes, one byte per array element, alongside the bytes of the actual array data. This type tag array serves the same function as the type field case: its value signals the type of the actual stored Union value in the array. In terms of layout, a Julia Array can include extra {\textquotedbl}buffer{\textquotedbl} space before and after its actual data values, which are tracked in the \texttt{a->offset} and \texttt{a->maxsize} fields of the \texttt{jl\_array\_t*} type. The {\textquotedbl}type tag array{\textquotedbl} is treated exactly as another \texttt{jl\_array\_t*}, but which shares the same \texttt{a->offset}, \texttt{a->maxsize}, and \texttt{a->len} fields. So the formula to access an isbits Union Array{\textquotesingle}s type tag bytes is \texttt{a->data + (a->maxsize - a->offset) * a->elsize + a->offset}; i.e. the Array{\textquotesingle}s \texttt{a->data} pointer is already shifted by \texttt{a->offset}, so correcting for that, we follow the data all the way to the max of what it can hold \texttt{a->maxsize}, then adjust by \texttt{a->ofset} more bytes to account for any present {\textquotedbl}front buffering{\textquotedbl} the array might be doing. This layout in particular allows for very efficient resizing operations as the type tag data only ever has to move when the actual array{\textquotesingle}s data has to move.



\hypertarget{6450179845418792741}{}


\section{System Image Building}



\hypertarget{2889722918811470983}{}


\subsection{Building the Julia system image}



Julia ships with a preparsed system image containing the contents of the \texttt{Base} module, named \texttt{sys.ji}.  This file is also precompiled into a shared library called \texttt{sys.\{so,dll,dylib\}} on as many platforms as possible, so as to give vastly improved startup times.  On systems that do not ship with a precompiled system image file, one can be generated from the source files shipped in Julia{\textquotesingle}s \texttt{DATAROOTDIR/julia/base} folder.



This operation is useful for multiple reasons.  A user may:



\begin{itemize}
\item Build a precompiled shared library system image on a platform that did not ship with one, thereby improving startup times.


\item Modify \texttt{Base}, rebuild the system image and use the new \texttt{Base} next time Julia is started.


\item Include a \texttt{userimg.jl} file that includes packages into the system image, thereby creating a system image that has packages embedded into the startup environment.

\end{itemize}


The \href{https://github.com/JuliaLang/PackageCompiler.jl}{\texttt{PackageCompiler.jl} package} contains convenient wrapper functions to automate this process.



\hypertarget{6216163822526201376}{}


\subsection{System image optimized for multiple microarchitectures}



The system image can be compiled simultaneously for multiple CPU microarchitectures under the same instruction set architecture (ISA). Multiple versions of the same function may be created with minimum dispatch point inserted into shared functions in order to take advantage of different ISA extensions or other microarchitecture features. The version that offers the best performance will be selected automatically at runtime based on available CPU features.



\hypertarget{7911922725601251657}{}


\subsubsection{Specifying multiple system image targets}



A multi-microarchitecture system image can be enabled by passing multiple targets during system image compilation. This can be done either with the \texttt{JULIA\_CPU\_TARGET} make option or with the \texttt{-C} command line option when running the compilation command manually. Multiple targets are separated by \texttt{;} in the option string. The syntax for each target is a CPU name followed by multiple features separated by \texttt{,}. All features supported by LLVM are supported and a feature can be disabled with a \texttt{-} prefix. (\texttt{+} prefix is also allowed and ignored to be consistent with LLVM syntax). Additionally, a few special features are supported to control the function cloning behavior.



\begin{itemize}
\item[1. ] \texttt{clone\_all}

By default, only functions that are the most likely to benefit from  the microarchitecture features will be cloned.  When \texttt{clone\_all} is specified for a target, however,  \textbf{all} functions in the system image will be cloned for the target.  The negative form \texttt{-clone\_all} can be used to prevent the built-in  heuristic from cloning all functions.


\item[2. ] \texttt{base(<n>)}

Where \texttt{<n>} is a placeholder for a non-negative number (e.g. \texttt{base(0)}, \texttt{base(1)}).  By default, a partially cloned (i.e. not \texttt{clone\_all}) target will use functions  from the default target (first one specified) if a function is not cloned.  This behavior can be changed by specifying a different base with the \texttt{base(<n>)} option.  The \texttt{n}th target (0-based) will be used as the base target instead of the default (\texttt{0}th) one.  The base target has to be either \texttt{0} or another \texttt{clone\_all} target.  Specifying a non-\texttt{clone\_all} target as the base target will cause an error.


\item[3. ] \texttt{opt\_size}

This causes the function for the target to be optimized for size when there isn{\textquotesingle}t a significant  runtime performance impact. This corresponds to \texttt{-Os} GCC and Clang option.


\item[4. ] \texttt{min\_size}

This causes the function for the target to be optimized for size that might have  a significant runtime performance impact. This corresponds to \texttt{-Oz} Clang option.

\end{itemize}


As an example, at the time of this writing, the following string is used in the creation of the official \texttt{x86\_64} Julia binaries downloadable from julialang.org:




\begin{lstlisting}
generic;sandybridge,-xsaveopt,clone_all;haswell,-rdrnd,base(1)
\end{lstlisting}



This creates a system image with three separate targets; one for a generic \texttt{x86\_64} processor, one with a \texttt{sandybridge} ISA (explicitly excluding \texttt{xsaveopt}) that explicitly clones all functions, and one targeting the \texttt{haswell} ISA, based off of the \texttt{sandybridge} sysimg version, and also excluding \texttt{rdrnd}.  When a Julia implementation loads the generated sysimg, it will check the host processor for matching CPU capability flags, enabling the highest ISA level possible.  Note that the base level (\texttt{generic}) requires the \texttt{cx16} instruction, which is disabled in some virtualization software and must be enabled for the \texttt{generic} target to be loaded.  Alternatively, a sysimg could be generated with the target \texttt{generic,-cx16} for greater compatibility, however note that this may cause performance and stability problems in some code.



\hypertarget{6161913736473072394}{}


\subsubsection{Implementation overview}



This is a brief overview of different part involved in the implementation. See code comments for each components for more implementation details.



\begin{itemize}
\item[1. ] System image compilation

The parsing and cloning decision are done in \texttt{src/processor*}.  We currently support cloning of function based on the present of loops, simd instructions,  or other math operations (e.g. fastmath, fma, muladd).  This information is passed on to \texttt{src/llvm-multiversioning.cpp} which does the actual cloning.  In addition to doing the cloning and insert dispatch slots  (see comments in \texttt{MultiVersioning::runOnModule} for how this is done),  the pass also generates metadata so that the runtime can load and initialize the  system image correctly.  A detail description of the metadata is available in \texttt{src/processor.h}.


\item[2. ] System image loading

The loading and initialization of the system image is done in \texttt{src/processor*} by  parsing the metadata saved during system image generation.  Host feature detection and selection decision are done in \texttt{src/processor\_*.cpp}  depending on the ISA. The target selection will prefer exact CPU name match,  larger vector register size, and larget number of features.  An overview of this process is in \texttt{src/processor.cpp}.

\end{itemize}


\hypertarget{5125896206531208336}{}


\section{Working with LLVM}



This is not a replacement for the LLVM documentation, but a collection of tips for working on LLVM for Julia.



\hypertarget{8956364453365125987}{}


\subsection{Overview of Julia to LLVM Interface}



Julia dynamically links against LLVM by default. Build with \texttt{USE\_LLVM\_SHLIB=0} to link statically.



The code for lowering Julia AST to LLVM IR or interpreting it directly is in directory \texttt{src/}.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
File & Description \\
\hline
\texttt{builtins.c} & Builtin functions \\
\hline
\texttt{ccall.cpp} & Lowering \hyperlink{14245046751182637566}{\texttt{ccall}} \\
\hline
\texttt{cgutils.cpp} & Lowering utilities, notably for array and tuple accesses \\
\hline
\texttt{codegen.cpp} & Top-level of code generation, pass list, lowering builtins \\
\hline
\texttt{debuginfo.cpp} & Tracks debug information for JIT code \\
\hline
\texttt{disasm.cpp} & Handles native object file and JIT code diassembly \\
\hline
\texttt{gf.c} & Generic functions \\
\hline
\texttt{intrinsics.cpp} & Lowering intrinsics \\
\hline
\texttt{llvm-simdloop.cpp} & Custom LLVM pass for \hyperlink{8155428559748374852}{\texttt{@simd}} \\
\hline
\texttt{sys.c} & I/O and operating system utility functions \\
\hline
\end{tabulary}

\end{table}



Some of the \texttt{.cpp} files form a group that compile to a single object.



The difference between an intrinsic and a builtin is that a builtin is a first class function that can be used like any other Julia function.  An intrinsic can operate only on unboxed data, and therefore its arguments must be statically typed.



\hypertarget{8366324567299313031}{}


\subsubsection{Alias Analysis}



Julia currently uses LLVM{\textquotesingle}s \href{http://llvm.org/docs/LangRef.html\#tbaa-metadata}{Type Based Alias Analysis}. To find the comments that document the inclusion relationships, look for \texttt{static MDNode*} in \texttt{src/codegen.cpp}.



The \texttt{-O} option enables LLVM{\textquotesingle}s \href{http://llvm.org/docs/AliasAnalysis.html\#the-basicaa-pass}{Basic Alias Analysis}.



\hypertarget{13120458447023898074}{}


\subsection{Building Julia with a different version of LLVM}



The default version of LLVM is specified in \texttt{deps/Versions.make}. You can override it by creating a file called \texttt{Make.user} in the top-level directory and adding a line to it such as:




\begin{lstlisting}
LLVM_VER = 6.0.1
\end{lstlisting}



Besides the LLVM release numerals, you can also use \texttt{LLVM\_VER = svn} to build against the latest development version of LLVM.



You can also specify to build a debug version of LLVM, by setting either \texttt{LLVM\_DEBUG = 1} or \texttt{LLVM\_DEBUG = Release} in your \texttt{Make.user} file. The former will be a fully unoptimized build of LLVM and the latter will produce an optimized build of LLVM. Depending on your needs the latter will suffice and it quite a bit faster. If you use \texttt{LLVM\_DEBUG = Release} you will also want to set \texttt{LLVM\_ASSERTIONS = 1} to enable diagonstics for different passes. Only \texttt{LLVM\_DEBUG = 1} implies that option by default.



\hypertarget{3429896864083237221}{}


\subsection{Passing options to LLVM}



You can pass options to LLVM via the environment variable \texttt{JULIA\_LLVM\_ARGS}. Here are example settings using \texttt{bash} syntax:



\begin{itemize}
\item \texttt{export JULIA\_LLVM\_ARGS = -print-after-all} dumps IR after each pass.


\item \texttt{export JULIA\_LLVM\_ARGS = -debug-only=loop-vectorize} dumps LLVM \texttt{DEBUG(...)} diagnostics for loop vectorizer. If you get warnings about {\textquotedbl}Unknown command line argument{\textquotedbl}, rebuild LLVM with \texttt{LLVM\_ASSERTIONS = 1}.

\end{itemize}


\hypertarget{7270369944062365114}{}


\subsection{Debugging LLVM transformations in isolation}



On occasion, it can be useful to debug LLVM{\textquotesingle}s transformations in isolation from the rest of the Julia system, e.g. because reproducing the issue inside \texttt{julia} would take too long, or because one wants to take advantage of LLVM{\textquotesingle}s tooling (e.g. bugpoint). To get unoptimized IR for the entire system image, pass the \texttt{--output-unopt-bc unopt.bc} option to the system image build process, which will output the unoptimized IR to an \texttt{unopt.bc} file. This file can then be passed to LLVM tools as usual. \texttt{libjulia} can function as an LLVM pass plugin and can be loaded into LLVM tools, to make julia-specific passes available in this environment. In addition, it exposes the \texttt{-julia} meta-pass, which runs the entire Julia pass-pipeline over the IR. As an example, to generate a system image, one could do:




\begin{lstlisting}
opt -load libjulia.so -julia -o opt.bc unopt.bc
llc -o sys.o opt.bc
cc -shared -o sys.so sys.o
\end{lstlisting}



This system image can then be loaded by \texttt{julia} as usual.



Alternatively, you can use \texttt{--output-jit-bc jit.bc} to obtain a trace of all IR passed to the JIT. This is useful for code that cannot be run as part of the sysimg generation process (e.g. because it creates unserializable state). However, the resulting \texttt{jit.bc} does not include sysimage data, and can thus not be used as such.



It is also possible to dump an LLVM IR module for just one Julia function, using:




\begin{minted}{julia}
fun, T = +, Tuple{Int,Int} # Substitute your function of interest here
optimize = false
open("plus.ll", "w") do file
    println(file, InteractiveUtils._dump_function(fun, T, false, false, false, true, :att, optimize, :default))
end
\end{minted}



These files can be processed the same way as the unoptimized sysimg IR shown above.



\hypertarget{18346154193244616171}{}


\subsection{Improving LLVM optimizations for Julia}



Improving LLVM code generation usually involves either changing Julia lowering to be more friendly to LLVM{\textquotesingle}s passes, or improving a pass.



If you are planning to improve a pass, be sure to read the \href{http://llvm.org/docs/DeveloperPolicy.html}{LLVM developer policy}. The best strategy is to create a code example in a form where you can use LLVM{\textquotesingle}s \texttt{opt} tool to study it and the pass of interest in isolation.



\begin{itemize}
\item[1. ] Create an example Julia code of interest.


\item[2. ] Use \texttt{JULIA\_LLVM\_ARGS = -print-after-all} to dump the IR.


\item[3. ] Pick out the IR at the point just before the pass of interest runs.


\item[4. ] Strip the debug metadata and fix up the TBAA metadata by hand.

\end{itemize}


The last step is labor intensive.  Suggestions on a better way would be appreciated.



\hypertarget{9068676689189894192}{}


\subsection{The jlcall calling convention}



Julia has a generic calling convention for unoptimized code, which looks somewhat as follows:




\begin{lstlisting}
jl_value_t *any_unoptimized_call(jl_value_t *, jl_value_t **, int);
\end{lstlisting}



where the first argument is the boxed function object, the second argument is an on-stack array of arguments and the third is the number of arguments. Now, we could perform a straightforward lowering and emit an alloca for the argument array. However, this would betray the SSA nature of the uses at the call site, making optimizations (including GC root placement), significantly harder. Instead, we emit it as follows:




\begin{lstlisting}
%bitcast = bitcast @any_unoptimized_call to %jl_value_t *(*)(%jl_value_t *, %jl_value_t *)
call cc 37 %jl_value_t *%bitcast(%jl_value_t *%arg1, %jl_value_t *%arg2)
\end{lstlisting}



The special \texttt{cc 37} annotation marks the fact that this call site is really using the jlcall calling convention. This allows us to retain the SSA-ness of the uses throughout the optimizer. GC root placement will later lower this call to the original C ABI. In the code the calling convention number is represented by the \texttt{JLCALL\_F\_CC} constant. In addition, there is the \texttt{JLCALL\_CC} calling convention which functions similarly, but omits the first argument.



\hypertarget{1193214752065867769}{}


\subsection{GC root placement}



GC root placement is done by an LLVM pass late in the pass pipeline. Doing GC root placement this late enables LLVM to make more aggressive optimizations around code that requires GC roots, as well as allowing us to reduce the number of required GC roots and GC root store operations (since LLVM doesn{\textquotesingle}t understand our GC, it wouldn{\textquotesingle}t otherwise know what it is and is not allowed to do with values stored to the GC frame, so it{\textquotesingle}ll conservatively do very little). As an example, consider an error path




\begin{minted}{julia}
if some_condition()
    #= Use some variables maybe =#
    error("An error occurred")
end
\end{minted}



During constant folding, LLVM may discover that the condition is always false, and can remove the basic block. However, if GC root lowering is done early, the GC root slots used in the deleted block, as well as any values kept alive in those slots only because they were used in the error path, would be kept alive by LLVM. By doing GC root lowering late, we give LLVM the license to do any of its usual optimizations (constant folding, dead code elimination, etc.), without having to worry (too much) about which values may or may not be GC tracked.



However, in order to be able to do late GC root placement, we need to be able to identify a) which pointers are GC tracked and b) all uses of such pointers. The goal of the GC placement pass is thus simple:



Minimize the number of needed GC roots/stores to them subject to the constraint that at every safepoint, any live GC-tracked pointer (i.e. for which there is a path after this point that contains a use of this pointer) is in some GC slot.



\hypertarget{8769102480019606347}{}


\subsubsection{Representation}



The primary difficulty is thus choosing an IR representation that allows us to identify GC-tracked pointers and their uses, even after the program has been run through the optimizer. Our design makes use of three LLVM features to achieve this:



\begin{itemize}
\item Custom address spaces


\item Operand Bundles


\item Non-integral pointers

\end{itemize}


Custom address spaces allow us to tag every point with an integer that needs to be preserved through optimizations. The compiler may not insert casts between address spaces that did not exist in the original program and it must never change the address space of a pointer on a load/store/etc operation. This allows us to annotate which pointers are GC-tracked in an optimizer-resistant way. Note that metadata would not be able to achieve the same purpose. Metadata is supposed to always be discardable without altering the semantics of the program. However, failing to identify a GC-tracked pointer alters the resulting program behavior dramatically - it{\textquotesingle}ll probably crash or return wrong results. We currently use three different address spaces (their numbers are defined in \texttt{src/codegen\_shared.cpp}):



\begin{itemize}
\item GC Tracked Pointers (currently 10): These are pointers to boxed values that may be put into a GC frame. It is loosely equivalent to a \texttt{jl\_value\_t*} pointer on the C side. N.B. It is illegal to ever have a pointer in this address space that may not be stored to a GC slot.


\item Derived Pointers (currently 11): These are pointers that are derived from some GC tracked pointer. Uses of these pointers generate uses of the original pointer. However, they need not themselves be known to the GC. The GC root placement pass MUST always find the GC tracked pointer from which this pointer is derived and use that as the pointer to root.


\item Callee Rooted Pointers (currently 12): This is a utility address space to express the notion of a callee rooted value. All values of this address space MUST be storable to a GC root (though it is possible to relax this condition in the future), but unlike the other pointers need not be rooted if passed to a call (they do still need to be rooted if they are live across another safepoint between the definition and the call).


\item Pointers loaded from tracked object (currently 13): This is used by arrays, which themselves contain a pointer to the managed data. This data area is owned by the array, but is not a GC-tracked object by itself. The compiler guarantees that as long as this pointer is live, the object that this pointer was loaded from will keep being live.

\end{itemize}


\hypertarget{10709955215160021117}{}


\subsubsection{Invariants}



The GC root placement pass makes use of several invariants, which need to be observed by the frontend and are preserved by the optimizer.



First, only the following address space casts are allowed:



\begin{itemize}
\item 0->\{Tracked,Derived,CalleeRooted\}: It is allowable to decay an untracked pointer to any of the others. However, do note that the optimizer has broad license to not root such a value. It is never safe to have a value in address space 0 in any part of the program if it is (or is derived from) a value that requires a GC root.


\item Tracked->Derived: This is the standard decay route for interior values. The placement pass will look for these to identify the base pointer for any use.


\item Tracked->CalleeRooted: Addrspace CalleeRooted serves merely as a hint that a GC root is not required. However, do note that the Derived->CalleeRooted decay is prohibited, since pointers should generally be storable to a GC slot, even in this address space.

\end{itemize}


Now let us consider what constitutes a use:



\begin{itemize}
\item Loads whose loaded values is in one of the address spaces


\item Stores of a value in one of the address spaces to a location


\item Stores to a pointer in one of the address spaces


\item Calls for which a value in one of the address spaces is an operand


\item Calls in jlcall ABI, for which the argument array contains a value


\item Return instructions.

\end{itemize}


We explicitly allow load/stores and simple calls in address spaces Tracked/Derived. Elements of jlcall argument arrays must always be in address space Tracked (it is required by the ABI that they are valid \texttt{jl\_value\_t*} pointers). The same is true for return instructions (though note that struct return arguments are allowed to have any of the address spaces). The only allowable use of an address space CalleeRooted pointer is to pass it to a call (which must have an appropriately typed operand).



Further, we disallow \texttt{getelementptr} in addrspace Tracked. This is because unless the operation is a noop, the resulting pointer will not be validly storable to a GC slot and may thus not be in this address space. If such a pointer is required, it should be decayed to addrspace Derived first.



Lastly, we disallow \texttt{inttoptr}/\texttt{ptrtoint} instructions in these address spaces. Having these instructions would mean that some \texttt{i64} values are really GC tracked. This is problematic, because it breaks that stated requirement that we{\textquotesingle}re able to identify GC-relevant pointers. This invariant is accomplished using the LLVM {\textquotedbl}non-integral pointers{\textquotedbl} feature, which is new in LLVM 5.0. It prohibits the optimizer from making optimizations that would introduce these operations. Note we can still insert static constants at JIT time by using \texttt{inttoptr} in address space 0 and then decaying to the appropriate address space afterwards.



\hypertarget{5598613901277707990}{}


\subsubsection{Supporting \texttt{ccall}}



One important aspect missing from the discussion so far is the handling of \hyperlink{14245046751182637566}{\texttt{ccall}}. \hyperlink{14245046751182637566}{\texttt{ccall}} has the peculiar feature that the location and scope of a use do not coincide. As an example consider:




\begin{minted}{julia}
A = randn(1024)
ccall(:foo, Cvoid, (Ptr{Float64},), A)
\end{minted}



In lowering, the compiler will insert a conversion from the array to the pointer which drops the reference to the array value. However, we of course need to make sure that the array does stay alive while we{\textquotesingle}re doing the \hyperlink{14245046751182637566}{\texttt{ccall}}. To understand how this is done, first recall the lowering of the above code:




\begin{minted}{julia}
return $(Expr(:foreigncall, :(:foo), Cvoid, svec(Ptr{Float64}), 0, :(:ccall), Expr(:foreigncall, :(:jl_array_ptr), Ptr{Float64}, svec(Any), 0, :(:ccall), :(A)), :(A)))
\end{minted}



The last \texttt{:(A)}, is an extra argument list inserted during lowering that informs the code generator which Julia level values need to be kept alive for the duration of this \hyperlink{14245046751182637566}{\texttt{ccall}}. We then take this information and represent it in an {\textquotedbl}operand bundle{\textquotedbl} at the IR level. An operand bundle is essentially a fake use that is attached to the call site. At the IR level, this looks like so:




\begin{lstlisting}
call void inttoptr (i64 ... to void (double*)*)(double* %5) [ "jl_roots"(%jl_value_t addrspace(10)* %A) ]
\end{lstlisting}



The GC root placement pass will treat the \texttt{jl\_roots} operand bundle as if it were a regular operand. However, as a final step, after the GC roots are inserted, it will drop the operand bundle to avoid confusing instruction selection.



\hypertarget{9100387688336588039}{}


\subsubsection{Supporting \texttt{pointer\_from\_objref}}



\hyperlink{9366554937543398846}{\texttt{pointer\_from\_objref}} is special because it requires the user to take explicit control of GC rooting. By our above invariants, this function is illegal, because it performs an address space cast from 10 to 0. However, it can be useful, in certain situations, so we provide a special intrinsic:




\begin{lstlisting}
declared %jl_value_t *julia.pointer_from_objref(%jl_value_t addrspace(10)*)
\end{lstlisting}



which is lowered to the corresponding address space cast after GC root lowering. Do note however that by using this intrinsic, the caller assumes all responsibility for making sure that the value in question is rooted. Further this intrinsic is not considered a use, so the GC root placement pass will not provide a GC root for the function. As a result, the external rooting must be arranged while the value is still tracked by the system. I.e. it is not valid to attempt to use the result of this operation to establish a global root - the optimizer may have already dropped the value.



\hypertarget{13949345143972752854}{}


\subsubsection{Keeping values alive in the absence of uses}



In certain cases it is necessary to keep an object alive, even though there is no compiler-visible use of said object. This may be case for low level code that operates on the memory-representation of an object directly or code that needs to interface with C code. In order to allow this, we provide the following intrinsics at the LLVM level:




\begin{lstlisting}
token @llvm.julia.gc_preserve_begin(...)
void @llvm.julia.gc_preserve_end(token)
\end{lstlisting}



(The \texttt{llvm.} in the name is required in order to be able to use the \texttt{token} type). The semantics of these intrinsics are as follows: At any safepoint that is dominated by a \texttt{gc\_preserve\_begin} call, but that is not not dominated by a corresponding \texttt{gc\_preserve\_end} call (i.e. a call whose argument is the token returned by a \texttt{gc\_preserve\_begin} call), the values passed as arguments to that \texttt{gc\_preserve\_begin} will be kept live. Note that the \texttt{gc\_preserve\_begin} still counts as a regular use of those values, so the standard lifetime semantics will ensure that the values will be kept alive before entering the preserve region.



\hypertarget{12315144918899798229}{}


\section{printf() and stdio in the Julia runtime}



\hypertarget{12808189198177172525}{}


\subsection{Libuv wrappers for stdio}



\texttt{julia.h} defines \href{http://docs.libuv.org}{libuv} wrappers for the \texttt{stdio.h} streams:




\begin{lstlisting}
uv_stream_t *JL_STDIN;
uv_stream_t *JL_STDOUT;
uv_stream_t *JL_STDERR;
\end{lstlisting}



... and corresponding output functions:




\begin{lstlisting}
int jl_printf(uv_stream_t *s, const char *format, ...);
int jl_vprintf(uv_stream_t *s, const char *format, va_list args);
\end{lstlisting}



These \texttt{printf} functions are used by the \texttt{.c} files in the \texttt{src/} and \texttt{ui/} directories wherever stdio is needed to ensure that output buffering is handled in a unified way.



In special cases, like signal handlers, where the full libuv infrastructure is too heavy, \texttt{jl\_safe\_printf()} can be used to \hyperlink{16947913578760238729}{\texttt{write(2)}} directly to \texttt{STDERR\_FILENO}:




\begin{lstlisting}
void jl_safe_printf(const char *str, ...);
\end{lstlisting}



\hypertarget{9919396910097555458}{}


\subsection{Interface between JL\_STD* and Julia code}



\hyperlink{3330957653919693521}{\texttt{Base.stdin}}, \hyperlink{18181294266083891471}{\texttt{Base.stdout}} and \hyperlink{6150355911915549172}{\texttt{Base.stderr}} are bound to the \texttt{JL\_STD*} libuv streams defined in the runtime.



Julia{\textquotesingle}s \texttt{\_\_init\_\_()} function (in \texttt{base/sysimg.jl}) calls \texttt{reinit\_stdio()} (in \texttt{base/stream.jl}) to create Julia objects for \hyperlink{3330957653919693521}{\texttt{Base.stdin}}, \hyperlink{18181294266083891471}{\texttt{Base.stdout}} and \hyperlink{6150355911915549172}{\texttt{Base.stderr}}.



\texttt{reinit\_stdio()} uses \hyperlink{14245046751182637566}{\texttt{ccall}} to retrieve pointers to \texttt{JL\_STD*} and calls \texttt{jl\_uv\_handle\_type()} to inspect the type of each stream.  It then creates a Julia \texttt{Base.IOStream}, \texttt{Base.TTY} or \texttt{Base.PipeEndpoint} object to represent each stream, e.g.:




\begin{lstlisting}
$ julia -e 'println(typeof((stdin, stdout, stderr)))'
Tuple{Base.TTY,Base.TTY,Base.TTY}

$ julia -e 'println(typeof((stdin, stdout, stderr)))' < /dev/null 2>/dev/null
Tuple{IOStream,Base.TTY,IOStream}

$ echo hello | julia -e 'println(typeof((stdin, stdout, stderr)))' | cat
Tuple{Base.PipeEndpoint,Base.PipeEndpoint,Base.TTY}
\end{lstlisting}



The \hyperlink{8104134490906192097}{\texttt{Base.read}} and \hyperlink{16947913578760238729}{\texttt{Base.write}} methods for these streams use \hyperlink{14245046751182637566}{\texttt{ccall}} to call libuv wrappers in \texttt{src/jl\_uv.c}, e.g.:




\begin{lstlisting}
stream.jl: function write(s::IO, p::Ptr, nb::Integer)
               -> ccall(:jl_uv_write, ...)
  jl_uv.c:          -> int jl_uv_write(uv_stream_t *stream, ...)
                        -> uv_write(uvw, stream, buf, ...)
\end{lstlisting}



\hypertarget{10878739879441287330}{}


\subsection{printf() during initialization}



The libuv streams relied upon by \texttt{jl\_printf()} etc., are not available until midway through initialization of the runtime (see \texttt{init.c}, \texttt{init\_stdio()}).  Error messages or warnings that need to be printed before this are routed to the standard C library \texttt{fwrite()} function by the following mechanism:



In \texttt{sys.c}, the \texttt{JL\_STD*} stream pointers are statically initialized to integer constants: \texttt{STD*\_FILENO (0, 1 and 2)}. In \texttt{jl\_uv.c} the \texttt{jl\_uv\_puts()} function checks its \texttt{uv\_stream\_t* stream} argument and calls \texttt{fwrite()} if stream is set to \texttt{STDOUT\_FILENO} or \texttt{STDERR\_FILENO}.



This allows for uniform use of \texttt{jl\_printf()} throughout the runtime regardless of whether or not any particular piece of code is reachable before initialization is complete.



\hypertarget{15654976823361224335}{}


\subsection{Legacy \texttt{ios.c} library}



The \texttt{src/support/ios.c} library is inherited from \href{https://github.com/JeffBezanson/femtolisp}{femtolisp}. It provides cross-platform buffered file IO and in-memory temporary buffers.



\texttt{ios.c} is still used by:



\begin{itemize}
\item \texttt{src/flisp/*.c}


\item \texttt{src/dump.c} – for serialization file IO and for memory buffers.


\item \texttt{src/staticdata.c} – for serialization file IO and for memory buffers.


\item \texttt{base/iostream.jl} – for file IO (see \texttt{base/fs.jl} for libuv equivalent).

\end{itemize}


Use of \texttt{ios.c} in these modules is mostly self-contained and separated from the libuv I/O system. However, there is \href{https://github.com/JuliaLang/julia/blob/master/src/flisp/print.c\#L654}{one place} where femtolisp calls through to \texttt{jl\_printf()} with a legacy \texttt{ios\_t} stream.



There is a hack in \texttt{ios.h} that makes the \texttt{ios\_t.bm} field line up with the \texttt{uv\_stream\_t.type} and ensures that the values used for \texttt{ios\_t.bm} to not overlap with valid \texttt{UV\_HANDLE\_TYPE} values.  This allows \texttt{uv\_stream\_t} pointers to point to \texttt{ios\_t} streams.



This is needed because \texttt{jl\_printf()} caller \texttt{jl\_static\_show()} is passed an \texttt{ios\_t} stream by femtolisp{\textquotesingle}s \texttt{fl\_print()} function. Julia{\textquotesingle}s \texttt{jl\_uv\_puts()} function has special handling for this:




\begin{lstlisting}
if (stream->type > UV_HANDLE_TYPE_MAX) {
    return ios_write((ios_t*)stream, str, n);
}
\end{lstlisting}



\hypertarget{7768027532525655179}{}


\section{边界检查}



和许多其他现代编程语言一样，Julia 在访问数组元素的时候也要通过边界检查来确保程序安全。当循环次数很多，或者在其他性能敏感的场景下，你可能希望不进行边界检查以提高运行时性能。比如要使用矢量 (SIMD) 指令，循环体就不能有分支语句，因此无法进行边界检查。Julia 提供了一个宏 \texttt{@inbounds(...)} 来告诉编译器在指定语句块不进行边界检查。用户自定义的数组类型可以通过宏 \texttt{@boundscheck(...)} 来达到上下文敏感的代码选择目的。



\hypertarget{2199104062335216769}{}


\subsection{移除边界检查}



宏 \texttt{@boundscheck(...)} 把代码块标记为要执行边界检查。但当这些代码块被被宏 \texttt{@inbounds(...)} 标记的代码包裹时，它们可能会被编译器移除。仅当\texttt{@boundscheck(...)} 代码块被调用函数包裹时，编译器会移除它们。比如你可能这样写的 \texttt{sum} 方法： 




\begin{minted}{julia}
function sum(A::AbstractArray)
    r = zero(eltype(A))
    for i = 1:length(A)
        @inbounds r += A[i]
    end
    return r
end
\end{minted}



使用自定义的类数组类型 \texttt{MyArray}，我们有：




\begin{minted}{julia}
@inline getindex(A::MyArray, i::Real) = (@boundscheck checkbounds(A,i); A.data[to_index(i)])
\end{minted}



当 \texttt{getindex} 被 \texttt{sum} 包裹时，对 \texttt{checkbounds(A,i)} 的调用会被忽略。如果存在多层包裹，最多只有一个 \texttt{@boundscheck} 被忽略。这个规则用来防止将来代码被改变时潜在的多余忽略。



\hypertarget{10208484018202603417}{}


\subsection{Propagating inbounds}



There may be certain scenarios where for code-organization reasons you want more than one layer between the \texttt{@inbounds} and \texttt{@boundscheck} declarations. For instance, the default \texttt{getindex} methods have the chain \texttt{getindex(A::AbstractArray, i::Real)} calls \texttt{getindex(IndexStyle(A), A, i)} calls \texttt{\_getindex(::IndexLinear, A, i)}.



To override the {\textquotedbl}one layer of inlining{\textquotedbl} rule, a function may be marked with \hyperlink{4942611866585954207}{\texttt{Base.@propagate\_inbounds}} to propagate an inbounds context (or out of bounds context) through one additional layer of inlining.



\hypertarget{17261866997775737461}{}


\subsection{The bounds checking call hierarchy}



The overall hierarchy is:



\begin{itemize}
\item \texttt{checkbounds(A, I...)} which calls

\begin{itemize}
\item \texttt{checkbounds(Bool, A, I...)} which calls

\begin{itemize}
\item \texttt{checkbounds\_indices(Bool, axes(A), I)} which recursively calls

\begin{itemize}
\item \texttt{checkindex} for each dimension

\end{itemize}
\end{itemize}
\end{itemize}
\end{itemize}


Here \texttt{A} is the array, and \texttt{I} contains the {\textquotedbl}requested{\textquotedbl} indices. \texttt{axes(A)} returns a tuple of {\textquotedbl}permitted{\textquotedbl} indices of \texttt{A}.



\texttt{checkbounds(A, I...)} throws an error if the indices are invalid, whereas \texttt{checkbounds(Bool, A, I...)} returns \texttt{false} in that circumstance.  \texttt{checkbounds\_indices} discards any information about the array other than its \texttt{axes} tuple, and performs a pure indices-vs-indices comparison: this allows relatively few compiled methods to serve a huge variety of array types. Indices are specified as tuples, and are usually compared in a 1-1 fashion with individual dimensions handled by calling another important function, \texttt{checkindex}: typically,




\begin{minted}{julia}
checkbounds_indices(Bool, (IA1, IA...), (I1, I...)) = checkindex(Bool, IA1, I1) &
                                                      checkbounds_indices(Bool, IA, I)
\end{minted}



so \texttt{checkindex} checks a single dimension.  All of these functions, including the unexported \texttt{checkbounds\_indices} have docstrings accessible with \texttt{?} .



If you have to customize bounds checking for a specific array type, you should specialize \texttt{checkbounds(Bool, A, I...)}. However, in most cases you should be able to rely on \texttt{checkbounds\_indices} as long as you supply useful \texttt{axes} for your array type.



If you have novel index types, first consider specializing \texttt{checkindex}, which handles a single index for a particular dimension of an array.  If you have a custom multidimensional index type (similar to \texttt{CartesianIndex}), then you may have to consider specializing \texttt{checkbounds\_indices}.



Note this hierarchy has been designed to reduce the likelihood of method ambiguities.  We try to make \texttt{checkbounds} the place to specialize on array type, and try to avoid specializations on index types; conversely, \texttt{checkindex} is intended to be specialized only on index type (especially, the last argument).



\hypertarget{17038639605096915302}{}


\section{Proper maintenance and care of multi-threading locks}



The following strategies are used to ensure that the code is dead-lock free (generally by addressing the 4th Coffman condition: circular wait).



\begin{quote}
\begin{itemize}
\item[1. ] structure code such that only one lock will need to be acquired at a time


\item[2. ] always acquire shared locks in the same order, as given by the table below


\item[3. ] avoid constructs that expect to need unrestricted recursion

\end{itemize}
\end{quote}


\hypertarget{13071695811965191352}{}


\subsection{Locks}



Below are all of the locks that exist in the system and the mechanisms for using them that avoid the potential for deadlocks (no Ostrich algorithm allowed here):



The following are definitely leaf locks (level 1), and must not try to acquire any other lock:



\begin{quote}
\begin{itemize}
\item safepoint

\begin{quote}
Note that this lock is acquired implicitly by \texttt{JL\_LOCK} and \texttt{JL\_UNLOCK}. use the \texttt{\_NOGC} variants to avoid that for level 1 locks.

While holding this lock, the code must not do any allocation or hit any safepoints. Note that there are safepoints when doing allocation, enabling / disabling GC, entering / restoring exception frames, and taking / releasing locks.

\end{quote}

\item shared\_map


\item finalizers


\item pagealloc


\item gc\emph{perm}lock


\item flisp

\begin{quote}
flisp itself is already threadsafe, this lock only protects the \texttt{jl\_ast\_context\_list\_t} pool

\end{quote}
\end{itemize}
\end{quote}


The following is a leaf lock (level 2), and only acquires level 1 locks (safepoint) internally:



\begin{quote}
\begin{itemize}
\item typecache


\item Module->lock

\end{itemize}
\end{quote}


The following is a level 3 lock, which can only acquire level 1 or level 2 locks internally:



\begin{quote}
\begin{itemize}
\item Method->writelock

\end{itemize}
\end{quote}


The following is a level 4 lock, which can only recurse to acquire level 1, 2, or 3 locks:



\begin{quote}
\begin{itemize}
\item MethodTable->writelock

\end{itemize}
\end{quote}


No Julia code may be called while holding a lock above this point.



The following are a level 6 lock, which can only recurse to acquire locks at lower levels:



\begin{quote}
\begin{itemize}
\item codegen


\item jl\emph{modules}mutex

\end{itemize}
\end{quote}


The following is an almost root lock (level end-1), meaning only the root look may be held when trying to acquire it:



\begin{quote}
\begin{itemize}
\item typeinf

\begin{quote}
this one is perhaps one of the most tricky ones, since type-inference can be invoked from many points

currently the lock is merged with the codegen lock, since they call each other recursively

\end{quote}
\end{itemize}
\end{quote}


The following lock synchronizes IO operation. Be aware that doing any I/O (for example, printing warning messages or debug information) while holding any other lock listed above may result in pernicious and hard-to-find deadlocks. BE VERY CAREFUL!



\begin{quote}
\begin{itemize}
\item iolock


\item Individual ThreadSynchronizers locks

\begin{quote}
this may continue to be held after releasing the iolock, or acquired without it, but be very careful to never attempt to acquire the iolock while holding it

\end{quote}
\end{itemize}
\end{quote}


The following is the root lock, meaning no other lock shall be held when trying to acquire it:



\begin{quote}
\begin{itemize}
\item toplevel

\begin{quote}
this should be held while attempting a top-level action (such as making a new type or defining a new method): trying to obtain this lock inside a staged function will cause a deadlock condition!

additionally, it{\textquotesingle}s unclear if \emph{any} code can safely run in parallel with an arbitrary toplevel expression, so it may require all threads to get to a safepoint first

\end{quote}
\end{itemize}
\end{quote}


\hypertarget{9065842407229995149}{}


\subsection{Broken Locks}



The following locks are broken:



\begin{itemize}
\item toplevel

\begin{quote}
doesn{\textquotesingle}t exist right now

fix: create it

\end{quote}

\item Module->lock

\begin{quote}
This is vulnerable to deadlocks since it can{\textquotesingle}t be certain it is acquired in sequence. Some operations (such as \texttt{import\_module}) are missing a lock.

fix: replace with \texttt{jl\_modules\_mutex}?

\end{quote}

\item loading.jl: \texttt{require} and \texttt{register\_root\_module}

\begin{quote}
This file potentially has numerous problems.

fix: needs locks

\end{quote}
\end{itemize}


\hypertarget{1067922422509615580}{}


\subsection{Shared Global Data Structures}



These data structures each need locks due to being shared mutable global state. It is the inverse list for the above lock priority list. This list does not include level 1 leaf resources due to their simplicity.



MethodTable modifications (def, cache, kwsorter type) : MethodTable->writelock



Type declarations : toplevel lock



Type application : typecache lock



Global variable tables : Module->lock



Module serializer : toplevel lock



JIT \& type-inference : codegen lock



MethodInstance/CodeInstance updates : Method->writelock, codegen lock



\begin{quote}
\begin{itemize}
\item These are set at construction and immutable:

\begin{itemize}
\item specTypes


\item sparam\_vals


\item def

\end{itemize}
\end{itemize}
\end{quote}


\begin{quote}
\begin{itemize}
\item These are set by \texttt{jl\_type\_infer} (while holding codegen lock):

\begin{itemize}
\item cache


\item rettype


\item inferred

\end{itemize}
\end{itemize}
\end{quote}



\begin{lstlisting}
    * valid ages
\end{lstlisting}



\begin{quote}
\begin{itemize}
\item \texttt{inInference} flag:

\begin{itemize}
\item optimization to quickly avoid recurring into \texttt{jl\_type\_infer} while it is already running


\item actual state (of setting \texttt{inferred}, then \texttt{fptr}) is protected by codegen lock

\end{itemize}
\end{itemize}
\end{quote}


\begin{quote}
\begin{itemize}
\item Function pointers:

\begin{itemize}
\item these transition once, from \texttt{NULL} to a value, while the codegen lock is held

\end{itemize}

\item Code-generator cache (the contents of \texttt{functionObjectsDecls}):

\begin{itemize}
\item these can transition multiple times, but only while the codegen lock is held


\item it is valid to use old version of this, or block for new versions of this, so races are benign, as long as the code is careful not to reference other data in the method instance (such as \texttt{rettype}) and assume it is coordinated, unless also holding the codegen lock

\end{itemize}
\end{itemize}
\end{quote}


LLVMContext : codegen lock



Method : Method->writelock



\begin{itemize}
\item roots array (serializer and codegen)


\item invoke / specializations / tfunc modifications

\end{itemize}


\hypertarget{10976543622473505620}{}


\section{Arrays with custom indices}



Conventionally, Julia{\textquotesingle}s arrays are indexed starting at 1, whereas some other languages start numbering at 0, and yet others (e.g., Fortran) allow you to specify arbitrary starting indices.  While there is much merit in picking a standard (i.e., 1 for Julia), there are some algorithms which simplify considerably if you can index outside the range \texttt{1:size(A,d)} (and not just \texttt{0:size(A,d)-1}, either). To facilitate such computations, Julia supports arrays with arbitrary indices.



The purpose of this page is to address the question, {\textquotedbl}what do I have to do to support such arrays in my own code?{\textquotedbl}  First, let{\textquotesingle}s address the simplest case: if you know that your code will never need to handle arrays with unconventional indexing, hopefully the answer is {\textquotedbl}nothing.{\textquotedbl} Old code, on conventional arrays, should function essentially without alteration as long as it was using the exported interfaces of Julia. If you find it more convenient to just force your users to supply traditional arrays where indexing starts at one, you can add




\begin{minted}{julia}
Base.require_one_based_indexing(arrays...)
\end{minted}



where \texttt{arrays...} is a list of the array objects that you wish to check for anything that violates 1-based indexing.



\hypertarget{12133789893433293548}{}


\subsection{Generalizing existing code}



As an overview, the steps are:



\begin{itemize}
\item replace many uses of \texttt{size} with \texttt{axes}


\item replace \texttt{1:length(A)} with \texttt{eachindex(A)}, or in some cases \texttt{LinearIndices(A)}


\item replace explicit allocations like \texttt{Array\{Int\}(undef, size(B))} with \texttt{similar(Array\{Int\}, axes(B))}

\end{itemize}


These are described in more detail below.



\hypertarget{3112549925833933267}{}


\subsubsection{Things to watch out for}



Because unconventional indexing breaks many people{\textquotesingle}s assumptions that all arrays start indexing with 1, there is always the chance that using such arrays will trigger errors. The most frustrating bugs would be incorrect results or segfaults (total crashes of Julia). For example, consider the following function:




\begin{minted}{julia}
function mycopy!(dest::AbstractVector, src::AbstractVector)
    length(dest) == length(src) || throw(DimensionMismatch("vectors must match"))
    # OK, now we're safe to use @inbounds, right? (not anymore!)
    for i = 1:length(src)
        @inbounds dest[i] = src[i]
    end
    dest
end
\end{minted}



This code implicitly assumes that vectors are indexed from 1; if \texttt{dest} starts at a different index than \texttt{src}, there is a chance that this code would trigger a segfault. (If you do get segfaults, to help locate the cause try running julia with the option \texttt{--check-bounds=yes}.)



\hypertarget{1628519832551402952}{}


\subsubsection{Using \texttt{axes} for bounds checks and loop iteration}



\texttt{axes(A)} (reminiscent of \texttt{size(A)}) returns a tuple of \texttt{AbstractUnitRange} objects, specifying the range of valid indices along each dimension of \texttt{A}.  When \texttt{A} has unconventional indexing, the ranges may not start at 1.  If you just want the range for a particular dimension \texttt{d}, there is \texttt{axes(A, d)}.



Base implements a custom range type, \texttt{OneTo}, where \texttt{OneTo(n)} means the same thing as \texttt{1:n} but in a form that guarantees (via the type system) that the lower index is 1. For any new \hyperlink{6514416309183787338}{\texttt{AbstractArray}} type, this is the default returned by \texttt{axes}, and it indicates that this array type uses {\textquotedbl}conventional{\textquotedbl} 1-based indexing.



For bounds checking, note that there are dedicated functions \texttt{checkbounds} and \texttt{checkindex} which can sometimes simplify such tests.



\hypertarget{15690038127583202025}{}


\subsubsection{Linear indexing (\texttt{LinearIndices})}



Some algorithms are most conveniently (or efficiently) written in terms of a single linear index, \texttt{A[i]} even if \texttt{A} is multi-dimensional. Regardless of the array{\textquotesingle}s native indices, linear indices always range from \texttt{1:length(A)}. However, this raises an ambiguity for one-dimensional arrays (a.k.a., \hyperlink{12517057979818647811}{\texttt{AbstractVector}}): does \texttt{v[i]} mean linear indexing , or Cartesian indexing with the array{\textquotesingle}s native indices?



For this reason, your best option may be to iterate over the array with \texttt{eachindex(A)}, or, if you require the indices to be sequential integers, to get the index range by calling \texttt{LinearIndices(A)}. This will return \texttt{axes(A, 1)} if A is an AbstractVector, and the equivalent of \texttt{1:length(A)} otherwise.



By this definition, 1-dimensional arrays always use Cartesian indexing with the array{\textquotesingle}s native indices. To help enforce this, it{\textquotesingle}s worth noting that the index conversion functions will throw an error if shape indicates a 1-dimensional array with unconventional indexing (i.e., is a \texttt{Tuple\{UnitRange\}} rather than a tuple of \texttt{OneTo}). For arrays with conventional indexing, these functions continue to work the same as always.



Using \texttt{axes} and \texttt{LinearIndices}, here is one way you could rewrite \texttt{mycopy!}:




\begin{minted}{julia}
function mycopy!(dest::AbstractVector, src::AbstractVector)
    axes(dest) == axes(src) || throw(DimensionMismatch("vectors must match"))
    for i in LinearIndices(src)
        @inbounds dest[i] = src[i]
    end
    dest
end
\end{minted}



\hypertarget{8664586686165592487}{}


\subsubsection{Allocating storage using generalizations of \texttt{similar}}



Storage is often allocated with \texttt{Array\{Int\}(undef, dims)} or \texttt{similar(A, args...)}. When the result needs to match the indices of some other array, this may not always suffice. The generic replacement for such patterns is to use \texttt{similar(storagetype, shape)}.  \texttt{storagetype} indicates the kind of underlying {\textquotedbl}conventional{\textquotedbl} behavior you{\textquotesingle}d like, e.g., \texttt{Array\{Int\}} or \texttt{BitArray} or even \texttt{dims->zeros(Float32, dims)} (which would allocate an all-zeros array). \texttt{shape} is a tuple of \hyperlink{8469131683393450448}{\texttt{Integer}} or \texttt{AbstractUnitRange} values, specifying the indices that you want the result to use. Note that a convenient way of producing an all-zeros array that matches the indices of A is simply \texttt{zeros(A)}.



Let{\textquotesingle}s walk through a couple of explicit examples. First, if \texttt{A} has conventional indices, then \texttt{similar(Array\{Int\}, axes(A))} would end up calling \texttt{Array\{Int\}(undef, size(A))}, and thus return an array.  If \texttt{A} is an \texttt{AbstractArray} type with unconventional indexing, then \texttt{similar(Array\{Int\}, axes(A))} should return something that {\textquotedbl}behaves like{\textquotedbl} an \texttt{Array\{Int\}} but with a shape (including indices) that matches \texttt{A}.  (The most obvious implementation is to allocate an \texttt{Array\{Int\}(undef, size(A))} and then {\textquotedbl}wrap{\textquotedbl} it in a type that shifts the indices.)



Note also that \texttt{similar(Array\{Int\}, (axes(A, 2),))} would allocate an \texttt{AbstractVector\{Int\}} (i.e., 1-dimensional array) that matches the indices of the columns of \texttt{A}.



\hypertarget{4699181205936675892}{}


\subsection{Writing custom array types with non-1 indexing}



Most of the methods you{\textquotesingle}ll need to define are standard for any \texttt{AbstractArray} type, see \hyperlink{9718377734213742156}{Abstract Arrays}. This page focuses on the steps needed to define unconventional indexing.



\hypertarget{5924242856598341681}{}


\subsubsection{Custom \texttt{AbstractUnitRange} types}



If you{\textquotesingle}re writing a non-1 indexed array type, you will want to specialize \texttt{axes} so it returns a \texttt{UnitRange}, or (perhaps better) a custom \texttt{AbstractUnitRange}.  The advantage of a custom type is that it {\textquotedbl}signals{\textquotedbl} the allocation type for functions like \texttt{similar}. If we{\textquotesingle}re writing an array type for which indexing will start at 0, we likely want to begin by creating a new \texttt{AbstractUnitRange}, \texttt{ZeroRange}, where \texttt{ZeroRange(n)} is equivalent to \texttt{0:n-1}.



In general, you should probably \emph{not} export \texttt{ZeroRange} from your package: there may be other packages that implement their own \texttt{ZeroRange}, and having multiple distinct \texttt{ZeroRange} types is (perhaps counterintuitively) an advantage: \texttt{ModuleA.ZeroRange} indicates that \texttt{similar} should create a \texttt{ModuleA.ZeroArray}, whereas \texttt{ModuleB.ZeroRange} indicates a \texttt{ModuleB.ZeroArray} type.  This design allows peaceful coexistence among many different custom array types.



Note that the Julia package \href{https://github.com/JuliaArrays/CustomUnitRanges.jl}{CustomUnitRanges.jl} can sometimes be used to avoid the need to write your own \texttt{ZeroRange} type.



\hypertarget{5545377887498946318}{}


\subsubsection{Specializing \texttt{axes}}



Once you have your \texttt{AbstractUnitRange} type, then specialize \texttt{axes}:




\begin{minted}{julia}
Base.axes(A::ZeroArray) = map(n->ZeroRange(n), A.size)
\end{minted}



where here we imagine that \texttt{ZeroArray} has a field called \texttt{size} (there would be other ways to implement this).



In some cases, the fallback definition for \texttt{axes(A, d)}:




\begin{minted}{julia}
axes(A::AbstractArray{T,N}, d) where {T,N} = d <= N ? axes(A)[d] : OneTo(1)
\end{minted}



may not be what you want: you may need to specialize it to return something other than \texttt{OneTo(1)} when \texttt{d > ndims(A)}.  Likewise, in \texttt{Base} there is a dedicated function \texttt{axes1} which is equivalent to \texttt{axes(A, 1)} but which avoids checking (at runtime) whether \texttt{ndims(A) > 0}. (This is purely a performance optimization.)  It is defined as:




\begin{minted}{julia}
axes1(A::AbstractArray{T,0}) where {T} = OneTo(1)
axes1(A::AbstractArray) = axes(A)[1]
\end{minted}



If the first of these (the zero-dimensional case) is problematic for your custom array type, be sure to specialize it appropriately.



\hypertarget{5556461946249659648}{}


\subsubsection{Specializing \texttt{similar}}



Given your custom \texttt{ZeroRange} type, then you should also add the following two specializations for \texttt{similar}:




\begin{minted}{julia}
function Base.similar(A::AbstractArray, T::Type, shape::Tuple{ZeroRange,Vararg{ZeroRange}})
    # body
end

function Base.similar(f::Union{Function,DataType}, shape::Tuple{ZeroRange,Vararg{ZeroRange}})
    # body
end
\end{minted}



Both of these should allocate your custom array type.



\hypertarget{16440701718956142132}{}


\subsubsection{Specializing \texttt{reshape}}



Optionally, define a method




\begin{lstlisting}
Base.reshape(A::AbstractArray, shape::Tuple{ZeroRange,Vararg{ZeroRange}}) = ...
\end{lstlisting}



and you can \texttt{reshape} an array so that the result has custom indices.



\hypertarget{18101383726856776769}{}


\subsubsection{For objects that mimic AbstractArray but are not subtypes}



\texttt{has\_offset\_axes} depends on having \texttt{axes} defined for the objects you call it on. If there is some reason you don{\textquotesingle}t have an \texttt{axes} method defined for your object, consider defining a method




\begin{minted}{julia}
Base.has_offset_axes(obj::MyNon1IndexedArraylikeObject) = true
\end{minted}



This will allow code that assumes 1-based indexing to detect a problem and throw a helpful error, rather than returning incorrect results or segfaulting julia.



\hypertarget{12667413576127681892}{}


\subsubsection{Catching errors}



If your new array type triggers errors in other code, one helpful debugging step can be to comment out \texttt{@boundscheck} in your \texttt{getindex} and \texttt{setindex!} implementation. This will ensure that every element access checks bounds. Or, restart julia with \texttt{--check-bounds=yes}.



In some cases it may also be helpful to temporarily disable \texttt{size} and \texttt{length} for your new array type, since code that makes incorrect assumptions frequently uses these functions.



\hypertarget{860188194179028487}{}


\section{Module loading}



\hyperlink{16690217505788642360}{\texttt{Base.require}} is responsible for loading modules and it also manages the precompilation cache. It is the implementation of the \texttt{import} statement.



\hypertarget{8895570116735182580}{}


\subsection{Experimental features}



The features below are experimental and not part of the stable Julia API. Before building upon them inform yourself about the current thinking and whether they might change soon.



\hypertarget{14149276766401458683}{}


\subsubsection{Module loading callbacks}



It is possible to listen to the modules loaded by \texttt{Base.require}, by registering a callback.




\begin{minted}{julia}
loaded_packages = Channel{Symbol}()
callback = (mod::Symbol) -> put!(loaded_packages, mod)
push!(Base.package_callbacks, callback)
\end{minted}



Please note that the symbol given to the callback is a non-unique identifier and it is the responsibility of the callback provider to walk the module chain to determine the fully qualified name of the loaded binding.



The callback below is an example of how to do that:




\begin{minted}{julia}
# Get the fully-qualified name of a module.
function module_fqn(name::Symbol)
    fqn = fullname(Base.root_module(name))
    return join(fqn, '.')
end
\end{minted}



\hypertarget{17787937227289045576}{}


\section{类型推导}



\hypertarget{2654942546276234129}{}


\subsection{类型推导是如何工作的}



\href{https://en.wikipedia.org/wiki/Type\_inference}{类型推导}指的是由输入值的类型推导其他值得类型得过程。



这两篇博客 (\href{https://juliacomputing.com/blog/2016/04/04/inference-convergence.html}{1}, \href{https://juliacomputing.com/blog/2017/05/15/inference-converage2.html}{2}) 描述了 Julia 的类型推导实现。



\hypertarget{4685549306288927755}{}


\subsection{调试 compiler.jl}



You can start a Julia session, edit \texttt{compiler/*.jl} (for example to insert \texttt{print} statements), and then replace \texttt{Core.Compiler} in your running session by navigating to \texttt{base} and executing \texttt{include({\textquotedbl}compiler/compiler.jl{\textquotedbl})}. This trick typically leads to much faster development than if you rebuild Julia for each change.



Alternatively, you can use the \href{https://github.com/timholy/Revise.jl}{Revise.jl} package to track the compiler changes by using the command \texttt{Revise.track(Core.Compiler)} at the beginning of your Julia session. As explained in the \href{https://timholy.github.io/Revise.jl/stable/}{Revise documentation}, the modifications to the compiler will be reflected when the modified files are saved.



A convenient entry point into inference is \texttt{typeinf\_code}. Here{\textquotesingle}s a demo running inference on \texttt{convert(Int, UInt(1))}:




\begin{minted}{julia}
# Get the method
atypes = Tuple{Type{Int}, UInt}  # argument types
mths = methods(convert, atypes)  # worth checking that there is only one
m = first(mths)

# Create variables needed to call `typeinf_code`
params = Core.Compiler.Params(typemax(UInt))  # parameter is the world age,
                                              # typemax(UInt) -> most recent
sparams = Core.svec()      # this particular method doesn't have type-parameters
optimize = true            # run all inference optimizations
types = Tuple{typeof(convert), atypes.parameters...} # Tuple{typeof(convert), Type{Int}, UInt}
Core.Compiler.typeinf_code(m, types, sparams, optimize, params)
\end{minted}



If your debugging adventures require a \texttt{MethodInstance}, you can look it up by calling \texttt{Core.Compiler.specialize\_method} using many of the variables above. A \texttt{CodeInfo} object may be obtained with




\begin{minted}{julia}
# Returns the CodeInfo object for `convert(Int, ::UInt)`:
ci = (@code_typed convert(Int, UInt(1)))[1]
\end{minted}



\hypertarget{3650644351684738912}{}


\subsection{The inlining algorithm (inline\_worthy)}



Much of the hardest work for inlining runs in \texttt{inlining\_pass}. However, if your question is {\textquotedbl}why didn{\textquotesingle}t my function inline?{\textquotedbl} then you will most likely be interested in \texttt{isinlineable} and its primary callee, \texttt{inline\_worthy}. \texttt{isinlineable} handles a number of special cases (e.g., critical functions like \texttt{next} and \texttt{done}, incorporating a bonus for functions that return tuples, etc.). The main decision-making happens in \texttt{inline\_worthy}, which returns \texttt{true} if the function should be inlined.



\texttt{inline\_worthy} implements a cost-model, where {\textquotedbl}cheap{\textquotedbl} functions get inlined; more specifically, we inline functions if their anticipated run-time is not large compared to the time it would take to \href{https://en.wikipedia.org/wiki/Calling\_convention}{issue a call} to them if they were not inlined. The cost-model is extremely simple and ignores many important details: for example, all \texttt{for} loops are analyzed as if they will be executed once, and the cost of an \texttt{if...else...end} includes the summed cost of all branches. It{\textquotesingle}s also worth acknowledging that we currently lack a suite of functions suitable for testing how well the cost model predicts the actual run-time cost, although \href{https://github.com/JuliaCI/BaseBenchmarks.jl}{BaseBenchmarks} provides a great deal of indirect information about the successes and failures of any modification to the inlining algorithm.



The foundation of the cost-model is a lookup table, implemented in \texttt{add\_tfunc} and its callers, that assigns an estimated cost (measured in CPU cycles) to each of Julia{\textquotesingle}s intrinsic functions. These costs are based on \href{http://ithare.com/wp-content/uploads/part101\_infographics\_v08.png}{standard ranges for common architectures} (see \href{https://www.agner.org/optimize/instruction\_tables.pdf}{Agner Fog{\textquotesingle}s analysis} for more detail).



We supplement this low-level lookup table with a number of special cases. For example, an \texttt{:invoke} expression (a call for which all input and output types were inferred in advance) is assigned a fixed cost (currently 20 cycles). In contrast, a \texttt{:call} expression, for functions other than intrinsics/builtins, indicates that the call will require dynamic dispatch, in which case we assign a cost set by \texttt{Params.inline\_nonleaf\_penalty} (currently set at 1000). Note that this is not a {\textquotedbl}first-principles{\textquotedbl} estimate of the raw cost of dynamic dispatch, but a mere heuristic indicating that dynamic dispatch is extremely expensive.



Each statement gets analyzed for its total cost in a function called \texttt{statement\_cost}. You can run this yourself by following the sketch below, where \texttt{f} is your function and \texttt{tt} is the Tuple-type of the arguments:




\begin{minted}{julia}
# A demo on `fill(3.5, (2, 3))`
f = fill
tt = Tuple{Float64, Tuple{Int,Int}}
# Create the objects we need to interact with the compiler
params = Core.Compiler.Params(typemax(UInt))
mi = Base.method_instances(f, tt)[1]
ci = code_typed(f, tt)[1][1]
opt = Core.Compiler.OptimizationState(mi, params)
# Calculate cost of each statement
cost(stmt::Expr) = Core.Compiler.statement_cost(stmt, -1, ci, opt.sptypes, opt.slottypes, opt.params)
cost(stmt) = 0
cst = map(cost, ci.code)

# output

31-element Array{Int64,1}:
  0
  0
 20
  4
  1
  1
  1
  0
  0
  0
  ⋮
  0
  0
  0
  0
  0
  0
  0
  0
  0
\end{minted}



The output is a \texttt{Vector\{Int\}} holding the estimated cost of each statement in \texttt{ci.code}.  Note that \texttt{ci} includes the consequences of inlining callees, and consequently the costs do too.



\chapter{Developing/debugging Julia's C code}


\hypertarget{14100866936909376046}{}


\section{报告和分析崩溃（段错误）}



So you managed to break Julia.  Congratulations!  Collected here are some general procedures you can undergo for common symptoms encountered when something goes awry.  Including the information from these debugging steps can greatly help the maintainers when tracking down a segfault or trying to figure out why your script is running slower than expected.



If you{\textquotesingle}ve been directed to this page, find the symptom that best matches what you{\textquotesingle}re experiencing and follow the instructions to generate the debugging information requested.  Table of symptoms:



\begin{itemize}
\item \href{@ref}{自举启动阶段的段错误 (\texttt{sysimg.jl})}


\item \href{@ref}{运行脚本时的段错误}


\item \href{@ref}{启动 Julia 时发生的段错误}

\end{itemize}


\hypertarget{13046485394122703550}{}


\subsection{版本/环境信息}



No matter the error, we will always need to know what version of Julia you are running. When Julia first starts up, a header is printed out with a version number and date. Please also include the output of \texttt{versioninfo()} (exported from the \hyperlink{11698106121547091928}{\texttt{InteractiveUtils}} standard library) in any report you create:




\begin{minted}{jlcon}
julia> using InteractiveUtils

julia> versioninfo()
Julia Version 1.4.2
Commit 44fa15b150* (2020-05-23 18:35 UTC)
Platform Info:
  OS: Windows (x86_64-w64-mingw32)
  CPU: Intel(R) Core(TM) i7-5600U CPU @ 2.60GHz
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-8.0.1 (ORCJIT, broadwell)
Environment:
  JULIA_PKG_SERVER = https://mirrors.bfsu.edu.cn/julia/static
\end{minted}



\hypertarget{3553581061539675492}{}


\subsection{Segfaults during bootstrap (\texttt{sysimg.jl})}



Segfaults toward the end of the \texttt{make} process of building Julia are a common symptom of something going wrong while Julia is preparsing the corpus of code in the \texttt{base/} folder.  Many factors can contribute toward this process dying unexpectedly, however it is as often as not due to an error in the C-code portion of Julia, and as such must typically be debugged with a debug build inside of \texttt{gdb}.  Explicitly:



Create a debug build of Julia:




\begin{lstlisting}
$ cd <julia_root>
$ make debug
\end{lstlisting}



Note that this process will likely fail with the same error as a normal \texttt{make} incantation, however this will create a debug executable that will offer \texttt{gdb} the debugging symbols needed to get accurate backtraces.  Next, manually run the bootstrap process inside of \texttt{gdb}:




\begin{lstlisting}
$ cd base/
$ gdb -x ../contrib/debug_bootstrap.gdb
\end{lstlisting}



This will start \texttt{gdb}, attempt to run the bootstrap process using the debug build of Julia, and print out a backtrace if (when) it segfaults.  You may need to hit \texttt{<enter>} a few times to get the full backtrace.  Create a \href{https://gist.github.com}{gist} with the backtrace, the \hyperlink{4601189142062189569}{version info}, and any other pertinent information you can think of and open a new \href{https://github.com/JuliaLang/julia/issues?q=is\%3Aopen}{issue} on Github with a link to the gist.



\hypertarget{17337880191991868567}{}


\subsection{Segfaults when running a script}



The procedure is very similar to \hyperlink{13671941627037387928}{Segfaults during bootstrap (\texttt{sysimg.jl})}.  Create a debug build of Julia, and run your script inside of a debugged Julia process:




\begin{lstlisting}
$ cd <julia_root>
$ make debug
$ gdb --args usr/bin/julia-debug <path_to_your_script>
\end{lstlisting}



Note that \texttt{gdb} will sit there, waiting for instructions.  Type \texttt{r} to run the process, and \texttt{bt} to generate a backtrace once it segfaults:




\begin{lstlisting}
(gdb) r
Starting program: /home/sabae/src/julia/usr/bin/julia-debug ./test.jl
...
(gdb) bt
\end{lstlisting}



Create a \href{https://gist.github.com}{gist} with the backtrace, the \hyperlink{4601189142062189569}{version info}, and any other pertinent information you can think of and open a new \href{https://github.com/JuliaLang/julia/issues?q=is\%3Aopen}{issue} on Github with a link to the gist.



\hypertarget{8599391806074935874}{}


\subsection{Errors during Julia startup}



Occasionally errors occur during Julia{\textquotesingle}s startup process (especially when using binary distributions, as opposed to compiling from source) such as the following:




\begin{minted}{julia}
$ julia
exec: error -5
\end{minted}



These errors typically indicate something is not getting loaded properly very early on in the bootup phase, and our best bet in determining what{\textquotesingle}s going wrong is to use external tools to audit the disk activity of the \texttt{julia} process:



\begin{itemize}
\item On Linux, use \texttt{strace}:


\begin{lstlisting}
$ strace julia
\end{lstlisting}


\item On OSX, use \texttt{dtruss}:


\begin{lstlisting}
$ dtruss -f julia
\end{lstlisting}

\end{itemize}


Create a \href{https://gist.github.com}{gist} with the \texttt{strace}/ \texttt{dtruss} output, the \hyperlink{4601189142062189569}{version info}, and any other pertinent information and open a new \href{https://github.com/JuliaLang/julia/issues?q=is\%3Aopen}{issue} on Github with a link to the gist.



\hypertarget{17259129457802099150}{}


\subsection{术语表}



A few terms have been used as shorthand in this guide:



\begin{itemize}
\item \texttt{<julia\_root>} refers to the root directory of the Julia source tree; e.g. it should contain folders such as \texttt{base}, \texttt{deps}, \texttt{src}, \texttt{test}, etc.....

\end{itemize}


\hypertarget{9756537906535455458}{}


\section{gdb 调试提示}



\hypertarget{12713077053871939955}{}


\subsection{显示 Julia 变量}



在 \texttt{gdb} 中, 任何 \texttt{jl\_value\_t*} 类型的变量 \texttt{obj} 的展示可以通过使用：




\begin{lstlisting}
(gdb) call jl_(obj)
\end{lstlisting}



这个对象会在 \texttt{julia} 会话中展示，而不是在 gdb 会话中。这是一种行之有效的方式来发现由 Julia 的 C 代码操控的对象的类型和值。



同样，如果你在调试一些 Julia 内部的东西 （比如 \texttt{compiler.jl} ），你可以通过使用这些来打印 \texttt{obj} ：




\begin{minted}{julia}
ccall(:jl_, Cvoid, (Any,), obj)
\end{minted}



这是一种很好的方法，可以避免 Julia 的输出流初始化顺序引起的问题。



Julia的 flisp 解释器使用 \texttt{value\_t} 对象；能够通过  \texttt{call fl\_print(fl\_ctx, ios\_stdout, obj)} 来展示。



\hypertarget{1284180401016634793}{}


\subsection{有用的用于检查的 Julia 变量}



While the addresses of many variables, like singletons, can be useful to print for many failures, there are a number of additional variables (see \texttt{julia.h} for a complete list) that are even more useful.



\begin{itemize}
\item (when in \texttt{jl\_apply\_generic}) \texttt{mfunc} and \texttt{jl\_uncompress\_ast(mfunc->def, mfunc->code)} :: for figuring out a bit about the call-stack


\item \texttt{jl\_lineno} and \texttt{jl\_filename} :: for figuring out what line in a test to go start debugging from (or figure out how far into a file has been parsed)


\item \texttt{\$1} :: not really a variable, but still a useful shorthand for referring to the result of the last gdb command (such as \texttt{print})


\item \texttt{jl\_options} :: sometimes useful, since it lists all of the command line options that were successfully parsed


\item \texttt{jl\_uv\_stderr} :: because who doesn{\textquotesingle}t like to be able to interact with stdio

\end{itemize}


\hypertarget{7178558395386377758}{}


\subsection{Useful Julia functions for Inspecting those variables}



\begin{itemize}
\item \texttt{jl\_gdblookup(\$rip)} :: For looking up the current function and line. (use \texttt{\$eip} on i686 platforms)


\item \texttt{jlbacktrace()} :: For dumping the current Julia backtrace stack to stderr. Only usable after \texttt{record\_backtrace()} has been called.


\item \texttt{jl\_dump\_llvm\_value(Value*)} :: For invoking \texttt{Value->dump()} in gdb, where it doesn{\textquotesingle}t work natively. For example, \texttt{f->linfo->functionObject}, \texttt{f->linfo->specFunctionObject}, and \texttt{to\_function(f->linfo)}.


\item \texttt{Type->dump()} :: only works in lldb. Note: add something like \texttt{;1} to prevent lldb from printing its prompt over the output


\item \texttt{jl\_eval\_string({\textquotedbl}expr{\textquotedbl})} :: for invoking side-effects to modify the current state or to lookup symbols


\item \texttt{jl\_typeof(jl\_value\_t*)} :: for extracting the type tag of a Julia value (in gdb, call \texttt{macro define jl\_typeof jl\_typeof} first, or pick something short like \texttt{ty} for the first arg to define a shorthand)

\end{itemize}


\hypertarget{1392415358123037898}{}


\subsection{Inserting breakpoints for inspection from gdb}



In your \texttt{gdb} session, set a breakpoint in \texttt{jl\_breakpoint} like so:




\begin{lstlisting}
(gdb) break jl_breakpoint
\end{lstlisting}



Then within your Julia code, insert a call to \texttt{jl\_breakpoint} by adding




\begin{minted}{julia}
ccall(:jl_breakpoint, Cvoid, (Any,), obj)
\end{minted}



where \texttt{obj} can be any variable or tuple you want to be accessible in the breakpoint.



It{\textquotesingle}s particularly helpful to back up to the \texttt{jl\_apply} frame, from which you can display the arguments to a function using, e.g.,




\begin{lstlisting}
(gdb) call jl_(args[0])
\end{lstlisting}



Another useful frame is \texttt{to\_function(jl\_method\_instance\_t *li, bool cstyle)}. The \texttt{jl\_method\_instance\_t*} argument is a struct with a reference to the final AST sent into the compiler. However, the AST at this point will usually be compressed; to view the AST, call \texttt{jl\_uncompress\_ast} and then pass the result to \texttt{jl\_}:




\begin{lstlisting}
#2  0x00007ffff7928bf7 in to_function (li=0x2812060, cstyle=false) at codegen.cpp:584
584          abort();
(gdb) p jl_(jl_uncompress_ast(li, li->ast))
\end{lstlisting}



\hypertarget{10952602490249170772}{}


\subsection{Inserting breakpoints upon certain conditions}



\hypertarget{796097711199942153}{}


\subsubsection{Loading a particular file}



Let{\textquotesingle}s say the file is \texttt{sysimg.jl}:




\begin{lstlisting}
(gdb) break jl_load if strcmp(fname, "sysimg.jl")==0
\end{lstlisting}



\hypertarget{11262037379695434792}{}


\subsubsection{Calling a particular method}




\begin{lstlisting}
(gdb) break jl_apply_generic if strcmp((char*)(jl_symbol_name)(jl_gf_mtable(F)->name), "method_to_break")==0
\end{lstlisting}



Since this function is used for every call, you will make everything 1000x slower if you do this.



\hypertarget{12553217263049394878}{}


\subsection{Dealing with signals}



Julia requires a few signal to function property. The profiler uses \texttt{SIGUSR2} for sampling and the garbage collector uses \texttt{SIGSEGV} for threads synchronization. If you are debugging some code that uses the profiler or multiple threads, you may want to let the debugger ignore these signals since they can be triggered very often during normal operations. The command to do this in GDB is (replace \texttt{SIGSEGV} with \texttt{SIGUSRS} or other signals you want to ignore):




\begin{lstlisting}
(gdb) handle SIGSEGV noprint nostop pass
\end{lstlisting}



The corresponding LLDB command is (after the process is started):




\begin{lstlisting}
(lldb) pro hand -p true -s false -n false SIGSEGV
\end{lstlisting}



If you are debugging a segfault with threaded code, you can set a breakpoint on \texttt{jl\_critical\_error} (\texttt{sigdie\_handler} should also work on Linux and BSD) in order to only catch the actual segfault rather than the GC synchronization points.



\hypertarget{8144212274800572894}{}


\subsection{Debugging during Julia{\textquotesingle}s build process (bootstrap)}



Errors that occur during \texttt{make} need special handling. Julia is built in two stages, constructing \texttt{sys0} and \texttt{sys.ji}. To see what commands are running at the time of failure, use \texttt{make VERBOSE=1}.



At the time of this writing, you can debug build errors during the \texttt{sys0} phase from the \texttt{base} directory using:




\begin{lstlisting}
julia/base$ gdb --args ../usr/bin/julia-debug -C native --build ../usr/lib/julia/sys0 sysimg.jl
\end{lstlisting}



You might need to delete all the files in \texttt{usr/lib/julia/} to get this to work.



You can debug the \texttt{sys.ji} phase using:




\begin{lstlisting}
julia/base$ gdb --args ../usr/bin/julia-debug -C native --build ../usr/lib/julia/sys -J ../usr/lib/julia/sys0.ji sysimg.jl
\end{lstlisting}



By default, any errors will cause Julia to exit, even under gdb. To catch an error {\textquotedbl}in the act{\textquotedbl}, set a breakpoint in \texttt{jl\_error} (there are several other useful spots, for specific kinds of failures, including: \texttt{jl\_too\_few\_args}, \texttt{jl\_too\_many\_args}, and \texttt{jl\_throw}).



Once an error is caught, a useful technique is to walk up the stack and examine the function by inspecting the related call to \texttt{jl\_apply}. To take a real-world example:




\begin{lstlisting}
Breakpoint 1, jl_throw (e=0x7ffdf42de400) at task.c:802
802 {
(gdb) p jl_(e)
ErrorException("auto_unbox: unable to determine argument type")
$2 = void
(gdb) bt 10
#0  jl_throw (e=0x7ffdf42de400) at task.c:802
#1  0x00007ffff65412fe in jl_error (str=0x7ffde56be000 <_j_str267> "auto_unbox:
   unable to determine argument type")
   at builtins.c:39
#2  0x00007ffde56bd01a in julia_convert_16886 ()
#3  0x00007ffff6541154 in jl_apply (f=0x7ffdf367f630, args=0x7fffffffc2b0, nargs=2) at julia.h:1281
...
\end{lstlisting}



The most recent \texttt{jl\_apply} is at frame \#3, so we can go back there and look at the AST for the function \texttt{julia\_convert\_16886}. This is the uniqued name for some method of \texttt{convert}. \texttt{f} in this frame is a \texttt{jl\_function\_t*}, so we can look at the type signature, if any, from the \texttt{specTypes} field:




\begin{lstlisting}
(gdb) f 3
#3  0x00007ffff6541154 in jl_apply (f=0x7ffdf367f630, args=0x7fffffffc2b0, nargs=2) at julia.h:1281
1281            return f->fptr((jl_value_t*)f, args, nargs);
(gdb) p f->linfo->specTypes
$4 = (jl_tupletype_t *) 0x7ffdf39b1030
(gdb) p jl_( f->linfo->specTypes )
Tuple{Type{Float32}, Float64}           # <-- type signature for julia_convert_16886
\end{lstlisting}



Then, we can look at the AST for this function:




\begin{lstlisting}
(gdb) p jl_( jl_uncompress_ast(f->linfo, f->linfo->ast) )
Expr(:lambda, Array{Any, 1}[:#s29, :x], Array{Any, 1}[Array{Any, 1}[], Array{Any, 1}[Array{Any, 1}[:#s29, :Any, 0], Array{Any, 1}[:x, :Any, 0]], Array{Any, 1}[], 0], Expr(:body,
Expr(:line, 90, :float.jl)::Any,
Expr(:return, Expr(:call, :box, :Float32, Expr(:call, :fptrunc, :Float32, :x)::Any)::Any)::Any)::Any)::Any
\end{lstlisting}



Finally, and perhaps most usefully, we can force the function to be recompiled in order to step through the codegen process. To do this, clear the cached \texttt{functionObject} from the \texttt{jl\_lamdbda\_info\_t*}:




\begin{lstlisting}
(gdb) p f->linfo->functionObject
$8 = (void *) 0x1289d070
(gdb) set f->linfo->functionObject = NULL
\end{lstlisting}



Then, set a breakpoint somewhere useful (e.g. \texttt{emit\_function}, \texttt{emit\_expr}, \texttt{emit\_call}, etc.), and run codegen:




\begin{lstlisting}
(gdb) p jl_compile(f)
... # your breakpoint here
\end{lstlisting}



\hypertarget{15283936980874101721}{}


\subsection{Debugging precompilation errors}



Module precompilation spawns a separate Julia process to precompile each module. Setting a breakpoint or catching failures in a precompile worker requires attaching a debugger to the worker. The easiest approach is to set the debugger watch for new process launches matching a given name. For example:




\begin{lstlisting}
(gdb) attach -w -n julia-debug
\end{lstlisting}



or:




\begin{lstlisting}
(lldb) process attach -w -n julia-debug
\end{lstlisting}



Then run a script/command to start precompilation. As described earlier, use conditional breakpoints in the parent process to catch specific file-loading events and narrow the debugging window. (some operating systems may require alternative approaches, such as following each \texttt{fork} from the parent process)



\hypertarget{2874239207045478266}{}


\subsection{Mozilla{\textquotesingle}s Record and Replay Framework (rr)}



Julia now works out of the box with \href{http://rr-project.org/}{rr}, the lightweight recording and deterministic debugging framework from Mozilla. This allows you to replay the trace of an execution deterministically.  The replayed execution{\textquotesingle}s address spaces, register contents, syscall data etc are exactly the same in every run.



A recent version of rr (3.1.0 or higher) is required.



\hypertarget{8199500901675456324}{}


\subsubsection{Reproducing concurrency bugs with rr}



rr simulates a single-threaded machine by default. In order to debug concurrent code you can use \texttt{rr record --chaos} which will cause rr to simulate between one to eight cores, chosen randomly. You might therefore want to set \texttt{JULIA\_NUM\_THREADS=8} and rerun your code under rr until you have caught your bug.



\hypertarget{1705795605392310931}{}


\section{在Julia中使用Valgrind}



\href{http://valgrind.org/}{Valgrind} is a tool for memory debugging, memory leak detection, and profiling.  This section describes things to keep in mind when using Valgrind to debug memory issues with Julia.



\hypertarget{527857279218691176}{}


\subsection{General considerations}



By default, Valgrind assumes that there is no self modifying code in the programs it runs.  This assumption works fine in most instances but fails miserably for a just-in-time compiler like \texttt{julia}.  For this reason it is crucial to pass \texttt{--smc-check=all-non-file} to \texttt{valgrind}, else code may crash or behave unexpectedly (often in subtle ways).



In some cases, to better detect memory errors using Valgrind it can help to compile \texttt{julia} with memory pools disabled.  The compile-time flag \texttt{MEMDEBUG} disables memory pools in Julia, and \texttt{MEMDEBUG2} disables memory pools in FemtoLisp.  To build \texttt{julia} with both flags, add the following line to \texttt{Make.user}:




\begin{minted}{julia}
CFLAGS = -DMEMDEBUG -DMEMDEBUG2
\end{minted}



Another thing to note: if your program uses multiple workers processes, it is likely that you want all such worker processes to run under Valgrind, not just the parent process.  To do this, pass \texttt{--trace-children=yes} to \texttt{valgrind}.



\hypertarget{9183907630008953484}{}


\subsection{Suppressions}



Valgrind will typically display spurious warnings as it runs.  To reduce the number of such warnings, it helps to provide a \href{http://valgrind.org/docs/manual/manual-core.html\#manual-core.suppress}{suppressions file} to Valgrind.  A sample suppressions file is included in the Julia source distribution at \texttt{contrib/valgrind-julia.supp}.



The suppressions file can be used from the \texttt{julia/} source directory as follows:




\begin{lstlisting}
$ valgrind --smc-check=all-non-file --suppressions=contrib/valgrind-julia.supp ./julia progname.jl
\end{lstlisting}



Any memory errors that are displayed should either be reported as bugs or contributed as additional suppressions.  Note that some versions of Valgrind are \href{https://github.com/JuliaLang/julia/issues/8314\#issuecomment-55766210}{shipped with insufficient default suppressions}, so that may be one thing to consider before submitting any bugs.



\hypertarget{10173787738831416739}{}


\subsection{Running the Julia test suite under Valgrind}



It is possible to run the entire Julia test suite under Valgrind, but it does take quite some time (typically several hours).  To do so, run the following command from the \texttt{julia/test/} directory:




\begin{lstlisting}
valgrind --smc-check=all-non-file --trace-children=yes --suppressions=$PWD/../contrib/valgrind-julia.supp ../julia runtests.jl all
\end{lstlisting}



If you would like to see a report of {\textquotedbl}definite{\textquotedbl} memory leaks, pass the flags \texttt{--leak-check=full --show-leak-kinds=definite} to \texttt{valgrind} as well.



\hypertarget{11463604234155946056}{}


\subsection{Caveats}



Valgrind currently \href{https://bugs.kde.org/show\_bug.cgi?id=136779}{does not support multiple rounding modes}, so code that adjusts the rounding mode will behave differently when run under Valgrind.



In general, if after setting \texttt{--smc-check=all-non-file} you find that your program behaves differently when run under Valgrind, it may help to pass \texttt{--tool=none} to \texttt{valgrind} as you investigate further.  This will enable the minimal Valgrind machinery but will also run much faster than when the full memory checker is enabled.



\hypertarget{7868060637958278195}{}


\section{Sanitizer support}



\hypertarget{527857279218691176}{}


\subsection{General considerations}



Using Clang{\textquotesingle}s sanitizers obviously require you to use Clang (\texttt{USECLANG=1}), but there{\textquotesingle}s another catch: most sanitizers require a run-time library, provided by the host compiler, while the instrumented code generated by Julia{\textquotesingle}s JIT relies on functionality from that library. This implies that the LLVM version of your host compiler matches that of the LLVM library used within Julia.



An easy solution is to have an dedicated build folder for providing a matching toolchain, by building with \texttt{BUILD\_LLVM\_CLANG=1}. You can then refer to this toolchain from another build folder by specifying \texttt{USECLANG=1} while overriding the \texttt{CC} and \texttt{CXX} variables.



\hypertarget{1061650975116506198}{}


\subsection{Address Sanitizer (ASAN)}



For detecting or debugging memory bugs, you can use Clang{\textquotesingle}s \href{http://clang.llvm.org/docs/AddressSanitizer.html}{address sanitizer (ASAN)}. By compiling with \texttt{SANITIZE=1} you enable ASAN for the Julia compiler and its generated code. In addition, you can specify \texttt{LLVM\_SANITIZE=1} to sanitize the LLVM library as well. Note that these options incur a high performance and memory cost. For example, using ASAN for Julia and LLVM makes \texttt{testall1} takes 8-10 times as long while using 20 times as much memory (this can be reduced to respectively a factor of 3 and 4 by using the options described below).



By default, Julia sets the \texttt{allow\_user\_segv\_handler=1} ASAN flag, which is required for signal delivery to work properly. You can define other options using the \texttt{ASAN\_OPTIONS} environment flag, in which case you{\textquotesingle}ll need to repeat the default option mentioned before. For example, memory usage can be reduced by specifying \texttt{fast\_unwind\_on\_malloc=0} and \texttt{malloc\_context\_size=2}, at the cost of backtrace accuracy. For now, Julia also sets \texttt{detect\_leaks=0}, but this should be removed in the future.



\hypertarget{11752764117060042950}{}


\subsection{Memory Sanitizer (MSAN)}



For detecting use of uninitialized memory, you can use Clang{\textquotesingle}s \href{http://clang.llvm.org/docs/MemorySanitizer.html}{memory sanitizer (MSAN)} by compiling with \texttt{SANITIZE\_MEMORY=1}.



\end{document}
