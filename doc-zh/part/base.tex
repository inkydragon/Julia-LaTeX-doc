
\part{Base}


\hypertarget{16478843685103880703}{}


\chapter{基本功能}



\hypertarget{7253998760451691688}{}


\section{介绍}



Julia Base 中包含一系列适用于科学及数值计算的函数和宏，但也可以用于通用编程，其它功能则由 Julia 生态圈中的各种库来提供。函数按主题划分如下：



一些通用的提示：



\begin{itemize}
\item 可以通过 \texttt{Import Module} 导入想要使用的模块，并利用 \texttt{Module.fn(x)} 语句来实现对模块内函数的调用。


\item 此外，\texttt{using Module} 语句会将名为 \texttt{Module} 的模块中的所有可调函数引入当前的命名空间。


\item 按照约定，名字以感叹号（\texttt{!}）结尾的函数会改变其输入参数的内容。 一些函数同时拥有改变参数（例如 \texttt{sort!}）和不改变参数（\texttt{sort}）的版本

\end{itemize}


\hypertarget{10705549471205156223}{}


\section{概览}


\hypertarget{14846984688570889934}{} 
\hyperlink{14846984688570889934}{\texttt{Base.exit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
exit(code=0)
\end{minted}

Stop the program with an exit code. The default exit code is zero, indicating that the program completed successfully. In an interactive session, \texttt{exit()} can be called with the keyboard shortcut \texttt{{\textasciicircum}D}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/initdefs.jl#L21-L27}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17479944696971324992}{} 
\hyperlink{17479944696971324992}{\texttt{Base.atexit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
atexit(f)
\end{minted}

Register a zero-argument function \texttt{f()} to be called at process exit. \texttt{atexit()} hooks are called in last in first out (LIFO) order and run before object finalizers.

Exit hooks are allowed to call \texttt{exit(n)}, in which case Julia will exit with exit code \texttt{n} (instead of the original exit code). If more than one exit hook calls \texttt{exit(n)}, then Julia will exit with the exit code corresponding to the last called exit hook that calls \texttt{exit(n)}. (Because exit hooks are called in LIFO order, {\textquotedbl}last called{\textquotedbl} is equivalent to {\textquotedbl}first registered{\textquotedbl}.)



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/initdefs.jl#L298-L309}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10304111149900708910}{} 
\hyperlink{10304111149900708910}{\texttt{Base.isinteractive}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isinteractive() -> Bool
\end{minted}

Determine whether Julia is running an interactive session.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/initdefs.jl#L35-L39}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16959611366931029689}{} 
\hyperlink{16959611366931029689}{\texttt{Base.summarysize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.summarysize(obj; exclude=Union{...}, chargeall=Union{...}) -> Int
\end{minted}

Compute the amount of memory, in bytes, used by all unique objects reachable from the argument.

\textbf{Keyword Arguments}

\begin{itemize}
\item \texttt{exclude}: specifies the types of objects to exclude from the traversal.


\item \texttt{chargeall}: specifies the types of objects to always charge the size of all of their fields, even if those fields would normally be excluded.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/summarysize.jl#L11-L20}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16690217505788642360}{} 
\hyperlink{16690217505788642360}{\texttt{Base.require}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
require(into::Module, module::Symbol)
\end{minted}

This function is part of the implementation of \hyperlink{169458112978175560}{\texttt{using}} / \hyperlink{16252475688663093021}{\texttt{import}}, if a module is not already defined in \texttt{Main}. It can also be called directly to force reloading a module, regardless of whether it has been loaded before (for example, when interactively developing libraries).

Loads a source file, in the context of the \texttt{Main} module, on every active node, searching standard locations for files. \texttt{require} is considered a top-level operation, so it sets the current \texttt{include} path but does not use it to search for files (see help for \hyperlink{438355891087818425}{\texttt{include}}). This function is typically used to load library code, and is implicitly called by \texttt{using} to load packages.

When searching for files, \texttt{require} first looks for package code in the global array \hyperlink{17914149694871263675}{\texttt{LOAD\_PATH}}. \texttt{require} is case-sensitive on all platforms, including those with case-insensitive filesystems like macOS and Windows.

For more details regarding code loading, see the manual sections on \hyperlink{16725527896995457152}{modules} and \href{@ref code-availability}{parallel computing}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/loading.jl#L865-L885}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15403934372637978246}{} 
\hyperlink{15403934372637978246}{\texttt{Base.compilecache}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.compilecache(module::PkgId)
\end{minted}

Creates a precompiled cache file for a module and all of its dependencies. This can be used to reduce package load times. Cache files are stored in \texttt{DEPOT\_PATH[1]/compiled}. See \href{@ref}{Module initialization and precompilation} for important notes.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/loading.jl#L1222-L1229}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9213488790068613847}{} 
\hyperlink{9213488790068613847}{\texttt{Base.\_\_precompile\_\_}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
__precompile__(isprecompilable::Bool)
\end{minted}

Specify whether the file calling this function is precompilable, defaulting to \texttt{true}. If a module or file is \emph{not} safely precompilable, it should call \texttt{\_\_precompile\_\_(false)} in order to throw an error if Julia attempts to precompile it.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/loading.jl#L845-L851}{\texttt{source}}


\end{adjustwidth}
\hypertarget{438355891087818425}{} 
\hyperlink{438355891087818425}{\texttt{Base.include}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.include([m::Module,] path::AbstractString)
\end{minted}

Evaluate the contents of the input source file in the global scope of module \texttt{m}. Every module (except those defined with \hyperlink{13329108222158426840}{\texttt{baremodule}}) has its own 1-argument definition of \texttt{include}, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to \texttt{include} will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/loading.jl#L1100-L1110}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7507443674556842580}{} 
\hyperlink{7507443674556842580}{\texttt{Base.MainInclude.include}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
include(path::AbstractString)
\end{minted}

Evaluate the contents of the input source file in the global scope of the containing module. Every module (except those defined with \texttt{baremodule}) has its own 1-argument definition of \texttt{include}, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to \texttt{include} will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.

Use \hyperlink{438355891087818425}{\texttt{Base.include}} to evaluate a file into another module.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/client.jl#L461-L473}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2796348696499086186}{} 
\hyperlink{2796348696499086186}{\texttt{Base.include\_string}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
include_string(m::Module, code::AbstractString, filename::AbstractString="string")
\end{minted}

Like \hyperlink{438355891087818425}{\texttt{include}}, except reads code from the given string rather than from a file.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/loading.jl#L1075-L1079}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13423629850785876688}{} 
\hyperlink{13423629850785876688}{\texttt{Base.include\_dependency}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
include_dependency(path::AbstractString)
\end{minted}

In a module, declare that the file specified by \texttt{path} (relative or absolute) is a dependency for precompilation; that is, the module will need to be recompiled if this file changes.

This is only needed if your module depends on a file that is not used via \hyperlink{438355891087818425}{\texttt{include}}. It has no effect outside of compilation.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/loading.jl#L820-L829}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17355831054812136492}{} 
\hyperlink{17355831054812136492}{\texttt{Base.which}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
which(f, types)
\end{minted}

Returns the method of \texttt{f} (a \texttt{Method} object) that would be called for arguments of the given \texttt{types}.

If \texttt{types} is an abstract type, then the method that would be called by \texttt{invoke} is returned.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L1133-L1139}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3025953302266245919}{} 
\hyperlink{3025953302266245919}{\texttt{Base.methods}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
methods(f, [types], [module])
\end{minted}

Return the method table for \texttt{f}.

If \texttt{types} is specified, return an array of methods whose types match. If \texttt{module} is specified, return an array of methods defined in that module. A list of modules can also be specified as an array.

\begin{quote}
\textbf{Julia 1.4}

At least Julia 1.4 is required for specifying a module.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L865-L876}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13133508810150623671}{} 
\hyperlink{13133508810150623671}{\texttt{Base.@show}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@show
\end{minted}

Show an expression and result, returning the result. See also \hyperlink{14071376285304310153}{\texttt{show}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/show.jl#L604-L608}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11288188119698492222}{} 
\hyperlink{11288188119698492222}{\texttt{ans}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ans
\end{minted}

A variable referring to the last computed value, automatically set at the interactive prompt.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1029-L1033}{\texttt{source}}


\end{adjustwidth}

\hypertarget{1461769336029416688}{}


\section{关键字}



This is the list of reserved keywords in Julia: \texttt{baremodule}, \texttt{begin}, \texttt{break}, \texttt{catch}, \texttt{const}, \texttt{continue}, \texttt{do}, \texttt{else}, \texttt{elseif}, \texttt{end}, \texttt{export}, \texttt{false}, \texttt{finally}, \texttt{for}, \texttt{function}, \texttt{global}, \texttt{if}, \texttt{import}, \texttt{let}, \texttt{local}, \texttt{macro}, \texttt{module}, \texttt{quote}, \texttt{return}, \texttt{struct}, \texttt{true}, \texttt{try}, \texttt{using}, \texttt{while}. Those keywords are not allowed to be used as variable names.



The following two-word sequences are reserved: \texttt{abstract type}, \texttt{mutable struct}, \texttt{primitive type}. However, you can create variables with names: \texttt{abstract}, \texttt{mutable}, \texttt{primitive} and \texttt{type}.



Finally, \texttt{where} is parsed as an infix operator for writing parametric method and type definitions. Also \texttt{in} and \texttt{isa} are parsed as infix operators. Creation of a variable named \texttt{where}, \texttt{in} or \texttt{isa} is allowed though.


\hypertarget{16285380181904025577}{} 
\hyperlink{16285380181904025577}{\texttt{module}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
module
\end{minted}

\texttt{module} declares a \hyperlink{6070072550914765640}{\texttt{Module}}, which is a separate global variable workspace. Within a module, you can control which names from other modules are visible (via importing), and specify which of your names are intended to be public (via exporting). Modules allow you to create top-level definitions without worrying about name conflicts when your code is used together with somebody else’s. See the \hyperlink{16725527896995457152}{manual section about modules} for more details.

\textbf{Examples}


\begin{minted}{julia}
module Foo
import Base.show
export MyType, foo

struct MyType
    x
end

bar(x) = 2x
foo(a::MyType) = bar(a.x) + 1
show(io::IO, a::MyType) = print(io, "MyType $(a.x)")
end
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L75-L100}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17583167789241791362}{} 
\hyperlink{17583167789241791362}{\texttt{export}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
export
\end{minted}

\texttt{export} is used within modules to tell Julia which functions should be made available to the user. For example: \texttt{export foo} makes the name \texttt{foo} available when \hyperlink{169458112978175560}{\texttt{using}} the module. See the \hyperlink{16725527896995457152}{manual section about modules} for details.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L49-L56}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16252475688663093021}{} 
\hyperlink{16252475688663093021}{\texttt{import}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
import
\end{minted}

\texttt{import Foo} will load the module or package \texttt{Foo}. Names from the imported \texttt{Foo} module can be accessed with dot syntax (e.g. \texttt{Foo.foo} to access the name \texttt{foo}). See the \hyperlink{16725527896995457152}{manual section about modules} for details.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L39-L46}{\texttt{source}}


\end{adjustwidth}
\hypertarget{169458112978175560}{} 
\hyperlink{169458112978175560}{\texttt{using}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
using
\end{minted}

\texttt{using Foo} will load the module or package \texttt{Foo} and make its \hyperlink{17583167789241791362}{\texttt{export}}ed names available for direct use. Names can also be used via dot syntax (e.g. \texttt{Foo.foo} to access the name \texttt{foo}), whether they are \texttt{export}ed or not. See the \hyperlink{16725527896995457152}{manual section about modules} for details.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L29-L36}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13329108222158426840}{} 
\hyperlink{13329108222158426840}{\texttt{baremodule}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
baremodule
\end{minted}

\texttt{baremodule} declares a module that does not contain \texttt{using Base} or a definition of \hyperlink{7998531662462967836}{\texttt{eval}}. It does still import \texttt{Core}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L126-L131}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5624836169846334627}{} 
\hyperlink{5624836169846334627}{\texttt{function}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
function
\end{minted}

Functions are defined with the \texttt{function} keyword:


\begin{minted}{julia}
function add(a, b)
    return a + b
end
\end{minted}

Or the short form notation:


\begin{minted}{julia}
add(a, b) = a + b
\end{minted}

The use of the \hyperlink{10918908543132060605}{\texttt{return}} keyword is exactly the same as in other languages, but is often optional. A function without an explicit \texttt{return} statement will return the last expression in the function body.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L499-L518}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4625593635027008869}{} 
\hyperlink{4625593635027008869}{\texttt{macro}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
macro
\end{minted}

\texttt{macro} defines a method for inserting generated code into a program. A macro maps a sequence of argument expressions to a returned expression, and the resulting expression is substituted directly into the program at the point where the macro is invoked. Macros are a way to run generated code without calling \hyperlink{7998531662462967836}{\texttt{eval}}, since the generated code instead simply becomes part of the surrounding program. Macro arguments may include expressions, literal values, and symbols.

\textbf{Examples}


\begin{minted}{jlcon}
julia> macro sayhello(name)
           return :( println("Hello, ", $name, "!") )
       end
@sayhello (macro with 1 method)

julia> @sayhello "Charlie"
Hello, Charlie!
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L152-L173}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10918908543132060605}{} 
\hyperlink{10918908543132060605}{\texttt{return}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
return
\end{minted}

\texttt{return x} causes the enclosing function to exit early, passing the given value \texttt{x} back to its caller. \texttt{return} by itself with no value is equivalent to \texttt{return nothing} (see \hyperlink{9331422207248206047}{\texttt{nothing}}).


\begin{minted}{julia}
function compare(a, b)
    a == b && return "equal to"
    a < b ? "less than" : "greater than"
end
\end{minted}

In general you can place a \texttt{return} statement anywhere within a function body, including within deeply nested loops or conditionals, but be careful with \texttt{do} blocks. For example:


\begin{minted}{julia}
function test1(xs)
    for x in xs
        iseven(x) && return 2x
    end
end

function test2(xs)
    map(xs) do x
        iseven(x) && return 2x
        x
    end
end
\end{minted}

In the first example, the return breaks out of \texttt{test1} as soon as it hits an even number, so \texttt{test1([5,6,7])} returns \texttt{12}.

You might expect the second example to behave the same way, but in fact the \texttt{return} there only breaks out of the \emph{inner} function (inside the \texttt{do} block) and gives a value back to \texttt{map}. \texttt{test2([5,6,7])} then returns \texttt{[5,12,7]}.

When used in a top-level expression (i.e. outside any function), \texttt{return} causes the entire current top-level expression to terminate early.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L521-L561}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16455129305818705265}{} 
\hyperlink{16455129305818705265}{\texttt{do}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
do
\end{minted}

Create an anonymous function and pass it as the first argument to a function call. For example:


\begin{minted}{julia}
map(1:10) do x
    2x
end
\end{minted}

is equivalent to \texttt{map(x->2x, 1:10)}.

Use multiple arguments like so:


\begin{minted}{julia}
map(1:10, 11:20) do x, y
    x + y
end
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L758-L780}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2050903905813838256}{} 
\hyperlink{2050903905813838256}{\texttt{begin}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
begin
\end{minted}

\texttt{begin...end} denotes a block of code.


\begin{minted}{julia}
begin
    println("Hello, ")
    println("World!")
end
\end{minted}

Usually \texttt{begin} will not be necessary, since keywords such as \hyperlink{5624836169846334627}{\texttt{function}} and \hyperlink{4956741936243461891}{\texttt{let}} implicitly begin blocks of code. See also \hyperlink{13353096094479374008}{\texttt{;}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L894-L908}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11574363005673055470}{} 
\hyperlink{11574363005673055470}{\texttt{end}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
end
\end{minted}

\texttt{end} marks the conclusion of a block of expressions, for example \hyperlink{16285380181904025577}{\texttt{module}}, \hyperlink{4119979838407461137}{\texttt{struct}}, \hyperlink{15383430693516362700}{\texttt{mutable struct}}, \hyperlink{2050903905813838256}{\texttt{begin}}, \hyperlink{4956741936243461891}{\texttt{let}}, \hyperlink{9105224580875818383}{\texttt{for}} etc. \texttt{end} may also be used when indexing into an array to represent the last index of a dimension.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> A[end, :]
2-element Array{Int64,1}:
 3
 4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L630-L651}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4956741936243461891}{} 
\hyperlink{4956741936243461891}{\texttt{let}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
let
\end{minted}

\texttt{let} statements allocate new variable bindings each time they run. Whereas an assignment modifies an existing value location, \texttt{let} creates new locations. This difference is only detectable in the case of variables that outlive their scope via closures. The \texttt{let} syntax accepts a comma-separated series of assignments and variable names:


\begin{minted}{julia}
let var1 = value1, var2, var3 = value3
    code
end
\end{minted}

The assignments are evaluated in order, with each right-hand side evaluated in the scope before the new variable on the left-hand side has been introduced. Therefore it makes sense to write something like \texttt{let x = x}, since the two \texttt{x} variables are distinct and have separate storage.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L311-L329}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11624168233949720742}{} 
\hyperlink{11624168233949720742}{\texttt{if}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
if/elseif/else
\end{minted}

\texttt{if}/\texttt{elseif}/\texttt{else} performs conditional evaluation, which allows portions of code to be evaluated or not evaluated depending on the value of a boolean expression. Here is the anatomy of the \texttt{if}/\texttt{elseif}/\texttt{else} conditional syntax:


\begin{minted}{julia}
if x < y
    println("x is less than y")
elseif x > y
    println("x is greater than y")
else
    println("x is equal to y")
end
\end{minted}

If the condition expression \texttt{x < y} is true, then the corresponding block is evaluated; otherwise the condition expression \texttt{x > y} is evaluated, and if it is true, the corresponding block is evaluated; if neither expression is true, the \texttt{else} block is evaluated. The \texttt{elseif} and \texttt{else} blocks are optional, and as many \texttt{elseif} blocks as desired can be used.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L564-L585}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9105224580875818383}{} 
\hyperlink{9105224580875818383}{\texttt{for}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
for
\end{minted}

\texttt{for} loops repeatedly evaluate a block of statements while iterating over a sequence of values.

\textbf{Examples}


\begin{minted}{jlcon}
julia> for i in [1, 4, 0]
           println(i)
       end
1
4
0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L588-L603}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15133348314455964692}{} 
\hyperlink{15133348314455964692}{\texttt{while}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
while
\end{minted}

\texttt{while} loops repeatedly evaluate a conditional expression, and continue evaluating the body of the while loop as long as the expression remains true. If the condition expression is false when the while loop is first reached, the body is never evaluated.

\textbf{Examples}


\begin{minted}{jlcon}
julia> i = 1
1

julia> while i < 5
           println(i)
           global i += 1
       end
1
2
3
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L606-L627}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6474422097180568887}{} 
\hyperlink{6474422097180568887}{\texttt{break}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
break
\end{minted}

Break out of a loop immediately.

\textbf{Examples}


\begin{minted}{jlcon}
julia> i = 0
0

julia> while true
           global i += 1
           i > 5 && break
           println(i)
       end
1
2
3
4
5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L716-L737}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8191155978135871388}{} 
\hyperlink{8191155978135871388}{\texttt{continue}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
continue
\end{minted}

Skip the rest of the current loop iteration.

\textbf{Examples}


\begin{minted}{jlcon}
julia> for i = 1:6
           iseven(i) && continue
           println(i)
       end
1
3
5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L740-L755}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16338536928035025961}{} 
\hyperlink{16338536928035025961}{\texttt{try}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
try/catch
\end{minted}

A \texttt{try}/\texttt{catch} statement allows intercepting errors (exceptions) thrown by \hyperlink{16410366672587017456}{\texttt{throw}} so that program execution can continue. For example, the following code attempts to write a file, but warns the user and proceeds instead of terminating execution if the file cannot be written:


\begin{minted}{julia}
try
    open("/danger", "w") do f
        println(f, "Hello")
    end
catch
    @warn "Could not write file."
end
\end{minted}

or, when the file cannot be read into a variable:


\begin{minted}{julia}
lines = try
    open("/danger", "r") do f
        readlines(f)
    end
catch
    @warn "File not found."
end
\end{minted}

The syntax \texttt{catch e} (where \texttt{e} is any variable) assigns the thrown exception object to the given variable within the \texttt{catch} block.

The power of the \texttt{try}/\texttt{catch} construct lies in the ability to unwind a deeply nested computation immediately to a much higher level in the stack of calling functions.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L654-L689}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1444863245857684967}{} 
\hyperlink{1444863245857684967}{\texttt{finally}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
finally
\end{minted}

Run some code when a given block of code exits, regardless of how it exits. For example, here is how we can guarantee that an opened file is closed:


\begin{minted}{julia}
f = open("file")
try
    operate_on_file(f)
finally
    close(f)
end
\end{minted}

When control leaves the \hyperlink{16338536928035025961}{\texttt{try}} block (for example, due to a \hyperlink{10918908543132060605}{\texttt{return}}, or just finishing normally), \hyperlink{5331333469799487255}{\texttt{close(f)}} will be executed. If the \texttt{try} block exits due to an exception, the exception will continue propagating. A \texttt{catch} block may be combined with \texttt{try} and \texttt{finally} as well. In this case the \texttt{finally} block will run after \texttt{catch} has handled the error.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L692-L713}{\texttt{source}}


\end{adjustwidth}
\hypertarget{569926224232766960}{} 
\hyperlink{569926224232766960}{\texttt{quote}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
quote
\end{minted}

\texttt{quote} creates multiple expression objects in a block without using the explicit \hyperlink{17120496304147995299}{\texttt{Expr}} constructor. For example:


\begin{minted}{julia}
ex = quote
    x = 1
    y = 2
    x + y
end
\end{minted}

Unlike the other means of quoting, \texttt{:( ... )}, this form introduces \texttt{QuoteNode} elements to the expression tree, which must be considered when directly manipulating the tree. For other purposes, \texttt{:( ... )} and \texttt{quote .. end} blocks are treated identically.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L332-L348}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4330407494414118784}{} 
\hyperlink{4330407494414118784}{\texttt{local}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
local
\end{minted}

\texttt{local} introduces a new local variable. See the \hyperlink{11957539949537805757}{manual section on variable scoping} for more information.

\textbf{Examples}


\begin{minted}{jlcon}
julia> function foo(n)
           x = 0
           for i = 1:n
               local x # introduce a loop-local x
               x = i
           end
           x
       end
foo (generic function with 1 method)

julia> foo(10)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L176-L197}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15648176341806922625}{} 
\hyperlink{15648176341806922625}{\texttt{global}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
global
\end{minted}

\texttt{global x} makes \texttt{x} in the current scope and its inner scopes refer to the global variable of that name. See the \hyperlink{11957539949537805757}{manual section on variable scoping} for more information.

\textbf{Examples}


\begin{minted}{jlcon}
julia> z = 3
3

julia> function foo()
           global z = 6 # use the z variable defined outside foo
       end
foo (generic function with 1 method)

julia> foo()
6

julia> z
6
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L200-L223}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8421885763632484758}{} 
\hyperlink{8421885763632484758}{\texttt{const}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
const
\end{minted}

\texttt{const} is used to declare global variables whose values will not change. In almost all code (and particularly performance sensitive code) global variables should be declared constant in this way.


\begin{minted}{julia}
const x = 5
\end{minted}

Multiple variables can be declared within a single \texttt{const}:


\begin{minted}{julia}
const y, z = 7, 11
\end{minted}

Note that \texttt{const} only applies to one \texttt{=} operation, therefore \texttt{const x = y = 1} declares \texttt{x} to be constant but not \texttt{y}. On the other hand, \texttt{const x = const y = 1} declares both \texttt{x} and \texttt{y} constant.

Note that {\textquotedbl}constant-ness{\textquotedbl} does not extend into mutable containers; only the association between a variable and its value is constant. If \texttt{x} is an array or dictionary (for example) you can still modify, add, or remove elements.

In some cases changing the value of a \texttt{const} variable gives a warning instead of an error. However, this can produce unpredictable behavior or corrupt the state of your program, and so should be avoided. This feature is intended only for convenience during interactive use.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L467-L496}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4119979838407461137}{} 
\hyperlink{4119979838407461137}{\texttt{struct}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
struct
\end{minted}

The most commonly used kind of type in Julia is a struct, specified as a name and a set of fields.


\begin{minted}{julia}
struct Point
    x
    y
end
\end{minted}

Fields can have type restrictions, which may be parameterized:


\begin{minted}{julia}
struct Point{X}
    x::X
    y::Float64
end
\end{minted}

A struct can also declare an abstract super type via \texttt{<:} syntax:


\begin{minted}{julia}
struct Point <: AbstractPoint
    x
    y
end
\end{minted}

\texttt{struct}s are immutable by default; an instance of one of these types cannot be modified after construction. Use \hyperlink{15383430693516362700}{\texttt{mutable struct}} instead to declare a type whose instances can be modified.

See the manual section on \href{@ref}{Composite Types} for more details, such as how to define constructors.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L911-L948}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15383430693516362700}{} 
\hyperlink{15383430693516362700}{\texttt{mutable struct}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mutable struct
\end{minted}

\texttt{mutable struct} is similar to \hyperlink{4119979838407461137}{\texttt{struct}}, but additionally allows the fields of the type to be set after construction. See the manual section on \href{@ref}{Composite Types} for more information.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L951-L957}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12403756508738429935}{} 
\hyperlink{12403756508738429935}{\texttt{abstract type}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
abstract type
\end{minted}

\texttt{abstract type} declares a type that cannot be instantiated, and serves only as a node in the type graph, thereby describing sets of related concrete types: those concrete types which are their descendants. Abstract types form the conceptual hierarchy which makes Julia’s type system more than just a collection of object implementations. For example:


\begin{minted}{julia}
abstract type Number end
abstract type Real <: Number end
\end{minted}

\hyperlink{1990584313715697055}{\texttt{Number}} has no supertype, whereas \hyperlink{6175959395021454412}{\texttt{Real}} is an abstract subtype of \texttt{Number}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L59-L72}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7972868697479608081}{} 
\hyperlink{7972868697479608081}{\texttt{primitive type}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
primitive type
\end{minted}

\texttt{primitive type} declares a concrete type whose data consists only of a series of bits. Classic examples of primitive types are integers and floating-point values. Some example built-in primitive type declarations:


\begin{minted}{julia}
primitive type Char 32 end
primitive type Bool <: Integer 8 end
\end{minted}

The number after the name indicates how many bits of storage the type requires. Currently, only sizes that are multiples of 8 bits are supported. The \hyperlink{46725311238864537}{\texttt{Bool}} declaration shows how a primitive type can be optionally declared to be a subtype of some supertype.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L134-L149}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7395867868929900722}{} 
\hyperlink{7395867868929900722}{\texttt{where}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
where
\end{minted}

The \texttt{where} keyword creates a type that is an iterated union of other types, over all values of some variable. For example \texttt{Vector\{T\} where T<:Real} includes all \hyperlink{10571362059486397014}{\texttt{Vector}}s where the element type is some kind of \texttt{Real} number.

The variable bound defaults to \hyperlink{15014186392807667022}{\texttt{Any}} if it is omitted:


\begin{minted}{julia}
Vector{T} where T    # short for `where T<:Any`
\end{minted}

Variables can also have lower bounds:


\begin{minted}{julia}
Vector{T} where T>:Int
Vector{T} where Int<:T<:Real
\end{minted}

There is also a concise syntax for nested \texttt{where} expressions. For example, this:


\begin{minted}{julia}
Pair{T, S} where S<:Array{T} where T<:Number
\end{minted}

can be shortened to:


\begin{minted}{julia}
Pair{T, S} where {T<:Number, S<:Array{T}}
\end{minted}

This form is often found on method signatures.

Note that in this form, the variables are listed outermost-first. This matches the order in which variables are substituted when a type is {\textquotedbl}applied{\textquotedbl} to parameter values using the syntax \texttt{T\{p1, p2, ...\}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L970-L1003}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4851239593686894811}{} 
\hyperlink{4851239593686894811}{\texttt{...}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
...
\end{minted}

The {\textquotedbl}splat{\textquotedbl} operator, \texttt{...}, represents a sequence of arguments. \texttt{...} can be used in function definitions, to indicate that the function accepts an arbitrary number of arguments. \texttt{...} can also be used to apply a function to a sequence of arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> add(xs...) = reduce(+, xs)
add (generic function with 1 method)

julia> add(1, 2, 3, 4, 5)
15

julia> add([1, 2, 3]...)
6

julia> add(7, 1:100..., 1000:1100...)
111107
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L783-L805}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13353096094479374008}{} 
\hyperlink{13353096094479374008}{\texttt{;}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
;
\end{minted}

\texttt{;} has a similar role in Julia as in many C-like languages, and is used to delimit the end of the previous statement. \texttt{;} is not necessary after new lines, but can be used to separate statements on a single line or to join statements into a single expression. \texttt{;} is also used to suppress output printing in the REPL and similar interfaces.

\textbf{Examples}


\begin{minted}{julia}
julia> function foo()
           x = "Hello, "; x *= "World!"
           return x
       end
foo (generic function with 1 method)

julia> bar() = (x = "Hello, Mars!"; return x)
bar (generic function with 1 method)

julia> foo();

julia> bar()
"Hello, Mars!"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L808-L832}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6802539926897218580}{} 
\hyperlink{6802539926897218580}{\texttt{=}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
=
\end{minted}

\texttt{=} is the assignment operator.

\begin{itemize}
\item For variable \texttt{a} and expression \texttt{b}, \texttt{a = b} makes \texttt{a} refer to the value of \texttt{b}.


\item For functions \texttt{f(x)}, \texttt{f(x) = x} defines a new function constant \texttt{f}, or adds a new method to \texttt{f} if \texttt{f} is already defined; this usage is equivalent to \texttt{function f(x); x; end}.


\item \texttt{a[i] = v} calls \hyperlink{1309244355901386657}{\texttt{setindex!}}\texttt{(a,v,i)}.


\item \texttt{a.b = c} calls \hyperlink{9055518433069578344}{\texttt{setproperty!}}\texttt{(a,:b,c)}.


\item Inside a function call, \texttt{f(a=b)} passes \texttt{b} as the value of keyword argument \texttt{a}.


\item Inside parentheses with commas, \texttt{(a=1,)} constructs a \hyperlink{3845731488275720657}{\texttt{NamedTuple}}.

\end{itemize}
\textbf{Examples}

Assigning \texttt{a} to \texttt{b} does not create a copy of \texttt{b}; instead use \hyperlink{15665284441316555522}{\texttt{copy}} or \hyperlink{3259459540194502889}{\texttt{deepcopy}}.


\begin{minted}{jlcon}
julia> b = [1]; a = b; b[1] = 2; a
1-element Array{Int64,1}:
 2

julia> b = [1]; a = copy(b); b[1] = 2; a
1-element Array{Int64,1}:
 1

\end{minted}

Collections passed to functions are also not copied. Functions can modify (mutate) the contents of the objects their arguments refer to. (The names of functions which do this are conventionally suffixed with {\textquotesingle}!{\textquotesingle}.)


\begin{minted}{jlcon}
julia> function f!(x); x[:] .+= 1; end
f! (generic function with 1 method)

julia> a = [1]; f!(a); a
1-element Array{Int64,1}:
 2

\end{minted}

Assignment can operate on multiple variables in parallel, taking values from an iterable:


\begin{minted}{jlcon}
julia> a, b = 4, 5
(4, 5)

julia> a, b = 1:3
1:3

julia> a, b
(1, 2)

\end{minted}

Assignment can operate on multiple variables in series, and will return the value of the right-hand-most expression:


\begin{minted}{jlcon}
julia> a = [1]; b = [2]; c = [3]; a = b = c
1-element Array{Int64,1}:
 3

julia> b[1] = 2; a, b, c
([2], [2], [2])

\end{minted}

Assignment at out-of-bounds indices does not grow a collection. If the collection is a \hyperlink{10571362059486397014}{\texttt{Vector}} it can instead be grown with \hyperlink{18026893834387542681}{\texttt{push!}} or \hyperlink{2587432243763606566}{\texttt{append!}}.


\begin{minted}{jlcon}
julia> a = [1, 1]; a[3] = 2
ERROR: BoundsError: attempt to access 2-element Array{Int64,1} at index [3]
[...]

julia> push!(a, 2, 3)
4-element Array{Int64,1}:
 1
 1
 2
 3

\end{minted}

Assigning \texttt{[]} does not eliminate elements from a collection; instead use \hyperlink{3384092630307389071}{\texttt{filter!}}.


\begin{minted}{jlcon}
julia> a = collect(1:3); a[a .<= 1] = []
ERROR: DimensionMismatch("tried to assign 0 elements to 1 destinations")
[...]

julia> filter!(x -> x > 1, a) # in-place & thus more efficient than a = a[a .> 1]
2-element Array{Int64,1}:
 2
 3

\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L226-L308}{\texttt{source}}


\end{adjustwidth}

\hypertarget{128695592908019721}{}


\section{Standard Modules}


\hypertarget{7094459820733568273}{} 
\hyperlink{7094459820733568273}{\texttt{Main}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Main
\end{minted}

\texttt{Main} is the top-level module, and Julia starts with \texttt{Main} set as the current module.  Variables defined at the prompt go in \texttt{Main}, and \texttt{varinfo} lists variables in \texttt{Main}.


\begin{minted}{jlcon}
julia> @__MODULE__
Main
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2335-L2343}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14876339894285762624}{} 
\hyperlink{14876339894285762624}{\texttt{Core}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Core
\end{minted}

\texttt{Core} is the module that contains all identifiers considered {\textquotedbl}built in{\textquotedbl} to the language, i.e. part of the core language and not libraries. Every module implicitly specifies \texttt{using Core}, since you can{\textquotesingle}t do anything without those definitions.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2328-L2332}{\texttt{source}}


\end{adjustwidth}
\hypertarget{464144976511314225}{} 
\hyperlink{464144976511314225}{\texttt{Base}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base
\end{minted}

The base library of Julia. \texttt{Base} is a module that contains basic functionality (the contents of \texttt{base/}). All modules implicitly contain \texttt{using Base}, since this is needed in the vast majority of cases.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2346-L2350}{\texttt{source}}


\end{adjustwidth}

\hypertarget{5508136195995469038}{}


\section{Base Submodules}


\hypertarget{9799306936683713029}{} 
\hyperlink{9799306936683713029}{\texttt{Base.Broadcast}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.Broadcast
\end{minted}

Module containing the broadcasting implementation.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/broadcast.jl#L3-L7}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1765705340642413832}{} 
\hyperlink{1765705340642413832}{\texttt{Base.Docs}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Docs
\end{minted}

The \texttt{Docs} module provides the \texttt{@doc} macro which can be used to set and retrieve documentation metadata for Julia objects.

Please see the manual section on documentation for more information.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/Docs.jl#L3-L11}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12000006282392952693}{} 
\hyperlink{12000006282392952693}{\texttt{Base.Iterators}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}

Methods for working with Iterators.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L3-L5}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3335410005884556492}{} 
\hyperlink{3335410005884556492}{\texttt{Base.Libc}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}

Interface to libc, the C standard library.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L4-L6}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8471843084197669597}{} 
\hyperlink{8471843084197669597}{\texttt{Base.Meta}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}

Convenience functions for metaprogramming.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/meta.jl#L3-L5}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6478309095911256465}{} 
\hyperlink{6478309095911256465}{\texttt{Base.StackTraces}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}

Tools for collecting and manipulating stack traces. Mainly used for building errors.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stacktraces.jl#L3-L5}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4151026031590153569}{} 
\hyperlink{4151026031590153569}{\texttt{Base.Sys}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}

Provide methods for retrieving information about hardware and the operating system.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L4-L6}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3241995235349190465}{} 
\hyperlink{3241995235349190465}{\texttt{Base.Threads}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}

Experimental multithreading support.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/threads.jl#L3-L5}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9832907666069494090}{} 
\hyperlink{9832907666069494090}{\texttt{Base.GC}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.GC
\end{minted}

Module with garbage collection utilities.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/gcutils.jl#L45-L49}{\texttt{source}}


\end{adjustwidth}

\hypertarget{17640924221043151492}{}


\section{All Objects}


\hypertarget{7974744969331231272}{} 
\hyperlink{7974744969331231272}{\texttt{Core.:===}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
===(x,y) -> Bool
≡(x,y) -> Bool
\end{minted}

Determine whether \texttt{x} and \texttt{y} are identical, in the sense that no program could distinguish them. First the types of \texttt{x} and \texttt{y} are compared. If those are identical, mutable objects are compared by address in memory and immutable objects (such as numbers) are compared by contents at the bit level. This function is sometimes called {\textquotedbl}egal{\textquotedbl}. It always returns a \texttt{Bool} value.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1, 2]; b = [1, 2];

julia> a == b
true

julia> a === b
false

julia> a === a
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L196-L219}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7066325108767373297}{} 
\hyperlink{7066325108767373297}{\texttt{Core.isa}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isa(x, type) -> Bool
\end{minted}

Determine whether \texttt{x} is of the given \texttt{type}. Can also be used as an infix operator, e.g. \texttt{x isa type}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isa(1, Int)
true

julia> isa(1, Matrix)
false

julia> isa(1, Char)
false

julia> isa(1, Number)
true

julia> 1 isa Number
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1414-L1437}{\texttt{source}}


\end{adjustwidth}
\hypertarget{269533589463185031}{} 
\hyperlink{269533589463185031}{\texttt{Base.isequal}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isequal(x, y)
\end{minted}

Similar to \hyperlink{15143149452920304570}{\texttt{==}}, except for the treatment of floating point numbers and of missing values. \texttt{isequal} treats all floating-point \texttt{NaN} values as equal to each other, treats \texttt{-0.0} as unequal to \texttt{0.0}, and \hyperlink{14596725676261444434}{\texttt{missing}} as equal to \texttt{missing}. Always returns a \texttt{Bool} value.

\textbf{Implementation}

The default implementation of \texttt{isequal} calls \texttt{==}, so a type that does not involve floating-point values generally only needs to define \texttt{==}.

\texttt{isequal} is the comparison function used by hash tables (\texttt{Dict}). \texttt{isequal(x,y)} must imply that \texttt{hash(x) == hash(y)}.

This typically means that types for which a custom \texttt{==} or \texttt{isequal} method exists must implement a corresponding \texttt{hash} method (and vice versa). Collections typically implement \texttt{isequal} by calling \texttt{isequal} recursively on all contents.

Scalar types generally do not need to implement \texttt{isequal} separate from \texttt{==}, unless they represent floating-point numbers amenable to a more efficient implementation than that provided as a generic fallback (based on \texttt{isnan}, \texttt{signbit}, and \texttt{==}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> isequal([1., NaN], [1., NaN])
true

julia> [1., NaN] == [1., NaN]
false

julia> 0.0 == -0.0
true

julia> isequal(0.0, -0.0)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L85-L122}{\texttt{source}}



\begin{lstlisting}
isequal(x)
\end{lstlisting}

Create a function that compares its argument to \texttt{x} using \hyperlink{269533589463185031}{\texttt{isequal}}, i.e. a function equivalent to \texttt{y -> isequal(y, x)}.

The returned function is of type \texttt{Base.Fix2\{typeof(isequal)\}}, which can be used to implement specialized methods.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L916-L924}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8062916604071842790}{} 
\hyperlink{8062916604071842790}{\texttt{Base.isless}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isless(x, y)
\end{minted}

Test whether \texttt{x} is less than \texttt{y}, according to a fixed total order. \texttt{isless} is not defined on all pairs of values \texttt{(x, y)}. However, if it is defined, it is expected to satisfy the following:

\begin{itemize}
\item If \texttt{isless(x, y)} is defined, then so is \texttt{isless(y, x)} and \texttt{isequal(x, y)}, and exactly one of those three yields \texttt{true}.


\item The relation defined by \texttt{isless} is transitive, i.e., \texttt{isless(x, y) \&\& isless(y, z)} implies \texttt{isless(x, z)}.

\end{itemize}
Values that are normally unordered, such as \texttt{NaN}, are ordered in an arbitrary but consistent fashion. \hyperlink{14596725676261444434}{\texttt{missing}} values are ordered last.

This is the default comparison used by \hyperlink{8473525809131227606}{\texttt{sort}}.

\textbf{Implementation}

Non-numeric types with a total order should implement this function. Numeric types only need to implement it if they have special values such as \texttt{NaN}. Types with a partial order should implement \hyperlink{702782232449268329}{\texttt{<}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L132-L153}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12785896617485598962}{} 
\hyperlink{12785896617485598962}{\texttt{Core.ifelse}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ifelse(condition::Bool, x, y)
\end{minted}

Return \texttt{x} if \texttt{condition} is \texttt{true}, otherwise return \texttt{y}. This differs from \texttt{?} or \texttt{if} in that it is an ordinary function, so all the arguments are evaluated first. In some cases, using \texttt{ifelse} instead of an \texttt{if} statement can eliminate the branch in generated code and provide higher performance in tight loops.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ifelse(1 > 2, 1, 2)
2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L348-L361}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11044636010338290257}{} 
\hyperlink{11044636010338290257}{\texttt{Core.typeassert}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
typeassert(x, type)
\end{minted}

Throw a \hyperlink{2622693721821893139}{\texttt{TypeError}} unless \texttt{x isa type}. The syntax \texttt{x::type} calls this function.

\textbf{Examples}


\begin{minted}{jlcon}
julia> typeassert(2.5, Int)
ERROR: TypeError: in typeassert, expected Int64, got Float64
Stacktrace:
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2227-L2240}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13440452181855594120}{} 
\hyperlink{13440452181855594120}{\texttt{Core.typeof}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
typeof(x)
\end{minted}

Get the concrete type of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = 1//2;

julia> typeof(a)
Rational{Int64}

julia> M = [1 2; 3.5 4];

julia> typeof(M)
Array{Float64,2}
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1667-L1684}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12342862450082530092}{} 
\hyperlink{12342862450082530092}{\texttt{Core.tuple}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tuple(xs...)
\end{minted}

Construct a tuple of the given objects.

\textbf{Examples}


\begin{minted}{jlcon}
julia> tuple(1, 'a', pi)
(1, 'a', π)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1601-L1611}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11196859324054101444}{} 
\hyperlink{11196859324054101444}{\texttt{Base.ntuple}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ntuple(f::Function, n::Integer)
\end{minted}

Create a tuple of length \texttt{n}, computing each element as \texttt{f(i)}, where \texttt{i} is the index of the element.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ntuple(i -> 2*i, 4)
(2, 4, 6, 8)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ntuple.jl#L5-L16}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9461762562299643141}{} 
\hyperlink{9461762562299643141}{\texttt{Base.objectid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
objectid(x)
\end{minted}

Get a hash value for \texttt{x} based on object identity. \texttt{objectid(x)==objectid(y)} if \texttt{x === y}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L307-L311}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13797072367283572032}{} 
\hyperlink{13797072367283572032}{\texttt{Base.hash}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hash(x[, h::UInt])
\end{minted}

Compute an integer hash code such that \texttt{isequal(x,y)} implies \texttt{hash(x)==hash(y)}. The optional second argument \texttt{h} is a hash code to be mixed with the result.

New types should implement the 2-argument form, typically by calling the 2-argument \texttt{hash} method recursively in order to mix hashes of the contents with each other (and with \texttt{h}). Typically, any type that implements \texttt{hash} should also implement its own \texttt{==} (hence \texttt{isequal}) to guarantee the property mentioned above. Types supporting subtraction (operator \texttt{-}) should also implement \hyperlink{18091106262785739128}{\texttt{widen}}, which is required to hash values inside heterogeneous arrays.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/hashing.jl#L5-L17}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4805357059330171046}{} 
\hyperlink{4805357059330171046}{\texttt{Base.finalizer}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
finalizer(f, x)
\end{minted}

Register a function \texttt{f(x)} to be called when there are no program-accessible references to \texttt{x}, and return \texttt{x}. The type of \texttt{x} must be a \texttt{mutable struct}, otherwise the behavior of this function is unpredictable.

\texttt{f} must not cause a task switch, which excludes most I/O operations such as \texttt{println}. \texttt{@schedule println({\textquotedbl}message{\textquotedbl})} or \texttt{ccall(:jl\_, Cvoid, (Any,), {\textquotedbl}message{\textquotedbl})} may be helpful for debugging purposes.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/gcutils.jl#L7-L17}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6584919147438336166}{} 
\hyperlink{6584919147438336166}{\texttt{Base.finalize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
finalize(x)
\end{minted}

Immediately run finalizers registered for object \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/gcutils.jl#L37-L41}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15665284441316555522}{} 
\hyperlink{15665284441316555522}{\texttt{Base.copy}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
copy(x)
\end{minted}

Create a shallow copy of \texttt{x}: the outer structure is copied, but not all internal values. For example, copying an array produces a new array with identically-same elements as the original.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L343-L349}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3259459540194502889}{} 
\hyperlink{3259459540194502889}{\texttt{Base.deepcopy}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
deepcopy(x)
\end{minted}

Create a deep copy of \texttt{x}: everything is copied recursively, resulting in a fully independent object. For example, deep-copying an array produces a new array whose elements are deep copies of the original elements. Calling \texttt{deepcopy} on an object should generally have the same effect as serializing and then deserializing it.

While it isn{\textquotesingle}t normally necessary, user-defined types can override the default \texttt{deepcopy} behavior by defining a specialized version of the function \texttt{deepcopy\_internal(x::T, dict::IdDict)} (which shouldn{\textquotesingle}t otherwise be used), where \texttt{T} is the type to be specialized for, and \texttt{dict} keeps track of objects copied so far within the recursion. Within the definition, \texttt{deepcopy\_internal} should be used in place of \texttt{deepcopy}, and the \texttt{dict} variable should be updated as appropriate before returning.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/deepcopy.jl#L8-L23}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11040282462516403506}{} 
\hyperlink{11040282462516403506}{\texttt{Base.getproperty}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getproperty(value, name::Symbol)
\end{minted}

The syntax \texttt{a.b} calls \texttt{getproperty(a, :b)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> struct MyType
           x
       end

julia> function Base.getproperty(obj::MyType, sym::Symbol)
           if sym === :special
               return obj.x + 1
           else # fallback to getfield
               return getfield(obj, sym)
           end
       end

julia> obj = MyType(1);

julia> obj.special
2

julia> obj.x
1
\end{minted}

See also \hyperlink{9156534253458520177}{\texttt{propertynames}} and \hyperlink{9055518433069578344}{\texttt{setproperty!}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2243-L2273}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9055518433069578344}{} 
\hyperlink{9055518433069578344}{\texttt{Base.setproperty!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
setproperty!(value, name::Symbol, x)
\end{minted}

The syntax \texttt{a.b = c} calls \texttt{setproperty!(a, :b, c)}.

See also \hyperlink{9156534253458520177}{\texttt{propertynames}} and \hyperlink{11040282462516403506}{\texttt{getproperty}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2276-L2283}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9156534253458520177}{} 
\hyperlink{9156534253458520177}{\texttt{Base.propertynames}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
propertynames(x, private=false)
\end{minted}

Get a tuple or a vector of the properties (\texttt{x.property}) of an object \texttt{x}. This is typically the same as \hyperlink{17481253338332315021}{\texttt{fieldnames(typeof(x))}}, but types that overload \hyperlink{11040282462516403506}{\texttt{getproperty}} should generally overload \texttt{propertynames} as well to get the properties of an instance of the type.

\texttt{propertynames(x)} may return only {\textquotedbl}public{\textquotedbl} property names that are part of the documented interface of \texttt{x}.   If you want it to also return {\textquotedbl}private{\textquotedbl} fieldnames intended for internal use, pass \texttt{true} for the optional second argument. REPL tab completion on \texttt{x.} shows only the \texttt{private=false} properties.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L1348-L1360}{\texttt{source}}


\end{adjustwidth}
\hypertarget{754956111730806889}{} 
\hyperlink{754956111730806889}{\texttt{Base.hasproperty}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hasproperty(x, s::Symbol)
\end{minted}

Return a boolean indicating whether the object \texttt{x} has \texttt{s} as one of its own properties.

\begin{quote}
\textbf{Julia 1.2}

This function requires at least Julia 1.2.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L1365-L1372}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13312214354258464709}{} 
\hyperlink{13312214354258464709}{\texttt{Core.getfield}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getfield(value, name::Symbol)
getfield(value, i::Int)
\end{minted}

Extract a field from a composite \texttt{value} by name or position. See also \hyperlink{11040282462516403506}{\texttt{getproperty}} and \hyperlink{17481253338332315021}{\texttt{fieldnames}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = 1//2
1//2

julia> getfield(a, :num)
1

julia> a.num
1

julia> getfield(a, 1)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1614-L1635}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11796708313392299971}{} 
\hyperlink{11796708313392299971}{\texttt{Core.setfield!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
setfield!(value, name::Symbol, x)
\end{minted}

Assign \texttt{x} to a named field in \texttt{value} of composite type. The \texttt{value} must be mutable and \texttt{x} must be a subtype of \texttt{fieldtype(typeof(value), name)}. See also \hyperlink{9055518433069578344}{\texttt{setproperty!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> mutable struct MyMutableStruct
           field::Int
       end

julia> a = MyMutableStruct(1);

julia> setfield!(a, :field, 2);

julia> getfield(a, :field)
2

julia> a = 1//2
1//2

julia> setfield!(a, :num, 3);
ERROR: setfield! immutable struct of type Rational cannot be changed
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1638-L1664}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11212950246505288748}{} 
\hyperlink{11212950246505288748}{\texttt{Core.isdefined}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isdefined(m::Module, s::Symbol)
isdefined(object, s::Symbol)
isdefined(object, index::Int)
\end{minted}

Tests whether a global variable or object field is defined. The arguments can be a module and a symbol or a composite object and field name (as a symbol) or index.

To test whether an array element is defined, use \hyperlink{976355747478401147}{\texttt{isassigned}} instead.

See also \hyperlink{3530198890456603420}{\texttt{@isdefined}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isdefined(Base, :sum)
true

julia> isdefined(Base, :NonExistentMethod)
false

julia> a = 1//2;

julia> isdefined(a, 2)
true

julia> isdefined(a, 3)
false

julia> isdefined(a, :num)
true

julia> isdefined(a, :numerator)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1687-L1721}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3530198890456603420}{} 
\hyperlink{3530198890456603420}{\texttt{Base.@isdefined}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@isdefined s -> Bool
\end{minted}

Tests whether variable \texttt{s} is defined in the current scope.

See also \hyperlink{11212950246505288748}{\texttt{isdefined}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> function f()
           println(@isdefined x)
           x = 3
           println(@isdefined x)
       end
f (generic function with 1 method)

julia> f()
false
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L243-L263}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1846942650946171605}{} 
\hyperlink{1846942650946171605}{\texttt{Base.convert}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
convert(T, x)
\end{minted}

Convert \texttt{x} to a value of type \texttt{T}.

If \texttt{T} is an \hyperlink{8469131683393450448}{\texttt{Integer}} type, an \hyperlink{5399118524830636312}{\texttt{InexactError}} will be raised if \texttt{x} is not representable by \texttt{T}, for example if \texttt{x} is not integer-valued, or is outside the range supported by \texttt{T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> convert(Int, 3.0)
3

julia> convert(Int, 3.5)
ERROR: InexactError: Int64(3.5)
Stacktrace:
[...]
\end{minted}

If \texttt{T} is a \hyperlink{11465394427882483091}{\texttt{AbstractFloat}} or \hyperlink{8304566144531167610}{\texttt{Rational}} type, then it will return the closest value to \texttt{x} representable by \texttt{T}.


\begin{minted}{jlcon}
julia> x = 1/3
0.3333333333333333

julia> convert(Float32, x)
0.33333334f0

julia> convert(Rational{Int32}, x)
1//3

julia> convert(Rational{Int64}, x)
6004799503160661//18014398509481984
\end{minted}

If \texttt{T} is a collection type and \texttt{x} a collection, the result of \texttt{convert(T, x)} may alias all or part of \texttt{x}.


\begin{minted}{jlcon}
julia> x = Int[1, 2, 3];

julia> y = convert(Vector{Int}, x);

julia> y === x
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L119-L166}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1760874576431605095}{} 
\hyperlink{1760874576431605095}{\texttt{Base.promote}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
promote(xs...)
\end{minted}

Convert all arguments to a common type, and return them all (as a tuple). If no arguments can be converted, an error is raised.

\textbf{Examples}


\begin{minted}{jlcon}
julia> promote(Int8(1), Float16(4.5), Float32(4.1))
(1.0f0, 4.5f0, 4.1f0)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/promotion.jl#L242-L253}{\texttt{source}}


\end{adjustwidth}
\hypertarget{374166931194490566}{} 
\hyperlink{374166931194490566}{\texttt{Base.oftype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
oftype(x, y)
\end{minted}

Convert \texttt{y} to the type of \texttt{x} (\texttt{convert(typeof(x), y)}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = 4;

julia> y = 3.;

julia> oftype(x, y)
3

julia> oftype(y, x)
4.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L351-L368}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18091106262785739128}{} 
\hyperlink{18091106262785739128}{\texttt{Base.widen}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
widen(x)
\end{minted}

If \texttt{x} is a type, return a {\textquotedbl}larger{\textquotedbl} type, defined so that arithmetic operations \texttt{+} and \texttt{-} are guaranteed not to overflow nor lose precision for any combination of values that type \texttt{x} can hold.

For fixed-size integer types less than 128 bits, \texttt{widen} will return a type with twice the number of bits.

If \texttt{x} is a value, it is converted to \texttt{widen(typeof(x))}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> widen(Int32)
Int64

julia> widen(1.5f0)
1.5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L786-L806}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18150582836499084779}{} 
\hyperlink{18150582836499084779}{\texttt{Base.identity}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
identity(x)
\end{minted}

The identity function. Returns its argument.

\textbf{Examples}


\begin{minted}{jlcon}
julia> identity("Well, what did you expect?")
"Well, what did you expect?"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L491-L501}{\texttt{source}}


\end{adjustwidth}

\hypertarget{3637915929986814863}{}


\section{Properties of Types}



\hypertarget{12208529669326883573}{}


\subsection{Type relations}


\hypertarget{12192788431675298651}{} 
\hyperlink{12192788431675298651}{\texttt{Base.supertype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
supertype(T::DataType)
\end{minted}

Return the supertype of DataType \texttt{T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> supertype(Int32)
Signed
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L32-L42}{\texttt{source}}


\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Core.Type}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}


\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Core.DataType}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{6254591906563366276}{} 
\hyperlink{6254591906563366276}{\texttt{Core.:<:}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
<:(T1, T2)
\end{minted}

Subtype operator: returns \texttt{true} if and only if all values of type \texttt{T1} are also of type \texttt{T2}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Float64 <: AbstractFloat
true

julia> Vector{Int} <: AbstractArray
true

julia> Matrix{Float64} <: Matrix{AbstractFloat}
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L5-L22}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13074915255343859584}{} 
\hyperlink{13074915255343859584}{\texttt{Base.:>:}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
>:(T1, T2)
\end{minted}

Supertype operator, equivalent to \texttt{T2 <: T1}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L25-L29}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6895589781245489183}{} 
\hyperlink{6895589781245489183}{\texttt{Base.typejoin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
typejoin(T, S)
\end{minted}

Return the closest common ancestor of \texttt{T} and \texttt{S}, i.e. the narrowest type from which they both inherit.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/promotion.jl#L5-L11}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1869272868531275554}{} 
\hyperlink{1869272868531275554}{\texttt{Base.typeintersect}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
typeintersect(T, S)
\end{minted}

Compute a type that contains the intersection of \texttt{T} and \texttt{S}. Usually this will be the smallest such type or one close to it.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L587-L592}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15048881762587391286}{} 
\hyperlink{15048881762587391286}{\texttt{Base.promote\_type}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
promote_type(type1, type2)
\end{minted}

Promotion refers to converting values of mixed types to a single common type. \texttt{promote\_type} represents the default promotion behavior in Julia when operators (usually mathematical) are given arguments of differing types. \texttt{promote\_type} generally tries to return a type which can at least approximate most values of either input type without excessively widening.  Some loss is tolerated; for example, \texttt{promote\_type(Int64, Float64)} returns \hyperlink{5027751419500983000}{\texttt{Float64}} even though strictly, not all \hyperlink{7720564657383125058}{\texttt{Int64}} values can be represented exactly as \texttt{Float64} values.


\begin{minted}{jlcon}
julia> promote_type(Int64, Float64)
Float64

julia> promote_type(Int32, Int64)
Int64

julia> promote_type(Float32, BigInt)
BigFloat

julia> promote_type(Int16, Float16)
Float16

julia> promote_type(Int64, Float16)
Float16

julia> promote_type(Int8, UInt16)
UInt16
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/promotion.jl#L173-L204}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16547112220540026290}{} 
\hyperlink{16547112220540026290}{\texttt{Base.promote\_rule}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
promote_rule(type1, type2)
\end{minted}

Specifies what type should be used by \hyperlink{1760874576431605095}{\texttt{promote}} when given values of types \texttt{type1} and \texttt{type2}. This function should not be called directly, but should have definitions added to it for new types as appropriate.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/promotion.jl#L226-L232}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7941351778625214321}{} 
\hyperlink{7941351778625214321}{\texttt{Base.isdispatchtuple}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isdispatchtuple(T)
\end{minted}

Determine whether type \texttt{T} is a tuple {\textquotedbl}leaf type{\textquotedbl}, meaning it could appear as a type signature in dispatch and has no subtypes (or supertypes) which could appear in a call.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L482-L488}{\texttt{source}}


\end{adjustwidth}

\hypertarget{5044551426260747944}{}


\subsection{Declared structure}



\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Base.ismutable}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{13869545361033105546}{} 
\hyperlink{13869545361033105546}{\texttt{Base.isimmutable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isimmutable(v) -> Bool
\end{minted}

Return \texttt{true} iff value \texttt{v} is immutable.  See \href{@ref}{Mutable Composite Types} for a discussion of immutability. Note that this function works on values, so if you give it a type, it will tell you that a value of \texttt{DataType} is mutable.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isimmutable(1)
true

julia> isimmutable([1,2])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L404-L419}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5418736735412668772}{} 
\hyperlink{5418736735412668772}{\texttt{Base.isabstracttype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isabstracttype(T)
\end{minted}

Determine whether type \texttt{T} was declared as an abstract type (i.e. using the \texttt{abstract} keyword).

\textbf{Examples}


\begin{minted}{jlcon}
julia> isabstracttype(AbstractArray)
true

julia> isabstracttype(Vector)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L532-L546}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4186582503402156523}{} 
\hyperlink{4186582503402156523}{\texttt{Base.isprimitivetype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isprimitivetype(T) -> Bool
\end{minted}

Determine whether type \texttt{T} was declared as a primitive type (i.e. using the \texttt{primitive} keyword).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L437-L442}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1553131089235872077}{} 
\hyperlink{1553131089235872077}{\texttt{Base.issingletontype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.issingletontype(T)
\end{minted}

Determine whether type \texttt{T} has exactly one possible instance; for example, a struct type with no fields.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L554-L559}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16402814804737397668}{} 
\hyperlink{16402814804737397668}{\texttt{Base.isstructtype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isstructtype(T) -> Bool
\end{minted}

Determine whether type \texttt{T} was declared as a struct type (i.e. using the \texttt{struct} or \texttt{mutable struct} keyword).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L422-L427}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1199014503871893996}{} 
\hyperlink{1199014503871893996}{\texttt{Base.nameof}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nameof(t::DataType) -> Symbol
\end{minted}

Get the name of a (potentially \texttt{UnionAll}-wrapped) \texttt{DataType} (without its parent module) as a symbol.

\textbf{Examples}


\begin{minted}{jlcon}
julia> module Foo
           struct S{T}
           end
       end
Foo

julia> nameof(Foo.S{T} where T)
:S
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L192-L209}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17481253338332315021}{} 
\hyperlink{17481253338332315021}{\texttt{Base.fieldnames}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fieldnames(x::DataType)
\end{minted}

Get a tuple with the names of the fields of a \texttt{DataType}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> fieldnames(Rational)
(:num, :den)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L161-L171}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3835503835621011695}{} 
\hyperlink{3835503835621011695}{\texttt{Base.fieldname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fieldname(x::DataType, i::Integer)
\end{minted}

Get the name of field \texttt{i} of a \texttt{DataType}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> fieldname(Rational, 1)
:num

julia> fieldname(Rational, 2)
:den
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L131-L144}{\texttt{source}}


\end{adjustwidth}
\hypertarget{742071551420127681}{} 
\hyperlink{742071551420127681}{\texttt{Base.hasfield}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hasfield(T::Type, name::Symbol)
\end{minted}

Return a boolean indicating whether \texttt{T} has \texttt{name} as one of its own fields.

\begin{quote}
\textbf{Julia 1.2}

This function requires at least Julia 1.2.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L179-L186}{\texttt{source}}


\end{adjustwidth}

\hypertarget{822312099330602815}{}


\subsection{Memory layout}


\hypertarget{10394541563305653720}{} 
\hyperlink{10394541563305653720}{\texttt{Base.sizeof}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sizeof(T::DataType)
sizeof(obj)
\end{minted}

Size, in bytes, of the canonical binary representation of the given \texttt{DataType} \texttt{T}, if any. Size, in bytes, of object \texttt{obj} if it is not \texttt{DataType}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sizeof(Float32)
4

julia> sizeof(ComplexF64)
16

julia> sizeof(1.0)
8

julia> sizeof([1.0:10.0;])
80
\end{minted}

If \texttt{DataType} \texttt{T} does not have a specific size, an error is thrown.


\begin{minted}{jlcon}
julia> sizeof(AbstractArray)
ERROR: Abstract type AbstractArray does not have a definite size.
Stacktrace:
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L420-L450}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14038424001821057774}{} 
\hyperlink{14038424001821057774}{\texttt{Base.isconcretetype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isconcretetype(T)
\end{minted}

Determine whether type \texttt{T} is a concrete type, meaning it could have direct instances (values \texttt{x} such that \texttt{typeof(x) === T}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> isconcretetype(Complex)
false

julia> isconcretetype(Complex{Float32})
true

julia> isconcretetype(Vector{Complex})
true

julia> isconcretetype(Vector{Complex{Float32}})
true

julia> isconcretetype(Union{})
false

julia> isconcretetype(Union{Int,String})
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L503-L529}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12980593021531333073}{} 
\hyperlink{12980593021531333073}{\texttt{Base.isbits}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isbits(x)
\end{minted}

Return \texttt{true} if \texttt{x} is an instance of an \texttt{isbitstype} type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L475-L479}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16222127093346839171}{} 
\hyperlink{16222127093346839171}{\texttt{Base.isbitstype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isbitstype(T)
\end{minted}

Return \texttt{true} if type \texttt{T} is a {\textquotedbl}plain data{\textquotedbl} type, meaning it is immutable and contains no references to other values, only \texttt{primitive} types and other \texttt{isbitstype} types. Typical examples are numeric types such as \hyperlink{6609065134969660118}{\texttt{UInt8}}, \hyperlink{5027751419500983000}{\texttt{Float64}}, and \hyperlink{11302502367029942782}{\texttt{Complex\{Float64\}}}. This category of types is significant since they are valid as type parameters, may not track \hyperlink{11212950246505288748}{\texttt{isdefined}} / \hyperlink{976355747478401147}{\texttt{isassigned}} status, and have a defined layout that is compatible with C.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isbitstype(Complex{Float64})
true

julia> isbitstype(Complex)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L452-L472}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17091563430048909487}{} 
\hyperlink{17091563430048909487}{\texttt{Core.fieldtype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fieldtype(T, name::Symbol | index::Int)
\end{minted}

Determine the declared type of a field (specified by name or index) in a composite DataType \texttt{T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> struct Foo
           x::Int64
           y::String
       end

julia> fieldtype(Foo, :x)
Int64

julia> fieldtype(Foo, 2)
String
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L624-L642}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5798312736605167668}{} 
\hyperlink{5798312736605167668}{\texttt{Base.fieldtypes}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fieldtypes(T::Type)
\end{minted}

The declared types of all fields in a composite DataType \texttt{T} as a tuple.

\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> struct Foo
           x::Int64
           y::String
       end

julia> fieldtypes(Foo)
(Int64, String)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L713-L731}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15325030456619527024}{} 
\hyperlink{15325030456619527024}{\texttt{Base.fieldcount}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fieldcount(t::Type)
\end{minted}

Get the number of fields that an instance of the given type would have. An error is thrown if the type is too abstract to determine this.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L673-L678}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6956980533195055227}{} 
\hyperlink{6956980533195055227}{\texttt{Base.fieldoffset}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fieldoffset(type, i)
\end{minted}

The byte offset of field \texttt{i} of a type relative to the data start. For example, we could use it in the following manner to summarize information about a struct:


\begin{minted}{jlcon}
julia> structinfo(T) = [(fieldoffset(T,i), fieldname(T,i), fieldtype(T,i)) for i = 1:fieldcount(T)];

julia> structinfo(Base.Filesystem.StatStruct)
12-element Array{Tuple{UInt64,Symbol,DataType},1}:
 (0x0000000000000000, :device, UInt64)
 (0x0000000000000008, :inode, UInt64)
 (0x0000000000000010, :mode, UInt64)
 (0x0000000000000018, :nlink, Int64)
 (0x0000000000000020, :uid, UInt64)
 (0x0000000000000028, :gid, UInt64)
 (0x0000000000000030, :rdev, UInt64)
 (0x0000000000000038, :size, Int64)
 (0x0000000000000040, :blksize, Int64)
 (0x0000000000000048, :blocks, Int64)
 (0x0000000000000050, :mtime, Float64)
 (0x0000000000000058, :ctime, Float64)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L597-L621}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10538406441051412404}{} 
\hyperlink{10538406441051412404}{\texttt{Base.datatype\_alignment}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.datatype_alignment(dt::DataType) -> Int
\end{minted}

Memory allocation minimum alignment for instances of this type. Can be called on any \texttt{isconcretetype}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L328-L333}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6424780829184450870}{} 
\hyperlink{6424780829184450870}{\texttt{Base.datatype\_haspadding}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.datatype_haspadding(dt::DataType) -> Bool
\end{minted}

Return whether the fields of instances of this type are packed in memory, with no intervening padding bytes. Can be called on any \texttt{isconcretetype}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L361-L367}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15379950191784462663}{} 
\hyperlink{15379950191784462663}{\texttt{Base.datatype\_pointerfree}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.datatype_pointerfree(dt::DataType) -> Bool
\end{minted}

Return whether instances of this type can contain references to gc-managed memory. Can be called on any \texttt{isconcretetype}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L375-L380}{\texttt{source}}


\end{adjustwidth}

\hypertarget{12923909417161931188}{}


\subsection{Special values}


\hypertarget{3613894539247233488}{} 
\hyperlink{3613894539247233488}{\texttt{Base.typemin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
typemin(T)
\end{minted}

The lowest value representable by the given (real) numeric DataType \texttt{T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> typemin(Float16)
-Inf16

julia> typemin(Float32)
-Inf32
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L619-L632}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17760305803764597758}{} 
\hyperlink{17760305803764597758}{\texttt{Base.typemax}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
typemax(T)
\end{minted}

The highest value representable by the given (real) numeric \texttt{DataType}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> typemax(Int8)
127

julia> typemax(UInt32)
0xffffffff
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L635-L648}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3677946765696158382}{} 
\hyperlink{3677946765696158382}{\texttt{Base.floatmin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
floatmin(T)
\end{minted}

The smallest in absolute value non-subnormal value representable by the given floating-point DataType \texttt{T}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L752-L757}{\texttt{source}}


\end{adjustwidth}
\hypertarget{516655729472223591}{} 
\hyperlink{516655729472223591}{\texttt{Base.floatmax}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
floatmax(T)
\end{minted}

The highest finite value representable by the given floating-point DataType \texttt{T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> floatmax(Float16)
Float16(6.55e4)

julia> floatmax(Float32)
3.4028235f38
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L760-L773}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5283633936957536148}{} 
\hyperlink{5283633936957536148}{\texttt{Base.maxintfloat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
maxintfloat(T=Float64)
\end{minted}

The largest consecutive integer-valued floating-point number that is exactly represented in the given floating-point type \texttt{T} (which defaults to \texttt{Float64}).

That is, \texttt{maxintfloat} returns the smallest positive integer-valued floating-point number \texttt{n} such that \texttt{n+1} is \emph{not} exactly representable in the type \texttt{T}.

When an \texttt{Integer}-type value is needed, use \texttt{Integer(maxintfloat(T))}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/floatfuncs.jl#L19-L29}{\texttt{source}}



\begin{lstlisting}
maxintfloat(T, S)
\end{lstlisting}

The largest consecutive integer representable in the given floating-point type \texttt{T} that also does not exceed the maximum integer representable by the integer type \texttt{S}.  Equivalently, it is the minimum of \texttt{maxintfloat(T)} and \hyperlink{17760305803764597758}{\texttt{typemax(S)}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/floatfuncs.jl#L35-L41}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4564486364601788299}{} 
\hyperlink{4564486364601788299}{\texttt{Base.eps}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eps(::Type{T}) where T<:AbstractFloat
eps()
\end{minted}

Return the \emph{machine epsilon} of the floating point type \texttt{T} (\texttt{T = Float64} by default). This is defined as the gap between 1 and the next largest value representable by \texttt{typeof(one(T))}, and is equivalent to \texttt{eps(one(T))}.  (Since \texttt{eps(T)} is a bound on the \emph{relative error} of \texttt{T}, it is a {\textquotedbl}dimensionless{\textquotedbl} quantity like \hyperlink{11395333326208453101}{\texttt{one}}.)

\textbf{Examples}


\begin{minted}{jlcon}
julia> eps()
2.220446049250313e-16

julia> eps(Float32)
1.1920929f-7

julia> 1.0 + eps()
1.0000000000000002

julia> 1.0 + eps()/2
1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L779-L802}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8678379894267468692}{} 
\hyperlink{8678379894267468692}{\texttt{Base.eps}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eps(x::AbstractFloat)
\end{minted}

Return the \emph{unit in last place} (ulp) of \texttt{x}. This is the distance between consecutive representable floating point values at \texttt{x}. In most cases, if the distance on either side of \texttt{x} is different, then the larger of the two is taken, that is


\begin{lstlisting}
eps(x) == max(x-prevfloat(x), nextfloat(x)-x)
\end{lstlisting}

The exceptions to this rule are the smallest and largest finite values (e.g. \texttt{nextfloat(-Inf)} and \texttt{prevfloat(Inf)} for \hyperlink{5027751419500983000}{\texttt{Float64}}), which round to the smaller of the values.

The rationale for this behavior is that \texttt{eps} bounds the floating point rounding error. Under the default \texttt{RoundNearest} rounding mode, if  \(y\)  is a real number and  \(x\)  is the nearest floating point number to  \(y\) , then

\begin{equation*}
\begin{split}|y-x| \leq \operatorname{eps}(x)/2.\end{split}\end{equation*}
\textbf{Examples}


\begin{minted}{jlcon}
julia> eps(1.0)
2.220446049250313e-16

julia> eps(prevfloat(2.0))
2.220446049250313e-16

julia> eps(2.0)
4.440892098500626e-16

julia> x = prevfloat(Inf)      # largest finite Float64
1.7976931348623157e308

julia> x + eps(x)/2            # rounds up
Inf

julia> x + prevfloat(eps(x)/2) # rounds down
1.7976931348623157e308
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L805-L846}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1621796923312060494}{} 
\hyperlink{1621796923312060494}{\texttt{Base.instances}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
instances(T::Type)
\end{minted}

Return a collection of all instances of the given type, if applicable. Mostly used for enumerated types (see \texttt{@enum}).

\textbf{Example}


\begin{minted}{jlcon}
julia> @enum Color red blue green

julia> instances(Color)
(red, blue, green)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L736-L749}{\texttt{source}}


\end{adjustwidth}

\hypertarget{16613146440678600421}{}


\section{Special Types}


\hypertarget{15014186392807667022}{} 
\hyperlink{15014186392807667022}{\texttt{Core.Any}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Any::DataType
\end{minted}

\texttt{Any} is the union of all types. It has the defining property \texttt{isa(x, Any) == true} for any \texttt{x}. \texttt{Any} therefore describes the entire universe of possible values. For example \texttt{Integer} is a subset of \texttt{Any} that includes \texttt{Int}, \texttt{Int8}, and other integer types.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2077-L2083}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5087820771052303592}{} 
\hyperlink{5087820771052303592}{\texttt{Core.Union}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Union{Types...}
\end{minted}

A type union is an abstract type which includes all instances of any of its argument types. The empty union \hyperlink{17871676717506458499}{\texttt{Union\{\}}} is the bottom type of Julia.

\textbf{Examples}


\begin{minted}{jlcon}
julia> IntOrString = Union{Int,AbstractString}
Union{Int64, AbstractString}

julia> 1 :: IntOrString
1

julia> "Hello!" :: IntOrString
"Hello!"

julia> 1.0 :: IntOrString
ERROR: TypeError: in typeassert, expected Union{Int64, AbstractString}, got Float64
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2101-L2121}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17871676717506458499}{} 
\hyperlink{17871676717506458499}{\texttt{Union\{\}}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Union{}
\end{minted}

\texttt{Union\{\}}, the empty \hyperlink{5087820771052303592}{\texttt{Union}} of types, is the type that has no values. That is, it has the defining property \texttt{isa(x, Union\{\}) == false} for any \texttt{x}. \texttt{Base.Bottom} is defined as its alias and the type of \texttt{Union\{\}} is \texttt{Core.TypeofBottom}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isa(nothing, Union{})
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2086-L2098}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13291956087044414878}{} 
\hyperlink{13291956087044414878}{\texttt{Core.UnionAll}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UnionAll
\end{minted}

A union of types over all values of a type parameter. \texttt{UnionAll} is used to describe parametric types where the values of some parameters are not known.

\textbf{Examples}


\begin{minted}{jlcon}
julia> typeof(Vector)
UnionAll

julia> typeof(Vector{Int})
DataType
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2125-L2139}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17462354060312563026}{} 
\hyperlink{17462354060312563026}{\texttt{Core.Tuple}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Tuple{Types...}
\end{minted}

Tuples are an abstraction of the arguments of a function – without the function itself. The salient aspects of a function{\textquotesingle}s arguments are their order and their types. Therefore a tuple type is similar to a parameterized immutable type where each parameter is the type of one field. Tuple types may have any number of parameters.

Tuple types are covariant in their parameters: \texttt{Tuple\{Int\}} is a subtype of \texttt{Tuple\{Any\}}. Therefore \texttt{Tuple\{Any\}} is considered an abstract type, and tuple types are only concrete if their parameters are. Tuples do not have field names; fields are only accessed by index.

See the manual section on \href{@ref}{Tuple Types}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2189-L2201}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3845731488275720657}{} 
\hyperlink{3845731488275720657}{\texttt{Core.NamedTuple}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
NamedTuple
\end{minted}

\texttt{NamedTuple}s are, as their name suggests, named \hyperlink{17462354060312563026}{\texttt{Tuple}}s. That is, they{\textquotesingle}re a tuple-like collection of values, where each entry has a unique name, represented as a \hyperlink{18332791376992528422}{\texttt{Symbol}}. Like \texttt{Tuple}s, \texttt{NamedTuple}s are immutable; neither the names nor the values can be modified in place after construction.

Accessing the value associated with a name in a named tuple can be done using field access syntax, e.g. \texttt{x.a}, or using \hyperlink{13720608614876840481}{\texttt{getindex}}, e.g. \texttt{x[:a]}. A tuple of the names can be obtained using \hyperlink{6023948435845840069}{\texttt{keys}}, and a tuple of the values can be obtained using \hyperlink{14429101350359443046}{\texttt{values}}.

\begin{quote}
\textbf{Note}

Iteration over \texttt{NamedTuple}s produces the \emph{values} without the names. (See example below.) To iterate over the name-value pairs, use the \hyperlink{15543779110977484852}{\texttt{pairs}} function.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> x = (a=1, b=2)
(a = 1, b = 2)

julia> x.a
1

julia> x[:a]
1

julia> keys(x)
(:a, :b)

julia> values(x)
(1, 2)

julia> collect(x)
2-element Array{Int64,1}:
 1
 2

julia> collect(pairs(x))
2-element Array{Pair{Symbol,Int64},1}:
 :a => 1
 :b => 2
\end{minted}

In a similar fashion as to how one can define keyword arguments programmatically, a named tuple can be created by giving a pair \texttt{name::Symbol => value} or splatting an iterator yielding such pairs after a semicolon inside a tuple literal:


\begin{minted}{jlcon}
julia> (; :a => 1)
(a = 1,)

julia> keys = (:a, :b, :c); values = (1, 2, 3);

julia> (; zip(keys, values)...)
(a = 1, b = 2, c = 3)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/namedtuple.jl#L3-L61}{\texttt{source}}


\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Base.@NamedTuple}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{1312938105781775871}{} 
\hyperlink{1312938105781775871}{\texttt{Base.Val}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Val(c)
\end{minted}

Return \texttt{Val\{c\}()}, which contains no run-time data. Types like this can be used to pass the information between functions through the value \texttt{c}, which must be an \texttt{isbits} value. The intent of this construct is to be able to dispatch on constants directly (at compile time) without having to test the value of the constant at run time.

\textbf{Examples}


\begin{minted}{jlcon}
julia> f(::Val{true}) = "Good"
f (generic function with 1 method)

julia> f(::Val{false}) = "Bad"
f (generic function with 2 methods)

julia> f(Val(true))
"Good"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L675-L694}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5941806424098279588}{} 
\hyperlink{5941806424098279588}{\texttt{Core.Vararg}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Vararg{T,N}
\end{minted}

The last parameter of a tuple type \hyperlink{17462354060312563026}{\texttt{Tuple}} can be the special type \texttt{Vararg}, which denotes any number of trailing elements. The type \texttt{Vararg\{T,N\}} corresponds to exactly \texttt{N} elements of type \texttt{T}. \texttt{Vararg\{T\}} corresponds to zero or more elements of type \texttt{T}. \texttt{Vararg} tuple types are used to represent the arguments accepted by varargs methods (see the section on \href{@ref}{Varargs Functions} in the manual.)

\textbf{Examples}


\begin{minted}{jlcon}
julia> mytupletype = Tuple{AbstractString,Vararg{Int}}
Tuple{AbstractString,Vararg{Int64,N} where N}

julia> isa(("1",), mytupletype)
true

julia> isa(("1",1), mytupletype)
true

julia> isa(("1",1,2), mytupletype)
true

julia> isa(("1",1,2,3.0), mytupletype)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2161-L2186}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13508459519898889544}{} 
\hyperlink{13508459519898889544}{\texttt{Core.Nothing}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Nothing
\end{minted}

A type with no fields that is the type of \hyperlink{9331422207248206047}{\texttt{nothing}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1050-L1054}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15485094872489766212}{} 
\hyperlink{15485094872489766212}{\texttt{Base.isnothing}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isnothing(x)
\end{minted}

Return \texttt{true} if \texttt{x === nothing}, and return \texttt{false} if not.

\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/some.jl#L56-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12733330042100122220}{} 
\hyperlink{12733330042100122220}{\texttt{Base.Some}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Some{T}
\end{minted}

A wrapper type used in \texttt{Union\{Some\{T\}, Nothing\}} to distinguish between the absence of a value (\hyperlink{9331422207248206047}{\texttt{nothing}}) and the presence of a \texttt{nothing} value (i.e. \texttt{Some(nothing)}).

Use \hyperlink{12366229165852827603}{\texttt{something}} to access the value wrapped by a \texttt{Some} object.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/some.jl#L3-L10}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12366229165852827603}{} 
\hyperlink{12366229165852827603}{\texttt{Base.something}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
something(x, y...)
\end{minted}

Return the first value in the arguments which is not equal to \hyperlink{9331422207248206047}{\texttt{nothing}}, if any. Otherwise throw an error. Arguments of type \hyperlink{12733330042100122220}{\texttt{Some}} are unwrapped.

See also \hyperlink{13286612216921584050}{\texttt{coalesce}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> something(nothing, 1)
1

julia> something(Some(1), nothing)
1

julia> something(missing, nothing)
missing

julia> something(nothing, nothing)
ERROR: ArgumentError: No value arguments present
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/some.jl#L68-L91}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12477318268908279491}{} 
\hyperlink{12477318268908279491}{\texttt{Base.Enums.Enum}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Enum{T<:Integer}
\end{minted}

The abstract supertype of all enumerated types defined with \hyperlink{18177775477210803027}{\texttt{@enum}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/Enums.jl#L10-L14}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18177775477210803027}{} 
\hyperlink{18177775477210803027}{\texttt{Base.Enums.@enum}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@enum EnumName[::BaseType] value1[=x] value2[=y]
\end{minted}

Create an \texttt{Enum\{BaseType\}} subtype with name \texttt{EnumName} and enum member values of \texttt{value1} and \texttt{value2} with optional assigned values of \texttt{x} and \texttt{y}, respectively. \texttt{EnumName} can be used just like other types and enum member values as regular values, such as

\textbf{Examples}


\begin{minted}{jlcon}
julia> @enum Fruit apple=1 orange=2 kiwi=3

julia> f(x::Fruit) = "I'm a Fruit with value: $(Int(x))"
f (generic function with 1 method)

julia> f(apple)
"I'm a Fruit with value: 1"

julia> Fruit(1)
apple::Fruit = 1
\end{minted}

Values can also be specified inside a \texttt{begin} block, e.g.


\begin{minted}{julia}
@enum EnumName begin
    value1
    value2
end
\end{minted}

\texttt{BaseType}, which defaults to \hyperlink{10103694114785108551}{\texttt{Int32}}, must be a primitive subtype of \texttt{Integer}. Member values can be converted between the enum type and \texttt{BaseType}. \texttt{read} and \texttt{write} perform these conversions automatically.

To list all the instances of an enum use \texttt{instances}, e.g.


\begin{minted}{jlcon}
julia> instances(Fruit)
(apple, orange, kiwi)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/Enums.jl#L77-L117}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17120496304147995299}{} 
\hyperlink{17120496304147995299}{\texttt{Core.Expr}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Expr(head::Symbol, args...)
\end{minted}

A type representing compound expressions in parsed julia code (ASTs). Each expression consists of a \texttt{head} \texttt{Symbol} identifying which kind of expression it is (e.g. a call, for loop, conditional statement, etc.), and subexpressions (e.g. the arguments of a call). The subexpressions are stored in a \texttt{Vector\{Any\}} field called \texttt{args}.

See the manual chapter on \href{@ref}{Metaprogramming} and the developer documentation \href{@ref}{Julia ASTs}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Expr(:call, :+, 1, 2)
:(1 + 2)

julia> dump(:(a ? b : c))
Expr
  head: Symbol if
  args: Array{Any}((3,))
    1: Symbol a
    2: Symbol b
    3: Symbol c
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L402-L427}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18332791376992528422}{} 
\hyperlink{18332791376992528422}{\texttt{Core.Symbol}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Symbol
\end{minted}

The type of object used to represent identifiers in parsed julia code (ASTs). Also often used as a name or label to identify an entity (e.g. as a dictionary key). \texttt{Symbol}s can be entered using the \texttt{:} quote operator:


\begin{minted}{jlcon}
julia> :name
:name

julia> typeof(:name)
Symbol

julia> x = 42
42

julia> eval(:x)
42
\end{minted}

\texttt{Symbol}s can also be constructed from strings or other values by calling the constructor \texttt{Symbol(x...)}.

\texttt{Symbol}s are immutable and should be compared using \texttt{===}. The implementation re-uses the same object for all \texttt{Symbol}s with the same name, so comparison tends to be efficient (it can just compare pointers).

Unlike strings, \texttt{Symbol}s are {\textquotedbl}atomic{\textquotedbl} or {\textquotedbl}scalar{\textquotedbl} entities that do not support iteration over characters.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1554-L1582}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8149537083915085913}{} 
\hyperlink{8149537083915085913}{\texttt{Core.Symbol}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Symbol(x...) -> Symbol
\end{minted}

Create a \hyperlink{18332791376992528422}{\texttt{Symbol}} by concatenating the string representations of the arguments together.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Symbol("my", "name")
:myname

julia> Symbol("day", 4)
:day4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1585-L1598}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6070072550914765640}{} 
\hyperlink{6070072550914765640}{\texttt{Core.Module}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Module
\end{minted}

A \texttt{Module} is a separate global variable workspace. See \hyperlink{16285380181904025577}{\texttt{module}} and the \hyperlink{16725527896995457152}{manual section about modules} for details.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2321-L2325}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14863412530278606383}{}


\section{Generic Functions}


\hypertarget{2744637612596423318}{} 
\hyperlink{2744637612596423318}{\texttt{Core.Function}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Function
\end{minted}

Abstract type of all functions.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isa(+, Function)
true

julia> typeof(sin)
typeof(sin)

julia> ans <: Function
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1072-L1088}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6562783328134837372}{} 
\hyperlink{6562783328134837372}{\texttt{Base.hasmethod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hasmethod(f, t::Type{<:Tuple}[, kwnames]; world=typemax(UInt)) -> Bool
\end{minted}

Determine whether the given generic function has a method matching the given \texttt{Tuple} of argument types with the upper bound of world age given by \texttt{world}.

If a tuple of keyword argument names \texttt{kwnames} is provided, this also checks whether the method of \texttt{f} matching \texttt{t} has the given keyword argument names. If the matching method accepts a variable number of keyword arguments, e.g. with \texttt{kwargs...}, any names given in \texttt{kwnames} are considered valid. Otherwise the provided names must be a subset of the method{\textquotesingle}s keyword arguments.

See also \hyperlink{366019948759111192}{\texttt{applicable}}.

\begin{quote}
\textbf{Julia 1.2}

Providing keyword argument names requires Julia 1.2 or later.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> hasmethod(length, Tuple{Array})
true

julia> hasmethod(sum, Tuple{Function, Array}, (:dims,))
true

julia> hasmethod(sum, Tuple{Function, Array}, (:apples, :bananas))
false

julia> g(; xs...) = 4;

julia> hasmethod(g, Tuple{}, (:a, :b, :c, :d))  # g accepts arbitrary kwargs
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L1210-L1243}{\texttt{source}}


\end{adjustwidth}
\hypertarget{366019948759111192}{} 
\hyperlink{366019948759111192}{\texttt{Core.applicable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
applicable(f, args...) -> Bool
\end{minted}

Determine whether the given generic function has a method applicable to the given arguments.

See also \hyperlink{6562783328134837372}{\texttt{hasmethod}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> function f(x, y)
           x + y
       end;

julia> applicable(f, 1)
false

julia> applicable(f, 1, 2)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1370-L1389}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14356043600121087376}{} 
\hyperlink{14356043600121087376}{\texttt{Core.invoke}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
invoke(f, argtypes::Type, args...; kwargs...)
\end{minted}

Invoke a method for the given generic function \texttt{f} matching the specified types \texttt{argtypes} on the specified arguments \texttt{args} and passing the keyword arguments \texttt{kwargs}. The arguments \texttt{args} must conform with the specified types in \texttt{argtypes}, i.e. conversion is not automatically performed. This method allows invoking a method other than the most specific matching method, which is useful when the behavior of a more general definition is explicitly needed (often as part of the implementation of a more specific method of the same function).

\textbf{Examples}


\begin{minted}{jlcon}
julia> f(x::Real) = x^2;

julia> f(x::Integer) = 1 + invoke(f, Tuple{Real}, x);

julia> f(2)
5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1392-L1411}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15240876280767285272}{} 
\hyperlink{15240876280767285272}{\texttt{Base.invokelatest}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
invokelatest(f, args...; kwargs...)
\end{minted}

Calls \texttt{f(args...; kwargs...)}, but guarantees that the most recent method of \texttt{f} will be executed.   This is useful in specialized circumstances, e.g. long-running event loops or callback functions that may call obsolete versions of a function \texttt{f}. (The drawback is that \texttt{invokelatest} is somewhat slower than calling \texttt{f} directly, and the type of the result cannot be inferred by the compiler.)



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L700-L709}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13888762393600028594}{} 
\hyperlink{13888762393600028594}{\texttt{new}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
new
\end{minted}

Special function available to inner constructors which created a new object of the type. See the manual section on \hyperlink{5052047505447273614}{Inner Constructor Methods} for more information.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L960-L967}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5135459825603202944}{} 
\hyperlink{5135459825603202944}{\texttt{Base.:|>}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
|>(x, f)
\end{minted}

Applies a function to the preceding argument. This allows for easy function chaining.

\textbf{Examples}


\begin{minted}{jlcon}
julia> [1:5;] |> x->x.^2 |> sum |> inv
0.01818181818181818
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L812-L822}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8400062617555407555}{} 
\hyperlink{8400062617555407555}{\texttt{Base.:∘}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
f ∘ g
\end{minted}

Compose functions: i.e. \texttt{(f ∘ g)(args...)} means \texttt{f(g(args...))}. The \texttt{∘} symbol can be entered in the Julia REPL (and most editors, appropriately configured) by typing \texttt{{\textbackslash}circ<tab>}.

Function composition also works in prefix form: \texttt{∘(f, g)} is the same as \texttt{f ∘ g}. The prefix form supports composition of multiple functions: \texttt{∘(f, g, h) = f ∘ g ∘ h} and splatting \texttt{∘(fs...)} for composing an iterable collection of functions.

\begin{quote}
\textbf{Julia 1.4}

Multiple function composition requires at least Julia 1.4.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> map(uppercase∘first, ["apple", "banana", "carrot"])
3-element Array{Char,1}:
 'A'
 'B'
 'C'

julia> fs = [
           x -> 2x
           x -> x/2
           x -> x-1
           x -> x+1
       ];

julia> ∘(fs...)(3)
3.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L827-L858}{\texttt{source}}


\end{adjustwidth}

\hypertarget{15383903001647696562}{}


\section{Syntax}


\hypertarget{2345597220715550879}{} 
\hyperlink{2345597220715550879}{\texttt{Core.eval}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Core.eval(m::Module, expr)
\end{minted}

Evaluate an expression in the given module and return the result.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/expr.jl#L168-L172}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7507639810592563424}{} 
\hyperlink{7507639810592563424}{\texttt{Base.MainInclude.eval}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eval(expr)
\end{minted}

Evaluate an expression in the global scope of the containing module. Every \texttt{Module} (except those defined with \texttt{baremodule}) has its own 1-argument definition of \texttt{eval}, which evaluates expressions in that module.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/client.jl#L452-L458}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12895501458291832858}{} 
\hyperlink{12895501458291832858}{\texttt{Base.@eval}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@eval [mod,] ex
\end{minted}

Evaluate an expression with values interpolated into it using \texttt{eval}. If two arguments are provided, the first is the module to evaluate in.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L176-L181}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1049904639707765509}{} 
\hyperlink{1049904639707765509}{\texttt{Base.evalfile}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
evalfile(path::AbstractString, args::Vector{String}=String[])
\end{minted}

Load the file using \hyperlink{438355891087818425}{\texttt{include}}, evaluate all expressions, and return the value of the last one.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/loading.jl#L1113-L1118}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17861659594346526773}{} 
\hyperlink{17861659594346526773}{\texttt{Base.esc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
esc(e)
\end{minted}

Only valid in the context of an \hyperlink{17120496304147995299}{\texttt{Expr}} returned from a macro. Prevents the macro hygiene pass from turning embedded variables into gensym variables. See the \hyperlink{5127151953463206825}{Macros} section of the Metaprogramming chapter of the manual for more details and examples.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L469-L475}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9619263577270933060}{} 
\hyperlink{9619263577270933060}{\texttt{Base.@inbounds}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@inbounds(blk)
\end{minted}

Eliminates array bounds checking within expressions.

In the example below the in-range check for referencing element \texttt{i} of array \texttt{A} is skipped to improve performance.


\begin{minted}{julia}
function sum(A::AbstractArray)
    r = zero(eltype(A))
    for i = 1:length(A)
        @inbounds r += A[i]
    end
    return r
end
\end{minted}

\begin{quote}
\textbf{Warning}

Using \texttt{@inbounds} may return incorrect results/crashes/corruption for out-of-bounds indices. The user is responsible for checking it manually. Only use \texttt{@inbounds} when it is certain from the information locally available that all accesses are in bounds.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L526-L550}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5163897958650268335}{} 
\hyperlink{5163897958650268335}{\texttt{Base.@boundscheck}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@boundscheck(blk)
\end{minted}

Annotates the expression \texttt{blk} as a bounds checking block, allowing it to be elided by \hyperlink{9619263577270933060}{\texttt{@inbounds}}.

\begin{quote}
\textbf{Note}

The function in which \texttt{@boundscheck} is written must be inlined into its caller in order for \texttt{@inbounds} to have effect.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> @inline function g(A, i)
           @boundscheck checkbounds(A, i)
           return "accessing ($A)[$i]"
       end;

julia> f1() = return g(1:2, -1);

julia> f2() = @inbounds return g(1:2, -1);

julia> f1()
ERROR: BoundsError: attempt to access 2-element UnitRange{Int64} at index [-1]
Stacktrace:
 [1] throw_boundserror(::UnitRange{Int64}, ::Tuple{Int64}) at ./abstractarray.jl:455
 [2] checkbounds at ./abstractarray.jl:420 [inlined]
 [3] g at ./none:2 [inlined]
 [4] f1() at ./none:1
 [5] top-level scope

julia> f2()
"accessing (1:2)[-1]"
\end{minted}

\begin{quote}
\textbf{Warning}

The \texttt{@boundscheck} annotation allows you, as a library writer, to opt-in to allowing \emph{other code} to remove your bounds checks with \hyperlink{9619263577270933060}{\texttt{@inbounds}}. As noted there, the caller must verify—using information they can access—that their accesses are valid before using \texttt{@inbounds}. For indexing into your \hyperlink{6514416309183787338}{\texttt{AbstractArray}} subclasses, for example, this involves checking the indices against its \hyperlink{17888996102305087038}{\texttt{size}}. Therefore, \texttt{@boundscheck} annotations should only be added to a \hyperlink{13720608614876840481}{\texttt{getindex}} or \hyperlink{1309244355901386657}{\texttt{setindex!}} implementation after you are certain its behavior is correct.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L478-L521}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4942611866585954207}{} 
\hyperlink{4942611866585954207}{\texttt{Base.@propagate\_inbounds}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@propagate_inbounds
\end{minted}

Tells the compiler to inline a function while retaining the caller{\textquotesingle}s inbounds context.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/expr.jl#L239-L243}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18060766522149343036}{} 
\hyperlink{18060766522149343036}{\texttt{Base.@inline}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@inline
\end{minted}

Give a hint to the compiler that this function is worth inlining.

Small functions typically do not need the \texttt{@inline} annotation, as the compiler does it automatically. By using \texttt{@inline} on bigger functions, an extra nudge can be given to the compiler to inline it. This is shown in the following example:


\begin{minted}{julia}
@inline function bigfunction(x)
    #=
        Function Definition
    =#
end
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/expr.jl#L175-L192}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13090632948127397341}{} 
\hyperlink{13090632948127397341}{\texttt{Base.@noinline}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@noinline
\end{minted}

Give a hint to the compiler that it should not inline a function.

Small functions are typically inlined automatically. By using \texttt{@noinline} on small functions, auto-inlining can be prevented. This is shown in the following example:


\begin{minted}{julia}
@noinline function smallfunction(x)
    #=
        Function Definition
    =#
end

If the function is trivial (for example returning a constant) it might get inlined anyway.
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/expr.jl#L197-L215}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5574860636759822935}{} 
\hyperlink{5574860636759822935}{\texttt{Base.@nospecialize}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@nospecialize
\end{minted}

Applied to a function argument name, hints to the compiler that the method should not be specialized for different types of that argument, but instead to use precisely the declared type for each argument. This is only a hint for avoiding excess code generation. Can be applied to an argument within a formal argument list, or in the function body. When applied to an argument, the macro must wrap the entire argument expression. When used in a function body, the macro must occur in statement position and before any code.

When used without arguments, it applies to all arguments of the parent scope. In local scope, this means all arguments of the containing function. In global (top-level) scope, this means all methods subsequently defined in the current module.

Specialization can reset back to the default by using \hyperlink{1495861121913085321}{\texttt{@specialize}}.


\begin{minted}{julia}
function example_function(@nospecialize x)
    ...
end

function example_function(@nospecialize(x = 1), y)
    ...
end

function example_function(x, y, z)
    @nospecialize x y
    ...
end

@nospecialize
f(y) = [x for x in y]
@specialize
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L43-L80}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1495861121913085321}{} 
\hyperlink{1495861121913085321}{\texttt{Base.@specialize}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@specialize
\end{minted}

Reset the specialization hint for an argument back to the default. For details, see \hyperlink{5574860636759822935}{\texttt{@nospecialize}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L92-L97}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3515345868651201289}{} 
\hyperlink{3515345868651201289}{\texttt{Base.gensym}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gensym([tag])
\end{minted}

Generates a symbol which will not conflict with other variable names.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/expr.jl#L5-L9}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1574260997115674041}{} 
\hyperlink{1574260997115674041}{\texttt{Base.@gensym}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@gensym
\end{minted}

Generates a gensym symbol for a variable. For example, \texttt{@gensym x y} is transformed into \texttt{x = gensym({\textquotedbl}x{\textquotedbl}); y = gensym({\textquotedbl}y{\textquotedbl})}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/expr.jl#L18-L23}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17011668714147183228}{} 
\hyperlink{17011668714147183228}{\texttt{var{\textquotedbl}name{\textquotedbl}}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
var
\end{minted}

The syntax \texttt{var{\textquotedbl}\#example\#{\textquotedbl}} refers to a variable named \texttt{Symbol({\textquotedbl}\#example\#{\textquotedbl})}, even though \texttt{\#example\#} is not a valid Julia identifier name.

This can be useful for interoperability with programming languages which have different rules for the construction of valid identifiers. For example, to refer to the \texttt{R} variable \texttt{draw.segments}, you can use \texttt{var{\textquotedbl}draw.segments{\textquotedbl}} in your Julia code.

It is also used to \texttt{show} julia source code which has gone through macro hygiene or otherwise contains variable names which can{\textquotesingle}t be parsed normally.

Note that this syntax requires parser support so it is expanded directly by the parser rather than being implemented as a normal string macro \texttt{@var\_str}.

\begin{quote}
\textbf{Julia 1.3}

This syntax requires at least Julia 1.3.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1006-L1026}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6008882266630078507}{} 
\hyperlink{6008882266630078507}{\texttt{Base.@goto}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@goto name
\end{minted}

\texttt{@goto name} unconditionally jumps to the statement at the location \hyperlink{11932619098205117246}{\texttt{@label name}}.

\texttt{@label} and \texttt{@goto} cannot create jumps to different top-level statements. Attempts cause an error. To still use \texttt{@goto}, enclose the \texttt{@label} and \texttt{@goto} in a block.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L569-L576}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11932619098205117246}{} 
\hyperlink{11932619098205117246}{\texttt{Base.@label}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@label name
\end{minted}

Labels a statement with the symbolic label \texttt{name}. The label marks the end-point of an unconditional jump with \hyperlink{6008882266630078507}{\texttt{@goto name}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L559-L564}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8155428559748374852}{} 
\hyperlink{8155428559748374852}{\texttt{Base.SimdLoop.@simd}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@simd
\end{minted}

Annotate a \texttt{for} loop to allow the compiler to take extra liberties to allow loop re-ordering

\begin{quote}
\textbf{Warning}

This feature is experimental and could change or disappear in future versions of Julia. Incorrect use of the \texttt{@simd} macro may cause unexpected results.

\end{quote}
The object iterated over in a \texttt{@simd for} loop should be a one-dimensional range. By using \texttt{@simd}, you are asserting several properties of the loop:

\begin{itemize}
\item It is safe to execute iterations in arbitrary or overlapping order, with special consideration for reduction variables.


\item Floating-point operations on reduction variables can be reordered, possibly causing different results than without \texttt{@simd}.

\end{itemize}
In many cases, Julia is able to automatically vectorize inner for loops without the use of \texttt{@simd}. Using \texttt{@simd} gives the compiler a little extra leeway to make it possible in more situations. In either case, your inner loop should have the following properties to allow vectorization:

\begin{itemize}
\item The loop must be an innermost loop


\item The loop body must be straight-line code. Therefore, \hyperlink{9619263577270933060}{\texttt{@inbounds}} is   currently needed for all array accesses. The compiler can sometimes turn   short \texttt{\&\&}, \texttt{||}, and \texttt{?:} expressions into straight-line code if it is safe   to evaluate all operands unconditionally. Consider using the \hyperlink{12785896617485598962}{\texttt{ifelse}}   function instead of \texttt{?:} in the loop if it is safe to do so.


\item Accesses must have a stride pattern and cannot be {\textquotedbl}gathers{\textquotedbl} (random-index   reads) or {\textquotedbl}scatters{\textquotedbl} (random-index writes).


\item The stride should be unit stride.

\end{itemize}
\begin{quote}
\textbf{Note}

The \texttt{@simd} does not assert by default that the loop is completely free of loop-carried memory dependencies, which is an assumption that can easily be violated in generic code. If you are writing non-generic code, you can use \texttt{@simd ivdep for ... end} to also assert that:

\end{quote}
\begin{itemize}
\item There exists no loop-carried memory dependencies


\item No iteration ever waits on a previous iteration to make forward progress.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/simdloop.jl#L90-L126}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17097218075487180587}{} 
\hyperlink{17097218075487180587}{\texttt{Base.@polly}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@polly
\end{minted}

Tells the compiler to apply the polyhedral optimizer Polly to a function.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/expr.jl#L252-L256}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11479538870805927749}{} 
\hyperlink{11479538870805927749}{\texttt{Base.@generated}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@generated f
@generated(f)
\end{minted}

\texttt{@generated} is used to annotate a function which will be generated. In the body of the generated function, only types of arguments can be read (not the values). The function returns a quoted expression evaluated when the function is called. The \texttt{@generated} macro should not be used on functions mutating the global scope or depending on mutable elements.

See \href{@ref}{Metaprogramming} for further details.

\textbf{Example:}


\begin{minted}{julia}
julia> @generated function bar(x)
           if x <: Integer
               return :(x ^ 2)
           else
               return :(x)
           end
       end
bar (generic function with 1 method)

julia> bar(4)
16

julia> bar("baz")
"baz"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/expr.jl#L386-L414}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14594515112262961362}{} 
\hyperlink{14594515112262961362}{\texttt{Base.@pure}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@pure ex
@pure(ex)
\end{minted}

\texttt{@pure} gives the compiler a hint for the definition of a pure function, helping for type inference.

A pure function can only depend on immutable information. This also means a \texttt{@pure} function cannot use any global mutable state, including generic functions. Calls to generic functions depend on method tables which are mutable global state. Use with caution, incorrect \texttt{@pure} annotation of a function may introduce hard to identify bugs. Double check for calls to generic functions. This macro is intended for internal compiler use and may be subject to changes.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/expr.jl#L220-L234}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10566386387238732905}{} 
\hyperlink{10566386387238732905}{\texttt{Base.@deprecate}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@deprecate old new [ex=true]
\end{minted}

The first argument \texttt{old} is the signature of the deprecated method, the second one \texttt{new} is the call which replaces it. \texttt{@deprecate} exports \texttt{old} unless the optional third argument is \texttt{false}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> @deprecate old(x) new(x)
old (generic function with 1 method)

julia> @deprecate old(x) new(x) false
old (generic function with 1 method)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/deprecated.jl#L17-L32}{\texttt{source}}


\end{adjustwidth}

\hypertarget{15425524910108036471}{}


\section{Missing Values}


\hypertarget{9306488559141158579}{} 
\hyperlink{9306488559141158579}{\texttt{Base.Missing}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Missing
\end{minted}

A type with no fields whose singleton instance \hyperlink{14596725676261444434}{\texttt{missing}} is used to represent missing values.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L766-L771}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14596725676261444434}{} 
\hyperlink{14596725676261444434}{\texttt{Base.missing}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
missing
\end{minted}

The singleton instance of type \hyperlink{9306488559141158579}{\texttt{Missing}} representing a missing value.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L774-L778}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13286612216921584050}{} 
\hyperlink{13286612216921584050}{\texttt{Base.coalesce}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
coalesce(x, y...)
\end{minted}

Return the first value in the arguments which is not equal to \hyperlink{14596725676261444434}{\texttt{missing}}, if any. Otherwise return \texttt{missing}.

See also \hyperlink{12366229165852827603}{\texttt{something}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> coalesce(missing, 1)
1

julia> coalesce(1, missing)
1

julia> coalesce(nothing, 1)  # returns `nothing`

julia> coalesce(missing, missing)
missing
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/missing.jl#L384-L406}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3452327148507948899}{} 
\hyperlink{3452327148507948899}{\texttt{Base.ismissing}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ismissing(x)
\end{minted}

Indicate whether \texttt{x} is \hyperlink{14596725676261444434}{\texttt{missing}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L781-L785}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2012470681884771400}{} 
\hyperlink{2012470681884771400}{\texttt{Base.skipmissing}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
skipmissing(itr)
\end{minted}

Return an iterator over the elements in \texttt{itr} skipping \hyperlink{14596725676261444434}{\texttt{missing}} values. The returned object can be indexed using indices of \texttt{itr} if the latter is indexable. Indices corresponding to missing values are not valid: they are skipped by \hyperlink{6023948435845840069}{\texttt{keys}} and \hyperlink{4701773772897287974}{\texttt{eachindex}}, and a \texttt{MissingException} is thrown when trying to use them.

Use \hyperlink{6278865767444641812}{\texttt{collect}} to obtain an \texttt{Array} containing the non-\texttt{missing} values in \texttt{itr}. Note that even if \texttt{itr} is a multidimensional array, the result will always be a \texttt{Vector} since it is not possible to remove missings while preserving dimensions of the input.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = skipmissing([1, missing, 2])
Base.SkipMissing{Array{Union{Missing, Int64},1}}(Union{Missing, Int64}[1, missing, 2])

julia> sum(x)
3

julia> x[1]
1

julia> x[2]
ERROR: MissingException: the value at index (2,) is missing
[...]

julia> argmax(x)
3

julia> collect(keys(x))
2-element Array{Int64,1}:
 1
 3

julia> collect(skipmissing([1, missing, 2]))
2-element Array{Int64,1}:
 1
 2

julia> collect(skipmissing([1 missing; 2 missing]))
2-element Array{Int64,1}:
 1
 2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/missing.jl#L183-L229}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1854627539013140402}{} 
\hyperlink{1854627539013140402}{\texttt{Base.nonmissingtype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nonmissingtype(T::Type)
\end{minted}

If \texttt{T} is a union of types containing \texttt{Missing}, return a new type with \texttt{Missing} removed.

\textbf{Examples}


\begin{minted}{jlcon}
julia> nonmissingtype(Union{Int64,Missing})
Int64

julia> nonmissingtype(Any)
Any
\end{minted}

\begin{quote}
\textbf{Julia 1.3}

\end{quote}
This function is exported as of Julia 1.3.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/missing.jl#L21-L38}{\texttt{source}}


\end{adjustwidth}

\hypertarget{16829646620249903859}{}


\section{System}


\hypertarget{18309243184998755104}{} 
\hyperlink{18309243184998755104}{\texttt{Base.run}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
run(command, args...; wait::Bool = true)
\end{minted}

Run a command object, constructed with backticks (see the \href{@ref}{Running External Programs} section in the manual). Throws an error if anything goes wrong, including the process exiting with a non-zero status (when \texttt{wait} is true).

If \texttt{wait} is false, the process runs asynchronously. You can later wait for it and check its exit status by calling \texttt{success} on the returned process object.

When \texttt{wait} is false, the process{\textquotesingle} I/O streams are directed to \texttt{devnull}. When \texttt{wait} is true, I/O streams are shared with the parent process. Use \hyperlink{17710887576380723118}{\texttt{pipeline}} to control I/O redirection.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/process.jl#L423-L436}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13412111234074215621}{} 
\hyperlink{13412111234074215621}{\texttt{Base.devnull}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
devnull
\end{minted}

Used in a stream redirect to discard all data written to it. Essentially equivalent to \texttt{/dev/null} on Unix or \texttt{NUL} on Windows. Usage:


\begin{minted}{julia}
run(pipeline(`cat test.txt`, devnull))
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1036-L1045}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3068527349757478883}{} 
\hyperlink{3068527349757478883}{\texttt{Base.success}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
success(command)
\end{minted}

Run a command object, constructed with backticks (see the \href{@ref}{Running External Programs} section in the manual), and tell whether it was successful (exited with a code of 0). An exception is raised if the process cannot be started.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/process.jl#L489-L495}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15578977278493337913}{} 
\hyperlink{15578977278493337913}{\texttt{Base.process\_running}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
process_running(p::Process)
\end{minted}

Determine whether a process is currently running.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/process.jl#L587-L591}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13017420786720044448}{} 
\hyperlink{13017420786720044448}{\texttt{Base.process\_exited}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
process_exited(p::Process)
\end{minted}

Determine whether a process has exited.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/process.jl#L596-L600}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1615401929219773934}{} 
\hyperlink{1615401929219773934}{\texttt{Base.kill}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
kill(p::Process, signum=Base.SIGTERM)
\end{minted}

Send a signal to a process. The default is to terminate the process. Returns successfully if the process has already exited, but throws an error if killing the process failed for other reasons (e.g. insufficient permissions).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/process.jl#L541-L548}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18437818836884264741}{} 
\hyperlink{18437818836884264741}{\texttt{Base.Sys.set\_process\_title}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.set_process_title(title::AbstractString)
\end{minted}

Set the process title. No-op on some operating systems.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L268-L272}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10090978748613293378}{} 
\hyperlink{10090978748613293378}{\texttt{Base.Sys.get\_process\_title}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.get_process_title()
\end{minted}

Get the process title. On some systems, will always return an empty string.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L256-L260}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14924556434347277048}{} 
\hyperlink{14924556434347277048}{\texttt{Base.ignorestatus}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ignorestatus(command)
\end{minted}

Mark a command object so that running it will not throw an error if the result code is non-zero.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/cmd.jl#L195-L199}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3965292339357216921}{} 
\hyperlink{3965292339357216921}{\texttt{Base.detach}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
detach(command)
\end{minted}

Mark a command object so that it will be run in a new process group, allowing it to outlive the julia process, and not have Ctrl-C interrupts passed to it.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/cmd.jl#L204-L208}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10541952265148699805}{} 
\hyperlink{10541952265148699805}{\texttt{Base.Cmd}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cmd(cmd::Cmd; ignorestatus, detach, windows_verbatim, windows_hide, env, dir)
\end{minted}

Construct a new \texttt{Cmd} object, representing an external program and arguments, from \texttt{cmd}, while changing the settings of the optional keyword arguments:

\begin{itemize}
\item \texttt{ignorestatus::Bool}: If \texttt{true} (defaults to \texttt{false}), then the \texttt{Cmd} will not throw an error if the return code is nonzero.


\item \texttt{detach::Bool}: If \texttt{true} (defaults to \texttt{false}), then the \texttt{Cmd} will be run in a new process group, allowing it to outlive the \texttt{julia} process and not have Ctrl-C passed to it.


\item \texttt{windows\_verbatim::Bool}: If \texttt{true} (defaults to \texttt{false}), then on Windows the \texttt{Cmd} will send a command-line string to the process with no quoting or escaping of arguments, even arguments containing spaces. (On Windows, arguments are sent to a program as a single {\textquotedbl}command-line{\textquotedbl} string, and programs are responsible for parsing it into arguments. By default, empty arguments and arguments with spaces or tabs are quoted with double quotes \texttt{{\textquotedbl}} in the command line, and \texttt{{\textbackslash}} or \texttt{{\textquotedbl}} are preceded by backslashes. \texttt{windows\_verbatim=true} is useful for launching programs that parse their command line in nonstandard ways.) Has no effect on non-Windows systems.


\item \texttt{windows\_hide::Bool}: If \texttt{true} (defaults to \texttt{false}), then on Windows no new console window is displayed when the \texttt{Cmd} is executed. This has no effect if a console is already open or on non-Windows systems.


\item \texttt{env}: Set environment variables to use when running the \texttt{Cmd}. \texttt{env} is either a dictionary mapping strings to strings, an array of strings of the form \texttt{{\textquotedbl}var=val{\textquotedbl}}, an array or tuple of \texttt{{\textquotedbl}var{\textquotedbl}=>val} pairs, or \texttt{nothing}. In order to modify (rather than replace) the existing environment, create \texttt{env} by \texttt{copy(ENV)} and then set \texttt{env[{\textquotedbl}var{\textquotedbl}]=val} as desired.


\item \texttt{dir::AbstractString}: Specify a working directory for the command (instead of the current directory).

\end{itemize}
For any keywords that are not specified, the current settings from \texttt{cmd} are used. Normally, to create a \texttt{Cmd} object in the first place, one uses backticks, e.g.


\begin{lstlisting}
Cmd(`echo "Hello world"`, ignorestatus=true, detach=false)
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/cmd.jl#L39-L73}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14476048880059260855}{} 
\hyperlink{14476048880059260855}{\texttt{Base.setenv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
setenv(command::Cmd, env; dir="")
\end{minted}

Set environment variables to use when running the given \texttt{command}. \texttt{env} is either a dictionary mapping strings to strings, an array of strings of the form \texttt{{\textquotedbl}var=val{\textquotedbl}}, or zero or more \texttt{{\textquotedbl}var{\textquotedbl}=>val} pair arguments. In order to modify (rather than replace) the existing environment, create \texttt{env} by \texttt{copy(ENV)} and then setting \texttt{env[{\textquotedbl}var{\textquotedbl}]=val} as desired, or use \texttt{withenv}.

The \texttt{dir} keyword argument can be used to specify a working directory for the command.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/cmd.jl#L229-L239}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16080922180039851128}{} 
\hyperlink{16080922180039851128}{\texttt{Base.withenv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
withenv(f::Function, kv::Pair...)
\end{minted}

Execute \texttt{f} in an environment that is temporarily modified (not replaced as in \texttt{setenv}) by zero or more \texttt{{\textquotedbl}var{\textquotedbl}=>val} arguments \texttt{kv}. \texttt{withenv} is generally used via the \texttt{withenv(kv...) do ... end} syntax. A value of \texttt{nothing} can be used to temporarily unset an environment variable (if it is set). When \texttt{withenv} returns, the original environment has been restored.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/env.jl#L146-L154}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17710887576380723118}{} 
\hyperlink{17710887576380723118}{\texttt{Base.pipeline}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pipeline(from, to, ...)
\end{minted}

Create a pipeline from a data source to a destination. The source and destination can be commands, I/O streams, strings, or results of other \texttt{pipeline} calls. At least one argument must be a command. Strings refer to filenames. When called with more than two arguments, they are chained together from left to right. For example, \texttt{pipeline(a,b,c)} is equivalent to \texttt{pipeline(pipeline(a,b),c)}. This provides a more concise way to specify multi-stage pipelines.

\textbf{Examples}:


\begin{minted}{julia}
run(pipeline(`ls`, `grep xyz`))
run(pipeline(`ls`, "out.txt"))
run(pipeline("out.txt", `grep xyz`))
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/cmd.jl#L296-L313}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14749518171354514193}{} 
\hyperlink{14749518171354514193}{\texttt{Base.pipeline}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pipeline(command; stdin, stdout, stderr, append=false)
\end{minted}

Redirect I/O to or from the given \texttt{command}. Keyword arguments specify which of the command{\textquotesingle}s streams should be redirected. \texttt{append} controls whether file output appends to the file. This is a more general version of the 2-argument \texttt{pipeline} function. \texttt{pipeline(from, to)} is equivalent to \texttt{pipeline(from, stdout=to)} when \texttt{from} is a command, and to \texttt{pipeline(to, stdin=from)} when \texttt{from} is another kind of data source.

\textbf{Examples}:


\begin{minted}{julia}
run(pipeline(`dothings`, stdout="out.txt", stderr="errs.txt"))
run(pipeline(`update`, stdout="log.txt", append=true))
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/cmd.jl#L261-L276}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1938096715296079780}{} 
\hyperlink{1938096715296079780}{\texttt{Base.Libc.gethostname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gethostname() -> AbstractString
\end{minted}

Get the local machine{\textquotesingle}s host name.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L260-L264}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13507906219795618929}{} 
\hyperlink{13507906219795618929}{\texttt{Base.Libc.getpid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getpid(process) -> Int32
\end{minted}

Get the child process ID, if it still exists.

\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/process.jl#L565-L572}{\texttt{source}}



\begin{lstlisting}
getpid() -> Int32
\end{lstlisting}

Get Julia{\textquotesingle}s process ID.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L251-L255}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2441622941271736623}{} 
\hyperlink{2441622941271736623}{\texttt{Base.Libc.time}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
time()
\end{minted}

Get the system time in seconds since the epoch, with fairly high (typically, microsecond) resolution.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L242-L246}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3638234932564609978}{} 
\hyperlink{3638234932564609978}{\texttt{Base.time\_ns}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
time_ns()
\end{minted}

Get the time in nanoseconds. The time corresponding to 0 is undefined, and wraps every 5.8 years.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/Base.jl#L60-L64}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8029752041511656628}{} 
\hyperlink{8029752041511656628}{\texttt{Base.@time}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@time
\end{minted}

A macro to execute an expression, printing the time it took to execute, the number of allocations, and the total number of bytes its execution caused to be allocated, before returning the value of the expression.

See also \hyperlink{16435014226257034667}{\texttt{@timev}}, \hyperlink{6506376105249440645}{\texttt{@timed}}, \hyperlink{13321256500037064321}{\texttt{@elapsed}}, and \hyperlink{5377755456008435782}{\texttt{@allocated}}.

\begin{quote}
\textbf{Note}

For more serious benchmarking, consider the \texttt{@btime} macro from the BenchmarkTools.jl package which among other things evaluates the function multiple times in order to reduce noise.

\end{quote}

\begin{minted}{jlcon}
julia> @time rand(10^6);
  0.001525 seconds (7 allocations: 7.630 MiB)

julia> @time begin
           sleep(0.3)
           1+1
       end
  0.301395 seconds (8 allocations: 336 bytes)
2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/util.jl#L143-L169}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16435014226257034667}{} 
\hyperlink{16435014226257034667}{\texttt{Base.@timev}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@timev
\end{minted}

This is a verbose version of the \texttt{@time} macro. It first prints the same information as \texttt{@time}, then any non-zero memory allocation counters, and then returns the value of the expression.

See also \hyperlink{8029752041511656628}{\texttt{@time}}, \hyperlink{6506376105249440645}{\texttt{@timed}}, \hyperlink{13321256500037064321}{\texttt{@elapsed}}, and \hyperlink{5377755456008435782}{\texttt{@allocated}}.


\begin{minted}{jlcon}
julia> @timev rand(10^6);
  0.001006 seconds (7 allocations: 7.630 MiB)
elapsed time (ns): 1005567
bytes allocated:   8000256
pool allocs:       6
malloc() calls:    1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/util.jl#L185-L203}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6506376105249440645}{} 
\hyperlink{6506376105249440645}{\texttt{Base.@timed}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@timed
\end{minted}

A macro to execute an expression, and return the value of the expression, elapsed time, total bytes allocated, garbage collection time, and an object with various memory allocation counters.

See also \hyperlink{8029752041511656628}{\texttt{@time}}, \hyperlink{16435014226257034667}{\texttt{@timev}}, \hyperlink{13321256500037064321}{\texttt{@elapsed}}, and \hyperlink{5377755456008435782}{\texttt{@allocated}}.


\begin{minted}{jlcon}
julia> val, t, bytes, gctime, memallocs = @timed rand(10^6);

julia> t
0.006634834

julia> bytes
8000256

julia> gctime
0.0055765

julia> fieldnames(typeof(memallocs))
(:allocd, :malloc, :realloc, :poolalloc, :bigalloc, :freecall, :total_time, :pause, :full_sweep)

julia> memallocs.total_time
5576500
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/util.jl#L274-L302}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13321256500037064321}{} 
\hyperlink{13321256500037064321}{\texttt{Base.@elapsed}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@elapsed
\end{minted}

A macro to evaluate an expression, discarding the resulting value, instead returning the number of seconds it took to execute as a floating-point number.

See also \hyperlink{8029752041511656628}{\texttt{@time}}, \hyperlink{16435014226257034667}{\texttt{@timev}}, \hyperlink{6506376105249440645}{\texttt{@timed}}, and \hyperlink{5377755456008435782}{\texttt{@allocated}}.


\begin{minted}{jlcon}
julia> @elapsed sleep(0.3)
0.301391426
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/util.jl#L216-L229}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5377755456008435782}{} 
\hyperlink{5377755456008435782}{\texttt{Base.@allocated}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@allocated
\end{minted}

A macro to evaluate an expression, discarding the resulting value, instead returning the total number of bytes allocated during evaluation of the expression.

See also \hyperlink{8029752041511656628}{\texttt{@time}}, \hyperlink{16435014226257034667}{\texttt{@timev}}, \hyperlink{6506376105249440645}{\texttt{@timed}}, and \hyperlink{13321256500037064321}{\texttt{@elapsed}}.


\begin{minted}{jlcon}
julia> @allocated rand(10^6)
8000080
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/util.jl#L248-L261}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13502577110353968166}{} 
\hyperlink{13502577110353968166}{\texttt{Base.EnvDict}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
EnvDict() -> EnvDict
\end{minted}

A singleton of this type provides a hash table interface to environment variables.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/env.jl#L59-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{196658496437650743}{} 
\hyperlink{196658496437650743}{\texttt{Base.ENV}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ENV
\end{minted}

Reference to the singleton \texttt{EnvDict}, providing a dictionary interface to system environment variables.

(On Windows, system environment variables are case-insensitive, and \texttt{ENV} correspondingly converts all keys to uppercase for display, iteration, and copying. Portable code should not rely on the ability to distinguish variables by case, and should beware that setting an ostensibly lowercase variable may result in an uppercase \texttt{ENV} key.)



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/env.jl#L66-L76}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10436581591987980463}{} 
\hyperlink{10436581591987980463}{\texttt{Base.Sys.isunix}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.isunix([os])
\end{minted}

Predicate for testing if the OS provides a Unix-like interface. See documentation in \href{@ref}{Handling Operating System Variation}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L288-L293}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2208925609939091556}{} 
\hyperlink{2208925609939091556}{\texttt{Base.Sys.isapple}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.isapple([os])
\end{minted}

Predicate for testing if the OS is a derivative of Apple Macintosh OS X or Darwin. See documentation in \href{@ref}{Handling Operating System Variation}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L395-L400}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17218792417395859538}{} 
\hyperlink{17218792417395859538}{\texttt{Base.Sys.islinux}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.islinux([os])
\end{minted}

Predicate for testing if the OS is a derivative of Linux. See documentation in \href{@ref}{Handling Operating System Variation}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L310-L315}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2887161873276448004}{} 
\hyperlink{2887161873276448004}{\texttt{Base.Sys.isbsd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.isbsd([os])
\end{minted}

Predicate for testing if the OS is a derivative of BSD. See documentation in \href{@ref}{Handling Operating System Variation}.

\begin{quote}
\textbf{Note}

The Darwin kernel descends from BSD, which means that \texttt{Sys.isbsd()} is \texttt{true} on macOS systems. To exclude macOS from a predicate, use \texttt{Sys.isbsd() \&\& !Sys.isapple()}.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L318-L328}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11529071867109632004}{} 
\hyperlink{11529071867109632004}{\texttt{Base.Sys.isfreebsd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.isfreebsd([os])
\end{minted}

Predicate for testing if the OS is a derivative of FreeBSD. See documentation in \href{@ref}{Handling Operating System Variation}.

\begin{quote}
\textbf{Note}

Not to be confused with \texttt{Sys.isbsd()}, which is \texttt{true} on FreeBSD but also on other BSD-based systems. \texttt{Sys.isfreebsd()} refers only to FreeBSD.

\end{quote}
\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L331-L342}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9449644140157558794}{} 
\hyperlink{9449644140157558794}{\texttt{Base.Sys.isopenbsd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.isopenbsd([os])
\end{minted}

Predicate for testing if the OS is a derivative of OpenBSD. See documentation in \href{@ref}{Handling Operating System Variation}.

\begin{quote}
\textbf{Note}

Not to be confused with \texttt{Sys.isbsd()}, which is \texttt{true} on OpenBSD but also on other BSD-based systems. \texttt{Sys.isopenbsd()} refers only to OpenBSD.

\end{quote}
\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L345-L356}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5472156301464507299}{} 
\hyperlink{5472156301464507299}{\texttt{Base.Sys.isnetbsd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.isnetbsd([os])
\end{minted}

Predicate for testing if the OS is a derivative of NetBSD. See documentation in \href{@ref}{Handling Operating System Variation}.

\begin{quote}
\textbf{Note}

Not to be confused with \texttt{Sys.isbsd()}, which is \texttt{true} on NetBSD but also on other BSD-based systems. \texttt{Sys.isnetbsd()} refers only to NetBSD.

\end{quote}
\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L359-L370}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2925171972183731495}{} 
\hyperlink{2925171972183731495}{\texttt{Base.Sys.isdragonfly}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.isdragonfly([os])
\end{minted}

Predicate for testing if the OS is a derivative of DragonFly BSD. See documentation in \href{@ref}{Handling Operating System Variation}.

\begin{quote}
\textbf{Note}

Not to be confused with \texttt{Sys.isbsd()}, which is \texttt{true} on DragonFly but also on other BSD-based systems. \texttt{Sys.isdragonfly()} refers only to DragonFly.

\end{quote}
\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L373-L384}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16249920580734218703}{} 
\hyperlink{16249920580734218703}{\texttt{Base.Sys.iswindows}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.iswindows([os])
\end{minted}

Predicate for testing if the OS is a derivative of Microsoft Windows NT. See documentation in \href{@ref}{Handling Operating System Variation}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L387-L392}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17167896699654870190}{} 
\hyperlink{17167896699654870190}{\texttt{Base.Sys.windows\_version}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.windows_version()
\end{minted}

Return the version number for the Windows NT Kernel as a \texttt{VersionNumber}, i.e. \texttt{v{\textquotedbl}major.minor.build{\textquotedbl}}, or \texttt{v{\textquotedbl}0.0.0{\textquotedbl}} if this is not running on Windows.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L427-L432}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7740760197620822749}{} 
\hyperlink{7740760197620822749}{\texttt{Base.Sys.free\_memory}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.free_memory()
\end{minted}

Get the total free memory in RAM in kilobytes.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L242-L246}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10546193444003448021}{} 
\hyperlink{10546193444003448021}{\texttt{Base.Sys.total\_memory}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.total_memory()
\end{minted}

Get the total memory in RAM (including that which is currently used) in kilobytes.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L249-L253}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15508347639286112437}{} 
\hyperlink{15508347639286112437}{\texttt{Base.@static}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@static
\end{minted}

Partially evaluate an expression at parse time.

For example, \texttt{@static Sys.iswindows() ? foo : bar} will evaluate \texttt{Sys.iswindows()} and insert either \texttt{foo} or \texttt{bar} into the expression. This is useful in cases where a construct would be invalid on other platforms, such as a \texttt{ccall} to a non-existent function. \texttt{@static if Sys.isapple() foo end} and \texttt{@static foo <\&\&,||> bar} are also valid syntax.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/osutils.jl#L3-L13}{\texttt{source}}


\end{adjustwidth}

\hypertarget{12706049637458593234}{}


\section{Versioning}


\hypertarget{16653194174751393225}{} 
\hyperlink{16653194174751393225}{\texttt{Base.VersionNumber}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
VersionNumber
\end{minted}

Version number type which follow the specifications of \href{https://semver.org/}{semantic versioning}, composed of major, minor and patch numeric values, followed by pre-release and build alpha-numeric annotations. See also \hyperlink{8914616188788850763}{\texttt{@v\_str}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> VersionNumber("1.2.3")
v"1.2.3"

julia> VersionNumber("2.0.1-rc1")
v"2.0.1-rc1"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/version.jl#L6-L22}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8914616188788850763}{} 
\hyperlink{8914616188788850763}{\texttt{Base.@v\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@v_str
\end{minted}

String macro used to parse a string to a \hyperlink{16653194174751393225}{\texttt{VersionNumber}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v"1.2.3"
v"1.2.3"

julia> v"2.0.1-rc1"
v"2.0.1-rc1"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/version.jl#L124-L137}{\texttt{source}}


\end{adjustwidth}

\hypertarget{7115517658733019231}{}


\section{Errors}


\hypertarget{17992125292605951734}{} 
\hyperlink{17992125292605951734}{\texttt{Base.error}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
error(message::AbstractString)
\end{minted}

Raise an \texttt{ErrorException} with the given message.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/error.jl#L28-L32}{\texttt{source}}



\begin{lstlisting}
error(msg...)
\end{lstlisting}

Raise an \texttt{ErrorException} with the given message.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/error.jl#L35-L39}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16410366672587017456}{} 
\hyperlink{16410366672587017456}{\texttt{Core.throw}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
throw(e)
\end{minted}

Throw an object as an exception.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/error.jl#L19-L23}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2102349972401293064}{} 
\hyperlink{2102349972401293064}{\texttt{Base.rethrow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rethrow()
\end{minted}

Rethrow the current exception from within a \texttt{catch} block. The rethrown exception will continue propagation as if it had not been caught.

\begin{quote}
\textbf{Note}

The alternative form \texttt{rethrow(e)} allows you to associate an alternative exception object \texttt{e} with the current backtrace. However this misrepresents the program state at the time of the error so you{\textquotesingle}re encouraged to instead throw a new exception using \texttt{throw(e)}. In Julia 1.1 and above, using \texttt{throw(e)} will preserve the root cause exception on the stack, as described in \hyperlink{5950075931444385711}{\texttt{catch\_stack}}.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/error.jl#L45-L58}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6187626674327343338}{} 
\hyperlink{6187626674327343338}{\texttt{Base.backtrace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
backtrace()
\end{minted}

Get a backtrace object for the current program point.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/error.jl#L102-L106}{\texttt{source}}


\end{adjustwidth}
\hypertarget{98342946516168163}{} 
\hyperlink{98342946516168163}{\texttt{Base.catch\_backtrace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
catch_backtrace()
\end{minted}

Get the backtrace of the current exception, for use within \texttt{catch} blocks.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/error.jl#L116-L120}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5950075931444385711}{} 
\hyperlink{5950075931444385711}{\texttt{Base.catch\_stack}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
catch_stack(task=current_task(); [inclue_bt=true])
\end{minted}

Get the stack of exceptions currently being handled. For nested catch blocks there may be more than one current exception in which case the most recently thrown exception is last in the stack. The stack is returned as a Vector of \texttt{(exception,backtrace)} pairs, or a Vector of exceptions if \texttt{include\_bt} is false.

Explicitly passing \texttt{task} will return the current exception stack on an arbitrary task. This is useful for inspecting tasks which have failed due to uncaught exceptions.

\begin{quote}
\textbf{Julia 1.1}

This function is experimental in Julia 1.1 and will likely be renamed in a future release (see https://github.com/JuliaLang/julia/pull/29901).

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/error.jl#L126-L142}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4796942656392369899}{} 
\hyperlink{4796942656392369899}{\texttt{Base.@assert}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@assert cond [text]
\end{minted}

Throw an \hyperlink{11676817432925230066}{\texttt{AssertionError}} if \texttt{cond} is \texttt{false}. Preferred syntax for writing assertions. Message \texttt{text} is optionally displayed upon assertion failure.

\begin{quote}
\textbf{Warning}

An assert might be disabled at various optimization levels. Assert should therefore only be used as a debugging tool and not used for authentication verification (e.g., verifying passwords), nor should side effects needed for the function to work correctly be used inside of asserts.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> @assert iseven(3) "3 is an odd number!"
ERROR: AssertionError: 3 is an odd number!

julia> @assert isodd(3) "What even are numbers?"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/error.jl#L189-L209}{\texttt{source}}


\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Base.Experimental.register\_error\_hint}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}


\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Base.Experimental.show\_error\_hints}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{9721838137887538764}{} 
\hyperlink{9721838137887538764}{\texttt{Core.ArgumentError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ArgumentError(msg)
\end{minted}

The parameters to a function call do not match a valid signature. Argument \texttt{msg} is a descriptive error string.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2029-L2034}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11676817432925230066}{} 
\hyperlink{11676817432925230066}{\texttt{Core.AssertionError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AssertionError([msg])
\end{minted}

The asserted condition did not evaluate to \texttt{true}. Optional argument \texttt{msg} is a descriptive error string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> @assert false "this is not true"
ERROR: AssertionError: this is not true
\end{minted}

\texttt{AssertionError} is usually thrown from \hyperlink{4796942656392369899}{\texttt{@assert}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2045-L2058}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9731558909100893938}{} 
\hyperlink{9731558909100893938}{\texttt{Core.BoundsError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
BoundsError([a],[i])
\end{minted}

An indexing operation into an array, \texttt{a}, tried to access an out-of-bounds element at index \texttt{i}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = fill(1.0, 7);

julia> A[8]
ERROR: BoundsError: attempt to access 7-element Array{Float64,1} at index [8]
Stacktrace:
 [1] getindex(::Array{Float64,1}, ::Int64) at ./array.jl:660
 [2] top-level scope

julia> B = fill(1.0, (2,3));

julia> B[2, 4]
ERROR: BoundsError: attempt to access 2×3 Array{Float64,2} at index [2, 4]
Stacktrace:
 [1] getindex(::Array{Float64,2}, ::Int64, ::Int64) at ./array.jl:661
 [2] top-level scope

julia> B[9]
ERROR: BoundsError: attempt to access 2×3 Array{Float64,2} at index [9]
Stacktrace:
 [1] getindex(::Array{Float64,2}, ::Int64) at ./array.jl:660
 [2] top-level scope
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1191-L1220}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15047752250898038281}{} 
\hyperlink{15047752250898038281}{\texttt{Base.CompositeException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
CompositeException
\end{minted}

Wrap a \texttt{Vector} of exceptions thrown by a \hyperlink{7131243650304654155}{\texttt{Task}} (e.g. generated from a remote worker over a channel or an asynchronously executing local I/O write or a remote worker under \texttt{pmap}) with information about the series of exceptions. For example, if a group of workers are executing several tasks, and multiple workers fail, the resulting \texttt{CompositeException} will contain a {\textquotedbl}bundle{\textquotedbl} of information from each worker indicating where and why the exception(s) occurred.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L28-L35}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13752533629496758140}{} 
\hyperlink{13752533629496758140}{\texttt{Base.DimensionMismatch}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DimensionMismatch([msg])
\end{minted}

The objects called do not have matching dimensionality. Optional argument \texttt{msg} is a descriptive error string.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L5-L10}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4168463413201806292}{} 
\hyperlink{4168463413201806292}{\texttt{Core.DivideError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DivideError()
\end{minted}

Integer division was attempted with a denominator value of 0.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 2/0
Inf

julia> div(2, 0)
ERROR: DivideError: integer division error
Stacktrace:
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1440-L1455}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14085880504701688639}{} 
\hyperlink{14085880504701688639}{\texttt{Core.DomainError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DomainError(val)
DomainError(val, msg)
\end{minted}

The argument \texttt{val} to a function or constructor is outside the valid domain.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sqrt(-1)
ERROR: DomainError with -1.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1238-L1252}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2683611566077490148}{} 
\hyperlink{2683611566077490148}{\texttt{Base.EOFError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
EOFError()
\end{minted}

No more data was available to read from a file or stream.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L5-L9}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12102596058483452470}{} 
\hyperlink{12102596058483452470}{\texttt{Core.ErrorException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ErrorException(msg)
\end{minted}

Generic error type. The error message, in the \texttt{.msg} field, may provide more specific details.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ex = ErrorException("I've done a bad thing");

julia> ex.msg
"I've done a bad thing"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1098-L1110}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5399118524830636312}{} 
\hyperlink{5399118524830636312}{\texttt{Core.InexactError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
InexactError(name::Symbol, T, val)
\end{minted}

Cannot exactly convert \texttt{val} to type \texttt{T} in a method of function \texttt{name}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> convert(Float64, 1+2im)
ERROR: InexactError: Float64(1 + 2im)
Stacktrace:
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1223-L1235}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11255134339055983338}{} 
\hyperlink{11255134339055983338}{\texttt{Core.InterruptException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
InterruptException()
\end{minted}

The process was stopped by a terminal interrupt (CTRL+C).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1363-L1367}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12862287453053981792}{} 
\hyperlink{12862287453053981792}{\texttt{Base.KeyError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
KeyError(key)
\end{minted}

An indexing operation into an \texttt{AbstractDict} (\texttt{Dict}) or \texttt{Set} like object tried to access or delete a non-existent element.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L5-L10}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15548397364092946520}{} 
\hyperlink{15548397364092946520}{\texttt{Core.LoadError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LoadError(file::AbstractString, line::Int, error)
\end{minted}

An error occurred while \hyperlink{438355891087818425}{\texttt{include}}ing, \hyperlink{16690217505788642360}{\texttt{require}}ing, or \hyperlink{169458112978175560}{\texttt{using}} a file. The error specifics should be available in the \texttt{.error} field.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2061-L2066}{\texttt{source}}


\end{adjustwidth}
\hypertarget{68769522931907606}{} 
\hyperlink{68769522931907606}{\texttt{Core.MethodError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
MethodError(f, args)
\end{minted}

A method with the required type signature does not exist in the given generic function. Alternatively, there is no unique most-specific method.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2037-L2042}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16542348944118402477}{} 
\hyperlink{16542348944118402477}{\texttt{Base.MissingException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
MissingException(msg)
\end{minted}

Exception thrown when a \hyperlink{14596725676261444434}{\texttt{missing}} value is encountered in a situation where it is not supported. The error message, in the \texttt{msg} field may provide more specific details.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/missing.jl#L7-L13}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9656432107553099418}{} 
\hyperlink{9656432107553099418}{\texttt{Core.OutOfMemoryError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
OutOfMemoryError()
\end{minted}

An operation allocated too much memory for either the system or the garbage collector to handle properly.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1183-L1188}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5617183776424836760}{} 
\hyperlink{5617183776424836760}{\texttt{Core.ReadOnlyMemoryError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ReadOnlyMemoryError()
\end{minted}

An operation tried to write to memory that is read-only.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1091-L1095}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10461069697702909970}{} 
\hyperlink{10461069697702909970}{\texttt{Core.OverflowError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
OverflowError(msg)
\end{minted}

The result of an expression is too large for the specified type and will cause a wraparound.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1349-L1353}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9812388372329622426}{} 
\hyperlink{9812388372329622426}{\texttt{Base.ProcessFailedException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ProcessFailedException
\end{minted}

Indicates problematic exit status of a process. When running commands or pipelines, this is thrown to indicate a nonzero exit code was returned (i.e. that the invoked process failed).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/process.jl#L499-L505}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10362102427170738683}{} 
\hyperlink{10362102427170738683}{\texttt{Core.StackOverflowError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
StackOverflowError()
\end{minted}

The function call grew beyond the size of the call stack. This usually happens when a call recurses infinitely.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1272-L1277}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16303515589950241655}{} 
\hyperlink{16303515589950241655}{\texttt{Base.SystemError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SystemError(prefix::AbstractString, [errno::Int32])
\end{minted}

A system call failed with an error code (in the \texttt{errno} global variable).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L12-L16}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2622693721821893139}{} 
\hyperlink{2622693721821893139}{\texttt{Core.TypeError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
TypeError(func::Symbol, context::AbstractString, expected::Type, got)
\end{minted}

A type assertion failure, or calling an intrinsic function with an incorrect argument type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1356-L1360}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14325831233857471256}{} 
\hyperlink{14325831233857471256}{\texttt{Core.UndefKeywordError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UndefKeywordError(var::Symbol)
\end{minted}

The required keyword argument \texttt{var} was not assigned in a function call.

\textbf{Examples}


\begin{minted}{jlcon}
julia> function my_func(;my_arg)
           return my_arg + 1
       end
my_func (generic function with 1 method)

julia> my_func()
ERROR: UndefKeywordError: keyword argument my_arg not assigned
Stacktrace:
 [1] my_func() at ./REPL[1]:2
 [2] top-level scope at REPL[2]:1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1328-L1346}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7764749529861419421}{} 
\hyperlink{7764749529861419421}{\texttt{Core.UndefRefError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UndefRefError()
\end{minted}

The item or field is not defined for the given object.

\textbf{Examples}


\begin{minted}{jlcon}
julia> struct MyType
           a::Vector{Int}
           MyType() = new()
       end

julia> A = MyType()
MyType(#undef)

julia> A.a
ERROR: UndefRefError: access to undefined reference
Stacktrace:
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1122-L1142}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4452889246677411554}{} 
\hyperlink{4452889246677411554}{\texttt{Core.UndefVarError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UndefVarError(var::Symbol)
\end{minted}

A symbol in the current scope is not defined.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a
ERROR: UndefVarError: a not defined

julia> a = 1;

julia> a
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1310-L1325}{\texttt{source}}


\end{adjustwidth}
\hypertarget{414193743931514144}{} 
\hyperlink{414193743931514144}{\texttt{Base.StringIndexError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
StringIndexError(str, i)
\end{minted}

An error occurred when trying to access \texttt{str} at index \texttt{i} that is not valid.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/string.jl#L3-L7}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15248096136337910028}{} 
\hyperlink{15248096136337910028}{\texttt{Core.InitError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
InitError(mod::Symbol, error)
\end{minted}

An error occurred when running a module{\textquotesingle}s \texttt{\_\_init\_\_} function. The actual error thrown is available in the \texttt{.error} field.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2069-L2074}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13615447016541985376}{} 
\hyperlink{13615447016541985376}{\texttt{Base.retry}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
retry(f;  delays=ExponentialBackOff(), check=nothing) -> Function
\end{minted}

Return an anonymous function that calls function \texttt{f}.  If an exception arises, \texttt{f} is repeatedly called again, each time \texttt{check} returns \texttt{true}, after waiting the number of seconds specified in \texttt{delays}.  \texttt{check} should input \texttt{delays}{\textquotesingle}s current state and the \texttt{Exception}.

\begin{quote}
\textbf{Julia 1.2}

Before Julia 1.2 this signature was restricted to \texttt{f::Function}.

\end{quote}
\textbf{Examples}


\begin{minted}{julia}
retry(f, delays=fill(5.0, 3))
retry(f, delays=rand(5:10, 2))
retry(f, delays=Base.ExponentialBackOff(n=3, first_delay=5, max_delay=1000))
retry(http_get, check=(s,e)->e.status == "503")(url)
retry(read, check=(s,e)->isa(e, IOError))(io, 128; all=false)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/error.jl#L262-L281}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5330798934113311579}{} 
\hyperlink{5330798934113311579}{\texttt{Base.ExponentialBackOff}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ExponentialBackOff(; n=1, first_delay=0.05, max_delay=10.0, factor=5.0, jitter=0.1)
\end{minted}

A \hyperlink{5027751419500983000}{\texttt{Float64}} iterator of length \texttt{n} whose elements exponentially increase at a rate in the interval \texttt{factor} * (1 ± \texttt{jitter}).  The first element is \texttt{first\_delay} and all elements are clamped to \texttt{max\_delay}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/error.jl#L243-L249}{\texttt{source}}


\end{adjustwidth}

\hypertarget{1591085875948558926}{}


\section{Events}


\hypertarget{16894292126246559716}{} 
\hyperlink{16894292126246559716}{\texttt{Base.Timer}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Timer(callback::Function, delay; interval = 0)
\end{minted}

Create a timer that wakes up tasks waiting for it (by calling \hyperlink{13761789780433862250}{\texttt{wait}} on the timer object) and calls the function \texttt{callback}.

Waiting tasks are woken and the function \texttt{callback} is called after an initial delay of \texttt{delay} seconds, and then repeating with the given \texttt{interval} in seconds. If \texttt{interval} is equal to \texttt{0}, the timer is only triggered once. The function \texttt{callback} is called with a single argument, the timer itself. When the timer is closed (by \hyperlink{5331333469799487255}{\texttt{close}} waiting tasks are woken with an error. Use \hyperlink{12411519405593851135}{\texttt{isopen}} to check whether a timer is still active.

\textbf{Examples}

Here the first number is printed after a delay of two seconds, then the following numbers are printed quickly.


\begin{minted}{jlcon}
julia> begin
           i = 0
           cb(timer) = (global i += 1; println(i))
           t = Timer(cb, 2, interval=0.2)
           wait(t)
           sleep(0.5)
           close(t)
       end
1
2
3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/asyncevent.jl#L218-L247}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11288834678466677845}{} 
\hyperlink{11288834678466677845}{\texttt{Base.Timer}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Timer(delay; interval = 0)
\end{minted}

Create a timer that wakes up tasks waiting for it (by calling \hyperlink{13761789780433862250}{\texttt{wait}} on the timer object).

Waiting tasks are woken after an initial delay of \texttt{delay} seconds, and then repeating with the given \texttt{interval} in seconds. If \texttt{interval} is equal to \texttt{0}, the timer is only triggered once. When the timer is closed (by \hyperlink{5331333469799487255}{\texttt{close}} waiting tasks are woken with an error. Use \hyperlink{12411519405593851135}{\texttt{isopen}} to check whether a timer is still active.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/asyncevent.jl#L55-L64}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6110056827764884232}{} 
\hyperlink{6110056827764884232}{\texttt{Base.AsyncCondition}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AsyncCondition()
\end{minted}

Create a async condition that wakes up tasks waiting for it (by calling \hyperlink{13761789780433862250}{\texttt{wait}} on the object) when notified from C by a call to \texttt{uv\_async\_send}. Waiting tasks are woken with an error when the object is closed (by \hyperlink{5331333469799487255}{\texttt{close}}. Use \hyperlink{12411519405593851135}{\texttt{isopen}} to check whether it is still active.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/asyncevent.jl#L5-L13}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11991658286161618588}{} 
\hyperlink{11991658286161618588}{\texttt{Base.AsyncCondition}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AsyncCondition(callback::Function)
\end{minted}

Create a async condition that calls the given \texttt{callback} function. The \texttt{callback} is passed one argument, the async condition object itself.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/asyncevent.jl#L38-L43}{\texttt{source}}


\end{adjustwidth}

\hypertarget{15814129481708918585}{}


\section{Reflection}


\hypertarget{15855443469905882708}{} 
\hyperlink{15855443469905882708}{\texttt{Base.nameof}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nameof(m::Module) -> Symbol
\end{minted}

Get the name of a \texttt{Module} as a \hyperlink{18332791376992528422}{\texttt{Symbol}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> nameof(Base.Broadcast)
:Broadcast
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L5-L15}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10164029261176394442}{} 
\hyperlink{10164029261176394442}{\texttt{Base.parentmodule}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
parentmodule(m::Module) -> Module
\end{minted}

Get a module{\textquotesingle}s enclosing \texttt{Module}. \texttt{Main} is its own parent.

\textbf{Examples}


\begin{minted}{jlcon}
julia> parentmodule(Main)
Main

julia> parentmodule(Base.Broadcast)
Base
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L18-L31}{\texttt{source}}



\begin{lstlisting}
parentmodule(t::DataType) -> Module
\end{lstlisting}

Determine the module containing the definition of a (potentially \texttt{UnionAll}-wrapped) \texttt{DataType}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> module Foo
           struct Int end
       end
Foo

julia> parentmodule(Int)
Core

julia> parentmodule(Foo.Int)
Foo
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L213-L231}{\texttt{source}}



\begin{lstlisting}
parentmodule(f::Function) -> Module
\end{lstlisting}

Determine the module containing the (first) definition of a generic function.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L1189-L1194}{\texttt{source}}



\begin{lstlisting}
parentmodule(f::Function, types) -> Module
\end{lstlisting}

Determine the module containing a given definition of a generic function.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L1197-L1201}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1055866307163702776}{} 
\hyperlink{1055866307163702776}{\texttt{Base.pathof}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pathof(m::Module)
\end{minted}

Return the path of the \texttt{m.jl} file that was used to \texttt{import} module \texttt{m}, or \texttt{nothing} if \texttt{m} was not imported from a package.

Use \hyperlink{10993431289442855643}{\texttt{dirname}} to get the directory part and \hyperlink{16452154606861459390}{\texttt{basename}} to get the file name part of the path.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/loading.jl#L272-L280}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10679300263900972054}{} 
\hyperlink{10679300263900972054}{\texttt{Base.moduleroot}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
moduleroot(m::Module) -> Module
\end{minted}

Find the root module of a given module. This is the first module in the chain of parent modules of \texttt{m} which is either a registered root module or which is its own parent module.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L34-L40}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8796901235206560169}{} 
\hyperlink{8796901235206560169}{\texttt{Base.@\_\_MODULE\_\_}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@__MODULE__ -> Module
\end{minted}

Get the \texttt{Module} of the toplevel eval, which is the \texttt{Module} code is currently being read from.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L50-L55}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17712571889684451973}{} 
\hyperlink{17712571889684451973}{\texttt{Base.fullname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fullname(m::Module)
\end{minted}

Get the fully-qualified name of a module as a tuple of symbols. For example,

\textbf{Examples}


\begin{minted}{jlcon}
julia> fullname(Base.Iterators)
(:Base, :Iterators)

julia> fullname(Main)
(:Main,)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L60-L73}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6473328671144201991}{} 
\hyperlink{6473328671144201991}{\texttt{Base.names}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
names(x::Module; all::Bool = false, imported::Bool = false)
\end{minted}

Get an array of the names exported by a \texttt{Module}, excluding deprecated names. If \texttt{all} is true, then the list also includes non-exported names defined in the module, deprecated names, and compiler-generated names. If \texttt{imported} is true, then names explicitly imported from other modules are also included.

As a special case, all names defined in \texttt{Main} are considered {\textquotedbl}exported{\textquotedbl}, since it is not idiomatic to explicitly export names from \texttt{Main}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L86-L97}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4268493915558726264}{} 
\hyperlink{4268493915558726264}{\texttt{Core.nfields}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nfields(x) -> Int
\end{minted}

Get the number of fields in the given object.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = 1//2;

julia> nfields(a)
2

julia> b = 1
1

julia> nfields(b)
0

julia> ex = ErrorException("I've done a bad thing");

julia> nfields(ex)
1
\end{minted}

In these examples, \texttt{a} is a \hyperlink{8304566144531167610}{\texttt{Rational}}, which has two fields. \texttt{b} is an \texttt{Int}, which is a primitive bitstype with no fields at all. \texttt{ex} is an \hyperlink{12102596058483452470}{\texttt{ErrorException}}, which has one field.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1280-L1307}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15692280320547071693}{} 
\hyperlink{15692280320547071693}{\texttt{Base.isconst}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isconst(m::Module, s::Symbol) -> Bool
\end{minted}

Determine whether a global is declared \texttt{const} in a given \texttt{Module}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L235-L239}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7261886635035590602}{} 
\hyperlink{7261886635035590602}{\texttt{Base.nameof}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nameof(f::Function) -> Symbol
\end{minted}

Get the name of a generic \texttt{Function} as a symbol. For anonymous functions, this is a compiler-generated name. For explicitly-declared subtypes of \texttt{Function}, it is the name of the function{\textquotesingle}s type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L1167-L1173}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4995931598335689542}{} 
\hyperlink{4995931598335689542}{\texttt{Base.functionloc}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
functionloc(f::Function, types)
\end{minted}

Returns a tuple \texttt{(filename,line)} giving the location of a generic \texttt{Function} definition.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/methodshow.jl#L158-L162}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10700244958032489972}{} 
\hyperlink{10700244958032489972}{\texttt{Base.functionloc}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
functionloc(m::Method)
\end{minted}

Returns a tuple \texttt{(filename,line)} giving the location of a \texttt{Method} definition.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/methodshow.jl#L145-L149}{\texttt{source}}


\end{adjustwidth}

\hypertarget{15339696196009341465}{}


\section{Internals}


\hypertarget{16287035550645122381}{} 
\hyperlink{16287035550645122381}{\texttt{Base.GC.gc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GC.gc([full=true])
\end{minted}

Perform garbage collection. The argument \texttt{full} determines the kind of collection: A full collection (default) sweeps all objects, which makes the next GC scan much slower, while an incremental collection may only sweep so-called young objects.

\begin{quote}
\textbf{Warning}

Excessive use will likely lead to poor performance.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/gcutils.jl#L57-L67}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4235089923765717766}{} 
\hyperlink{4235089923765717766}{\texttt{Base.GC.enable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GC.enable(on::Bool)
\end{minted}

Control whether garbage collection is enabled using a boolean argument (\texttt{true} for enabled, \texttt{false} for disabled). Return previous GC state.

\begin{quote}
\textbf{Warning}

Disabling garbage collection should be used only with caution, as it can cause memory use to grow without bound.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/gcutils.jl#L71-L80}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6484353991353718972}{} 
\hyperlink{6484353991353718972}{\texttt{Base.GC.@preserve}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GC.@preserve x1 x2 ... xn expr
\end{minted}

Temporarily protect the given objects from being garbage collected, even if they would otherwise be unreferenced.

The last argument is the expression during which the object(s) will be preserved. The previous arguments are the objects to preserve.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/gcutils.jl#L83-L91}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16829072478362874105}{} 
\hyperlink{16829072478362874105}{\texttt{Base.GC.safepoint}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GC.safepoint()
\end{minted}

Inserts a point in the program where garbage collection may run. This can be useful in rare cases in multi-threaded programs where some threads are allocating memory (and hence may need to run GC) but other threads are doing only simple operations (no allocation, task switches, or I/O). Calling this function periodically in non-allocating threads allows garbage collection to run.

\begin{quote}
\textbf{Julia 1.4}

This function is available as of Julia 1.4.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/gcutils.jl#L100-L112}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6644553029841096787}{} 
\hyperlink{6644553029841096787}{\texttt{Base.Meta.lower}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lower(m, x)
\end{minted}

Takes the expression \texttt{x} and returns an equivalent expression in lowered form for executing in module \texttt{m}. See also \hyperlink{18235967286596219009}{\texttt{code\_lowered}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/meta.jl#L116-L122}{\texttt{source}}


\end{adjustwidth}
\hypertarget{480381111730976310}{} 
\hyperlink{480381111730976310}{\texttt{Base.Meta.@lower}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@lower [m] x
\end{minted}

Return lowered form of the expression \texttt{x} in module \texttt{m}. By default \texttt{m} is the module in which the macro is called. See also \hyperlink{6644553029841096787}{\texttt{lower}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/meta.jl#L125-L131}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10422957797582368651}{} 
\hyperlink{10422957797582368651}{\texttt{Base.Meta.parse}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
parse(str, start; greedy=true, raise=true, depwarn=true)
\end{minted}

Parse the expression string and return an expression (which could later be passed to eval for execution). \texttt{start} is the index of the first character to start parsing. If \texttt{greedy} is \texttt{true} (default), \texttt{parse} will try to consume as much input as it can; otherwise, it will stop as soon as it has parsed a valid expression. Incomplete but otherwise syntactically valid expressions will return \texttt{Expr(:incomplete, {\textquotedbl}(error message){\textquotedbl})}. If \texttt{raise} is \texttt{true} (default), syntax errors other than incomplete expressions will raise an error. If \texttt{raise} is \texttt{false}, \texttt{parse} will return an expression that will raise an error upon evaluation. If \texttt{depwarn} is \texttt{false}, deprecation warnings will be suppressed.


\begin{minted}{jlcon}
julia> Meta.parse("x = 3, y = 5", 7)
(:(y = 5), 13)

julia> Meta.parse("x = 3, y = 5", 5)
(:((3, y) = 5), 13)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/meta.jl#L152-L171}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13034113286621278549}{} 
\hyperlink{13034113286621278549}{\texttt{Base.Meta.parse}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
parse(str; raise=true, depwarn=true)
\end{minted}

Parse the expression string greedily, returning a single expression. An error is thrown if there are additional characters after the first expression. If \texttt{raise} is \texttt{true} (default), syntax errors will raise an error; otherwise, \texttt{parse} will return an expression that will raise an error upon evaluation.  If \texttt{depwarn} is \texttt{false}, deprecation warnings will be suppressed.


\begin{minted}{jlcon}
julia> Meta.parse("x = 3")
:(x = 3)

julia> Meta.parse("x = ")
:($(Expr(:incomplete, "incomplete: premature end of input")))

julia> Meta.parse("1.0.2")
ERROR: Base.Meta.ParseError("invalid numeric constant \"1.0.\"")
Stacktrace:
[...]

julia> Meta.parse("1.0.2"; raise = false)
:($(Expr(:error, "invalid numeric constant \"1.0.\"")))
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/meta.jl#L189-L213}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6896679243086513948}{} 
\hyperlink{6896679243086513948}{\texttt{Base.Meta.ParseError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ParseError(msg)
\end{minted}

The expression passed to the \hyperlink{10422957797582368651}{\texttt{parse}} function could not be interpreted as a valid Julia expression.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/meta.jl#L142-L147}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10163592186435616882}{} 
\hyperlink{10163592186435616882}{\texttt{Core.QuoteNode}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
QuoteNode
\end{minted}

A quoted piece of code, that does not support interpolation. See the \hyperlink{12992283596689691837}{manual section about QuoteNodes} for details.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2353-L2357}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8018172489611994488}{} 
\hyperlink{8018172489611994488}{\texttt{Base.macroexpand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
macroexpand(m::Module, x; recursive=true)
\end{minted}

Take the expression \texttt{x} and return an equivalent expression with all macros removed (expanded) for executing in module \texttt{m}. The \texttt{recursive} keyword controls whether deeper levels of nested macros are also expanded. This is demonstrated in the example below:


\begin{minted}{jlcon}
julia> module M
           macro m1()
               42
           end
           macro m2()
               :(@m1())
           end
       end
M

julia> macroexpand(M, :(@m2()), recursive=true)
42

julia> macroexpand(M, :(@m2()), recursive=false)
:(#= REPL[16]:6 =# M.@m1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/expr.jl#L81-L105}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14913190777653949565}{} 
\hyperlink{14913190777653949565}{\texttt{Base.@macroexpand}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@macroexpand
\end{minted}

Return equivalent expression with all macros removed (expanded).

There are differences between \texttt{@macroexpand} and \hyperlink{8018172489611994488}{\texttt{macroexpand}}.

\begin{itemize}
\item While \hyperlink{8018172489611994488}{\texttt{macroexpand}} takes a keyword argument \texttt{recursive}, \texttt{@macroexpand}

\end{itemize}
is always recursive. For a non recursive macro version, see \hyperlink{1640589448022397515}{\texttt{@macroexpand1}}.

\begin{itemize}
\item While \hyperlink{8018172489611994488}{\texttt{macroexpand}} has an explicit \texttt{module} argument, \texttt{@macroexpand} always

\end{itemize}
expands with respect to the module in which it is called. This is best seen in the following example:


\begin{minted}{jlcon}
julia> module M
           macro m()
               1
           end
           function f()
               (@macroexpand(@m),
                macroexpand(M, :(@m)),
                macroexpand(Main, :(@m))
               )
           end
       end
M

julia> macro m()
           2
       end
@m (macro with 1 method)

julia> M.f()
(1, 1, 2)
\end{minted}

With \texttt{@macroexpand} the expression expands where \texttt{@macroexpand} appears in the code (module \texttt{M} in the example). With \texttt{macroexpand} the expression expands in the module given as the first argument.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/expr.jl#L114-L151}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1640589448022397515}{} 
\hyperlink{1640589448022397515}{\texttt{Base.@macroexpand1}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@macroexpand1
\end{minted}

Non recursive version of \hyperlink{14913190777653949565}{\texttt{@macroexpand}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/expr.jl#L157-L161}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18235967286596219009}{} 
\hyperlink{18235967286596219009}{\texttt{Base.code\_lowered}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
code_lowered(f, types; generated=true, debuginfo=:default)
\end{minted}

Return an array of the lowered forms (IR) for the methods matching the given generic function and type signature.

If \texttt{generated} is \texttt{false}, the returned \texttt{CodeInfo} instances will correspond to fallback implementations. An error is thrown if no fallback implementation exists. If \texttt{generated} is \texttt{true}, these \texttt{CodeInfo} instances will correspond to the method bodies yielded by expanding the generators.

The keyword debuginfo controls the amount of code metadata present in the output.

Note that an error will be thrown if \texttt{types} are not leaf types when \texttt{generated} is \texttt{true} and any of the corresponding methods are an \texttt{@generated} method.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L779-L794}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14801595959157535515}{} 
\hyperlink{14801595959157535515}{\texttt{Base.code\_typed}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
code_typed(f, types; optimize=true, debuginfo=:default)
\end{minted}

Returns an array of type-inferred lowered form (IR) for the methods matching the given generic function and type signature. The keyword argument \texttt{optimize} controls whether additional optimizations, such as inlining, are also applied. The keyword \texttt{debuginfo} controls the amount of code metadata present in the output, possible options are \texttt{:source} or \texttt{:none}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reflection.jl#L1077-L1085}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11532354486541587545}{} 
\hyperlink{11532354486541587545}{\texttt{Base.precompile}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
precompile(f, args::Tuple{Vararg{Any}})
\end{minted}

Compile the given function \texttt{f} for the argument tuple (of types) \texttt{args}, but do not execute it.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L456-L460}{\texttt{source}}


\end{adjustwidth}

\hypertarget{9034456781179297090}{}


\section{Meta}


\hypertarget{11257355729811091611}{} 
\hyperlink{11257355729811091611}{\texttt{Base.Meta.quot}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Meta.quot(ex)::Expr
\end{minted}

Quote expression \texttt{ex} to produce an expression with head \texttt{quote}. This can for instance be used to represent objects of type \texttt{Expr} in the AST. See also the manual section about \hyperlink{12992283596689691837}{QuoteNode}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> eval(Meta.quot(:x))
:x

julia> dump(Meta.quot(:x))
Expr
  head: Symbol quote
  args: Array{Any}((1,))
    1: Symbol x

julia> eval(Meta.quot(:(1+2)))
:(1 + 2)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/meta.jl#L15-L35}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1144697536461438199}{} 
\hyperlink{1144697536461438199}{\texttt{Base.Meta.isexpr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Meta.isexpr(ex, head[, n])::Bool
\end{minted}

Check if \texttt{ex} is an expression with head \texttt{head} and \texttt{n} arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ex = :(f(x))
:(f(x))

julia> Meta.isexpr(ex, :block)
false

julia> Meta.isexpr(ex, :call)
true

julia> Meta.isexpr(ex, [:block, :call]) # multiple possible heads
true

julia> Meta.isexpr(ex, :call, 1)
false

julia> Meta.isexpr(ex, :call, 2)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/meta.jl#L38-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3820669871127402199}{} 
\hyperlink{3820669871127402199}{\texttt{Base.Meta.show\_sexpr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Meta.show_sexpr([io::IO,], ex)
\end{minted}

Show expression \texttt{ex} as a lisp style S-expression.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Meta.show_sexpr(:(f(x, g(y,z))))
(:call, :f, :x, (:call, :g, :y, :z))
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/meta.jl#L68-L78}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14575780034324270910}{}


\chapter{集合和数据结构}



\hypertarget{405296213558195800}{}


\section{迭代}



序列迭代由 \hyperlink{1722534687975587846}{\texttt{iterate}} 实现 广义的 \texttt{for} 循环




\begin{minted}{julia}
for i in iter   # or  "for i = iter"
    # body
end
\end{minted}



被转换成




\begin{minted}{julia}
next = iterate(iter)
while next !== nothing
    (i, state) = next
    # body
    next = iterate(iter, state)
end
\end{minted}



\texttt{state} 对象可以是任何对象，并且对于每个可迭代类型应该选择合适的 \texttt{state} 对象。 请参照 \hyperlink{3897660032678469808}{帮助文档接口的迭代小节} 来获取关于定义一个常见迭代类型的更多细节。


\hypertarget{1722534687975587846}{} 
\hyperlink{1722534687975587846}{\texttt{Base.iterate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
iterate(iter [, state]) -> Union{Nothing, Tuple{Any, Any}}
\end{minted}

Advance the iterator to obtain the next element. If no elements remain, \texttt{nothing} should be returned. Otherwise, a 2-tuple of the next element and the new iteration state should be returned.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L823-L829}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9027264262435687173}{} 
\hyperlink{9027264262435687173}{\texttt{Base.IteratorSize}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IteratorSize(itertype::Type) -> IteratorSize
\end{minted}

Given the type of an iterator, return one of the following values:

\begin{itemize}
\item \texttt{SizeUnknown()} if the length (number of elements) cannot be determined in advance.


\item \texttt{HasLength()} if there is a fixed, finite length.


\item \texttt{HasShape\{N\}()} if there is a known length plus a notion of multidimensional shape (as for an array).  In this case \texttt{N} should give the number of dimensions, and the \hyperlink{7074821531920287868}{\texttt{axes}} function is valid  for the iterator.


\item \texttt{IsInfinite()} if the iterator yields values forever.

\end{itemize}
The default value (for iterators that do not define this function) is \texttt{HasLength()}. This means that most iterators are assumed to implement \hyperlink{9362803119463040896}{\texttt{length}}.

This trait is generally used to select between algorithms that pre-allocate space for their result, and algorithms that resize their result incrementally.


\begin{minted}{jlcon}
julia> Base.IteratorSize(1:5)
Base.HasShape{1}()

julia> Base.IteratorSize((2,3))
Base.HasLength()
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/generator.jl#L64-L89}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14296089798779773392}{} 
\hyperlink{14296089798779773392}{\texttt{Base.IteratorEltype}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IteratorEltype(itertype::Type) -> IteratorEltype
\end{minted}

Given the type of an iterator, return one of the following values:

\begin{itemize}
\item \texttt{EltypeUnknown()} if the type of elements yielded by the iterator is not known in advance.


\item \texttt{HasEltype()} if the element type is known, and \hyperlink{6396209842929672718}{\texttt{eltype}} would return a meaningful value.

\end{itemize}
\texttt{HasEltype()} is the default, since iterators are assumed to implement \hyperlink{6396209842929672718}{\texttt{eltype}}.

This trait is generally used to select between algorithms that pre-allocate a specific type of result, and algorithms that pick a result type based on the types of yielded values.


\begin{minted}{jlcon}
julia> Base.IteratorEltype(1:5)
Base.HasEltype()
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/generator.jl#L104-L122}{\texttt{source}}


\end{adjustwidth}

以下类型均完全实现了上述函数：



\begin{itemize}
\item \hyperlink{13239199982495881110}{\texttt{AbstractRange}}


\item \hyperlink{9165955949298153694}{\texttt{UnitRange}}


\item \texttt{Tuple}


\item \texttt{Number}


\item \hyperlink{6514416309183787338}{\texttt{AbstractArray}}


\item \hyperlink{12699422379073174384}{\texttt{BitSet}}


\item \hyperlink{14088500196255451490}{\texttt{IdDict}}


\item \hyperlink{3089397136845322041}{\texttt{Dict}}


\item \hyperlink{17958922440222792850}{\texttt{WeakKeyDict}}


\item \texttt{EachLine}


\item \texttt{AbstractString}


\item \hyperlink{1143189053501747033}{\texttt{Set}}


\item \hyperlink{14946515604348703614}{\texttt{Pair}}


\item \hyperlink{3845731488275720657}{\texttt{NamedTuple}}

\end{itemize}


\hypertarget{7658593471001121217}{}


\section{构造函数和类型}


\hypertarget{13239199982495881110}{} 
\hyperlink{13239199982495881110}{\texttt{Base.AbstractRange}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractRange{T}
\end{minted}

Supertype for ranges with elements of type \texttt{T}. \hyperlink{9165955949298153694}{\texttt{UnitRange}} and other types are subtypes of this.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/range.jl#L134-L139}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17576963097125092768}{} 
\hyperlink{17576963097125092768}{\texttt{Base.OrdinalRange}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
OrdinalRange{T, S} <: AbstractRange{T}
\end{minted}

Supertype for ordinal ranges with elements of type \texttt{T} with spacing(s) of type \texttt{S}. The steps should be always-exact multiples of \hyperlink{2310843180104103470}{\texttt{oneunit}}, and \texttt{T} should be a {\textquotedbl}discrete{\textquotedbl} type, which cannot have values smaller than \texttt{oneunit}. For example, \texttt{Integer} or \texttt{Date} types would qualify, whereas \texttt{Float64} would not (since this type can represent values smaller than \texttt{oneunit(Float64)}. \hyperlink{9165955949298153694}{\texttt{UnitRange}}, \hyperlink{11698840710736817669}{\texttt{StepRange}}, and other types are subtypes of this.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/range.jl#L149-L159}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15649454524028353659}{} 
\hyperlink{15649454524028353659}{\texttt{Base.AbstractUnitRange}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractUnitRange{T} <: OrdinalRange{T, T}
\end{minted}

Supertype for ranges with a step size of \hyperlink{2310843180104103470}{\texttt{oneunit(T)}} with elements of type \texttt{T}. \hyperlink{9165955949298153694}{\texttt{UnitRange}} and other types are subtypes of this.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/range.jl#L162-L167}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11698840710736817669}{} 
\hyperlink{11698840710736817669}{\texttt{Base.StepRange}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
StepRange{T, S} <: OrdinalRange{T, S}
\end{minted}

Ranges with elements of type \texttt{T} with spacing of type \texttt{S}. The step between each element is constant, and the range is defined in terms of a \texttt{start} and \texttt{stop} of type \texttt{T} and a \texttt{step} of type \texttt{S}. Neither \texttt{T} nor \texttt{S} should be floating point types. The syntax \texttt{a:b:c} with \texttt{b > 1} and \texttt{a}, \texttt{b}, and \texttt{c} all integers creates a \texttt{StepRange}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> collect(StepRange(1, Int8(2), 10))
5-element Array{Int64,1}:
 1
 3
 5
 7
 9

julia> typeof(StepRange(1, Int8(2), 10))
StepRange{Int64,Int8}

julia> typeof(1:3:6)
StepRange{Int64,Int64}
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/range.jl#L170-L195}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9165955949298153694}{} 
\hyperlink{9165955949298153694}{\texttt{Base.UnitRange}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UnitRange{T<:Real}
\end{minted}

A range parameterized by a \texttt{start} and \texttt{stop} of type \texttt{T}, filled with elements spaced by \texttt{1} from \texttt{start} until \texttt{stop} is exceeded. The syntax \texttt{a:b} with \texttt{a} and \texttt{b} both \texttt{Integer}s creates a \texttt{UnitRange}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> collect(UnitRange(2.3, 5.2))
3-element Array{Float64,1}:
 2.3
 3.3
 4.3

julia> typeof(1:10)
UnitRange{Int64}
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/range.jl#L255-L273}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5701362841495158413}{} 
\hyperlink{5701362841495158413}{\texttt{Base.LinRange}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LinRange{T}
\end{minted}

A range with \texttt{len} linearly spaced elements between its \texttt{start} and \texttt{stop}. The size of the spacing is controlled by \texttt{len}, which must be an \texttt{Int}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> LinRange(1.5, 5.5, 9)
9-element LinRange{Float64}:
 1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0,5.5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/range.jl#L357-L370}{\texttt{source}}


\end{adjustwidth}

\hypertarget{1951875669203082477}{}


\section{通用集合}


\hypertarget{16079064795802595318}{} 
\hyperlink{16079064795802595318}{\texttt{Base.isempty}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isempty(collection) -> Bool
\end{minted}

Determine whether a collection is empty (has no elements).

\textbf{Examples}


\begin{minted}{jlcon}
julia> isempty([])
true

julia> isempty([1 2 3])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L722-L735}{\texttt{source}}



\begin{lstlisting}
isempty(condition)
\end{lstlisting}

Return \texttt{true} if no tasks are waiting on the condition, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/condition.jl#L141-L145}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11014622222736498057}{} 
\hyperlink{11014622222736498057}{\texttt{Base.empty!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
empty!(collection) -> collection
\end{minted}

Remove all elements from a \texttt{collection}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = Dict("a" => 1, "b" => 2)
Dict{String,Int64} with 2 entries:
  "b" => 2
  "a" => 1

julia> empty!(A);

julia> A
Dict{String,Int64} with 0 entries
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L245-L262}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9362803119463040896}{} 
\hyperlink{9362803119463040896}{\texttt{Base.length}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
length(collection) -> Integer
\end{minted}

Return the number of elements in the collection.

Use \hyperlink{15780929618270241785}{\texttt{lastindex}} to get the last valid index of an indexable collection.

\textbf{Examples}


\begin{minted}{jlcon}
julia> length(1:5)
5

julia> length([1, 2, 3, 4])
4

julia> length([1 2; 3 4])
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L171-L189}{\texttt{source}}


\end{adjustwidth}

以下类型均完全实现了上述函数：



\begin{itemize}
\item \hyperlink{13239199982495881110}{\texttt{AbstractRange}}


\item \hyperlink{9165955949298153694}{\texttt{UnitRange}}


\item \texttt{Tuple}


\item \texttt{Number}


\item \hyperlink{6514416309183787338}{\texttt{AbstractArray}}


\item \hyperlink{12699422379073174384}{\texttt{BitSet}}


\item \hyperlink{14088500196255451490}{\texttt{IdDict}}


\item \hyperlink{3089397136845322041}{\texttt{Dict}}


\item \hyperlink{17958922440222792850}{\texttt{WeakKeyDict}}


\item \texttt{AbstractString}


\item \hyperlink{1143189053501747033}{\texttt{Set}}


\item \hyperlink{3845731488275720657}{\texttt{NamedTuple}}

\end{itemize}


\hypertarget{2860415058234143628}{}


\section{可迭代集合}


\hypertarget{17277603976666670638}{} 
\hyperlink{17277603976666670638}{\texttt{Base.in}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
in(item, collection) -> Bool
∈(item, collection) -> Bool
∋(collection, item) -> Bool
\end{minted}

Determine whether an item is in the given collection, in the sense that it is \hyperlink{15143149452920304570}{\texttt{==}} to one of the values generated by iterating over the collection. Returns a \texttt{Bool} value, except if \texttt{item} is \hyperlink{14596725676261444434}{\texttt{missing}} or \texttt{collection} contains \texttt{missing} but not \texttt{item}, in which case \texttt{missing} is returned (\href{https://en.wikipedia.org/wiki/Three-valued\_logic}{three-valued logic}, matching the behavior of \hyperlink{14612039032155203548}{\texttt{any}} and \hyperlink{15143149452920304570}{\texttt{==}}).

Some collections follow a slightly different definition. For example, \hyperlink{1143189053501747033}{\texttt{Set}}s check whether the item \hyperlink{269533589463185031}{\texttt{isequal}} to one of the elements. \hyperlink{3089397136845322041}{\texttt{Dict}}s look for \texttt{key=>value} pairs, and the key is compared using \hyperlink{269533589463185031}{\texttt{isequal}}. To test for the presence of a key in a dictionary, use \hyperlink{16178429961779994033}{\texttt{haskey}} or \texttt{k in keys(dict)}. For these collections, the result is always a \texttt{Bool} and never \texttt{missing}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = 1:3:20
1:3:19

julia> 4 in a
true

julia> 5 in a
false

julia> missing in [1, 2]
missing

julia> 1 in [2, missing]
missing

julia> 1 in [1, missing]
true

julia> missing in Set([1, 2])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L1057-L1099}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5662586987512487976}{} 
\hyperlink{5662586987512487976}{\texttt{Base.:∉}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
∉(item, collection) -> Bool
∌(collection, item) -> Bool
\end{minted}

Negation of \texttt{∈} and \texttt{∋}, i.e. checks that \texttt{item} is not in \texttt{collection}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 1 ∉ 2:4
true

julia> 1 ∉ 1:3
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L1102-L1116}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6396209842929672718}{} 
\hyperlink{6396209842929672718}{\texttt{Base.eltype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eltype(type)
\end{minted}

Determine the type of the elements generated by iterating a collection of the given \texttt{type}. For dictionary types, this will be a \texttt{Pair\{KeyType,ValType\}}. The definition \texttt{eltype(x) = eltype(typeof(x))} is provided for convenience so that instances can be passed instead of types. However the form that accepts a type argument should be defined for new types.

\textbf{Examples}


\begin{minted}{jlcon}
julia> eltype(fill(1f0, (2,2)))
Float32

julia> eltype(fill(0x1, (2,2)))
UInt8
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L105-L122}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16333903346703258373}{} 
\hyperlink{16333903346703258373}{\texttt{Base.indexin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
indexin(a, b)
\end{minted}

Return an array containing the first index in \texttt{b} for each value in \texttt{a} that is a member of \texttt{b}. The output array contains \texttt{nothing} wherever \texttt{a} is not a member of \texttt{b}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = ['a', 'b', 'c', 'b', 'd', 'a'];

julia> b = ['a', 'b', 'c'];

julia> indexin(a, b)
6-element Array{Union{Nothing, Int64},1}:
 1
 2
 3
 2
  nothing
 1

julia> indexin(b, a)
3-element Array{Union{Nothing, Int64},1}:
 1
 2
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L2220-L2248}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11470702940123921114}{} 
\hyperlink{11470702940123921114}{\texttt{Base.unique}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unique(itr)
\end{minted}

Return an array containing only the unique elements of collection \texttt{itr}, as determined by \hyperlink{269533589463185031}{\texttt{isequal}}, in the order that the first of each set of equivalent elements originally appears. The element type of the input is preserved.

\textbf{Examples}


\begin{minted}{jlcon}
julia> unique([1, 2, 6, 2])
3-element Array{Int64,1}:
 1
 2
 6

julia> unique(Real[1, 1.0, 2])
2-element Array{Real,1}:
 1
 2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/set.jl#L90-L111}{\texttt{source}}



\begin{lstlisting}
unique(f, itr)
\end{lstlisting}

Returns an array containing one value from \texttt{itr} for each unique value produced by \texttt{f} applied to elements of \texttt{itr}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> unique(x -> x^2, [1, -1, 3, -3, 4])
3-element Array{Int64,1}:
 1
 3
 4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/set.jl#L153-L167}{\texttt{source}}



\begin{lstlisting}
unique(A::AbstractArray; dims::Int)
\end{lstlisting}

Return unique regions of \texttt{A} along dimension \texttt{dims}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = map(isodd, reshape(Vector(1:8), (2,2,2)))
2×2×2 Array{Bool,3}:
[:, :, 1] =
 1  1
 0  0

[:, :, 2] =
 1  1
 0  0

julia> unique(A)
2-element Array{Bool,1}:
 1
 0

julia> unique(A, dims=2)
2×1×2 Array{Bool,3}:
[:, :, 1] =
 1
 0

[:, :, 2] =
 1
 0

julia> unique(A, dims=3)
2×2×1 Array{Bool,3}:
[:, :, 1] =
 1  1
 0  0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L1449-L1487}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13070761997161983625}{} 
\hyperlink{13070761997161983625}{\texttt{Base.unique!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unique!(f, A::AbstractVector)
\end{minted}

Selects one value from \texttt{A} for each unique value produced by \texttt{f} applied to elements of \texttt{A} , then return the modified A.

\begin{quote}
\textbf{Julia 1.1}

This method is available as of Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> unique!(x -> x^2, [1, -1, 3, -3, 4])
3-element Array{Int64,1}:
 1
 3
 4

julia> unique!(n -> n%3, [5, 1, 8, 9, 3, 4, 10, 7, 2, 6])
3-element Array{Int64,1}:
 5
 1
 9

julia> unique!(iseven, [2, 3, 5, 7, 9])
2-element Array{Int64,1}:
 2
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/set.jl#L205-L233}{\texttt{source}}



\begin{lstlisting}
unique!(A::AbstractVector)
\end{lstlisting}

Remove duplicate items as determined by \hyperlink{269533589463185031}{\texttt{isequal}}, then return the modified \texttt{A}. \texttt{unique!} will return the elements of \texttt{A} in the order that they occur. If you do not care about the order of the returned data, then calling \texttt{(sort!(A); unique!(A))} will be much more efficient as long as the elements of \texttt{A} can be sorted.

\textbf{Examples}


\begin{minted}{jlcon}
julia> unique!([1, 1, 1])
1-element Array{Int64,1}:
 1

julia> A = [7, 3, 2, 3, 7, 5];

julia> unique!(A)
4-element Array{Int64,1}:
 7
 3
 2
 5

julia> B = [7, 6, 42, 6, 7, 42];

julia> sort!(B);  # unique! is able to process sorted data much more efficiently.

julia> unique!(B)
3-element Array{Int64,1}:
  6
  7
 42
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/set.jl#L293-L326}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7704267519153156361}{} 
\hyperlink{7704267519153156361}{\texttt{Base.allunique}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
allunique(itr) -> Bool
\end{minted}

Return \texttt{true} if all values from \texttt{itr} are distinct when compared with \hyperlink{269533589463185031}{\texttt{isequal}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1; 2; 3]
3-element Array{Int64,1}:
 1
 2
 3

julia> allunique([a, a])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/set.jl#L347-L363}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12844407765882691496}{} 
\hyperlink{12844407765882691496}{\texttt{Base.reduce}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reduce(op, itr; [init])
\end{minted}

Reduce the given collection \texttt{itr} with the given binary operator \texttt{op}. If provided, the initial value \texttt{init} must be a neutral element for \texttt{op} that will be returned for empty collections. It is unspecified whether \texttt{init} is used for non-empty collections.

For empty collections, providing \texttt{init} will be necessary, except for some special cases (e.g. when \texttt{op} is one of \texttt{+}, \texttt{*}, \texttt{max}, \texttt{min}, \texttt{\&}, \texttt{|}) when Julia can determine the neutral element of \texttt{op}.

Reductions for certain commonly-used operators may have special implementations, and should be used instead: \texttt{maximum(itr)}, \texttt{minimum(itr)}, \texttt{sum(itr)}, \texttt{prod(itr)},  \texttt{any(itr)}, \texttt{all(itr)}.

The associativity of the reduction is implementation dependent. This means that you can{\textquotesingle}t use non-associative operations like \texttt{-} because it is undefined whether \texttt{reduce(-,[1,2,3])} should be evaluated as \texttt{(1-2)-3} or \texttt{1-(2-3)}. Use \hyperlink{3612301023460122482}{\texttt{foldl}} or \hyperlink{4241312416601225037}{\texttt{foldr}} instead for guaranteed left or right associativity.

Some operations accumulate error. Parallelism will be easier if the reduction can be executed in groups. Future versions of Julia might change the algorithm. Note that the elements are not reordered if you use an ordered collection.

\textbf{Examples}


\begin{minted}{jlcon}
julia> reduce(*, [2; 3; 4])
24

julia> reduce(*, [2; 3; 4]; init=-1)
-24
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L415-L447}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3612301023460122482}{} 
\hyperlink{3612301023460122482}{\texttt{Base.foldl}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
foldl(op, itr; [init])
\end{minted}

Like \hyperlink{12844407765882691496}{\texttt{reduce}}, but with guaranteed left associativity. If provided, the keyword argument \texttt{init} will be used exactly once. In general, it will be necessary to provide \texttt{init} to work with empty collections.

\textbf{Examples}


\begin{minted}{jlcon}
julia> foldl(=>, 1:4)
((1 => 2) => 3) => 4

julia> foldl(=>, 1:4; init=0)
(((0 => 1) => 2) => 3) => 4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L159-L174}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4241312416601225037}{} 
\hyperlink{4241312416601225037}{\texttt{Base.foldr}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
foldr(op, itr; [init])
\end{minted}

Like \hyperlink{12844407765882691496}{\texttt{reduce}}, but with guaranteed right associativity. If provided, the keyword argument \texttt{init} will be used exactly once. In general, it will be necessary to provide \texttt{init} to work with empty collections.

\textbf{Examples}


\begin{minted}{jlcon}
julia> foldr(=>, 1:4)
1 => (2 => (3 => 4))

julia> foldr(=>, 1:4; init=0)
1 => (2 => (3 => (4 => 0)))
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L203-L218}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14719513931696680717}{} 
\hyperlink{14719513931696680717}{\texttt{Base.maximum}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
maximum(f, itr)
\end{minted}

Returns the largest result of calling function \texttt{f} on each element of \texttt{itr}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> maximum(length, ["Julion", "Julia", "Jule"])
6
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L604-L614}{\texttt{source}}



\begin{lstlisting}
maximum(itr)
\end{lstlisting}

Returns the largest element in a collection.

\textbf{Examples}


\begin{minted}{jlcon}
julia> maximum(-20.5:10)
9.5

julia> maximum([1,2,3])
3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L630-L643}{\texttt{source}}



\begin{lstlisting}
maximum(A::AbstractArray; dims)
\end{lstlisting}

Compute the maximum value of an array over the given dimensions. See also the \hyperlink{7839419811914289844}{\texttt{max(a,b)}} function to take the maximum of two or more arguments, which can be applied elementwise to arrays via \texttt{max.(a,b)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> maximum(A, dims=1)
1×2 Array{Int64,2}:
 3  4

julia> maximum(A, dims=2)
2×1 Array{Int64,2}:
 2
 4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L451-L474}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8410756622363562035}{} 
\hyperlink{8410756622363562035}{\texttt{Base.maximum!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
maximum!(r, A)
\end{minted}

Compute the maximum value of \texttt{A} over the singleton dimensions of \texttt{r}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> maximum!([1; 1], A)
2-element Array{Int64,1}:
 2
 4

julia> maximum!([1 1], A)
1×2 Array{Int64,2}:
 3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L477-L498}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13126064576294034099}{} 
\hyperlink{13126064576294034099}{\texttt{Base.minimum}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
minimum(f, itr)
\end{minted}

Returns the smallest result of calling function \texttt{f} on each element of \texttt{itr}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> minimum(length, ["Julion", "Julia", "Jule"])
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L617-L627}{\texttt{source}}



\begin{lstlisting}
minimum(itr)
\end{lstlisting}

Returns the smallest element in a collection.

\textbf{Examples}


\begin{minted}{jlcon}
julia> minimum(-20.5:10)
-20.5

julia> minimum([1,2,3])
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L646-L659}{\texttt{source}}



\begin{lstlisting}
minimum(A::AbstractArray; dims)
\end{lstlisting}

Compute the minimum value of an array over the given dimensions. See also the \hyperlink{7458766354532817148}{\texttt{min(a,b)}} function to take the minimum of two or more arguments, which can be applied elementwise to arrays via \texttt{min.(a,b)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> minimum(A, dims=1)
1×2 Array{Int64,2}:
 1  2

julia> minimum(A, dims=2)
2×1 Array{Int64,2}:
 1
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L501-L524}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15755225581375550665}{} 
\hyperlink{15755225581375550665}{\texttt{Base.minimum!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
minimum!(r, A)
\end{minted}

Compute the minimum value of \texttt{A} over the singleton dimensions of \texttt{r}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> minimum!([1; 1], A)
2-element Array{Int64,1}:
 1
 3

julia> minimum!([1 1], A)
1×2 Array{Int64,2}:
 1  2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L527-L548}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5171681020038097298}{} 
\hyperlink{5171681020038097298}{\texttt{Base.extrema}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
extrema(itr) -> Tuple
\end{minted}

Compute both the minimum and maximum element in a single pass, and return them as a 2-tuple.

\textbf{Examples}


\begin{minted}{jlcon}
julia> extrema(2:10)
(2, 10)

julia> extrema([9,pi,4.5])
(3.141592653589793, 9.0)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L437-L450}{\texttt{source}}



\begin{lstlisting}
extrema(f, itr) -> Tuple
\end{lstlisting}

Compute both the minimum and maximum of \texttt{f} applied to each element in \texttt{itr} and return them as a 2-tuple. Only one pass is made over \texttt{itr}.

\begin{quote}
\textbf{Julia 1.2}

This method requires Julia 1.2 or later.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> extrema(sin, 0:π)
(0.0, 0.9092974268256817)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L453-L467}{\texttt{source}}



\begin{lstlisting}
extrema(A::AbstractArray; dims) -> Array{Tuple}
\end{lstlisting}

Compute the minimum and maximum elements of an array over the given dimensions.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = reshape(Vector(1:2:16), (2,2,2))
2×2×2 Array{Int64,3}:
[:, :, 1] =
 1  5
 3  7

[:, :, 2] =
  9  13
 11  15

julia> extrema(A, dims = (1,2))
1×1×2 Array{Tuple{Int64,Int64},3}:
[:, :, 1] =
 (1, 7)

[:, :, 2] =
 (9, 15)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L1562-L1587}{\texttt{source}}



\begin{lstlisting}
extrema(f, A::AbstractArray; dims) -> Array{Tuple}
\end{lstlisting}

Compute the minimum and maximum of \texttt{f} applied to each element in the given dimensions of \texttt{A}.

\begin{quote}
\textbf{Julia 1.2}

This method requires Julia 1.2 or later.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L1590-L1598}{\texttt{source}}


\end{adjustwidth}
\hypertarget{956545262187649384}{} 
\hyperlink{956545262187649384}{\texttt{Base.argmax}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
argmax(itr) -> Integer
\end{minted}

Return the index of the maximum element in a collection. If there are multiple maximal elements, then the first one will be returned.

The collection must not be empty.

\textbf{Examples}


\begin{minted}{jlcon}
julia> argmax([8,0.1,-9,pi])
1

julia> argmax([1,7,7,6])
2

julia> argmax([1,7,7,NaN])
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L2175-L2194}{\texttt{source}}



\begin{lstlisting}
argmax(A; dims) -> indices
\end{lstlisting}

For an array input, return the indices of the maximum elements over the given dimensions. \texttt{NaN} is treated as greater than all other values.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1.0 2; 3 4]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia> argmax(A, dims=1)
1×2 Array{CartesianIndex{2},2}:
 CartesianIndex(2, 1)  CartesianIndex(2, 2)

julia> argmax(A, dims=2)
2×1 Array{CartesianIndex{2},2}:
 CartesianIndex(1, 2)
 CartesianIndex(2, 2)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L859-L881}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3019098764376574337}{} 
\hyperlink{3019098764376574337}{\texttt{Base.argmin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
argmin(itr) -> Integer
\end{minted}

Return the index of the minimum element in a collection. If there are multiple minimal elements, then the first one will be returned.

The collection must not be empty.

\textbf{Examples}


\begin{minted}{jlcon}
julia> argmin([8,0.1,-9,pi])
3

julia> argmin([7,1,1,6])
2

julia> argmin([7,1,1,NaN])
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L2197-L2216}{\texttt{source}}



\begin{lstlisting}
argmin(A; dims) -> indices
\end{lstlisting}

For an array input, return the indices of the minimum elements over the given dimensions. \texttt{NaN} is treated as less than all other values.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1.0 2; 3 4]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia> argmin(A, dims=1)
1×2 Array{CartesianIndex{2},2}:
 CartesianIndex(1, 1)  CartesianIndex(1, 2)

julia> argmin(A, dims=2)
2×1 Array{CartesianIndex{2},2}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L834-L856}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6489526403180080657}{} 
\hyperlink{6489526403180080657}{\texttt{Base.findmax}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findmax(itr) -> (x, index)
\end{minted}

Return the maximum element of the collection \texttt{itr} and its index. If there are multiple maximal elements, then the first one will be returned. If any data element is \texttt{NaN}, this element is returned. The result is in line with \texttt{max}.

The collection must not be empty.

\textbf{Examples}


\begin{minted}{jlcon}
julia> findmax([8,0.1,-9,pi])
(8.0, 1)

julia> findmax([1,7,7,6])
(7, 2)

julia> findmax([1,7,7,NaN])
(NaN, 4)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L2085-L2106}{\texttt{source}}



\begin{lstlisting}
findmax(A; dims) -> (maxval, index)
\end{lstlisting}

For an array input, returns the value and index of the maximum over the given dimensions. \texttt{NaN} is treated as greater than all other values.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1.0 2; 3 4]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia> findmax(A, dims=1)
([3.0 4.0], CartesianIndex{2}[CartesianIndex(2, 1) CartesianIndex(2, 2)])

julia> findmax(A, dims=2)
([2.0; 4.0], CartesianIndex{2}[CartesianIndex(1, 2); CartesianIndex(2, 2)])
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L797-L816}{\texttt{source}}


\end{adjustwidth}
\hypertarget{676075112677273449}{} 
\hyperlink{676075112677273449}{\texttt{Base.findmin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findmin(itr) -> (x, index)
\end{minted}

Return the minimum element of the collection \texttt{itr} and its index. If there are multiple minimal elements, then the first one will be returned. If any data element is \texttt{NaN}, this element is returned. The result is in line with \texttt{min}.

The collection must not be empty.

\textbf{Examples}


\begin{minted}{jlcon}
julia> findmin([8,0.1,-9,pi])
(-9.0, 3)

julia> findmin([7,1,1,6])
(1, 2)

julia> findmin([7,1,1,NaN])
(NaN, 4)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L2130-L2151}{\texttt{source}}



\begin{lstlisting}
findmin(A; dims) -> (minval, index)
\end{lstlisting}

For an array input, returns the value and index of the minimum over the given dimensions. \texttt{NaN} is treated as less than all other values.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1.0 2; 3 4]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia> findmin(A, dims=1)
([1.0 2.0], CartesianIndex{2}[CartesianIndex(1, 1) CartesianIndex(1, 2)])

julia> findmin(A, dims=2)
([1.0; 3.0], CartesianIndex{2}[CartesianIndex(1, 1); CartesianIndex(2, 1)])
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L748-L767}{\texttt{source}}


\end{adjustwidth}
\hypertarget{585571988055972211}{} 
\hyperlink{585571988055972211}{\texttt{Base.findmax!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findmax!(rval, rind, A) -> (maxval, index)
\end{minted}

Find the maximum of \texttt{A} and the corresponding linear index along singleton dimensions of \texttt{rval} and \texttt{rind}, and store the results in \texttt{rval} and \texttt{rind}. \texttt{NaN} is treated as greater than all other values.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L785-L791}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6616116230203866531}{} 
\hyperlink{6616116230203866531}{\texttt{Base.findmin!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findmin!(rval, rind, A) -> (minval, index)
\end{minted}

Find the minimum of \texttt{A} and the corresponding linear index along singleton dimensions of \texttt{rval} and \texttt{rind}, and store the results in \texttt{rval} and \texttt{rind}. \texttt{NaN} is treated as less than all other values.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L736-L742}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8666686648688281595}{} 
\hyperlink{8666686648688281595}{\texttt{Base.sum}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sum(f, itr)
\end{minted}

Sum the results of calling function \texttt{f} on each element of \texttt{itr}.

The return type is \texttt{Int} for signed integers of less than system word size, and \texttt{UInt} for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sum(abs2, [2; 3; 4])
29
\end{minted}

Note the important difference between \texttt{sum(A)} and \texttt{reduce(+, A)} for arrays with small integer eltype:


\begin{minted}{jlcon}
julia> sum(Int8[100, 28])
128

julia> reduce(+, Int8[100, 28])
-128
\end{minted}

In the former case, the integers are widened to system word size and therefore the result is 128. In the latter case, no such widening happens and integer overflow results in -128.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L456-L485}{\texttt{source}}



\begin{lstlisting}
sum(itr)
\end{lstlisting}

Returns the sum of all elements in a collection.

The return type is \texttt{Int} for signed integers of less than system word size, and \texttt{UInt} for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sum(1:20)
210
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L488-L502}{\texttt{source}}



\begin{lstlisting}
sum(A::AbstractArray; dims)
\end{lstlisting}

Sum elements of an array over the given dimensions.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> sum(A, dims=1)
1×2 Array{Int64,2}:
 4  6

julia> sum(A, dims=2)
2×1 Array{Int64,2}:
 3
 7
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L355-L376}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6277092149981507138}{} 
\hyperlink{6277092149981507138}{\texttt{Base.sum!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sum!(r, A)
\end{minted}

Sum elements of \texttt{A} over the singleton dimensions of \texttt{r}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> sum!([1; 1], A)
2-element Array{Int64,1}:
 3
 7

julia> sum!([1 1], A)
1×2 Array{Int64,2}:
 4  6
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L379-L400}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13484084847910116333}{} 
\hyperlink{13484084847910116333}{\texttt{Base.prod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
prod(f, itr)
\end{minted}

Returns the product of \texttt{f} applied to each element of \texttt{itr}.

The return type is \texttt{Int} for signed integers of less than system word size, and \texttt{UInt} for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.

\textbf{Examples}


\begin{minted}{jlcon}
julia> prod(abs2, [2; 3; 4])
576
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L507-L521}{\texttt{source}}



\begin{lstlisting}
prod(itr)
\end{lstlisting}

Returns the product of all elements of a collection.

The return type is \texttt{Int} for signed integers of less than system word size, and \texttt{UInt} for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.

\textbf{Examples}


\begin{minted}{jlcon}
julia> prod(1:20)
2432902008176640000
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L524-L538}{\texttt{source}}



\begin{lstlisting}
prod(A::AbstractArray; dims)
\end{lstlisting}

Multiply elements of an array over the given dimensions.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> prod(A, dims=1)
1×2 Array{Int64,2}:
 3  8

julia> prod(A, dims=2)
2×1 Array{Int64,2}:
  2
 12
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L403-L424}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15969471860599880580}{} 
\hyperlink{15969471860599880580}{\texttt{Base.prod!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
prod!(r, A)
\end{minted}

Multiply elements of \texttt{A} over the singleton dimensions of \texttt{r}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> prod!([1; 1], A)
2-element Array{Int64,1}:
  2
 12

julia> prod!([1 1], A)
1×2 Array{Int64,2}:
 3  8
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L427-L448}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14612039032155203548}{} 
\hyperlink{14612039032155203548}{\texttt{Base.any}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
any(itr) -> Bool
\end{minted}

Test whether any elements of a boolean collection are \texttt{true}, returning \texttt{true} as soon as the first \texttt{true} value in \texttt{itr} is encountered (short-circuiting).

If the input contains \hyperlink{14596725676261444434}{\texttt{missing}} values, return \texttt{missing} if all non-missing values are \texttt{false} (or equivalently, if the input contains no \texttt{true} value), following \href{https://en.wikipedia.org/wiki/Three-valued\_logic}{three-valued logic}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [true,false,false,true]
4-element Array{Bool,1}:
 1
 0
 0
 1

julia> any(a)
true

julia> any((println(i); v) for (i, v) in enumerate(a))
1
true

julia> any([missing, true])
true

julia> any([false, missing])
missing
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L664-L696}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13269987351988461926}{} 
\hyperlink{13269987351988461926}{\texttt{Base.any}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
any(p, itr) -> Bool
\end{minted}

Determine whether predicate \texttt{p} returns \texttt{true} for any elements of \texttt{itr}, returning \texttt{true} as soon as the first item in \texttt{itr} for which \texttt{p} returns \texttt{true} is encountered (short-circuiting).

If the input contains \hyperlink{14596725676261444434}{\texttt{missing}} values, return \texttt{missing} if all non-missing values are \texttt{false} (or equivalently, if the input contains no \texttt{true} value), following \href{https://en.wikipedia.org/wiki/Three-valued\_logic}{three-valued logic}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> any(i->(4<=i<=6), [3,5,7])
true

julia> any(i -> (println(i); i > 3), 1:10)
1
2
3
4
true

julia> any(i -> i > 0, [1, missing])
true

julia> any(i -> i > 0, [-1, missing])
missing

julia> any(i -> i > 0, [-1, 0])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L735-L767}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8281403281900865383}{} 
\hyperlink{8281403281900865383}{\texttt{Base.any!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
any!(r, A)
\end{minted}

Test whether any values in \texttt{A} along the singleton dimensions of \texttt{r} are \texttt{true}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [true false; true false]
2×2 Array{Bool,2}:
 1  0
 1  0

julia> any!([1; 1], A)
2-element Array{Int64,1}:
 1
 1

julia> any!([1 1], A)
1×2 Array{Int64,2}:
 1  0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L623-L645}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7942004983516218646}{} 
\hyperlink{7942004983516218646}{\texttt{Base.all}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
all(itr) -> Bool
\end{minted}

Test whether all elements of a boolean collection are \texttt{true}, returning \texttt{false} as soon as the first \texttt{false} value in \texttt{itr} is encountered (short-circuiting).

If the input contains \hyperlink{14596725676261444434}{\texttt{missing}} values, return \texttt{missing} if all non-missing values are \texttt{true} (or equivalently, if the input contains no \texttt{false} value), following \href{https://en.wikipedia.org/wiki/Three-valued\_logic}{three-valued logic}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [true,false,false,true]
4-element Array{Bool,1}:
 1
 0
 0
 1

julia> all(a)
false

julia> all((println(i); v) for (i, v) in enumerate(a))
1
2
false

julia> all([missing, false])
false

julia> all([true, missing])
missing
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L699-L732}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2312198897330859084}{} 
\hyperlink{2312198897330859084}{\texttt{Base.all}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
all(p, itr) -> Bool
\end{minted}

Determine whether predicate \texttt{p} returns \texttt{true} for all elements of \texttt{itr}, returning \texttt{false} as soon as the first item in \texttt{itr} for which \texttt{p} returns \texttt{false} is encountered (short-circuiting).

If the input contains \hyperlink{14596725676261444434}{\texttt{missing}} values, return \texttt{missing} if all non-missing values are \texttt{true} (or equivalently, if the input contains no \texttt{false} value), following \href{https://en.wikipedia.org/wiki/Three-valued\_logic}{three-valued logic}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> all(i->(4<=i<=6), [4,5,6])
true

julia> all(i -> (println(i); i < 3), 1:10)
1
2
3
false

julia> all(i -> i > 0, [1, missing])
missing

julia> all(i -> i > 0, [-1, missing])
false

julia> all(i -> i > 0, [1, 2])
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L783-L814}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1382810654686121973}{} 
\hyperlink{1382810654686121973}{\texttt{Base.all!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
all!(r, A)
\end{minted}

Test whether all values in \texttt{A} along the singleton dimensions of \texttt{r} are \texttt{true}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [true false; true false]
2×2 Array{Bool,2}:
 1  0
 1  0

julia> all!([1; 1], A)
2-element Array{Int64,1}:
 0
 0

julia> all!([1 1], A)
1×2 Array{Int64,2}:
 1  0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reducedim.jl#L575-L596}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4123799324867706690}{} 
\hyperlink{4123799324867706690}{\texttt{Base.count}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
count(p, itr) -> Integer
count(itr) -> Integer
\end{minted}

Count the number of elements in \texttt{itr} for which predicate \texttt{p} returns \texttt{true}. If \texttt{p} is omitted, counts the number of \texttt{true} elements in \texttt{itr} (which should be a collection of boolean values).

\textbf{Examples}


\begin{minted}{jlcon}
julia> count(i->(4<=i<=6), [2,3,4,5,6])
3

julia> count([true, false, true, true])
3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L835-L851}{\texttt{source}}



\begin{lstlisting}
count(
    pattern::Union{AbstractString,Regex},
    string::AbstractString;
    overlap::Bool = false,
)
\end{lstlisting}

Return the number of matches for \texttt{pattern} in \texttt{string}. This is equivalent to calling \texttt{length(findall(pattern, string))} but more efficient.

If \texttt{overlap=true}, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from disjoint character ranges.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/regex.jl#L358-L370}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5656508174326485968}{} 
\hyperlink{5656508174326485968}{\texttt{Base.any}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
any(p, itr) -> Bool
\end{minted}

Determine whether predicate \texttt{p} returns \texttt{true} for any elements of \texttt{itr}, returning \texttt{true} as soon as the first item in \texttt{itr} for which \texttt{p} returns \texttt{true} is encountered (short-circuiting).

If the input contains \hyperlink{14596725676261444434}{\texttt{missing}} values, return \texttt{missing} if all non-missing values are \texttt{false} (or equivalently, if the input contains no \texttt{true} value), following \href{https://en.wikipedia.org/wiki/Three-valued\_logic}{three-valued logic}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> any(i->(4<=i<=6), [3,5,7])
true

julia> any(i -> (println(i); i > 3), 1:10)
1
2
3
4
true

julia> any(i -> i > 0, [1, missing])
true

julia> any(i -> i > 0, [-1, missing])
missing

julia> any(i -> i > 0, [-1, 0])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L735-L767}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8835516150928560592}{} 
\hyperlink{8835516150928560592}{\texttt{Base.all}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
all(p, itr) -> Bool
\end{minted}

Determine whether predicate \texttt{p} returns \texttt{true} for all elements of \texttt{itr}, returning \texttt{false} as soon as the first item in \texttt{itr} for which \texttt{p} returns \texttt{false} is encountered (short-circuiting).

If the input contains \hyperlink{14596725676261444434}{\texttt{missing}} values, return \texttt{missing} if all non-missing values are \texttt{true} (or equivalently, if the input contains no \texttt{false} value), following \href{https://en.wikipedia.org/wiki/Three-valued\_logic}{three-valued logic}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> all(i->(4<=i<=6), [4,5,6])
true

julia> all(i -> (println(i); i < 3), 1:10)
1
2
3
false

julia> all(i -> i > 0, [1, missing])
missing

julia> all(i -> i > 0, [-1, missing])
false

julia> all(i -> i > 0, [1, 2])
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L783-L814}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8999415072542722396}{} 
\hyperlink{8999415072542722396}{\texttt{Base.foreach}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
foreach(f, c...) -> Nothing
\end{minted}

Call function \texttt{f} on each element of iterable \texttt{c}. For multiple iterable arguments, \texttt{f} is called elementwise. \texttt{foreach} should be used instead of \texttt{map} when the results of \texttt{f} are not needed, for example in \texttt{foreach(println, array)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = 1:3:7;

julia> foreach(x -> println(x^2), a)
1
16
49
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L1900-L1917}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11483231213869150535}{} 
\hyperlink{11483231213869150535}{\texttt{Base.map}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
map(f, c...) -> collection
\end{minted}

Transform collection \texttt{c} by applying \texttt{f} to each element. For multiple collection arguments, apply \texttt{f} elementwise.

See also: \hyperlink{8678396932318499078}{\texttt{mapslices}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> map(x -> x * 2, [1, 2, 3])
3-element Array{Int64,1}:
 2
 4
 6

julia> map(+, [1, 2, 3], [10, 20, 30])
3-element Array{Int64,1}:
 11
 22
 33
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L2075-L2097}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11037843636480523134}{} 
\hyperlink{11037843636480523134}{\texttt{Base.map!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
map!(function, destination, collection...)
\end{minted}

Like \hyperlink{11483231213869150535}{\texttt{map}}, but stores the result in \texttt{destination} rather than a new collection. \texttt{destination} must be at least as large as the first collection.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = zeros(3);

julia> map!(x -> x * 2, a, [1, 2, 3]);

julia> a
3-element Array{Float64,1}:
 2.0
 4.0
 6.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L2132-L2150}{\texttt{source}}



\begin{lstlisting}
map!(f, values(dict::AbstractDict))
\end{lstlisting}

Modifies \texttt{dict} by transforming each value from \texttt{val} to \texttt{f(val)}. Note that the type of \texttt{dict} cannot be changed: if \texttt{f(val)} is not an instance of the value type of \texttt{dict} then it will be converted to the value type if possible and otherwise raise an error.

\begin{quote}
\textbf{Julia 1.2}

\texttt{map!(f, values(dict::AbstractDict))} requires Julia 1.2 or later.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> d = Dict(:a => 1, :b => 2)
Dict{Symbol,Int64} with 2 entries:
  :a => 1
  :b => 2

julia> map!(v -> v-1, values(d))
Base.ValueIterator for a Dict{Symbol,Int64} with 2 entries. Values:
  0
  1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L709-L731}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10927609949347955937}{} 
\hyperlink{10927609949347955937}{\texttt{Base.mapreduce}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mapreduce(f, op, itrs...; [init])
\end{minted}

Apply function \texttt{f} to each element(s) in \texttt{itrs}, and then reduce the result using the binary function \texttt{op}. If provided, \texttt{init} must be a neutral element for \texttt{op} that will be returned for empty collections. It is unspecified whether \texttt{init} is used for non-empty collections. In general, it will be necessary to provide \texttt{init} to work with empty collections.

\hyperlink{10927609949347955937}{\texttt{mapreduce}} is functionally equivalent to calling \texttt{reduce(op, map(f, itr); init=init)}, but will in general execute faster since no intermediate collection needs to be created. See documentation for \hyperlink{12844407765882691496}{\texttt{reduce}} and \hyperlink{11483231213869150535}{\texttt{map}}.

\begin{quote}
\textbf{Julia 1.2}

\texttt{mapreduce} with multiple iterators requires Julia 1.2 or later.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> mapreduce(x->x^2, +, [1:3;]) # == 1 + 4 + 9
14
\end{minted}

The associativity of the reduction is implementation-dependent. Additionally, some implementations may reuse the return value of \texttt{f} for elements that appear multiple times in \texttt{itr}. Use \hyperlink{14886875186313200647}{\texttt{mapfoldl}} or \hyperlink{14828426243224858846}{\texttt{mapfoldr}} instead for guaranteed left or right associativity and invocation of \texttt{f} for every value.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L256-L282}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14886875186313200647}{} 
\hyperlink{14886875186313200647}{\texttt{Base.mapfoldl}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mapfoldl(f, op, itr; [init])
\end{minted}

Like \hyperlink{10927609949347955937}{\texttt{mapreduce}}, but with guaranteed left associativity, as in \hyperlink{3612301023460122482}{\texttt{foldl}}. If provided, the keyword argument \texttt{init} will be used exactly once. In general, it will be necessary to provide \texttt{init} to work with empty collections.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L150-L156}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14828426243224858846}{} 
\hyperlink{14828426243224858846}{\texttt{Base.mapfoldr}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mapfoldr(f, op, itr; [init])
\end{minted}

Like \hyperlink{10927609949347955937}{\texttt{mapreduce}}, but with guaranteed right associativity, as in \hyperlink{4241312416601225037}{\texttt{foldr}}. If provided, the keyword argument \texttt{init} will be used exactly once. In general, it will be necessary to provide \texttt{init} to work with empty collections.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reduce.jl#L193-L199}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10301663699427216331}{} 
\hyperlink{10301663699427216331}{\texttt{Base.first}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
first(coll)
\end{minted}

Get the first element of an iterable collection. Return the start point of an \hyperlink{13239199982495881110}{\texttt{AbstractRange}} even if it is empty.

\textbf{Examples}


\begin{minted}{jlcon}
julia> first(2:2:10)
2

julia> first([1; 2; 3; 4])
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L325-L339}{\texttt{source}}



\begin{minted}{julia}
first(s::AbstractString, n::Integer)
\end{minted}

Get a string consisting of the first \texttt{n} characters of \texttt{s}.


\begin{minted}{jlcon}
julia> first("∀ϵ≠0: ϵ²>0", 0)
""

julia> first("∀ϵ≠0: ϵ²>0", 1)
"∀"

julia> first("∀ϵ≠0: ϵ²>0", 3)
"∀ϵ≠"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L596-L611}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7482613677577278193}{} 
\hyperlink{7482613677577278193}{\texttt{Base.last}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
last(coll)
\end{minted}

Get the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling \hyperlink{15780929618270241785}{\texttt{lastindex}} to get the last index. Return the end point of an \hyperlink{13239199982495881110}{\texttt{AbstractRange}} even if it is empty.

\textbf{Examples}


\begin{minted}{jlcon}
julia> last(1:2:10)
9

julia> last([1; 2; 3; 4])
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L346-L361}{\texttt{source}}



\begin{minted}{julia}
last(s::AbstractString, n::Integer)
\end{minted}

Get a string consisting of the last \texttt{n} characters of \texttt{s}.


\begin{minted}{jlcon}
julia> last("∀ϵ≠0: ϵ²>0", 0)
""

julia> last("∀ϵ≠0: ϵ²>0", 1)
"0"

julia> last("∀ϵ≠0: ϵ²>0", 3)
"²>0"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L614-L629}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12661956456222222367}{} 
\hyperlink{12661956456222222367}{\texttt{Base.front}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
front(x::Tuple)::Tuple
\end{minted}

Return a \texttt{Tuple} consisting of all but the last component of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Base.front((1,2,3))
(1, 2)

julia> Base.front(())
ERROR: ArgumentError: Cannot call front on an empty tuple.
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/tuple.jl#L128-L141}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4601841136652136570}{} 
\hyperlink{4601841136652136570}{\texttt{Base.tail}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tail(x::Tuple)::Tuple
\end{minted}

Return a \texttt{Tuple} consisting of all but the first component of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Base.tail((1,2,3))
(2, 3)

julia> Base.tail(())
ERROR: ArgumentError: Cannot call tail on an empty tuple.
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L191-L204}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6276843274198881822}{} 
\hyperlink{6276843274198881822}{\texttt{Base.step}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
step(r)
\end{minted}

Get the step size of an \hyperlink{13239199982495881110}{\texttt{AbstractRange}} object.

\textbf{Examples}


\begin{minted}{jlcon}
julia> step(1:10)
1

julia> step(1:2:10)
2

julia> step(2.5:0.3:10.9)
0.3

julia> step(range(2.5, stop=10.9, length=85))
0.1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/range.jl#L481-L500}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6278865767444641812}{} 
\hyperlink{6278865767444641812}{\texttt{Base.collect}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
collect(collection)
\end{minted}

Return an \texttt{Array} of all items in a collection or iterator. For dictionaries, returns \texttt{Pair\{KeyType, ValType\}}. If the argument is array-like or is an iterator with the \hyperlink{9027264262435687173}{\texttt{HasShape}} trait, the result will have the same shape and number of dimensions as the argument.

\textbf{Examples}


\begin{minted}{jlcon}
julia> collect(1:2:13)
7-element Array{Int64,1}:
  1
  3
  5
  7
  9
 11
 13
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L582-L602}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3539644528130741625}{} 
\hyperlink{3539644528130741625}{\texttt{Base.collect}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
collect(element_type, collection)
\end{minted}

Return an \texttt{Array} with the given element type of all items in a collection or iterable. The result has the same shape and number of dimensions as \texttt{collection}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> collect(Float64, 1:2:5)
3-element Array{Float64,1}:
 1.0
 3.0
 5.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L547-L561}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11445961893478569145}{} 
\hyperlink{11445961893478569145}{\texttt{Base.filter}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
filter(f, a::AbstractArray)
\end{minted}

Return a copy of \texttt{a}, removing elements for which \texttt{f} is \texttt{false}. The function \texttt{f} is passed one argument.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = 1:10
1:10

julia> filter(isodd, a)
5-element Array{Int64,1}:
 1
 3
 5
 7
 9
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L2350-L2369}{\texttt{source}}



\begin{lstlisting}
filter(f, d::AbstractDict)
\end{lstlisting}

Return a copy of \texttt{d}, removing elements for which \texttt{f} is \texttt{false}. The function \texttt{f} is passed \texttt{key=>value} pairs.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d = Dict(1=>"a", 2=>"b")
Dict{Int64,String} with 2 entries:
  2 => "b"
  1 => "a"

julia> filter(p->isodd(p.first), d)
Dict{Int64,String} with 1 entry:
  1 => "a"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L371-L388}{\texttt{source}}



\begin{lstlisting}
filter(f, itr::SkipMissing{<:AbstractArray})
\end{lstlisting}

Return a vector similar to the array wrapped by the given \texttt{SkipMissing} iterator but with all missing elements and those for which \texttt{f} returns \texttt{false} removed.

\begin{quote}
\textbf{Julia 1.2}

This method requires Julia 1.2 or later.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> x = [1 2; missing 4]
2×2 Array{Union{Missing, Int64},2}:
 1         2
  missing  4

julia> filter(isodd, skipmissing(x))
1-element Array{Int64,1}:
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/missing.jl#L353-L373}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3384092630307389071}{} 
\hyperlink{3384092630307389071}{\texttt{Base.filter!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
filter!(f, a::AbstractVector)
\end{minted}

Update \texttt{a}, removing elements for which \texttt{f} is \texttt{false}. The function \texttt{f} is passed one argument.

\textbf{Examples}


\begin{minted}{jlcon}
julia> filter!(isodd, Vector(1:10))
5-element Array{Int64,1}:
 1
 3
 5
 7
 9
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L2399-L2415}{\texttt{source}}



\begin{lstlisting}
filter!(f, d::AbstractDict)
\end{lstlisting}

Update \texttt{d}, removing elements for which \texttt{f} is \texttt{false}. The function \texttt{f} is passed \texttt{key=>value} pairs.

\textbf{Example}


\begin{minted}{jlcon}
julia> d = Dict(1=>"a", 2=>"b", 3=>"c")
Dict{Int64,String} with 3 entries:
  2 => "b"
  3 => "c"
  1 => "a"

julia> filter!(p->isodd(p.first), d)
Dict{Int64,String} with 2 entries:
  3 => "c"
  1 => "a"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L329-L348}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17608641146794059481}{} 
\hyperlink{17608641146794059481}{\texttt{Base.replace}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
replace(A, old_new::Pair...; [count::Integer])
\end{minted}

Return a copy of collection \texttt{A} where, for each pair \texttt{old=>new} in \texttt{old\_new}, all occurrences of \texttt{old} are replaced by \texttt{new}. Equality is determined using \hyperlink{269533589463185031}{\texttt{isequal}}. If \texttt{count} is specified, then replace at most \texttt{count} occurrences in total.

The element type of the result is chosen using promotion (see \hyperlink{15048881762587391286}{\texttt{promote\_type}}) based on the element type of \texttt{A} and on the types of the \texttt{new} values in pairs. If \texttt{count} is omitted and the element type of \texttt{A} is a \texttt{Union}, the element type of the result will not include singleton types which are replaced with values of a different type: for example, \texttt{Union\{T,Missing\}} will become \texttt{T} if \texttt{missing} is replaced.

See also \hyperlink{5131476008802508952}{\texttt{replace!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> replace([1, 2, 1, 3], 1=>0, 2=>4, count=2)
4-element Array{Int64,1}:
 0
 4
 1
 3

julia> replace([1, missing], missing=>0)
2-element Array{Int64,1}:
 1
 0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/set.jl#L493-L524}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18363712244886975978}{} 
\hyperlink{18363712244886975978}{\texttt{Base.replace}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
replace(new::Function, A; [count::Integer])
\end{minted}

Return a copy of \texttt{A} where each value \texttt{x} in \texttt{A} is replaced by \texttt{new(x)} If \texttt{count} is specified, then replace at most \texttt{count} values in total (replacements being defined as \texttt{new(x) !== x}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> replace(x -> isodd(x) ? 2x : x, [1, 2, 3, 4])
4-element Array{Int64,1}:
 2
 2
 6
 4

julia> replace(Dict(1=>2, 3=>4)) do kv
           first(kv) < 3 ? first(kv)=>3 : kv
       end
Dict{Int64,Int64} with 2 entries:
  3 => 4
  1 => 3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/set.jl#L551-L574}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5131476008802508952}{} 
\hyperlink{5131476008802508952}{\texttt{Base.replace!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
replace!(A, old_new::Pair...; [count::Integer])
\end{minted}

For each pair \texttt{old=>new} in \texttt{old\_new}, replace all occurrences of \texttt{old} in collection \texttt{A} by \texttt{new}. Equality is determined using \hyperlink{269533589463185031}{\texttt{isequal}}. If \texttt{count} is specified, then replace at most \texttt{count} occurrences in total. See also \hyperlink{17608641146794059481}{\texttt{replace}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> replace!([1, 2, 1, 3], 1=>0, 2=>4, count=2)
4-element Array{Int64,1}:
 0
 4
 1
 3

julia> replace!(Set([1, 2, 3]), 1=>0)
Set{Int64} with 3 elements:
  0
  2
  3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/set.jl#L423-L447}{\texttt{source}}



\begin{lstlisting}
replace!(new::Function, A; [count::Integer])
\end{lstlisting}

Replace each element \texttt{x} in collection \texttt{A} by \texttt{new(x)}. If \texttt{count} is specified, then replace at most \texttt{count} values in total (replacements being defined as \texttt{new(x) !== x}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> replace!(x -> isodd(x) ? 2x : x, [1, 2, 3, 4])
4-element Array{Int64,1}:
 2
 2
 6
 4

julia> replace!(Dict(1=>2, 3=>4)) do kv
           first(kv) < 3 ? first(kv)=>3 : kv
       end
Dict{Int64,Int64} with 2 entries:
  3 => 4
  1 => 3

julia> replace!(x->2x, Set([3, 6]))
Set{Int64} with 2 elements:
  6
  12
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/set.jl#L461-L489}{\texttt{source}}


\end{adjustwidth}

\hypertarget{9076050997374125173}{}


\section{可索引集合}


\hypertarget{13720608614876840481}{} 
\hyperlink{13720608614876840481}{\texttt{Base.getindex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getindex(collection, key...)
\end{minted}

Retrieve the value(s) stored at the given key or index within a collection. The syntax \texttt{a[i,j,...]} is converted by the compiler to \texttt{getindex(a, i, j, ...)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = Dict("a" => 1, "b" => 2)
Dict{String,Int64} with 2 entries:
  "b" => 2
  "a" => 1

julia> getindex(A, "a")
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L768-L784}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1309244355901386657}{} 
\hyperlink{1309244355901386657}{\texttt{Base.setindex!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
setindex!(collection, value, key...)
\end{minted}

Store the given value at the given key or index within a collection. The syntax \texttt{a[i,j,...] = x} is converted by the compiler to \texttt{(setindex!(a, x, i, j, ...); x)}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L818-L823}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16943669671291374223}{} 
\hyperlink{16943669671291374223}{\texttt{Base.firstindex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
firstindex(collection) -> Integer
firstindex(collection, d) -> Integer
\end{minted}

Return the first index of \texttt{collection}. If \texttt{d} is given, return the first index of \texttt{collection} along dimension \texttt{d}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> firstindex([1,2,4])
1

julia> firstindex(rand(3,4,5), 2)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L305-L319}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15780929618270241785}{} 
\hyperlink{15780929618270241785}{\texttt{Base.lastindex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lastindex(collection) -> Integer
lastindex(collection, d) -> Integer
\end{minted}

Return the last index of \texttt{collection}. If \texttt{d} is given, return the last index of \texttt{collection} along dimension \texttt{d}.

The syntaxes \texttt{A[end]} and \texttt{A[end, end]} lower to \texttt{A[lastindex(A)]} and \texttt{A[lastindex(A, 1), lastindex(A, 2)]}, respectively.

\textbf{Examples}


\begin{minted}{jlcon}
julia> lastindex([1,2,4])
3

julia> lastindex(rand(3,4,5), 2)
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L284-L301}{\texttt{source}}


\end{adjustwidth}

以下类型均完全实现了上述函数：



\begin{itemize}
\item \hyperlink{15492651498431872487}{\texttt{Array}}


\item \hyperlink{18015155802543401629}{\texttt{BitArray}}


\item \hyperlink{6514416309183787338}{\texttt{AbstractArray}}


\item \texttt{SubArray}

\end{itemize}


以下类型仅实现了部分上述函数：



\begin{itemize}
\item \hyperlink{13239199982495881110}{\texttt{AbstractRange}}


\item \hyperlink{9165955949298153694}{\texttt{UnitRange}}


\item \texttt{Tuple}


\item \texttt{AbstractString}


\item \hyperlink{3089397136845322041}{\texttt{Dict}}


\item \hyperlink{14088500196255451490}{\texttt{IdDict}}


\item \hyperlink{17958922440222792850}{\texttt{WeakKeyDict}}


\item \hyperlink{3845731488275720657}{\texttt{NamedTuple}}

\end{itemize}


\hypertarget{8604172220127987938}{}


\section{字典}



\hyperlink{3089397136845322041}{\texttt{Dict}} 是一个标准字典。其实现利用了 \hyperlink{13797072367283572032}{\texttt{hash}} 作为键的哈希函数和 \hyperlink{269533589463185031}{\texttt{isequal}} 来决定是否相等。对于自定义类型，可以定义这两个函数来重载它们在哈希表内的存储方式。



\hyperlink{14088500196255451490}{\texttt{IdDict}} 是一种特殊的哈希表，在里面键始终是对象标识符。



\hyperlink{17958922440222792850}{\texttt{WeakKeyDict}} 是一个哈希表的实现，里面键是对象的弱引用， 所以即使键在哈希表中被引用也有可能被垃圾回收。 它像 \texttt{Dict} 一样使用 \texttt{hash} 来做哈希和 \texttt{isequal} 来做相等判断， 但是它不会在插入时转换键，这点不像 \texttt{Dict}。



\hyperlink{3089397136845322041}{\texttt{Dict}}s 可以由传递含有 \texttt{=>} 的成对对象给 \hyperlink{3089397136845322041}{\texttt{Dict}} 的构造函数来被创建：\texttt{Dict({\textquotedbl}A{\textquotedbl}=>1, {\textquotedbl}B{\textquotedbl}=>2)}。 这个调用会尝试从键值对中推到类型信息（比如这个例子创造了一个 \texttt{Dict\{String, Int64\}}）。 为了显式指定类型，请使用语法 \texttt{Dict\{KeyType,ValueType\}(...)}。例如：\texttt{Dict\{String,Int32\}({\textquotedbl}A{\textquotedbl}=>1, {\textquotedbl}B{\textquotedbl}=>2)}。



字典也可以用生成器创建。例如：\texttt{Dict(i => f(i) for i = 1:10)}。



对于字典 \texttt{D}，若键 \texttt{x} 的值存在，则语法 \texttt{D[x]} 返回 \texttt{x} 的值；否则抛出一个错误。 \texttt{D[x] = y} 存储键值对 \texttt{x => y} 到 \texttt{D} 中，会覆盖键 \texttt{x} 的已有的值。 多个参数传入\texttt{D[...]} 会被转化成元组； 例如：语法 \texttt{D[x,y]} 等于 \texttt{D[(x,y)]}，也就是说，它指向键为元组 \texttt{(x,y)} 的值。


\hypertarget{6373987858401217649}{} 
\hyperlink{6373987858401217649}{\texttt{Base.AbstractDict}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractDict{K, V}
\end{minted}

Supertype for dictionary-like types with keys of type \texttt{K} and values of type \texttt{V}. \hyperlink{3089397136845322041}{\texttt{Dict}}, \hyperlink{14088500196255451490}{\texttt{IdDict}} and other types are subtypes of this. An \texttt{AbstractDict\{K, V\}} should be an iterator of \texttt{Pair\{K, V\}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L17-L23}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3089397136845322041}{} 
\hyperlink{3089397136845322041}{\texttt{Base.Dict}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Dict([itr])
\end{minted}

\texttt{Dict\{K,V\}()} constructs a hash table with keys of type \texttt{K} and values of type \texttt{V}. Keys are compared with \hyperlink{269533589463185031}{\texttt{isequal}} and hashed with \hyperlink{13797072367283572032}{\texttt{hash}}.

Given a single iterable argument, constructs a \hyperlink{3089397136845322041}{\texttt{Dict}} whose key-value pairs are taken from 2-tuples \texttt{(key,value)} generated by the argument.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dict([("A", 1), ("B", 2)])
Dict{String,Int64} with 2 entries:
  "B" => 2
  "A" => 1
\end{minted}

Alternatively, a sequence of pair arguments may be passed.


\begin{minted}{jlcon}
julia> Dict("A"=>1, "B"=>2)
Dict{String,Int64} with 2 entries:
  "B" => 2
  "A" => 1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L52-L77}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14088500196255451490}{} 
\hyperlink{14088500196255451490}{\texttt{Base.IdDict}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IdDict([itr])
\end{minted}

\texttt{IdDict\{K,V\}()} constructs a hash table using object-id as hash and \texttt{===} as equality with keys of type \texttt{K} and values of type \texttt{V}.

See \hyperlink{3089397136845322041}{\texttt{Dict}} for further help.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L499-L506}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17958922440222792850}{} 
\hyperlink{17958922440222792850}{\texttt{Base.WeakKeyDict}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
WeakKeyDict([itr])
\end{minted}

\texttt{WeakKeyDict()} constructs a hash table where the keys are weak references to objects which may be garbage collected even when referenced in a hash table.

See \hyperlink{3089397136845322041}{\texttt{Dict}} for further help.  Note, unlike \hyperlink{3089397136845322041}{\texttt{Dict}}, \texttt{WeakKeyDict} does not convert keys on insertion.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/weakkeydict.jl#L5-L14}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2867962635551946253}{} 
\hyperlink{2867962635551946253}{\texttt{Base.ImmutableDict}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ImmutableDict
\end{minted}

ImmutableDict is a Dictionary implemented as an immutable linked list, which is optimal for small dictionaries that are constructed over many individual insertions Note that it is not possible to remove a value, although it can be partially overridden and hidden by inserting a new value with the same key


\begin{lstlisting}
ImmutableDict(KV::Pair)
\end{lstlisting}

Create a new entry in the Immutable Dictionary for the key => value pair

\begin{itemize}
\item use \texttt{(key => value) in dict} to see if this particular combination is in the properties set


\item use \texttt{get(dict, key, default)} to retrieve the most recent value for a particular key

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L733-L748}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16178429961779994033}{} 
\hyperlink{16178429961779994033}{\texttt{Base.haskey}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
haskey(collection, key) -> Bool
\end{minted}

Determine whether a collection has a mapping for a given \texttt{key}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> D = Dict('a'=>2, 'b'=>3)
Dict{Char,Int64} with 2 entries:
  'a' => 2
  'b' => 3

julia> haskey(D, 'a')
true

julia> haskey(D, 'c')
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L526-L544}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1600067245044904172}{} 
\hyperlink{1600067245044904172}{\texttt{Base.get}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
get(collection, key, default)
\end{minted}

Return the value stored for the given key, or the given default value if no mapping for the key is present.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d = Dict("a"=>1, "b"=>2);

julia> get(d, "a", 3)
1

julia> get(d, "c", 3)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L480-L496}{\texttt{source}}


\end{adjustwidth}
\hypertarget{282460992333585641}{} 
\hyperlink{282460992333585641}{\texttt{Base.get}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
get(collection, key, default)
\end{minted}

Return the value stored for the given key, or the given default value if no mapping for the key is present.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d = Dict("a"=>1, "b"=>2);

julia> get(d, "a", 3)
1

julia> get(d, "c", 3)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L480-L496}{\texttt{source}}



\begin{lstlisting}
get(f::Function, collection, key)
\end{lstlisting}

Return the value stored for the given key, or if no mapping for the key is present, return \texttt{f()}.  Use \hyperlink{1533836558345014565}{\texttt{get!}} to also store the default value in the dictionary.

This is intended to be called using \texttt{do} block syntax


\begin{minted}{julia}
get(dict, key) do
    # default value calculated here
    time()
end
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L504-L518}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1533836558345014565}{} 
\hyperlink{1533836558345014565}{\texttt{Base.get!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
get!(collection, key, default)
\end{minted}

Return the value stored for the given key, or if no mapping for the key is present, store \texttt{key => default}, and return \texttt{default}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d = Dict("a"=>1, "b"=>2, "c"=>3);

julia> get!(d, "a", 5)
1

julia> get!(d, "d", 4)
4

julia> d
Dict{String,Int64} with 4 entries:
  "c" => 3
  "b" => 2
  "a" => 1
  "d" => 4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L394-L417}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8556034432039635706}{} 
\hyperlink{8556034432039635706}{\texttt{Base.get!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
get!(f::Function, collection, key)
\end{minted}

Return the value stored for the given key, or if no mapping for the key is present, store \texttt{key => f()}, and return \texttt{f()}.

This is intended to be called using \texttt{do} block syntax:


\begin{minted}{julia}
get!(dict, key) do
    # default value calculated here
    time()
end
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L422-L435}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7350451602884809264}{} 
\hyperlink{7350451602884809264}{\texttt{Base.getkey}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getkey(collection, key, default)
\end{minted}

Return the key matching argument \texttt{key} if one exists in \texttt{collection}, otherwise return \texttt{default}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> D = Dict('a'=>2, 'b'=>3)
Dict{Char,Int64} with 2 entries:
  'a' => 2
  'b' => 3

julia> getkey(D, 'a', 1)
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)

julia> getkey(D, 'd', 'a')
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L548-L566}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2012894417553832980}{} 
\hyperlink{2012894417553832980}{\texttt{Base.delete!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
delete!(collection, key)
\end{minted}

Delete the mapping for the given key in a collection, if any, and return the collection.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d = Dict("a"=>1, "b"=>2)
Dict{String,Int64} with 2 entries:
  "b" => 2
  "a" => 1

julia> delete!(d, "b")
Dict{String,Int64} with 1 entry:
  "a" => 1

julia> delete!(d, "b") # d is left unchanged
Dict{String,Int64} with 1 entry:
  "a" => 1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L631-L651}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8214834680518266248}{} 
\hyperlink{8214834680518266248}{\texttt{Base.pop!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pop!(collection, key[, default])
\end{minted}

Delete and return the mapping for \texttt{key} if it exists in \texttt{collection}, otherwise return \texttt{default}, or throw an error if \texttt{default} is not specified.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d = Dict("a"=>1, "b"=>2, "c"=>3);

julia> pop!(d, "a")
1

julia> pop!(d, "d")
ERROR: KeyError: key "d" not found
Stacktrace:
[...]

julia> pop!(d, "e", 4)
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L583-L604}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6023948435845840069}{} 
\hyperlink{6023948435845840069}{\texttt{Base.keys}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
keys(iterator)
\end{minted}

For an iterator or collection that has keys and values (e.g. arrays and dictionaries), return an iterator over the keys.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L67-L72}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14429101350359443046}{} 
\hyperlink{14429101350359443046}{\texttt{Base.values}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
values(iterator)
\end{minted}

For an iterator or collection that has keys and values, return an iterator over the values. This function simply returns its argument by default, since the elements of a general iterator are normally considered its {\textquotedbl}values{\textquotedbl}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d = Dict("a"=>1, "b"=>2);

julia> values(d)
Base.ValueIterator for a Dict{String,Int64} with 2 entries. Values:
  2
  1

julia> values([2])
1-element Array{Int64,1}:
 2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L742-L763}{\texttt{source}}



\begin{lstlisting}
values(a::AbstractDict)
\end{lstlisting}

Return an iterator over all values in a collection. \texttt{collect(values(a))} returns an array of values. When the values are stored internally in a hash table, as is the case for \texttt{Dict}, the order in which they are returned may vary. But \texttt{keys(a)} and \texttt{values(a)} both iterate \texttt{a} and return the elements in the same order.

\textbf{Examples}


\begin{minted}{jlcon}
julia> D = Dict('a'=>2, 'b'=>3)
Dict{Char,Int64} with 2 entries:
  'a' => 2
  'b' => 3

julia> collect(values(D))
2-element Array{Int64,1}:
 2
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L101-L124}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15543779110977484852}{} 
\hyperlink{15543779110977484852}{\texttt{Base.pairs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pairs(collection)
\end{minted}

Return an iterator over \texttt{key => value} pairs for any collection that maps a set of keys to a set of values. This includes arrays, where the keys are the array indices.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L127-L133}{\texttt{source}}



\begin{lstlisting}
pairs(IndexLinear(), A)
pairs(IndexCartesian(), A)
pairs(IndexStyle(A), A)
\end{lstlisting}

An iterator that accesses each element of the array \texttt{A}, returning \texttt{i => x}, where \texttt{i} is the index for the element and \texttt{x = A[i]}. Identical to \texttt{pairs(A)}, except that the style of index can be selected. Also similar to \texttt{enumerate(A)}, except \texttt{i} will be a valid index for \texttt{A}, while \texttt{enumerate} always counts from 1 regardless of the indices of \texttt{A}.

Specifying \hyperlink{1761039776681330940}{\texttt{IndexLinear()}} ensures that \texttt{i} will be an integer; specifying \hyperlink{4052302263500310575}{\texttt{IndexCartesian()}} ensures that \texttt{i} will be a \hyperlink{4571802376991525093}{\texttt{CartesianIndex}}; specifying \texttt{IndexStyle(A)} chooses whichever has been defined as the native indexing style for array \texttt{A}.

Mutation of the bounds of the underlying array will invalidate this iterator.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = ["a" "d"; "b" "e"; "c" "f"];

julia> for (index, value) in pairs(IndexStyle(A), A)
           println("$index $value")
       end
1 a
2 b
3 c
4 d
5 e
6 f

julia> S = view(A, 1:2, :);

julia> for (index, value) in pairs(IndexStyle(S), S)
           println("$index $value")
       end
CartesianIndex(1, 1) a
CartesianIndex(2, 1) b
CartesianIndex(1, 2) d
CartesianIndex(2, 2) e
\end{minted}

See also: \hyperlink{7782790551324367092}{\texttt{IndexStyle}}, \hyperlink{7074821531920287868}{\texttt{axes}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L172-L217}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2980395915971142404}{} 
\hyperlink{2980395915971142404}{\texttt{Base.merge}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
merge(d::AbstractDict, others::AbstractDict...)
\end{minted}

Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. If the same key is present in another collection, the value for that key will be the value it has in the last collection listed.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = Dict("foo" => 0.0, "bar" => 42.0)
Dict{String,Float64} with 2 entries:
  "bar" => 42.0
  "foo" => 0.0

julia> b = Dict("baz" => 17, "bar" => 4711)
Dict{String,Int64} with 2 entries:
  "bar" => 4711
  "baz" => 17

julia> merge(a, b)
Dict{String,Float64} with 3 entries:
  "bar" => 4711.0
  "baz" => 17.0
  "foo" => 0.0

julia> merge(b, a)
Dict{String,Float64} with 3 entries:
  "bar" => 42.0
  "baz" => 17.0
  "foo" => 0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L253-L285}{\texttt{source}}



\begin{lstlisting}
merge(combine, d::AbstractDict, others::AbstractDict...)
\end{lstlisting}

Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. Values with the same key will be combined using the combiner function.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = Dict("foo" => 0.0, "bar" => 42.0)
Dict{String,Float64} with 2 entries:
  "bar" => 42.0
  "foo" => 0.0

julia> b = Dict("baz" => 17, "bar" => 4711)
Dict{String,Int64} with 2 entries:
  "bar" => 4711
  "baz" => 17

julia> merge(+, a, b)
Dict{String,Float64} with 3 entries:
  "bar" => 4753.0
  "baz" => 17.0
  "foo" => 0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L289-L315}{\texttt{source}}



\begin{lstlisting}
merge(a::NamedTuple, bs::NamedTuple...)
\end{lstlisting}

Construct a new named tuple by merging two or more existing ones, in a left-associative manner. Merging proceeds left-to-right, between pairs of named tuples, and so the order of fields present in both the leftmost and rightmost named tuples take the same position as they are found in the leftmost named tuple. However, values are taken from matching fields in the rightmost named tuple that contains that field. Fields present in only the rightmost named tuple of a pair are appended at the end. A fallback is implemented for when only a single named tuple is supplied, with signature \texttt{merge(a::NamedTuple)}.

\begin{quote}
\textbf{Julia 1.1}

Merging 3 or more \texttt{NamedTuple} requires at least Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> merge((a=1, b=2, c=3), (b=4, d=5))
(a = 1, b = 4, c = 3, d = 5)
\end{minted}


\begin{minted}{jlcon}
julia> merge((a=1, b=2), (b=3, c=(d=1,)), (c=(d=2,),))
(a = 1, b = 3, c = (d = 2,))
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/namedtuple.jl#L195-L219}{\texttt{source}}



\begin{lstlisting}
merge(a::NamedTuple, iterable)
\end{lstlisting}

Interpret an iterable of key-value pairs as a named tuple, and perform a merge.


\begin{minted}{jlcon}
julia> merge((a=1, b=2, c=3), [:b=>4, :d=>5])
(a = 1, b = 4, c = 3, d = 5)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/namedtuple.jl#L241-L250}{\texttt{source}}


\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Base.mergewith}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{6445163593036205863}{} 
\hyperlink{6445163593036205863}{\texttt{Base.merge!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
merge!(d::AbstractDict, others::AbstractDict...)
\end{minted}

Update collection with pairs from the other collections. See also \hyperlink{2980395915971142404}{\texttt{merge}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d1 = Dict(1 => 2, 3 => 4);

julia> d2 = Dict(1 => 4, 4 => 5);

julia> merge!(d1, d2);

julia> d1
Dict{Int64,Int64} with 3 entries:
  4 => 5
  3 => 4
  1 => 4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L156-L176}{\texttt{source}}



\begin{lstlisting}
merge!(combine, d::AbstractDict, others::AbstractDict...)
\end{lstlisting}

Update collection with pairs from the other collections. Values with the same key will be combined using the combiner function.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d1 = Dict(1 => 2, 3 => 4);

julia> d2 = Dict(1 => 4, 4 => 5);

julia> merge!(+, d1, d2);

julia> d1
Dict{Int64,Int64} with 3 entries:
  4 => 5
  3 => 4
  1 => 6

julia> merge!(-, d1, d1);

julia> d1
Dict{Int64,Int64} with 3 entries:
  4 => 0
  3 => 0
  1 => 0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L186-L215}{\texttt{source}}


\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Base.mergewith!}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{15797102328828238137}{} 
\hyperlink{15797102328828238137}{\texttt{Base.sizehint!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sizehint!(s, n)
\end{minted}

Suggest that collection \texttt{s} reserve capacity for at least \texttt{n} elements. This can improve performance.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1074-L1078}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7157735428816224008}{} 
\hyperlink{7157735428816224008}{\texttt{Base.keytype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
keytype(T::Type{<:AbstractArray})
keytype(A::AbstractArray)
\end{minted}

Return the key type of an array. This is equal to the \texttt{eltype} of the result of \texttt{keys(...)}, and is provided mainly for compatibility with the dictionary interface.

\textbf{Examples}


\begin{minted}{jlcon}
julia> keytype([1, 2, 3]) == Int
true

julia> keytype([1 2; 3 4])
CartesianIndex{2}
\end{minted}

\begin{quote}
\textbf{Julia 1.2}

For arrays, this function requires at least Julia 1.2.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L104-L123}{\texttt{source}}



\begin{lstlisting}
keytype(type)
\end{lstlisting}

Get the key type of an dictionary type. Behaves similarly to \hyperlink{6396209842929672718}{\texttt{eltype}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> keytype(Dict(Int32(1) => "foo"))
Int32
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L225-L235}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1758642341593311431}{} 
\hyperlink{1758642341593311431}{\texttt{Base.valtype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
valtype(T::Type{<:AbstractArray})
valtype(A::AbstractArray)
\end{minted}

Return the value type of an array. This is identical to \texttt{eltype} and is provided mainly for compatibility with the dictionary interface.

\textbf{Examples}


\begin{minted}{jlcon}
julia> valtype(["one", "two", "three"])
String
\end{minted}

\begin{quote}
\textbf{Julia 1.2}

For arrays, this function requires at least Julia 1.2.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L131-L146}{\texttt{source}}



\begin{lstlisting}
valtype(type)
\end{lstlisting}

Get the value type of an dictionary type. Behaves similarly to \hyperlink{6396209842929672718}{\texttt{eltype}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> valtype(Dict(Int32(1) => "foo"))
String
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractdict.jl#L239-L249}{\texttt{source}}


\end{adjustwidth}

以下类型均完全实现了上述函数：



\begin{itemize}
\item \hyperlink{14088500196255451490}{\texttt{IdDict}}


\item \hyperlink{3089397136845322041}{\texttt{Dict}}


\item \hyperlink{17958922440222792850}{\texttt{WeakKeyDict}}

\end{itemize}


以下类型仅实现了部分上述函数：



\begin{itemize}
\item \hyperlink{12699422379073174384}{\texttt{BitSet}}


\item \hyperlink{1143189053501747033}{\texttt{Set}}


\item \hyperlink{13502577110353968166}{\texttt{EnvDict}}


\item \hyperlink{15492651498431872487}{\texttt{Array}}


\item \hyperlink{18015155802543401629}{\texttt{BitArray}}


\item \hyperlink{2867962635551946253}{\texttt{ImmutableDict}}


\item \hyperlink{1741207879021199162}{\texttt{Iterators.Pairs}}

\end{itemize}


\hypertarget{12709358817338877858}{}


\section{类似 Set 的集合}


\hypertarget{10183330636847972356}{} 
\hyperlink{10183330636847972356}{\texttt{Base.AbstractSet}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractSet{T}
\end{minted}

Supertype for set-like types whose elements are of type \texttt{T}. \hyperlink{1143189053501747033}{\texttt{Set}}, \hyperlink{12699422379073174384}{\texttt{BitSet}} and other types are subtypes of this.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L9-L14}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1143189053501747033}{} 
\hyperlink{1143189053501747033}{\texttt{Base.Set}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Set([itr])
\end{minted}

Construct a \hyperlink{1143189053501747033}{\texttt{Set}} of the values generated by the given iterable object, or an empty set. Should be used instead of \hyperlink{12699422379073174384}{\texttt{BitSet}} for sparse integer sets, or for sets of arbitrary objects.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/set.jl#L14-L20}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12699422379073174384}{} 
\hyperlink{12699422379073174384}{\texttt{Base.BitSet}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
BitSet([itr])
\end{minted}

Construct a sorted set of \texttt{Int}s generated by the given iterable object, or an empty set. Implemented as a bit string, and therefore designed for dense integer sets. If the set will be sparse (for example, holding a few very large integers), use \hyperlink{1143189053501747033}{\texttt{Set}} instead.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/bitset.jl#L21-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6278797112644055704}{} 
\hyperlink{6278797112644055704}{\texttt{Base.union}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
union(s, itrs...)
∪(s, itrs...)
\end{minted}

Construct the union of sets. Maintain order with arrays.

\textbf{Examples}


\begin{minted}{jlcon}
julia> union([1, 2], [3, 4])
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> union([1, 2], [2, 4])
3-element Array{Int64,1}:
 1
 2
 4

julia> union([4, 2], 1:2)
3-element Array{Int64,1}:
 4
 2
 1

julia> union(Set([1, 2]), 2:3)
Set{Int64} with 3 elements:
  2
  3
  1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractset.jl#L10-L43}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12706236051336451682}{} 
\hyperlink{12706236051336451682}{\texttt{Base.union!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
union!(s::Union{AbstractSet,AbstractVector}, itrs...)
\end{minted}

Construct the union of passed in sets and overwrite \texttt{s} with the result. Maintain order with arrays.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = Set([1, 3, 4, 5]);

julia> union!(a, 1:2:8);

julia> a
Set{Int64} with 5 elements:
  7
  4
  3
  5
  1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractset.jl#L53-L73}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17029201757338520959}{} 
\hyperlink{17029201757338520959}{\texttt{Base.intersect}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
intersect(s, itrs...)
∩(s, itrs...)
\end{minted}

Construct the intersection of sets. Maintain order with arrays.

\textbf{Examples}


\begin{minted}{jlcon}
julia> intersect([1, 2, 3], [3, 4, 5])
1-element Array{Int64,1}:
 3

julia> intersect([1, 4, 4, 5, 6], [4, 6, 6, 7, 8])
2-element Array{Int64,1}:
 4
 6

julia> intersect(Set([1, 2]), BitSet([2, 3]))
Set{Int64} with 1 element:
  2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractset.jl#L97-L119}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11050652365145191041}{} 
\hyperlink{11050652365145191041}{\texttt{Base.setdiff}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
setdiff(s, itrs...)
\end{minted}

Construct the set of elements in \texttt{s} but not in any of the iterables in \texttt{itrs}. Maintain order with arrays.

\textbf{Examples}


\begin{minted}{jlcon}
julia> setdiff([1,2,3], [3,4,5])
2-element Array{Int64,1}:
 1
 2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractset.jl#L142-L155}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12326722559100879167}{} 
\hyperlink{12326722559100879167}{\texttt{Base.setdiff!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
setdiff!(s, itrs...)
\end{minted}

Remove from set \texttt{s} (in-place) each element of each iterable from \texttt{itrs}. Maintain order with arrays.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = Set([1, 3, 4, 5]);

julia> setdiff!(a, 1:2:6);

julia> a
Set{Int64} with 1 element:
  4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractset.jl#L159-L175}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4317834782250216015}{} 
\hyperlink{4317834782250216015}{\texttt{Base.symdiff}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
symdiff(s, itrs...)
\end{minted}

Construct the symmetric difference of elements in the passed in sets. When \texttt{s} is not an \texttt{AbstractSet}, the order is maintained. Note that in this case the multiplicity of elements matters.

\textbf{Examples}


\begin{minted}{jlcon}
julia> symdiff([1,2,3], [3,4,5], [4,5,6])
3-element Array{Int64,1}:
 1
 2
 6

julia> symdiff([1,2,1], [2, 1, 2])
2-element Array{Int64,1}:
 1
 2

julia> symdiff(unique([1,2,1]), unique([2, 1, 2]))
0-element Array{Int64,1}
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractset.jl#L190-L213}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13446903852078819564}{} 
\hyperlink{13446903852078819564}{\texttt{Base.symdiff!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
symdiff!(s::Union{AbstractSet,AbstractVector}, itrs...)
\end{minted}

Construct the symmetric difference of the passed in sets, and overwrite \texttt{s} with the result. When \texttt{s} is an array, the order is maintained. Note that in this case the multiplicity of elements matters.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractset.jl#L217-L223}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18401946028185283153}{} 
\hyperlink{18401946028185283153}{\texttt{Base.intersect!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
intersect!(s::Union{AbstractSet,AbstractVector}, itrs...)
\end{minted}

Intersect all passed in sets and overwrite \texttt{s} with the result. Maintain order with arrays.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractset.jl#L126-L131}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18158680907243266011}{} 
\hyperlink{18158680907243266011}{\texttt{Base.issubset}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issubset(a, b) -> Bool
⊆(a, b) -> Bool
⊇(b, a) -> Bool
\end{minted}

Determine whether every element of \texttt{a} is also in \texttt{b}, using \hyperlink{17277603976666670638}{\texttt{in}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> issubset([1, 2], [1, 2, 3])
true

julia> [1, 2, 3] ⊆ [1, 2]
false

julia> [1, 2, 3] ⊇ [1, 2]
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractset.jl#L242-L260}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1999401891136155185}{} 
\hyperlink{1999401891136155185}{\texttt{Base.:⊈}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
⊈(a, b) -> Bool
⊉(b, a) -> Bool
\end{minted}

Negation of \texttt{⊆} and \texttt{⊇}, i.e. checks that \texttt{a} is not a subset of \texttt{b}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> (1, 2) ⊈ (2, 3)
true

julia> (1, 2) ⊈ (1, 2, 3)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractset.jl#L324-L338}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8215860421663834339}{} 
\hyperlink{8215860421663834339}{\texttt{Base.:⊊}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
⊊(a, b) -> Bool
⊋(b, a) -> Bool
\end{minted}

Determines if \texttt{a} is a subset of, but not equal to, \texttt{b}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> (1, 2) ⊊ (1, 2, 3)
true

julia> (1, 2) ⊊ (1, 2)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractset.jl#L301-L315}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10250979601085180143}{} 
\hyperlink{10250979601085180143}{\texttt{Base.issetequal}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issetequal(a, b) -> Bool
\end{minted}

Determine whether \texttt{a} and \texttt{b} have the same elements. Equivalent to \texttt{a ⊆ b \&\& b ⊆ a} but more efficient when possible.

\textbf{Examples}


\begin{minted}{jlcon}
julia> issetequal([1, 2], [1, 2, 3])
false

julia> issetequal([1, 2], [2, 1])
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractset.jl#L346-L360}{\texttt{source}}


\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Base.isdisjoint}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}


以下类型均完全实现了上述函数：



\begin{itemize}
\item \hyperlink{12699422379073174384}{\texttt{BitSet}}


\item \hyperlink{1143189053501747033}{\texttt{Set}}

\end{itemize}


以下类型仅实现了部分上述函数：



\begin{itemize}
\item \hyperlink{15492651498431872487}{\texttt{Array}}

\end{itemize}


\hypertarget{9142077600230868636}{}


\section{双端队列}


\hypertarget{18026893834387542681}{} 
\hyperlink{18026893834387542681}{\texttt{Base.push!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
push!(collection, items...) -> collection
\end{minted}

Insert one or more \texttt{items} in \texttt{collection}. If \texttt{collection} is an ordered container, the items are inserted at the end (in the given order).

\textbf{Examples}


\begin{minted}{jlcon}
julia> push!([1, 2, 3], 4, 5, 6)
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6
\end{minted}

If \texttt{collection} is ordered, use \hyperlink{2587432243763606566}{\texttt{append!}} to add all the elements of another collection to it. The result of the preceding example is equivalent to \texttt{append!([1, 2, 3], [4, 5, 6])}. For \texttt{AbstractSet} objects, \hyperlink{12706236051336451682}{\texttt{union!}} can be used instead.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L887-L908}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14467641005327674015}{} 
\hyperlink{14467641005327674015}{\texttt{Base.pop!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pop!(collection) -> item
\end{minted}

Remove an item in \texttt{collection} and return it. If \texttt{collection} is an ordered container, the last item is returned.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A=[1, 2, 3]
3-element Array{Int64,1}:
 1
 2
 3

julia> pop!(A)
3

julia> A
2-element Array{Int64,1}:
 1
 2

julia> S = Set([1, 2])
Set{Int64} with 2 elements:
  2
  1

julia> pop!(S)
2

julia> S
Set{Int64} with 1 element:
  1

julia> pop!(Dict(1=>2))
1 => 2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1086-L1123}{\texttt{source}}



\begin{minted}{julia}
pop!(collection, key[, default])
\end{minted}

Delete and return the mapping for \texttt{key} if it exists in \texttt{collection}, otherwise return \texttt{default}, or throw an error if \texttt{default} is not specified.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d = Dict("a"=>1, "b"=>2, "c"=>3);

julia> pop!(d, "a")
1

julia> pop!(d, "d")
ERROR: KeyError: key "d" not found
Stacktrace:
[...]

julia> pop!(d, "e", 4)
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/dict.jl#L583-L604}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13975349246934359471}{} 
\hyperlink{13975349246934359471}{\texttt{Base.pushfirst!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pushfirst!(collection, items...) -> collection
\end{minted}

Insert one or more \texttt{items} at the beginning of \texttt{collection}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> pushfirst!([1, 2, 3, 4], 5, 6)
6-element Array{Int64,1}:
 5
 6
 1
 2
 3
 4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1133-L1149}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6030955907577332369}{} 
\hyperlink{6030955907577332369}{\texttt{Base.popfirst!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
popfirst!(collection) -> item
\end{minted}

Remove the first \texttt{item} from \texttt{collection}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1, 2, 3, 4, 5, 6]
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6

julia> popfirst!(A)
1

julia> A
5-element Array{Int64,1}:
 2
 3
 4
 5
 6
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1157-L1184}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2077968578228414845}{} 
\hyperlink{2077968578228414845}{\texttt{Base.insert!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
insert!(a::Vector, index::Integer, item)
\end{minted}

Insert an \texttt{item} into \texttt{a} at the given \texttt{index}. \texttt{index} is the index of \texttt{item} in the resulting \texttt{a}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> insert!([6, 5, 4, 2, 1], 4, 3)
6-element Array{Int64,1}:
 6
 5
 4
 3
 2
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1194-L1211}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16790471737745785097}{} 
\hyperlink{16790471737745785097}{\texttt{Base.deleteat!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
deleteat!(a::Vector, i::Integer)
\end{minted}

Remove the item at the given \texttt{i} and return the modified \texttt{a}. Subsequent items are shifted to fill the resulting gap.

\textbf{Examples}


\begin{minted}{jlcon}
julia> deleteat!([6, 5, 4, 3, 2, 1], 2)
5-element Array{Int64,1}:
 6
 4
 3
 2
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1221-L1237}{\texttt{source}}



\begin{lstlisting}
deleteat!(a::Vector, inds)
\end{lstlisting}

Remove the items at the indices given by \texttt{inds}, and return the modified \texttt{a}. Subsequent items are shifted to fill the resulting gap.

\texttt{inds} can be either an iterator or a collection of sorted and unique integer indices, or a boolean vector of the same length as \texttt{a} with \texttt{true} indicating entries to delete.

\textbf{Examples}


\begin{minted}{jlcon}
julia> deleteat!([6, 5, 4, 3, 2, 1], 1:2:5)
3-element Array{Int64,1}:
 5
 3
 1

julia> deleteat!([6, 5, 4, 3, 2, 1], [true, false, true, false, true, false])
3-element Array{Int64,1}:
 5
 3
 1

julia> deleteat!([6, 5, 4, 3, 2, 1], (2, 2))
ERROR: ArgumentError: indices must be unique and sorted
Stacktrace:
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1246-L1274}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13785507599688955371}{} 
\hyperlink{13785507599688955371}{\texttt{Base.splice!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
splice!(a::Vector, index::Integer, [replacement]) -> item
\end{minted}

Remove the item at the given index, and return the removed item. Subsequent items are shifted left to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed item.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [6, 5, 4, 3, 2, 1]; splice!(A, 5)
2

julia> A
5-element Array{Int64,1}:
 6
 5
 4
 3
 1

julia> splice!(A, 5, -1)
1

julia> A
5-element Array{Int64,1}:
  6
  5
  4
  3
 -1

julia> splice!(A, 1, [-1, -2, -3])
6

julia> A
7-element Array{Int64,1}:
 -1
 -2
 -3
  5
  4
  3
 -1
\end{minted}

To insert \texttt{replacement} before an index \texttt{n} without removing any items, use \texttt{splice!(collection, n:n-1, replacement)}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1325-L1373}{\texttt{source}}



\begin{lstlisting}
splice!(a::Vector, range, [replacement]) -> items
\end{lstlisting}

Remove items in the specified index range, and return a collection containing the removed items. Subsequent items are shifted left to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed items.

To insert \texttt{replacement} before an index \texttt{n} without removing any items, use \texttt{splice!(collection, n:n-1, replacement)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [-1, -2, -3, 5, 4, 3, -1]; splice!(A, 4:3, 2)
0-element Array{Int64,1}

julia> A
8-element Array{Int64,1}:
 -1
 -2
 -3
  2
  5
  4
  3
 -1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1392-L1420}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10980093798189218206}{} 
\hyperlink{10980093798189218206}{\texttt{Base.resize!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
resize!(a::Vector, n::Integer) -> Vector
\end{minted}

Resize \texttt{a} to contain \texttt{n} elements. If \texttt{n} is smaller than the current collection length, the first \texttt{n} elements will be retained. If \texttt{n} is larger, the new elements are not guaranteed to be initialized.

\textbf{Examples}


\begin{minted}{jlcon}
julia> resize!([6, 5, 4, 3, 2, 1], 3)
3-element Array{Int64,1}:
 6
 5
 4

julia> a = resize!([6, 5, 4, 3, 2, 1], 8);

julia> length(a)
8

julia> a[1:6]
6-element Array{Int64,1}:
 6
 5
 4
 3
 2
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1031-L1060}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2587432243763606566}{} 
\hyperlink{2587432243763606566}{\texttt{Base.append!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
append!(collection, collection2) -> collection.
\end{minted}

For an ordered container \texttt{collection}, add the elements of \texttt{collection2} to the end of it.

\textbf{Examples}


\begin{minted}{jlcon}
julia> append!([1],[2,3])
3-element Array{Int64,1}:
 1
 2
 3

julia> append!([1, 2, 3], [4, 5, 6])
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6
\end{minted}

Use \hyperlink{18026893834387542681}{\texttt{push!}} to add individual items to \texttt{collection} which are not already themselves in another collection. The result of the preceding example is equivalent to \texttt{push!([1, 2, 3], 4, 5, 6)}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L925-L951}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9292529440147652243}{} 
\hyperlink{9292529440147652243}{\texttt{Base.prepend!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
prepend!(a::Vector, items) -> collection
\end{minted}

Insert the elements of \texttt{items} to the beginning of \texttt{a}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> prepend!([3],[1,2])
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L980-L993}{\texttt{source}}


\end{adjustwidth}

以下类型均完全实现了上述函数：



\begin{itemize}
\item \texttt{Vector} (a.k.a. 1-dimensional \hyperlink{15492651498431872487}{\texttt{Array}})


\item \texttt{BitVector} (a.k.a. 1-dimensional \hyperlink{18015155802543401629}{\texttt{BitArray}})

\end{itemize}


\hypertarget{13950347812673143734}{}


\section{集合相关的实用工具}


\hypertarget{14946515604348703614}{} 
\hyperlink{14946515604348703614}{\texttt{Base.Pair}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Pair(x, y)
x => y
\end{minted}

Construct a \texttt{Pair} object with type \texttt{Pair\{typeof(x), typeof(y)\}}. The elements are stored in the fields \texttt{first} and \texttt{second}. They can also be accessed via iteration (but a \texttt{Pair} is treated as a single {\textquotedbl}scalar{\textquotedbl} for broadcasting operations).

See also: \hyperlink{3089397136845322041}{\texttt{Dict}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> p = "foo" => 7
"foo" => 7

julia> typeof(p)
Pair{String,Int64}

julia> p.first
"foo"

julia> for x in p
           println(x)
       end
foo
7
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/pair.jl#L18-L45}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1741207879021199162}{} 
\hyperlink{1741207879021199162}{\texttt{Base.Iterators.Pairs}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Iterators.Pairs(values, keys) <: AbstractDict{eltype(keys), eltype(values)}
\end{minted}

Transforms an indexable container into an Dictionary-view of the same data. Modifying the key-space of the underlying data may invalidate this object.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L160-L165}{\texttt{source}}


\end{adjustwidth}

\hypertarget{2401809609636377775}{}


\chapter{数学相关}



\hypertarget{15714690155437633961}{}


\section{数学运算符}


\hypertarget{8228207173393714756}{} 
\hyperlink{8228207173393714756}{\texttt{Base.:-}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
-(x)
\end{minted}

Unary minus operator.

\textbf{Examples}


\begin{minted}{jlcon}
julia> -1
-1

julia> -(2)
-2

julia> -[1 2; 3 4]
2×2 Array{Int64,2}:
 -1  -2
 -3  -4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1956-L1974}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3677358729494553841}{} 
\hyperlink{3677358729494553841}{\texttt{Base.:+}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dt::Date + t::Time -> DateTime
\end{minted}

The addition of a \texttt{Date} with a \texttt{Time} produces a \texttt{DateTime}. The hour, minute, second, and millisecond parts of the \texttt{Time} are used along with the year, month, and day of the \texttt{Date} to create the new \texttt{DateTime}. Non-zero microseconds or nanoseconds in the \texttt{Time} type will result in an \texttt{InexactError} being thrown.




\begin{lstlisting}
+(x, y...)
\end{lstlisting}

Addition operator. \texttt{x+y+z+...} calls this function with all arguments, i.e. \texttt{+(x, y, z, ...)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 1 + 20 + 4
25

julia> +(1, 20, 4)
25
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1940-L1953}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11135345846828585592}{} 
\hyperlink{11135345846828585592}{\texttt{Base.:-}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
-(x, y)
\end{minted}

Subtraction operator.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 2 - 3
-1

julia> -(2, 4.5)
-2.5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1977-L1990}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7592762607639177347}{} 
\hyperlink{7592762607639177347}{\texttt{Base.:*}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
*(x, y...)
\end{minted}

Multiplication operator. \texttt{x*y*z*...} calls this function with all arguments, i.e. \texttt{*(x, y, z, ...)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 2 * 7 * 8
112

julia> *(2, 7, 8)
112
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1993-L2006}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4103478871488785445}{} 
\hyperlink{4103478871488785445}{\texttt{Base.:/}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
/(x, y)
\end{minted}

Right division operator: multiplication of \texttt{x} by the inverse of \texttt{y} on the right. Gives floating-point results for integer arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 1/2
0.5

julia> 4/2
2.0

julia> 4.5/2
2.25
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2009-L2026}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4639577998029770435}{} 
\hyperlink{4639577998029770435}{\texttt{Base.:{\textbackslash}}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
\(x, y)
\end{minted}

Left division operator: multiplication of \texttt{y} by the inverse of \texttt{x} on the left. Gives floating-point results for integer arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 3 \ 6
2.0

julia> inv(3) * 6
2.0

julia> A = [4 3; 2 1]; x = [5, 6];

julia> A \ x
2-element Array{Float64,1}:
  6.5
 -7.0

julia> inv(A) * x
2-element Array{Float64,1}:
  6.5
 -7.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L536-L562}{\texttt{source}}


\end{adjustwidth}
\hypertarget{462277561264792021}{} 
\hyperlink{462277561264792021}{\texttt{Base.:{\textasciicircum}}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
^(x, y)
\end{minted}

Exponentiation operator. If \texttt{x} is a matrix, computes matrix exponentiation.

If \texttt{y} is an \texttt{Int} literal (e.g. \texttt{2} in \texttt{x{\textasciicircum}2} or \texttt{-3} in \texttt{x{\textasciicircum}-3}), the Julia code \texttt{x{\textasciicircum}y} is transformed by the compiler to \texttt{Base.literal\_pow({\textasciicircum}, x, Val(y))}, to enable compile-time specialization on the value of the exponent. (As a default fallback we have \texttt{Base.literal\_pow({\textasciicircum}, x, Val(y)) = {\textasciicircum}(x,y)}, where usually \texttt{{\textasciicircum} == Base.{\textasciicircum}} unless \texttt{{\textasciicircum}} has been defined in the calling namespace.)


\begin{minted}{jlcon}
julia> 3^5
243

julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> A^3
2×2 Array{Int64,2}:
 37   54
 81  118
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/promotion.jl#L316-L342}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17935587874085983500}{} 
\hyperlink{17935587874085983500}{\texttt{Base.fma}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fma(x, y, z)
\end{minted}

Computes \texttt{x*y+z} without rounding the intermediate result \texttt{x*y}. On some systems this is significantly more expensive than \texttt{x*y+z}. \texttt{fma} is used to improve accuracy in certain algorithms. See \hyperlink{7153024527713262493}{\texttt{muladd}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/floatfuncs.jl#L295-L301}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7153024527713262493}{} 
\hyperlink{7153024527713262493}{\texttt{Base.muladd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
muladd(x, y, z)
\end{minted}

Combined multiply-add: computes \texttt{x*y+z}, but allowing the add and multiply to be merged with each other or with surrounding operations for performance. For example, this may be implemented as an \hyperlink{17935587874085983500}{\texttt{fma}} if the hardware supports it efficiently. The result can be different on different machines and can also be different on the same machine due to constant propagation or other optimizations. See \hyperlink{17935587874085983500}{\texttt{fma}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> muladd(3, 2, 1)
7

julia> 3 * 2 + 1
7
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L1087-L1106}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13336866048543706848}{} 
\hyperlink{13336866048543706848}{\texttt{Base.inv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
inv(x)
\end{minted}

Return the multiplicative inverse of \texttt{x}, such that \texttt{x*inv(x)} or \texttt{inv(x)*x} yields \hyperlink{11395333326208453101}{\texttt{one(x)}} (the multiplicative identity) up to roundoff errors.

If \texttt{x} is a number, this is essentially the same as \texttt{one(x)/x}, but for some types \texttt{inv(x)} may be slightly more efficient.

\textbf{Examples}


\begin{minted}{jlcon}
julia> inv(2)
0.5

julia> inv(1 + 2im)
0.2 - 0.4im

julia> inv(1 + 2im) * (1 + 2im)
1.0 + 0.0im

julia> inv(2//3)
3//2
\end{minted}

\begin{quote}
\textbf{Julia 1.2}

\texttt{inv(::Missing)} requires at least Julia 1.2.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L172-L198}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8020976424566491334}{} 
\hyperlink{8020976424566491334}{\texttt{Base.div}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
div(x, y)
÷(x, y)
\end{minted}

The quotient from Euclidean division. Computes \texttt{x/y}, truncated to an integer.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 9 ÷ 4
2

julia> -5 ÷ 3
-1

julia> 5.0 ÷ 2
2.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L708-L725}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15067916827074788527}{} 
\hyperlink{15067916827074788527}{\texttt{Base.fld}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fld(x, y)
\end{minted}

Largest integer less than or equal to \texttt{x/y}. Equivalent to \texttt{div(x, y, RoundDown)}.

See also: \hyperlink{8020976424566491334}{\texttt{div}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> fld(7.3,5.5)
1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/div.jl#L71-L83}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7922388465305816555}{} 
\hyperlink{7922388465305816555}{\texttt{Base.cld}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cld(x, y)
\end{minted}

Smallest integer larger than or equal to \texttt{x/y}. Equivalent to \texttt{div(x, y, RoundUp)}.

See also: \hyperlink{8020976424566491334}{\texttt{div}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> cld(5.5,2.2)
3.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/div.jl#L86-L98}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2082041235715276573}{} 
\hyperlink{2082041235715276573}{\texttt{Base.mod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mod(x::Integer, r::AbstractUnitRange)
\end{minted}

Find \texttt{y} in the range \texttt{r} such that  \(x ≡ y (mod n)\) , where \texttt{n = length(r)}, i.e. \texttt{y = mod(x - first(r), n) + first(r)}.

See also: \hyperlink{13778479217547823795}{\texttt{mod1}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> mod(0, Base.OneTo(3))
3

julia> mod(3, 0:2)
0
\end{minted}

\begin{quote}
\textbf{Julia 1.3}

This method requires at least Julia 1.3.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/range.jl#L1044-L1063}{\texttt{source}}



\begin{lstlisting}
mod(x, y)
rem(x, y, RoundDown)
\end{lstlisting}

The reduction of \texttt{x} modulo \texttt{y}, or equivalently, the remainder of \texttt{x} after floored division by \texttt{y}, i.e. \texttt{x - y*fld(x,y)} if computed without intermediate rounding.

The result will have the same sign as \texttt{y}, and magnitude less than \texttt{abs(y)} (with some exceptions, see note below).

\begin{quote}
\textbf{Note}

When used with floating point values, the exact result may not be representable by the type, and so rounding error may occur. In particular, if the exact result is very close to \texttt{y}, then it may be rounded to \texttt{y}.

\end{quote}

\begin{minted}{jlcon}
julia> mod(8, 3)
2

julia> mod(9, 3)
0

julia> mod(8.9, 3)
2.9000000000000004

julia> mod(eps(), 3)
2.220446049250313e-16

julia> mod(-eps(), 3)
3.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L187-L219}{\texttt{source}}



\begin{lstlisting}
rem(x::Integer, T::Type{<:Integer}) -> T
mod(x::Integer, T::Type{<:Integer}) -> T
%(x::Integer, T::Type{<:Integer}) -> T
\end{lstlisting}

Find \texttt{y::T} such that \texttt{x} ≡ \texttt{y} (mod n), where n is the number of integers representable in \texttt{T}, and \texttt{y} is an integer in \texttt{[typemin(T),typemax(T)]}. If \texttt{T} can represent any integer (e.g. \texttt{T == BigInt}), then this operation corresponds to a conversion to \texttt{T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 129 % Int8
-127
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L460-L475}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3827563084771191385}{} 
\hyperlink{3827563084771191385}{\texttt{Base.rem}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rem(x, y)
%(x, y)
\end{minted}

Remainder from Euclidean division, returning a value of the same sign as \texttt{x}, and smaller in magnitude than \texttt{y}. This value is always exact.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = 15; y = 4;

julia> x % y
3

julia> x == div(x, y) * y + rem(x, y)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L687-L704}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7552737171387915272}{} 
\hyperlink{7552737171387915272}{\texttt{Base.Math.rem2pi}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rem2pi(x, r::RoundingMode)
\end{minted}

Compute the remainder of \texttt{x} after integer division by \texttt{2π}, with the quotient rounded according to the rounding mode \texttt{r}. In other words, the quantity


\begin{lstlisting}
x - 2π*round(x/(2π),r)
\end{lstlisting}

without any intermediate rounding. This internally uses a high precision approximation of 2π, and so will give a more accurate result than \texttt{rem(x,2π,r)}

\begin{itemize}
\item if \texttt{r == RoundNearest}, then the result is in the interval  \([-π, π]\) . This will generally be the most accurate result. See also \hyperlink{868115654703135309}{\texttt{RoundNearest}}.


\item if \texttt{r == RoundToZero}, then the result is in the interval  \([0, 2π]\)  if \texttt{x} is positive,. or  \([-2π, 0]\)  otherwise. See also \hyperlink{7760059079134067537}{\texttt{RoundToZero}}.


\item if \texttt{r == RoundDown}, then the result is in the interval  \([0, 2π]\) . See also \hyperlink{3648739763580508258}{\texttt{RoundDown}}.


\item if \texttt{r == RoundUp}, then the result is in the interval  \([-2π, 0]\) . See also \hyperlink{874246484265932239}{\texttt{RoundUp}}.

\end{itemize}
\textbf{Examples}


\begin{minted}{jlcon}
julia> rem2pi(7pi/4, RoundNearest)
-0.7853981633974485

julia> rem2pi(7pi/4, RoundDown)
5.497787143782138
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L914-L944}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15322754370885673769}{} 
\hyperlink{15322754370885673769}{\texttt{Base.Math.mod2pi}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mod2pi(x)
\end{minted}

Modulus after division by \texttt{2π}, returning in the range  \([0,2π)\) .

This function computes a floating point representation of the modulus after division by numerically exact \texttt{2π}, and is therefore not exactly the same as \texttt{mod(x,2π)}, which would compute the modulus of \texttt{x} relative to division by the floating-point number \texttt{2π}.

\begin{quote}
\textbf{Note}

Depending on the format of the input value, the closest representable value to 2π may be less than 2π. For example, the expression \texttt{mod2pi(2π)} will not return \texttt{0}, because the intermediate value of \texttt{2*π} is a \texttt{Float64} and \texttt{2*Float64(π) < 2*big(π)}. See \hyperlink{7552737171387915272}{\texttt{rem2pi}} for more refined control of this behavior.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> mod2pi(9*pi/4)
0.7853981633974481
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L1062-L1082}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6106909621813654214}{} 
\hyperlink{6106909621813654214}{\texttt{Base.divrem}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
divrem(x, y, r::RoundingMode=RoundToZero)
\end{minted}

The quotient and remainder from Euclidean division. Equivalent to \texttt{(div(x,y,r), rem(x,y,r))}. Equivalently, with the the default value of \texttt{r}, this call is equivalent to \texttt{(x÷y, x\%y)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> divrem(3,7)
(0, 3)

julia> divrem(7,3)
(2, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/div.jl#L102-L117}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2806360720034558325}{} 
\hyperlink{2806360720034558325}{\texttt{Base.fldmod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fldmod(x, y)
\end{minted}

The floored quotient and modulus after division. A convenience wrapper for \texttt{divrem(x, y, RoundDown)}. Equivalent to \texttt{(fld(x,y), mod(x,y))}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/div.jl#L179-L184}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2046682076337602867}{} 
\hyperlink{2046682076337602867}{\texttt{Base.fld1}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fld1(x, y)
\end{minted}

Flooring division, returning a value consistent with \texttt{mod1(x,y)}

See also: \hyperlink{13778479217547823795}{\texttt{mod1}}, \hyperlink{3908876301745770865}{\texttt{fldmod1}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = 15; y = 4;

julia> fld1(x, y)
4

julia> x == fld(x, y) * y + mod(x, y)
true

julia> x == (fld1(x, y) - 1) * y + mod1(x, y)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L749-L769}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13778479217547823795}{} 
\hyperlink{13778479217547823795}{\texttt{Base.mod1}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mod1(x, y)
\end{minted}

Modulus after flooring division, returning a value \texttt{r} such that \texttt{mod(r, y) == mod(x, y)} in the range  \((0, y]\)  for positive \texttt{y} and in the range  \([y,0)\)  for negative \texttt{y}.

See also: \hyperlink{2046682076337602867}{\texttt{fld1}}, \hyperlink{3908876301745770865}{\texttt{fldmod1}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> mod1(4, 2)
2

julia> mod1(4, 3)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L729-L745}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3908876301745770865}{} 
\hyperlink{3908876301745770865}{\texttt{Base.fldmod1}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fldmod1(x, y)
\end{minted}

Return \texttt{(fld1(x,y), mod1(x,y))}.

See also: \hyperlink{2046682076337602867}{\texttt{fld1}}, \hyperlink{13778479217547823795}{\texttt{mod1}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L776-L782}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17539582191808611917}{} 
\hyperlink{17539582191808611917}{\texttt{Base.://}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
//(num, den)
\end{minted}

Divide two integers or rational numbers, giving a \hyperlink{8304566144531167610}{\texttt{Rational}} result.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 3 // 5
3//5

julia> (3 // 5) // (2 // 1)
3//10
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rational.jl#L36-L49}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6368672003928643787}{} 
\hyperlink{6368672003928643787}{\texttt{Base.rationalize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rationalize([T<:Integer=Int,] x; tol::Real=eps(x))
\end{minted}

Approximate floating point number \texttt{x} as a \hyperlink{8304566144531167610}{\texttt{Rational}} number with components of the given integer type. The result will differ from \texttt{x} by no more than \texttt{tol}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rationalize(5.6)
28//5

julia> a = rationalize(BigInt, 10.3)
103//10

julia> typeof(numerator(a))
BigInt
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rational.jl#L121-L138}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7885506453580572157}{} 
\hyperlink{7885506453580572157}{\texttt{Base.numerator}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
numerator(x)
\end{minted}

Numerator of the rational representation of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> numerator(2//3)
2

julia> numerator(4)
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rational.jl#L201-L214}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12407209279719593434}{} 
\hyperlink{12407209279719593434}{\texttt{Base.denominator}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
denominator(x)
\end{minted}

Denominator of the rational representation of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> denominator(2//3)
3

julia> denominator(4)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rational.jl#L218-L231}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2724916807067930829}{} 
\hyperlink{2724916807067930829}{\texttt{Base.:<<}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
<<(x, n)
\end{minted}

Left bit shift operator, \texttt{x << n}. For \texttt{n >= 0}, the result is \texttt{x} shifted left by \texttt{n} bits, filling with \texttt{0}s. This is equivalent to \texttt{x * 2{\textasciicircum}n}. For \texttt{n < 0}, this is equivalent to \texttt{x >> -n}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Int8(3) << 2
12

julia> bitstring(Int8(3))
"00000011"

julia> bitstring(Int8(12))
"00001100"
\end{minted}

See also \hyperlink{6883264745383491304}{\texttt{>>}}, \hyperlink{16613216773443333487}{\texttt{>>>}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L569-L588}{\texttt{source}}



\begin{lstlisting}
<<(B::BitVector, n) -> BitVector
\end{lstlisting}

Left bit shift operator, \texttt{B << n}. For \texttt{n >= 0}, the result is \texttt{B} with elements shifted \texttt{n} positions backwards, filling with \texttt{false} values. If \texttt{n < 0}, elements are shifted forwards. Equivalent to \texttt{B >> -n}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> B = BitVector([true, false, true, false, false])
5-element BitArray{1}:
 1
 0
 1
 0
 0

julia> B << 1
5-element BitArray{1}:
 0
 1
 0
 0
 0

julia> B << -1
5-element BitArray{1}:
 0
 1
 0
 1
 0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/bitarray.jl#L1311-L1345}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6883264745383491304}{} 
\hyperlink{6883264745383491304}{\texttt{Base.:>>}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
>>(x, n)
\end{minted}

Right bit shift operator, \texttt{x >> n}. For \texttt{n >= 0}, the result is \texttt{x} shifted right by \texttt{n} bits, where \texttt{n >= 0}, filling with \texttt{0}s if \texttt{x >= 0}, \texttt{1}s if \texttt{x < 0}, preserving the sign of \texttt{x}. This is equivalent to \texttt{fld(x, 2{\textasciicircum}n)}. For \texttt{n < 0}, this is equivalent to \texttt{x << -n}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Int8(13) >> 2
3

julia> bitstring(Int8(13))
"00001101"

julia> bitstring(Int8(3))
"00000011"

julia> Int8(-14) >> 2
-4

julia> bitstring(Int8(-14))
"11110010"

julia> bitstring(Int8(-4))
"11111100"
\end{minted}

See also \hyperlink{16613216773443333487}{\texttt{>>>}}, \hyperlink{2724916807067930829}{\texttt{<<}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L604-L633}{\texttt{source}}



\begin{lstlisting}
>>(B::BitVector, n) -> BitVector
\end{lstlisting}

Right bit shift operator, \texttt{B >> n}. For \texttt{n >= 0}, the result is \texttt{B} with elements shifted \texttt{n} positions forward, filling with \texttt{false} values. If \texttt{n < 0}, elements are shifted backwards. Equivalent to \texttt{B << -n}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> B = BitVector([true, false, true, false, false])
5-element BitArray{1}:
 1
 0
 1
 0
 0

julia> B >> 1
5-element BitArray{1}:
 0
 1
 0
 1
 0

julia> B >> -1
5-element BitArray{1}:
 0
 1
 0
 0
 0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/bitarray.jl#L1273-L1307}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16613216773443333487}{} 
\hyperlink{16613216773443333487}{\texttt{Base.:>>>}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
>>>(x, n)
\end{minted}

Unsigned right bit shift operator, \texttt{x >>> n}. For \texttt{n >= 0}, the result is \texttt{x} shifted right by \texttt{n} bits, where \texttt{n >= 0}, filling with \texttt{0}s. For \texttt{n < 0}, this is equivalent to \texttt{x << -n}.

For \hyperlink{4780971278803506664}{\texttt{Unsigned}} integer types, this is equivalent to \hyperlink{6883264745383491304}{\texttt{>>}}. For \hyperlink{14154866400772377486}{\texttt{Signed}} integer types, this is equivalent to \texttt{signed(unsigned(x) >> n)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Int8(-14) >>> 2
60

julia> bitstring(Int8(-14))
"11110010"

julia> bitstring(Int8(60))
"00111100"
\end{minted}

\hyperlink{423405808990690832}{\texttt{BigInt}}s are treated as if having infinite size, so no filling is required and this is equivalent to \hyperlink{6883264745383491304}{\texttt{>>}}.

See also \hyperlink{6883264745383491304}{\texttt{>>}}, \hyperlink{2724916807067930829}{\texttt{<<}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L645-L671}{\texttt{source}}



\begin{lstlisting}
>>>(B::BitVector, n) -> BitVector
\end{lstlisting}

Unsigned right bitshift operator, \texttt{B >>> n}. Equivalent to \texttt{B >> n}. See \hyperlink{6883264745383491304}{\texttt{>>}} for details and examples.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/bitarray.jl#L1348-L1353}{\texttt{source}}


\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Base.bitrotate}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{1027906901078185239}{} 
\hyperlink{1027906901078185239}{\texttt{Base.::}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
(:)(I::CartesianIndex, J::CartesianIndex)
\end{minted}

Construct \hyperlink{16831958174907250244}{\texttt{CartesianIndices}} from two \texttt{CartesianIndex}.

\begin{quote}
\textbf{Julia 1.1}

This method requires at least Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> I = CartesianIndex(2,1);

julia> J = CartesianIndex(3,3);

julia> I:J
2×3 CartesianIndices{2,Tuple{UnitRange{Int64},UnitRange{Int64}}}:
 CartesianIndex(2, 1)  CartesianIndex(2, 2)  CartesianIndex(2, 3)
 CartesianIndex(3, 1)  CartesianIndex(3, 2)  CartesianIndex(3, 3)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L264-L283}{\texttt{source}}



\begin{lstlisting}
(:)(start, [step], stop)
\end{lstlisting}

Range operator. \texttt{a:b} constructs a range from \texttt{a} to \texttt{b} with a step size of 1 (a \hyperlink{9165955949298153694}{\texttt{UnitRange}}) , and \texttt{a:s:b} is similar but uses a step size of \texttt{s} (a \hyperlink{11698840710736817669}{\texttt{StepRange}}).

\texttt{:} is also used in indexing to select whole dimensions  and for \hyperlink{18332791376992528422}{\texttt{Symbol}} literals, as in e.g. \texttt{:hello}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/range.jl#L31-L39}{\texttt{source}}


\end{adjustwidth}
\hypertarget{737600656772861535}{} 
\hyperlink{737600656772861535}{\texttt{Base.range}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
range(start[, stop]; length, stop, step=1)
\end{minted}

Given a starting value, construct a range either by length or from \texttt{start} to \texttt{stop}, optionally with a given step (defaults to 1, a \hyperlink{9165955949298153694}{\texttt{UnitRange}}). One of \texttt{length} or \texttt{stop} is required.  If \texttt{length}, \texttt{stop}, and \texttt{step} are all specified, they must agree.

If \texttt{length} and \texttt{stop} are provided and \texttt{step} is not, the step size will be computed automatically such that there are \texttt{length} linearly spaced elements in the range (a \hyperlink{5701362841495158413}{\texttt{LinRange}}).

If \texttt{step} and \texttt{stop} are provided and \texttt{length} is not, the overall range length will be computed automatically such that the elements are \texttt{step} spaced (a \hyperlink{11698840710736817669}{\texttt{StepRange}}).

\texttt{stop} may be specified as either a positional or keyword argument.

\begin{quote}
\textbf{Julia 1.1}

\texttt{stop} as a positional argument requires at least Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> range(1, length=100)
1:100

julia> range(1, stop=100)
1:100

julia> range(1, step=5, length=100)
1:5:496

julia> range(1, step=5, stop=100)
1:5:96

julia> range(1, 10, length=101)
1.0:0.09:10.0

julia> range(1, 100, step=5)
1:5:96
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/range.jl#L49-L87}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7189994599038205424}{} 
\hyperlink{7189994599038205424}{\texttt{Base.OneTo}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.OneTo(n)
\end{minted}

Define an \texttt{AbstractUnitRange} that behaves like \texttt{1:n}, with the added distinction that the lower limit is guaranteed (by the type system) to be 1.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/range.jl#L302-L308}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6593444000385137506}{} 
\hyperlink{6593444000385137506}{\texttt{Base.StepRangeLen}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
StepRangeLen{T,R,S}(ref::R, step::S, len, [offset=1]) where {T,R,S}
StepRangeLen(       ref::R, step::S, len, [offset=1]) where {  R,S}
\end{minted}

A range \texttt{r} where \texttt{r[i]} produces values of type \texttt{T} (in the second form, \texttt{T} is deduced automatically), parameterized by a \texttt{ref}erence value, a \texttt{step}, and the \texttt{len}gth. By default \texttt{ref} is the starting value \texttt{r[1]}, but alternatively you can supply it as the value of \texttt{r[offset]} for some other index \texttt{1 <= offset <= len}. In conjunction with \texttt{TwicePrecision} this can be used to implement ranges that are free of roundoff error.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/range.jl#L325-L336}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15143149452920304570}{} 
\hyperlink{15143149452920304570}{\texttt{Base.:==}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
==(x, y)
\end{minted}

Generic equality operator. Falls back to \hyperlink{7974744969331231272}{\texttt{===}}. Should be implemented for all types with a notion of equality, based on the abstract value that an instance represents. For example, all numeric types are compared by numeric value, ignoring type. Strings are compared as sequences of characters, ignoring encoding. For collections, \texttt{==} is generally called recursively on all contents, though other properties (like the shape for arrays) may also be taken into account.

This operator follows IEEE semantics for floating-point numbers: \texttt{0.0 == -0.0} and \texttt{NaN != NaN}.

The result is of type \texttt{Bool}, except when one of the operands is \hyperlink{14596725676261444434}{\texttt{missing}}, in which case \texttt{missing} is returned (\href{https://en.wikipedia.org/wiki/Three-valued\_logic}{three-valued logic}). For collections, \texttt{missing} is returned if at least one of the operands contains a \texttt{missing} value and all non-missing values are equal. Use \hyperlink{269533589463185031}{\texttt{isequal}} or \hyperlink{7974744969331231272}{\texttt{===}} to always get a \texttt{Bool} result.

\textbf{Implementation}

New numeric types should implement this function for two arguments of the new type, and handle comparison to other types via promotion rules where possible.

\hyperlink{269533589463185031}{\texttt{isequal}} falls back to \texttt{==}, so new methods of \texttt{==} will be used by the \hyperlink{3089397136845322041}{\texttt{Dict}} type to compare keys. If your type will be used as a dictionary key, it should therefore also implement \hyperlink{13797072367283572032}{\texttt{hash}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L55-L82}{\texttt{source}}



\begin{lstlisting}
==(x)
\end{lstlisting}

Create a function that compares its argument to \texttt{x} using \hyperlink{15143149452920304570}{\texttt{==}}, i.e. a function equivalent to \texttt{y -> y == x}.

The returned function is of type \texttt{Base.Fix2\{typeof(==)\}}, which can be used to implement specialized methods.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L927-L935}{\texttt{source}}



\begin{minted}{julia}
==(a::AbstractString, b::AbstractString) -> Bool
\end{minted}

Test whether two strings are equal character by character (technically, Unicode code point by code point).

\textbf{Examples}


\begin{minted}{jlcon}
julia> "abc" == "abc"
true

julia> "abc" == "αβγ"
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L280-L294}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3046079188653285114}{} 
\hyperlink{3046079188653285114}{\texttt{Base.:!=}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
!=(x, y)
≠(x,y)
\end{minted}

Not-equals comparison operator. Always gives the opposite answer as \hyperlink{15143149452920304570}{\texttt{==}}.

\textbf{Implementation}

New types should generally not implement this, and rely on the fallback definition \texttt{!=(x,y) = !(x==y)} instead.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 3 != 2
true

julia> "foo" ≠ "foo"
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L174-L192}{\texttt{source}}



\begin{lstlisting}
!=(x)
\end{lstlisting}

Create a function that compares its argument to \texttt{x} using \hyperlink{3046079188653285114}{\texttt{!=}}, i.e. a function equivalent to \texttt{y -> y != x}. The returned function is of type \texttt{Base.Fix2\{typeof(!=)\}}, which can be used to implement specialized methods.

\begin{quote}
\textbf{Julia 1.2}

This functionality requires at least Julia 1.2.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L938-L948}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3509174727635606109}{} 
\hyperlink{3509174727635606109}{\texttt{Base.:!==}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
!==(x, y)
≢(x,y)
\end{minted}

Always gives the opposite answer as \hyperlink{7974744969331231272}{\texttt{===}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1, 2]; b = [1, 2];

julia> a ≢ b
true

julia> a ≢ a
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L223-L239}{\texttt{source}}


\end{adjustwidth}
\hypertarget{702782232449268329}{} 
\hyperlink{702782232449268329}{\texttt{Base.:<}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
<(x, y)
\end{minted}

Less-than comparison operator. Falls back to \hyperlink{8062916604071842790}{\texttt{isless}}. Because of the behavior of floating-point NaN values, this operator implements a partial order.

\textbf{Implementation}

New numeric types with a canonical partial order should implement this function for two arguments of the new type. Types with a canonical total order should implement \hyperlink{8062916604071842790}{\texttt{isless}} instead. (x < y) | (x == y)

\textbf{Examples}


\begin{minted}{jlcon}
julia> 'a' < 'b'
true

julia> "abc" < "abd"
true

julia> 5 < 3
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L243-L267}{\texttt{source}}



\begin{lstlisting}
<(x)
\end{lstlisting}

Create a function that compares its argument to \texttt{x} using \hyperlink{702782232449268329}{\texttt{<}}, i.e. a function equivalent to \texttt{y -> y < x}. The returned function is of type \texttt{Base.Fix2\{typeof(<)\}}, which can be used to implement specialized methods.

\begin{quote}
\textbf{Julia 1.2}

This functionality requires at least Julia 1.2.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L990-L1000}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11411050964021316526}{} 
\hyperlink{11411050964021316526}{\texttt{Base.:<=}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
<=(x, y)
≤(x,y)
\end{minted}

Less-than-or-equals comparison operator. Falls back to \texttt{(x < y) | (x == y)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 'a' <= 'b'
true

julia> 7 ≤ 7 ≤ 9
true

julia> "abc" ≤ "abc"
true

julia> 5 <= 3
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L296-L316}{\texttt{source}}



\begin{lstlisting}
<=(x)
\end{lstlisting}

Create a function that compares its argument to \texttt{x} using \hyperlink{11411050964021316526}{\texttt{<=}}, i.e. a function equivalent to \texttt{y -> y <= x}. The returned function is of type \texttt{Base.Fix2\{typeof(<=)\}}, which can be used to implement specialized methods.

\begin{quote}
\textbf{Julia 1.2}

This functionality requires at least Julia 1.2.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L964-L974}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8677991761303191103}{} 
\hyperlink{8677991761303191103}{\texttt{Base.:>}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
>(x, y)
\end{minted}

Greater-than comparison operator. Falls back to \texttt{y < x}.

\textbf{Implementation}

Generally, new types should implement \hyperlink{702782232449268329}{\texttt{<}} instead of this function, and rely on the fallback definition \texttt{>(x, y) = y < x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 'a' > 'b'
false

julia> 7 > 3 > 1
true

julia> "abc" > "abd"
false

julia> 5 > 3
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L270-L293}{\texttt{source}}



\begin{lstlisting}
>(x)
\end{lstlisting}

Create a function that compares its argument to \texttt{x} using \hyperlink{8677991761303191103}{\texttt{>}}, i.e. a function equivalent to \texttt{y -> y > x}. The returned function is of type \texttt{Base.Fix2\{typeof(>)\}}, which can be used to implement specialized methods.

\begin{quote}
\textbf{Julia 1.2}

This functionality requires at least Julia 1.2.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L977-L987}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7019639580556993898}{} 
\hyperlink{7019639580556993898}{\texttt{Base.:>=}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
>=(x, y)
≥(x,y)
\end{minted}

Greater-than-or-equals comparison operator. Falls back to \texttt{y <= x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 'a' >= 'b'
false

julia> 7 ≥ 7 ≥ 3
true

julia> "abc" ≥ "abc"
true

julia> 5 >= 3
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L320-L340}{\texttt{source}}



\begin{lstlisting}
>=(x)
\end{lstlisting}

Create a function that compares its argument to \texttt{x} using \hyperlink{7019639580556993898}{\texttt{>=}}, i.e. a function equivalent to \texttt{y -> y >= x}. The returned function is of type \texttt{Base.Fix2\{typeof(>=)\}}, which can be used to implement specialized methods.

\begin{quote}
\textbf{Julia 1.2}

This functionality requires at least Julia 1.2.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L951-L961}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8951185024259053949}{} 
\hyperlink{8951185024259053949}{\texttt{Base.cmp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cmp(x,y)
\end{minted}

Return -1, 0, or 1 depending on whether \texttt{x} is less than, equal to, or greater than \texttt{y}, respectively. Uses the total order implemented by \texttt{isless}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> cmp(1, 2)
-1

julia> cmp(2, 1)
1

julia> cmp(2+im, 3-im)
ERROR: MethodError: no method matching isless(::Complex{Int64}, ::Complex{Int64})
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L364-L382}{\texttt{source}}



\begin{lstlisting}
cmp(<, x, y)
\end{lstlisting}

Return -1, 0, or 1 depending on whether \texttt{x} is less than, equal to, or greater than \texttt{y}, respectively. The first argument specifies a less-than comparison function to use.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L385-L390}{\texttt{source}}



\begin{minted}{julia}
cmp(a::AbstractString, b::AbstractString) -> Int
\end{minted}

Compare two strings. Return \texttt{0} if both strings have the same length and the character at each index is the same in both strings. Return \texttt{-1} if \texttt{a} is a prefix of \texttt{b}, or if \texttt{a} comes before \texttt{b} in alphabetical order. Return \texttt{1} if \texttt{b} is a prefix of \texttt{a}, or if \texttt{b} comes before \texttt{a} in alphabetical order (technically, lexicographical order by Unicode code points).

\textbf{Examples}


\begin{minted}{jlcon}
julia> cmp("abc", "abc")
0

julia> cmp("ab", "abc")
-1

julia> cmp("abc", "ab")
1

julia> cmp("ab", "ac")
-1

julia> cmp("ac", "ab")
1

julia> cmp("α", "a")
1

julia> cmp("b", "β")
-1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L237-L269}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2433030275488323500}{} 
\hyperlink{2433030275488323500}{\texttt{Base.:{\textasciitilde}}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
~(x)
\end{minted}

Bitwise not.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ~4
-5

julia> ~10
-11

julia> ~true
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L237-L253}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1494761116451616317}{} 
\hyperlink{1494761116451616317}{\texttt{Base.:\&}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
&(x, y)
\end{minted}

Bitwise and. Implements \href{https://en.wikipedia.org/wiki/Three-valued\_logic}{three-valued logic}, returning \hyperlink{14596725676261444434}{\texttt{missing}} if one operand is \texttt{missing} and the other is \texttt{true}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 4 & 10
0

julia> 4 & 12
4

julia> true & missing
missing

julia> false & missing
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L256-L276}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9633687763646488853}{} 
\hyperlink{9633687763646488853}{\texttt{Base.:|}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
|(x, y)
\end{minted}

Bitwise or. Implements \href{https://en.wikipedia.org/wiki/Three-valued\_logic}{three-valued logic}, returning \hyperlink{14596725676261444434}{\texttt{missing}} if one operand is \texttt{missing} and the other is \texttt{false}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 4 | 10
14

julia> 4 | 1
5

julia> true | missing
true

julia> false | missing
missing
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L279-L299}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7071880015536674935}{} 
\hyperlink{7071880015536674935}{\texttt{Base.xor}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}[escapeinside=\#\%]{julia}
xor(x, y)
#\unicodeveebar%(x, y)
\end{minted}

Bitwise exclusive or of \texttt{x} and \texttt{y}. Implements \href{https://en.wikipedia.org/wiki/Three-valued\_logic}{three-valued logic}, returning \hyperlink{14596725676261444434}{\texttt{missing}} if one of the arguments is \texttt{missing}.

The infix operation \texttt{a \unicodeveebar{} b} is a synonym for \texttt{xor(a,b)}, and \texttt{\unicodeveebar{}} can be typed by tab-completing \texttt{{\textbackslash}xor} or \texttt{{\textbackslash}veebar} in the Julia REPL.

\textbf{Examples}


\begin{minted}[escapeinside=\#\%]{jlcon}
julia> xor(true, false)
true

julia> xor(true, true)
false

julia> xor(true, missing)
missing

julia> false #\unicodeveebar% false
false

julia> [true; true; false] .#\unicodeveebar% [true; false; false]
3-element BitArray{1}:
 0
 1
 0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/bool.jl#L43-L74}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4329035214952292986}{} 
\hyperlink{4329035214952292986}{\texttt{Base.:!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
!(x)
\end{minted}

Boolean not. Implements \href{https://en.wikipedia.org/wiki/Three-valued\_logic}{three-valued logic}, returning \hyperlink{14596725676261444434}{\texttt{missing}} if \texttt{x} is \texttt{missing}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> !true
false

julia> !false
true

julia> !missing
missing

julia> .![true false true]
1×3 BitArray{2}:
 0  1  0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/bool.jl#L11-L32}{\texttt{source}}



\begin{lstlisting}
!f::Function
\end{lstlisting}

Predicate function negation: when the argument of \texttt{!} is a function, it returns a function which computes the boolean negation of \texttt{f}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> str = "∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |f(x)-f(y)| < ε"
"∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |f(x)-f(y)| < ε"

julia> filter(isletter, str)
"εδxyδfxfyε"

julia> filter(!isletter, str)
"∀  > 0, ∃  > 0: |-| <  ⇒ |()-()| < "
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L862-L879}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4714012140247170866}{} 
\hyperlink{4714012140247170866}{\texttt{\&\&}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
x && y
\end{minted}

Short-circuiting boolean AND.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L835-L839}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2053797086840563251}{} 
\hyperlink{2053797086840563251}{\texttt{||}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
x || y
\end{minted}

Short-circuiting boolean OR.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L842-L846}{\texttt{source}}


\end{adjustwidth}

\hypertarget{5496173814433638888}{}


\section{数学函数}


\hypertarget{12499503887608197213}{} 
\hyperlink{12499503887608197213}{\texttt{Base.isapprox}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isapprox(x, y; rtol::Real=atol>0 ? 0 : √eps, atol::Real=0, nans::Bool=false, norm::Function)
\end{minted}

Inexact equality comparison: \texttt{true} if \texttt{norm(x-y) <= max(atol, rtol*max(norm(x), norm(y)))}. The default \texttt{atol} is zero and the default \texttt{rtol} depends on the types of \texttt{x} and \texttt{y}. The keyword argument \texttt{nans} determines whether or not NaN values are considered equal (defaults to false).

For real or complex floating-point values, if an \texttt{atol > 0} is not specified, \texttt{rtol} defaults to the square root of \hyperlink{4594213520310841636}{\texttt{eps}} of the type of \texttt{x} or \texttt{y}, whichever is bigger (least precise). This corresponds to requiring equality of about half of the significand digits. Otherwise, e.g. for integer arguments or if an \texttt{atol > 0} is supplied, \texttt{rtol} defaults to zero.

\texttt{x} and \texttt{y} may also be arrays of numbers, in which case \texttt{norm} defaults to the usual \texttt{norm} function in LinearAlgebra, but may be changed by passing a \texttt{norm::Function} keyword argument. (For numbers, \texttt{norm} is the same thing as \texttt{abs}.) When \texttt{x} and \texttt{y} are arrays, if \texttt{norm(x-y)} is not finite (i.e. \texttt{±Inf} or \texttt{NaN}), the comparison falls back to checking whether all elements of \texttt{x} and \texttt{y} are approximately equal component-wise.

The binary operator \texttt{≈} is equivalent to \texttt{isapprox} with the default arguments, and \texttt{x ≉ y} is equivalent to \texttt{!isapprox(x,y)}.

Note that \texttt{x ≈ 0} (i.e., comparing to zero with the default tolerances) is equivalent to \texttt{x == 0} since the default \texttt{atol} is \texttt{0}.  In such cases, you should either supply an appropriate \texttt{atol} (or use \texttt{norm(x) ≤ atol}) or rearrange your code (e.g. use \texttt{x ≈ y} rather than \texttt{x - y ≈ 0}).   It is not possible to pick a nonzero \texttt{atol} automatically because it depends on the overall scaling (the {\textquotedbl}units{\textquotedbl}) of your problem: for example, in \texttt{x - y ≈ 0}, \texttt{atol=1e-9} is an absurdly small tolerance if \texttt{x} is the \href{https://en.wikipedia.org/wiki/Earth\_radius}{radius of the Earth} in meters, but an absurdly large tolerance if \texttt{x} is the \href{https://en.wikipedia.org/wiki/Bohr\_radius}{radius of a Hydrogen atom} in meters.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 0.1 ≈ (0.1 - 1e-10)
true

julia> isapprox(10, 11; atol = 2)
true

julia> isapprox([10.0^9, 1.0], [10.0^9, 2.0])
true

julia> 1e-10 ≈ 0
false

julia> isapprox(1e-10, 0, atol=1e-8)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/floatfuncs.jl#L222-L272}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10540279982054240733}{} 
\hyperlink{10540279982054240733}{\texttt{Base.sin}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sin(x)
\end{minted}

Compute sine of \texttt{x}, where \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L407-L411}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10355926621556840804}{} 
\hyperlink{10355926621556840804}{\texttt{Base.cos}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cos(x)
\end{minted}

Compute cosine of \texttt{x}, where \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L414-L418}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11271016674859747568}{} 
\hyperlink{11271016674859747568}{\texttt{Base.Math.sincos}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sincos(x)
\end{minted}

Simultaneously compute the sine and cosine of \texttt{x}, where the \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L168-L172}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16587188232273592448}{} 
\hyperlink{16587188232273592448}{\texttt{Base.tan}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tan(x)
\end{minted}

Compute tangent of \texttt{x}, where \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L421-L425}{\texttt{source}}


\end{adjustwidth}
\hypertarget{38337471195460170}{} 
\hyperlink{38337471195460170}{\texttt{Base.Math.sind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sind(x)
\end{minted}

Compute sine of \texttt{x}, where \texttt{x} is in degrees. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L1101-L1103}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6437354581891939537}{} 
\hyperlink{6437354581891939537}{\texttt{Base.Math.cosd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cosd(x)
\end{minted}

Compute cosine of \texttt{x}, where \texttt{x} is in degrees. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L1101-L1103}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10125316154174803495}{} 
\hyperlink{10125316154174803495}{\texttt{Base.Math.tand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tand(x)
\end{minted}

Compute tangent of \texttt{x}, where \texttt{x} is in degrees. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L1101-L1103}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16554510911661822298}{} 
\hyperlink{16554510911661822298}{\texttt{Base.Math.sinpi}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sinpi(x)
\end{minted}

Compute  \(\sin(\pi x)\)  more accurately than \texttt{sin(pi*x)}, especially for large \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L746-L750}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2974547424856180253}{} 
\hyperlink{2974547424856180253}{\texttt{Base.Math.cospi}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cospi(x)
\end{minted}

Compute  \(\cos(\pi x)\)  more accurately than \texttt{cos(pi*x)}, especially for large \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L809-L813}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8358213610919564439}{} 
\hyperlink{8358213610919564439}{\texttt{Base.sinh}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sinh(x)
\end{minted}

Compute hyperbolic sine of \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L299-L303}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15935907810641925869}{} 
\hyperlink{15935907810641925869}{\texttt{Base.cosh}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cosh(x)
\end{minted}

Compute hyperbolic cosine of \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L306-L310}{\texttt{source}}


\end{adjustwidth}
\hypertarget{26467867180214017}{} 
\hyperlink{26467867180214017}{\texttt{Base.tanh}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tanh(x)
\end{minted}

Compute hyperbolic tangent of \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L313-L317}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10601878151948439368}{} 
\hyperlink{10601878151948439368}{\texttt{Base.asin}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asin(x)
\end{minted}

Compute the inverse sine of \texttt{x}, where the output is in radians.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L428-L432}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12082560375801220429}{} 
\hyperlink{12082560375801220429}{\texttt{Base.acos}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acos(x)
\end{minted}

Compute the inverse cosine of \texttt{x}, where the output is in radians



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L435-L439}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16445804261034090556}{} 
\hyperlink{16445804261034090556}{\texttt{Base.atan}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
atan(y)
atan(y, x)
\end{minted}

Compute the inverse tangent of \texttt{y} or \texttt{y/x}, respectively.

For one argument, this is the angle in radians between the positive \emph{x}-axis and the point (1, \emph{y}), returning a value in the interval  \([-\pi/2, \pi/2]\) .

For two arguments, this is the angle in radians between the positive \emph{x}-axis and the point (\emph{x}, \emph{y}), returning a value in the interval  \([-\pi, \pi]\) . This corresponds to a standard \href{https://en.wikipedia.org/wiki/Atan2}{\texttt{atan2}} function.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L320-L332}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11304354062744129101}{} 
\hyperlink{11304354062744129101}{\texttt{Base.Math.asind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asind(x)
\end{minted}

Compute the inverse sine of \texttt{x}, where the output is in degrees. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L1111-L1114}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9068426203671659431}{} 
\hyperlink{9068426203671659431}{\texttt{Base.Math.acosd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acosd(x)
\end{minted}

Compute the inverse cosine of \texttt{x}, where the output is in degrees. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L1111-L1114}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16709452940889335182}{} 
\hyperlink{16709452940889335182}{\texttt{Base.Math.atand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
atand(y)
atand(y,x)
\end{minted}

Compute the inverse tangent of \texttt{y} or \texttt{y/x}, respectively, where the output is in degrees.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L1118-L1123}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2348370164701029702}{} 
\hyperlink{2348370164701029702}{\texttt{Base.Math.sec}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sec(x)
\end{minted}

Compute the secant of \texttt{x}, where \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L965-L969}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6870524379126652076}{} 
\hyperlink{6870524379126652076}{\texttt{Base.Math.csc}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
csc(x)
\end{minted}

Compute the cosecant of \texttt{x}, where \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L965-L969}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10310506620597376911}{} 
\hyperlink{10310506620597376911}{\texttt{Base.Math.cot}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cot(x)
\end{minted}

Compute the cotangent of \texttt{x}, where \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L965-L969}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3627927627858191087}{} 
\hyperlink{3627927627858191087}{\texttt{Base.Math.secd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
secd(x)
\end{minted}

Compute the secant of \texttt{x}, where \texttt{x} is in degrees.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L975-L979}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5282241990933081613}{} 
\hyperlink{5282241990933081613}{\texttt{Base.Math.cscd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cscd(x)
\end{minted}

Compute the cosecant of \texttt{x}, where \texttt{x} is in degrees.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L975-L979}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10552388625489786427}{} 
\hyperlink{10552388625489786427}{\texttt{Base.Math.cotd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cotd(x)
\end{minted}

Compute the cotangent of \texttt{x}, where \texttt{x} is in degrees.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L975-L979}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6414678656298972359}{} 
\hyperlink{6414678656298972359}{\texttt{Base.Math.asec}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asec(x)
\end{minted}

Compute the inverse secant of \texttt{x}, where the output is in radians. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L989-L991}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6613609554321971358}{} 
\hyperlink{6613609554321971358}{\texttt{Base.Math.acsc}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acsc(x)
\end{minted}

Compute the inverse cosecant of \texttt{x}, where the output is in radians. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L989-L991}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5496289593528195445}{} 
\hyperlink{5496289593528195445}{\texttt{Base.Math.acot}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acot(x)
\end{minted}

Compute the inverse cotangent of \texttt{x}, where the output is in radians. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L989-L991}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11130798465735678102}{} 
\hyperlink{11130798465735678102}{\texttt{Base.Math.asecd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asecd(x)
\end{minted}

Compute the inverse secant of \texttt{x}, where the output is in degrees. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L1111-L1114}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4156782540452156093}{} 
\hyperlink{4156782540452156093}{\texttt{Base.Math.acscd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acscd(x)
\end{minted}

Compute the inverse cosecant of \texttt{x}, where the output is in degrees. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L1111-L1114}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8127927203221847430}{} 
\hyperlink{8127927203221847430}{\texttt{Base.Math.acotd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acotd(x)
\end{minted}

Compute the inverse cotangent of \texttt{x}, where the output is in degrees. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L1111-L1114}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11032843379178642696}{} 
\hyperlink{11032843379178642696}{\texttt{Base.Math.sech}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sech(x)
\end{minted}

Compute the hyperbolic secant of \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L970-L974}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7622662781941268376}{} 
\hyperlink{7622662781941268376}{\texttt{Base.Math.csch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
csch(x)
\end{minted}

Compute the hyperbolic cosecant of \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L970-L974}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2237100109226086781}{} 
\hyperlink{2237100109226086781}{\texttt{Base.Math.coth}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
coth(x)
\end{minted}

Compute the hyperbolic cotangent of \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L970-L974}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9149326513268706036}{} 
\hyperlink{9149326513268706036}{\texttt{Base.asinh}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asinh(x)
\end{minted}

Compute the inverse hyperbolic sine of \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L335-L339}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18089515813362208379}{} 
\hyperlink{18089515813362208379}{\texttt{Base.acosh}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acosh(x)
\end{minted}

Compute the inverse hyperbolic cosine of \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L442-L446}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13328745702871778622}{} 
\hyperlink{13328745702871778622}{\texttt{Base.atanh}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
atanh(x)
\end{minted}

Compute the inverse hyperbolic tangent of \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L449-L453}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7159979165465243804}{} 
\hyperlink{7159979165465243804}{\texttt{Base.Math.asech}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asech(x)
\end{minted}

Compute the inverse hyperbolic secant of \texttt{x}. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L992-L994}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6612108333331684139}{} 
\hyperlink{6612108333331684139}{\texttt{Base.Math.acsch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acsch(x)
\end{minted}

Compute the inverse hyperbolic cosecant of \texttt{x}. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L992-L994}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7076402848633775115}{} 
\hyperlink{7076402848633775115}{\texttt{Base.Math.acoth}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acoth(x)
\end{minted}

Compute the inverse hyperbolic cotangent of \texttt{x}. 



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L992-L994}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16625449660258120296}{} 
\hyperlink{16625449660258120296}{\texttt{Base.Math.sinc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sinc(x)
\end{minted}

Compute  \(\sin(\pi x) / (\pi x)\)  if  \(x \neq 0\) , and  \(1\)  if  \(x = 0\) .



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L935-L939}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16278225468798010360}{} 
\hyperlink{16278225468798010360}{\texttt{Base.Math.cosc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cosc(x)
\end{minted}

Compute  \(\cos(\pi x) / x - \sin(\pi x) / (\pi x^2)\)  if  \(x \neq 0\) , and  \(0\)  if  \(x = 0\) . This is the derivative of \texttt{sinc(x)}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/trig.jl#L946-L951}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11016541033238436876}{} 
\hyperlink{11016541033238436876}{\texttt{Base.Math.deg2rad}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
deg2rad(x)
\end{minted}

Convert \texttt{x} from degrees to radians.

\textbf{Examples}


\begin{minted}{jlcon}
julia> deg2rad(90)
1.5707963267948966
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L232-L242}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17164560583584594903}{} 
\hyperlink{17164560583584594903}{\texttt{Base.Math.rad2deg}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rad2deg(x)
\end{minted}

Convert \texttt{x} from radians to degrees.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rad2deg(pi)
180.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L219-L229}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18304489571285447949}{} 
\hyperlink{18304489571285447949}{\texttt{Base.Math.hypot}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hypot(x, y)
\end{minted}

Compute the hypotenuse  \(\sqrt{|x|^2+|y|^2}\)  avoiding overflow and underflow.

This code is an implementation of the algorithm described in: An Improved Algorithm for \texttt{hypot(a,b)} by Carlos F. Borges The article is available online at ArXiv at the link   https://arxiv.org/abs/1904.09481

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = Int64(10)^10;

julia> hypot(a, a)
1.4142135623730951e10

julia> √(a^2 + a^2) # a^2 overflows
ERROR: DomainError with -2.914184810805068e18:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
[...]

julia> hypot(3, 4im)
5.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L585-L612}{\texttt{source}}



\begin{lstlisting}
hypot(x...)
\end{lstlisting}

Compute the hypotenuse  \(\sqrt{\sum |x_i|^2}\)  avoiding overflow and underflow.

\textbf{Examples}


\begin{minted}{jlcon}
julia> hypot(-5.7)
5.7

julia> hypot(3, 4im, 12.0)
13.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L675-L688}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17317607370922767936}{} 
\hyperlink{17317607370922767936}{\texttt{Base.log}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
log(x)
\end{minted}

Compute the natural logarithm of \texttt{x}. Throws \hyperlink{14085880504701688639}{\texttt{DomainError}} for negative \hyperlink{6175959395021454412}{\texttt{Real}} arguments. Use complex negative arguments to obtain complex results.

\textbf{Examples}


\begin{minted}{jlcon}
julia> log(2)
0.6931471805599453

julia> log(-3)
ERROR: DomainError with -3.0:
log will only return a complex result if called with a complex argument. Try log(Complex(x)).
Stacktrace:
 [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L456-L474}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10582107494419543982}{} 
\hyperlink{10582107494419543982}{\texttt{Base.log}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
log(b,x)
\end{minted}

Compute the base \texttt{b} logarithm of \texttt{x}. Throws \hyperlink{14085880504701688639}{\texttt{DomainError}} for negative \hyperlink{6175959395021454412}{\texttt{Real}} arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> log(4,8)
1.5

julia> log(4,2)
0.5

julia> log(-2, 3)
ERROR: DomainError with -2.0:
log will only return a complex result if called with a complex argument. Try log(Complex(x)).
Stacktrace:
 [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31
[...]

julia> log(2, -3)
ERROR: DomainError with -3.0:
log will only return a complex result if called with a complex argument. Try log(Complex(x)).
Stacktrace:
 [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31
[...]
\end{minted}

\begin{quote}
\textbf{Note}

If \texttt{b} is a power of 2 or 10, \hyperlink{18341149201477905713}{\texttt{log2}} or \hyperlink{3481560771470480868}{\texttt{log10}} should be used, as these will typically be faster and more accurate. For example,


\begin{minted}{jlcon}
julia> log(100,1000000)
2.9999999999999996

julia> log10(1000000)/2
3.0
\end{minted}

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L251-L291}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18341149201477905713}{} 
\hyperlink{18341149201477905713}{\texttt{Base.log2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
log2(x)
\end{minted}

Compute the logarithm of \texttt{x} to base 2. Throws \hyperlink{14085880504701688639}{\texttt{DomainError}} for negative \hyperlink{6175959395021454412}{\texttt{Real}} arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> log2(4)
2.0

julia> log2(10)
3.321928094887362

julia> log2(-2)
ERROR: DomainError with -2.0:
NaN result for non-NaN input.
Stacktrace:
 [1] nan_dom_err at ./math.jl:325 [inlined]
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L477-L498}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3481560771470480868}{} 
\hyperlink{3481560771470480868}{\texttt{Base.log10}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
log10(x)
\end{minted}

Compute the logarithm of \texttt{x} to base 10. Throws \hyperlink{14085880504701688639}{\texttt{DomainError}} for negative \hyperlink{6175959395021454412}{\texttt{Real}} arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> log10(100)
2.0

julia> log10(2)
0.3010299956639812

julia> log10(-2)
ERROR: DomainError with -2.0:
NaN result for non-NaN input.
Stacktrace:
 [1] nan_dom_err at ./math.jl:325 [inlined]
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L501-L522}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5533050447473188877}{} 
\hyperlink{5533050447473188877}{\texttt{Base.log1p}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
log1p(x)
\end{minted}

Accurate natural logarithm of \texttt{1+x}. Throws \hyperlink{14085880504701688639}{\texttt{DomainError}} for \hyperlink{6175959395021454412}{\texttt{Real}} arguments less than -1.

\textbf{Examples}


\begin{minted}{jlcon}
julia> log1p(-0.5)
-0.6931471805599453

julia> log1p(0)
0.0

julia> log1p(-2)
ERROR: DomainError with -2.0:
log1p will only return a complex result if called with a complex argument. Try log1p(Complex(x)).
Stacktrace:
 [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L525-L546}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12570003490345822061}{} 
\hyperlink{12570003490345822061}{\texttt{Base.Math.frexp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
frexp(val)
\end{minted}

Return \texttt{(x,exp)} such that \texttt{x} has a magnitude in the interval  \([1/2, 1)\)  or 0, and \texttt{val} is equal to  \(x \times 2^{exp}\) .



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L810-L815}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5801729597955756107}{} 
\hyperlink{5801729597955756107}{\texttt{Base.exp}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
exp(x)
\end{minted}

Compute the natural base exponential of \texttt{x}, in other words  \(e^x\) .

\textbf{Examples}


\begin{minted}{jlcon}
julia> exp(1.0)
2.718281828459045
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/exp.jl#L62-L72}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12542609616026627164}{} 
\hyperlink{12542609616026627164}{\texttt{Base.exp2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
exp2(x)
\end{minted}

Compute the base 2 exponential of \texttt{x}, in other words  \(2^x\) .

\textbf{Examples}


\begin{minted}{jlcon}
julia> exp2(5)
32.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L356-L366}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4510833300532946775}{} 
\hyperlink{4510833300532946775}{\texttt{Base.exp10}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
exp10(x)
\end{minted}

Compute the base 10 exponential of \texttt{x}, in other words  \(10^x\) .

\textbf{Examples}


\begin{minted}{jlcon}
julia> exp10(2)
100.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L369-L379}{\texttt{source}}



\begin{lstlisting}
exp10(x)
\end{lstlisting}

Compute  \(10^x\) .

\textbf{Examples}


\begin{minted}{jlcon}
julia> exp10(2)
100.0

julia> exp10(0.2)
1.5848931924611136
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/exp10.jl#L72-L85}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14721177606508229464}{} 
\hyperlink{14721177606508229464}{\texttt{Base.Math.ldexp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ldexp(x, n)
\end{minted}

Compute  \(x \times 2^n\) .

\textbf{Examples}


\begin{minted}{jlcon}
julia> ldexp(5., 2)
20.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L706-L716}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7336011242447784962}{} 
\hyperlink{7336011242447784962}{\texttt{Base.Math.modf}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
modf(x)
\end{minted}

Return a tuple \texttt{(fpart, ipart)} of the fractional and integral parts of a number. Both parts have the same sign as the argument.

\textbf{Examples}


\begin{minted}{jlcon}
julia> modf(3.5)
(0.5, 3.0)

julia> modf(-3.5)
(-0.5, -3.0)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L840-L854}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4939309737829480377}{} 
\hyperlink{4939309737829480377}{\texttt{Base.expm1}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
expm1(x)
\end{minted}

Accurately compute  \(e^x-1\) .



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L342-L346}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12930779325193350739}{} 
\hyperlink{12930779325193350739}{\texttt{Base.round}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
round([T,] x, [r::RoundingMode])
round(x, [r::RoundingMode]; digits::Integer=0, base = 10)
round(x, [r::RoundingMode]; sigdigits::Integer, base = 10)
\end{minted}

Rounds the number \texttt{x}.

Without keyword arguments, \texttt{x} is rounded to an integer value, returning a value of type \texttt{T}, or of the same type of \texttt{x} if no \texttt{T} is provided. An \hyperlink{5399118524830636312}{\texttt{InexactError}} will be thrown if the value is not representable by \texttt{T}, similar to \hyperlink{1846942650946171605}{\texttt{convert}}.

If the \texttt{digits} keyword argument is provided, it rounds to the specified number of digits after the decimal place (or before if negative), in base \texttt{base}.

If the \texttt{sigdigits} keyword argument is provided, it rounds to the specified number of significant digits, in base \texttt{base}.

The \hyperlink{16713322195952720212}{\texttt{RoundingMode}} \texttt{r} controls the direction of the rounding; the default is \hyperlink{868115654703135309}{\texttt{RoundNearest}}, which rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer. Note that \texttt{round} may give incorrect results if the global rounding mode is changed (see \hyperlink{6511778857518292792}{\texttt{rounding}}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> round(1.7)
2.0

julia> round(Int, 1.7)
2

julia> round(1.5)
2.0

julia> round(2.5)
2.0

julia> round(pi; digits=2)
3.14

julia> round(pi; digits=3, base=2)
3.125

julia> round(123.456; sigdigits=2)
120.0

julia> round(357.913; sigdigits=4, base=2)
352.0
\end{minted}

\begin{quote}
\textbf{Note}

Rounding to specified digits in bases other than 2 can be inexact when operating on binary floating point numbers. For example, the \hyperlink{5027751419500983000}{\texttt{Float64}} value represented by \texttt{1.15} is actually \emph{less} than 1.15, yet will be rounded to 1.2.

\chapter{Examples}


\begin{minted}{jlcon}
julia> x = 1.15
1.15

julia> @sprintf "%.20f" x
"1.14999999999999991118"

julia> x < 115//100
true

julia> round(x, digits=1)
1.2
\end{minted}

\end{quote}
\textbf{Extensions}

To extend \texttt{round} to new numeric types, it is typically sufficient to define \texttt{Base.round(x::NewType, r::RoundingMode)}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/floatfuncs.jl#L47-L120}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16713322195952720212}{} 
\hyperlink{16713322195952720212}{\texttt{Base.Rounding.RoundingMode}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RoundingMode
\end{minted}

A type used for controlling the rounding mode of floating point operations (via \hyperlink{6511778857518292792}{\texttt{rounding}}/\hyperlink{12025922235501343815}{\texttt{setrounding}} functions), or as optional arguments for rounding to the nearest integer (via the \hyperlink{12930779325193350739}{\texttt{round}} function).

Currently supported rounding modes are:

\begin{itemize}
\item \hyperlink{868115654703135309}{\texttt{RoundNearest}} (default)


\item \hyperlink{975776970636292472}{\texttt{RoundNearestTiesAway}}


\item \hyperlink{9147917195826641690}{\texttt{RoundNearestTiesUp}}


\item \hyperlink{7760059079134067537}{\texttt{RoundToZero}}


\item \hyperlink{9825765525550990700}{\texttt{RoundFromZero}} (\hyperlink{749816618809421837}{\texttt{BigFloat}} only)


\item \hyperlink{874246484265932239}{\texttt{RoundUp}}


\item \hyperlink{3648739763580508258}{\texttt{RoundDown}}

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L26-L43}{\texttt{source}}


\end{adjustwidth}
\hypertarget{868115654703135309}{} 
\hyperlink{868115654703135309}{\texttt{Base.Rounding.RoundNearest}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RoundNearest
\end{minted}

The default rounding mode. Rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L46-L51}{\texttt{source}}


\end{adjustwidth}
\hypertarget{975776970636292472}{} 
\hyperlink{975776970636292472}{\texttt{Base.Rounding.RoundNearestTiesAway}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RoundNearestTiesAway
\end{minted}

Rounds to nearest integer, with ties rounded away from zero (C/C++ \hyperlink{12930779325193350739}{\texttt{round}} behaviour).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L89-L94}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9147917195826641690}{} 
\hyperlink{9147917195826641690}{\texttt{Base.Rounding.RoundNearestTiesUp}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RoundNearestTiesUp
\end{minted}

Rounds to nearest integer, with ties rounded toward positive infinity (Java/JavaScript \hyperlink{12930779325193350739}{\texttt{round}} behaviour).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L97-L102}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7760059079134067537}{} 
\hyperlink{7760059079134067537}{\texttt{Base.Rounding.RoundToZero}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RoundToZero
\end{minted}

\hyperlink{12930779325193350739}{\texttt{round}} using this rounding mode is an alias for \hyperlink{1728363361565303194}{\texttt{trunc}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L54-L58}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9825765525550990700}{} 
\hyperlink{9825765525550990700}{\texttt{Base.Rounding.RoundFromZero}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RoundFromZero
\end{minted}

Rounds away from zero. This rounding mode may only be used with \texttt{T == BigFloat} inputs to \hyperlink{12930779325193350739}{\texttt{round}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> BigFloat("1.0000000000000001", 5, RoundFromZero)
1.06
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L75-L86}{\texttt{source}}


\end{adjustwidth}
\hypertarget{874246484265932239}{} 
\hyperlink{874246484265932239}{\texttt{Base.Rounding.RoundUp}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RoundUp
\end{minted}

\hyperlink{12930779325193350739}{\texttt{round}} using this rounding mode is an alias for \hyperlink{10519509038312853061}{\texttt{ceil}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L61-L65}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3648739763580508258}{} 
\hyperlink{3648739763580508258}{\texttt{Base.Rounding.RoundDown}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RoundDown
\end{minted}

\hyperlink{12930779325193350739}{\texttt{round}} using this rounding mode is an alias for \hyperlink{11115257331910840693}{\texttt{floor}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L68-L72}{\texttt{source}}


\end{adjustwidth}
\hypertarget{703325969015264809}{} 
\hyperlink{703325969015264809}{\texttt{Base.round}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
round(z::Complex[, RoundingModeReal, [RoundingModeImaginary]])
round(z::Complex[, RoundingModeReal, [RoundingModeImaginary]]; digits=, base=10)
round(z::Complex[, RoundingModeReal, [RoundingModeImaginary]]; sigdigits=, base=10)
\end{minted}

Return the nearest integral value of the same type as the complex-valued \texttt{z} to \texttt{z}, breaking ties using the specified \hyperlink{16713322195952720212}{\texttt{RoundingMode}}s. The first \hyperlink{16713322195952720212}{\texttt{RoundingMode}} is used for rounding the real components while the second is used for rounding the imaginary components.

\textbf{Example}


\begin{minted}{jlcon}
julia> round(3.14 + 4.5im)
3.0 + 4.0im
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/complex.jl#L993-L1008}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10519509038312853061}{} 
\hyperlink{10519509038312853061}{\texttt{Base.ceil}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ceil([T,] x)
ceil(x; digits::Integer= [, base = 10])
ceil(x; sigdigits::Integer= [, base = 10])
\end{minted}

\texttt{ceil(x)} returns the nearest integral value of the same type as \texttt{x} that is greater than or equal to \texttt{x}.

\texttt{ceil(T, x)} converts the result to type \texttt{T}, throwing an \texttt{InexactError} if the value is not representable.

\texttt{digits}, \texttt{sigdigits} and \texttt{base} work as for \hyperlink{12930779325193350739}{\texttt{round}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L516-L528}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11115257331910840693}{} 
\hyperlink{11115257331910840693}{\texttt{Base.floor}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
floor([T,] x)
floor(x; digits::Integer= [, base = 10])
floor(x; sigdigits::Integer= [, base = 10])
\end{minted}

\texttt{floor(x)} returns the nearest integral value of the same type as \texttt{x} that is less than or equal to \texttt{x}.

\texttt{floor(T, x)} converts the result to type \texttt{T}, throwing an \texttt{InexactError} if the value is not representable.

\texttt{digits}, \texttt{sigdigits} and \texttt{base} work as for \hyperlink{12930779325193350739}{\texttt{round}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L501-L513}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1728363361565303194}{} 
\hyperlink{1728363361565303194}{\texttt{Base.trunc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trunc([T,] x)
trunc(x; digits::Integer= [, base = 10])
trunc(x; sigdigits::Integer= [, base = 10])
\end{minted}

\texttt{trunc(x)} returns the nearest integral value of the same type as \texttt{x} whose absolute value is less than or equal to \texttt{x}.

\texttt{trunc(T, x)} converts the result to type \texttt{T}, throwing an \texttt{InexactError} if the value is not representable.

\texttt{digits}, \texttt{sigdigits} and \texttt{base} work as for \hyperlink{12930779325193350739}{\texttt{round}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L486-L498}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6382984648980626356}{} 
\hyperlink{6382984648980626356}{\texttt{Base.unsafe\_trunc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unsafe_trunc(T, x)
\end{minted}

Return the nearest integral value of type \texttt{T} whose absolute value is less than or equal to \texttt{x}. If the value is not representable by \texttt{T}, an arbitrary value will be returned.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L297-L303}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7458766354532817148}{} 
\hyperlink{7458766354532817148}{\texttt{Base.min}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
min(x, y, ...)
\end{minted}

Return the minimum of the arguments. See also the \hyperlink{13126064576294034099}{\texttt{minimum}} function to take the minimum element from a collection.

\textbf{Examples}


\begin{minted}{jlcon}
julia> min(2, 5, 1)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L410-L421}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7839419811914289844}{} 
\hyperlink{7839419811914289844}{\texttt{Base.max}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
max(x, y, ...)
\end{minted}

Return the maximum of the arguments. See also the \hyperlink{14719513931696680717}{\texttt{maximum}} function to take the maximum element from a collection.

\textbf{Examples}


\begin{minted}{jlcon}
julia> max(2, 5, 1)
5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L396-L407}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9004904914922806611}{} 
\hyperlink{9004904914922806611}{\texttt{Base.minmax}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
minmax(x, y)
\end{minted}

Return \texttt{(min(x,y), max(x,y))}. See also: \hyperlink{5171681020038097298}{\texttt{extrema}} that returns \texttt{(minimum(x), maximum(x))}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> minmax('c','b')
('b', 'c')
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/operators.jl#L424-L434}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2549437629093220350}{} 
\hyperlink{2549437629093220350}{\texttt{Base.Math.clamp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
clamp(x, lo, hi)
\end{minted}

Return \texttt{x} if \texttt{lo <= x <= hi}. If \texttt{x > hi}, return \texttt{hi}. If \texttt{x < lo}, return \texttt{lo}. Arguments are promoted to a common type.

\textbf{Examples}


\begin{minted}{jlcon}
julia> clamp.([pi, 1.0, big(10.)], 2., 9.)
3-element Array{BigFloat,1}:
 3.141592653589793238462643383279502884197169399375105820974944592307816406286198
 2.0
 9.0

julia> clamp.([11,8,5],10,6) # an example where lo > hi
3-element Array{Int64,1}:
  6
  6
 10
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L44-L64}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15974741233540534893}{} 
\hyperlink{15974741233540534893}{\texttt{Base.Math.clamp!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
clamp!(array::AbstractArray, lo, hi)
\end{minted}

Restrict values in \texttt{array} to the specified range, in-place. See also \hyperlink{2549437629093220350}{\texttt{clamp}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L71-L76}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9614495866226399167}{} 
\hyperlink{9614495866226399167}{\texttt{Base.abs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
abs(x)
\end{minted}

The absolute value of \texttt{x}.

When \texttt{abs} is applied to signed integers, overflow may occur, resulting in the return of a negative value. This overflow occurs only when \texttt{abs} is applied to the minimum representable value of a signed integer. That is, when \texttt{x == typemin(typeof(x))}, \texttt{abs(x) == x < 0}, not \texttt{-x} as might be expected.

\textbf{Examples}


\begin{minted}{jlcon}
julia> abs(-3)
3

julia> abs(1 + im)
1.4142135623730951

julia> abs(typemin(Int64))
-9223372036854775808
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L110-L132}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10885135672778604809}{} 
\hyperlink{10885135672778604809}{\texttt{Base.Checked.checked\_abs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.checked_abs(x)
\end{minted}

Calculates \texttt{abs(x)}, checking for overflow errors where applicable. For example, standard two{\textquotesingle}s complement signed integers (e.g. \texttt{Int}) cannot represent \texttt{abs(typemin(Int))}, thus leading to an overflow.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L105-L113}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13229568824844995103}{} 
\hyperlink{13229568824844995103}{\texttt{Base.Checked.checked\_neg}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.checked_neg(x)
\end{minted}

Calculates \texttt{-x}, checking for overflow errors where applicable. For example, standard two{\textquotesingle}s complement signed integers (e.g. \texttt{Int}) cannot represent \texttt{-typemin(Int)}, thus leading to an overflow.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L77-L85}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2964592337942314373}{} 
\hyperlink{2964592337942314373}{\texttt{Base.Checked.checked\_add}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.checked_add(x, y)
\end{minted}

Calculates \texttt{x+y}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L156-L162}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10268341695343039853}{} 
\hyperlink{10268341695343039853}{\texttt{Base.Checked.checked\_sub}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.checked_sub(x, y)
\end{minted}

Calculates \texttt{x-y}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L213-L219}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4390963153143215118}{} 
\hyperlink{4390963153143215118}{\texttt{Base.Checked.checked\_mul}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.checked_mul(x, y)
\end{minted}

Calculates \texttt{x*y}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L278-L284}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6689390039928836022}{} 
\hyperlink{6689390039928836022}{\texttt{Base.Checked.checked\_div}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.checked_div(x, y)
\end{minted}

Calculates \texttt{div(x,y)}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L307-L313}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12129844323919398781}{} 
\hyperlink{12129844323919398781}{\texttt{Base.Checked.checked\_rem}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.checked_rem(x, y)
\end{minted}

Calculates \texttt{x\%y}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L316-L322}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3745431966407804814}{} 
\hyperlink{3745431966407804814}{\texttt{Base.Checked.checked\_fld}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.checked_fld(x, y)
\end{minted}

Calculates \texttt{fld(x,y)}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L325-L331}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2512435134040972090}{} 
\hyperlink{2512435134040972090}{\texttt{Base.Checked.checked\_mod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.checked_mod(x, y)
\end{minted}

Calculates \texttt{mod(x,y)}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L334-L340}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1863194407625991652}{} 
\hyperlink{1863194407625991652}{\texttt{Base.Checked.checked\_cld}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.checked_cld(x, y)
\end{minted}

Calculates \texttt{cld(x,y)}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L343-L349}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8862869478194651358}{} 
\hyperlink{8862869478194651358}{\texttt{Base.Checked.add\_with\_overflow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.add_with_overflow(x, y) -> (r, f)
\end{minted}

Calculates \texttt{r = x+y}, with the flag \texttt{f} indicating whether overflow has occurred.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L126-L130}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2951243344761333492}{} 
\hyperlink{2951243344761333492}{\texttt{Base.Checked.sub\_with\_overflow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.sub_with_overflow(x, y) -> (r, f)
\end{minted}

Calculates \texttt{r = x-y}, with the flag \texttt{f} indicating whether overflow has occurred.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L188-L192}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9052860252825488939}{} 
\hyperlink{9052860252825488939}{\texttt{Base.Checked.mul\_with\_overflow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.mul_with_overflow(x, y) -> (r, f)
\end{minted}

Calculates \texttt{r = x*y}, with the flag \texttt{f} indicating whether overflow has occurred.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/checked.jl#L228-L232}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15686257922156163743}{} 
\hyperlink{15686257922156163743}{\texttt{Base.abs2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
abs2(x)
\end{minted}

Squared absolute value of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> abs2(-3)
9
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L122-L132}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6024566200716053110}{} 
\hyperlink{6024566200716053110}{\texttt{Base.copysign}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
copysign(x, y) -> z
\end{minted}

Return \texttt{z} which has the magnitude of \texttt{x} and the same sign as \texttt{y}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> copysign(1, -2)
-1

julia> copysign(-1, 2)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L151-L164}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14349105033929355161}{} 
\hyperlink{14349105033929355161}{\texttt{Base.sign}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sign(x)
\end{minted}

Return zero if \texttt{x==0} and  \(x/|x|\)  otherwise (i.e., ±1 for real \texttt{x}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L112-L116}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9457038569823603490}{} 
\hyperlink{9457038569823603490}{\texttt{Base.signbit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
signbit(x)
\end{minted}

Returns \texttt{true} if the value of the sign of \texttt{x} is negative, otherwise \texttt{false}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> signbit(-4)
true

julia> signbit(5)
false

julia> signbit(5.5)
false

julia> signbit(-4.1)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L90-L109}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2689022981470151558}{} 
\hyperlink{2689022981470151558}{\texttt{Base.flipsign}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
flipsign(x, y)
\end{minted}

Return \texttt{x} with its sign flipped if \texttt{y} is negative. For example \texttt{abs(x) = flipsign(x,x)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> flipsign(5, 3)
5

julia> flipsign(5, -3)
-5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L135-L148}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4551113327515323898}{} 
\hyperlink{4551113327515323898}{\texttt{Base.sqrt}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sqrt(x)
\end{minted}

Return  \(\sqrt{x}\) . Throws \hyperlink{14085880504701688639}{\texttt{DomainError}} for negative \hyperlink{6175959395021454412}{\texttt{Real}} arguments. Use complex negative arguments instead. The prefix operator \texttt{√} is equivalent to \texttt{sqrt}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sqrt(big(81))
9.0

julia> sqrt(big(-81))
ERROR: DomainError with -81.0:
NaN result for non-NaN input.
Stacktrace:
 [1] sqrt(::BigFloat) at ./mpfr.jl:501
[...]

julia> sqrt(big(complex(-81)))
0.0 + 9.0im
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L561-L582}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13061326033497045577}{} 
\hyperlink{13061326033497045577}{\texttt{Base.isqrt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isqrt(n::Integer)
\end{minted}

Integer square root: the largest integer \texttt{m} such that \texttt{m*m <= n}.


\begin{minted}{jlcon}
julia> isqrt(5)
2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L806-L815}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15104025502404840355}{} 
\hyperlink{15104025502404840355}{\texttt{Base.Math.cbrt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cbrt(x::Real)
\end{minted}

Return the cube root of \texttt{x}, i.e.  \(x^{1/3}\) . Negative values are accepted (returning the negative real root when  \(x < 0\) ).

The prefix operator \texttt{∛} is equivalent to \texttt{cbrt}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> cbrt(big(27))
3.0

julia> cbrt(big(-27))
-3.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/special/cbrt.jl#L17-L33}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10579540000886584250}{} 
\hyperlink{10579540000886584250}{\texttt{Base.real}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
real(z)
\end{minted}

Return the real part of the complex number \texttt{z}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> real(1 + 3im)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/complex.jl#L52-L62}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13331686588901351068}{} 
\hyperlink{13331686588901351068}{\texttt{Base.imag}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
imag(z)
\end{minted}

Return the imaginary part of the complex number \texttt{z}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> imag(1 + 3im)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/complex.jl#L65-L75}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4559968878634602058}{} 
\hyperlink{4559968878634602058}{\texttt{Base.reim}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reim(z)
\end{minted}

Return both the real and imaginary parts of the complex number \texttt{z}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> reim(1 + 3im)
(1, 3)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/complex.jl#L80-L90}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9940023991150673697}{} 
\hyperlink{9940023991150673697}{\texttt{Base.conj}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
conj(z)
\end{minted}

Compute the complex conjugate of a complex number \texttt{z}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> conj(1 + 3im)
1 - 3im
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/complex.jl#L252-L262}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9465547375318501186}{} 
\hyperlink{9465547375318501186}{\texttt{Base.angle}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
angle(z)
\end{minted}

Compute the phase angle in radians of a complex number \texttt{z}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rad2deg(angle(1 + im))
45.0

julia> rad2deg(angle(1 - im))
-45.0

julia> rad2deg(angle(-1 - im))
-135.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/complex.jl#L544-L560}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4687572676090761946}{} 
\hyperlink{4687572676090761946}{\texttt{Base.cis}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cis(z)
\end{minted}

Return  \(\exp(iz)\) .

\textbf{Examples}


\begin{minted}{jlcon}
julia> cis(π) ≈ -1
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/complex.jl#L527-L537}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7127784108654808529}{} 
\hyperlink{7127784108654808529}{\texttt{Base.binomial}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
binomial(n::Integer, k::Integer)
\end{minted}

The \emph{binomial coefficient}  \(\binom{n}{k}\) , being the coefficient of the  \(k\) th term in the polynomial expansion of  \((1+x)^n\) .

If  \(n\)  is non-negative, then it is the number of ways to choose \texttt{k} out of \texttt{n} items:

\begin{equation*}
\begin{split}\binom{n}{k} = \frac{n!}{k! (n-k)!}\end{split}\end{equation*}
where  \(n!\)  is the \hyperlink{1793920701415589315}{\texttt{factorial}} function.

If  \(n\)  is negative, then it is defined in terms of the identity

\begin{equation*}
\begin{split}\binom{n}{k} = (-1)^k \binom{k-n-1}{k}\end{split}\end{equation*}
\textbf{Examples}


\begin{minted}{jlcon}
julia> binomial(5, 3)
10

julia> factorial(5) ÷ (factorial(5-3) * factorial(3))
10

julia> binomial(-5, 3)
-35
\end{minted}

\textbf{See also}

\begin{itemize}
\item \hyperlink{1793920701415589315}{\texttt{factorial}}

\end{itemize}
\textbf{External links}

\begin{itemize}
\item \href{https://en.wikipedia.org/wiki/Binomial\_coefficient}{Binomial coeffient} on Wikipedia.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L863-L897}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1793920701415589315}{} 
\hyperlink{1793920701415589315}{\texttt{Base.factorial}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
factorial(n::Integer)
\end{minted}

Factorial of \texttt{n}. If \texttt{n} is an \hyperlink{8469131683393450448}{\texttt{Integer}}, the factorial is computed as an integer (promoted to at least 64 bits). Note that this may overflow if \texttt{n} is not small, but you can use \texttt{factorial(big(n))} to compute the result exactly in arbitrary precision.

\textbf{Examples}


\begin{minted}{jlcon}
julia> factorial(6)
720

julia> factorial(21)
ERROR: OverflowError: 21 is too large to look up in the table; consider using `factorial(big(21))` instead
Stacktrace:
[...]

julia> factorial(big(21))
51090942171709440000
\end{minted}

\textbf{See also}

\begin{itemize}
\item \hyperlink{7127784108654808529}{\texttt{binomial}}

\end{itemize}
\textbf{External links}

\begin{itemize}
\item \href{https://en.wikipedia.org/wiki/Factorial}{Factorial} on Wikipedia.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L827-L853}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15906911311436241979}{} 
\hyperlink{15906911311436241979}{\texttt{Base.gcd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gcd(x,y)
\end{minted}

Greatest common (positive) divisor (or zero if \texttt{x} and \texttt{y} are both zero). The arguments may be integer and rational numbers.

\begin{quote}
\textbf{Julia 1.4}

Rational arguments require Julia 1.4 or later.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> gcd(6,9)
3

julia> gcd(6,-9)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L5-L22}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12975400110924105221}{} 
\hyperlink{12975400110924105221}{\texttt{Base.lcm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lcm(x,y)
\end{minted}

Least common (non-negative) multiple. The arguments may be integer and rational numbers.

\begin{quote}
\textbf{Julia 1.4}

Rational arguments require Julia 1.4 or later.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> lcm(2,3)
6

julia> lcm(-2,3)
6
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L56-L73}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18359524628605105681}{} 
\hyperlink{18359524628605105681}{\texttt{Base.gcdx}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gcdx(x,y)
\end{minted}

Computes the greatest common (positive) divisor of \texttt{x} and \texttt{y} and their Bézout coefficients, i.e. the integer coefficients \texttt{u} and \texttt{v} that satisfy  \(ux+vy = d = gcd(x,y)\) .  \(gcdx(x,y)\)  returns  \((d,u,v)\) .

The arguments may be integer and rational numbers.

\begin{quote}
\textbf{Julia 1.4}

Rational arguments require Julia 1.4 or later.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> gcdx(12, 42)
(6, -3, 1)

julia> gcdx(240, 46)
(2, -9, 47)
\end{minted}

\begin{quote}
\textbf{Note}

Bézout coefficients are \emph{not} uniquely defined. \texttt{gcdx} returns the minimal Bézout coefficients that are computed by the extended Euclidean algorithm. (Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.) For signed integers, these coefficients \texttt{u} and \texttt{v} are minimal in the sense that  \(|u| < |y/d|\)  and  \(|v| < |x/d|\) . Furthermore, the signs of \texttt{u} and \texttt{v} are chosen so that \texttt{d} is positive. For unsigned integers, the coefficients \texttt{u} and \texttt{v} might be near their \texttt{typemax}, and the identity then holds only via the unsigned integers{\textquotesingle} modulo arithmetic.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L107-L138}{\texttt{source}}


\end{adjustwidth}
\hypertarget{598817088840034027}{} 
\hyperlink{598817088840034027}{\texttt{Base.ispow2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ispow2(n::Integer) -> Bool
\end{minted}

Test whether \texttt{n} is a power of two.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ispow2(4)
true

julia> ispow2(5)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L335-L348}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14955572944376366290}{} 
\hyperlink{14955572944376366290}{\texttt{Base.nextpow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nextpow(a, x)
\end{minted}

The smallest \texttt{a{\textasciicircum}n} not less than \texttt{x}, where \texttt{n} is a non-negative integer. \texttt{a} must be greater than 1, and \texttt{x} must be greater than 0.

\textbf{Examples}


\begin{minted}{jlcon}
julia> nextpow(2, 7)
8

julia> nextpow(2, 9)
16

julia> nextpow(5, 20)
25

julia> nextpow(4, 16)
16
\end{minted}

See also \hyperlink{488025580584649031}{\texttt{prevpow}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L351-L373}{\texttt{source}}


\end{adjustwidth}
\hypertarget{488025580584649031}{} 
\hyperlink{488025580584649031}{\texttt{Base.prevpow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
prevpow(a, x)
\end{minted}

The largest \texttt{a{\textasciicircum}n} not greater than \texttt{x}, where \texttt{n} is a non-negative integer. \texttt{a} must be greater than 1, and \texttt{x} must not be less than 1.

\textbf{Examples}


\begin{minted}{jlcon}
julia> prevpow(2, 7)
4

julia> prevpow(2, 9)
8

julia> prevpow(5, 20)
5

julia> prevpow(4, 16)
16
\end{minted}

See also \hyperlink{14955572944376366290}{\texttt{nextpow}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L388-L409}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9591900175500358341}{} 
\hyperlink{9591900175500358341}{\texttt{Base.nextprod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nextprod([k_1, k_2,...], n)
\end{minted}

Next integer greater than or equal to \texttt{n} that can be written as  \(\prod k_i^{p_i}\)  for integers  \(p_1\) ,  \(p_2\) , etc.

\textbf{Examples}


\begin{minted}{jlcon}
julia> nextprod([2, 3], 105)
108

julia> 2^2 * 3^3
108
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/combinatorics.jl#L248-L262}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17191792848451148355}{} 
\hyperlink{17191792848451148355}{\texttt{Base.invmod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
invmod(x,m)
\end{minted}

Take the inverse of \texttt{x} modulo \texttt{m}: \texttt{y} such that  \(x y = 1 \pmod m\) , with  \(div(x,y) = 0\) . This is undefined for  \(m = 0\) , or if  \(gcd(x,m) \neq 1\) .

\textbf{Examples}


\begin{minted}{jlcon}
julia> invmod(2,5)
3

julia> invmod(2,3)
2

julia> invmod(5,6)
5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L157-L175}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5886563157147453257}{} 
\hyperlink{5886563157147453257}{\texttt{Base.powermod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
powermod(x::Integer, p::Integer, m)
\end{minted}

Compute  \(x^p \pmod m\) .

\textbf{Examples}


\begin{minted}{jlcon}
julia> powermod(2, 6, 5)
4

julia> mod(2^6, 5)
4

julia> powermod(5, 2, 20)
5

julia> powermod(5, 2, 19)
6

julia> powermod(5, 3, 19)
11
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L284-L306}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7415013084438358060}{} 
\hyperlink{7415013084438358060}{\texttt{Base.ndigits}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ndigits(n::Integer; base::Integer=10, pad::Integer=1)
\end{minted}

Compute the number of digits in integer \texttt{n} written in base \texttt{base} (\texttt{base} must not be in \texttt{[-1, 0, 1]}), optionally padded with zeros to a specified size (the result will never be less than \texttt{pad}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> ndigits(12345)
5

julia> ndigits(1022, base=16)
3

julia> string(1022, base=16)
"3fe"

julia> ndigits(123, pad=5)
5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L543-L564}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4564031682097452426}{} 
\hyperlink{4564031682097452426}{\texttt{Base.widemul}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
widemul(x, y)
\end{minted}

Multiply \texttt{x} and \texttt{y}, giving the result as a larger type.

\textbf{Examples}


\begin{minted}{jlcon}
julia> widemul(Float32(3.), 4.)
12.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L202-L212}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8357888339204308169}{} 
\hyperlink{8357888339204308169}{\texttt{Base.Math.evalpoly}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
evalpoly(x, p)
\end{minted}

Evaluate the polynomial  \(\sum_k p[k] x^{k-1}\)  for the coefficients \texttt{p[1]}, \texttt{p[2]}, ...; that is, the coefficients are given in ascending order by power of \texttt{x}. Loops are unrolled at compile time if the number of coefficients is statically known, i.e. when \texttt{p} is a \texttt{Tuple}. This function generates efficient code using Horner{\textquotesingle}s method if \texttt{x} is real, or using a Goertzel-like \footnotemark[1] algorithm if \texttt{x} is complex.

\footnotetext[1]{Donald Knuth, Art of Computer Programming, Volume 2: Seminumerical Algorithms, Sec. 4.6.4.

}
\begin{quote}
\textbf{Julia 1.4}

This function requires Julia 1.4 or later.

\end{quote}
\textbf{Example}


\begin{minted}{jlcon}
julia> evalpoly(2, (1, 2, 3))
17
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L85-L105}{\texttt{source}}


\end{adjustwidth}
\hypertarget{552638784001429566}{} 
\hyperlink{552638784001429566}{\texttt{Base.Math.@evalpoly}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@evalpoly(z, c...)
\end{minted}

Evaluate the polynomial  \(\sum_k c[k] z^{k-1}\)  for the coefficients \texttt{c[1]}, \texttt{c[2]}, ...; that is, the coefficients are given in ascending order by power of \texttt{z}.  This macro expands to efficient inline code that uses either Horner{\textquotesingle}s method or, for complex \texttt{z}, a more efficient Goertzel-like algorithm.

\textbf{Examples}


\begin{minted}{jlcon}
julia> @evalpoly(3, 1, 0, 1)
10

julia> @evalpoly(2, 1, 0, 1)
5

julia> @evalpoly(2, 1, 1, 1)
7
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L194-L213}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8577961464469068114}{} 
\hyperlink{8577961464469068114}{\texttt{Base.FastMath.@fastmath}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@fastmath expr
\end{minted}

Execute a transformed version of the expression, which calls functions that may violate strict IEEE semantics. This allows the fastest possible operation, but results are undefined – be careful when doing this, as it may change numerical results.

This sets the \href{http://llvm.org/docs/LangRef.html\#fast-math-flags}{LLVM Fast-Math flags}, and corresponds to the \texttt{-ffast-math} option in clang. See \hyperlink{2666116597324353353}{the notes on performance annotations} for more details.

\textbf{Examples}


\begin{minted}{jlcon}
julia> @fastmath 1+2
3

julia> @fastmath(sin(3))
0.1411200080598672
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/fastmath.jl#L129-L149}{\texttt{source}}


\end{adjustwidth}

\hypertarget{15678902192626228911}{}


\section{Customizable binary operators}



Some unicode characters can be used to define new binary operators that support infix notation. For example \texttt{⊗(x,y) = kron(x,y)} defines the \texttt{⊗} (otimes) function to be the Kronecker product, and one can call it as binary operator using infix syntax: \texttt{C = A ⊗ B} as well as with the usual prefix syntax \texttt{C = ⊗(A,B)}.



Other characters that support such extensions include {\textbackslash}odot \texttt{⊙} and {\textbackslash}oplus \texttt{⊕}



The complete list is in the parser code: https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm



Those that are parsed like \texttt{*} (in terms of precedence) include \texttt{* / ÷ \% \& ⋅ ∘ × |{\textbackslash}{\textbackslash}| ∩ ∧ ⊗ ⊘ ⊙ ⊚ ⊛ ⊠ ⊡ ⊓ ∗ ∙ ∤ ⅋ ≀ ⊼ ⋄ ⋆ ⋇ ⋉ ⋊ ⋋ ⋌ ⋏ ⋒ ⟑ ⦸ ⦼ ⦾ ⦿ ⧶ ⧷ ⨇ ⨰ ⨱ ⨲ ⨳ ⨴ ⨵ ⨶ ⨷ ⨸ ⨻ ⨼ ⨽ ⩀ ⩃ ⩄ ⩋ ⩍ ⩎ ⩑ ⩓ ⩕ ⩘ ⩚ ⩜ ⩞ ⩟ ⩠ ⫛ ⊍ ▷ ⨝ ⟕ ⟖ ⟗} and those that are parsed like \texttt{+} include \texttt{+ - |{\textbackslash}|| ⊕ ⊖ ⊞ ⊟ |++| ∪ ∨ ⊔ ± ∓ ∔ ∸ ≏ ⊎ \unicodeveebar{} ⊽ ⋎ ⋓ ⧺ ⧻ ⨈ ⨢ ⨣ ⨤ ⨥ ⨦ ⨧ ⨨ ⨩ ⨪ ⨫ ⨬ ⨭ ⨮ ⨹ ⨺ ⩁ ⩂ ⩅ ⩊ ⩌ ⩏ ⩐ ⩒ ⩔ ⩖ ⩗ ⩛ ⩝ ⩡ ⩢ ⩣} There are many others that are related to arrows, comparisons, and powers.



\hypertarget{856545484690558276}{}


\chapter{Numbers}



\hypertarget{9397501928806461980}{}


\section{标准数值类型}



\hypertarget{1351792297266187673}{}


\subsection{抽象数值类型}


\hypertarget{1990584313715697055}{} 
\hyperlink{1990584313715697055}{\texttt{Core.Number}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Number
\end{minted}

Abstract supertype for all number types.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1458-L1462}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6175959395021454412}{} 
\hyperlink{6175959395021454412}{\texttt{Core.Real}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Real <: Number
\end{minted}

Abstract supertype for all real numbers.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1465-L1469}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11465394427882483091}{} 
\hyperlink{11465394427882483091}{\texttt{Core.AbstractFloat}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractFloat <: Real
\end{minted}

Abstract supertype for all floating point numbers.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1472-L1476}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8469131683393450448}{} 
\hyperlink{8469131683393450448}{\texttt{Core.Integer}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Integer <: Real
\end{minted}

Abstract supertype for all integers.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1479-L1483}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14154866400772377486}{} 
\hyperlink{14154866400772377486}{\texttt{Core.Signed}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Signed <: Integer
\end{minted}

Abstract supertype for all signed integers.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1486-L1490}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4780971278803506664}{} 
\hyperlink{4780971278803506664}{\texttt{Core.Unsigned}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Unsigned <: Integer
\end{minted}

Abstract supertype for all unsigned integers.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1493-L1497}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1075257529074867746}{} 
\hyperlink{1075257529074867746}{\texttt{Base.AbstractIrrational}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractIrrational <: Real
\end{minted}

Number type representing an exact irrational value.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/irrationals.jl#L5-L9}{\texttt{source}}


\end{adjustwidth}

\hypertarget{12287781227840134308}{}


\subsection{具象数值类型}


\hypertarget{2727296760866702904}{} 
\hyperlink{2727296760866702904}{\texttt{Core.Float16}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Float16 <: AbstractFloat
\end{minted}

16-bit floating point number type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1527-L1531}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8101639384272933082}{} 
\hyperlink{8101639384272933082}{\texttt{Core.Float32}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Float32 <: AbstractFloat
\end{minted}

32-bit floating point number type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1527-L1531}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5027751419500983000}{} 
\hyperlink{5027751419500983000}{\texttt{Core.Float64}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Float64 <: AbstractFloat
\end{minted}

64-bit floating point number type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1527-L1531}{\texttt{source}}


\end{adjustwidth}
\hypertarget{749816618809421837}{} 
\hyperlink{749816618809421837}{\texttt{Base.MPFR.BigFloat}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
BigFloat <: AbstractFloat
\end{minted}

Arbitrary precision floating point number type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/mpfr.jl#L86-L90}{\texttt{source}}


\end{adjustwidth}
\hypertarget{46725311238864537}{} 
\hyperlink{46725311238864537}{\texttt{Core.Bool}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Bool <: Integer
\end{minted}

Boolean type, containing the values \texttt{true} and \texttt{false}.

\texttt{Bool} is a kind of number: \texttt{false} is numerically equal to \texttt{0} and \texttt{true} is numerically equal to \texttt{1}. Moreover, \texttt{false} acts as a multiplicative {\textquotedbl}strong zero{\textquotedbl}:


\begin{minted}{jlcon}
julia> false == 0
true

julia> true == 1
true

julia> 0 * NaN
NaN

julia> false * NaN
0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1500-L1522}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5857518405103968275}{} 
\hyperlink{5857518405103968275}{\texttt{Core.Int8}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Int8 <: Signed
\end{minted}

8-bit signed integer type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1538-L1542}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6609065134969660118}{} 
\hyperlink{6609065134969660118}{\texttt{Core.UInt8}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UInt8 <: Unsigned
\end{minted}

8-bit unsigned integer type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1545-L1549}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6667287249103968645}{} 
\hyperlink{6667287249103968645}{\texttt{Core.Int16}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Int16 <: Signed
\end{minted}

16-bit signed integer type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1538-L1542}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7018610346698168012}{} 
\hyperlink{7018610346698168012}{\texttt{Core.UInt16}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UInt16 <: Unsigned
\end{minted}

16-bit unsigned integer type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1545-L1549}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10103694114785108551}{} 
\hyperlink{10103694114785108551}{\texttt{Core.Int32}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Int32 <: Signed
\end{minted}

32-bit signed integer type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1538-L1542}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8690996847580776341}{} 
\hyperlink{8690996847580776341}{\texttt{Core.UInt32}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UInt32 <: Unsigned
\end{minted}

32-bit unsigned integer type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1545-L1549}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7720564657383125058}{} 
\hyperlink{7720564657383125058}{\texttt{Core.Int64}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Int64 <: Signed
\end{minted}

64-bit signed integer type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1538-L1542}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5500998675195555601}{} 
\hyperlink{5500998675195555601}{\texttt{Core.UInt64}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UInt64 <: Unsigned
\end{minted}

64-bit unsigned integer type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1545-L1549}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8012327724714767060}{} 
\hyperlink{8012327724714767060}{\texttt{Core.Int128}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Int128 <: Signed
\end{minted}

128-bit signed integer type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1538-L1542}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14811222188335428522}{} 
\hyperlink{14811222188335428522}{\texttt{Core.UInt128}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UInt128 <: Unsigned
\end{minted}

128-bit unsigned integer type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1545-L1549}{\texttt{source}}


\end{adjustwidth}
\hypertarget{423405808990690832}{} 
\hyperlink{423405808990690832}{\texttt{Base.GMP.BigInt}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
BigInt <: Signed
\end{minted}

Arbitrary precision integer type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/gmp.jl#L45-L49}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11302502367029942782}{} 
\hyperlink{11302502367029942782}{\texttt{Base.Complex}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Complex{T<:Real} <: Number
\end{minted}

Complex number type with real and imaginary part of type \texttt{T}.

\texttt{ComplexF16}, \texttt{ComplexF32} and \texttt{ComplexF64} are aliases for \texttt{Complex\{Float16\}}, \texttt{Complex\{Float32\}} and \texttt{Complex\{Float64\}} respectively.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/complex.jl#L3-L10}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8304566144531167610}{} 
\hyperlink{8304566144531167610}{\texttt{Base.Rational}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Rational{T<:Integer} <: Real
\end{minted}

Rational number type, with numerator and denominator of type \texttt{T}. Rationals are checked for overflow.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rational.jl#L3-L8}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5993828909973077529}{} 
\hyperlink{5993828909973077529}{\texttt{Base.Irrational}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Irrational{sym} <: AbstractIrrational
\end{minted}

Number type representing an exact irrational value denoted by the symbol \texttt{sym}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/irrationals.jl#L12-L17}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14469209681538830551}{}


\section{数据格式}


\hypertarget{17983913084963570964}{} 
\hyperlink{17983913084963570964}{\texttt{Base.digits}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
digits([T<:Integer], n::Integer; base::T = 10, pad::Integer = 1)
\end{minted}

Return an array with element type \texttt{T} (default \texttt{Int}) of the digits of \texttt{n} in the given base, optionally padded with zeros to a specified size. More significant digits are at higher indices, such that \texttt{n == sum([digits[k]*base{\textasciicircum}(k-1) for k=1:length(digits)])}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> digits(10, base = 10)
2-element Array{Int64,1}:
 0
 1

julia> digits(10, base = 2)
4-element Array{Int64,1}:
 0
 1
 0
 1

julia> digits(10, base = 2, pad = 6)
6-element Array{Int64,1}:
 0
 1
 0
 1
 0
 0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L700-L730}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18145156230339025572}{} 
\hyperlink{18145156230339025572}{\texttt{Base.digits!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
digits!(array, n::Integer; base::Integer = 10)
\end{minted}

Fills an array of the digits of \texttt{n} in the given base. More significant digits are at higher indices. If the array length is insufficient, the least significant digits are filled up to the array length. If the array length is excessive, the excess portion is filled with zeros.

\textbf{Examples}


\begin{minted}{jlcon}
julia> digits!([2,2,2,2], 10, base = 2)
4-element Array{Int64,1}:
 0
 1
 0
 1

julia> digits!([2,2,2,2,2,2], 10, base = 2)
6-element Array{Int64,1}:
 0
 1
 0
 1
 0
 0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L746-L771}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9171163989026657457}{} 
\hyperlink{9171163989026657457}{\texttt{Base.bitstring}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
bitstring(n)
\end{minted}

A string giving the literal bit representation of a number.

\textbf{Examples}


\begin{minted}{jlcon}
julia> bitstring(4)
"0000000000000000000000000000000000000000000000000000000000000100"

julia> bitstring(2.2)
"0100000000000001100110011001100110011001100110011001100110011010"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L678-L691}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14207407853646164654}{} 
\hyperlink{14207407853646164654}{\texttt{Base.parse}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
parse(type, str; base)
\end{minted}

Parse a string as a number. For \texttt{Integer} types, a base can be specified (the default is 10). For floating-point types, the string is parsed as a decimal floating-point number.  \texttt{Complex} types are parsed from decimal strings of the form \texttt{{\textquotedbl}R±Iim{\textquotedbl}} as a \texttt{Complex(R,I)} of the requested type; \texttt{{\textquotedbl}i{\textquotedbl}} or \texttt{{\textquotedbl}j{\textquotedbl}} can also be used instead of \texttt{{\textquotedbl}im{\textquotedbl}}, and \texttt{{\textquotedbl}R{\textquotedbl}} or \texttt{{\textquotedbl}Iim{\textquotedbl}} are also permitted. If the string does not contain a valid number, an error is raised.

\begin{quote}
\textbf{Julia 1.1}

\texttt{parse(Bool, str)} requires at least Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> parse(Int, "1234")
1234

julia> parse(Int, "1234", base = 5)
194

julia> parse(Int, "afc", base = 16)
2812

julia> parse(Float64, "1.2e-3")
0.0012

julia> parse(Complex{Float64}, "3.2e-1 + 4.5im")
0.32 + 4.5im
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/parse.jl#L7-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16455869400787770938}{} 
\hyperlink{16455869400787770938}{\texttt{Base.tryparse}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tryparse(type, str; base)
\end{minted}

Like \hyperlink{14207407853646164654}{\texttt{parse}}, but returns either a value of the requested type, or \hyperlink{9331422207248206047}{\texttt{nothing}} if the string does not contain a valid number.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/parse.jl#L226-L231}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2266887946765468938}{} 
\hyperlink{2266887946765468938}{\texttt{Base.big}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
big(x)
\end{minted}

Convert a number to a maximum precision representation (typically \hyperlink{423405808990690832}{\texttt{BigInt}} or \texttt{BigFloat}). See \hyperlink{749816618809421837}{\texttt{BigFloat}} for information about some pitfalls with floating-point numbers.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/gmp.jl#L454-L459}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8153758211648029368}{} 
\hyperlink{8153758211648029368}{\texttt{Base.signed}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
signed(x)
\end{minted}

Convert a number to a signed integer. If the argument is unsigned, it is reinterpreted as signed without checking for overflow.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L161-L166}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5348292453497802071}{} 
\hyperlink{5348292453497802071}{\texttt{Base.unsigned}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unsigned(x) -> Unsigned
\end{minted}

Convert a number to an unsigned integer. If the argument is signed, it is reinterpreted as unsigned without checking for negative values.

\textbf{Examples}


\begin{minted}{jlcon}
julia> unsigned(-2)
0xfffffffffffffffe

julia> unsigned(2)
0x0000000000000002

julia> signed(unsigned(-2))
-2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L140-L157}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6134868769696830446}{} 
\hyperlink{6134868769696830446}{\texttt{Base.float}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
float(x)
\end{minted}

Convert a number or array to a floating point data type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L272-L276}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11312242195671521747}{} 
\hyperlink{11312242195671521747}{\texttt{Base.Math.significand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
significand(x)
\end{minted}

Extract the \texttt{significand(s)} (a.k.a. mantissa), in binary representation, of a floating-point number. If \texttt{x} is a non-zero finite number, then the result will be a number of the same type on the interval  \([1,2)\) . Otherwise \texttt{x} is returned.

\textbf{Examples}


\begin{minted}{jlcon}
julia> significand(15.2)/15.2
0.125

julia> significand(15.2)*8
15.2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L780-L795}{\texttt{source}}


\end{adjustwidth}
\hypertarget{39736318364195845}{} 
\hyperlink{39736318364195845}{\texttt{Base.Math.exponent}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
exponent(x) -> Int
\end{minted}

Get the exponent of a normalized floating-point number.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/math.jl#L761-L765}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16014240202095271744}{} 
\hyperlink{16014240202095271744}{\texttt{Base.complex}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
complex(r, [i])
\end{minted}

Convert real numbers or arrays to complex. \texttt{i} defaults to zero.

\textbf{Examples}


\begin{minted}{jlcon}
julia> complex(7)
7 + 0im

julia> complex([1, 2, 3])
3-element Array{Complex{Int64},1}:
 1 + 0im
 2 + 0im
 3 + 0im
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/complex.jl#L141-L157}{\texttt{source}}


\end{adjustwidth}
\hypertarget{931573217390904193}{} 
\hyperlink{931573217390904193}{\texttt{Base.bswap}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
bswap(n)
\end{minted}

Reverse the byte order of \texttt{n}.

(See also \hyperlink{17463337378549787661}{\texttt{ntoh}} and \hyperlink{17749829108559566344}{\texttt{hton}} to convert between the current native byte order and big-endian order.)

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = bswap(0x10203040)
0x40302010

julia> bswap(a)
0x10203040

julia> string(1, base = 2)
"1"

julia> string(bswap(1), base = 2)
"100000000000000000000000000000000000000000000000000000000"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L303-L324}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7748090932723143403}{} 
\hyperlink{7748090932723143403}{\texttt{Base.hex2bytes}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hex2bytes(s::Union{AbstractString,AbstractVector{UInt8}})
\end{minted}

Given a string or array \texttt{s} of ASCII codes for a sequence of hexadecimal digits, returns a \texttt{Vector\{UInt8\}} of bytes  corresponding to the binary representation: each successive pair of hexadecimal digits in \texttt{s} gives the value of one byte in the return vector.

The length of \texttt{s} must be even, and the returned array has half of the length of \texttt{s}. See also \hyperlink{12258920440597292563}{\texttt{hex2bytes!}} for an in-place version, and \hyperlink{14739363105735559529}{\texttt{bytes2hex}} for the inverse.

\textbf{Examples}


\begin{minted}{jlcon}
julia> s = string(12345, base = 16)
"3039"

julia> hex2bytes(s)
2-element Array{UInt8,1}:
 0x30
 0x39

julia> a = b"01abEF"
6-element Base.CodeUnits{UInt8,String}:
 0x30
 0x31
 0x61
 0x62
 0x45
 0x46

julia> hex2bytes(a)
3-element Array{UInt8,1}:
 0x01
 0xab
 0xef
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L501-L536}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12258920440597292563}{} 
\hyperlink{12258920440597292563}{\texttt{Base.hex2bytes!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hex2bytes!(d::AbstractVector{UInt8}, s::Union{String,AbstractVector{UInt8}})
\end{minted}

Convert an array \texttt{s} of bytes representing a hexadecimal string to its binary representation, similar to \hyperlink{7748090932723143403}{\texttt{hex2bytes}} except that the output is written in-place in \texttt{d}.   The length of \texttt{s} must be exactly twice the length of \texttt{d}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L547-L553}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14739363105735559529}{} 
\hyperlink{14739363105735559529}{\texttt{Base.bytes2hex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
bytes2hex(a::AbstractArray{UInt8}) -> String
bytes2hex(io::IO, a::AbstractArray{UInt8})
\end{minted}

Convert an array \texttt{a} of bytes to its hexadecimal string representation, either returning a \texttt{String} via \texttt{bytes2hex(a)} or writing the string to an \texttt{io} stream via \texttt{bytes2hex(io, a)}.  The hexadecimal characters are all lowercase.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = string(12345, base = 16)
"3039"

julia> b = hex2bytes(a)
2-element Array{UInt8,1}:
 0x30
 0x39

julia> bytes2hex(b)
"3039"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L572-L593}{\texttt{source}}


\end{adjustwidth}

\hypertarget{10637014207943065137}{}


\section{常用数值函数和常量}


\hypertarget{11395333326208453101}{} 
\hyperlink{11395333326208453101}{\texttt{Base.one}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
one(x)
one(T::type)
\end{minted}

Return a multiplicative identity for \texttt{x}: a value such that \texttt{one(x)*x == x*one(x) == x}.  Alternatively \texttt{one(T)} can take a type \texttt{T}, in which case \texttt{one} returns a multiplicative identity for any \texttt{x} of type \texttt{T}.

If possible, \texttt{one(x)} returns a value of the same type as \texttt{x}, and \texttt{one(T)} returns a value of type \texttt{T}.  However, this may not be the case for types representing dimensionful quantities (e.g. time in days), since the multiplicative identity must be dimensionless.  In that case, \texttt{one(x)} should return an identity value of the same precision (and shape, for matrices) as \texttt{x}.

If you want a quantity that is of the same type as \texttt{x}, or of type \texttt{T}, even if \texttt{x} is dimensionful, use \hyperlink{2310843180104103470}{\texttt{oneunit}} instead.

\textbf{Examples}


\begin{minted}{jlcon}
julia> one(3.7)
1.0

julia> one(Int)
1

julia> import Dates; one(Dates.Day(1))
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L244-L275}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2310843180104103470}{} 
\hyperlink{2310843180104103470}{\texttt{Base.oneunit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
oneunit(x::T)
oneunit(T::Type)
\end{minted}

Returns \texttt{T(one(x))}, where \texttt{T} is either the type of the argument or (if a type is passed) the argument.  This differs from \hyperlink{11395333326208453101}{\texttt{one}} for dimensionful quantities: \texttt{one} is dimensionless (a multiplicative identity) while \texttt{oneunit} is dimensionful (of the same type as \texttt{x}, or of type \texttt{T}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> oneunit(3.7)
1.0

julia> import Dates; oneunit(Dates.Day)
1 day
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L281-L298}{\texttt{source}}


\end{adjustwidth}
\hypertarget{240596739242881814}{} 
\hyperlink{240596739242881814}{\texttt{Base.zero}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
zero(x)
\end{minted}

Get the additive identity element for the type of \texttt{x} (\texttt{x} can also specify the type itself).

\textbf{Examples}


\begin{minted}{jlcon}
julia> zero(1)
0

julia> zero(big"2.0")
0.0

julia> zero(rand(2,2))
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L222-L240}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15097910740298861288}{} 
\hyperlink{15097910740298861288}{\texttt{Base.im}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
im
\end{minted}

The imaginary unit.

\textbf{Examples}


\begin{minted}{jlcon}
julia> im * im
-1 + 0im
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/complex.jl#L18-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4355513108985533054}{} 
\hyperlink{4355513108985533054}{\texttt{Base.MathConstants.pi}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
π
pi
\end{minted}

The constant pi.

\textbf{Examples}


\begin{minted}{jlcon}
julia> pi
π = 3.1415926535897...
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/mathconstants.jl#L20-L31}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5995848487717371733}{} 
\hyperlink{5995848487717371733}{\texttt{Base.MathConstants.ℯ}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ℯ
e
\end{minted}

The constant ℯ.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ℯ
ℯ = 2.7182818284590...
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/mathconstants.jl#L34-L45}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8524456009860829844}{} 
\hyperlink{8524456009860829844}{\texttt{Base.MathConstants.catalan}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
catalan
\end{minted}

Catalan{\textquotesingle}s constant.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Base.MathConstants.catalan
catalan = 0.9159655941772...
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/mathconstants.jl#L76-L86}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10414961909538485487}{} 
\hyperlink{10414961909538485487}{\texttt{Base.MathConstants.eulergamma}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
γ
eulergamma
\end{minted}

Euler{\textquotesingle}s constant.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Base.MathConstants.eulergamma
γ = 0.5772156649015...
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/mathconstants.jl#L48-L59}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1981793918228771227}{} 
\hyperlink{1981793918228771227}{\texttt{Base.MathConstants.golden}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
φ
golden
\end{minted}

The golden ratio.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Base.MathConstants.golden
φ = 1.6180339887498...
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/mathconstants.jl#L62-L73}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1907914141659611007}{} 
\hyperlink{1907914141659611007}{\texttt{Base.Inf}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Inf, Inf64
\end{minted}

Positive infinity of type \hyperlink{5027751419500983000}{\texttt{Float64}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L35-L39}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7827423203261078742}{} 
\hyperlink{7827423203261078742}{\texttt{Base.Inf32}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Inf32
\end{minted}

Positive infinity of type \hyperlink{8101639384272933082}{\texttt{Float32}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L19-L23}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7656978911755578336}{} 
\hyperlink{7656978911755578336}{\texttt{Base.Inf16}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Inf16
\end{minted}

Positive infinity of type \hyperlink{2727296760866702904}{\texttt{Float16}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L7-L11}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11449618129446476597}{} 
\hyperlink{11449618129446476597}{\texttt{Base.NaN}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
NaN, NaN64
\end{minted}

A not-a-number value of type \hyperlink{5027751419500983000}{\texttt{Float64}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L43-L47}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3173013683234902743}{} 
\hyperlink{3173013683234902743}{\texttt{Base.NaN32}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
NaN32
\end{minted}

A not-a-number value of type \hyperlink{8101639384272933082}{\texttt{Float32}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L25-L29}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1412633859926300302}{} 
\hyperlink{1412633859926300302}{\texttt{Base.NaN16}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
NaN16
\end{minted}

A not-a-number value of type \hyperlink{2727296760866702904}{\texttt{Float16}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L13-L17}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10864939112775145474}{} 
\hyperlink{10864939112775145474}{\texttt{Base.issubnormal}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issubnormal(f) -> Bool
\end{minted}

Test whether a floating point number is subnormal.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L718-L722}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2906021895910968108}{} 
\hyperlink{2906021895910968108}{\texttt{Base.isfinite}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isfinite(f) -> Bool
\end{minted}

Test whether a number is finite.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isfinite(5)
true

julia> isfinite(NaN32)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L540-L553}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4492113908831448207}{} 
\hyperlink{4492113908831448207}{\texttt{Base.isinf}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isinf(f) -> Bool
\end{minted}

Test whether a number is infinite.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L559-L563}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6770390199496851634}{} 
\hyperlink{6770390199496851634}{\texttt{Base.isnan}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isnan(f) -> Bool
\end{minted}

Test whether a number value is a NaN, an indeterminate value which is neither an infinity nor a finite number ({\textquotedbl}not a number{\textquotedbl}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L530-L535}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17648248624761612718}{} 
\hyperlink{17648248624761612718}{\texttt{Base.iszero}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
iszero(x)
\end{minted}

Return \texttt{true} if \texttt{x == zero(x)}; if \texttt{x} is an array, this checks whether all of the elements of \texttt{x} are zero.

\textbf{Examples}


\begin{minted}{jlcon}
julia> iszero(0.0)
true

julia> iszero([1, 9, 0])
false

julia> iszero([false, 0, 0])
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L22-L39}{\texttt{source}}


\end{adjustwidth}
\hypertarget{253331863485455966}{} 
\hyperlink{253331863485455966}{\texttt{Base.isone}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isone(x)
\end{minted}

Return \texttt{true} if \texttt{x == one(x)}; if \texttt{x} is an array, this checks whether \texttt{x} is an identity matrix.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isone(1.0)
true

julia> isone([1 0; 0 2])
false

julia> isone([1 0; 0 true])
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L42-L59}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8339500090035450608}{} 
\hyperlink{8339500090035450608}{\texttt{Base.nextfloat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nextfloat(x::AbstractFloat, n::Integer)
\end{minted}

The result of \texttt{n} iterative applications of \texttt{nextfloat} to \texttt{x} if \texttt{n >= 0}, or \texttt{-n} applications of \texttt{prevfloat} if \texttt{n < 0}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L603-L608}{\texttt{source}}



\begin{lstlisting}
nextfloat(x::AbstractFloat)
\end{lstlisting}

Return the smallest floating point number \texttt{y} of the same type as \texttt{x} such \texttt{x < y}. If no such \texttt{y} exists (e.g. if \texttt{x} is \texttt{Inf} or \texttt{NaN}), then return \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L647-L652}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14035790731013288499}{} 
\hyperlink{14035790731013288499}{\texttt{Base.prevfloat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
prevfloat(x::AbstractFloat, n::Integer)
\end{minted}

The result of \texttt{n} iterative applications of \texttt{prevfloat} to \texttt{x} if \texttt{n >= 0}, or \texttt{-n} applications of \texttt{nextfloat} if \texttt{n < 0}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L655-L660}{\texttt{source}}



\begin{lstlisting}
prevfloat(x::AbstractFloat)
\end{lstlisting}

Return the largest floating point number \texttt{y} of the same type as \texttt{x} such \texttt{y < x}. If no such \texttt{y} exists (e.g. if \texttt{x} is \texttt{-Inf} or \texttt{NaN}), then return \texttt{x}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L663-L668}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1292047667500506923}{} 
\hyperlink{1292047667500506923}{\texttt{Base.isinteger}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isinteger(x) -> Bool
\end{minted}

Test whether \texttt{x} is numerically equal to some integer.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isinteger(4.0)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/number.jl#L9-L19}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11869977035061433209}{} 
\hyperlink{11869977035061433209}{\texttt{Base.isreal}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isreal(x) -> Bool
\end{minted}

Test whether \texttt{x} or all its elements are numerically equal to some real number including infinities and NaNs. \texttt{isreal(x)} is true if \texttt{isequal(x, real(x))} is true.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isreal(5.)
true

julia> isreal(Inf + 0im)
true

julia> isreal([4.; complex(0,1)])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/complex.jl#L113-L131}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11475816161015002523}{} 
\hyperlink{11475816161015002523}{\texttt{Core.Float32}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Float32(x [, mode::RoundingMode])
\end{minted}

Create a \texttt{Float32} from \texttt{x}. If \texttt{x} is not exactly representable then \texttt{mode} determines how \texttt{x} is rounded.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Float32(1/3, RoundDown)
0.3333333f0

julia> Float32(1/3, RoundUp)
0.33333334f0
\end{minted}

See \hyperlink{16713322195952720212}{\texttt{RoundingMode}} for available rounding modes.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1145-L1161}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5076205197474650253}{} 
\hyperlink{5076205197474650253}{\texttt{Core.Float64}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Float64(x [, mode::RoundingMode])
\end{minted}

Create a \texttt{Float64} from \texttt{x}. If \texttt{x} is not exactly representable then \texttt{mode} determines how \texttt{x} is rounded.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Float64(pi, RoundDown)
3.141592653589793

julia> Float64(pi, RoundUp)
3.1415926535897936
\end{minted}

See \hyperlink{16713322195952720212}{\texttt{RoundingMode}} for available rounding modes.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1164-L1180}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6511778857518292792}{} 
\hyperlink{6511778857518292792}{\texttt{Base.Rounding.rounding}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rounding(T)
\end{minted}

Get the current floating point rounding mode for type \texttt{T}, controlling the rounding of basic arithmetic functions (\hyperlink{3677358729494553841}{\texttt{+}}, \hyperlink{8228207173393714756}{\texttt{-}}, \hyperlink{7592762607639177347}{\texttt{*}}, \hyperlink{4103478871488785445}{\texttt{/}} and \hyperlink{4551113327515323898}{\texttt{sqrt}}) and type conversion.

See \hyperlink{16713322195952720212}{\texttt{RoundingMode}} for available modes.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L143-L151}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12025922235501343815}{} 
\hyperlink{12025922235501343815}{\texttt{Base.Rounding.setrounding}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
setrounding(T, mode)
\end{minted}

Set the rounding mode of floating point type \texttt{T}, controlling the rounding of basic arithmetic functions (\hyperlink{3677358729494553841}{\texttt{+}}, \hyperlink{8228207173393714756}{\texttt{-}}, \hyperlink{7592762607639177347}{\texttt{*}}, \hyperlink{4103478871488785445}{\texttt{/}} and \hyperlink{4551113327515323898}{\texttt{sqrt}}) and type conversion. Other numerical functions may give incorrect or invalid values when using rounding modes other than the default \hyperlink{868115654703135309}{\texttt{RoundNearest}}.

Note that this is currently only supported for \texttt{T == BigFloat}.

\begin{quote}
\textbf{Warning}

This function is not thread-safe. It will affect code running on all threads, but its behavior is undefined if called concurrently with computations that use the setting.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L124-L140}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9774741470027705214}{} 
\hyperlink{9774741470027705214}{\texttt{Base.Rounding.setrounding}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
setrounding(f::Function, T, mode)
\end{minted}

Change the rounding mode of floating point type \texttt{T} for the duration of \texttt{f}. It is logically equivalent to:


\begin{lstlisting}
old = rounding(T)
setrounding(T, mode)
f()
setrounding(T, old)
\end{lstlisting}

See \hyperlink{16713322195952720212}{\texttt{RoundingMode}} for available rounding modes.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L159-L171}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13184231496538414617}{} 
\hyperlink{13184231496538414617}{\texttt{Base.Rounding.get\_zero\_subnormals}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
get_zero_subnormals() -> Bool
\end{minted}

Return \texttt{false} if operations on subnormal floating-point values ({\textquotedbl}denormals{\textquotedbl}) obey rules for IEEE arithmetic, and \texttt{true} if they might be converted to zeros.

\begin{quote}
\textbf{Warning}

This function only affects the current thread.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L237-L246}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2845950135157372113}{} 
\hyperlink{2845950135157372113}{\texttt{Base.Rounding.set\_zero\_subnormals}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
set_zero_subnormals(yes::Bool) -> Bool
\end{minted}

If \texttt{yes} is \texttt{false}, subsequent floating-point operations follow rules for IEEE arithmetic on subnormal values ({\textquotedbl}denormals{\textquotedbl}). Otherwise, floating-point operations are permitted (but not required) to convert subnormal inputs or outputs to zero. Returns \texttt{true} unless \texttt{yes==true} but the hardware does not support zeroing of subnormal numbers.

\texttt{set\_zero\_subnormals(true)} can speed up some computations on some hardware. However, it can break identities such as \texttt{(x-y==0) == (x==y)}.

\begin{quote}
\textbf{Warning}

This function only affects the current thread.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/rounding.jl#L220-L234}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14839704257524522191}{}


\subsection{整型}


\hypertarget{4179288755987827924}{} 
\hyperlink{4179288755987827924}{\texttt{Base.count\_ones}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
count_ones(x::Integer) -> Integer
\end{minted}

Number of ones in the binary representation of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> count_ones(7)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L329-L339}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7870666257802898093}{} 
\hyperlink{7870666257802898093}{\texttt{Base.count\_zeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
count_zeros(x::Integer) -> Integer
\end{minted}

Number of zeros in the binary representation of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> count_zeros(Int32(2 ^ 16 - 1))
16
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L368-L378}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7979293123371436933}{} 
\hyperlink{7979293123371436933}{\texttt{Base.leading\_zeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
leading_zeros(x::Integer) -> Integer
\end{minted}

Number of zeros leading the binary representation of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> leading_zeros(Int32(1))
31
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L342-L352}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9160604458117919092}{} 
\hyperlink{9160604458117919092}{\texttt{Base.leading\_ones}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
leading_ones(x::Integer) -> Integer
\end{minted}

Number of ones leading the binary representation of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> leading_ones(UInt32(2 ^ 32 - 2))
31
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L381-L391}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4757748081622484794}{} 
\hyperlink{4757748081622484794}{\texttt{Base.trailing\_zeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trailing_zeros(x::Integer) -> Integer
\end{minted}

Number of zeros trailing the binary representation of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> trailing_zeros(2)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L355-L365}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1557366507921404436}{} 
\hyperlink{1557366507921404436}{\texttt{Base.trailing\_ones}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trailing_ones(x::Integer) -> Integer
\end{minted}

Number of ones trailing the binary representation of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> trailing_ones(3)
2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L394-L404}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2288006657111547854}{} 
\hyperlink{2288006657111547854}{\texttt{Base.isodd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isodd(x::Integer) -> Bool
\end{minted}

Return \texttt{true} if \texttt{x} is odd (that is, not divisible by 2), and \texttt{false} otherwise.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isodd(9)
true

julia> isodd(10)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L61-L74}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6755629456808693979}{} 
\hyperlink{6755629456808693979}{\texttt{Base.iseven}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
iseven(x::Integer) -> Bool
\end{minted}

Return \texttt{true} is \texttt{x} is even (that is, divisible by 2), and \texttt{false} otherwise.

\textbf{Examples}


\begin{minted}{jlcon}
julia> iseven(9)
false

julia> iseven(10)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L77-L90}{\texttt{source}}


\end{adjustwidth}
\hypertarget{291660922357493034}{} 
\hyperlink{291660922357493034}{\texttt{Core.@int128\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@int128_str str
@int128_str(str)
\end{minted}

\texttt{@int128\_str} parses a string into a Int128 Throws an \texttt{ArgumentError} if the string is not a valid integer



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L538-L544}{\texttt{source}}


\end{adjustwidth}
\hypertarget{325519564013190561}{} 
\hyperlink{325519564013190561}{\texttt{Core.@uint128\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@uint128_str str
@uint128_str(str)
\end{minted}

\texttt{@uint128\_str} parses a string into a UInt128 Throws an \texttt{ArgumentError} if the string is not a valid integer



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L549-L555}{\texttt{source}}


\end{adjustwidth}

\hypertarget{15006469534325680034}{}


\section{BigFloats and BigInts}



The \hyperlink{749816618809421837}{\texttt{BigFloat}} and \hyperlink{423405808990690832}{\texttt{BigInt}} types implements arbitrary-precision floating point and integer arithmetic, respectively. For \hyperlink{749816618809421837}{\texttt{BigFloat}} the \href{https://www.mpfr.org/}{GNU MPFR library} is used, and for \hyperlink{423405808990690832}{\texttt{BigInt}} the \href{https://gmplib.org}{GNU Multiple Precision Arithmetic Library (GMP)} is used.


\hypertarget{9760529761072602961}{} 
\hyperlink{9760529761072602961}{\texttt{Base.MPFR.BigFloat}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
BigFloat(x::Union{Real, AbstractString} [, rounding::RoundingMode=rounding(BigFloat)]; [precision::Integer=precision(BigFloat)])
\end{minted}

Create an arbitrary precision floating point number from \texttt{x}, with precision \texttt{precision}. The \texttt{rounding} argument specifies the direction in which the result should be rounded if the conversion cannot be done exactly. If not provided, these are set by the current global values.

\texttt{BigFloat(x::Real)} is the same as \texttt{convert(BigFloat,x)}, except if \texttt{x} itself is already \texttt{BigFloat}, in which case it will return a value with the precision set to the current global precision; \texttt{convert} will always return \texttt{x}.

\texttt{BigFloat(x::AbstractString)} is identical to \hyperlink{14207407853646164654}{\texttt{parse}}. This is provided for convenience since decimal literals are converted to \texttt{Float64} when parsed, so \texttt{BigFloat(2.1)} may not yield what you expect.

\begin{quote}
\textbf{Julia 1.1}

\texttt{precision} as a keyword argument requires at least Julia 1.1. In Julia 1.0 \texttt{precision} is the second positional argument (\texttt{BigFloat(x, precision)}).

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> BigFloat(2.1) # 2.1 here is a Float64
2.100000000000000088817841970012523233890533447265625

julia> BigFloat("2.1") # the closest BigFloat to 2.1
2.099999999999999999999999999999999999999999999999999999999999999999999999999986

julia> BigFloat("2.1", RoundUp)
2.100000000000000000000000000000000000000000000000000000000000000000000000000021

julia> BigFloat("2.1", RoundUp, precision=128)
2.100000000000000000000000000000000000007
\end{minted}

\textbf{See also}

\begin{itemize}
\item \hyperlink{4226571565562941917}{\texttt{@big\_str}}


\item \hyperlink{6511778857518292792}{\texttt{rounding}} and \hyperlink{12025922235501343815}{\texttt{setrounding}}


\item \hyperlink{13742359768532654153}{\texttt{precision}} and \hyperlink{3543074496498234209}{\texttt{setprecision}}

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/mpfr.jl#L140-L178}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13742359768532654153}{} 
\hyperlink{13742359768532654153}{\texttt{Base.precision}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
precision(num::AbstractFloat)
\end{minted}

Get the precision of a floating point number, as defined by the effective number of bits in the mantissa.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/float.jl#L578-L583}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6555036846799841969}{} 
\hyperlink{6555036846799841969}{\texttt{Base.precision}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
precision(BigFloat)
\end{minted}

Get the precision (in bits) currently used for \hyperlink{749816618809421837}{\texttt{BigFloat}} arithmetic.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/mpfr.jl#L809-L813}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3543074496498234209}{} 
\hyperlink{3543074496498234209}{\texttt{Base.MPFR.setprecision}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
setprecision([T=BigFloat,] precision::Int)
\end{minted}

Set the precision (in bits) to be used for \texttt{T} arithmetic.

\begin{quote}
\textbf{Warning}

This function is not thread-safe. It will affect code running on all threads, but its behavior is undefined if called concurrently with computations that use the setting.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/mpfr.jl#L816-L826}{\texttt{source}}



\begin{lstlisting}
setprecision(f::Function, [T=BigFloat,] precision::Integer)
\end{lstlisting}

Change the \texttt{T} arithmetic precision (in bits) for the duration of \texttt{f}. It is logically equivalent to:


\begin{lstlisting}
old = precision(BigFloat)
setprecision(BigFloat, precision)
f()
setprecision(BigFloat, old)
\end{lstlisting}

Often used as \texttt{setprecision(T, precision) do ... end}

Note: \texttt{nextfloat()}, \texttt{prevfloat()} do not use the precision mentioned by \texttt{setprecision}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/mpfr.jl#L928-L943}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11702055980905109221}{} 
\hyperlink{11702055980905109221}{\texttt{Base.GMP.BigInt}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
BigInt(x)
\end{minted}

Create an arbitrary precision integer. \texttt{x} may be an \texttt{Int} (or anything that can be converted to an \texttt{Int}). The usual mathematical operators are defined for this type, and results are promoted to a \hyperlink{423405808990690832}{\texttt{BigInt}}.

Instances can be constructed from strings via \hyperlink{14207407853646164654}{\texttt{parse}}, or using the \texttt{big} string literal.

\textbf{Examples}


\begin{minted}{jlcon}
julia> parse(BigInt, "42")
42

julia> big"313"
313
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/gmp.jl#L62-L80}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4226571565562941917}{} 
\hyperlink{4226571565562941917}{\texttt{Core.@big\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@big_str str
@big_str(str)
\end{minted}

Parse a string into a \hyperlink{423405808990690832}{\texttt{BigInt}} or \hyperlink{749816618809421837}{\texttt{BigFloat}}, and throw an \texttt{ArgumentError} if the string is not a valid number. For integers \texttt{\_} is allowed in the string as a separator.

\textbf{Examples}


\begin{minted}{jlcon}
julia> big"123_456"
123456

julia> big"7891.5"
7891.5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/int.jl#L560-L576}{\texttt{source}}


\end{adjustwidth}

\hypertarget{7104946044181754749}{}


\chapter{字符串}


\hypertarget{17842511721012314372}{} 
\hyperlink{17842511721012314372}{\texttt{Core.AbstractChar}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

The \texttt{AbstractChar} type is the supertype of all character implementations in Julia. A character represents a Unicode code point, and can be converted to an integer via the \hyperlink{683489308723658065}{\texttt{codepoint}} function in order to obtain the numerical value of the code point, or constructed from the same integer. These numerical values determine how characters are compared with \texttt{<} and \texttt{==}, for example.  New \texttt{T <: AbstractChar} types should define a \texttt{codepoint(::T)} method and a \texttt{T(::UInt32)} constructor, at minimum.

A given \texttt{AbstractChar} subtype may be capable of representing only a subset of Unicode, in which case conversion from an unsupported \texttt{UInt32} value may throw an error. Conversely, the built-in \hyperlink{3463806064296245385}{\texttt{Char}} type represents a \emph{superset} of Unicode (in order to losslessly encode invalid byte streams), in which case conversion of a non-Unicode value \emph{to} \texttt{UInt32} throws an error. The \hyperlink{9678448882095016755}{\texttt{isvalid}} function can be used to check which codepoints are representable in a given \texttt{AbstractChar} type.

Internally, an \texttt{AbstractChar} type may use a variety of encodings.  Conversion via \texttt{codepoint(char)} will not reveal this encoding because it always returns the Unicode value of the character. \texttt{print(io, c)} of any \texttt{c::AbstractChar} produces an encoding determined by \texttt{io} (UTF-8 for all built-in \texttt{IO} types), via conversion to \texttt{Char} if necessary.

\texttt{write(io, c)}, in contrast, may emit an encoding depending on \texttt{typeof(c)}, and \texttt{read(io, typeof(c))} should read the same encoding as \texttt{write}. New \texttt{AbstractChar} types must provide their own implementations of \texttt{write} and \texttt{read}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/char.jl#L3-L30}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3463806064296245385}{} 
\hyperlink{3463806064296245385}{\texttt{Core.Char}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Char(c::Union{Number,AbstractChar})
\end{minted}

\texttt{Char} is a 32-bit \hyperlink{17842511721012314372}{\texttt{AbstractChar}} type that is the default representation of characters in Julia. \texttt{Char} is the type used for character literals like \texttt{{\textquotesingle}x{\textquotesingle}} and it is also the element type of \hyperlink{2825695355940841177}{\texttt{String}}.

In order to losslessly represent arbitrary byte streams stored in a \texttt{String}, a \texttt{Char} value may store information that cannot be converted to a Unicode codepoint — converting such a \texttt{Char} to \texttt{UInt32} will throw an error. The \hyperlink{9678448882095016755}{\texttt{isvalid(c::Char)}} function can be used to query whether \texttt{c} represents a valid Unicode character.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/char.jl#L33-L45}{\texttt{source}}


\end{adjustwidth}
\hypertarget{683489308723658065}{} 
\hyperlink{683489308723658065}{\texttt{Base.codepoint}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
codepoint(c::AbstractChar) -> Integer
\end{minted}

Return the Unicode codepoint (an unsigned integer) corresponding to the character \texttt{c} (or throw an exception if \texttt{c} does not represent a valid character). For \texttt{Char}, this is a \texttt{UInt32} value, but \texttt{AbstractChar} types that represent only a subset of Unicode may return a different-sized integer (e.g. \texttt{UInt8}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/char.jl#L66-L74}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10635384680993060803}{} 
\hyperlink{10635384680993060803}{\texttt{Base.length}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
length(s::AbstractString) -> Int
length(s::AbstractString, i::Integer, j::Integer) -> Int
\end{minted}

The number of characters in string \texttt{s} from indices \texttt{i} through \texttt{j}. This is computed as the number of code unit indices from \texttt{i} to \texttt{j} which are valid character indices. With only a single string argument, this computes the number of characters in the entire string. With \texttt{i} and \texttt{j} arguments it computes the number of indices between \texttt{i} and \texttt{j} inclusive that are valid indices in the string \texttt{s}. In addition to in-bounds values, \texttt{i} may take the out-of-bounds value \texttt{ncodeunits(s) + 1} and \texttt{j} may take the out-of-bounds value \texttt{0}.

See also: \hyperlink{9678448882095016755}{\texttt{isvalid}}, \hyperlink{1775518749150675445}{\texttt{ncodeunits}}, \hyperlink{15780929618270241785}{\texttt{lastindex}}, \hyperlink{11299403048911786045}{\texttt{thisind}}, \hyperlink{7455293228649070526}{\texttt{nextind}}, \hyperlink{15871508897466976220}{\texttt{prevind}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> length("jμΛIα")
5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L325-L346}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1670208154575640673}{} 
\hyperlink{1670208154575640673}{\texttt{Base.sizeof}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sizeof(str::AbstractString)
\end{minted}

Size, in bytes, of the string \texttt{str}. Equal to the number of code units in \texttt{str} multiplied by the size, in bytes, of one code unit in \texttt{str}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sizeof("")
0

julia> sizeof("∀")
3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L142-L156}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10114608239100313924}{} 
\hyperlink{10114608239100313924}{\texttt{Base.:*}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
*(s::Union{AbstractString, AbstractChar}, t::Union{AbstractString, AbstractChar}...) -> AbstractString
\end{minted}

Concatenate strings and/or characters, producing a \hyperlink{2825695355940841177}{\texttt{String}}. This is equivalent to calling the \hyperlink{7919678712989769360}{\texttt{string}} function on the arguments. Concatenation of built-in string types always produces a value of type \texttt{String} but other string types may choose to return a string of a different type as appropriate.

\textbf{Examples}


\begin{minted}{jlcon}
julia> "Hello " * "world"
"Hello world"

julia> 'j' * "ulia"
"julia"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L214-L230}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5729367935110528960}{} 
\hyperlink{5729367935110528960}{\texttt{Base.:{\textasciicircum}}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
^(s::Union{AbstractString,AbstractChar}, n::Integer)
\end{minted}

Repeat a string or character \texttt{n} times. This can also be written as \texttt{repeat(s, n)}.

See also: \hyperlink{15426606278434194584}{\texttt{repeat}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> "Test "^3
"Test Test Test "
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L667-L679}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7919678712989769360}{} 
\hyperlink{7919678712989769360}{\texttt{Base.string}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
string(n::Integer; base::Integer = 10, pad::Integer = 1)
\end{minted}

Convert an integer \texttt{n} to a string in the given \texttt{base}, optionally specifying a number of digits to pad to.


\begin{minted}{jlcon}
julia> string(5, base = 13, pad = 4)
"0005"

julia> string(13, base = 5, pad = 4)
"0023"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/intfuncs.jl#L644-L657}{\texttt{source}}



\begin{lstlisting}
string(xs...)
\end{lstlisting}

Create a string from any values, except \texttt{nothing}, using the \hyperlink{8248717042415202230}{\texttt{print}} function.

\texttt{string} should usually not be defined directly. Instead, define a method \texttt{print(io::IO, x::MyType)}. If \texttt{string(x)} for a certain type needs to be highly efficient, then it may make sense to add a method to \texttt{string} and define \texttt{print(io::IO, x::MyType) = print(io, string(x))} to ensure the functions are consistent.

\textbf{Examples}


\begin{minted}{jlcon}
julia> string("a", 1, true)
"a1true"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/io.jl#L157-L173}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17106633743155423093}{} 
\hyperlink{17106633743155423093}{\texttt{Base.repeat}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
repeat(s::AbstractString, r::Integer)
\end{minted}

Repeat a string \texttt{r} times. This can be written as \texttt{s{\textasciicircum}r}.

See also: \hyperlink{462277561264792021}{\texttt{{\textasciicircum}}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> repeat("ha", 3)
"hahaha"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L652-L664}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12559457455507699304}{} 
\hyperlink{12559457455507699304}{\texttt{Base.repeat}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
repeat(c::AbstractChar, r::Integer) -> String
\end{minted}

Repeat a character \texttt{r} times. This can equivalently be accomplished by calling \hyperlink{462277561264792021}{\texttt{c{\textasciicircum}r}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> repeat('A', 3)
"AAA"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/string.jl#L308-L318}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1022185167898104929}{} 
\hyperlink{1022185167898104929}{\texttt{Base.repr}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
repr(x; context=nothing)
\end{minted}

Create a string from any value using the \hyperlink{14071376285304310153}{\texttt{show}} function. You should not add methods to \texttt{repr}; define a \texttt{show} method instead.

The optional keyword argument \texttt{context} can be set to an \texttt{IO} or \hyperlink{13454403377667762339}{\texttt{IOContext}} object whose attributes are used for the I/O stream passed to \texttt{show}.

Note that \texttt{repr(x)} is usually similar to how the value of \texttt{x} would be entered in Julia.  See also \hyperlink{13076889230390082034}{\texttt{repr(MIME({\textquotedbl}text/plain{\textquotedbl}), x)}} to instead return a {\textquotedbl}pretty-printed{\textquotedbl} version of \texttt{x} designed more for human consumption, equivalent to the REPL display of \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> repr(1)
"1"

julia> repr(zeros(3))
"[0.0, 0.0, 0.0]"

julia> repr(big(1/3))
"0.333333333333333314829616256247390992939472198486328125"

julia> repr(big(1/3), context=:compact => true)
"0.333333"

\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/io.jl#L197-L226}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2825695355940841177}{} 
\hyperlink{2825695355940841177}{\texttt{Core.String}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
String(s::AbstractString)
\end{minted}

Convert a string to a contiguous byte array representation encoded as UTF-8 bytes. This representation is often appropriate for passing strings to C.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/string.jl#L62-L67}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2624824381693370630}{} 
\hyperlink{2624824381693370630}{\texttt{Base.SubString}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SubString(s::AbstractString, i::Integer, j::Integer=lastindex(s))
SubString(s::AbstractString, r::UnitRange{<:Integer})
\end{minted}

Like \hyperlink{13720608614876840481}{\texttt{getindex}}, but returns a view into the parent string \texttt{s} within range \texttt{i:j} or \texttt{r} respectively instead of making a copy.

\textbf{Examples}


\begin{minted}{jlcon}
julia> SubString("abc", 1, 2)
"ab"

julia> SubString("abc", 1:2)
"ab"

julia> SubString("abc", 2)
"bc"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/substring.jl#L3-L21}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11147209877072452260}{} 
\hyperlink{11147209877072452260}{\texttt{Base.transcode}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
transcode(T, src)
\end{minted}

Convert string data between Unicode encodings. \texttt{src} is either a \texttt{String} or a \texttt{Vector\{UIntXX\}} of UTF-XX code units, where \texttt{XX} is 8, 16, or 32. \texttt{T} indicates the encoding of the return value: \texttt{String} to return a (UTF-8 encoded) \texttt{String} or \texttt{UIntXX} to return a \texttt{Vector\{UIntXX\}} of UTF-\texttt{XX} data. (The alias \hyperlink{2619479148155454993}{\texttt{Cwchar\_t}} can also be used as the integer type, for converting \texttt{wchar\_t*} strings used by external C libraries.)

The \texttt{transcode} function succeeds as long as the input data can be reasonably represented in the target encoding; it always succeeds for conversions between UTF-XX encodings, even for invalid Unicode data.

Only conversion to/from UTF-8 is currently supported.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L257-L273}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12370128473268209010}{} 
\hyperlink{12370128473268209010}{\texttt{Base.unsafe\_string}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unsafe_string(p::Ptr{UInt8}, [length::Integer])
\end{minted}

Copy a string from the address of a C-style (NUL-terminated) string encoded as UTF-8. (The pointer can be safely freed afterwards.) If \texttt{length} is specified (the length of the data in bytes), the string does not have to be NUL-terminated.

This function is labeled {\textquotedbl}unsafe{\textquotedbl} because it will crash if \texttt{p} is not a valid memory address to data of the requested length.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/string.jl#L41-L50}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1775518749150675445}{} 
\hyperlink{1775518749150675445}{\texttt{Base.ncodeunits}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ncodeunits(s::AbstractString) -> Int
\end{minted}

Return the number of code units in a string. Indices that are in bounds to access this string must satisfy \texttt{1 ≤ i ≤ ncodeunits(s)}. Not all such indices are valid – they may not be the start of a character, but they will return a code unit value when calling \texttt{codeunit(s,i)}.

See also: \hyperlink{16983098119361955361}{\texttt{codeunit}}, \hyperlink{6593895036014271495}{\texttt{checkbounds}}, \hyperlink{10394541563305653720}{\texttt{sizeof}}, \hyperlink{9362803119463040896}{\texttt{length}}, \hyperlink{15780929618270241785}{\texttt{lastindex}}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L45-L55}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16983098119361955361}{} 
\hyperlink{16983098119361955361}{\texttt{Base.codeunit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
codeunit(s::AbstractString) -> Type{<:Union{UInt8, UInt16, UInt32}}
\end{minted}

Return the code unit type of the given string object. For ASCII, Latin-1, or UTF-8 encoded strings, this would be \texttt{UInt8}; for UCS-2 and UTF-16 it would be \texttt{UInt16}; for UTF-32 it would be \texttt{UInt32}. The unit code type need not be limited to these three types, but it{\textquotesingle}s hard to think of widely used string encodings that don{\textquotesingle}t use one of these units. \texttt{codeunit(s)} is the same as \texttt{typeof(codeunit(s,1))} when \texttt{s} is a non-empty string.

See also: \hyperlink{1775518749150675445}{\texttt{ncodeunits}}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L58-L69}{\texttt{source}}



\begin{lstlisting}
codeunit(s::AbstractString, i::Integer) -> Union{UInt8, UInt16, UInt32}
\end{lstlisting}

Return the code unit value in the string \texttt{s} at index \texttt{i}. Note that


\begin{lstlisting}
codeunit(s, i) :: codeunit(s)
\end{lstlisting}

I.e. the value returned by \texttt{codeunit(s, i)} is of the type returned by \texttt{codeunit(s)}.

See also: \hyperlink{1775518749150675445}{\texttt{ncodeunits}}, \hyperlink{6593895036014271495}{\texttt{checkbounds}}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L72-L83}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17283482973786973382}{} 
\hyperlink{17283482973786973382}{\texttt{Base.codeunits}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
codeunits(s::AbstractString)
\end{minted}

Obtain a vector-like object containing the code units of a string. Returns a \texttt{CodeUnits} wrapper by default, but \texttt{codeunits} may optionally be defined for new string types if necessary.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L712-L718}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16934723397501354088}{} 
\hyperlink{16934723397501354088}{\texttt{Base.ascii}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ascii(s::AbstractString)
\end{minted}

Convert a string to \texttt{String} type and check that it contains only ASCII data, otherwise throwing an \texttt{ArgumentError} indicating the position of the first non-ASCII byte.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ascii("abcdeγfgh")
ERROR: ArgumentError: invalid ASCII at index 6 in "abcdeγfgh"
Stacktrace:
[...]

julia> ascii("abcdefgh")
"abcdefgh"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L619-L635}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8320574829780813411}{} 
\hyperlink{8320574829780813411}{\texttt{Base.@r\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@r_str -> Regex
\end{minted}

Construct a regex, such as \texttt{r{\textquotedbl}{\textasciicircum}[a-z]*\${\textquotedbl}}, without interpolation and unescaping (except for quotation mark \texttt{{\textquotedbl}} which still has to be escaped). The regex also accepts one or more flags, listed after the ending quote, to change its behaviour:

\begin{itemize}
\item \texttt{i} enables case-insensitive matching


\item \texttt{m} treats the \texttt{{\textasciicircum}} and \texttt{\$} tokens as matching the start and end of individual lines, as opposed to the whole string.


\item \texttt{s} allows the \texttt{.} modifier to match newlines.


\item \texttt{x} enables {\textquotedbl}comment mode{\textquotedbl}: whitespace is enabled except when escaped with \texttt{{\textbackslash}}, and \texttt{\#} is treated as starting a comment.


\item \texttt{a} disables \texttt{UCP} mode (enables ASCII mode). By default \texttt{{\textbackslash}B}, \texttt{{\textbackslash}b}, \texttt{{\textbackslash}D}, \texttt{{\textbackslash}d}, \texttt{{\textbackslash}S}, \texttt{{\textbackslash}s}, \texttt{{\textbackslash}W}, \texttt{{\textbackslash}w}, etc. match based on Unicode character properties. With this option, these sequences only match ASCII characters.

\end{itemize}
See \texttt{Regex} if interpolation is needed.

\textbf{Examples}


\begin{minted}{jlcon}
julia> match(r"a+.*b+.*?d$"ism, "Goodbye,\nOh, angry,\nBad world\n")
RegexMatch("angry,\nBad world")
\end{minted}

This regex has the first three flags enabled.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/regex.jl#L83-L108}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16275294768422181757}{} 
\hyperlink{16275294768422181757}{\texttt{Base.SubstitutionString}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SubstitutionString(substr)
\end{minted}

Stores the given string \texttt{substr} as a \texttt{SubstitutionString}, for use in regular expression substitutions. Most commonly constructed using the \hyperlink{10479548868515771509}{\texttt{@s\_str}} macro.


\begin{minted}{jlcon}
julia> SubstitutionString("Hello \\g<name>, it's \\1")
s"Hello \\g<name>, it's \\1"

julia> subst = s"Hello \g<name>, it's \1"
s"Hello \\g<name>, it's \\1"

julia> typeof(subst)
SubstitutionString{String}

\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/regex.jl#L385-L403}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10479548868515771509}{} 
\hyperlink{10479548868515771509}{\texttt{Base.@s\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@s_str -> SubstitutionString
\end{minted}

Construct a substitution string, used for regular expression substitutions.  Within the string, sequences of the form \texttt{{\textbackslash}N} refer to the Nth capture group in the regex, and \texttt{{\textbackslash}g<groupname>} refers to a named capture group with name \texttt{groupname}.


\begin{minted}{jlcon}
julia> msg = "#Hello# from Julia";

julia> replace(msg, r"#(.+)# from (?<from>\w+)" => s"FROM: \g<from>; MESSAGE: \1")
"FROM: Julia; MESSAGE: Hello"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/regex.jl#L419-L432}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3530098139758734654}{} 
\hyperlink{3530098139758734654}{\texttt{Base.@raw\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@raw_str -> String
\end{minted}

Create a raw string without interpolation and unescaping. The exception is that quotation marks still must be escaped. Backslashes escape both quotation marks and other backslashes, but only when a sequence of backslashes precedes a quote character. Thus, 2n backslashes followed by a quote encodes n backslashes and the end of the literal while 2n+1 backslashes followed by a quote encodes n backslashes followed by a quote character.

\textbf{Examples}


\begin{minted}{jlcon}
julia> println(raw"\ $x")
\ $x

julia> println(raw"\"")
"

julia> println(raw"\\\"")
\"

julia> println(raw"\\x \\\"")
\\x \"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/io.jl#L499-L523}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5401350878127948144}{} 
\hyperlink{5401350878127948144}{\texttt{Base.@b\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@b_str
\end{minted}

Create an immutable byte (\texttt{UInt8}) vector using string syntax.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = b"12\x01\x02"
4-element Base.CodeUnits{UInt8,String}:
 0x31
 0x32
 0x01
 0x02

julia> v[2]
0x32
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/io.jl#L476-L493}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3198534740077872140}{} 
\hyperlink{3198534740077872140}{\texttt{Base.Docs.@html\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@html_str -> Docs.HTML
\end{minted}

Create an \texttt{HTML} object from a literal string.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/utils.jl#L37-L41}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4530478957610065001}{} 
\hyperlink{4530478957610065001}{\texttt{Base.Docs.@text\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@text_str -> Docs.Text
\end{minted}

Create a \texttt{Text} object from a literal string.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/utils.jl#L78-L82}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9678448882095016755}{} 
\hyperlink{9678448882095016755}{\texttt{Base.isvalid}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isvalid(value) -> Bool
\end{minted}

Returns \texttt{true} if the given value is valid for its type, which currently can be either \texttt{AbstractChar} or \texttt{String} or \texttt{SubString\{String\}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isvalid(Char(0xd800))
false

julia> isvalid(SubString(String(UInt8[0xfe,0x80,0x80,0x80,0x80,0x80]),1,2))
false

julia> isvalid(Char(0xd799))
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L11-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16014659773986219432}{} 
\hyperlink{16014659773986219432}{\texttt{Base.isvalid}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isvalid(T, value) -> Bool
\end{minted}

Returns \texttt{true} if the given value is valid for that type. Types currently can be either \texttt{AbstractChar} or \texttt{String}. Values for \texttt{AbstractChar} can be of type \texttt{AbstractChar} or \hyperlink{8690996847580776341}{\texttt{UInt32}}. Values for \texttt{String} can be of that type, or \texttt{Vector\{UInt8\}} or \texttt{SubString\{String\}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isvalid(Char, 0xd800)
false

julia> isvalid(String, SubString("thisisvalid",1,5))
true

julia> isvalid(Char, 0xd799)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L31-L49}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10276715660934277801}{} 
\hyperlink{10276715660934277801}{\texttt{Base.isvalid}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isvalid(s::AbstractString, i::Integer) -> Bool
\end{minted}

Predicate indicating whether the given index is the start of the encoding of a character in \texttt{s} or not. If \texttt{isvalid(s, i)} is true then \texttt{s[i]} will return the character whose encoding starts at that index, if it{\textquotesingle}s false, then \texttt{s[i]} will raise an invalid index error or a bounds error depending on if \texttt{i} is in bounds. In order for \texttt{isvalid(s, i)} to be an O(1) function, the encoding of \texttt{s} must be \href{https://en.wikipedia.org/wiki/Self-synchronizing\_code}{self-synchronizing} this is a basic assumption of Julia{\textquotesingle}s generic string support.

See also: \hyperlink{13720608614876840481}{\texttt{getindex}}, \hyperlink{1722534687975587846}{\texttt{iterate}}, \hyperlink{11299403048911786045}{\texttt{thisind}}, \hyperlink{7455293228649070526}{\texttt{nextind}}, \hyperlink{15871508897466976220}{\texttt{prevind}}, \hyperlink{9362803119463040896}{\texttt{length}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> str = "αβγdef";

julia> isvalid(str, 1)
true

julia> str[1]
'α': Unicode U+03B1 (category Ll: Letter, lowercase)

julia> isvalid(str, 2)
false

julia> str[2]
ERROR: StringIndexError("αβγdef", 2)
Stacktrace:
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L87-L120}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2695862412477105800}{} 
\hyperlink{2695862412477105800}{\texttt{Base.match}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
match(r::Regex, s::AbstractString[, idx::Integer[, addopts]])
\end{minted}

Search for the first match of the regular expression \texttt{r} in \texttt{s} and return a \texttt{RegexMatch} object containing the match, or nothing if the match failed. The matching substring can be retrieved by accessing \texttt{m.match} and the captured sequences can be retrieved by accessing \texttt{m.captures} The optional \texttt{idx} argument specifies an index at which to start the search.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rx = r"a(.)a"
r"a(.)a"

julia> m = match(rx, "cabac")
RegexMatch("aba", 1="b")

julia> m.captures
1-element Array{Union{Nothing, SubString{String}},1}:
 "b"

julia> m.match
"aba"

julia> match(rx, "cabac", 3) === nothing
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/regex.jl#L245-L271}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2810316550892708557}{} 
\hyperlink{2810316550892708557}{\texttt{Base.eachmatch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eachmatch(r::Regex, s::AbstractString; overlap::Bool=false)
\end{minted}

Search for all matches of a the regular expression \texttt{r} in \texttt{s} and return a iterator over the matches. If overlap is \texttt{true}, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from distinct character ranges.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rx = r"a.a"
r"a.a"

julia> m = eachmatch(rx, "a1a2a3a")
Base.RegexMatchIterator(r"a.a", "a1a2a3a", false)

julia> collect(m)
2-element Array{RegexMatch,1}:
 RegexMatch("a1a")
 RegexMatch("a3a")

julia> collect(eachmatch(rx, "a1a2a3a", overlap = true))
3-element Array{RegexMatch,1}:
 RegexMatch("a1a")
 RegexMatch("a2a")
 RegexMatch("a3a")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/regex.jl#L565-L591}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8569460931372581795}{} 
\hyperlink{8569460931372581795}{\texttt{Base.isless}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isless(a::AbstractString, b::AbstractString) -> Bool
\end{minted}

Test whether string \texttt{a} comes before string \texttt{b} in alphabetical order (technically, in lexicographical order by Unicode code points).

\textbf{Examples}


\begin{minted}{jlcon}
julia> isless("a", "b")
true

julia> isless("β", "α")
false

julia> isless("a", "a")
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L297-L314}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1134770895107848480}{} 
\hyperlink{1134770895107848480}{\texttt{Base.:==}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
==(a::AbstractString, b::AbstractString) -> Bool
\end{minted}

Test whether two strings are equal character by character (technically, Unicode code point by code point).

\textbf{Examples}


\begin{minted}{jlcon}
julia> "abc" == "abc"
true

julia> "abc" == "αβγ"
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L280-L294}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3848352610359377999}{} 
\hyperlink{3848352610359377999}{\texttt{Base.cmp}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cmp(a::AbstractString, b::AbstractString) -> Int
\end{minted}

Compare two strings. Return \texttt{0} if both strings have the same length and the character at each index is the same in both strings. Return \texttt{-1} if \texttt{a} is a prefix of \texttt{b}, or if \texttt{a} comes before \texttt{b} in alphabetical order. Return \texttt{1} if \texttt{b} is a prefix of \texttt{a}, or if \texttt{b} comes before \texttt{a} in alphabetical order (technically, lexicographical order by Unicode code points).

\textbf{Examples}


\begin{minted}{jlcon}
julia> cmp("abc", "abc")
0

julia> cmp("ab", "abc")
-1

julia> cmp("abc", "ab")
1

julia> cmp("ab", "ac")
-1

julia> cmp("ac", "ab")
1

julia> cmp("α", "a")
1

julia> cmp("b", "β")
-1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L237-L269}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3722145084740074291}{} 
\hyperlink{3722145084740074291}{\texttt{Base.lpad}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lpad(s, n::Integer, p::Union{AbstractChar,AbstractString}=' ') -> String
\end{minted}

Stringify \texttt{s} and pad the resulting string on the left with \texttt{p} to make it \texttt{n} characters (code points) long. If \texttt{s} is already \texttt{n} characters long, an equal string is returned. Pad with spaces by default.

\textbf{Examples}


\begin{minted}{jlcon}
julia> lpad("March", 10)
"     March"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L226-L238}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12508684325429723537}{} 
\hyperlink{12508684325429723537}{\texttt{Base.rpad}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rpad(s, n::Integer, p::Union{AbstractChar,AbstractString}=' ') -> String
\end{minted}

Stringify \texttt{s} and pad the resulting string on the right with \texttt{p} to make it \texttt{n} characters (code points) long. If \texttt{s} is already \texttt{n} characters long, an equal string is returned. Pad with spaces by default.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rpad("March", 20)
"March               "
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L253-L265}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17790464283749157857}{} 
\hyperlink{17790464283749157857}{\texttt{Base.findfirst}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findfirst(pattern::AbstractString, string::AbstractString)
findfirst(pattern::Regex, string::String)
\end{minted}

Find the first occurrence of \texttt{pattern} in \texttt{string}. Equivalent to \hyperlink{9906000186778518011}{\texttt{findnext(pattern, string, firstindex(s))}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> findfirst("z", "Hello to the world") # returns nothing, but not printed in the REPL

julia> findfirst("Julia", "JuliaLang")
1:5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/search.jl#L89-L103}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2491646810354884982}{} 
\hyperlink{2491646810354884982}{\texttt{Base.findnext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findnext(pattern::AbstractString, string::AbstractString, start::Integer)
findnext(pattern::Regex, string::String, start::Integer)
\end{minted}

Find the next occurrence of \texttt{pattern} in \texttt{string} starting at position \texttt{start}. \texttt{pattern} can be either a string, or a regular expression, in which case \texttt{string} must be of type \texttt{String}.

The return value is a range of indices where the matching sequence is found, such that \texttt{s[findnext(x, s, i)] == x}:

\texttt{findnext({\textquotedbl}substring{\textquotedbl}, string, i)} == \texttt{start:stop} such that \texttt{string[start:stop] == {\textquotedbl}substring{\textquotedbl}} and \texttt{i <= start}, or \texttt{nothing} if unmatched.

\textbf{Examples}


\begin{minted}{jlcon}
julia> findnext("z", "Hello to the world", 1) === nothing
true

julia> findnext("o", "Hello to the world", 6)
8:8

julia> findnext("Lang", "JuliaLang", 2)
6:9
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/search.jl#L249-L274}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17670820783371803126}{} 
\hyperlink{17670820783371803126}{\texttt{Base.findnext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findnext(ch::AbstractChar, string::AbstractString, start::Integer)
\end{minted}

Find the next occurrence of character \texttt{ch} in \texttt{string} starting at position \texttt{start}.

\begin{quote}
\textbf{Julia 1.3}

This method requires at least Julia 1.3.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> findnext('z', "Hello to the world", 1) === nothing
true

julia> findnext('o', "Hello to the world", 6)
8
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/search.jl#L277-L293}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9131404165887186379}{} 
\hyperlink{9131404165887186379}{\texttt{Base.findlast}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findlast(pattern::AbstractString, string::AbstractString)
\end{minted}

Find the last occurrence of \texttt{pattern} in \texttt{string}. Equivalent to \hyperlink{3864667477361062614}{\texttt{findprev(pattern, string, lastindex(string))}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> findlast("o", "Hello to the world")
15:15

julia> findfirst("Julia", "JuliaLang")
1:5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/search.jl#L297-L311}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17692183083231057658}{} 
\hyperlink{17692183083231057658}{\texttt{Base.findlast}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findlast(ch::AbstractChar, string::AbstractString)
\end{minted}

Find the last occurrence of character \texttt{ch} in \texttt{string}.

\begin{quote}
\textbf{Julia 1.3}

This method requires at least Julia 1.3.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> findlast('p', "happy")
4

julia> findlast('z', "happy") === nothing
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/search.jl#L315-L331}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16511176906297413591}{} 
\hyperlink{16511176906297413591}{\texttt{Base.findprev}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findprev(pattern::AbstractString, string::AbstractString, start::Integer)
\end{minted}

Find the previous occurrence of \texttt{pattern} in \texttt{string} starting at position \texttt{start}.

The return value is a range of indices where the matching sequence is found, such that \texttt{s[findprev(x, s, i)] == x}:

\texttt{findprev({\textquotedbl}substring{\textquotedbl}, string, i)} == \texttt{start:stop} such that \texttt{string[start:stop] == {\textquotedbl}substring{\textquotedbl}} and \texttt{stop <= i}, or \texttt{nothing} if unmatched.

\textbf{Examples}


\begin{minted}{jlcon}
julia> findprev("z", "Hello to the world", 18) === nothing
true

julia> findprev("o", "Hello to the world", 18)
15:15

julia> findprev("Julia", "JuliaLang", 6)
1:5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/search.jl#L464-L486}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7988132114328914630}{} 
\hyperlink{7988132114328914630}{\texttt{Base.occursin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
occursin(needle::Union{AbstractString,Regex,AbstractChar}, haystack::AbstractString)
\end{minted}

Determine whether the first argument is a substring of the second. If \texttt{needle} is a regular expression, checks whether \texttt{haystack} contains a match.

\textbf{Examples}


\begin{minted}{jlcon}
julia> occursin("Julia", "JuliaLang is pretty cool!")
true

julia> occursin('a', "JuliaLang is pretty cool!")
true

julia> occursin(r"a.a", "aba")
true

julia> occursin(r"a.a", "abba")
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/search.jl#L509-L529}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14584532121712292440}{} 
\hyperlink{14584532121712292440}{\texttt{Base.reverse}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reverse(s::AbstractString) -> AbstractString
\end{minted}

Reverses a string. Technically, this function reverses the codepoints in a string and its main utility is for reversed-order string processing, especially for reversed regular-expression searches. See also \hyperlink{16812685153025781176}{\texttt{reverseind}} to convert indices in \texttt{s} to indices in \texttt{reverse(s)} and vice-versa, and \texttt{graphemes} from module \texttt{Unicode} to operate on user-visible {\textquotedbl}characters{\textquotedbl} (graphemes) rather than codepoints. See also \hyperlink{12943296479800134710}{\texttt{Iterators.reverse}} for reverse-order iteration without making a copy. Custom string types must implement the \texttt{reverse} function themselves and should typically return a string with the same type and encoding. If they return a string with a different encoding, they must also override \texttt{reverseind} for that string type to satisfy \texttt{s[reverseind(s,i)] == reverse(s)[i]}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> reverse("JuliaLang")
"gnaLailuJ"

julia> reverse("ax̂e") # combining characters can lead to surprising results
"êxa"

julia> using Unicode

julia> join(reverse(collect(graphemes("ax̂e")))) # reverses graphemes
"ex̂a"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/substring.jl#L116-L143}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17541271486456290686}{} 
\hyperlink{17541271486456290686}{\texttt{Base.replace}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
replace(s::AbstractString, pat=>r; [count::Integer])
\end{minted}

Search for the given pattern \texttt{pat} in \texttt{s}, and replace each occurrence with \texttt{r}. If \texttt{count} is provided, replace at most \texttt{count} occurrences. \texttt{pat} may be a single character, a vector or a set of characters, a string, or a regular expression. If \texttt{r} is a function, each occurrence is replaced with \texttt{r(s)} where \texttt{s} is the matched substring (when \texttt{pat} is a \texttt{Regex} or \texttt{AbstractString}) or character (when \texttt{pat} is an \texttt{AbstractChar} or a collection of \texttt{AbstractChar}). If \texttt{pat} is a regular expression and \texttt{r} is a \hyperlink{16275294768422181757}{\texttt{SubstitutionString}}, then capture group references in \texttt{r} are replaced with the corresponding matched text. To remove instances of \texttt{pat} from \texttt{string}, set \texttt{r} to the empty \texttt{String} (\texttt{{\textquotedbl}{\textquotedbl}}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> replace("Python is a programming language.", "Python" => "Julia")
"Julia is a programming language."

julia> replace("The quick foxes run quickly.", "quick" => "slow", count=1)
"The slow foxes run quickly."

julia> replace("The quick foxes run quickly.", "quick" => "", count=1)
"The  foxes run quickly."

julia> replace("The quick foxes run quickly.", r"fox(es)?" => s"bus\1")
"The quick buses run quickly."
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L465-L493}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8368077469888537439}{} 
\hyperlink{8368077469888537439}{\texttt{Base.split}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
split(str::AbstractString, dlm; limit::Integer=0, keepempty::Bool=true)
split(str::AbstractString; limit::Integer=0, keepempty::Bool=false)
\end{minted}

Split \texttt{str} into an array of substrings on occurrences of the delimiter(s) \texttt{dlm}.  \texttt{dlm} can be any of the formats allowed by \hyperlink{9906000186778518011}{\texttt{findnext}}{\textquotesingle}s first argument (i.e. as a string, regular expression or a function), or as a single character or collection of characters.

If \texttt{dlm} is omitted, it defaults to \hyperlink{774253773882022491}{\texttt{isspace}}.

The optional keyword arguments are:

\begin{itemize}
\item \texttt{limit}: the maximum size of the result. \texttt{limit=0} implies no maximum (default)


\item \texttt{keepempty}: whether empty fields should be kept in the result. Default is \texttt{false} without a \texttt{dlm} argument, \texttt{true} with a \texttt{dlm} argument.

\end{itemize}
See also \hyperlink{15507349251888266905}{\texttt{rsplit}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = "Ma.rch"
"Ma.rch"

julia> split(a,".")
2-element Array{SubString{String},1}:
 "Ma"
 "rch"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L280-L308}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15507349251888266905}{} 
\hyperlink{15507349251888266905}{\texttt{Base.rsplit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rsplit(s::AbstractString; limit::Integer=0, keepempty::Bool=false)
rsplit(s::AbstractString, chars; limit::Integer=0, keepempty::Bool=true)
\end{minted}

Similar to \hyperlink{8368077469888537439}{\texttt{split}}, but starting from the end of the string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = "M.a.r.c.h"
"M.a.r.c.h"

julia> rsplit(a,".")
5-element Array{SubString{String},1}:
 "M"
 "a"
 "r"
 "c"
 "h"

julia> rsplit(a,".";limit=1)
1-element Array{SubString{String},1}:
 "M.a.r.c.h"

julia> rsplit(a,".";limit=2)
2-element Array{SubString{String},1}:
 "M.a.r.c"
 "h"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L354-L382}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7002432768371197450}{} 
\hyperlink{7002432768371197450}{\texttt{Base.strip}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
strip([pred=isspace,] str::AbstractString) -> SubString
strip(str::AbstractString, chars) -> SubString
\end{minted}

Remove leading and trailing characters from \texttt{str}, either those specified by \texttt{chars} or those for which the function \texttt{pred} returns \texttt{true}.

The default behaviour is to remove leading whitespace and delimiters: see \hyperlink{774253773882022491}{\texttt{isspace}} for precise details.

The optional \texttt{chars} argument specifies which characters to remove: it can be a single character, vector or set of characters.

\begin{quote}
\textbf{Julia 1.2}

The method which accepts a predicate function requires Julia 1.2 or later.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> strip("{3, 5}\n", ['{', '}', '\n'])
"3, 5"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L198-L219}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7433804272240772935}{} 
\hyperlink{7433804272240772935}{\texttt{Base.lstrip}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lstrip([pred=isspace,] str::AbstractString) -> SubString
lstrip(str::AbstractString, chars) -> SubString
\end{minted}

Remove leading characters from \texttt{str}, either those specified by \texttt{chars} or those for which the function \texttt{pred} returns \texttt{true}.

The default behaviour is to remove leading whitespace and delimiters: see \hyperlink{774253773882022491}{\texttt{isspace}} for precise details.

The optional \texttt{chars} argument specifies which characters to remove: it can be a single character, or a vector or set of characters.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = lpad("March", 20)
"               March"

julia> lstrip(a)
"March"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L135-L156}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8645844793440900923}{} 
\hyperlink{8645844793440900923}{\texttt{Base.rstrip}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rstrip([pred=isspace,] str::AbstractString) -> SubString
rstrip(str::AbstractString, chars) -> SubString
\end{minted}

Remove trailing characters from \texttt{str}, either those specified by \texttt{chars} or those for which the function \texttt{pred} returns \texttt{true}.

The default behaviour is to remove trailing whitespace and delimiters: see \hyperlink{774253773882022491}{\texttt{isspace}} for precise details.

The optional \texttt{chars} argument specifies which characters to remove: it can be a single character, or a vector or set of characters.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = rpad("March", 20)
"March               "

julia> rstrip(a)
"March"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L167-L188}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3780640516028077129}{} 
\hyperlink{3780640516028077129}{\texttt{Base.startswith}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
startswith(s::AbstractString, prefix::AbstractString)
\end{minted}

Return \texttt{true} if \texttt{s} starts with \texttt{prefix}. If \texttt{prefix} is a vector or set of characters, test whether the first character of \texttt{s} belongs to that set.

See also \hyperlink{7763134966257769023}{\texttt{endswith}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> startswith("JuliaLang", "Julia")
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L7-L20}{\texttt{source}}



\begin{lstlisting}
startswith(s::AbstractString, prefix::Regex)
\end{lstlisting}

Return \texttt{true} if \texttt{s} starts with the regex pattern, \texttt{prefix}.

\begin{quote}
\textbf{Note}

\texttt{startswith} does not compile the anchoring into the regular expression, but instead passes the anchoring as \texttt{match\_option} to PCRE. If compile time is amortized, \texttt{occursin(r{\textquotedbl}{\textasciicircum}...{\textquotedbl}, s)} is faster than \texttt{startswith(s, r{\textquotedbl}...{\textquotedbl})}.

\end{quote}
See also \hyperlink{7988132114328914630}{\texttt{occursin}} and \hyperlink{7763134966257769023}{\texttt{endswith}}.

\begin{quote}
\textbf{Julia 1.2}

This method requires at least Julia 1.2.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> startswith("JuliaLang", r"Julia|Romeo")
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/regex.jl#L181-L202}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7763134966257769023}{} 
\hyperlink{7763134966257769023}{\texttt{Base.endswith}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
endswith(s::AbstractString, suffix::AbstractString)
\end{minted}

Return \texttt{true} if \texttt{s} ends with \texttt{suffix}. If \texttt{suffix} is a vector or set of characters, test whether the last character of \texttt{s} belongs to that set.

See also \hyperlink{3780640516028077129}{\texttt{startswith}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> endswith("Sunday", "day")
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L27-L40}{\texttt{source}}



\begin{lstlisting}
endswith(s::AbstractString, suffix::Regex)
\end{lstlisting}

Return \texttt{true} if \texttt{s} ends with the regex pattern, \texttt{suffix}.

\begin{quote}
\textbf{Note}

\texttt{endswith} does not compile the anchoring into the regular expression, but instead passes the anchoring as \texttt{match\_option} to PCRE. If compile time is amortized, \texttt{occursin(r{\textquotedbl}...\${\textquotedbl}, s)} is faster than \texttt{endswith(s, r{\textquotedbl}...{\textquotedbl})}.

\end{quote}
See also \hyperlink{7988132114328914630}{\texttt{occursin}} and \hyperlink{3780640516028077129}{\texttt{startswith}}.

\begin{quote}
\textbf{Julia 1.2}

This method requires at least Julia 1.2.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> endswith("JuliaLang", r"Lang|Roberts")
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/regex.jl#L213-L234}{\texttt{source}}


\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Base.contains}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{10538250976171410519}{} 
\hyperlink{10538250976171410519}{\texttt{Base.first}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
first(s::AbstractString, n::Integer)
\end{minted}

Get a string consisting of the first \texttt{n} characters of \texttt{s}.


\begin{minted}{jlcon}
julia> first("∀ϵ≠0: ϵ²>0", 0)
""

julia> first("∀ϵ≠0: ϵ²>0", 1)
"∀"

julia> first("∀ϵ≠0: ϵ²>0", 3)
"∀ϵ≠"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L596-L611}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14768252027631185795}{} 
\hyperlink{14768252027631185795}{\texttt{Base.last}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
last(s::AbstractString, n::Integer)
\end{minted}

Get a string consisting of the last \texttt{n} characters of \texttt{s}.


\begin{minted}{jlcon}
julia> last("∀ϵ≠0: ϵ²>0", 0)
""

julia> last("∀ϵ≠0: ϵ²>0", 1)
"0"

julia> last("∀ϵ≠0: ϵ²>0", 3)
"²>0"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L614-L629}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3820837624621500945}{} 
\hyperlink{3820837624621500945}{\texttt{Base.Unicode.uppercase}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
uppercase(s::AbstractString)
\end{minted}

Return \texttt{s} with all characters converted to uppercase.

\textbf{Examples}


\begin{minted}{jlcon}
julia> uppercase("Julia")
"JULIA"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L507-L517}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1268691712877286833}{} 
\hyperlink{1268691712877286833}{\texttt{Base.Unicode.lowercase}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lowercase(s::AbstractString)
\end{minted}

Return \texttt{s} with all characters converted to lowercase.

\textbf{Examples}


\begin{minted}{jlcon}
julia> lowercase("STRINGS AND THINGS")
"strings and things"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L520-L530}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4707563025366615926}{} 
\hyperlink{4707563025366615926}{\texttt{Base.Unicode.titlecase}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
titlecase(s::AbstractString; [wordsep::Function], strict::Bool=true) -> String
\end{minted}

Capitalize the first character of each word in \texttt{s}; if \texttt{strict} is true, every other character is converted to lowercase, otherwise they are left unchanged. By default, all non-letters are considered as word separators; a predicate can be passed as the \texttt{wordsep} keyword to determine which characters should be considered as word separators. See also \hyperlink{17133955858733933884}{\texttt{uppercasefirst}} to capitalize only the first character in \texttt{s}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> titlecase("the JULIA programming language")
"The Julia Programming Language"

julia> titlecase("ISS - international space station", strict=false)
"ISS - International Space Station"

julia> titlecase("a-a b-b", wordsep = c->c==' ')
"A-a B-b"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L533-L556}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17133955858733933884}{} 
\hyperlink{17133955858733933884}{\texttt{Base.Unicode.uppercasefirst}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
uppercasefirst(s::AbstractString) -> String
\end{minted}

Return \texttt{s} with the first character converted to uppercase (technically {\textquotedbl}title case{\textquotedbl} for Unicode). See also \hyperlink{4707563025366615926}{\texttt{titlecase}} to capitalize the first character of every word in \texttt{s}.

See also: \hyperlink{8884363915338850304}{\texttt{lowercasefirst}}, \hyperlink{3820837624621500945}{\texttt{uppercase}}, \hyperlink{1268691712877286833}{\texttt{lowercase}}, \hyperlink{4707563025366615926}{\texttt{titlecase}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> uppercasefirst("python")
"Python"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L572-L587}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8884363915338850304}{} 
\hyperlink{8884363915338850304}{\texttt{Base.Unicode.lowercasefirst}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lowercasefirst(s::AbstractString)
\end{minted}

Return \texttt{s} with the first character converted to lowercase.

See also: \hyperlink{17133955858733933884}{\texttt{uppercasefirst}}, \hyperlink{3820837624621500945}{\texttt{uppercase}}, \hyperlink{1268691712877286833}{\texttt{lowercase}}, \hyperlink{4707563025366615926}{\texttt{titlecase}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> lowercasefirst("Julia")
"julia"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L596-L609}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18064910688022011979}{} 
\hyperlink{18064910688022011979}{\texttt{Base.join}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
join([io::IO,] strings [, delim [, last]])
\end{minted}

Join an array of \texttt{strings} into a single string, inserting the given delimiter (if any) between adjacent strings. If \texttt{last} is given, it will be used instead of \texttt{delim} between the last two strings. If \texttt{io} is given, the result is written to \texttt{io} rather than returned as as a \texttt{String}.

\texttt{strings} can be any iterable over elements \texttt{x} which are convertible to strings via \texttt{print(io::IOBuffer, x)}. \texttt{strings} will be printed to \texttt{io}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> join(["apples", "bananas", "pineapples"], ", ", " and ")
"apples, bananas and pineapples"

julia> join([1,2,3,4,5])
"12345"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/io.jl#L254-L273}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18002354026785919806}{} 
\hyperlink{18002354026785919806}{\texttt{Base.chop}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
chop(s::AbstractString; head::Integer = 0, tail::Integer = 1)
\end{minted}

Remove the first \texttt{head} and the last \texttt{tail} characters from \texttt{s}. The call \texttt{chop(s)} removes the last character from \texttt{s}. If it is requested to remove more characters than \texttt{length(s)} then an empty string is returned.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = "March"
"March"

julia> chop(a)
"Marc"

julia> chop(a, head = 1, tail = 2)
"ar"

julia> chop(a, head = 5, tail = 5)
""
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L73-L95}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5360081372937794006}{} 
\hyperlink{5360081372937794006}{\texttt{Base.chomp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
chomp(s::AbstractString) -> SubString
\end{minted}

Remove a single trailing newline from a string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> chomp("Hello\n")
"Hello"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/util.jl#L106-L116}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11299403048911786045}{} 
\hyperlink{11299403048911786045}{\texttt{Base.thisind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
thisind(s::AbstractString, i::Integer) -> Int
\end{minted}

If \texttt{i} is in bounds in \texttt{s} return the index of the start of the character whose encoding code unit \texttt{i} is part of. In other words, if \texttt{i} is the start of a character, return \texttt{i}; if \texttt{i} is not the start of a character, rewind until the start of a character and return that index. If \texttt{i} is equal to 0 or \texttt{ncodeunits(s)+1} return \texttt{i}. In all other cases throw \texttt{BoundsError}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> thisind("α", 0)
0

julia> thisind("α", 1)
1

julia> thisind("α", 2)
1

julia> thisind("α", 3)
3

julia> thisind("α", 4)
ERROR: BoundsError: attempt to access String
  at index [4]
[...]

julia> thisind("α", -1)
ERROR: BoundsError: attempt to access String
  at index [-1]
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L364-L397}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7455293228649070526}{} 
\hyperlink{7455293228649070526}{\texttt{Base.nextind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nextind(str::AbstractString, i::Integer, n::Integer=1) -> Int
\end{minted}

\begin{itemize}
\item Case \texttt{n == 1}

If \texttt{i} is in bounds in \texttt{s} return the index of the start of the character whose encoding starts after index \texttt{i}. In other words, if \texttt{i} is the start of a character, return the start of the next character; if \texttt{i} is not the start of a character, move forward until the start of a character and return that index. If \texttt{i} is equal to \texttt{0} return \texttt{1}. If \texttt{i} is in bounds but greater or equal to \texttt{lastindex(str)} return \texttt{ncodeunits(str)+1}. Otherwise throw \texttt{BoundsError}.


\item Case \texttt{n > 1}

Behaves like applying \texttt{n} times \texttt{nextind} for \texttt{n==1}. The only difference is that if \texttt{n} is so large that applying \texttt{nextind} would reach \texttt{ncodeunits(str)+1} then each remaining iteration increases the returned value by \texttt{1}. This means that in this case \texttt{nextind} can return a value greater than \texttt{ncodeunits(str)+1}.


\item Case \texttt{n == 0}

Return \texttt{i} only if \texttt{i} is a valid index in \texttt{s} or is equal to \texttt{0}. Otherwise \texttt{StringIndexError} or \texttt{BoundsError} is thrown.

\end{itemize}
\textbf{Examples}


\begin{minted}{jlcon}
julia> nextind("α", 0)
1

julia> nextind("α", 1)
3

julia> nextind("α", 3)
ERROR: BoundsError: attempt to access String
  at index [3]
[...]

julia> nextind("α", 0, 2)
3

julia> nextind("α", 1, 2)
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L470-L514}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15871508897466976220}{} 
\hyperlink{15871508897466976220}{\texttt{Base.prevind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
prevind(str::AbstractString, i::Integer, n::Integer=1) -> Int
\end{minted}

\begin{itemize}
\item Case \texttt{n == 1}

If \texttt{i} is in bounds in \texttt{s} return the index of the start of the character whose encoding starts before index \texttt{i}. In other words, if \texttt{i} is the start of a character, return the start of the previous character; if \texttt{i} is not the start of a character, rewind until the start of a character and return that index. If \texttt{i} is equal to \texttt{1} return \texttt{0}. If \texttt{i} is equal to \texttt{ncodeunits(str)+1} return \texttt{lastindex(str)}. Otherwise throw \texttt{BoundsError}.


\item Case \texttt{n > 1}

Behaves like applying \texttt{n} times \texttt{prevind} for \texttt{n==1}. The only difference is that if \texttt{n} is so large that applying \texttt{prevind} would reach \texttt{0} then each remaining iteration decreases the returned value by \texttt{1}. This means that in this case \texttt{prevind} can return a negative value.


\item Case \texttt{n == 0}

Return \texttt{i} only if \texttt{i} is a valid index in \texttt{str} or is equal to \texttt{ncodeunits(str)+1}. Otherwise \texttt{StringIndexError} or \texttt{BoundsError} is thrown.

\end{itemize}
\textbf{Examples}


\begin{minted}{jlcon}
julia> prevind("α", 3)
1

julia> prevind("α", 1)
0

julia> prevind("α", 0)
ERROR: BoundsError: attempt to access String
  at index [0]
[...]

julia> prevind("α", 2, 2)
0

julia> prevind("α", 2, 3)
-1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L410-L454}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16270671982929669109}{} 
\hyperlink{16270671982929669109}{\texttt{Base.Unicode.textwidth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
textwidth(c)
\end{minted}

Give the number of columns needed to print a character.

\textbf{Examples}


\begin{minted}{jlcon}
julia> textwidth('α')
1

julia> textwidth('⛵')
2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L213-L226}{\texttt{source}}



\begin{lstlisting}
textwidth(s::AbstractString)
\end{lstlisting}

Give the number of columns needed to print a string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> textwidth("March")
5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L232-L242}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15093956188358440526}{} 
\hyperlink{15093956188358440526}{\texttt{Base.isascii}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isascii(c::Union{AbstractChar,AbstractString}) -> Bool
\end{minted}

Test whether a character belongs to the ASCII character set, or whether this is true for all elements of a string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isascii('a')
true

julia> isascii('α')
false

julia> isascii("abc")
true

julia> isascii("αβγ")
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L543-L563}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4032541622324391497}{} 
\hyperlink{4032541622324391497}{\texttt{Base.Unicode.iscntrl}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
iscntrl(c::AbstractChar) -> Bool
\end{minted}

Tests whether a character is a control character. Control characters are the non-printing characters of the Latin-1 subset of Unicode.

\textbf{Examples}


\begin{minted}{jlcon}
julia> iscntrl('\x01')
true

julia> iscntrl('a')
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L405-L419}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6749017765435728728}{} 
\hyperlink{6749017765435728728}{\texttt{Base.Unicode.isdigit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isdigit(c::AbstractChar) -> Bool
\end{minted}

Tests whether a character is a decimal digit (0-9).

\textbf{Examples}


\begin{minted}{jlcon}
julia> isdigit('❤')
false

julia> isdigit('9')
true

julia> isdigit('α')
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L336-L352}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12561738838785727067}{} 
\hyperlink{12561738838785727067}{\texttt{Base.Unicode.isletter}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isletter(c::AbstractChar) -> Bool
\end{minted}

Test whether a character is a letter. A character is classified as a letter if it belongs to the Unicode general category Letter, i.e. a character whose category code begins with {\textquotesingle}L{\textquotesingle}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isletter('❤')
false

julia> isletter('α')
true

julia> isletter('9')
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L355-L373}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11243750221058781239}{} 
\hyperlink{11243750221058781239}{\texttt{Base.Unicode.islowercase}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
islowercase(c::AbstractChar) -> Bool
\end{minted}

Tests whether a character is a lowercase letter. A character is classified as lowercase if it belongs to Unicode category Ll, Letter: Lowercase.

\textbf{Examples}


\begin{minted}{jlcon}
julia> islowercase('α')
true

julia> islowercase('Γ')
false

julia> islowercase('❤')
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L276-L294}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12093502248158263869}{} 
\hyperlink{12093502248158263869}{\texttt{Base.Unicode.isnumeric}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isnumeric(c::AbstractChar) -> Bool
\end{minted}

Tests whether a character is numeric. A character is classified as numeric if it belongs to the Unicode general category Number, i.e. a character whose category code begins with {\textquotesingle}N{\textquotesingle}.

Note that this broad category includes characters such as ¾ and ௰. Use \hyperlink{6749017765435728728}{\texttt{isdigit}} to check whether a character a decimal digit between 0 and 9.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isnumeric('௰')
true

julia> isnumeric('9')
true

julia> isnumeric('α')
false

julia> isnumeric('❤')
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L376-L400}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7756178256858757543}{} 
\hyperlink{7756178256858757543}{\texttt{Base.Unicode.isprint}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isprint(c::AbstractChar) -> Bool
\end{minted}

Tests whether a character is printable, including spaces, but not a control character.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isprint('\x01')
false

julia> isprint('A')
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L470-L483}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12870722043550444957}{} 
\hyperlink{12870722043550444957}{\texttt{Base.Unicode.ispunct}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ispunct(c::AbstractChar) -> Bool
\end{minted}

Tests whether a character belongs to the Unicode general category Punctuation, i.e. a character whose category code begins with {\textquotesingle}P{\textquotesingle}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ispunct('α')
false

julia> ispunct('/')
true

julia> ispunct(';')
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L422-L439}{\texttt{source}}


\end{adjustwidth}
\hypertarget{774253773882022491}{} 
\hyperlink{774253773882022491}{\texttt{Base.Unicode.isspace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isspace(c::AbstractChar) -> Bool
\end{minted}

Tests whether a character is any whitespace character. Includes ASCII characters {\textquotesingle}{\textbackslash}t{\textquotesingle}, {\textquotesingle}{\textbackslash}n{\textquotesingle}, {\textquotesingle}{\textbackslash}v{\textquotesingle}, {\textquotesingle}{\textbackslash}f{\textquotesingle}, {\textquotesingle}{\textbackslash}r{\textquotesingle}, and {\textquotesingle} {\textquotesingle}, Latin-1 character U+0085, and characters in Unicode category Zs.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isspace('\n')
true

julia> isspace('\r')
true

julia> isspace(' ')
true

julia> isspace('\x20')
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L444-L465}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1249092202955861802}{} 
\hyperlink{1249092202955861802}{\texttt{Base.Unicode.isuppercase}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isuppercase(c::AbstractChar) -> Bool
\end{minted}

Tests whether a character is an uppercase letter. A character is classified as uppercase if it belongs to Unicode category Lu, Letter: Uppercase, or Lt, Letter: Titlecase.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isuppercase('γ')
false

julia> isuppercase('Γ')
true

julia> isuppercase('❤')
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L299-L317}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13818528006711193037}{} 
\hyperlink{13818528006711193037}{\texttt{Base.Unicode.isxdigit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isxdigit(c::AbstractChar) -> Bool
\end{minted}

Test whether a character is a valid hexadecimal digit. Note that this does not include \texttt{x} (as in the standard \texttt{0x} prefix).

\textbf{Examples}


\begin{minted}{jlcon}
julia> isxdigit('a')
true

julia> isxdigit('x')
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/unicode.jl#L488-L502}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2720373307114882969}{} 
\hyperlink{2720373307114882969}{\texttt{Base.escape\_string}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
escape_string(str::AbstractString[, esc])::AbstractString
escape_string(io, str::AbstractString[, esc::])::Nothing
\end{minted}

General escaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to \texttt{io}.

Backslashes (\texttt{{\textbackslash}}) are escaped with a double-backslash (\texttt{{\textquotedbl}{\textbackslash}{\textbackslash}{\textquotedbl}}). Non-printable characters are escaped either with their standard C escape codes, \texttt{{\textquotedbl}{\textbackslash}0{\textquotedbl}} for NUL (if unambiguous), unicode code point (\texttt{{\textquotedbl}{\textbackslash}u{\textquotedbl}} prefix) or hex (\texttt{{\textquotedbl}{\textbackslash}x{\textquotedbl}} prefix).

The optional \texttt{esc} argument specifies any additional characters that should also be escaped by a prepending backslash (\texttt{{\textquotedbl}} is also escaped by default in the first form).

\textbf{Examples}


\begin{minted}{jlcon}
julia> escape_string("aaa\nbbb")
"aaa\\nbbb"

julia> escape_string("\xfe\xff") # invalid utf-8
"\\xfe\\xff"

julia> escape_string(string('\u2135','\0')) # unambiguous
"ℵ\\0"

julia> escape_string(string('\u2135','\0','0')) # \0 would be ambiguous
"ℵ\\x000"
\end{minted}

\textbf{See also}

\hyperlink{4382494947698149975}{\texttt{unescape\_string}} for the reverse operation.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/io.jl#L310-L341}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4382494947698149975}{} 
\hyperlink{4382494947698149975}{\texttt{Base.unescape\_string}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unescape_string(str::AbstractString, keep = ())::AbstractString
unescape_string(io, s::AbstractString, keep = ())::Nothing
\end{minted}

General unescaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to \texttt{io}. The argument \texttt{keep} specifies a collection of characters which (along with backlashes) are to be kept as they are.

The following escape sequences are recognised:

\begin{itemize}
\item Escaped backslash (\texttt{{\textbackslash}{\textbackslash}})


\item Escaped double-quote (\texttt{{\textbackslash}{\textquotedbl}})


\item Standard C escape sequences (\texttt{{\textbackslash}a}, \texttt{{\textbackslash}b}, \texttt{{\textbackslash}t}, \texttt{{\textbackslash}n}, \texttt{{\textbackslash}v}, \texttt{{\textbackslash}f}, \texttt{{\textbackslash}r}, \texttt{{\textbackslash}e})


\item Unicode BMP code points (\texttt{{\textbackslash}u} with 1-4 trailing hex digits)


\item All Unicode code points (\texttt{{\textbackslash}U} with 1-8 trailing hex digits; max value = 0010ffff)


\item Hex bytes (\texttt{{\textbackslash}x} with 1-2 trailing hex digits)


\item Octal bytes (\texttt{{\textbackslash}} with 1-3 trailing octal digits)

\end{itemize}
\textbf{Examples}


\begin{minted}{jlcon}
julia> unescape_string("aaa\\nbbb") # C escape sequence
"aaa\nbbb"

julia> unescape_string("\\u03c0") # unicode
"π"

julia> unescape_string("\\101") # octal
"A"

julia> unescape_string("aaa \\g \\n", ['g']) # using `keep` argument
"aaa \\g \n"
\end{minted}

\textbf{See also}

\hyperlink{2720373307114882969}{\texttt{escape\_string}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/io.jl#L380-L415}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14629781252390713372}{}


\chapter{数组}



\hypertarget{4417167577090041953}{}


\section{构造函数与类型}


\hypertarget{6514416309183787338}{} 
\hyperlink{6514416309183787338}{\texttt{Core.AbstractArray}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractArray{T,N}
\end{minted}

Supertype for \texttt{N}-dimensional arrays (or array-like types) with elements of type \texttt{T}. \hyperlink{15492651498431872487}{\texttt{Array}} and other types are subtypes of this. See the manual section on the \hyperlink{9718377734213742156}{\texttt{AbstractArray} interface}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L5-L11}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12517057979818647811}{} 
\hyperlink{12517057979818647811}{\texttt{Base.AbstractVector}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractVector{T}
\end{minted}

Supertype for one-dimensional arrays (or array-like types) with elements of type \texttt{T}. Alias for \hyperlink{6514416309183787338}{\texttt{AbstractArray\{T,1\}}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L17-L22}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17966587371929951201}{} 
\hyperlink{17966587371929951201}{\texttt{Base.AbstractMatrix}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractMatrix{T}
\end{minted}

Supertype for two-dimensional arrays (or array-like types) with elements of type \texttt{T}. Alias for \hyperlink{6514416309183787338}{\texttt{AbstractArray\{T,2\}}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L25-L30}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1242753619689895999}{} 
\hyperlink{1242753619689895999}{\texttt{Base.AbstractVecOrMat}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractVecOrMat{T}
\end{minted}

Union type of \hyperlink{12517057979818647811}{\texttt{AbstractVector\{T\}}} and \hyperlink{17966587371929951201}{\texttt{AbstractMatrix\{T\}}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L33-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15492651498431872487}{} 
\hyperlink{15492651498431872487}{\texttt{Core.Array}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Array{T,N} <: AbstractArray{T,N}
\end{minted}

\texttt{N}-dimensional dense array with elements of type \texttt{T}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L45-L49}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16608354292334711958}{} 
\hyperlink{16608354292334711958}{\texttt{Core.Array}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Array{T}(undef, dims)
Array{T,N}(undef, dims)
\end{minted}

Construct an uninitialized \texttt{N}-dimensional \hyperlink{15492651498431872487}{\texttt{Array}} containing elements of type \texttt{T}. \texttt{N} can either be supplied explicitly, as in \texttt{Array\{T,N\}(undef, dims)}, or be determined by the length or number of \texttt{dims}. \texttt{dims} may be a tuple or a series of integer arguments corresponding to the lengths in each dimension. If the rank \texttt{N} is supplied explicitly, then it must match the length or number of \texttt{dims}. See \hyperlink{5151602251166445554}{\texttt{undef}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = Array{Float64,2}(undef, 2, 3) # N given explicitly
2×3 Array{Float64,2}:
 6.90198e-310  6.90198e-310  6.90198e-310
 6.90198e-310  6.90198e-310  0.0

julia> B = Array{Float64}(undef, 2) # N determined by the input
2-element Array{Float64,1}:
 1.87103e-320
 0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1824-L1847}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7218323500801746536}{} 
\hyperlink{7218323500801746536}{\texttt{Core.Array}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Array{T}(nothing, dims)
Array{T,N}(nothing, dims)
\end{minted}

Construct an \texttt{N}-dimensional \hyperlink{15492651498431872487}{\texttt{Array}} containing elements of type \texttt{T}, initialized with \hyperlink{9331422207248206047}{\texttt{nothing}} entries. Element type \texttt{T} must be able to hold these values, i.e. \texttt{Nothing <: T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Array{Union{Nothing, String}}(nothing, 2)
2-element Array{Union{Nothing, String},1}:
 nothing
 nothing

julia> Array{Union{Nothing, Int}}(nothing, 2, 3)
2×3 Array{Union{Nothing, Int64},2}:
 nothing  nothing  nothing
 nothing  nothing  nothing
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1850-L1870}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12823362688708528916}{} 
\hyperlink{12823362688708528916}{\texttt{Core.Array}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Array{T}(missing, dims)
Array{T,N}(missing, dims)
\end{minted}

Construct an \texttt{N}-dimensional \hyperlink{15492651498431872487}{\texttt{Array}} containing elements of type \texttt{T}, initialized with \hyperlink{14596725676261444434}{\texttt{missing}} entries. Element type \texttt{T} must be able to hold these values, i.e. \texttt{Missing <: T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Array{Union{Missing, String}}(missing, 2)
2-element Array{Union{Missing, String},1}:
 missing
 missing

julia> Array{Union{Missing, Int}}(missing, 2, 3)
2×3 Array{Union{Missing, Int64},2}:
 missing  missing  missing
 missing  missing  missing
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1874-L1894}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9570767809940895771}{} 
\hyperlink{9570767809940895771}{\texttt{Core.UndefInitializer}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UndefInitializer
\end{minted}

Singleton type used in array initialization, indicating the array-constructor-caller would like an uninitialized array. See also \hyperlink{5151602251166445554}{\texttt{undef}}, an alias for \texttt{UndefInitializer()}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Array{Float64,1}(UndefInitializer(), 3)
3-element Array{Float64,1}:
 2.2752528595e-314
 2.202942107e-314
 2.275252907e-314
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1897-L1912}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5151602251166445554}{} 
\hyperlink{5151602251166445554}{\texttt{Core.undef}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
undef
\end{minted}

Alias for \texttt{UndefInitializer()}, which constructs an instance of the singleton type \hyperlink{9570767809940895771}{\texttt{UndefInitializer}}, used in array initialization to indicate the array-constructor-caller would like an uninitialized array.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Array{Float64,1}(undef, 3)
3-element Array{Float64,1}:
 2.2752528595e-314
 2.202942107e-314
 2.275252907e-314
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1915-L1930}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10571362059486397014}{} 
\hyperlink{10571362059486397014}{\texttt{Base.Vector}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Vector{T} <: AbstractVector{T}
\end{minted}

One-dimensional dense array with elements of type \texttt{T}, often used to represent a mathematical vector. Alias for \hyperlink{15492651498431872487}{\texttt{Array\{T,1\}}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L52-L57}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11314200556699527986}{} 
\hyperlink{11314200556699527986}{\texttt{Base.Vector}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Vector{T}(undef, n)
\end{minted}

Construct an uninitialized \hyperlink{10571362059486397014}{\texttt{Vector\{T\}}} of length \texttt{n}. See \hyperlink{5151602251166445554}{\texttt{undef}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Vector{Float64}(undef, 3)
3-element Array{Float64,1}:
 6.90966e-310
 6.90966e-310
 6.90966e-310
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1725-L1738}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8846296074574617607}{} 
\hyperlink{8846296074574617607}{\texttt{Base.Vector}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Vector{T}(nothing, m)
\end{minted}

Construct a \hyperlink{10571362059486397014}{\texttt{Vector\{T\}}} of length \texttt{m}, initialized with \hyperlink{9331422207248206047}{\texttt{nothing}} entries. Element type \texttt{T} must be able to hold these values, i.e. \texttt{Nothing <: T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Vector{Union{Nothing, String}}(nothing, 2)
2-element Array{Union{Nothing, String},1}:
 nothing
 nothing
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1741-L1755}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4511365004580822281}{} 
\hyperlink{4511365004580822281}{\texttt{Base.Vector}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Vector{T}(missing, m)
\end{minted}

Construct a \hyperlink{10571362059486397014}{\texttt{Vector\{T\}}} of length \texttt{m}, initialized with \hyperlink{14596725676261444434}{\texttt{missing}} entries. Element type \texttt{T} must be able to hold these values, i.e. \texttt{Missing <: T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Vector{Union{Missing, String}}(missing, 2)
2-element Array{Union{Missing, String},1}:
 missing
 missing
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1758-L1772}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5448927444601277512}{} 
\hyperlink{5448927444601277512}{\texttt{Base.Matrix}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Matrix{T} <: AbstractMatrix{T}
\end{minted}

Two-dimensional dense array with elements of type \texttt{T}, often used to represent a mathematical matrix. Alias for \hyperlink{15492651498431872487}{\texttt{Array\{T,2\}}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L60-L65}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12196830356379655838}{} 
\hyperlink{12196830356379655838}{\texttt{Base.Matrix}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Matrix{T}(undef, m, n)
\end{minted}

Construct an uninitialized \hyperlink{5448927444601277512}{\texttt{Matrix\{T\}}} of size \texttt{m}×\texttt{n}. See \hyperlink{5151602251166445554}{\texttt{undef}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Matrix{Float64}(undef, 2, 3)
2×3 Array{Float64,2}:
 6.93517e-310  6.93517e-310  6.93517e-310
 6.93517e-310  6.93517e-310  1.29396e-320
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1775-L1787}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12588731237614698381}{} 
\hyperlink{12588731237614698381}{\texttt{Base.Matrix}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Matrix{T}(nothing, m, n)
\end{minted}

Construct a \hyperlink{5448927444601277512}{\texttt{Matrix\{T\}}} of size \texttt{m}×\texttt{n}, initialized with \hyperlink{9331422207248206047}{\texttt{nothing}} entries. Element type \texttt{T} must be able to hold these values, i.e. \texttt{Nothing <: T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Matrix{Union{Nothing, String}}(nothing, 2, 3)
2×3 Array{Union{Nothing, String},2}:
 nothing  nothing  nothing
 nothing  nothing  nothing
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1790-L1804}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10540962728142918076}{} 
\hyperlink{10540962728142918076}{\texttt{Base.Matrix}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Matrix{T}(missing, m, n)
\end{minted}

Construct a \hyperlink{5448927444601277512}{\texttt{Matrix\{T\}}} of size \texttt{m}×\texttt{n}, initialized with \hyperlink{14596725676261444434}{\texttt{missing}} entries. Element type \texttt{T} must be able to hold these values, i.e. \texttt{Missing <: T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Matrix{Union{Missing, String}}(missing, 2, 3)
2×3 Array{Union{Missing, String},2}:
 missing  missing  missing
 missing  missing  missing
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1807-L1821}{\texttt{source}}


\end{adjustwidth}
\hypertarget{445304492601262393}{} 
\hyperlink{445304492601262393}{\texttt{Base.VecOrMat}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
VecOrMat{T}
\end{minted}

Union type of \hyperlink{10571362059486397014}{\texttt{Vector\{T\}}} and \hyperlink{5448927444601277512}{\texttt{Matrix\{T\}}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L67-L71}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9999901851371131327}{} 
\hyperlink{9999901851371131327}{\texttt{Core.DenseArray}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DenseArray{T, N} <: AbstractArray{T,N}
\end{minted}

\texttt{N}-dimensional dense array with elements of type \texttt{T}. The elements of a dense array are stored contiguously in memory.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L74-L79}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12295200244111521486}{} 
\hyperlink{12295200244111521486}{\texttt{Base.DenseVector}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DenseVector{T}
\end{minted}

One-dimensional \hyperlink{9999901851371131327}{\texttt{DenseArray}} with elements of type \texttt{T}. Alias for \texttt{DenseArray\{T,1\}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L82-L86}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14980162445656578339}{} 
\hyperlink{14980162445656578339}{\texttt{Base.DenseMatrix}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DenseMatrix{T}
\end{minted}

Two-dimensional \hyperlink{9999901851371131327}{\texttt{DenseArray}} with elements of type \texttt{T}. Alias for \texttt{DenseArray\{T,2\}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L89-L93}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11093696735728490715}{} 
\hyperlink{11093696735728490715}{\texttt{Base.DenseVecOrMat}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DenseVecOrMat{T}
\end{minted}

Union type of \hyperlink{12295200244111521486}{\texttt{DenseVector\{T\}}} and \hyperlink{14980162445656578339}{\texttt{DenseMatrix\{T\}}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L96-L100}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14336154597485782910}{} 
\hyperlink{14336154597485782910}{\texttt{Base.StridedArray}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
StridedArray{T, N}
\end{minted}

An \texttt{N} dimensional \emph{strided} array with elements of type \texttt{T}. These arrays follow the \hyperlink{3010450308855105276}{strided array interface}. If \texttt{A} is a \texttt{StridedArray}, then its elements are stored in memory with offsets, which may vary between dimensions but are constant within a dimension. For example, \texttt{A} could have stride 2 in dimension 1, and stride 3 in dimension 2. Incrementing \texttt{A} along dimension \texttt{d} jumps in memory by [\texttt{strides(A, d)}] slots. Strided arrays are particularly important and useful because they can sometimes be passed directly as pointers to foreign language libraries like BLAS.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2286-L2297}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18350706206094827862}{} 
\hyperlink{18350706206094827862}{\texttt{Base.StridedVector}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
StridedVector{T}
\end{minted}

One dimensional \hyperlink{14336154597485782910}{\texttt{StridedArray}} with elements of type \texttt{T}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2300-L2304}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3855703768476610836}{} 
\hyperlink{3855703768476610836}{\texttt{Base.StridedMatrix}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
StridedMatrix{T}
\end{minted}

Two dimensional \hyperlink{14336154597485782910}{\texttt{StridedArray}} with elements of type \texttt{T}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2307-L2311}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1581729656055818973}{} 
\hyperlink{1581729656055818973}{\texttt{Base.StridedVecOrMat}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
StridedVecOrMat{T}
\end{minted}

Union type of \hyperlink{18350706206094827862}{\texttt{StridedVector}} and \hyperlink{3855703768476610836}{\texttt{StridedMatrix}} with elements of type \texttt{T}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L2314-L2318}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2839226020402435013}{} 
\hyperlink{2839226020402435013}{\texttt{Base.getindex}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getindex(type[, elements...])
\end{minted}

Construct a 1-d array of the specified type. This is usually called with the syntax \texttt{Type[]}. Element values can be specified using \texttt{Type[a,b,c,...]}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Int8[1, 2, 3]
3-element Array{Int8,1}:
 1
 2
 3

julia> getindex(Int8, 1, 2, 3)
3-element Array{Int8,1}:
 1
 2
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L365-L385}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13837674686090348619}{} 
\hyperlink{13837674686090348619}{\texttt{Base.zeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
zeros([T=Float64,] dims::Tuple)
zeros([T=Float64,] dims...)
\end{minted}

Create an \texttt{Array}, with element type \texttt{T}, of all zeros with size specified by \texttt{dims}. See also \hyperlink{2836152204730819918}{\texttt{fill}}, \hyperlink{5858390260510292771}{\texttt{ones}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> zeros(1)
1-element Array{Float64,1}:
 0.0

julia> zeros(Int8, 2, 3)
2×3 Array{Int8,2}:
 0  0  0
 0  0  0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L455-L473}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5858390260510292771}{} 
\hyperlink{5858390260510292771}{\texttt{Base.ones}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ones([T=Float64,] dims::Tuple)
ones([T=Float64,] dims...)
\end{minted}

Create an \texttt{Array}, with element type \texttt{T}, of all ones with size specified by \texttt{dims}. See also: \hyperlink{2836152204730819918}{\texttt{fill}}, \hyperlink{13837674686090348619}{\texttt{zeros}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ones(1,2)
1×2 Array{Float64,2}:
 1.0  1.0

julia> ones(ComplexF64, 2, 3)
2×3 Array{Complex{Float64},2}:
 1.0+0.0im  1.0+0.0im  1.0+0.0im
 1.0+0.0im  1.0+0.0im  1.0+0.0im
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L476-L494}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18015155802543401629}{} 
\hyperlink{18015155802543401629}{\texttt{Base.BitArray}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
BitArray{N} <: AbstractArray{Bool, N}
\end{minted}

Space-efficient \texttt{N}-dimensional boolean array, using just one bit for each boolean value.

\texttt{BitArray}s pack up to 64 values into every 8 bytes, resulting in an 8x space efficiency over \texttt{Array\{Bool, N\}} and allowing some operations to work on 64 values at once.

By default, Julia returns \texttt{BitArrays} from \href{@ref Broadcasting}{broadcasting} operations that generate boolean elements (including dotted-comparisons like \texttt{.==}) as well as from the functions \hyperlink{12844393578243965152}{\texttt{trues}} and \hyperlink{12518029339635756199}{\texttt{falses}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/bitarray.jl#L7-L18}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2664788023587904444}{} 
\hyperlink{2664788023587904444}{\texttt{Base.BitArray}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
BitArray(undef, dims::Integer...)
BitArray{N}(undef, dims::NTuple{N,Int})
\end{minted}

Construct an undef \hyperlink{18015155802543401629}{\texttt{BitArray}} with the given dimensions. Behaves identically to the \hyperlink{15492651498431872487}{\texttt{Array}} constructor. See \hyperlink{5151602251166445554}{\texttt{undef}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> BitArray(undef, 2, 2)
2×2 BitArray{2}:
 0  0
 0  0

julia> BitArray(undef, (3, 1))
3×1 BitArray{2}:
 0
 0
 0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/bitarray.jl#L43-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17297916140801761844}{} 
\hyperlink{17297916140801761844}{\texttt{Base.BitArray}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
BitArray(itr)
\end{minted}

Construct a \hyperlink{18015155802543401629}{\texttt{BitArray}} generated by the given iterable object. The shape is inferred from the \texttt{itr} object.

\textbf{Examples}


\begin{minted}{jlcon}
julia> BitArray([1 0; 0 1])
2×2 BitArray{2}:
 1  0
 0  1

julia> BitArray(x+y == 3 for x = 1:2, y = 1:3)
2×3 BitArray{2}:
 0  1  0
 1  0  0

julia> BitArray(x+y == 3 for x = 1:2 for y = 1:3)
6-element BitArray{1}:
 0
 1
 0
 1
 0
 0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/bitarray.jl#L539-L566}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12844393578243965152}{} 
\hyperlink{12844393578243965152}{\texttt{Base.trues}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trues(dims)
\end{minted}

Create a \texttt{BitArray} with all values set to \texttt{true}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> trues(2,3)
2×3 BitArray{2}:
 1  1  1
 1  1  1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/bitarray.jl#L403-L415}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12518029339635756199}{} 
\hyperlink{12518029339635756199}{\texttt{Base.falses}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
falses(dims)
\end{minted}

Create a \texttt{BitArray} with all values set to \texttt{false}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> falses(2,3)
2×3 BitArray{2}:
 0  0  0
 0  0  0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/bitarray.jl#L385-L397}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2836152204730819918}{} 
\hyperlink{2836152204730819918}{\texttt{Base.fill}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fill(x, dims::Tuple)
fill(x, dims...)
\end{minted}

Create an array filled with the value \texttt{x}. For example, \texttt{fill(1.0, (5,5))} returns a 5×5 array of floats, with each element initialized to \texttt{1.0}.

\texttt{dims} may be specified as either a tuple or a sequence of arguments. For example, the common idiom \texttt{fill(x)} creates a zero-dimensional array containing the single value \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> fill(1.0, (5,5))
5×5 Array{Float64,2}:
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0

julia> fill(0.5, 1, 2)
1×2 Array{Float64,2}:
 0.5  0.5

julia> fill(42)
0-dimensional Array{Int64,0}:
42
\end{minted}

If \texttt{x} is an object reference, all elements will refer to the same object. \texttt{fill(Foo(), dims)} will return an array filled with the result of evaluating \texttt{Foo()} once.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L416-L447}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5162290739791026948}{} 
\hyperlink{5162290739791026948}{\texttt{Base.fill!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fill!(A, x)
\end{minted}

Fill array \texttt{A} with the value \texttt{x}. If \texttt{x} is an object reference, all elements will refer to the same object. \texttt{fill!(A, Foo())} will return \texttt{A} filled with the result of evaluating \texttt{Foo()} once.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = zeros(2,3)
2×3 Array{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0

julia> fill!(A, 2.)
2×3 Array{Float64,2}:
 2.0  2.0  2.0
 2.0  2.0  2.0

julia> a = [1, 1, 1]; A = fill!(Vector{Vector{Int}}(undef, 3), a); a[1] = 2; A
3-element Array{Array{Int64,1},1}:
 [2, 1, 1]
 [2, 1, 1]
 [2, 1, 1]

julia> x = 0; f() = (global x += 1; x); fill!(Vector{Int}(undef, 3), f())
3-element Array{Int64,1}:
 1
 1
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L889-L920}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15525808546723795098}{} 
\hyperlink{15525808546723795098}{\texttt{Base.similar}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
similar(array, [element_type=eltype(array)], [dims=size(array)])
\end{minted}

Create an uninitialized mutable array with the given element type and size, based upon the given source array. The second and third arguments are both optional, defaulting to the given array{\textquotesingle}s \texttt{eltype} and \texttt{size}. The dimensions may be specified either as a single tuple argument or as a series of integer arguments.

Custom AbstractArray subtypes may choose which specific array type is best-suited to return for the given element type and dimensionality. If they do not specialize this method, the default is an \texttt{Array\{element\_type\}(undef, dims...)}.

For example, \texttt{similar(1:10, 1, 4)} returns an uninitialized \texttt{Array\{Int,2\}} since ranges are neither mutable nor support 2 dimensions:


\begin{minted}{jlcon}
julia> similar(1:10, 1, 4)
1×4 Array{Int64,2}:
 4419743872  4374413872  4419743888  0
\end{minted}

Conversely, \texttt{similar(trues(10,10), 2)} returns an uninitialized \texttt{BitVector} with two elements since \texttt{BitArray}s are both mutable and can support 1-dimensional arrays:


\begin{minted}{jlcon}
julia> similar(trues(10,10), 2)
2-element BitArray{1}:
 0
 0
\end{minted}

Since \texttt{BitArray}s can only store elements of type \hyperlink{46725311238864537}{\texttt{Bool}}, however, if you request a different element type it will create a regular \texttt{Array} instead:


\begin{minted}{jlcon}
julia> similar(falses(10), Float64, 2, 4)
2×4 Array{Float64,2}:
 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314
 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L582-L623}{\texttt{source}}



\begin{lstlisting}
similar(storagetype, axes)
\end{lstlisting}

Create an uninitialized mutable array analogous to that specified by \texttt{storagetype}, but with \texttt{axes} specified by the last argument. \texttt{storagetype} might be a type or a function.

\textbf{Examples}:


\begin{lstlisting}
similar(Array{Int}, axes(A))
\end{lstlisting}

creates an array that {\textquotedbl}acts like{\textquotedbl} an \texttt{Array\{Int\}} (and might indeed be backed by one), but which is indexed identically to \texttt{A}. If \texttt{A} has conventional indexing, this will be identical to \texttt{Array\{Int\}(undef, size(A))}, but if \texttt{A} has unconventional indexing then the indices of the result will match \texttt{A}.


\begin{lstlisting}
similar(BitArray, (axes(A, 2),))
\end{lstlisting}

would create a 1-dimensional logical array whose indices match those of the columns of \texttt{A}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L647-L668}{\texttt{source}}


\end{adjustwidth}

\hypertarget{9348596862671224476}{}


\section{基础函数}


\hypertarget{1688406579181746010}{} 
\hyperlink{1688406579181746010}{\texttt{Base.ndims}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ndims(A::AbstractArray) -> Integer
\end{minted}

Return the number of dimensions of \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = fill(1, (3,4,5));

julia> ndims(A)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L155-L167}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17888996102305087038}{} 
\hyperlink{17888996102305087038}{\texttt{Base.size}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
size(A::AbstractArray, [dim])
\end{minted}

Return a tuple containing the dimensions of \texttt{A}. Optionally you can specify a dimension to just get the length of that dimension.

Note that \texttt{size} may not be defined for arrays with non-standard indices, in which case \hyperlink{7074821531920287868}{\texttt{axes}} may be useful. See the manual chapter on \hyperlink{1238988360302116626}{arrays with custom indices}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = fill(1, (2,3,4));

julia> size(A)
(2, 3, 4)

julia> size(A, 2)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L18-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7074821531920287868}{} 
\hyperlink{7074821531920287868}{\texttt{Base.axes}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
axes(A)
\end{minted}

Return the tuple of valid indices for array \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = fill(1, (5,6,7));

julia> axes(A)
(Base.OneTo(5), Base.OneTo(6), Base.OneTo(7))
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L60-L72}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9203019773133814597}{} 
\hyperlink{9203019773133814597}{\texttt{Base.axes}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
axes(A, d)
\end{minted}

Return the valid range of indices for array \texttt{A} along dimension \texttt{d}.

See also \hyperlink{17888996102305087038}{\texttt{size}}, and the manual chapter on \hyperlink{1238988360302116626}{arrays with custom indices}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = fill(1, (5,6,7));

julia> axes(A, 2)
Base.OneTo(6)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L40-L54}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3699181304419743826}{} 
\hyperlink{3699181304419743826}{\texttt{Base.length}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
length(A::AbstractArray)
\end{minted}

Return the number of elements in the array, defaults to \texttt{prod(size(A))}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> length([1, 2, 3, 4])
4

julia> length([1 2; 3 4])
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L192-L205}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4701773772897287974}{} 
\hyperlink{4701773772897287974}{\texttt{Base.eachindex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eachindex(A...)
\end{minted}

Create an iterable object for visiting each index of an \texttt{AbstractArray} \texttt{A} in an efficient manner. For array types that have opted into fast linear indexing (like \texttt{Array}), this is simply the range \texttt{1:length(A)}. For other array types, return a specialized Cartesian range to efficiently index into the array with indices specified for every dimension. For other iterables, including strings and dictionaries, return an iterator object supporting arbitrary index types (e.g. unevenly spaced or non-integer indices).

If you supply more than one \texttt{AbstractArray} argument, \texttt{eachindex} will create an iterable object that is fast for all arguments (a \hyperlink{9165955949298153694}{\texttt{UnitRange}} if all inputs have fast linear indexing, a \hyperlink{16831958174907250244}{\texttt{CartesianIndices}} otherwise). If the arrays have different sizes and/or dimensionalities, a DimensionMismatch exception will be thrown.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4];

julia> for i in eachindex(A) # linear indexing
           println(i)
       end
1
2
3
4

julia> for i in eachindex(view(A, 1:2, 1:1)) # Cartesian indexing
           println(i)
       end
CartesianIndex(1, 1)
CartesianIndex(2, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L221-L255}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7782790551324367092}{} 
\hyperlink{7782790551324367092}{\texttt{Base.IndexStyle}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IndexStyle(A)
IndexStyle(typeof(A))
\end{minted}

\texttt{IndexStyle} specifies the {\textquotedbl}native indexing style{\textquotedbl} for array \texttt{A}. When you define a new \hyperlink{6514416309183787338}{\texttt{AbstractArray}} type, you can choose to implement either linear indexing (with \hyperlink{1761039776681330940}{\texttt{IndexLinear}}) or cartesian indexing. If you decide to only implement linear indexing, then you must set this trait for your array type:


\begin{lstlisting}
Base.IndexStyle(::Type{<:MyArray}) = IndexLinear()
\end{lstlisting}

The default is \hyperlink{4052302263500310575}{\texttt{IndexCartesian()}}.

Julia{\textquotesingle}s internal indexing machinery will automatically (and invisibly) recompute all indexing operations into the preferred style. This allows users to access elements of your array using any indexing style, even when explicit methods have not been provided.

If you define both styles of indexing for your \texttt{AbstractArray}, this trait can be used to select the most performant indexing style. Some methods check this trait on their inputs, and dispatch to different algorithms depending on the most efficient access pattern. In particular, \hyperlink{4701773772897287974}{\texttt{eachindex}} creates an iterator whose type depends on the setting of this trait.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/indices.jl#L68-L93}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1761039776681330940}{} 
\hyperlink{1761039776681330940}{\texttt{Base.IndexLinear}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IndexLinear()
\end{minted}

Subtype of \hyperlink{7782790551324367092}{\texttt{IndexStyle}} used to describe arrays which are optimally indexed by one linear index.

A linear indexing style uses one integer index to describe the position in the array (even if it{\textquotesingle}s a multidimensional array) and column-major ordering is used to efficiently access the elements. This means that requesting \hyperlink{4701773772897287974}{\texttt{eachindex}} from an array that is \texttt{IndexLinear} will return a simple one-dimensional range, even if it is multidimensional.

A custom array that reports its \texttt{IndexStyle} as \texttt{IndexLinear} only needs to implement indexing (and indexed assignment) with a single \texttt{Int} index; all other indexing expressions — including multidimensional accesses — will be recomputed to the linear index.  For example, if \texttt{A} were a \texttt{2×3} custom matrix with linear indexing, and we referenced \texttt{A[1, 3]}, this would be recomputed to the equivalent linear index and call \texttt{A[5]} since \texttt{2*1 + 3 = 5}.

See also \hyperlink{4052302263500310575}{\texttt{IndexCartesian}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/indices.jl#L16-L36}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4052302263500310575}{} 
\hyperlink{4052302263500310575}{\texttt{Base.IndexCartesian}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IndexCartesian()
\end{minted}

Subtype of \hyperlink{7782790551324367092}{\texttt{IndexStyle}} used to describe arrays which are optimally indexed by a Cartesian index. This is the default for new custom \hyperlink{6514416309183787338}{\texttt{AbstractArray}} subtypes.

A Cartesian indexing style uses multiple integer indices to describe the position in a multidimensional array, with exactly one index per dimension. This means that requesting \hyperlink{4701773772897287974}{\texttt{eachindex}} from an array that is \texttt{IndexCartesian} will return a range of \hyperlink{16831958174907250244}{\texttt{CartesianIndices}}.

A \texttt{N}-dimensional custom array that reports its \texttt{IndexStyle} as \texttt{IndexCartesian} needs to implement indexing (and indexed assignment) with exactly \texttt{N} \texttt{Int} indices; all other indexing expressions — including linear indexing — will be recomputed to the equivalent Cartesian location.  For example, if \texttt{A} were a \texttt{2×3} custom matrix with cartesian indexing, and we referenced \texttt{A[5]}, this would be recomputed to the equivalent Cartesian index and call \texttt{A[1, 3]} since \texttt{5 = 2*1 + 3}.

It is significantly more expensive to compute Cartesian indices from a linear index than it is to go the other way.  The former operation requires division — a very costly operation — whereas the latter only uses multiplication and addition and is essentially free. This asymmetry means it is far more costly to use linear indexing with an \texttt{IndexCartesian} array than it is to use Cartesian indexing with an \texttt{IndexLinear} array.

See also \hyperlink{1761039776681330940}{\texttt{IndexLinear}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/indices.jl#L39-L65}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17819607861919666057}{} 
\hyperlink{17819607861919666057}{\texttt{Base.conj!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
conj!(A)
\end{minted}

Transform an array to its complex conjugate in-place.

See also \hyperlink{9940023991150673697}{\texttt{conj}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1+im 2-im; 2+2im 3+im]
2×2 Array{Complex{Int64},2}:
 1+1im  2-1im
 2+2im  3+1im

julia> conj!(A);

julia> A
2×2 Array{Complex{Int64},2}:
 1-1im  2+1im
 2-2im  3-1im
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/arraymath.jl#L5-L26}{\texttt{source}}


\end{adjustwidth}
\hypertarget{97811245619734938}{} 
\hyperlink{97811245619734938}{\texttt{Base.stride}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stride(A, k::Integer)
\end{minted}

Return the distance in memory (in number of elements) between adjacent elements in dimension \texttt{k}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = fill(1, (3,4,5));

julia> stride(A,2)
3

julia> stride(A,3)
12
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L379-L394}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13576557637670855932}{} 
\hyperlink{13576557637670855932}{\texttt{Base.strides}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
strides(A)
\end{minted}

Return a tuple of the memory strides in each dimension.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = fill(1, (3,4,5));

julia> strides(A)
(1, 3, 12)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L364-L376}{\texttt{source}}


\end{adjustwidth}

\hypertarget{813179919394580087}{}


\section{广播与矢量化}



也可参照 \hyperlink{17801130558550430478}{dot syntax for vectorizing functions}； 例如，\texttt{f.(args...)} 隐式调用 \texttt{broadcast(f, args...)}。 与其依赖如 \texttt{sin} 函数的“已矢量化”方法，你应该使用 \texttt{sin.(a)} 来使用\texttt{broadcast}来矢量化。


\hypertarget{616124539803111168}{} 
\hyperlink{616124539803111168}{\texttt{Base.Broadcast.broadcast}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
broadcast(f, As...)
\end{minted}

Broadcast the function \texttt{f} over the arrays, tuples, collections, \hyperlink{7936024700322877457}{\texttt{Ref}}s and/or scalars \texttt{As}.

Broadcasting applies the function \texttt{f} over the elements of the container arguments and the scalars themselves in \texttt{As}. Singleton and missing dimensions are expanded to match the extents of the other arguments by virtually repeating the value. By default, only a limited number of types are considered scalars, including \texttt{Number}s, \texttt{String}s, \texttt{Symbol}s, \texttt{Type}s, \texttt{Function}s and some common singletons like \hyperlink{14596725676261444434}{\texttt{missing}} and \hyperlink{9331422207248206047}{\texttt{nothing}}. All other arguments are iterated over or indexed into elementwise.

The resulting container type is established by the following rules:

\begin{itemize}
\item If all the arguments are scalars or zero-dimensional arrays, it returns an unwrapped scalar.


\item If at least one argument is a tuple and all others are scalars or zero-dimensional arrays, it returns a tuple.


\item All other combinations of arguments default to returning an \texttt{Array}, but custom container types can define their own implementation and promotion-like rules to customize the result when they appear as arguments.

\end{itemize}
A special syntax exists for broadcasting: \texttt{f.(args...)} is equivalent to \texttt{broadcast(f, args...)}, and nested \texttt{f.(g.(args...))} calls are fused into a single broadcast loop.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1, 2, 3, 4, 5]
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia> B = [1 2; 3 4; 5 6; 7 8; 9 10]
5×2 Array{Int64,2}:
 1   2
 3   4
 5   6
 7   8
 9  10

julia> broadcast(+, A, B)
5×2 Array{Int64,2}:
  2   3
  5   6
  8   9
 11  12
 14  15

julia> parse.(Int, ["1", "2"])
2-element Array{Int64,1}:
 1
 2

julia> abs.((1, -2))
(1, 2)

julia> broadcast(+, 1.0, (0, -2.0))
(1.0, -1.0)

julia> (+).([[0,2], [1,3]], Ref{Vector{Int}}([1,-1]))
2-element Array{Array{Int64,1},1}:
 [1, 1]
 [2, 2]

julia> string.(("one","two","three","four"), ": ", 1:4)
4-element Array{String,1}:
 "one: 1"
 "two: 2"
 "three: 3"
 "four: 4"

\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/broadcast.jl#L682-L757}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7631985657411687574}{} 
\hyperlink{7631985657411687574}{\texttt{Base.Broadcast.broadcast!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
broadcast!(f, dest, As...)
\end{minted}

Like \hyperlink{616124539803111168}{\texttt{broadcast}}, but store the result of \texttt{broadcast(f, As...)} in the \texttt{dest} array. Note that \texttt{dest} is only used to store the result, and does not supply arguments to \texttt{f} unless it is also listed in the \texttt{As}, as in \texttt{broadcast!(f, A, A, B)} to perform \texttt{A[:] = broadcast(f, A, B)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1.0; 0.0]; B = [0.0; 0.0];

julia> broadcast!(+, B, A, (0, -2.0));

julia> B
2-element Array{Float64,1}:
  1.0
 -2.0

julia> A
2-element Array{Float64,1}:
 1.0
 0.0

julia> broadcast!(+, A, A, (0, -2.0));

julia> A
2-element Array{Float64,1}:
  1.0
 -2.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/broadcast.jl#L764-L796}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16688502228717894452}{} 
\hyperlink{16688502228717894452}{\texttt{Base.Broadcast.@\_\_dot\_\_}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@. expr
\end{minted}

Convert every function call or operator in \texttt{expr} into a {\textquotedbl}dot call{\textquotedbl} (e.g. convert \texttt{f(x)} to \texttt{f.(x)}), and convert every assignment in \texttt{expr} to a {\textquotedbl}dot assignment{\textquotedbl} (e.g. convert \texttt{+=} to \texttt{.+=}).

If you want to \emph{avoid} adding dots for selected function calls in \texttt{expr}, splice those function calls in with \texttt{\$}.  For example, \texttt{@. sqrt(abs(\$sort(x)))} is equivalent to \texttt{sqrt.(abs.(sort(x)))} (no dot for \texttt{sort}).

(\texttt{@.} is equivalent to a call to \texttt{@\_\_dot\_\_}.)

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = 1.0:3.0; y = similar(x);

julia> @. y = x + 3 * sin(x)
3-element Array{Float64,1}:
 3.5244129544236893
 4.727892280477045
 3.4233600241796016
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/broadcast.jl#L1191-L1215}{\texttt{source}}


\end{adjustwidth}

自定义类型的广播，请参照


\hypertarget{16514427843815723867}{} 
\hyperlink{16514427843815723867}{\texttt{Base.Broadcast.BroadcastStyle}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

\texttt{BroadcastStyle} is an abstract type and trait-function used to determine behavior of objects under broadcasting. \texttt{BroadcastStyle(typeof(x))} returns the style associated with \texttt{x}. To customize the broadcasting behavior of a type, one can declare a style by defining a type/method pair


\begin{lstlisting}
struct MyContainerStyle <: BroadcastStyle end
Base.BroadcastStyle(::Type{<:MyContainer}) = MyContainerStyle()
\end{lstlisting}

One then writes method(s) (at least \hyperlink{15525808546723795098}{\texttt{similar}}) operating on \texttt{Broadcasted\{MyContainerStyle\}}. There are also several pre-defined subtypes of \texttt{BroadcastStyle} that you may be able to leverage; see the \hyperlink{13211037977997948197}{Interfaces chapter} for more information.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/broadcast.jl#L21-L34}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18399209409025901494}{} 
\hyperlink{18399209409025901494}{\texttt{Base.Broadcast.AbstractArrayStyle}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

\texttt{Broadcast.AbstractArrayStyle\{N\} <: BroadcastStyle} is the abstract supertype for any style associated with an \texttt{AbstractArray} type. The \texttt{N} parameter is the dimensionality, which can be handy for AbstractArray types that only support specific dimensionalities:


\begin{lstlisting}
struct SparseMatrixStyle <: Broadcast.AbstractArrayStyle{2} end
Base.BroadcastStyle(::Type{<:SparseMatrixCSC}) = SparseMatrixStyle()
\end{lstlisting}

For \texttt{AbstractArray} types that support arbitrary dimensionality, \texttt{N} can be set to \texttt{Any}:


\begin{lstlisting}
struct MyArrayStyle <: Broadcast.AbstractArrayStyle{Any} end
Base.BroadcastStyle(::Type{<:MyArray}) = MyArrayStyle()
\end{lstlisting}

In cases where you want to be able to mix multiple \texttt{AbstractArrayStyle}s and keep track of dimensionality, your style needs to support a \hyperlink{1312938105781775871}{\texttt{Val}} constructor:


\begin{lstlisting}
struct MyArrayStyleDim{N} <: Broadcast.AbstractArrayStyle{N} end
(::Type{<:MyArrayStyleDim})(::Val{N}) where N = MyArrayStyleDim{N}()
\end{lstlisting}

Note that if two or more \texttt{AbstractArrayStyle} subtypes conflict, broadcasting machinery will fall back to producing \texttt{Array}s. If this is undesirable, you may need to define binary \hyperlink{16514427843815723867}{\texttt{BroadcastStyle}} rules to control the output type.

See also \hyperlink{5203521679854231580}{\texttt{Broadcast.DefaultArrayStyle}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/broadcast.jl#L51-L76}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7130961038203619012}{} 
\hyperlink{7130961038203619012}{\texttt{Base.Broadcast.ArrayStyle}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

\texttt{Broadcast.ArrayStyle\{MyArrayType\}()} is a \hyperlink{16514427843815723867}{\texttt{BroadcastStyle}} indicating that an object behaves as an array for broadcasting. It presents a simple way to construct \hyperlink{18399209409025901494}{\texttt{Broadcast.AbstractArrayStyle}}s for specific \texttt{AbstractArray} container types. Broadcast styles created this way lose track of dimensionality; if keeping track is important for your type, you should create your own custom \hyperlink{18399209409025901494}{\texttt{Broadcast.AbstractArrayStyle}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/broadcast.jl#L79-L85}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5203521679854231580}{} 
\hyperlink{5203521679854231580}{\texttt{Base.Broadcast.DefaultArrayStyle}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

\texttt{Broadcast.DefaultArrayStyle\{N\}()} is a \hyperlink{16514427843815723867}{\texttt{BroadcastStyle}} indicating that an object behaves as an \texttt{N}-dimensional array for broadcasting. Specifically, \texttt{DefaultArrayStyle} is used for any \texttt{AbstractArray} type that hasn{\textquotesingle}t defined a specialized style, and in the absence of overrides from other \texttt{broadcast} arguments the resulting output type is \texttt{Array}. When there are multiple inputs to \texttt{broadcast}, \texttt{DefaultArrayStyle} {\textquotedbl}loses{\textquotedbl} to any other \hyperlink{7130961038203619012}{\texttt{Broadcast.ArrayStyle}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/broadcast.jl#L89-L96}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3229213625072672556}{} 
\hyperlink{3229213625072672556}{\texttt{Base.Broadcast.broadcastable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Broadcast.broadcastable(x)
\end{minted}

Return either \texttt{x} or an object like \texttt{x} such that it supports \hyperlink{7074821531920287868}{\texttt{axes}}, indexing, and its type supports \hyperlink{1688406579181746010}{\texttt{ndims}}.

If \texttt{x} supports iteration, the returned value should have the same \texttt{axes} and indexing behaviors as \hyperlink{6278865767444641812}{\texttt{collect(x)}}.

If \texttt{x} is not an \texttt{AbstractArray} but it supports \texttt{axes}, indexing, and its type supports \texttt{ndims}, then \texttt{broadcastable(::typeof(x))} may be implemented to just return itself. Further, if \texttt{x} defines its own \hyperlink{16514427843815723867}{\texttt{BroadcastStyle}}, then it must define its \texttt{broadcastable} method to return itself for the custom style to have any effect.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Broadcast.broadcastable([1,2,3]) # like `identity` since arrays already support axes and indexing
3-element Array{Int64,1}:
 1
 2
 3

julia> Broadcast.broadcastable(Int) # Types don't support axes, indexing, or iteration but are commonly used as scalars
Base.RefValue{Type{Int64}}(Int64)

julia> Broadcast.broadcastable("hello") # Strings break convention of matching iteration and act like a scalar instead
Base.RefValue{String}("hello")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/broadcast.jl#L633-L660}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12795693983059633766}{} 
\hyperlink{12795693983059633766}{\texttt{Base.Broadcast.combine\_axes}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
combine_axes(As...) -> Tuple
\end{minted}

Determine the result axes for broadcasting across all values in \texttt{As}.


\begin{minted}{jlcon}
julia> Broadcast.combine_axes([1], [1 2; 3 4; 5 6])
(Base.OneTo(3), Base.OneTo(2))

julia> Broadcast.combine_axes(1, 1, 1)
()
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/broadcast.jl#L460-L472}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17310024314901524845}{} 
\hyperlink{17310024314901524845}{\texttt{Base.Broadcast.combine\_styles}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
combine_styles(cs...) -> BroadcastStyle
\end{minted}

Decides which \texttt{BroadcastStyle} to use for any number of value arguments. Uses \hyperlink{16514427843815723867}{\texttt{BroadcastStyle}} to get the style for each argument, and uses \hyperlink{6339732363631296845}{\texttt{result\_style}} to combine styles.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Broadcast.combine_styles([1], [1 2; 3 4])
Base.Broadcast.DefaultArrayStyle{2}()
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/broadcast.jl#L393-L406}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6339732363631296845}{} 
\hyperlink{6339732363631296845}{\texttt{Base.Broadcast.result\_style}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
result_style(s1::BroadcastStyle[, s2::BroadcastStyle]) -> BroadcastStyle
\end{minted}

Takes one or two \texttt{BroadcastStyle}s and combines them using \hyperlink{16514427843815723867}{\texttt{BroadcastStyle}} to determine a common \texttt{BroadcastStyle}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Broadcast.result_style(Broadcast.DefaultArrayStyle{0}(), Broadcast.DefaultArrayStyle{3}())
Base.Broadcast.DefaultArrayStyle{3}()

julia> Broadcast.result_style(Broadcast.Unknown(), Broadcast.DefaultArrayStyle{1}())
Base.Broadcast.DefaultArrayStyle{1}()
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/broadcast.jl#L414-L429}{\texttt{source}}


\end{adjustwidth}

\hypertarget{9968114529093360286}{}


\section{索引与赋值}


\hypertarget{70337294579126602}{} 
\hyperlink{70337294579126602}{\texttt{Base.getindex}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getindex(A, inds...)
\end{minted}

Return a subset of array \texttt{A} as specified by \texttt{inds}, where each \texttt{ind} may be an \texttt{Int}, an \hyperlink{13239199982495881110}{\texttt{AbstractRange}}, or a \hyperlink{10571362059486397014}{\texttt{Vector}}. See the manual section on \hyperlink{16717190941363337071}{array indexing} for details.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> getindex(A, 1)
1

julia> getindex(A, [2, 1])
2-element Array{Int64,1}:
 3
 1

julia> getindex(A, 2:4)
3-element Array{Int64,1}:
 3
 2
 4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L948-L976}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17903591429492118749}{} 
\hyperlink{17903591429492118749}{\texttt{Base.setindex!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
setindex!(A, X, inds...)
A[inds...] = X
\end{minted}

Store values from array \texttt{X} within some subset of \texttt{A} as specified by \texttt{inds}. The syntax \texttt{A[inds...] = X} is equivalent to \texttt{setindex!(A, X, inds...)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = zeros(2,2);

julia> setindex!(A, [10, 20], [1, 2]);

julia> A[[3, 4]] = [30, 40];

julia> A
2×2 Array{Float64,2}:
 10.0  30.0
 20.0  40.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L1049-L1069}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12981203184789384401}{} 
\hyperlink{12981203184789384401}{\texttt{Base.copyto!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
copyto!(dest, Rdest::CartesianIndices, src, Rsrc::CartesianIndices) -> dest
\end{minted}

Copy the block of \texttt{src} in the range of \texttt{Rsrc} to the block of \texttt{dest} in the range of \texttt{Rdest}. The sizes of the two regions must match.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L993-L998}{\texttt{source}}


\end{adjustwidth}
\hypertarget{976355747478401147}{} 
\hyperlink{976355747478401147}{\texttt{Base.isassigned}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isassigned(array, i) -> Bool
\end{minted}

Test whether the given array has a value associated with index \texttt{i}. Return \texttt{false} if the index is out of bounds, or has an undefined reference.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isassigned(rand(3, 3), 5)
true

julia> isassigned(rand(3, 3), 3 * 3 + 1)
false

julia> mutable struct Foo end

julia> v = similar(rand(3), Foo)
3-element Array{Foo,1}:
 #undef
 #undef
 #undef

julia> isassigned(v, 1)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L622-L647}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13649361117037263099}{} 
\hyperlink{13649361117037263099}{\texttt{Base.Colon}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Colon()
\end{minted}

Colons (:) are used to signify indexing entire objects or dimensions at once.

Very few operations are defined on Colons directly; instead they are converted by \hyperlink{10027537986402266830}{\texttt{to\_indices}} to an internal vector type (\texttt{Base.Slice}) to represent the collection of indices they span before being used.

The singleton instance of \texttt{Colon} is also a function used to construct ranges; see \hyperlink{1027906901078185239}{\texttt{:}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L659-L670}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4571802376991525093}{} 
\hyperlink{4571802376991525093}{\texttt{Base.IteratorsMD.CartesianIndex}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
CartesianIndex(i, j, k...)   -> I
CartesianIndex((i, j, k...)) -> I
\end{minted}

Create a multidimensional index \texttt{I}, which can be used for indexing a multidimensional array \texttt{A}.  In particular, \texttt{A[I]} is equivalent to \texttt{A[i,j,k...]}.  One can freely mix integer and \texttt{CartesianIndex} indices; for example, \texttt{A[Ipre, i, Ipost]} (where \texttt{Ipre} and \texttt{Ipost} are \texttt{CartesianIndex} indices and \texttt{i} is an \texttt{Int}) can be a useful expression when writing algorithms that work along a single dimension of an array of arbitrary dimensionality.

A \texttt{CartesianIndex} is sometimes produced by \hyperlink{4701773772897287974}{\texttt{eachindex}}, and always when iterating with an explicit \hyperlink{16831958174907250244}{\texttt{CartesianIndices}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = reshape(Vector(1:16), (2, 2, 2, 2))
2×2×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia> A[CartesianIndex((1, 1, 1, 1))]
1

julia> A[CartesianIndex((1, 1, 1, 2))]
9

julia> A[CartesianIndex((1, 1, 2, 1))]
5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L17-L62}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16831958174907250244}{} 
\hyperlink{16831958174907250244}{\texttt{Base.IteratorsMD.CartesianIndices}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
CartesianIndices(sz::Dims) -> R
CartesianIndices((istart:istop, jstart:jstop, ...)) -> R
\end{minted}

Define a region \texttt{R} spanning a multidimensional rectangular range of integer indices. These are most commonly encountered in the context of iteration, where \texttt{for I in R ... end} will return \hyperlink{4571802376991525093}{\texttt{CartesianIndex}} indices \texttt{I} equivalent to the nested loops


\begin{lstlisting}
for j = jstart:jstop
    for i = istart:istop
        ...
    end
end
\end{lstlisting}

Consequently these can be useful for writing algorithms that work in arbitrary dimensions.


\begin{lstlisting}
CartesianIndices(A::AbstractArray) -> R
\end{lstlisting}

As a convenience, constructing a \texttt{CartesianIndices} from an array makes a range of its indices.

\textbf{Examples}


\begin{minted}{jlcon}
julia> foreach(println, CartesianIndices((2, 2, 2)))
CartesianIndex(1, 1, 1)
CartesianIndex(2, 1, 1)
CartesianIndex(1, 2, 1)
CartesianIndex(2, 2, 1)
CartesianIndex(1, 1, 2)
CartesianIndex(2, 1, 2)
CartesianIndex(1, 2, 2)
CartesianIndex(2, 2, 2)

julia> CartesianIndices(fill(1, (2,3)))
2×3 CartesianIndices{2,Tuple{Base.OneTo{Int64},Base.OneTo{Int64}}}:
 CartesianIndex(1, 1)  CartesianIndex(1, 2)  CartesianIndex(1, 3)
 CartesianIndex(2, 1)  CartesianIndex(2, 2)  CartesianIndex(2, 3)
\end{minted}

\textbf{Conversion between linear and cartesian indices}

Linear index to cartesian index conversion exploits the fact that a \texttt{CartesianIndices} is an \texttt{AbstractArray} and can be indexed linearly:


\begin{minted}{jlcon}
julia> cartesian = CartesianIndices((1:3, 1:2))
3×2 CartesianIndices{2,Tuple{UnitRange{Int64},UnitRange{Int64}}}:
 CartesianIndex(1, 1)  CartesianIndex(1, 2)
 CartesianIndex(2, 1)  CartesianIndex(2, 2)
 CartesianIndex(3, 1)  CartesianIndex(3, 2)

julia> cartesian[4]
CartesianIndex(1, 2)
\end{minted}

\textbf{Broadcasting}

\texttt{CartesianIndices} support broadcasting arithmetic (+ and -) with a \texttt{CartesianIndex}.

\begin{quote}
\textbf{Julia 1.1}

Broadcasting of CartesianIndices requires at least Julia 1.1.

\end{quote}

\begin{minted}{jlcon}
julia> CIs = CartesianIndices((2:3, 5:6))
2×2 CartesianIndices{2,Tuple{UnitRange{Int64},UnitRange{Int64}}}:
 CartesianIndex(2, 5)  CartesianIndex(2, 6)
 CartesianIndex(3, 5)  CartesianIndex(3, 6)

julia> CI = CartesianIndex(3, 4)
CartesianIndex(3, 4)

julia> CIs .+ CI
2×2 CartesianIndices{2,Tuple{UnitRange{Int64},UnitRange{Int64}}}:
 CartesianIndex(5, 9)  CartesianIndex(5, 10)
 CartesianIndex(6, 9)  CartesianIndex(6, 10)
\end{minted}

For cartesian to linear index conversion, see \hyperlink{12250457823889413092}{\texttt{LinearIndices}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L168-L248}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16915357711927325718}{} 
\hyperlink{16915357711927325718}{\texttt{Base.Dims}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Dims{N}
\end{minted}

An \texttt{NTuple} of \texttt{N} \texttt{Int}s used to represent the dimensions of an \hyperlink{6514416309183787338}{\texttt{AbstractArray}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/indices.jl#L3-L8}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12250457823889413092}{} 
\hyperlink{12250457823889413092}{\texttt{Base.LinearIndices}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LinearIndices(A::AbstractArray)
\end{minted}

Return a \texttt{LinearIndices} array with the same shape and \hyperlink{7074821531920287868}{\texttt{axes}} as \texttt{A}, holding the linear index of each entry in \texttt{A}. Indexing this array with cartesian indices allows mapping them to linear indices.

For arrays with conventional indexing (indices start at 1), or any multidimensional array, linear indices range from 1 to \texttt{length(A)}. However, for \texttt{AbstractVector}s linear indices are \texttt{axes(A, 1)}, and therefore do not start at 1 for vectors with unconventional indexing.

Calling this function is the {\textquotedbl}safe{\textquotedbl} way to write algorithms that exploit linear indexing.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = fill(1, (5,6,7));

julia> b = LinearIndices(A);

julia> extrema(b)
(1, 210)
\end{minted}


\begin{lstlisting}
LinearIndices(inds::CartesianIndices) -> R
LinearIndices(sz::Dims) -> R
LinearIndices((istart:istop, jstart:jstop, ...)) -> R
\end{lstlisting}

Return a \texttt{LinearIndices} array with the specified shape or \hyperlink{7074821531920287868}{\texttt{axes}}.

\textbf{Example}

The main purpose of this constructor is intuitive conversion from cartesian to linear indexing:


\begin{minted}{jlcon}
julia> linear = LinearIndices((1:3, 1:2))
3×2 LinearIndices{2,Tuple{UnitRange{Int64},UnitRange{Int64}}}:
 1  4
 2  5
 3  6

julia> linear[1,2]
4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/indices.jl#L396-L442}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10027537986402266830}{} 
\hyperlink{10027537986402266830}{\texttt{Base.to\_indices}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
to_indices(A, I::Tuple)
\end{minted}

Convert the tuple \texttt{I} to a tuple of indices for use in indexing into array \texttt{A}.

The returned tuple must only contain either \texttt{Int}s or \texttt{AbstractArray}s of scalar indices that are supported by array \texttt{A}. It will error upon encountering a novel index type that it does not know how to process.

For simple index types, it defers to the unexported \texttt{Base.to\_index(A, i)} to process each index \texttt{i}. While this internal function is not intended to be called directly, \texttt{Base.to\_index} may be extended by custom array or index types to provide custom indexing behaviors.

More complicated index types may require more context about the dimension into which they index. To support those cases, \texttt{to\_indices(A, I)} calls \texttt{to\_indices(A, axes(A), I)}, which then recursively walks through both the given tuple of indices and the dimensional indices of \texttt{A} in tandem. As such, not all index types are guaranteed to propagate to \texttt{Base.to\_index}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/indices.jl#L301-L320}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6593895036014271495}{} 
\hyperlink{6593895036014271495}{\texttt{Base.checkbounds}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
checkbounds(Bool, A, I...)
\end{minted}

Return \texttt{true} if the specified indices \texttt{I} are in bounds for the given array \texttt{A}. Subtypes of \texttt{AbstractArray} should specialize this method if they need to provide custom bounds checking behaviors; however, in many cases one can rely on \texttt{A}{\textquotesingle}s indices and \hyperlink{4607154172896664089}{\texttt{checkindex}}.

See also \hyperlink{4607154172896664089}{\texttt{checkindex}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = rand(3, 3);

julia> checkbounds(Bool, A, 2)
true

julia> checkbounds(Bool, A, 3, 4)
false

julia> checkbounds(Bool, A, 1:3)
true

julia> checkbounds(Bool, A, 1:3, 2:4)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L452-L478}{\texttt{source}}



\begin{lstlisting}
checkbounds(A, I...)
\end{lstlisting}

Throw an error if the specified indices \texttt{I} are not in bounds for the given array \texttt{A}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L495-L499}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4607154172896664089}{} 
\hyperlink{4607154172896664089}{\texttt{Base.checkindex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
checkindex(Bool, inds::AbstractUnitRange, index)
\end{minted}

Return \texttt{true} if the given \texttt{index} is within the bounds of \texttt{inds}. Custom types that would like to behave as indices for all arrays can extend this method in order to provide a specialized bounds checking implementation.

\textbf{Examples}


\begin{minted}{jlcon}
julia> checkindex(Bool, 1:20, 8)
true

julia> checkindex(Bool, 1:20, 21)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L540-L556}{\texttt{source}}


\end{adjustwidth}

\hypertarget{3647642488568491652}{}


\section{Views (SubArrays 以及其它 view 类型)}



A “view” is a data structure that acts like an array (it is a subtype of \texttt{AbstractArray}), but the underlying data is actually part of another array.



For example, if \texttt{x} is an array and \texttt{v = @view x[1:10]}, then \texttt{v} acts like a 10-element array, but its data is actually accessing the first 10 elements of \texttt{x}. Writing to a view, e.g. \texttt{v[3] = 2}, writes directly to the underlying array \texttt{x} (in this case modifying \texttt{x[3]}).



Slicing operations like \texttt{x[1:10]} create a copy by default in Julia. \texttt{@view x[1:10]} changes it to make a view. The \texttt{@views} macro can be used on a whole block of code (e.g. \texttt{@views function foo() .... end} or \texttt{@views begin ... end}) to change all the slicing operations in that block to use views.  Sometimes making a copy of the data is faster and sometimes using a view is faster, as described in the \hyperlink{7873250295862620958}{performance tips}.


\hypertarget{4861450464669906845}{} 
\hyperlink{4861450464669906845}{\texttt{Base.view}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
view(A, inds...)
\end{minted}

Like \hyperlink{13720608614876840481}{\texttt{getindex}}, but returns a view into the parent array \texttt{A} with the given indices instead of making a copy.  Calling \hyperlink{13720608614876840481}{\texttt{getindex}} or \hyperlink{1309244355901386657}{\texttt{setindex!}} on the returned \texttt{SubArray} computes the indices to the parent array on the fly without checking bounds.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> b = view(A, :, 1)
2-element view(::Array{Int64,2}, :, 1) with eltype Int64:
 1
 3

julia> fill!(b, 0)
2-element view(::Array{Int64,2}, :, 1) with eltype Int64:
 0
 0

julia> A # Note A has changed even though we modified b
2×2 Array{Int64,2}:
 0  2
 0  4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/subarray.jl#L129-L159}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4916348678965327831}{} 
\hyperlink{4916348678965327831}{\texttt{Base.@view}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@view A[inds...]
\end{minted}

Creates a \texttt{SubArray} from an indexing expression. This can only be applied directly to a reference expression (e.g. \texttt{@view A[1,2:end]}), and should \emph{not} be used as the target of an assignment (e.g. \texttt{@view(A[1,2:end]) = ...}).  See also \hyperlink{4544474300423667148}{\texttt{@views}} to switch an entire block of code to use views for slicing.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> b = @view A[:, 1]
2-element view(::Array{Int64,2}, :, 1) with eltype Int64:
 1
 3

julia> fill!(b, 0)
2-element view(::Array{Int64,2}, :, 1) with eltype Int64:
 0
 0

julia> A
2×2 Array{Int64,2}:
 0  2
 0  4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/views.jl#L72-L102}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4544474300423667148}{} 
\hyperlink{4544474300423667148}{\texttt{Base.@views}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@views expression
\end{minted}

Convert every array-slicing operation in the given expression (which may be a \texttt{begin}/\texttt{end} block, loop, function, etc.) to return a view. Scalar indices, non-array types, and explicit \hyperlink{13720608614876840481}{\texttt{getindex}} calls (as opposed to \texttt{array[...]}) are unaffected.

\begin{quote}
\textbf{Note}

The \texttt{@views} macro only affects \texttt{array[...]} expressions that appear explicitly in the given \texttt{expression}, not array slicing that occurs in functions called by that code.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = zeros(3, 3);

julia> @views for row in 1:3
           b = A[row, :]
           b[:] .= row
       end

julia> A
3×3 Array{Float64,2}:
 1.0  1.0  1.0
 2.0  2.0  2.0
 3.0  3.0  3.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/views.jl#L183-L212}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11732113189086969263}{} 
\hyperlink{11732113189086969263}{\texttt{Base.parent}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
parent(A)
\end{minted}

Returns the {\textquotedbl}parent array{\textquotedbl} of an array view type (e.g., \texttt{SubArray}), or the array itself if it is not a view.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> V = view(A, 1:2, :)
2×2 view(::Array{Int64,2}, 1:2, :) with eltype Int64:
 1  2
 3  4

julia> parent(V)
2×2 Array{Int64,2}:
 1  2
 3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L1112-L1135}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16743033525479285274}{} 
\hyperlink{16743033525479285274}{\texttt{Base.parentindices}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
parentindices(A)
\end{minted}

Return the indices in the \hyperlink{11732113189086969263}{\texttt{parent}} which correspond to the array view \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4];

julia> V = view(A, 1, :)
2-element view(::Array{Int64,2}, 1, :) with eltype Int64:
 1
 2

julia> parentindices(V)
(1, Base.Slice(Base.OneTo(2)))
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/subarray.jl#L82-L99}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16041553215191638546}{} 
\hyperlink{16041553215191638546}{\texttt{Base.selectdim}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
selectdim(A, d::Integer, i)
\end{minted}

Return a view of all the data of \texttt{A} where the index for dimension \texttt{d} equals \texttt{i}.

Equivalent to \texttt{view(A,:,:,...,i,:,:,...)} where \texttt{i} is in position \texttt{d}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2 3 4; 5 6 7 8]
2×4 Array{Int64,2}:
 1  2  3  4
 5  6  7  8

julia> selectdim(A, 2, 3)
2-element view(::Array{Int64,2}, :, 3) with eltype Int64:
 3
 7
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarraymath.jl#L102-L121}{\texttt{source}}


\end{adjustwidth}
\hypertarget{293815781001952115}{} 
\hyperlink{293815781001952115}{\texttt{Base.reinterpret}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reinterpret(type, A)
\end{minted}

Change the type-interpretation of a block of memory. For arrays, this constructs a view of the array with the same binary data as the given array, but with the specified element type. For example, \texttt{reinterpret(Float32, UInt32(7))} interprets the 4 bytes corresponding to \texttt{UInt32(7)} as a \hyperlink{8101639384272933082}{\texttt{Float32}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> reinterpret(Float32, UInt32(7))
1.0f-44

julia> reinterpret(Float32, UInt32[1 2 3 4 5])
1×5 reinterpret(Float32, ::Array{UInt32,2}):
 1.0f-45  3.0f-45  4.0f-45  6.0f-45  7.0f-45
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L396-L415}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3388738163419525310}{} 
\hyperlink{3388738163419525310}{\texttt{Base.reshape}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reshape(A, dims...) -> AbstractArray
reshape(A, dims) -> AbstractArray
\end{minted}

Return an array with the same data as \texttt{A}, but with different dimension sizes or number of dimensions. The two arrays share the same underlying data, so that the result is mutable if and only if \texttt{A} is mutable, and setting elements of one alters the values of the other.

The new dimensions may be specified either as a list of arguments or as a shape tuple. At most one dimension may be specified with a \texttt{:}, in which case its length is computed such that its product with all the specified dimensions is equal to the length of the original array \texttt{A}. The total number of elements must not change.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = Vector(1:16)
16-element Array{Int64,1}:
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16

julia> reshape(A, (4, 4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> reshape(A, 2, :)
2×8 Array{Int64,2}:
 1  3  5  7   9  11  13  15
 2  4  6  8  10  12  14  16

julia> reshape(1:6, 2, 3)
2×3 reshape(::UnitRange{Int64}, 2, 3) with eltype Int64:
 1  3  5
 2  4  6
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/reshapedarray.jl#L54-L107}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18382575660271190579}{} 
\hyperlink{18382575660271190579}{\texttt{Base.dropdims}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dropdims(A; dims)
\end{minted}

Remove the dimensions specified by \texttt{dims} from array \texttt{A}. Elements of \texttt{dims} must be unique and within the range \texttt{1:ndims(A)}. \texttt{size(A,i)} must equal 1 for all \texttt{i} in \texttt{dims}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = reshape(Vector(1:4),(2,2,1,1))
2×2×1×1 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

julia> dropdims(a; dims=3)
2×2×1 Array{Int64,3}:
[:, :, 1] =
 1  3
 2  4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarraymath.jl#L48-L69}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18435874855636770528}{} 
\hyperlink{18435874855636770528}{\texttt{Base.vec}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
vec(a::AbstractArray) -> AbstractVector
\end{minted}

Reshape the array \texttt{a} as a one-dimensional column vector. Return \texttt{a} if it is already an \texttt{AbstractVector}. The resulting array shares the same underlying data as \texttt{a}, so it will only be mutable if \texttt{a} is mutable, in which case modifying one will also modify the other.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia> vec(a)
6-element Array{Int64,1}:
 1
 4
 2
 5
 3
 6

julia> vec(1:3)
1:3
\end{minted}

See also \hyperlink{3388738163419525310}{\texttt{reshape}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarraymath.jl#L11-L40}{\texttt{source}}


\end{adjustwidth}

\hypertarget{10571026513640698597}{}


\section{Concatenation and permutation}


\hypertarget{9868138443525443234}{} 
\hyperlink{9868138443525443234}{\texttt{Base.cat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cat(A...; dims=dims)
\end{minted}

Concatenate the input arrays along the specified dimensions in the iterable \texttt{dims}. For dimensions not in \texttt{dims}, all input arrays should have the same size, which will also be the size of the output array along that dimension. For dimensions in \texttt{dims}, the size of the output array is the sum of the sizes of the input arrays along that dimension. If \texttt{dims} is a single number, the different arrays are tightly stacked along that dimension. If \texttt{dims} is an iterable containing several dimensions, this allows one to construct block diagonal matrices and their higher-dimensional analogues by simultaneously increasing several dimensions for every new input array and putting zero blocks elsewhere. For example, \texttt{cat(matrices...; dims=(1,2))} builds a block diagonal matrix, i.e. a block matrix with \texttt{matrices[1]}, \texttt{matrices[2]}, ... as diagonal blocks and matching zero blocks away from the diagonal.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L1549-L1563}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14691815416955507876}{} 
\hyperlink{14691815416955507876}{\texttt{Base.vcat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
vcat(A...)
\end{minted}

Concatenate along dimension 1.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2 3 4 5]
1×5 Array{Int64,2}:
 1  2  3  4  5

julia> b = [6 7 8 9 10; 11 12 13 14 15]
2×5 Array{Int64,2}:
  6   7   8   9  10
 11  12  13  14  15

julia> vcat(a,b)
3×5 Array{Int64,2}:
  1   2   3   4   5
  6   7   8   9  10
 11  12  13  14  15

julia> c = ([1 2 3], [4 5 6])
([1 2 3], [4 5 6])

julia> vcat(c...)
2×3 Array{Int64,2}:
 1  2  3
 4  5  6
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L1471-L1501}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8862791894748483563}{} 
\hyperlink{8862791894748483563}{\texttt{Base.hcat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hcat(A...)
\end{minted}

Concatenate along dimension 2.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1; 2; 3; 4; 5]
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia> b = [6 7; 8 9; 10 11; 12 13; 14 15]
5×2 Array{Int64,2}:
  6   7
  8   9
 10  11
 12  13
 14  15

julia> hcat(a,b)
5×3 Array{Int64,2}:
 1   6   7
 2   8   9
 3  10  11
 4  12  13
 5  14  15

julia> c = ([1; 2; 3], [4; 5; 6])
([1, 2, 3], [4, 5, 6])

julia> hcat(c...)
3×2 Array{Int64,2}:
 1  4
 2  5
 3  6
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L1503-L1543}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16279083053557795116}{} 
\hyperlink{16279083053557795116}{\texttt{Base.hvcat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hvcat(rows::Tuple{Vararg{Int}}, values...)
\end{minted}

Horizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a, b, c, d, e, f = 1, 2, 3, 4, 5, 6
(1, 2, 3, 4, 5, 6)

julia> [a b c; d e f]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia> hvcat((3,3), a,b,c,d,e,f)
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia> [a b;c d; e f]
3×2 Array{Int64,2}:
 1  2
 3  4
 5  6

julia> hvcat((2,2,2), a,b,c,d,e,f)
3×2 Array{Int64,2}:
 1  2
 3  4
 5  6
\end{minted}

If the first argument is a single integer \texttt{n}, then all block rows are assumed to have \texttt{n} block columns.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L1594-L1631}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2932104842023453623}{} 
\hyperlink{2932104842023453623}{\texttt{Base.vect}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
vect(X...)
\end{minted}

Create a \hyperlink{10571362059486397014}{\texttt{Vector}} with element type computed from the \texttt{promote\_typeof} of the argument, containing the argument list.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = Base.vect(UInt8(1), 2.5, 1//2)
3-element Array{Float64,1}:
 1.0
 2.5
 0.5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L132-L146}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15182910221850902862}{} 
\hyperlink{15182910221850902862}{\texttt{Base.circshift}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
circshift(A, shifts)
\end{minted}

Circularly shift, i.e. rotate, the data in an array. The second argument is a tuple or vector giving the amount to shift in each dimension, or an integer to shift only in the first dimension.

\textbf{Examples}


\begin{minted}{jlcon}
julia> b = reshape(Vector(1:16), (4,4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> circshift(b, (0,2))
4×4 Array{Int64,2}:
  9  13  1  5
 10  14  2  6
 11  15  3  7
 12  16  4  8

julia> circshift(b, (-1,0))
4×4 Array{Int64,2}:
 2  6  10  14
 3  7  11  15
 4  8  12  16
 1  5   9  13

julia> a = BitArray([true, true, false, false, true])
5-element BitArray{1}:
 1
 1
 0
 0
 1

julia> circshift(a, 1)
5-element BitArray{1}:
 1
 1
 1
 0
 0

julia> circshift(a, -1)
5-element BitArray{1}:
 1
 0
 0
 1
 1
\end{minted}

See also \hyperlink{5319002815154535997}{\texttt{circshift!}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarraymath.jl#L184-L240}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5319002815154535997}{} 
\hyperlink{5319002815154535997}{\texttt{Base.circshift!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
circshift!(dest, src, shifts)
\end{minted}

Circularly shift, i.e. rotate, the data in \texttt{src}, storing the result in \texttt{dest}. \texttt{shifts} specifies the amount to shift in each dimension.

The \texttt{dest} array must be distinct from the \texttt{src} array (they cannot alias each other).

See also \hyperlink{15182910221850902862}{\texttt{circshift}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L1003-L1013}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13256910868822648458}{} 
\hyperlink{13256910868822648458}{\texttt{Base.circcopy!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
circcopy!(dest, src)
\end{minted}

Copy \texttt{src} to \texttt{dest}, indexing each dimension modulo its length. \texttt{src} and \texttt{dest} must have the same size, but can be offset in their indices; any offset results in a (circular) wraparound. If the arrays have overlapping indices, then on the domain of the overlap \texttt{dest} agrees with \texttt{src}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> src = reshape(Vector(1:16), (4,4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> dest = OffsetArray{Int}(undef, (0:3,2:5))

julia> circcopy!(dest, src)
OffsetArrays.OffsetArray{Int64,2,Array{Int64,2}} with indices 0:3×2:5:
 8  12  16  4
 5   9  13  1
 6  10  14  2
 7  11  15  3

julia> dest[1:3,2:4] == src[1:3,2:4]
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L1056-L1086}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16067208921941164599}{} 
\hyperlink{16067208921941164599}{\texttt{Base.findall}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findall(A)
\end{minted}

Return a vector \texttt{I} of the \texttt{true} indices or keys of \texttt{A}. If there are no such elements of \texttt{A}, return an empty array. To search for other kinds of values, pass a predicate as the first argument.

Indices or keys are of the same type as those returned by \hyperlink{6023948435845840069}{\texttt{keys(A)}} and \hyperlink{15543779110977484852}{\texttt{pairs(A)}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [true, false, false, true]
4-element Array{Bool,1}:
 1
 0
 0
 1

julia> findall(A)
2-element Array{Int64,1}:
 1
 4

julia> A = [true false; false true]
2×2 Array{Bool,2}:
 1  0
 0  1

julia> findall(A)
2-element Array{CartesianIndex{2},1}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 2)

julia> findall(falses(3))
0-element Array{Int64,1}
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L2026-L2063}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5230048188611808574}{} 
\hyperlink{5230048188611808574}{\texttt{Base.findall}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findall(f::Function, A)
\end{minted}

Return a vector \texttt{I} of the indices or keys of \texttt{A} where \texttt{f(A[I])} returns \texttt{true}. If there are no such elements of \texttt{A}, return an empty array.

Indices or keys are of the same type as those returned by \hyperlink{6023948435845840069}{\texttt{keys(A)}} and \hyperlink{15543779110977484852}{\texttt{pairs(A)}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = [1, 3, 4]
3-element Array{Int64,1}:
 1
 3
 4

julia> findall(isodd, x)
2-element Array{Int64,1}:
 1
 2

julia> A = [1 2 0; 3 4 0]
2×3 Array{Int64,2}:
 1  2  0
 3  4  0
julia> findall(isodd, A)
2-element Array{CartesianIndex{2},1}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 1)

julia> findall(!iszero, A)
4-element Array{CartesianIndex{2},1}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 1)
 CartesianIndex(1, 2)
 CartesianIndex(2, 2)

julia> d = Dict(:A => 10, :B => -1, :C => 0)
Dict{Symbol,Int64} with 3 entries:
  :A => 10
  :B => -1
  :C => 0

julia> findall(x -> x >= 0, d)
2-element Array{Symbol,1}:
 :A
 :C

\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1973-L2023}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13752961745140943082}{} 
\hyperlink{13752961745140943082}{\texttt{Base.findfirst}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findfirst(A)
\end{minted}

Return the index or key of the first \texttt{true} value in \texttt{A}. Return \texttt{nothing} if no such value is found. To search for other kinds of values, pass a predicate as the first argument.

Indices or keys are of the same type as those returned by \hyperlink{6023948435845840069}{\texttt{keys(A)}} and \hyperlink{15543779110977484852}{\texttt{pairs(A)}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [false, false, true, false]
4-element Array{Bool,1}:
 0
 0
 1
 0

julia> findfirst(A)
3

julia> findfirst(falses(3)) # returns nothing, but not printed in the REPL

julia> A = [false false; true false]
2×2 Array{Bool,2}:
 0  0
 1  0

julia> findfirst(A)
CartesianIndex(2, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1658-L1690}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10686327966799324598}{} 
\hyperlink{10686327966799324598}{\texttt{Base.findfirst}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findfirst(predicate::Function, A)
\end{minted}

Return the index or key of the first element of \texttt{A} for which \texttt{predicate} returns \texttt{true}. Return \texttt{nothing} if there is no such element.

Indices or keys are of the same type as those returned by \hyperlink{6023948435845840069}{\texttt{keys(A)}} and \hyperlink{15543779110977484852}{\texttt{pairs(A)}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1, 4, 2, 2]
4-element Array{Int64,1}:
 1
 4
 2
 2

julia> findfirst(iseven, A)
2

julia> findfirst(x -> x>10, A) # returns nothing, but not printed in the REPL

julia> findfirst(isequal(4), A)
2

julia> A = [1 4; 2 2]
2×2 Array{Int64,2}:
 1  4
 2  2

julia> findfirst(iseven, A)
CartesianIndex(2, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1740-L1774}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16601358451866933976}{} 
\hyperlink{16601358451866933976}{\texttt{Base.findlast}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findlast(A)
\end{minted}

Return the index or key of the last \texttt{true} value in \texttt{A}. Return \texttt{nothing} if there is no \texttt{true} value in \texttt{A}.

Indices or keys are of the same type as those returned by \hyperlink{6023948435845840069}{\texttt{keys(A)}} and \hyperlink{15543779110977484852}{\texttt{pairs(A)}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [true, false, true, false]
4-element Array{Bool,1}:
 1
 0
 1
 0

julia> findlast(A)
3

julia> A = falses(2,2);

julia> findlast(A) # returns nothing, but not printed in the REPL

julia> A = [true false; true false]
2×2 Array{Bool,2}:
 1  0
 1  0

julia> findlast(A)
CartesianIndex(2, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1839-L1872}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13690191743392331122}{} 
\hyperlink{13690191743392331122}{\texttt{Base.findlast}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findlast(predicate::Function, A)
\end{minted}

Return the index or key of the last element of \texttt{A} for which \texttt{predicate} returns \texttt{true}. Return \texttt{nothing} if there is no such element.

Indices or keys are of the same type as those returned by \hyperlink{6023948435845840069}{\texttt{keys(A)}} and \hyperlink{15543779110977484852}{\texttt{pairs(A)}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1, 2, 3, 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> findlast(isodd, A)
3

julia> findlast(x -> x > 5, A) # returns nothing, but not printed in the REPL

julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> findlast(isodd, A)
CartesianIndex(2, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1930-L1961}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9906000186778518011}{} 
\hyperlink{9906000186778518011}{\texttt{Base.findnext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findnext(A, i)
\end{minted}

Find the next index after or including \texttt{i} of a \texttt{true} element of \texttt{A}, or \texttt{nothing} if not found.

Indices are of the same type as those returned by \hyperlink{6023948435845840069}{\texttt{keys(A)}} and \hyperlink{15543779110977484852}{\texttt{pairs(A)}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [false, false, true, false]
4-element Array{Bool,1}:
 0
 0
 1
 0

julia> findnext(A, 1)
3

julia> findnext(A, 4) # returns nothing, but not printed in the REPL

julia> A = [false false; true false]
2×2 Array{Bool,2}:
 0  0
 1  0

julia> findnext(A, CartesianIndex(1, 1))
CartesianIndex(2, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1613-L1644}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2433853860677249610}{} 
\hyperlink{2433853860677249610}{\texttt{Base.findnext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findnext(predicate::Function, A, i)
\end{minted}

Find the next index after or including \texttt{i} of an element of \texttt{A} for which \texttt{predicate} returns \texttt{true}, or \texttt{nothing} if not found.

Indices are of the same type as those returned by \hyperlink{6023948435845840069}{\texttt{keys(A)}} and \hyperlink{15543779110977484852}{\texttt{pairs(A)}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1, 4, 2, 2];

julia> findnext(isodd, A, 1)
1

julia> findnext(isodd, A, 2) # returns nothing, but not printed in the REPL

julia> A = [1 4; 2 2];

julia> findnext(isodd, A, CartesianIndex(1, 1))
CartesianIndex(1, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1703-L1726}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3864667477361062614}{} 
\hyperlink{3864667477361062614}{\texttt{Base.findprev}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findprev(A, i)
\end{minted}

Find the previous index before or including \texttt{i} of a \texttt{true} element of \texttt{A}, or \texttt{nothing} if not found.

Indices are of the same type as those returned by \hyperlink{6023948435845840069}{\texttt{keys(A)}} and \hyperlink{15543779110977484852}{\texttt{pairs(A)}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [false, false, true, true]
4-element Array{Bool,1}:
 0
 0
 1
 1

julia> findprev(A, 3)
3

julia> findprev(A, 1) # returns nothing, but not printed in the REPL

julia> A = [false false; true true]
2×2 Array{Bool,2}:
 0  0
 1  1

julia> findprev(A, CartesianIndex(2, 1))
CartesianIndex(2, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1794-L1825}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17827047449430918639}{} 
\hyperlink{17827047449430918639}{\texttt{Base.findprev}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findprev(predicate::Function, A, i)
\end{minted}

Find the previous index before or including \texttt{i} of an element of \texttt{A} for which \texttt{predicate} returns \texttt{true}, or \texttt{nothing} if not found.

Indices are of the same type as those returned by \hyperlink{6023948435845840069}{\texttt{keys(A)}} and \hyperlink{15543779110977484852}{\texttt{pairs(A)}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4, 6, 1, 2]
4-element Array{Int64,1}:
 4
 6
 1
 2

julia> findprev(isodd, A, 1) # returns nothing, but not printed in the REPL

julia> findprev(isodd, A, 3)
3

julia> A = [4 6; 1 2]
2×2 Array{Int64,2}:
 4  6
 1  2

julia> findprev(isodd, A, CartesianIndex(1, 2))
CartesianIndex(2, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1885-L1916}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10913801624539723467}{} 
\hyperlink{10913801624539723467}{\texttt{Base.permutedims}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
permutedims(A::AbstractArray, perm)
\end{minted}

Permute the dimensions of array \texttt{A}. \texttt{perm} is a vector specifying a permutation of length \texttt{ndims(A)}.

See also: \hyperlink{16936235724694909186}{\texttt{PermutedDimsArray}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = reshape(Vector(1:8), (2,2,2))
2×2×2 Array{Int64,3}:
[:, :, 1] =
 1  3
 2  4

[:, :, 2] =
 5  7
 6  8

julia> permutedims(A, [3, 2, 1])
2×2×2 Array{Int64,3}:
[:, :, 1] =
 1  3
 5  7

[:, :, 2] =
 2  4
 6  8
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/permuteddimsarray.jl#L80-L110}{\texttt{source}}



\begin{lstlisting}
permutedims(m::AbstractMatrix)
\end{lstlisting}

Permute the dimensions of the matrix \texttt{m}, by flipping the elements across the diagonal of the matrix. Differs from \texttt{LinearAlgebra}{\textquotesingle}s \hyperlink{12700837529519091997}{\texttt{transpose}} in that the operation is not recursive.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4];

julia> b = [5 6; 7 8];

julia> c = [9 10; 11 12];

julia> d = [13 14; 15 16];

julia> X = [[a] [b]; [c] [d]]
2×2 Array{Array{Int64,2},2}:
 [1 2; 3 4]     [5 6; 7 8]
 [9 10; 11 12]  [13 14; 15 16]

julia> permutedims(X)
2×2 Array{Array{Int64,2},2}:
 [1 2; 3 4]  [9 10; 11 12]
 [5 6; 7 8]  [13 14; 15 16]

julia> transpose(X)
2×2 Transpose{Transpose{Int64,Array{Int64,2}},Array{Array{Int64,2},2}}:
 [1 3; 2 4]  [9 11; 10 12]
 [5 7; 6 8]  [13 15; 14 16]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/permuteddimsarray.jl#L116-L148}{\texttt{source}}



\begin{lstlisting}
permutedims(v::AbstractVector)
\end{lstlisting}

Reshape vector \texttt{v} into a \texttt{1 × length(v)} row matrix. Differs from \texttt{LinearAlgebra}{\textquotesingle}s \hyperlink{12700837529519091997}{\texttt{transpose}} in that the operation is not recursive.

\textbf{Examples}


\begin{minted}{jlcon}
julia> permutedims([1, 2, 3, 4])
1×4 Array{Int64,2}:
 1  2  3  4

julia> V = [[[1 2; 3 4]]; [[5 6; 7 8]]]
2-element Array{Array{Int64,2},1}:
 [1 2; 3 4]
 [5 6; 7 8]

julia> permutedims(V)
1×2 Array{Array{Int64,2},2}:
 [1 2; 3 4]  [5 6; 7 8]

julia> transpose(V)
1×2 Transpose{Transpose{Int64,Array{Int64,2}},Array{Array{Int64,2},1}}:
 [1 3; 2 4]  [5 7; 6 8]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/permuteddimsarray.jl#L151-L177}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15299422200414360384}{} 
\hyperlink{15299422200414360384}{\texttt{Base.permutedims!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
permutedims!(dest, src, perm)
\end{minted}

Permute the dimensions of array \texttt{src} and store the result in the array \texttt{dest}. \texttt{perm} is a vector specifying a permutation of length \texttt{ndims(src)}. The preallocated array \texttt{dest} should have \texttt{size(dest) == size(src)[perm]} and is completely overwritten. No in-place permutation is supported and unexpected results will happen if \texttt{src} and \texttt{dest} have overlapping memory regions.

See also \hyperlink{10913801624539723467}{\texttt{permutedims}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/permuteddimsarray.jl#L180-L190}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16936235724694909186}{} 
\hyperlink{16936235724694909186}{\texttt{Base.PermutedDimsArrays.PermutedDimsArray}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
PermutedDimsArray(A, perm) -> B
\end{minted}

Given an AbstractArray \texttt{A}, create a view \texttt{B} such that the dimensions appear to be permuted. Similar to \texttt{permutedims}, except that no copying occurs (\texttt{B} shares storage with \texttt{A}).

See also: \hyperlink{10913801624539723467}{\texttt{permutedims}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = rand(3,5,4);

julia> B = PermutedDimsArray(A, (3,1,2));

julia> size(B)
(4, 3, 5)

julia> B[3,1,2] == A[1,2,3]
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/permuteddimsarray.jl#L20-L41}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16545078180547259725}{} 
\hyperlink{16545078180547259725}{\texttt{Base.promote\_shape}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
promote_shape(s1, s2)
\end{minted}

Check two array shapes for compatibility, allowing trailing singleton dimensions, and return whichever shape has more dimensions.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = fill(1, (3,4,1,1,1));

julia> b = fill(1, (3,4));

julia> promote_shape(a,b)
(Base.OneTo(3), Base.OneTo(4), Base.OneTo(1), Base.OneTo(1), Base.OneTo(1))

julia> promote_shape((2,3,1,4), (2, 3, 1, 4, 1))
(2, 3, 1, 4, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/indices.jl#L132-L150}{\texttt{source}}


\end{adjustwidth}

\hypertarget{2513741487669385581}{}


\section{Array functions}


\hypertarget{318811369799573541}{} 
\hyperlink{318811369799573541}{\texttt{Base.accumulate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
accumulate(op, A; dims::Integer, [init])
\end{minted}

Cumulative operation \texttt{op} along the dimension \texttt{dims} of \texttt{A} (providing \texttt{dims} is optional for vectors). An initial value \texttt{init} may optionally be provided by a keyword argument. See also \hyperlink{5431648933624159647}{\texttt{accumulate!}} to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow). For common operations there are specialized variants of \texttt{accumulate}, see: \hyperlink{6230751605647278302}{\texttt{cumsum}}, \hyperlink{9956198945051267091}{\texttt{cumprod}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> accumulate(+, [1,2,3])
3-element Array{Int64,1}:
 1
 3
 6

julia> accumulate(*, [1,2,3])
3-element Array{Int64,1}:
 1
 2
 6

julia> accumulate(+, [1,2,3]; init=100)
3-element Array{Int64,1}:
 101
 103
 106

julia> accumulate(min, [1,2,-1]; init=0)
3-element Array{Int64,1}:
  0
  0
 -1

julia> accumulate(+, fill(1, 3, 3), dims=1)
3×3 Array{Int64,2}:
 1  1  1
 2  2  2
 3  3  3

julia> accumulate(+, fill(1, 3, 3), dims=2)
3×3 Array{Int64,2}:
 1  2  3
 1  2  3
 1  2  3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/accumulate.jl#L190-L237}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5431648933624159647}{} 
\hyperlink{5431648933624159647}{\texttt{Base.accumulate!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
accumulate!(op, B, A; [dims], [init])
\end{minted}

Cumulative operation \texttt{op} on \texttt{A} along the dimension \texttt{dims}, storing the result in \texttt{B}. Providing \texttt{dims} is optional for vectors.  If the keyword argument \texttt{init} is given, its value is used to instantiate the accumulation. See also \hyperlink{318811369799573541}{\texttt{accumulate}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = [1, 0, 2, 0, 3];

julia> y = [0, 0, 0, 0, 0];

julia> accumulate!(+, y, x);

julia> y
5-element Array{Int64,1}:
 1
 1
 3
 3
 6

julia> A = [1 2; 3 4];

julia> B = [0 0; 0 0];

julia> accumulate!(-, B, A, dims=1);

julia> B
2×2 Array{Int64,2}:
  1   2
 -2  -2

julia> accumulate!(-, B, A, dims=2);

julia> B
2×2 Array{Int64,2}:
 1  -1
 3  -1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/accumulate.jl#L250-L291}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9956198945051267091}{} 
\hyperlink{9956198945051267091}{\texttt{Base.cumprod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cumprod(A; dims::Integer)
\end{minted}

Cumulative product along the dimension \texttt{dim}. See also \hyperlink{17593173853905042752}{\texttt{cumprod!}} to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia> cumprod(a, dims=1)
2×3 Array{Int64,2}:
 1   2   3
 4  10  18

julia> cumprod(a, dims=2)
2×3 Array{Int64,2}:
 1   2    6
 4  20  120
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/accumulate.jl#L136-L160}{\texttt{source}}



\begin{lstlisting}
cumprod(x::AbstractVector)
\end{lstlisting}

Cumulative product of a vector. See also \hyperlink{17593173853905042752}{\texttt{cumprod!}} to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).

\textbf{Examples}


\begin{minted}{jlcon}
julia> cumprod(fill(1//2, 3))
3-element Array{Rational{Int64},1}:
 1//2
 1//4
 1//8

julia> cumprod([fill(1//3, 2, 2) for i in 1:3])
3-element Array{Array{Rational{Int64},2},1}:
 [1//3 1//3; 1//3 1//3]
 [2//9 2//9; 2//9 2//9]
 [4//27 4//27; 4//27 4//27]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/accumulate.jl#L165-L186}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17593173853905042752}{} 
\hyperlink{17593173853905042752}{\texttt{Base.cumprod!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cumprod!(B, A; dims::Integer)
\end{minted}

Cumulative product of \texttt{A} along the dimension \texttt{dims}, storing the result in \texttt{B}. See also \hyperlink{9956198945051267091}{\texttt{cumprod}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/accumulate.jl#L119-L124}{\texttt{source}}



\begin{lstlisting}
cumprod!(y::AbstractVector, x::AbstractVector)
\end{lstlisting}

Cumulative product of a vector \texttt{x}, storing the result in \texttt{y}. See also \hyperlink{9956198945051267091}{\texttt{cumprod}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/accumulate.jl#L128-L133}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6230751605647278302}{} 
\hyperlink{6230751605647278302}{\texttt{Base.cumsum}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cumsum(A; dims::Integer)
\end{minted}

Cumulative sum along the dimension \texttt{dims}. See also \hyperlink{6880214806638058949}{\texttt{cumsum!}} to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia> cumsum(a, dims=1)
2×3 Array{Int64,2}:
 1  2  3
 5  7  9

julia> cumsum(a, dims=2)
2×3 Array{Int64,2}:
 1  3   6
 4  9  15
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/accumulate.jl#L64-L88}{\texttt{source}}



\begin{lstlisting}
cumsum(x::AbstractVector)
\end{lstlisting}

Cumulative sum a vector. See also \hyperlink{6880214806638058949}{\texttt{cumsum!}} to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).

\textbf{Examples}


\begin{minted}{jlcon}
julia> cumsum([1, 1, 1])
3-element Array{Int64,1}:
 1
 2
 3

julia> cumsum([fill(1, 2) for i in 1:3])
3-element Array{Array{Int64,1},1}:
 [1, 1]
 [2, 2]
 [3, 3]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/accumulate.jl#L94-L115}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6880214806638058949}{} 
\hyperlink{6880214806638058949}{\texttt{Base.cumsum!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cumsum!(B, A; dims::Integer)
\end{minted}

Cumulative sum of \texttt{A} along the dimension \texttt{dims}, storing the result in \texttt{B}. See also \hyperlink{6230751605647278302}{\texttt{cumsum}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/accumulate.jl#L41-L45}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11629576691247647263}{} 
\hyperlink{11629576691247647263}{\texttt{Base.diff}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
diff(A::AbstractVector)
diff(A::AbstractArray; dims::Integer)
\end{minted}

Finite difference operator on a vector or a multidimensional array \texttt{A}. In the latter case the dimension to operate on needs to be specified with the \texttt{dims} keyword argument.

\begin{quote}
\textbf{Julia 1.1}

\texttt{diff} for arrays with dimension higher than 2 requires at least Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [2 4; 6 16]
2×2 Array{Int64,2}:
 2   4
 6  16

julia> diff(a, dims=2)
2×1 Array{Int64,2}:
  2
 10

julia> diff(vec(a))
3-element Array{Int64,1}:
  4
 -2
 12
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L795-L824}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15426606278434194584}{} 
\hyperlink{15426606278434194584}{\texttt{Base.repeat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
repeat(A::AbstractArray, counts::Integer...)
\end{minted}

Construct an array by repeating array \texttt{A} a given number of times in each dimension, specified by \texttt{counts}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> repeat([1, 2, 3], 2)
6-element Array{Int64,1}:
 1
 2
 3
 1
 2
 3

julia> repeat([1, 2, 3], 2, 3)
6×3 Array{Int64,2}:
 1  1  1
 2  2  2
 3  3  3
 1  1  1
 2  2  2
 3  3  3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarraymath.jl#L247-L272}{\texttt{source}}



\begin{lstlisting}
repeat(A::AbstractArray; inner=ntuple(x->1, ndims(A)), outer=ntuple(x->1, ndims(A)))
\end{lstlisting}

Construct an array by repeating the entries of \texttt{A}. The i-th element of \texttt{inner} specifies the number of times that the individual entries of the i-th dimension of \texttt{A} should be repeated. The i-th element of \texttt{outer} specifies the number of times that a slice along the i-th dimension of \texttt{A} should be repeated. If \texttt{inner} or \texttt{outer} are omitted, no repetition is performed.

\textbf{Examples}


\begin{minted}{jlcon}
julia> repeat(1:2, inner=2)
4-element Array{Int64,1}:
 1
 1
 2
 2

julia> repeat(1:2, outer=2)
4-element Array{Int64,1}:
 1
 2
 1
 2

julia> repeat([1 2; 3 4], inner=(2, 1), outer=(1, 3))
4×6 Array{Int64,2}:
 1  2  1  2  1  2
 1  2  1  2  1  2
 3  4  3  4  3  4
 3  4  3  4  3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarraymath.jl#L299-L331}{\texttt{source}}



\begin{minted}{julia}
repeat(s::AbstractString, r::Integer)
\end{minted}

Repeat a string \texttt{r} times. This can be written as \texttt{s{\textasciicircum}r}.

See also: \hyperlink{462277561264792021}{\texttt{{\textasciicircum}}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> repeat("ha", 3)
"hahaha"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L652-L664}{\texttt{source}}



\begin{minted}{julia}
repeat(c::AbstractChar, r::Integer) -> String
\end{minted}

Repeat a character \texttt{r} times. This can equivalently be accomplished by calling \hyperlink{462277561264792021}{\texttt{c{\textasciicircum}r}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> repeat('A', 3)
"AAA"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/string.jl#L308-L318}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12015243558136741941}{} 
\hyperlink{12015243558136741941}{\texttt{Base.rot180}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rot180(A)
\end{minted}

Rotate matrix \texttt{A} 180 degrees.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rot180(a)
2×2 Array{Int64,2}:
 4  3
 2  1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/arraymath.jl#L177-L194}{\texttt{source}}



\begin{lstlisting}
rot180(A, k)
\end{lstlisting}

Rotate matrix \texttt{A} 180 degrees an integer \texttt{k} number of times. If \texttt{k} is even, this is equivalent to a \texttt{copy}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rot180(a,1)
2×2 Array{Int64,2}:
 4  3
 2  1

julia> rot180(a,2)
2×2 Array{Int64,2}:
 1  2
 3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/arraymath.jl#L279-L302}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3749585719821242612}{} 
\hyperlink{3749585719821242612}{\texttt{Base.rotl90}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rotl90(A)
\end{minted}

Rotate matrix \texttt{A} left 90 degrees.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rotl90(a)
2×2 Array{Int64,2}:
 2  4
 1  3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/arraymath.jl#L122-L139}{\texttt{source}}



\begin{lstlisting}
rotl90(A, k)
\end{lstlisting}

Left-rotate matrix \texttt{A} 90 degrees counterclockwise an integer \texttt{k} number of times. If \texttt{k} is a multiple of four (including zero), this is equivalent to a \texttt{copy}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rotl90(a,1)
2×2 Array{Int64,2}:
 2  4
 1  3

julia> rotl90(a,2)
2×2 Array{Int64,2}:
 4  3
 2  1

julia> rotl90(a,3)
2×2 Array{Int64,2}:
 3  1
 4  2

julia> rotl90(a,4)
2×2 Array{Int64,2}:
 1  2
 3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/arraymath.jl#L204-L237}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4661209193738958579}{} 
\hyperlink{4661209193738958579}{\texttt{Base.rotr90}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rotr90(A)
\end{minted}

Rotate matrix \texttt{A} right 90 degrees.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rotr90(a)
2×2 Array{Int64,2}:
 3  1
 4  2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/arraymath.jl#L150-L167}{\texttt{source}}



\begin{lstlisting}
rotr90(A, k)
\end{lstlisting}

Right-rotate matrix \texttt{A} 90 degrees clockwise an integer \texttt{k} number of times. If \texttt{k} is a multiple of four (including zero), this is equivalent to a \texttt{copy}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rotr90(a,1)
2×2 Array{Int64,2}:
 3  1
 4  2

julia> rotr90(a,2)
2×2 Array{Int64,2}:
 4  3
 2  1

julia> rotr90(a,3)
2×2 Array{Int64,2}:
 2  4
 1  3

julia> rotr90(a,4)
2×2 Array{Int64,2}:
 1  2
 3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/arraymath.jl#L244-L277}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8678396932318499078}{} 
\hyperlink{8678396932318499078}{\texttt{Base.mapslices}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mapslices(f, A; dims)
\end{minted}

Transform the given dimensions of array \texttt{A} using function \texttt{f}. \texttt{f} is called on each slice of \texttt{A} of the form \texttt{A[...,:,...,:,...]}. \texttt{dims} is an integer vector specifying where the colons go in this expression. The results are concatenated along the remaining dimensions. For example, if \texttt{dims} is \texttt{[1,2]} and \texttt{A} is 4-dimensional, \texttt{f} is called on \texttt{A[:,:,i,j]} for all \texttt{i} and \texttt{j}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = reshape(Vector(1:16),(2,2,2,2))
2×2×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia> mapslices(sum, a, dims = [1,2])
1×1×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 10

[:, :, 2, 1] =
 26

[:, :, 1, 2] =
 42

[:, :, 2, 2] =
 58
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarray.jl#L1927-L1970}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9554202414701324127}{} 
\hyperlink{9554202414701324127}{\texttt{Base.eachrow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eachrow(A::AbstractVecOrMat)
\end{minted}

Create a generator that iterates over the first dimension of vector or matrix \texttt{A}, returning the rows as views.

See also \hyperlink{16048523827937992118}{\texttt{eachcol}} and \hyperlink{9044337245930922762}{\texttt{eachslice}}.

\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarraymath.jl#L410-L420}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16048523827937992118}{} 
\hyperlink{16048523827937992118}{\texttt{Base.eachcol}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eachcol(A::AbstractVecOrMat)
\end{minted}

Create a generator that iterates over the second dimension of matrix \texttt{A}, returning the columns as views.

See also \hyperlink{9554202414701324127}{\texttt{eachrow}} and \hyperlink{9044337245930922762}{\texttt{eachslice}}.

\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarraymath.jl#L424-L434}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9044337245930922762}{} 
\hyperlink{9044337245930922762}{\texttt{Base.eachslice}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eachslice(A::AbstractArray; dims)
\end{minted}

Create a generator that iterates over dimensions \texttt{dims} of \texttt{A}, returning views that select all the data from the other dimensions in \texttt{A}.

Only a single dimension in \texttt{dims} is currently supported. Equivalent to \texttt{(view(A,:,:,...,i,:,: ...)) for i in axes(A, dims))}, where \texttt{i} is in position \texttt{dims}.

See also \hyperlink{9554202414701324127}{\texttt{eachrow}}, \hyperlink{16048523827937992118}{\texttt{eachcol}}, and \hyperlink{16041553215191638546}{\texttt{selectdim}}.

\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarraymath.jl#L437-L450}{\texttt{source}}


\end{adjustwidth}

\hypertarget{12340194950665653103}{}


\section{Combinatorics}


\hypertarget{1395642908979377386}{} 
\hyperlink{1395642908979377386}{\texttt{Base.invperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
invperm(v)
\end{minted}

Return the inverse permutation of \texttt{v}. If \texttt{B = A[v]}, then \texttt{A == B[invperm(v)]}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [2; 4; 3; 1];

julia> invperm(v)
4-element Array{Int64,1}:
 4
 1
 3
 2

julia> A = ['a','b','c','d'];

julia> B = A[v]
4-element Array{Char,1}:
 'b'
 'd'
 'c'
 'a'

julia> B[invperm(v)]
4-element Array{Char,1}:
 'a'
 'b'
 'c'
 'd'
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/combinatorics.jl#L195-L228}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11897566016863942320}{} 
\hyperlink{11897566016863942320}{\texttt{Base.isperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isperm(v) -> Bool
\end{minted}

Return \texttt{true} if \texttt{v} is a valid permutation.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isperm([1; 2])
true

julia> isperm([1; 3])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/combinatorics.jl#L39-L52}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17157632988142440888}{} 
\hyperlink{17157632988142440888}{\texttt{Base.permute!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
permute!(v, p)
\end{minted}

Permute vector \texttt{v} in-place, according to permutation \texttt{p}. No checking is done to verify that \texttt{p} is a permutation.

To return a new permutation, use \texttt{v[p]}. Note that this is generally faster than \texttt{permute!(v,p)} for large vectors.

See also \hyperlink{7055834640889279783}{\texttt{invpermute!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1, 1, 3, 4];

julia> perm = [2, 4, 3, 1];

julia> permute!(A, perm);

julia> A
4-element Array{Int64,1}:
 1
 4
 3
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/combinatorics.jl#L119-L145}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7055834640889279783}{} 
\hyperlink{7055834640889279783}{\texttt{Base.invpermute!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
invpermute!(v, p)
\end{minted}

Like \hyperlink{17157632988142440888}{\texttt{permute!}}, but the inverse of the given permutation is applied.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1, 1, 3, 4];

julia> perm = [2, 4, 3, 1];

julia> invpermute!(A, perm);

julia> A
4-element Array{Int64,1}:
 4
 1
 3
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/combinatorics.jl#L172-L192}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5598774829914682536}{} 
\hyperlink{5598774829914682536}{\texttt{Base.reverse}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reverse(v [, start=1 [, stop=length(v) ]] )
\end{minted}

Return a copy of \texttt{v} reversed from start to stop.  See also \hyperlink{12943296479800134710}{\texttt{Iterators.reverse}} for reverse-order iteration without making a copy.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = Vector(1:5)
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia> reverse(A)
5-element Array{Int64,1}:
 5
 4
 3
 2
 1

julia> reverse(A, 1, 4)
5-element Array{Int64,1}:
 4
 3
 2
 1
 5

julia> reverse(A, 3, 5)
5-element Array{Int64,1}:
 1
 2
 5
 4
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1473-L1513}{\texttt{source}}



\begin{lstlisting}
reverse(A; dims::Integer)
\end{lstlisting}

Reverse \texttt{A} in dimension \texttt{dims}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> b = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> reverse(b, dims=2)
2×2 Array{Int64,2}:
 2  1
 4  3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/abstractarraymath.jl#L130-L147}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16812685153025781176}{} 
\hyperlink{16812685153025781176}{\texttt{Base.reverseind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reverseind(v, i)
\end{minted}

Given an index \texttt{i} in \hyperlink{5598774829914682536}{\texttt{reverse(v)}}, return the corresponding index in \texttt{v} so that \texttt{v[reverseind(v,i)] == reverse(v)[i]}. (This can be nontrivial in cases where \texttt{v} contains non-ASCII characters.)

\textbf{Examples}


\begin{minted}{jlcon}
julia> r = reverse("Julia")
"ailuJ"

julia> for i in 1:length(r)
           print(r[reverseind("Julia", i)])
       end
Julia
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/basic.jl#L632-L649}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9702108366803637048}{} 
\hyperlink{9702108366803637048}{\texttt{Base.reverse!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reverse!(v [, start=1 [, stop=length(v) ]]) -> v
\end{minted}

In-place version of \hyperlink{5598774829914682536}{\texttt{reverse}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = Vector(1:5)
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia> reverse!(A);

julia> A
5-element Array{Int64,1}:
 5
 4
 3
 2
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L1536-L1561}{\texttt{source}}


\end{adjustwidth}

\hypertarget{13032822450217674886}{}


\chapter{Tasks}


\hypertarget{7131243650304654155}{} 
\hyperlink{7131243650304654155}{\texttt{Core.Task}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Task(func)
\end{minted}

Create a \texttt{Task} (i.e. coroutine) to execute the given function \texttt{func} (which must be callable with no arguments). The task exits when this function returns.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a() = sum(i for i in 1:1000);

julia> b = Task(a);
\end{minted}

In this example, \texttt{b} is a runnable \texttt{Task} that hasn{\textquotesingle}t started yet.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1255-L1269}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16142823989571622868}{} 
\hyperlink{16142823989571622868}{\texttt{Base.@task}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@task
\end{minted}

Wrap an expression in a \hyperlink{7131243650304654155}{\texttt{Task}} without executing it, and return the \hyperlink{7131243650304654155}{\texttt{Task}}. This only creates a task, and does not run it.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a1() = sum(i for i in 1:1000);

julia> b = @task a1();

julia> istaskstarted(b)
false

julia> schedule(b);

julia> yield();

julia> istaskdone(b)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L88-L110}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10770947021537241619}{} 
\hyperlink{10770947021537241619}{\texttt{Base.@async}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@async
\end{minted}

Wrap an expression in a \hyperlink{7131243650304654155}{\texttt{Task}} and add it to the local machine{\textquotesingle}s scheduler queue.

Values can be interpolated into \texttt{@async} via \texttt{\$}, which copies the value directly into the constructed underlying closure. This allows you to insert the \emph{value} of a variable, isolating the aysnchronous code from changes to the variable{\textquotesingle}s value in the current task.

\begin{quote}
\textbf{Julia 1.4}

Interpolating values via \texttt{\$} is available as of Julia 1.4.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L343-L354}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14148755671315265621}{} 
\hyperlink{14148755671315265621}{\texttt{Base.asyncmap}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asyncmap(f, c...; ntasks=0, batch_size=nothing)
\end{minted}

Uses multiple concurrent tasks to map \texttt{f} over a collection (or multiple equal length collections). For multiple collection arguments, \texttt{f} is applied elementwise.

\texttt{ntasks} specifies the number of tasks to run concurrently. Depending on the length of the collections, if \texttt{ntasks} is unspecified, up to 100 tasks will be used for concurrent mapping.

\texttt{ntasks} can also be specified as a zero-arg function. In this case, the number of tasks to run in parallel is checked before processing every element and a new task started if the value of \texttt{ntasks\_func} is less than the current number of tasks.

If \texttt{batch\_size} is specified, the collection is processed in batch mode. \texttt{f} must then be a function that must accept a \texttt{Vector} of argument tuples and must return a vector of results. The input vector will have a length of \texttt{batch\_size} or less.

The following examples highlight execution in different tasks by returning the \texttt{objectid} of the tasks in which the mapping function is executed.

First, with \texttt{ntasks} undefined, each element is processed in a different task.


\begin{lstlisting}
julia> tskoid() = objectid(current_task());

julia> asyncmap(x->tskoid(), 1:5)
5-element Array{UInt64,1}:
 0x6e15e66c75c75853
 0x440f8819a1baa682
 0x9fb3eeadd0c83985
 0xebd3e35fe90d4050
 0x29efc93edce2b961

julia> length(unique(asyncmap(x->tskoid(), 1:5)))
5
\end{lstlisting}

With \texttt{ntasks=2} all elements are processed in 2 tasks.


\begin{lstlisting}
julia> asyncmap(x->tskoid(), 1:5; ntasks=2)
5-element Array{UInt64,1}:
 0x027ab1680df7ae94
 0xa23d2f80cd7cf157
 0x027ab1680df7ae94
 0xa23d2f80cd7cf157
 0x027ab1680df7ae94

julia> length(unique(asyncmap(x->tskoid(), 1:5; ntasks=2)))
2
\end{lstlisting}

With \texttt{batch\_size} defined, the mapping function needs to be changed to accept an array of argument tuples and return an array of results. \texttt{map} is used in the modified mapping function to achieve this.


\begin{lstlisting}
julia> batch_func(input) = map(x->string("args_tuple: ", x, ", element_val: ", x[1], ", task: ", tskoid()), input)
batch_func (generic function with 1 method)

julia> asyncmap(batch_func, 1:5; ntasks=2, batch_size=2)
5-element Array{String,1}:
 "args_tuple: (1,), element_val: 1, task: 9118321258196414413"
 "args_tuple: (2,), element_val: 2, task: 4904288162898683522"
 "args_tuple: (3,), element_val: 3, task: 9118321258196414413"
 "args_tuple: (4,), element_val: 4, task: 4904288162898683522"
 "args_tuple: (5,), element_val: 5, task: 9118321258196414413"
\end{lstlisting}

\begin{quote}
\textbf{Note}

Currently, all tasks in Julia are executed in a single OS thread co-operatively. Consequently, \texttt{asyncmap} is beneficial only when the mapping function involves any I/O - disk, network, remote worker invocation, etc.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/asyncmap.jl#L5-L79}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16469851777080200085}{} 
\hyperlink{16469851777080200085}{\texttt{Base.asyncmap!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asyncmap!(f, results, c...; ntasks=0, batch_size=nothing)
\end{minted}

Like \hyperlink{14148755671315265621}{\texttt{asyncmap}}, but stores output in \texttt{results} rather than returning a collection.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/asyncmap.jl#L412-L417}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12929971401717674174}{} 
\hyperlink{12929971401717674174}{\texttt{Base.current\_task}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
current_task()
\end{minted}

Get the currently running \hyperlink{7131243650304654155}{\texttt{Task}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L115-L119}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7432450399685996831}{} 
\hyperlink{7432450399685996831}{\texttt{Base.istaskdone}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
istaskdone(t::Task) -> Bool
\end{minted}

Determine whether a task has exited.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a2() = sum(i for i in 1:1000);

julia> b = Task(a2);

julia> istaskdone(b)
false

julia> schedule(b);

julia> yield();

julia> istaskdone(b)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L122-L143}{\texttt{source}}


\end{adjustwidth}
\hypertarget{188637489024602838}{} 
\hyperlink{188637489024602838}{\texttt{Base.istaskstarted}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
istaskstarted(t::Task) -> Bool
\end{minted}

Determine whether a task has started executing.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a3() = sum(i for i in 1:1000);

julia> b = Task(a3);

julia> istaskstarted(b)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L146-L160}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2767699747386067716}{} 
\hyperlink{2767699747386067716}{\texttt{Base.istaskfailed}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
istaskfailed(t::Task) -> Bool
\end{minted}

Determine whether a task has exited because an exception was thrown.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a4() = error("task failed");

julia> b = Task(a4);

julia> istaskfailed(b)
false

julia> schedule(b);

julia> yield();

julia> istaskfailed(b)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L163-L184}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8292907206163344794}{} 
\hyperlink{8292907206163344794}{\texttt{Base.task\_local\_storage}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
task_local_storage(key)
\end{minted}

Look up the value of a key in the current task{\textquotesingle}s task-local storage.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L199-L203}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2485476355246980354}{} 
\hyperlink{2485476355246980354}{\texttt{Base.task\_local\_storage}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
task_local_storage(key, value)
\end{minted}

Assign a value to a key in the current task{\textquotesingle}s task-local storage.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L206-L210}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18380692261281200127}{} 
\hyperlink{18380692261281200127}{\texttt{Base.task\_local\_storage}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
task_local_storage(body, key, value)
\end{minted}

Call the function \texttt{body} with a modified task-local storage, in which \texttt{value} is assigned to \texttt{key}; the previous value of \texttt{key}, or lack thereof, is restored afterwards. Useful for emulating dynamic scoping.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L213-L219}{\texttt{source}}


\end{adjustwidth}

\hypertarget{3706829557192562237}{}


\section{Scheduling}


\hypertarget{13455314829114364187}{} 
\hyperlink{13455314829114364187}{\texttt{Base.yield}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
yield()
\end{minted}

Switch to the scheduler to allow another scheduled task to run. A task that calls this function is still runnable, and will be restarted immediately if there are no other runnable tasks.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L600-L606}{\texttt{source}}



\begin{lstlisting}
yield(t::Task, arg = nothing)
\end{lstlisting}

A fast, unfair-scheduling version of \texttt{schedule(t, arg); yield()} which immediately yields to \texttt{t} before calling the scheduler.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L618-L623}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4920987536368477483}{} 
\hyperlink{4920987536368477483}{\texttt{Base.yieldto}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
yieldto(t::Task, arg = nothing)
\end{minted}

Switch to the given task. The first time a task is switched to, the task{\textquotesingle}s function is called with no arguments. On subsequent switches, \texttt{arg} is returned from the task{\textquotesingle}s last call to \texttt{yieldto}. This is a low-level call that only switches tasks, not considering states or scheduling in any way. Its use is discouraged.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L630-L637}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3231475347583891391}{} 
\hyperlink{3231475347583891391}{\texttt{Base.sleep}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sleep(seconds)
\end{minted}

Block the current task for a specified number of seconds. The minimum sleep time is 1 millisecond or input of \texttt{0.001}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/asyncevent.jl#L205-L210}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9185853093207176818}{} 
\hyperlink{9185853093207176818}{\texttt{Base.schedule}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
schedule(t::Task, [val]; error=false)
\end{minted}

Add a \hyperlink{7131243650304654155}{\texttt{Task}} to the scheduler{\textquotesingle}s queue. This causes the task to run constantly when the system is otherwise idle, unless the task performs a blocking operation such as \hyperlink{13761789780433862250}{\texttt{wait}}.

If a second argument \texttt{val} is provided, it will be passed to the task (via the return value of \hyperlink{4920987536368477483}{\texttt{yieldto}}) when it runs again. If \texttt{error} is \texttt{true}, the value is raised as an exception in the woken task.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a5() = sum(i for i in 1:1000);

julia> b = Task(a5);

julia> istaskstarted(b)
false

julia> schedule(b);

julia> yield();

julia> istaskstarted(b)
true

julia> istaskdone(b)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L556-L585}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4182455747623306187}{}


\section{Synchronization}


\hypertarget{7188613740509403855}{} 
\hyperlink{7188613740509403855}{\texttt{Base.@sync}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@sync
\end{minted}

Wait until all lexically-enclosed uses of \texttt{@async}, \texttt{@spawn}, \texttt{@spawnat} and \texttt{@distributed} are complete. All exceptions thrown by enclosed async operations are collected and thrown as a \texttt{CompositeException}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L323-L329}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13761789780433862250}{} 
\hyperlink{13761789780433862250}{\texttt{Base.wait}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Special note for \hyperlink{11528192138203594595}{\texttt{Threads.Condition}}:

The caller must be holding the \hyperlink{3013795445283337804}{\texttt{lock}} that owns \texttt{c} before calling this method. The calling task will be blocked until some other task wakes it, usually by calling \hyperlink{2865179286002578885}{\texttt{notify}}` on the same Condition object. The lock will be atomically released when blocking (even if it was locked recursively), and will be reacquired before returning.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/lock.jl#L211-L219}{\texttt{source}}



\begin{lstlisting}
wait(r::Future)
\end{lstlisting}

Wait for a value to become available for the specified \hyperlink{4170271048165085864}{\texttt{Future}}.




\begin{lstlisting}
wait(r::RemoteChannel, args...)
\end{lstlisting}

Wait for a value to become available on the specified \hyperlink{16773267780467157552}{\texttt{RemoteChannel}}.




\begin{lstlisting}
wait([x])
\end{lstlisting}

Block the current task until some event occurs, depending on the type of the argument:

\begin{itemize}
\item \hyperlink{12548845729684045604}{\texttt{Channel}}: Wait for a value to be appended to the channel.


\item \hyperlink{286351753995469758}{\texttt{Condition}}: Wait for \hyperlink{2865179286002578885}{\texttt{notify}} on a condition.


\item \texttt{Process}: Wait for a process or process chain to exit. The \texttt{exitcode} field of a process can be used to determine success or failure.


\item \hyperlink{7131243650304654155}{\texttt{Task}}: Wait for a \texttt{Task} to finish. If the task fails with an exception, a \texttt{TaskFailedException} (which wraps the failed task) is thrown.


\item \hyperlink{432946111555992347}{\texttt{RawFD}}: Wait for changes on a file descriptor (see the \texttt{FileWatching} package).

\end{itemize}
If no argument is passed, the task blocks for an undefined period. A task can only be restarted by an explicit call to \hyperlink{9185853093207176818}{\texttt{schedule}} or \hyperlink{4920987536368477483}{\texttt{yieldto}}.

Often \texttt{wait} is called within a \texttt{while} loop to ensure a waited-for condition is met before proceeding.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/condition.jl#L81-L99}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11007884648860062495}{} 
\hyperlink{11007884648860062495}{\texttt{Base.fetch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fetch(t::Task)
\end{minted}

Wait for a Task to finish, then return its result value. If the task fails with an exception, a \texttt{TaskFailedException} (which wraps the failed task) is thrown.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/task.jl#L274-L280}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6677218100159857934}{} 
\hyperlink{6677218100159857934}{\texttt{Base.timedwait}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
timedwait(testcb::Function, secs::Float64; pollint::Float64=0.1)
\end{minted}

Waits until \texttt{testcb} returns \texttt{true} or for \texttt{secs} seconds, whichever is earlier. \texttt{testcb} is polled every \texttt{pollint} seconds.

Returns :ok, :timed\_out, or :error



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/asyncevent.jl#L257-L264}{\texttt{source}}


\end{adjustwidth}
\hypertarget{286351753995469758}{} 
\hyperlink{286351753995469758}{\texttt{Base.Condition}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Condition()
\end{minted}

Create an edge-triggered event source that tasks can wait for. Tasks that call \hyperlink{13761789780433862250}{\texttt{wait}} on a \texttt{Condition} are suspended and queued. Tasks are woken up when \hyperlink{2865179286002578885}{\texttt{notify}} is later called on the \texttt{Condition}. Edge triggering means that only tasks waiting at the time \hyperlink{2865179286002578885}{\texttt{notify}} is called can be woken up. For level-triggered notifications, you must keep extra state to keep track of whether a notification has happened. The \hyperlink{12548845729684045604}{\texttt{Channel}} and \hyperlink{13017632704767046438}{\texttt{Threads.Event}} types do this, and can be used for level-triggered events.

This object is NOT thread-safe. See \hyperlink{11528192138203594595}{\texttt{Threads.Condition}} for a thread-safe version.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/condition.jl#L151-L162}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2865179286002578885}{} 
\hyperlink{2865179286002578885}{\texttt{Base.notify}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
notify(condition, val=nothing; all=true, error=false)
\end{minted}

Wake up tasks waiting for a condition, passing them \texttt{val}. If \texttt{all} is \texttt{true} (the default), all waiting tasks are woken, otherwise only one is. If \texttt{error} is \texttt{true}, the passed value is raised as an exception in the woken tasks.

Return the count of tasks woken up. Return 0 if no tasks are waiting on \texttt{condition}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/condition.jl#L115-L123}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11014313312721841609}{} 
\hyperlink{11014313312721841609}{\texttt{Base.Semaphore}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Semaphore(sem_size)
\end{minted}

Create a counting semaphore that allows at most \texttt{sem\_size} acquires to be in use at any time. Each acquire must be matched with a release.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/lock.jl#L225-L231}{\texttt{source}}


\end{adjustwidth}
\hypertarget{733284340937899961}{} 
\hyperlink{733284340937899961}{\texttt{Base.acquire}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acquire(s::Semaphore)
\end{minted}

Wait for one of the \texttt{sem\_size} permits to be available, blocking until one can be acquired.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/lock.jl#L239-L244}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8274760602310731764}{} 
\hyperlink{8274760602310731764}{\texttt{Base.release}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
release(s::Semaphore)
\end{minted}

Return one permit to the pool, possibly allowing another task to acquire it and resume execution.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/lock.jl#L258-L264}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11175712074621861288}{} 
\hyperlink{11175712074621861288}{\texttt{Base.AbstractLock}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractLock
\end{minted}

Abstract supertype describing types that implement the synchronization primitives: \hyperlink{3013795445283337804}{\texttt{lock}}, \hyperlink{8566561467185712956}{\texttt{trylock}}, \hyperlink{7477828718297215912}{\texttt{unlock}}, and \hyperlink{8304067307715619600}{\texttt{islocked}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/condition.jl#L11-L17}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3013795445283337804}{} 
\hyperlink{3013795445283337804}{\texttt{Base.lock}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lock(lock)
\end{minted}

Acquire the \texttt{lock} when it becomes available. If the lock is already locked by a different task/thread, wait for it to become available.

Each \texttt{lock} must be matched by an \hyperlink{7477828718297215912}{\texttt{unlock}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/lock.jl#L58-L66}{\texttt{source}}



\begin{lstlisting}
lock(f::Function, lock)
\end{lstlisting}

Acquire the \texttt{lock}, execute \texttt{f} with the \texttt{lock} held, and release the \texttt{lock} when \texttt{f} returns. If the lock is already locked by a different task/thread, wait for it to become available.

When this function returns, the \texttt{lock} has been released, so the caller should not attempt to \texttt{unlock} it.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/lock.jl#L148-L157}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7477828718297215912}{} 
\hyperlink{7477828718297215912}{\texttt{Base.unlock}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unlock(lock)
\end{minted}

Releases ownership of the \texttt{lock}.

If this is a recursive lock which has been acquired before, decrement an internal counter and return immediately.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/lock.jl#L90-L97}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8566561467185712956}{} 
\hyperlink{8566561467185712956}{\texttt{Base.trylock}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trylock(lock) -> Success (Boolean)
\end{minted}

Acquire the lock if it is available, and return \texttt{true} if successful. If the lock is already locked by a different task/thread, return \texttt{false}.

Each successful \texttt{trylock} must be matched by an \hyperlink{7477828718297215912}{\texttt{unlock}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/lock.jl#L31-L40}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8304067307715619600}{} 
\hyperlink{8304067307715619600}{\texttt{Base.islocked}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
islocked(lock) -> Status (Boolean)
\end{minted}

Check whether the \texttt{lock} is held by any task/thread. This should not be used for synchronization (see instead \hyperlink{8566561467185712956}{\texttt{trylock}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/lock.jl#L21-L26}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7552896090133941635}{} 
\hyperlink{7552896090133941635}{\texttt{Base.ReentrantLock}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ReentrantLock()
\end{minted}

Creates a re-entrant lock for synchronizing \hyperlink{7131243650304654155}{\texttt{Task}}s. The same task can acquire the lock as many times as required. Each \hyperlink{3013795445283337804}{\texttt{lock}} must be matched with an \hyperlink{7477828718297215912}{\texttt{unlock}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/lock.jl#L4-L10}{\texttt{source}}


\end{adjustwidth}

\hypertarget{5026428100850833092}{}


\section{Channels}


\hypertarget{12548845729684045604}{} 
\hyperlink{12548845729684045604}{\texttt{Base.Channel}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Channel{T=Any}(size::Int=0)
\end{minted}

Constructs a \texttt{Channel} with an internal buffer that can hold a maximum of \texttt{size} objects of type \texttt{T}. \hyperlink{12719543094136814100}{\texttt{put!}} calls on a full channel block until an object is removed with \hyperlink{4963355246106153560}{\texttt{take!}}.

\texttt{Channel(0)} constructs an unbuffered channel. \texttt{put!} blocks until a matching \texttt{take!} is called. And vice-versa.

Other constructors:

\begin{itemize}
\item \texttt{Channel()}: default constructor, equivalent to \texttt{Channel\{Any\}(0)}


\item \texttt{Channel(Inf)}: equivalent to \texttt{Channel\{Any\}(typemax(Int))}


\item \texttt{Channel(sz)}: equivalent to \texttt{Channel\{Any\}(sz)}

\end{itemize}
\begin{quote}
\textbf{Julia 1.3}

\end{quote}
The default constructor \texttt{Channel()} and default \texttt{size=0} were added in Julia 1.3.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/channels.jl#L10-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4793580164200292341}{} 
\hyperlink{4793580164200292341}{\texttt{Base.Channel}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Channel{T=Any}(func::Function, size=0; taskref=nothing, spawn=false)
\end{minted}

Create a new task from \texttt{func}, bind it to a new channel of type \texttt{T} and size \texttt{size}, and schedule the task, all in a single call.

\texttt{func} must accept the bound channel as its only argument.

If you need a reference to the created task, pass a \texttt{Ref\{Task\}} object via the keyword argument \texttt{taskref}.

If \texttt{spawn = true}, the Task created for \texttt{func} may be scheduled on another thread in parallel, equivalent to creating a task via \hyperlink{355982830105047813}{\texttt{Threads.@spawn}}.

Return a \texttt{Channel}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> chnl = Channel() do ch
           foreach(i -> put!(ch, i), 1:4)
       end;

julia> typeof(chnl)
Channel{Any}

julia> for i in chnl
           @show i
       end;
i = 1
i = 2
i = 3
i = 4
\end{minted}

Referencing the created task:


\begin{minted}{jlcon}
julia> taskref = Ref{Task}();

julia> chnl = Channel(taskref=taskref) do ch
           println(take!(ch))
       end;

julia> istaskdone(taskref[])
false

julia> put!(chnl, "Hello");
Hello

julia> istaskdone(taskref[])
true
\end{minted}

\begin{quote}
\textbf{Julia 1.3}

\end{quote}
The \texttt{spawn=} parameter was added in Julia 1.3. This constructor was added in Julia 1.3.   In earlier versions of Julia, Channel used keyword arguments to set \texttt{size} and \texttt{T}, but   those constructors are deprecated.


\begin{minted}{jlcon}
julia> chnl = Channel{Char}(1, spawn=true) do ch
           for c in "hello world"
               put!(ch, c)
           end
       end
Channel{Char}(sz_max:1,sz_curr:1)

julia> String(collect(chnl))
"hello world"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/channels.jl#L57-L126}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12719543094136814100}{} 
\hyperlink{12719543094136814100}{\texttt{Base.put!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
put!(c::Channel, v)
\end{minted}

Append an item \texttt{v} to the channel \texttt{c}. Blocks if the channel is full.

For unbuffered channels, blocks until a \hyperlink{4963355246106153560}{\texttt{take!}} is performed by a different task.

\begin{quote}
\textbf{Julia 1.1}

\texttt{v} now gets converted to the channel{\textquotesingle}s type with \hyperlink{1846942650946171605}{\texttt{convert}} as \texttt{put!} is called.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/channels.jl#L300-L310}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6608633734376348608}{} 
\hyperlink{6608633734376348608}{\texttt{Base.take!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
take!(c::Channel)
\end{minted}

Remove and return a value from a \hyperlink{12548845729684045604}{\texttt{Channel}}. Blocks until data is available.

For unbuffered channels, blocks until a \hyperlink{12719543094136814100}{\texttt{put!}} is performed by a different task.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/channels.jl#L375-L382}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15888554370655089980}{} 
\hyperlink{15888554370655089980}{\texttt{Base.isready}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isready(c::Channel)
\end{minted}

Determine whether a \hyperlink{12548845729684045604}{\texttt{Channel}} has a value stored to it. Returns immediately, does not block.

For unbuffered channels returns \texttt{true} if there are tasks waiting on a \hyperlink{12719543094136814100}{\texttt{put!}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/channels.jl#L413-L421}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7098010828229464277}{} 
\hyperlink{7098010828229464277}{\texttt{Base.fetch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fetch(c::Channel)
\end{minted}

Wait for and get the first available item from the channel. Does not remove the item. \texttt{fetch} is unsupported on an unbuffered (0-size) channel.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/channels.jl#L353-L358}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9979143087438478792}{} 
\hyperlink{9979143087438478792}{\texttt{Base.close}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
close(c::Channel[, excp::Exception])
\end{minted}

Close a channel. An exception (optionally given by \texttt{excp}), is thrown by:

\begin{itemize}
\item \hyperlink{12719543094136814100}{\texttt{put!}} on a closed channel.


\item \hyperlink{4963355246106153560}{\texttt{take!}} and \hyperlink{11007884648860062495}{\texttt{fetch}} on an empty, closed channel.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/channels.jl#L171-L178}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6778875052923307054}{} 
\hyperlink{6778875052923307054}{\texttt{Base.bind}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
bind(chnl::Channel, task::Task)
\end{minted}

Associate the lifetime of \texttt{chnl} with a task. \texttt{Channel} \texttt{chnl} is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on \texttt{chnl}.

The \texttt{chnl} object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed \texttt{Channel} objects.

When a channel is bound to multiple tasks, the first task to terminate will close the channel. When multiple channels are bound to the same task, termination of the task will close all of the bound channels.

\textbf{Examples}


\begin{minted}{jlcon}
julia> c = Channel(0);

julia> task = @async foreach(i->put!(c, i), 1:4);

julia> bind(c,task);

julia> for i in c
           @show i
       end;
i = 1
i = 2
i = 3
i = 4

julia> isopen(c)
false
\end{minted}


\begin{minted}{jlcon}
julia> c = Channel(0);

julia> task = @async (put!(c,1);error("foo"));

julia> bind(c,task);

julia> take!(c)
1

julia> put!(c,1);
ERROR: foo
Stacktrace:
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/channels.jl#L194-L243}{\texttt{source}}


\end{adjustwidth}

\hypertarget{7842773949108463380}{}


\chapter{Multi-Threading}


\hypertarget{15582842999596899869}{} 
\hyperlink{15582842999596899869}{\texttt{Base.Threads.@threads}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.@threads
\end{minted}

A macro to parallelize a for-loop to run with multiple threads. This spawns \texttt{nthreads()} number of threads, splits the iteration space amongst them, and iterates in parallel. A barrier is placed at the end of the loop which waits for all the threads to finish execution, and the loop returns.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/threadingconstructs.jl#L75-L82}{\texttt{source}}


\end{adjustwidth}
\hypertarget{355982830105047813}{} 
\hyperlink{355982830105047813}{\texttt{Base.Threads.@spawn}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.@spawn expr
\end{minted}

Create and run a \hyperlink{7131243650304654155}{\texttt{Task}} on any available thread. To wait for the task to finish, call \hyperlink{13761789780433862250}{\texttt{wait}} on the result of this macro, or call \hyperlink{11007884648860062495}{\texttt{fetch}} to wait and then obtain its return value.

Values can be interpolated into \texttt{@spawn} via \texttt{\$}, which copies the value directly into the constructed underlying closure. This allows you to insert the \emph{value} of a variable, isolating the aysnchronous code from changes to the variable{\textquotesingle}s value in the current task.

\begin{quote}
\textbf{Note}

This feature is currently considered experimental.

\end{quote}
\begin{quote}
\textbf{Julia 1.3}

This macro is available as of Julia 1.3.

\end{quote}
\begin{quote}
\textbf{Julia 1.4}

Interpolating values via \texttt{\$} is available as of Julia 1.4.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/threadingconstructs.jl#L103-L122}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12668125807854133993}{} 
\hyperlink{12668125807854133993}{\texttt{Base.Threads.threadid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.threadid()
\end{minted}

Get the ID number of the current thread of execution. The master thread has ID \texttt{1}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/threadingconstructs.jl#L5-L9}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11061583461116144745}{} 
\hyperlink{11061583461116144745}{\texttt{Base.Threads.nthreads}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.nthreads()
\end{minted}

Get the number of threads available to the Julia process. This is the inclusive upper bound on \texttt{threadid()}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/threadingconstructs.jl#L13-L18}{\texttt{source}}


\end{adjustwidth}

\hypertarget{9063370155780136313}{}


\section{Synchronization}


\hypertarget{11528192138203594595}{} 
\hyperlink{11528192138203594595}{\texttt{Base.Threads.Condition}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.Condition([lock])
\end{minted}

A thread-safe version of \hyperlink{286351753995469758}{\texttt{Base.Condition}}.

\begin{quote}
\textbf{Julia 1.2}

This functionality requires at least Julia 1.2.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/lock.jl#L201-L208}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13017632704767046438}{} 
\hyperlink{13017632704767046438}{\texttt{Base.Event}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Event()
\end{minted}

Create a level-triggered event source. Tasks that call \hyperlink{13761789780433862250}{\texttt{wait}} on an \texttt{Event} are suspended and queued until \texttt{notify} is called on the \texttt{Event}. After \texttt{notify} is called, the \texttt{Event} remains in a signaled state and tasks will no longer block when waiting for it.

\begin{quote}
\textbf{Julia 1.1}

This functionality requires at least Julia 1.1.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/lock.jl#L278-L288}{\texttt{source}}


\end{adjustwidth}

See also \hyperlink{7928897202753469122}{Synchronization}.



\hypertarget{14092913848436173389}{}


\section{Atomic operations}



\begin{quote}
\textbf{Warning}

The API for atomic operations has not yet been finalized and is likely to change.

\end{quote}

\hypertarget{1140117372581270616}{} 
\hyperlink{1140117372581270616}{\texttt{Base.Threads.Atomic}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.Atomic{T}
\end{minted}

Holds a reference to an object of type \texttt{T}, ensuring that it is only accessed atomically, i.e. in a thread-safe manner.

Only certain {\textquotedbl}simple{\textquotedbl} types can be used atomically, namely the primitive boolean, integer, and float-point types. These are \texttt{Bool}, \texttt{Int8}...\texttt{Int128}, \texttt{UInt8}...\texttt{UInt128}, and \texttt{Float16}...\texttt{Float64}.

New atomic objects can be created from a non-atomic values; if none is specified, the atomic object is initialized with zero.

Atomic objects can be accessed using the \texttt{[]} notation:

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> x[] = 1
1

julia> x[]
1
\end{minted}

Atomic operations use an \texttt{atomic\_} prefix, such as \hyperlink{4669846204248874730}{\texttt{atomic\_add!}}, \hyperlink{15583989732166753404}{\texttt{atomic\_xchg!}}, etc.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/atomics.jl#L34-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6924433775344145551}{} 
\hyperlink{6924433775344145551}{\texttt{Base.Threads.atomic\_cas!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.atomic_cas!(x::Atomic{T}, cmp::T, newval::T) where T
\end{minted}

Atomically compare-and-set \texttt{x}

Atomically compares the value in \texttt{x} with \texttt{cmp}. If equal, write \texttt{newval} to \texttt{x}. Otherwise, leaves \texttt{x} unmodified. Returns the old value in \texttt{x}. By comparing the returned value to \texttt{cmp} (via \texttt{===}) one knows whether \texttt{x} was modified and now holds the new value \texttt{newval}.

For further details, see LLVM{\textquotesingle}s \texttt{cmpxchg} instruction.

This function can be used to implement transactional semantics. Before the transaction, one records the value in \texttt{x}. After the transaction, the new value is stored only if \texttt{x} has not been modified in the mean time.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_cas!(x, 4, 2);

julia> x
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_cas!(x, 3, 2);

julia> x
Base.Threads.Atomic{Int64}(2)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/atomics.jl#L72-L104}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15583989732166753404}{} 
\hyperlink{15583989732166753404}{\texttt{Base.Threads.atomic\_xchg!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.atomic_xchg!(x::Atomic{T}, newval::T) where T
\end{minted}

Atomically exchange the value in \texttt{x}

Atomically exchanges the value in \texttt{x} with \texttt{newval}. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw xchg} instruction.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_xchg!(x, 2)
3

julia> x[]
2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/atomics.jl#L107-L128}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4669846204248874730}{} 
\hyperlink{4669846204248874730}{\texttt{Base.Threads.atomic\_add!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.atomic_add!(x::Atomic{T}, val::T) where T <: ArithmeticTypes
\end{minted}

Atomically add \texttt{val} to \texttt{x}

Performs \texttt{x[] += val} atomically. Returns the \textbf{old} value. Not defined for \texttt{Atomic\{Bool\}}.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw add} instruction.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_add!(x, 2)
3

julia> x[]
5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/atomics.jl#L131-L152}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17642173571521486894}{} 
\hyperlink{17642173571521486894}{\texttt{Base.Threads.atomic\_sub!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.atomic_sub!(x::Atomic{T}, val::T) where T <: ArithmeticTypes
\end{minted}

Atomically subtract \texttt{val} from \texttt{x}

Performs \texttt{x[] -= val} atomically. Returns the \textbf{old} value. Not defined for \texttt{Atomic\{Bool\}}.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw sub} instruction.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_sub!(x, 2)
3

julia> x[]
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/atomics.jl#L155-L176}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17667453349907943193}{} 
\hyperlink{17667453349907943193}{\texttt{Base.Threads.atomic\_and!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.atomic_and!(x::Atomic{T}, val::T) where T
\end{minted}

Atomically bitwise-and \texttt{x} with \texttt{val}

Performs \texttt{x[] \&= val} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw and} instruction.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_and!(x, 2)
3

julia> x[]
2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/atomics.jl#L179-L199}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7585036809570134634}{} 
\hyperlink{7585036809570134634}{\texttt{Base.Threads.atomic\_nand!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.atomic_nand!(x::Atomic{T}, val::T) where T
\end{minted}

Atomically bitwise-nand (not-and) \texttt{x} with \texttt{val}

Performs \texttt{x[] = {\textasciitilde}(x[] \& val)} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw nand} instruction.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_nand!(x, 2)
3

julia> x[]
-3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/atomics.jl#L202-L222}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13607043969188851947}{} 
\hyperlink{13607043969188851947}{\texttt{Base.Threads.atomic\_or!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.atomic_or!(x::Atomic{T}, val::T) where T
\end{minted}

Atomically bitwise-or \texttt{x} with \texttt{val}

Performs \texttt{x[] |= val} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw or} instruction.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(5)
Base.Threads.Atomic{Int64}(5)

julia> Threads.atomic_or!(x, 7)
5

julia> x[]
7
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/atomics.jl#L225-L245}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5701145140539338563}{} 
\hyperlink{5701145140539338563}{\texttt{Base.Threads.atomic\_xor!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.atomic_xor!(x::Atomic{T}, val::T) where T
\end{minted}

Atomically bitwise-xor (exclusive-or) \texttt{x} with \texttt{val}

Performs \texttt{x[] \$= val} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw xor} instruction.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(5)
Base.Threads.Atomic{Int64}(5)

julia> Threads.atomic_xor!(x, 7)
5

julia> x[]
2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/atomics.jl#L248-L268}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8102033568033818241}{} 
\hyperlink{8102033568033818241}{\texttt{Base.Threads.atomic\_max!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.atomic_max!(x::Atomic{T}, val::T) where T
\end{minted}

Atomically store the maximum of \texttt{x} and \texttt{val} in \texttt{x}

Performs \texttt{x[] = max(x[], val)} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw max} instruction.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(5)
Base.Threads.Atomic{Int64}(5)

julia> Threads.atomic_max!(x, 7)
5

julia> x[]
7
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/atomics.jl#L271-L291}{\texttt{source}}


\end{adjustwidth}
\hypertarget{392667369563982661}{} 
\hyperlink{392667369563982661}{\texttt{Base.Threads.atomic\_min!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.atomic_min!(x::Atomic{T}, val::T) where T
\end{minted}

Atomically store the minimum of \texttt{x} and \texttt{val} in \texttt{x}

Performs \texttt{x[] = min(x[], val)} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw min} instruction.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(7)
Base.Threads.Atomic{Int64}(7)

julia> Threads.atomic_min!(x, 5)
7

julia> x[]
5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/atomics.jl#L294-L314}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6451121520734566874}{} 
\hyperlink{6451121520734566874}{\texttt{Base.Threads.atomic\_fence}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Threads.atomic_fence()
\end{minted}

Insert a sequential-consistency memory fence

Inserts a memory fence with sequentially-consistent ordering semantics. There are algorithms where this is needed, i.e. where an acquire/release ordering is insufficient.

This is likely a very expensive operation. Given that all other atomic operations in Julia already have acquire/release semantics, explicit fences should not be necessary in most cases.

For further details, see LLVM{\textquotesingle}s \texttt{fence} instruction.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/atomics.jl#L432-L446}{\texttt{source}}


\end{adjustwidth}

\hypertarget{6332880025315332163}{}


\section{ccall using a threadpool (Experimental)}


\hypertarget{4118169676263419404}{} 
\hyperlink{4118169676263419404}{\texttt{Base.@threadcall}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@threadcall((cfunc, clib), rettype, (argtypes...), argvals...)
\end{minted}

The \texttt{@threadcall} macro is called in the same way as \hyperlink{14245046751182637566}{\texttt{ccall}} but does the work in a different thread. This is useful when you want to call a blocking C function without causing the main \texttt{julia} thread to become blocked. Concurrency is limited by size of the libuv thread pool, which defaults to 4 threads but can be increased by setting the \texttt{UV\_THREADPOOL\_SIZE} environment variable and restarting the \texttt{julia} process.

Note that the called function should never call back into Julia.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/threadcall.jl#L7-L18}{\texttt{source}}


\end{adjustwidth}

\hypertarget{13905974260827344810}{}


\section{Low-level synchronization primitives}



These building blocks are used to create the regular synchronization objects.


\hypertarget{16883834658935510339}{} 
\hyperlink{16883834658935510339}{\texttt{Base.Threads.SpinLock}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SpinLock()
\end{minted}

Create a non-reentrant, test-and-test-and-set spin lock. Recursive use will result in a deadlock. This kind of lock should only be used around code that takes little time to execute and does not block (e.g. perform I/O). In general, \hyperlink{7552896090133941635}{\texttt{ReentrantLock}} should be used instead.

Each \hyperlink{3013795445283337804}{\texttt{lock}} must be matched with an \hyperlink{7477828718297215912}{\texttt{unlock}}.

Test-and-test-and-set spin locks are quickest up to about 30ish contending threads. If you have more contention than that, different synchronization approaches should be considered.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/locks-mt.jl#L14-L28}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4380185033557519432}{}


\chapter{常量}


\hypertarget{9331422207248206047}{} 
\hyperlink{9331422207248206047}{\texttt{Core.nothing}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nothing
\end{minted}

The singleton instance of type \hyperlink{13508459519898889544}{\texttt{Nothing}}, used by convention when there is no value to return (as in a C \texttt{void} function) or when a variable or field holds no value.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L1057-L1062}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9054270179006636705}{} 
\hyperlink{9054270179006636705}{\texttt{Base.PROGRAM\_FILE}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
PROGRAM_FILE
\end{minted}

A string containing the script name passed to Julia from the command line. Note that the script name remains unchanged from within included files. Alternatively see \hyperlink{1518763743618824993}{\texttt{@\_\_FILE\_\_}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/initdefs.jl#L5-L11}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2567473177880607455}{} 
\hyperlink{2567473177880607455}{\texttt{Base.ARGS}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ARGS
\end{minted}

An array of the command line arguments passed to Julia, as strings.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/initdefs.jl#L14-L18}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11444309529550205492}{} 
\hyperlink{11444309529550205492}{\texttt{Base.C\_NULL}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
C_NULL
\end{minted}

The C null pointer constant, sometimes used when calling external code.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/pointer.jl#L13-L17}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12605722316331458198}{} 
\hyperlink{12605722316331458198}{\texttt{Base.VERSION}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
VERSION
\end{minted}

A \texttt{VersionNumber} object describing which version of Julia is in use. For details see \hyperlink{12935585355849408291}{Version Number Literals}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/version.jl#L216-L221}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15271486679944781836}{} 
\hyperlink{15271486679944781836}{\texttt{Base.DEPOT\_PATH}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DEPOT_PATH
\end{minted}

A stack of {\textquotedbl}depot{\textquotedbl} locations where the package manager, as well as Julia{\textquotesingle}s code loading mechanisms, look for package registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files. By default it includes:

\begin{itemize}
\item[1. ] \texttt{{\textasciitilde}/.julia} where \texttt{{\textasciitilde}} is the user home as appropriate on the system;


\item[2. ] an architecture-specific shared system directory, e.g. \texttt{/usr/local/share/julia};


\item[3. ] an architecture-independent shared system directory, e.g. \texttt{/usr/share/julia}.

\end{itemize}
So \texttt{DEPOT\_PATH} might be:


\begin{minted}{julia}
[joinpath(homedir(), ".julia"), "/usr/local/share/julia", "/usr/share/julia"]
\end{minted}

The first entry is the {\textquotedbl}user depot{\textquotedbl} and should be writable by and owned by the current user. The user depot is where: registries are cloned, new package versions are installed, named environments are created and updated, package repos are cloned, newly compiled package image files are saved, log files are written, development packages are checked out by default, and global configuration data is saved. Later entries in the depot path are treated as read-only and are appropriate for registries, packages, etc. installed and managed by system administrators.

\texttt{DEPOT\_PATH} is populated based on the \hyperlink{6468636275358768444}{\texttt{JULIA\_DEPOT\_PATH}} environment variable if set.

See also: \hyperlink{6468636275358768444}{\texttt{JULIA\_DEPOT\_PATH}}, and \href{@ref Code-Loading}{Code Loading}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/initdefs.jl#L44-L74}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17914149694871263675}{} 
\hyperlink{17914149694871263675}{\texttt{Base.LOAD\_PATH}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LOAD_PATH
\end{minted}

An array of paths for \texttt{using} and \texttt{import} statements to consider as project environments or package directories when loading code. It is populated based on the \hyperlink{8995491879208063980}{\texttt{JULIA\_LOAD\_PATH}} environment variable if set; otherwise it defaults to \texttt{[{\textquotedbl}@{\textquotedbl}, {\textquotedbl}@v\#.\#{\textquotedbl}, {\textquotedbl}@stdlib{\textquotedbl}]}. Entries starting with \texttt{@} have special meanings:

\begin{itemize}
\item \texttt{@} refers to the {\textquotedbl}current active environment{\textquotedbl}, the initial value of which is initially determined by the \hyperlink{596026888060672066}{\texttt{JULIA\_PROJECT}} environment variable or the \texttt{--project} command-line option.


\item \texttt{@stdlib} expands to the absolute path of the current Julia installation{\textquotesingle}s standard library directory.


\item \texttt{@name} refers to a named environment, which are stored in depots (see \hyperlink{6468636275358768444}{\texttt{JULIA\_DEPOT\_PATH}}) under the \texttt{environments} subdirectory. The user{\textquotesingle}s named environments are stored in \texttt{{\textasciitilde}/.julia/environments} so \texttt{@name} would refer to the environment in \texttt{{\textasciitilde}/.julia/environments/name} if it exists and contains a \texttt{Project.toml} file. If \texttt{name} contains \texttt{\#} characters, then they are replaced with the major, minor and patch components of the Julia version number. For example, if you are running Julia 1.2 then \texttt{@v\#.\#} expands to \texttt{@v1.2} and will look for an environment by that name, typically at \texttt{{\textasciitilde}/.julia/environments/v1.2}.

\end{itemize}
The fully expanded value of \texttt{LOAD\_PATH} that is searched for projects and packages can be seen by calling the \texttt{Base.load\_path()} function.

See also: \hyperlink{8995491879208063980}{\texttt{JULIA\_LOAD\_PATH}}, \hyperlink{596026888060672066}{\texttt{JULIA\_PROJECT}}, \hyperlink{6468636275358768444}{\texttt{JULIA\_DEPOT\_PATH}}, and \href{@ref Code-Loading}{Code Loading}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/initdefs.jl#L122-L156}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11034333937761980027}{} 
\hyperlink{11034333937761980027}{\texttt{Base.Sys.BINDIR}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.BINDIR
\end{minted}

A string containing the full path to the directory containing the \texttt{julia} executable.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L39-L43}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5072616208401232599}{} 
\hyperlink{5072616208401232599}{\texttt{Base.Sys.CPU\_THREADS}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.CPU_THREADS
\end{minted}

The number of logical CPU cores available in the system, i.e. the number of threads that the CPU can run concurrently. Note that this is not necessarily the number of CPU cores, for example, in the presence of \href{https://en.wikipedia.org/wiki/Hyper-threading}{hyper-threading}.

See Hwloc.jl or CpuId.jl for extended information, including number of physical cores.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L58-L67}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6553323097149877235}{} 
\hyperlink{6553323097149877235}{\texttt{Base.Sys.WORD\_SIZE}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.WORD_SIZE
\end{minted}

Standard word size on the current machine, in bits.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L92-L96}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9866627704997689218}{} 
\hyperlink{9866627704997689218}{\texttt{Base.Sys.KERNEL}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.KERNEL
\end{minted}

A symbol representing the name of the operating system, as returned by \texttt{uname} of the build configuration.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L78-L82}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10411677719248532228}{} 
\hyperlink{10411677719248532228}{\texttt{Base.Sys.ARCH}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.ARCH
\end{minted}

A symbol representing the architecture of the build configuration.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L70-L74}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14835867711534070832}{} 
\hyperlink{14835867711534070832}{\texttt{Base.Sys.MACHINE}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sys.MACHINE
\end{minted}

A string containing the build triple.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sysinfo.jl#L85-L89}{\texttt{source}}


\end{adjustwidth}

参见：



\begin{itemize}
\item \hyperlink{3330957653919693521}{\texttt{stdin}}


\item \hyperlink{18181294266083891471}{\texttt{stdout}}


\item \hyperlink{6150355911915549172}{\texttt{stderr}}


\item \hyperlink{196658496437650743}{\texttt{ENV}}


\item \hyperlink{15528013539058180213}{\texttt{ENDIAN\_BOM}}


\item \texttt{Libc.MS\_ASYNC}


\item \texttt{Libc.MS\_INVALIDATE}


\item \texttt{Libc.MS\_SYNC}

\end{itemize}


\hypertarget{14157880486595246176}{}


\chapter{文件系统}


\hypertarget{16313884780490629439}{} 
\hyperlink{16313884780490629439}{\texttt{Base.Filesystem.pwd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pwd() -> AbstractString
\end{minted}

Get the current working directory.

\textbf{Examples}


\begin{minted}{jlcon}
julia> pwd()
"/home/JuliaUser"

julia> cd("/home/JuliaUser/Projects/julia")

julia> pwd()
"/home/JuliaUser/Projects/julia"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L32-L47}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2737128667296781766}{} 
\hyperlink{2737128667296781766}{\texttt{Base.Filesystem.cd}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cd(dir::AbstractString=homedir())
\end{minted}

Set the current working directory.

\textbf{Examples}


\begin{minted}{jlcon}
julia> cd("/home/JuliaUser/Projects/julia")

julia> pwd()
"/home/JuliaUser/Projects/julia"

julia> cd()

julia> pwd()
"/home/JuliaUser"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L65-L82}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5425414028590761114}{} 
\hyperlink{5425414028590761114}{\texttt{Base.Filesystem.cd}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cd(f::Function, dir::AbstractString=homedir())
\end{minted}

Temporarily change the current working directory to \texttt{dir}, apply function \texttt{f} and finally return to the original directory.

\textbf{Examples}


\begin{minted}{jlcon}
julia> pwd()
"/home/JuliaUser"

julia> cd(readdir, "/home/JuliaUser/Projects/julia")
34-element Array{String,1}:
 ".circleci"
 ".freebsdci.sh"
 ".git"
 ".gitattributes"
 ".github"
 ⋮
 "test"
 "ui"
 "usr"
 "usr-staging"

julia> pwd()
"/home/JuliaUser"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L111-L138}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3860759521350595217}{} 
\hyperlink{3860759521350595217}{\texttt{Base.Filesystem.readdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readdir(dir::AbstractString=pwd();
    join::Bool = false,
    sort::Bool = true,
) -> Vector{String}
\end{minted}

Return the names in the directory \texttt{dir} or the current working directory if not given. When \texttt{join} is false, \texttt{readdir} returns just the names in the directory as is; when \texttt{join} is true, it returns \texttt{joinpath(dir, name)} for each \texttt{name} so that the returned strings are full paths. If you want to get absolute paths back, call \texttt{readdir} with an absolute directory path and \texttt{join} set to true.

By default, \texttt{readdir} sorts the list of names it returns. If you want to skip sorting the names and get them in the order that the file system lists them, you can use \texttt{readir(dir, sort=false)} to opt out of sorting.

\begin{quote}
\textbf{Julia 1.4}

The \texttt{join} and \texttt{sort} keyword arguments require at least Julia 1.4.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> cd("/home/JuliaUser/dev/julia")

julia> readdir()
30-element Array{String,1}:
 ".appveyor.yml"
 ".git"
 ".gitattributes"
 ⋮
 "ui"
 "usr"
 "usr-staging"

julia> readdir(join=true)
30-element Array{String,1}:
 "/home/JuliaUser/dev/julia/.appveyor.yml"
 "/home/JuliaUser/dev/julia/.git"
 "/home/JuliaUser/dev/julia/.gitattributes"
 ⋮
 "/home/JuliaUser/dev/julia/ui"
 "/home/JuliaUser/dev/julia/usr"
 "/home/JuliaUser/dev/julia/usr-staging"

julia> readdir("base")
145-element Array{String,1}:
 ".gitignore"
 "Base.jl"
 "Enums.jl"
 ⋮
 "version_git.sh"
 "views.jl"
 "weakkeydict.jl"

julia> readdir("base", join=true)
145-element Array{String,1}:
 "base/.gitignore"
 "base/Base.jl"
 "base/Enums.jl"
 ⋮
 "base/version_git.sh"
 "base/views.jl"
 "base/weakkeydict.jl"```

julia> readdir(abspath("base"), join=true)
145-element Array{String,1}:
 "/home/JuliaUser/dev/julia/base/.gitignore"
 "/home/JuliaUser/dev/julia/base/Base.jl"
 "/home/JuliaUser/dev/julia/base/Enums.jl"
 ⋮
 "/home/JuliaUser/dev/julia/base/version_git.sh"
 "/home/JuliaUser/dev/julia/base/views.jl"
 "/home/JuliaUser/dev/julia/base/weakkeydict.jl"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L699-L772}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6143720268840384551}{} 
\hyperlink{6143720268840384551}{\texttt{Base.Filesystem.walkdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
walkdir(dir; topdown=true, follow_symlinks=false, onerror=throw)
\end{minted}

Return an iterator that walks the directory tree of a directory. The iterator returns a tuple containing \texttt{(rootpath, dirs, files)}. The directory tree can be traversed top-down or bottom-up. If \texttt{walkdir} encounters a \hyperlink{16303515589950241655}{\texttt{SystemError}} it will rethrow the error by default. A custom error handling function can be provided through \texttt{onerror} keyword argument. \texttt{onerror} is called with a \texttt{SystemError} as argument.

\textbf{Examples}


\begin{minted}{julia}
for (root, dirs, files) in walkdir(".")
    println("Directories in $root")
    for dir in dirs
        println(joinpath(root, dir)) # path to directories
    end
    println("Files in $root")
    for file in files
        println(joinpath(root, file)) # path to files
    end
end
\end{minted}


\begin{minted}{jlcon}
julia> mkpath("my/test/dir");

julia> itr = walkdir("my");

julia> (root, dirs, files) = first(itr)
("my", ["test"], String[])

julia> (root, dirs, files) = first(itr)
("my/test", ["dir"], String[])

julia> (root, dirs, files) = first(itr)
("my/test/dir", String[], String[])
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L801-L840}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17495480510333417689}{} 
\hyperlink{17495480510333417689}{\texttt{Base.Filesystem.mkdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mkdir(path::AbstractString; mode::Unsigned = 0o777)
\end{minted}

Make a new directory with name \texttt{path} and permissions \texttt{mode}. \texttt{mode} defaults to \texttt{0o777}, modified by the current file creation mask. This function never creates more than one directory. If the directory already exists, or some intermediate directories do not exist, this function throws an error. See \hyperlink{12505165128372133919}{\texttt{mkpath}} for a function which creates all required intermediate directories. Return \texttt{path}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> mkdir("testingdir")
"testingdir"

julia> cd("testingdir")

julia> pwd()
"/home/JuliaUser/testingdir"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L148-L168}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12505165128372133919}{} 
\hyperlink{12505165128372133919}{\texttt{Base.Filesystem.mkpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mkpath(path::AbstractString; mode::Unsigned = 0o777)
\end{minted}

Create all directories in the given \texttt{path}, with permissions \texttt{mode}. \texttt{mode} defaults to \texttt{0o777}, modified by the current file creation mask. Return \texttt{path}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> mkdir("testingdir")
"testingdir"

julia> cd("testingdir")

julia> pwd()
"/home/JuliaUser/testingdir"

julia> mkpath("my/test/dir")
"my/test/dir"

julia> readdir()
1-element Array{String,1}:
 "my"

julia> cd("my")

julia> readdir()
1-element Array{String,1}:
 "test"

julia> readdir("test")
1-element Array{String,1}:
 "dir"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L186-L220}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2547536134326433103}{} 
\hyperlink{2547536134326433103}{\texttt{Base.Filesystem.symlink}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
symlink(target::AbstractString, link::AbstractString)
\end{minted}

Creates a symbolic link to \texttt{target} with the name \texttt{link}.

\begin{quote}
\textbf{Note}

This function raises an error under operating systems that do not support soft symbolic links, such as Windows XP.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L930-L938}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17144805426178555631}{} 
\hyperlink{17144805426178555631}{\texttt{Base.Filesystem.readlink}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readlink(path::AbstractString) -> AbstractString
\end{minted}

Return the target location a symbolic link \texttt{path} points to.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L961-L965}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11345760495317535206}{} 
\hyperlink{11345760495317535206}{\texttt{Base.Filesystem.chmod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
chmod(path::AbstractString, mode::Integer; recursive::Bool=false)
\end{minted}

Change the permissions mode of \texttt{path} to \texttt{mode}. Only integer \texttt{mode}s (e.g. \texttt{0o777}) are currently supported. If \texttt{recursive=true} and the path is a directory all permissions in that directory will be recursively changed. Return \texttt{path}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L985-L992}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11782125422345839965}{} 
\hyperlink{11782125422345839965}{\texttt{Base.Filesystem.chown}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
chown(path::AbstractString, owner::Integer, group::Integer=-1)
\end{minted}

Change the owner and/or group of \texttt{path} to \texttt{owner} and/or \texttt{group}. If the value entered for \texttt{owner} or \texttt{group} is \texttt{-1} the corresponding ID will not change. Only integer \texttt{owner}s and \texttt{group}s are currently supported. Return \texttt{path}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L1006-L1012}{\texttt{source}}


\end{adjustwidth}
\hypertarget{432946111555992347}{} 
\hyperlink{432946111555992347}{\texttt{Base.Libc.RawFD}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RawFD
\end{minted}

Primitive type which wraps the native OS file descriptor. \texttt{RawFD}s can be passed to methods like \hyperlink{10861694406169986183}{\texttt{stat}} to discover information about the underlying file, and can also be used to open streams, with the \texttt{RawFD} describing the OS file backing the stream.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L22-L30}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10861694406169986183}{} 
\hyperlink{10861694406169986183}{\texttt{Base.stat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stat(file)
\end{minted}

Returns a structure whose fields contain information about the file. The fields of the structure are:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Name & Description \\
\hline
size & The size (in bytes) of the file \\
\hline
device & ID of the device that contains the file \\
\hline
inode & The inode number of the file \\
\hline
mode & The protection mode of the file \\
\hline
nlink & The number of hard links to the file \\
\hline
uid & The user id of the owner of the file \\
\hline
gid & The group id of the file owner \\
\hline
rdev & If this file refers to a device, the ID of the device it refers to \\
\hline
blksize & The file-system preferred block size for the file \\
\hline
blocks & The number of such blocks allocated \\
\hline
mtime & Unix timestamp of when the file was last modified \\
\hline
ctime & Unix timestamp of when the file was created \\
\hline
\end{tabulary}

\end{table}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L87-L108}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14136422515630953157}{} 
\hyperlink{14136422515630953157}{\texttt{Base.Filesystem.lstat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lstat(file)
\end{minted}

Like \hyperlink{10861694406169986183}{\texttt{stat}}, but for symbolic links gets the info for the link itself rather than the file it refers to. This function must be called on a file path rather than a file object or a file descriptor.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L111-L118}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12867604313294084336}{} 
\hyperlink{12867604313294084336}{\texttt{Base.Filesystem.ctime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ctime(file)
\end{minted}

Equivalent to \texttt{stat(file).ctime}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L144-L148}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6000535741376632237}{} 
\hyperlink{6000535741376632237}{\texttt{Base.Filesystem.mtime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mtime(file)
\end{minted}

Equivalent to \texttt{stat(file).mtime}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L137-L141}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13483994185565548500}{} 
\hyperlink{13483994185565548500}{\texttt{Base.Filesystem.filemode}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
filemode(file)
\end{minted}

Equivalent to \texttt{stat(file).mode}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L123-L127}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7772513328501904656}{} 
\hyperlink{7772513328501904656}{\texttt{Base.Filesystem.filesize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
filesize(path...)
\end{minted}

Equivalent to \texttt{stat(file).size}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L130-L134}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1627468638377378187}{} 
\hyperlink{1627468638377378187}{\texttt{Base.Filesystem.uperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
uperm(file)
\end{minted}

Get the permissions of the owner of the file as a bitfield of


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Value & Description \\
\hline
01 & Execute Permission \\
\hline
02 & Write Permission \\
\hline
04 & Read Permission \\
\hline
\end{tabulary}

\end{table}

For allowed arguments, see \hyperlink{10861694406169986183}{\texttt{stat}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L260-L272}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7004818904788863313}{} 
\hyperlink{7004818904788863313}{\texttt{Base.Filesystem.gperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gperm(file)
\end{minted}

Like \hyperlink{1627468638377378187}{\texttt{uperm}} but gets the permissions of the group owning the file.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L275-L279}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5276829438522229212}{} 
\hyperlink{5276829438522229212}{\texttt{Base.Filesystem.operm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
operm(file)
\end{minted}

Like \hyperlink{1627468638377378187}{\texttt{uperm}} but gets the permissions for people who neither own the file nor are a member of the group owning the file



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L282-L287}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5101460505107133606}{} 
\hyperlink{5101460505107133606}{\texttt{Base.Filesystem.cp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cp(src::AbstractString, dst::AbstractString; force::Bool=false, follow_symlinks::Bool=false)
\end{minted}

Copy the file, link, or directory from \texttt{src} to \texttt{dst}. \texttt{force=true} will first remove an existing \texttt{dst}.

If \texttt{follow\_symlinks=false}, and \texttt{src} is a symbolic link, \texttt{dst} will be created as a symbolic link. If \texttt{follow\_symlinks=true} and \texttt{src} is a symbolic link, \texttt{dst} will be a copy of the file or directory \texttt{src} refers to. Return \texttt{dst}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L332-L342}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3963309772903794843}{} 
\hyperlink{3963309772903794843}{\texttt{Base.download}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
download(url::AbstractString, [localfile::AbstractString])
\end{minted}

Download a file from the given url, optionally renaming it to the given local file name. If no filename is given this will download into a randomly-named file in your temp directory. Note that this function relies on the availability of external tools such as \texttt{curl}, \texttt{wget} or \texttt{fetch} to download the file and is provided for convenience. For production use or situations in which more options are needed, please use a package that provides the desired functionality instead.

Returns the filename of the downloaded file.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/download.jl#L85-L96}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5817011497347557360}{} 
\hyperlink{5817011497347557360}{\texttt{Base.Filesystem.mv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mv(src::AbstractString, dst::AbstractString; force::Bool=false)
\end{minted}

Move the file, link, or directory from \texttt{src} to \texttt{dst}. \texttt{force=true} will first remove an existing \texttt{dst}. Return \texttt{dst}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> write("hello.txt", "world");

julia> mv("hello.txt", "goodbye.txt")
"goodbye.txt"

julia> "hello.txt" in readdir()
false

julia> readline("goodbye.txt")
"world"

julia> write("hello.txt", "world2");

julia> mv("hello.txt", "goodbye.txt")
ERROR: ArgumentError: 'goodbye.txt' exists. `force=true` is required to remove 'goodbye.txt' before moving.
Stacktrace:
 [1] #checkfor_mv_cp_cptree#10(::Bool, ::Function, ::String, ::String, ::String) at ./file.jl:293
[...]

julia> mv("hello.txt", "goodbye.txt", force=true)
"goodbye.txt"

julia> rm("goodbye.txt");

\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L356-L390}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9379238926612566029}{} 
\hyperlink{9379238926612566029}{\texttt{Base.Filesystem.rm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rm(path::AbstractString; force::Bool=false, recursive::Bool=false)
\end{minted}

Delete the file, link, or empty directory at the given path. If \texttt{force=true} is passed, a non-existing path is not treated as error. If \texttt{recursive=true} is passed and the path is a directory, then all contents are removed recursively.

\textbf{Examples}


\begin{minted}{jlcon}
julia> mkpath("my/test/dir");

julia> rm("my", recursive=true)

julia> rm("this_file_does_not_exist", force=true)

julia> rm("this_file_does_not_exist")
ERROR: IOError: unlink: no such file or directory (ENOENT)
Stacktrace:
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L238-L258}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12527826024259193863}{} 
\hyperlink{12527826024259193863}{\texttt{Base.Filesystem.touch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
touch(path::AbstractString)
\end{minted}

Update the last-modified timestamp on a file to the current time.

If the file does not exist a new file is created.

Return \texttt{path}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> write("my_little_file", 2);

julia> mtime("my_little_file")
1.5273815391135583e9

julia> touch("my_little_file");

julia> mtime("my_little_file")
1.527381559163435e9
\end{minted}

We can see the \hyperlink{6000535741376632237}{\texttt{mtime}} has been modified by \texttt{touch}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L397-L420}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14845808124082506604}{} 
\hyperlink{14845808124082506604}{\texttt{Base.Filesystem.tempname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tempname(parent=tempdir(); cleanup=true) -> String
\end{minted}

Generate a temporary file path. This function only returns a path; no file is created. The path is likely to be unique, but this cannot be guaranteed due to the very remote posibility of two simultaneous calls to \texttt{tempname} generating the same file name. The name is guaranteed to differ from all files already existing at the time of the call to \texttt{tempname}.

When called with no arguments, the temporary name will be an absolute path to a temporary name in the system temporary directory as given by \texttt{tempdir()}. If a \texttt{parent} directory argument is given, the temporary path will be in that directory instead.

The \texttt{cleanup} option controls whether the process attempts to delete the returned path automatically when the process exits. Note that the \texttt{tempname} function does not create any file or directory at the returned location, so there is nothing to cleanup unless you create a file or directory there. If you do and \texttt{clean} is \texttt{true} it will be deleted upon process termination.

\begin{quote}
\textbf{Julia 1.4}

The \texttt{parent} and \texttt{cleanup} arguments were added in 1.4. Prior to Julia 1.4 the path \texttt{tempname} would never be cleaned up at process termination.

\end{quote}
\begin{quote}
\textbf{Warning}

This can lead to security holes if another process obtains the same file name and creates the file before you are able to. Open the file with \texttt{JL\_O\_EXCL} if this is a concern. Using \hyperlink{16166286599015420654}{\texttt{mktemp()}} is also recommended instead.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L571-L601}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9014859942851246694}{} 
\hyperlink{9014859942851246694}{\texttt{Base.Filesystem.tempdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tempdir()
\end{minted}

Gets the path of the temporary directory. On Windows, \texttt{tempdir()} uses the first environment variable found in the ordered list \texttt{TMP}, \texttt{TEMP}, \texttt{USERPROFILE}. On all other operating systems, \texttt{tempdir()} uses the first environment variable found in the ordered list \texttt{TMPDIR}, \texttt{TMP}, \texttt{TEMP}, and \texttt{TEMPDIR}. If none of these are found, the path \texttt{{\textquotedbl}/tmp{\textquotedbl}} is used.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L437-L444}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16166286599015420654}{} 
\hyperlink{16166286599015420654}{\texttt{Base.Filesystem.mktemp}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mktemp(parent=tempdir(); cleanup=true) -> (path, io)
\end{minted}

Return \texttt{(path, io)}, where \texttt{path} is the path of a new temporary file in \texttt{parent} and \texttt{io} is an open file object for this path. The \texttt{cleanup} option controls whether the temporary file is automatically deleted when the process exits.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L604-L610}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18178401863594160042}{} 
\hyperlink{18178401863594160042}{\texttt{Base.Filesystem.mktemp}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mktemp(f::Function, parent=tempdir())
\end{minted}

Apply the function \texttt{f} to the result of \hyperlink{16166286599015420654}{\texttt{mktemp(parent)}} and remove the temporary file upon completion.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L650-L655}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13323517924995570544}{} 
\hyperlink{13323517924995570544}{\texttt{Base.Filesystem.mktempdir}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mktempdir(parent=tempdir(); prefix="jl_", cleanup=true) -> path
\end{minted}

Create a temporary directory in the \texttt{parent} directory with a name constructed from the given prefix and a random suffix, and return its path. Additionally, any trailing \texttt{X} characters may be replaced with random characters. If \texttt{parent} does not exist, throw an error. The \texttt{cleanup} option controls whether the temporary directory is automatically deleted when the process exits.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L613-L621}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7773039401295251460}{} 
\hyperlink{7773039401295251460}{\texttt{Base.Filesystem.mktempdir}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mktempdir(f::Function, parent=tempdir(); prefix="jl_")
\end{minted}

Apply the function \texttt{f} to the result of \hyperlink{13323517924995570544}{\texttt{mktempdir(parent; prefix)}} and remove the temporary directory all of its contents upon completion.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/file.jl#L672-L677}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12165280569414957484}{} 
\hyperlink{12165280569414957484}{\texttt{Base.Filesystem.isblockdev}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isblockdev(path) -> Bool
\end{minted}

Return \texttt{true} if \texttt{path} is a block device, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L194-L198}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16977107907382267368}{} 
\hyperlink{16977107907382267368}{\texttt{Base.Filesystem.ischardev}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ischardev(path) -> Bool
\end{minted}

Return \texttt{true} if \texttt{path} is a character device, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L169-L173}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3518595943652428720}{} 
\hyperlink{3518595943652428720}{\texttt{Base.Filesystem.isdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isdir(path) -> Bool
\end{minted}

Return \texttt{true} if \texttt{path} is a directory, \texttt{false} otherwise.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isdir(homedir())
true

julia> isdir("not/a/directory")
false
\end{minted}

See also: \hyperlink{7436789928697285849}{\texttt{isfile}} and \hyperlink{14301659288222317301}{\texttt{ispath}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L176-L191}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5085310894552406152}{} 
\hyperlink{5085310894552406152}{\texttt{Base.Filesystem.isfifo}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isfifo(path) -> Bool
\end{minted}

Return \texttt{true} if \texttt{path} is a FIFO, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L162-L166}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7436789928697285849}{} 
\hyperlink{7436789928697285849}{\texttt{Base.Filesystem.isfile}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isfile(path) -> Bool
\end{minted}

Return \texttt{true} if \texttt{path} is a regular file, \texttt{false} otherwise.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isfile(homedir())
false

julia> f = open("test_file.txt", "w");

julia> isfile(f)
true

julia> close(f); rm("test_file.txt")
\end{minted}

See also: \hyperlink{3518595943652428720}{\texttt{isdir}} and \hyperlink{14301659288222317301}{\texttt{ispath}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L201-L220}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4451336630382958860}{} 
\hyperlink{4451336630382958860}{\texttt{Base.Filesystem.islink}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
islink(path) -> Bool
\end{minted}

Return \texttt{true} if \texttt{path} is a symbolic link, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L223-L227}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5555615057884788946}{} 
\hyperlink{5555615057884788946}{\texttt{Base.Filesystem.ismount}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ismount(path) -> Bool
\end{minted}

Return \texttt{true} if \texttt{path} is a mount point, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L328-L332}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14301659288222317301}{} 
\hyperlink{14301659288222317301}{\texttt{Base.Filesystem.ispath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ispath(path) -> Bool
\end{minted}

Return \texttt{true} if a valid filesystem entity exists at \texttt{path}, otherwise returns \texttt{false}. This is the generalization of \hyperlink{7436789928697285849}{\texttt{isfile}}, \hyperlink{3518595943652428720}{\texttt{isdir}} etc.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L153-L159}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13653840348451879213}{} 
\hyperlink{13653840348451879213}{\texttt{Base.Filesystem.issetgid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issetgid(path) -> Bool
\end{minted}

Return \texttt{true} if \texttt{path} has the setgid flag set, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L246-L250}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16213917845195501776}{} 
\hyperlink{16213917845195501776}{\texttt{Base.Filesystem.issetuid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issetuid(path) -> Bool
\end{minted}

Return \texttt{true} if \texttt{path} has the setuid flag set, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L239-L243}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17017605444718674714}{} 
\hyperlink{17017605444718674714}{\texttt{Base.Filesystem.issocket}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issocket(path) -> Bool
\end{minted}

Return \texttt{true} if \texttt{path} is a socket, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L230-L234}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5099487162005794677}{} 
\hyperlink{5099487162005794677}{\texttt{Base.Filesystem.issticky}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issticky(path) -> Bool
\end{minted}

Return \texttt{true} if \texttt{path} has the sticky bit set, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stat.jl#L253-L257}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10630566360559889134}{} 
\hyperlink{10630566360559889134}{\texttt{Base.Filesystem.homedir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
homedir() -> String
\end{minted}

Return the current user{\textquotesingle}s home directory.

\begin{quote}
\textbf{Note}

\texttt{homedir} determines the home directory via \texttt{libuv}{\textquotesingle}s \texttt{uv\_os\_homedir}. For details (for example on how to specify the home directory via environment variables), see the \href{http://docs.libuv.org/en/v1.x/misc.html\#c.uv\_os\_homedir}{\texttt{uv\_os\_homedir} documentation}.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L54-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10993431289442855643}{} 
\hyperlink{10993431289442855643}{\texttt{Base.Filesystem.dirname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dirname(path::AbstractString) -> AbstractString
\end{minted}

Get the directory part of a path. Trailing characters ({\textquotesingle}/{\textquotesingle} or {\textquotesingle}{\textbackslash}{\textquotesingle}) in the path are counted as part of the path.

\textbf{Examples}


\begin{minted}{jlcon}
julia> dirname("/home/myuser")
"/home"

julia> dirname("/home/myuser/")
"/home/myuser"
\end{minted}

See also: \hyperlink{16452154606861459390}{\texttt{basename}}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L144-L160}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16452154606861459390}{} 
\hyperlink{16452154606861459390}{\texttt{Base.Filesystem.basename}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
basename(path::AbstractString) -> AbstractString
\end{minted}

Get the file name part of a path.

\textbf{Examples}


\begin{minted}{jlcon}
julia> basename("/home/myuser/example.jl")
"example.jl"
\end{minted}

See also: \hyperlink{10993431289442855643}{\texttt{dirname}}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L163-L175}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1518763743618824993}{} 
\hyperlink{1518763743618824993}{\texttt{Base.@\_\_FILE\_\_}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@__FILE__ -> AbstractString
\end{minted}

Expand to a string with the path to the file containing the macrocall, or an empty string if evaluated by \texttt{julia -e <expr>}. Return \texttt{nothing} if the macro was missing parser source information. Alternatively see \hyperlink{9054270179006636705}{\texttt{PROGRAM\_FILE}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/loading.jl#L1480-L1487}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12719499456415901450}{} 
\hyperlink{12719499456415901450}{\texttt{Base.@\_\_DIR\_\_}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@__DIR__ -> AbstractString
\end{minted}

Expand to a string with the absolute path to the directory of the file containing the macrocall. Return the current working directory if run from a REPL or if evaluated by \texttt{julia -e <expr>}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/loading.jl#L1493-L1499}{\texttt{source}}


\end{adjustwidth}
\hypertarget{277452200962288519}{} 
\hyperlink{277452200962288519}{\texttt{Base.@\_\_LINE\_\_}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@__LINE__ -> Int
\end{minted}

Expand to the line number of the location of the macrocall. Return \texttt{0} if the line number could not be determined.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L792-L797}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13394819469005127600}{} 
\hyperlink{13394819469005127600}{\texttt{Base.Filesystem.isabspath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isabspath(path::AbstractString) -> Bool
\end{minted}

Determine whether a path is absolute (begins at the root directory).

\textbf{Examples}


\begin{minted}{jlcon}
julia> isabspath("/home")
true

julia> isabspath("home")
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L87-L100}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7293742883276660783}{} 
\hyperlink{7293742883276660783}{\texttt{Base.Filesystem.isdirpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isdirpath(path::AbstractString) -> Bool
\end{minted}

Determine whether a path refers to a directory (for example, ends with a path separator).

\textbf{Examples}


\begin{minted}{jlcon}
julia> isdirpath("/home")
false

julia> isdirpath("/home/")
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L103-L116}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12470257079932202886}{} 
\hyperlink{12470257079932202886}{\texttt{Base.Filesystem.joinpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
joinpath(parts::AbstractString...) -> String
\end{minted}

Join path components into a full path. If some argument is an absolute path or (on Windows) has a drive specification that doesn{\textquotesingle}t match the drive computed for the join of the preceding paths, then prior components are dropped.

Note on Windows since there is a current directory for each drive, \texttt{joinpath({\textquotedbl}c:{\textquotedbl}, {\textquotedbl}foo{\textquotedbl})} represents a path relative to the current directory on drive {\textquotedbl}c:{\textquotedbl} so this is equal to {\textquotedbl}c:foo{\textquotedbl}, not {\textquotedbl}c:{\textbackslash}foo{\textquotedbl}. Furthermore, \texttt{joinpath} treats this as a non-absolute path and ignores the drive letter casing, hence \texttt{joinpath({\textquotedbl}C:{\textbackslash}A{\textquotedbl},{\textquotedbl}c:b{\textquotedbl}) = {\textquotedbl}C:{\textbackslash}A{\textbackslash}b{\textquotedbl}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> joinpath("/home/myuser", "example.jl")
"/home/myuser/example.jl"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L304-L321}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4673100532388501717}{} 
\hyperlink{4673100532388501717}{\texttt{Base.Filesystem.abspath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
abspath(path::AbstractString) -> String
\end{minted}

Convert a path to an absolute path by adding the current directory if necessary. Also normalizes the path as in \hyperlink{5019859018770545283}{\texttt{normpath}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L377-L382}{\texttt{source}}



\begin{lstlisting}
abspath(path::AbstractString, paths::AbstractString...) -> String
\end{lstlisting}

Convert a set of paths to an absolute path by joining them together and adding the current directory if necessary. Equivalent to \texttt{abspath(joinpath(path, paths...))}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L385-L390}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5019859018770545283}{} 
\hyperlink{5019859018770545283}{\texttt{Base.Filesystem.normpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
normpath(path::AbstractString) -> String
\end{minted}

Normalize a path, removing {\textquotedbl}.{\textquotedbl} and {\textquotedbl}..{\textquotedbl} entries.

\textbf{Examples}


\begin{minted}{jlcon}
julia> normpath("/home/myuser/../example.jl")
"/home/example.jl"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L324-L334}{\texttt{source}}



\begin{lstlisting}
normpath(path::AbstractString, paths::AbstractString...) -> String
\end{lstlisting}

Convert a set of paths to a normalized path by joining them together and removing {\textquotedbl}.{\textquotedbl} and {\textquotedbl}..{\textquotedbl} entries. Equivalent to \texttt{normpath(joinpath(path, paths...))}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L369-L374}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6055776470592315771}{} 
\hyperlink{6055776470592315771}{\texttt{Base.Filesystem.realpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
realpath(path::AbstractString) -> String
\end{minted}

Canonicalize a path by expanding symbolic links and removing {\textquotedbl}.{\textquotedbl} and {\textquotedbl}..{\textquotedbl} entries. On case-insensitive case-preserving filesystems (typically Mac and Windows), the filesystem{\textquotesingle}s stored case for the path is returned.

(This function throws an exception if \texttt{path} does not exist in the filesystem.)



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L412-L420}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16322454670651695984}{} 
\hyperlink{16322454670651695984}{\texttt{Base.Filesystem.relpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
relpath(path::AbstractString, startpath::AbstractString = ".") -> AbstractString
\end{minted}

Return a relative filepath to \texttt{path} either from the current directory or from an optional start directory. This is a path computation: the filesystem is not accessed to confirm the existence or nature of \texttt{path} or \texttt{startpath}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L482-L488}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10521892386506791258}{} 
\hyperlink{10521892386506791258}{\texttt{Base.Filesystem.expanduser}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
expanduser(path::AbstractString) -> AbstractString
\end{minted}

On Unix systems, replace a tilde character at the start of a path with the current user{\textquotesingle}s home directory.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L467-L471}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8483950538709909733}{} 
\hyperlink{8483950538709909733}{\texttt{Base.Filesystem.splitdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
splitdir(path::AbstractString) -> (AbstractString, AbstractString)
\end{minted}

Split a path into a tuple of the directory name and file name.

\textbf{Examples}


\begin{minted}{jlcon}
julia> splitdir("/home/myuser")
("/home", "myuser")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L119-L129}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14253131097250488223}{} 
\hyperlink{14253131097250488223}{\texttt{Base.Filesystem.splitdrive}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
splitdrive(path::AbstractString) -> (AbstractString, AbstractString)
\end{minted}

On Windows, split a path into the drive letter part and the path part. On Unix systems, the first component is always the empty string.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L46-L51}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4740094249280549542}{} 
\hyperlink{4740094249280549542}{\texttt{Base.Filesystem.splitext}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
splitext(path::AbstractString) -> (AbstractString, AbstractString)
\end{minted}

If the last component of a path contains a dot, split the path into everything before the dot and everything including and after the dot. Otherwise, return a tuple of the argument unmodified and the empty string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> splitext("/home/myuser/example.jl")
("/home/myuser/example", ".jl")

julia> splitext("/home/myuser/example")
("/home/myuser/example", "")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L178-L193}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11497527244991617161}{} 
\hyperlink{11497527244991617161}{\texttt{Base.Filesystem.splitpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
splitpath(path::AbstractString) -> Vector{String}
\end{minted}

Split a file path into all its path components. This is the opposite of \texttt{joinpath}. Returns an array of substrings, one for each directory or file in the path, including the root directory if present.

\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> splitpath("/home/myuser/example.jl")
4-element Array{String,1}:
 "/"
 "home"
 "myuser"
 "example.jl"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/path.jl#L204-L223}{\texttt{source}}


\end{adjustwidth}

\hypertarget{8198446107690940585}{}


\chapter{I/O 与网络}



\hypertarget{6650448682363190797}{}


\section{通用 I/O}


\hypertarget{18181294266083891471}{} 
\hyperlink{18181294266083891471}{\texttt{Base.stdout}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stdout
\end{minted}

Global variable referring to the standard out stream.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libuv.jl#L135-L139}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6150355911915549172}{} 
\hyperlink{6150355911915549172}{\texttt{Base.stderr}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stderr
\end{minted}

Global variable referring to the standard error stream.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libuv.jl#L142-L146}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3330957653919693521}{} 
\hyperlink{3330957653919693521}{\texttt{Base.stdin}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stdin
\end{minted}

Global variable referring to the standard input stream.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libuv.jl#L128-L132}{\texttt{source}}


\end{adjustwidth}
\hypertarget{300818094931158296}{} 
\hyperlink{300818094931158296}{\texttt{Base.open}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
open(f::Function, args...; kwargs....)
\end{minted}

Apply the function \texttt{f} to the result of \texttt{open(args...; kwargs...)} and close the resulting file descriptor upon completion.

\textbf{Examples}


\begin{minted}{jlcon}
julia> open("myfile.txt", "w") do io
           write(io, "Hello world!")
       end;

julia> open(f->read(f, String), "myfile.txt")
"Hello world!"

julia> rm("myfile.txt")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L277-L294}{\texttt{source}}



\begin{lstlisting}
open(filename::AbstractString; keywords...) -> IOStream
\end{lstlisting}

Open a file in a mode specified by five boolean keyword arguments:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Keyword & Description & Default \\
\hline
\texttt{read} & open for reading & \texttt{!write} \\
\hline
\texttt{write} & open for writing & \texttt{truncate | append} \\
\hline
\texttt{create} & create if non-existent & \texttt{!read \& write | truncate | append} \\
\hline
\texttt{truncate} & truncate to zero size & \texttt{!read \& write} \\
\hline
\texttt{append} & seek to end & \texttt{false} \\
\hline
\end{tabulary}

\end{table}

The default when no keywords are passed is to open files for reading only. Returns a stream for accessing the opened file.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L223-L238}{\texttt{source}}



\begin{lstlisting}
open(filename::AbstractString, [mode::AbstractString]) -> IOStream
\end{lstlisting}

Alternate syntax for open, where a string-based mode specifier is used instead of the five booleans. The values of \texttt{mode} correspond to those from \texttt{fopen(3)} or Perl \texttt{open}, and are equivalent to setting the following boolean groups:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Mode & Description & Keywords \\
\hline
\texttt{r} & read & none \\
\hline
\texttt{w} & write, create, truncate & \texttt{write = true} \\
\hline
\texttt{a} & write, create, append & \texttt{append = true} \\
\hline
\texttt{r+} & read, write & \texttt{read = true, write = true} \\
\hline
\texttt{w+} & read, write, create, truncate & \texttt{truncate = true, read = true} \\
\hline
\texttt{a+} & read, write, create, append & \texttt{append = true, read = true} \\
\hline
\end{tabulary}

\end{table}

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = open("myfile.txt", "w");

julia> write(io, "Hello world!");

julia> close(io);

julia> io = open("myfile.txt", "r");

julia> read(io, String)
"Hello world!"

julia> write(io, "This file is read only")
ERROR: ArgumentError: write failed, IOStream is not writeable
[...]

julia> close(io)

julia> io = open("myfile.txt", "a");

julia> write(io, "This stream is not read only")
28

julia> close(io)

julia> rm("myfile.txt")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L264-L308}{\texttt{source}}



\begin{lstlisting}
open(fd::OS_HANDLE) -> IO
\end{lstlisting}

Take a raw file descriptor wrap it in a Julia-aware IO type, and take ownership of the fd handle. Call \texttt{open(Libc.dup(fd))} to avoid the ownership capture of the original handle.

\begin{quote}
\textbf{Warn}

Do not call this on a handle that{\textquotesingle}s already owned by some other part of the system.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stream.jl#L258-L269}{\texttt{source}}



\begin{lstlisting}
open(command, mode::AbstractString, stdio=devnull)
\end{lstlisting}

Run \texttt{command} asynchronously. Like \texttt{open(command, stdio; read, write)} except specifying the read and write flags via a mode string instead of keyword arguments. Possible mode strings are:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Mode & Description & Keywords \\
\hline
\texttt{r} & read & none \\
\hline
\texttt{w} & write & \texttt{write = true} \\
\hline
\texttt{r+} & read, write & \texttt{read = true, write = true} \\
\hline
\texttt{w+} & read, write & \texttt{read = true, write = true} \\
\hline
\end{tabulary}

\end{table}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/process.jl#L323-L336}{\texttt{source}}



\begin{lstlisting}
open(command, stdio=devnull; write::Bool = false, read::Bool = !write)
\end{lstlisting}

Start running \texttt{command} asynchronously, and return a \texttt{process::IO} object.  If \texttt{read} is true, then reads from the process come from the process{\textquotesingle}s standard output and \texttt{stdio} optionally specifies the process{\textquotesingle}s standard input stream.  If \texttt{write} is true, then writes go to the process{\textquotesingle}s standard input and \texttt{stdio} optionally specifies the process{\textquotesingle}s standard output stream. The process{\textquotesingle}s standard error stream is connected to the current global \texttt{stderr}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/process.jl#L350-L359}{\texttt{source}}



\begin{lstlisting}
open(f::Function, command, args...; kwargs...)
\end{lstlisting}

Similar to \texttt{open(command, args...; kwargs...)}, but calls \texttt{f(stream)} on the resulting process stream, then closes the input stream and waits for the process to complete. Returns the value returned by \texttt{f}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/process.jl#L383-L389}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12496894737220238417}{} 
\hyperlink{12496894737220238417}{\texttt{Base.IOStream}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IOStream
\end{minted}

A buffered IO stream wrapping an OS file descriptor. Mostly used to represent files returned by \hyperlink{300818094931158296}{\texttt{open}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L7-L12}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15789326112236459498}{} 
\hyperlink{15789326112236459498}{\texttt{Base.IOBuffer}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IOBuffer([data::AbstractVector{UInt8}]; keywords...) -> IOBuffer
\end{minted}

Create an in-memory I/O stream, which may optionally operate on a pre-existing array.

It may take optional keyword arguments:

\begin{itemize}
\item \texttt{read}, \texttt{write}, \texttt{append}: restricts operations to the buffer; see \texttt{open} for details.


\item \texttt{truncate}: truncates the buffer size to zero length.


\item \texttt{maxsize}: specifies a size beyond which the buffer may not be grown.


\item \texttt{sizehint}: suggests a capacity of the buffer (\texttt{data} must implement \texttt{sizehint!(data, size)}).

\end{itemize}
When \texttt{data} is not given, the buffer will be both readable and writable by default.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer();

julia> write(io, "JuliaLang is a GitHub organization.", " It has many members.")
56

julia> String(take!(io))
"JuliaLang is a GitHub organization. It has many members."

julia> io = IOBuffer(b"JuliaLang is a GitHub organization.")
IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=35, maxsize=Inf, ptr=1, mark=-1)

julia> read(io, String)
"JuliaLang is a GitHub organization."

julia> write(io, "This isn't writable.")
ERROR: ArgumentError: ensureroom failed, IOBuffer is not writeable

julia> io = IOBuffer(UInt8[], read=true, write=true, maxsize=34)
IOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=0, maxsize=34, ptr=1, mark=-1)

julia> write(io, "JuliaLang is a GitHub organization.")
34

julia> String(take!(io))
"JuliaLang is a GitHub organization"

julia> length(read(IOBuffer(b"data", read=true, truncate=false)))
4

julia> length(read(IOBuffer(b"data", read=true, truncate=true)))
0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iobuffer.jl#L35-L82}{\texttt{source}}



\begin{lstlisting}
IOBuffer(string::String)
\end{lstlisting}

Create a read-only \texttt{IOBuffer} on the data underlying the given string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer("Haho");

julia> String(take!(io))
"Haho"

julia> String(take!(io))
"Haho"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/io.jl#L233-L248}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4963355246106153560}{} 
\hyperlink{4963355246106153560}{\texttt{Base.take!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
take!(b::IOBuffer)
\end{minted}

Obtain the contents of an \texttt{IOBuffer} as an array, without copying. Afterwards, the \texttt{IOBuffer} is reset to its initial state.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer();

julia> write(io, "JuliaLang is a GitHub organization.", " It has many members.")
56

julia> String(take!(io))
"JuliaLang is a GitHub organization. It has many members."
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iobuffer.jl#L348-L364}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4200832604380534486}{} 
\hyperlink{4200832604380534486}{\texttt{Base.fdio}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fdio([name::AbstractString, ]fd::Integer[, own::Bool=false]) -> IOStream
\end{minted}

Create an \hyperlink{12496894737220238417}{\texttt{IOStream}} object from an integer file descriptor. If \texttt{own} is \texttt{true}, closing this object will close the underlying descriptor. By default, an \texttt{IOStream} is closed when it is garbage collected. \texttt{name} allows you to associate the descriptor with a named file.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L208-L214}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4551926523947041107}{} 
\hyperlink{4551926523947041107}{\texttt{Base.flush}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
flush(stream)
\end{minted}

Commit all currently buffered writes to the given stream.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L1029-L1033}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5331333469799487255}{} 
\hyperlink{5331333469799487255}{\texttt{Base.close}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
close(stream)
\end{minted}

Close an I/O stream. Performs a \hyperlink{4551926523947041107}{\texttt{flush}} first.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L57-L61}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16947913578760238729}{} 
\hyperlink{16947913578760238729}{\texttt{Base.write}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
write(io::IO, x)
write(filename::AbstractString, x)
\end{minted}

Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream.   See also \hyperlink{8248717042415202230}{\texttt{print}} to write a text representation (with an encoding that may depend upon \texttt{io}).

You can write multiple values with the same \texttt{write} call. i.e. the following are equivalent:


\begin{lstlisting}
write(io, x, y...)
write(io, x) + write(io, y...)
\end{lstlisting}

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer();

julia> write(io, "JuliaLang is a GitHub organization.", " It has many members.")
56

julia> String(take!(io))
"JuliaLang is a GitHub organization. It has many members."

julia> write(io, "Sometimes those members") + write(io, " write documentation.")
44

julia> String(take!(io))
"Sometimes those members write documentation."
\end{minted}

User-defined plain-data types without \texttt{write} methods can be written when wrapped in a \texttt{Ref}:


\begin{minted}{jlcon}
julia> struct MyStruct; x::Float64; end

julia> io = IOBuffer()
IOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=0, maxsize=Inf, ptr=1, mark=-1)

julia> write(io, Ref(MyStruct(42.0)))
8

julia> seekstart(io); read!(io, Ref(MyStruct(NaN)))
Base.RefValue{MyStruct}(MyStruct(42.0))
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L148-L190}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8104134490906192097}{} 
\hyperlink{8104134490906192097}{\texttt{Base.read}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
read(io::IO, T)
\end{minted}

Read a single value of type \texttt{T} from \texttt{io}, in canonical binary representation.


\begin{lstlisting}
read(io::IO, String)
\end{lstlisting}

Read the entirety of \texttt{io}, as a \texttt{String}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer("JuliaLang is a GitHub organization");

julia> read(io, Char)
'J': ASCII/Unicode U+004A (category Lu: Letter, uppercase)

julia> io = IOBuffer("JuliaLang is a GitHub organization");

julia> read(io, String)
"JuliaLang is a GitHub organization"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L124-L145}{\texttt{source}}



\begin{lstlisting}
read(filename::AbstractString, args...)
\end{lstlisting}

Open a file and read its contents. \texttt{args} is passed to \texttt{read}: this is equivalent to \texttt{open(io->read(io, args...), filename)}.


\begin{lstlisting}
read(filename::AbstractString, String)
\end{lstlisting}

Read the entire contents of a file as a string.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L369-L378}{\texttt{source}}



\begin{lstlisting}
read(s::IO, nb=typemax(Int))
\end{lstlisting}

Read at most \texttt{nb} bytes from \texttt{s}, returning a \texttt{Vector\{UInt8\}} of the bytes read.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L903-L907}{\texttt{source}}



\begin{lstlisting}
read(s::IOStream, nb::Integer; all=true)
\end{lstlisting}

Read at most \texttt{nb} bytes from \texttt{s}, returning a \texttt{Vector\{UInt8\}} of the bytes read.

If \texttt{all} is \texttt{true} (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If \texttt{all} is \texttt{false}, at most one \texttt{read} call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the \texttt{all} option.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L471-L480}{\texttt{source}}



\begin{lstlisting}
read(command::Cmd)
\end{lstlisting}

Run \texttt{command} and return the resulting output as an array of bytes.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/process.jl#L404-L408}{\texttt{source}}



\begin{lstlisting}
read(command::Cmd, String)
\end{lstlisting}

Run \texttt{command} and return the resulting output as a \texttt{String}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/process.jl#L416-L420}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7305890466159196010}{} 
\hyperlink{7305890466159196010}{\texttt{Base.read!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
read!(stream::IO, array::AbstractArray)
read!(filename::AbstractString, array::AbstractArray)
\end{minted}

Read binary data from an I/O stream or file, filling in \texttt{array}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L383-L388}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14376170011353973168}{} 
\hyperlink{14376170011353973168}{\texttt{Base.readbytes!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readbytes!(stream::IO, b::AbstractVector{UInt8}, nb=length(b))
\end{minted}

Read at most \texttt{nb} bytes from \texttt{stream} into \texttt{b}, returning the number of bytes read. The size of \texttt{b} will be increased if needed (i.e. if \texttt{nb} is greater than \texttt{length(b)} and enough bytes could be read), but it will never be decreased.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L877-L883}{\texttt{source}}



\begin{lstlisting}
readbytes!(stream::IOStream, b::AbstractVector{UInt8}, nb=length(b); all::Bool=true)
\end{lstlisting}

Read at most \texttt{nb} bytes from \texttt{stream} into \texttt{b}, returning the number of bytes read. The size of \texttt{b} will be increased if needed (i.e. if \texttt{nb} is greater than \texttt{length(b)} and enough bytes could be read), but it will never be decreased.

If \texttt{all} is \texttt{true} (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If \texttt{all} is \texttt{false}, at most one \texttt{read} call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the \texttt{all} option.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L436-L447}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14873825528169247088}{} 
\hyperlink{14873825528169247088}{\texttt{Base.unsafe\_read}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unsafe_read(io::IO, ref, nbytes::UInt)
\end{minted}

Copy \texttt{nbytes} from the \texttt{IO} stream object into \texttt{ref} (converted to a pointer).

It is recommended that subtypes \texttt{T<:IO} override the following method signature to provide more efficient implementations: \texttt{unsafe\_read(s::T, p::Ptr\{UInt8\}, n::UInt)}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L213-L221}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7085957152663564741}{} 
\hyperlink{7085957152663564741}{\texttt{Base.unsafe\_write}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unsafe_write(io::IO, ref, nbytes::UInt)
\end{minted}

Copy \texttt{nbytes} from \texttt{ref} (converted to a pointer) into the \texttt{IO} object.

It is recommended that subtypes \texttt{T<:IO} override the following method signature to provide more efficient implementations: \texttt{unsafe\_write(s::T, p::Ptr\{UInt8\}, n::UInt)}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L196-L204}{\texttt{source}}


\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Base.peek}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{14999933350742523048}{} 
\hyperlink{14999933350742523048}{\texttt{Base.position}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
position(s)
\end{minted}

Get the current position of a stream.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer("JuliaLang is a GitHub organization.");

julia> seek(io, 5);

julia> position(io)
5

julia> skip(io, 10);

julia> position(io)
15

julia> seekend(io);

julia> position(io)
35
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L170-L194}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11269748483301652100}{} 
\hyperlink{11269748483301652100}{\texttt{Base.seek}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
seek(s, pos)
\end{minted}

Seek a stream to the given position.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer("JuliaLang is a GitHub organization.");

julia> seek(io, 5);

julia> read(io, Char)
'L': ASCII/Unicode U+004C (category Lu: Letter, uppercase)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L91-L105}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17809695755202491288}{} 
\hyperlink{17809695755202491288}{\texttt{Base.seekstart}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
seekstart(s)
\end{minted}

Seek a stream to its beginning.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer("JuliaLang is a GitHub organization.");

julia> seek(io, 5);

julia> read(io, Char)
'L': ASCII/Unicode U+004C (category Lu: Letter, uppercase)

julia> seekstart(io);

julia> read(io, Char)
'J': ASCII/Unicode U+004A (category Lu: Letter, uppercase)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L113-L132}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7051129712452805515}{} 
\hyperlink{7051129712452805515}{\texttt{Base.seekend}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
seekend(s)
\end{minted}

Seek a stream to its end.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L135-L139}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3828582500400083834}{} 
\hyperlink{3828582500400083834}{\texttt{Base.skip}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
skip(s, offset)
\end{minted}

Seek a stream relative to the current position.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer("JuliaLang is a GitHub organization.");

julia> seek(io, 5);

julia> skip(io, 10);

julia> read(io, Char)
'G': ASCII/Unicode U+0047 (category Lu: Letter, uppercase)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L146-L162}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12695720152576749628}{} 
\hyperlink{12695720152576749628}{\texttt{Base.mark}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mark(s)
\end{minted}

Add a mark at the current position of stream \texttt{s}. Return the marked position.

See also \hyperlink{1677829146244042320}{\texttt{unmark}}, \hyperlink{17642823092929127210}{\texttt{reset}}, \hyperlink{5764088774799520350}{\texttt{ismarked}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L977-L983}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1677829146244042320}{} 
\hyperlink{1677829146244042320}{\texttt{Base.unmark}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unmark(s)
\end{minted}

Remove a mark from stream \texttt{s}. Return \texttt{true} if the stream was marked, \texttt{false} otherwise.

See also \hyperlink{12695720152576749628}{\texttt{mark}}, \hyperlink{17642823092929127210}{\texttt{reset}}, \hyperlink{5764088774799520350}{\texttt{ismarked}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L988-L994}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17642823092929127210}{} 
\hyperlink{17642823092929127210}{\texttt{Base.reset}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reset(s)
\end{minted}

Reset a stream \texttt{s} to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked.

See also \hyperlink{12695720152576749628}{\texttt{mark}}, \hyperlink{1677829146244042320}{\texttt{unmark}}, \hyperlink{5764088774799520350}{\texttt{ismarked}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L1001-L1008}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5764088774799520350}{} 
\hyperlink{5764088774799520350}{\texttt{Base.ismarked}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ismarked(s)
\end{minted}

Return \texttt{true} if stream \texttt{s} is marked.

See also \hyperlink{12695720152576749628}{\texttt{mark}}, \hyperlink{1677829146244042320}{\texttt{unmark}}, \hyperlink{17642823092929127210}{\texttt{reset}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L1017-L1023}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1214745596749163873}{} 
\hyperlink{1214745596749163873}{\texttt{Base.eof}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eof(stream) -> Bool
\end{minted}

Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return \texttt{false}. Therefore it is always safe to read one byte after seeing \texttt{eof} return \texttt{false}. \texttt{eof} will return \texttt{false} as long as buffered data is still available, even if the remote end of a connection is closed.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L352-L360}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3535270730162763546}{} 
\hyperlink{3535270730162763546}{\texttt{Base.isreadonly}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isreadonly(io) -> Bool
\end{minted}

Determine whether a stream is read-only.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer("JuliaLang is a GitHub organization");

julia> isreadonly(io)
true

julia> io = IOBuffer();

julia> isreadonly(io)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L560-L577}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5354682531169079914}{} 
\hyperlink{5354682531169079914}{\texttt{Base.iswritable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
iswritable(io) -> Bool
\end{minted}

Return \texttt{true} if the specified IO object is writable (if that can be determined).

\textbf{Examples}


\begin{minted}{jlcon}
julia> open("myfile.txt", "w") do io
           print(io, "Hello world!");
           iswritable(io)
       end
true

julia> open("myfile.txt", "r") do io
           iswritable(io)
       end
false

julia> rm("myfile.txt")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L99-L119}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7695515320845284530}{} 
\hyperlink{7695515320845284530}{\texttt{Base.isreadable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isreadable(io) -> Bool
\end{minted}

Return \texttt{true} if the specified IO object is readable (if that can be determined).

\textbf{Examples}


\begin{minted}{jlcon}
julia> open("myfile.txt", "w") do io
           print(io, "Hello world!");
           isreadable(io)
       end
false

julia> open("myfile.txt", "r") do io
           isreadable(io)
       end
true

julia> rm("myfile.txt")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L76-L96}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12411519405593851135}{} 
\hyperlink{12411519405593851135}{\texttt{Base.isopen}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isopen(object) -> Bool
\end{minted}

Determine whether an object - such as a stream or timer – is not yet closed. Once an object is closed, it will never produce a new event. However, since a closed stream may still have data to read in its buffer, use \hyperlink{1214745596749163873}{\texttt{eof}} to check for the ability to read data. Use the \texttt{FileWatching} package to be notified when a stream might be writable or readable.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = open("my_file.txt", "w+");

julia> isopen(io)
true

julia> close(io)

julia> isopen(io)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L33-L54}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4096210142404798505}{} 
\hyperlink{4096210142404798505}{\texttt{Base.fd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fd(stream)
\end{minted}

Return the file descriptor backing the stream or file. Note that this function only applies to synchronous \texttt{File}{\textquotesingle}s and \texttt{IOStream}{\textquotesingle}s not to any of the asynchronous streams.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L36-L41}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1112291265677833393}{} 
\hyperlink{1112291265677833393}{\texttt{Base.redirect\_stdout}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
redirect_stdout([stream]) -> (rd, wr)
\end{minted}

Create a pipe to which all C and Julia level \hyperlink{18181294266083891471}{\texttt{stdout}} output will be redirected. Returns a tuple \texttt{(rd, wr)} representing the pipe ends. Data written to \hyperlink{18181294266083891471}{\texttt{stdout}} may now be read from the \texttt{rd} end of the pipe. The \texttt{wr} end is given for convenience in case the old \hyperlink{18181294266083891471}{\texttt{stdout}} object was cached by the user and needs to be replaced elsewhere.

If called with the optional \texttt{stream} argument, then returns \texttt{stream} itself.

\begin{quote}
\textbf{Note}

\texttt{stream} must be a \texttt{TTY}, a \texttt{Pipe}, or a socket.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stream.jl#L1106-L1121}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12923908242336925438}{} 
\hyperlink{12923908242336925438}{\texttt{Base.redirect\_stdout}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
redirect_stdout(f::Function, stream)
\end{minted}

Run the function \texttt{f} while redirecting \hyperlink{18181294266083891471}{\texttt{stdout}} to \texttt{stream}. Upon completion, \hyperlink{18181294266083891471}{\texttt{stdout}} is restored to its prior setting.

\begin{quote}
\textbf{Note}

\texttt{stream} must be a \texttt{TTY}, a \texttt{Pipe}, or a socket.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stream.jl#L1160-L1168}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17653990356642003163}{} 
\hyperlink{17653990356642003163}{\texttt{Base.redirect\_stderr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
redirect_stderr([stream]) -> (rd, wr)
\end{minted}

Like \hyperlink{1112291265677833393}{\texttt{redirect\_stdout}}, but for \hyperlink{6150355911915549172}{\texttt{stderr}}.

\begin{quote}
\textbf{Note}

\texttt{stream} must be a \texttt{TTY}, a \texttt{Pipe}, or a socket.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stream.jl#L1124-L1131}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4630317800478362301}{} 
\hyperlink{4630317800478362301}{\texttt{Base.redirect\_stderr}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
redirect_stderr(f::Function, stream)
\end{minted}

Run the function \texttt{f} while redirecting \hyperlink{6150355911915549172}{\texttt{stderr}} to \texttt{stream}. Upon completion, \hyperlink{6150355911915549172}{\texttt{stderr}} is restored to its prior setting.

\begin{quote}
\textbf{Note}

\texttt{stream} must be a \texttt{TTY}, a \texttt{Pipe}, or a socket.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stream.jl#L1171-L1179}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17751303507361009787}{} 
\hyperlink{17751303507361009787}{\texttt{Base.redirect\_stdin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
redirect_stdin([stream]) -> (rd, wr)
\end{minted}

Like \hyperlink{1112291265677833393}{\texttt{redirect\_stdout}}, but for \hyperlink{3330957653919693521}{\texttt{stdin}}. Note that the order of the return tuple is still \texttt{(rd, wr)}, i.e. data to be read from \hyperlink{3330957653919693521}{\texttt{stdin}} may be written to \texttt{wr}.

\begin{quote}
\textbf{Note}

\texttt{stream} must be a \texttt{TTY}, a \texttt{Pipe}, or a socket.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stream.jl#L1134-L1143}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17205945783347532140}{} 
\hyperlink{17205945783347532140}{\texttt{Base.redirect\_stdin}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
redirect_stdin(f::Function, stream)
\end{minted}

Run the function \texttt{f} while redirecting \hyperlink{3330957653919693521}{\texttt{stdin}} to \texttt{stream}. Upon completion, \hyperlink{3330957653919693521}{\texttt{stdin}} is restored to its prior setting.

\begin{quote}
\textbf{Note}

\texttt{stream} must be a \texttt{TTY}, a \texttt{Pipe}, or a socket.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stream.jl#L1182-L1190}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1622401395685476756}{} 
\hyperlink{1622401395685476756}{\texttt{Base.readchomp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readchomp(x)
\end{minted}

Read the entirety of \texttt{x} as a string and remove a single trailing newline if there is one. Equivalent to \texttt{chomp(read(x, String))}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> open("my_file.txt", "w") do io
           write(io, "JuliaLang is a GitHub organization.\nIt has many members.\n");
       end;

julia> readchomp("my_file.txt")
"JuliaLang is a GitHub organization.\nIt has many members."

julia> rm("my_file.txt");
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L855-L872}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16572122454613115528}{} 
\hyperlink{16572122454613115528}{\texttt{Base.truncate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
truncate(file, n)
\end{minted}

Resize the file or buffer given by the first argument to exactly \texttt{n} bytes, filling previously unallocated space with {\textquotesingle}{\textbackslash}0{\textquotesingle} if the file or buffer is grown.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer();

julia> write(io, "JuliaLang is a GitHub organization.")
35

julia> truncate(io, 15)
IOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=15, maxsize=Inf, ptr=16, mark=-1)

julia> String(take!(io))
"JuliaLang is a "

julia> io = IOBuffer();

julia> write(io, "JuliaLang is a GitHub organization.");

julia> truncate(io, 40);

julia> String(take!(io))
"JuliaLang is a GitHub organization.\0\0\0\0\0"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iostream.jl#L56-L84}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6177395059245061697}{} 
\hyperlink{6177395059245061697}{\texttt{Base.skipchars}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
skipchars(predicate, io::IO; linecomment=nothing)
\end{minted}

Advance the stream \texttt{io} such that the next-read character will be the first remaining for which \texttt{predicate} returns \texttt{false}. If the keyword argument \texttt{linecomment} is specified, all characters from that character until the start of the next line are ignored.

\textbf{Examples}


\begin{minted}{jlcon}
julia> buf = IOBuffer("    text")
IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=8, maxsize=Inf, ptr=1, mark=-1)

julia> skipchars(isspace, buf)
IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=8, maxsize=Inf, ptr=5, mark=-1)

julia> String(readavailable(buf))
"text"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L1036-L1054}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17858389738629138759}{} 
\hyperlink{17858389738629138759}{\texttt{Base.countlines}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
countlines(io::IO; eol::AbstractChar = '\n')
\end{minted}

Read \texttt{io} until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than \texttt{{\textquotesingle}{\textbackslash}n{\textquotesingle}} are supported by passing them as the second argument.  The last non-empty line of \texttt{io} is counted even if it does not end with the EOL, matching the length returned by \hyperlink{3474649815265066504}{\texttt{eachline}} and \hyperlink{2102076388448706590}{\texttt{readlines}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer("JuliaLang is a GitHub organization.\n");

julia> countlines(io)
1

julia> io = IOBuffer("JuliaLang is a GitHub organization.");

julia> countlines(io)
1

julia> countlines(io, eol = '.')
0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L1068-L1091}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16959584405141637900}{} 
\hyperlink{16959584405141637900}{\texttt{Base.PipeBuffer}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
PipeBuffer(data::Vector{UInt8}=UInt8[]; maxsize::Integer = typemax(Int))
\end{minted}

An \hyperlink{15789326112236459498}{\texttt{IOBuffer}} that allows reading and performs writes by appending. Seeking and truncating are not supported. See \hyperlink{15789326112236459498}{\texttt{IOBuffer}} for the available constructors. If \texttt{data} is given, creates a \texttt{PipeBuffer} to operate on a data vector, optionally specifying a size beyond which the underlying \texttt{Array} may not be grown.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iobuffer.jl#L127-L135}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11079438348370067557}{} 
\hyperlink{11079438348370067557}{\texttt{Base.readavailable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readavailable(stream)
\end{minted}

Read all available data on the stream, blocking the task only if no data is available. The result is a \texttt{Vector\{UInt8,1\}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L68-L73}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13454403377667762339}{} 
\hyperlink{13454403377667762339}{\texttt{Base.IOContext}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IOContext
\end{minted}

\texttt{IOContext} provides a mechanism for passing output configuration settings among \hyperlink{14071376285304310153}{\texttt{show}} methods.

In short, it is an immutable dictionary that is a subclass of \texttt{IO}. It supports standard dictionary operations such as \hyperlink{13720608614876840481}{\texttt{getindex}}, and can also be used as an I/O stream.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/show.jl#L207-L214}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15316695504427164836}{} 
\hyperlink{15316695504427164836}{\texttt{Base.IOContext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IOContext(io::IO, KV::Pair...)
\end{minted}

Create an \texttt{IOContext} that wraps a given stream, adding the specified \texttt{key=>value} pairs to the properties of that stream (note that \texttt{io} can itself be an \texttt{IOContext}).

\begin{itemize}
\item use \texttt{(key => value) in io} to see if this particular combination is in the properties set


\item use \texttt{get(io, key, default)} to retrieve the most recent value for a particular key

\end{itemize}
The following properties are in common use:

\begin{itemize}
\item \texttt{:compact}: Boolean specifying that small values should be printed more compactly, e.g. that numbers should be printed with fewer digits. This is set when printing array elements.


\item \texttt{:limit}: Boolean specifying that containers should be truncated, e.g. showing \texttt{…} in place of most elements.


\item \texttt{:displaysize}: A \texttt{Tuple\{Int,Int\}} giving the size in rows and columns to use for text output. This can be used to override the display size for called functions, but to get the size of the screen use the \texttt{displaysize} function.


\item \texttt{:typeinfo}: a \texttt{Type} characterizing the information already printed concerning the type of the object about to be displayed. This is mainly useful when displaying a collection of objects of the same type, so that redundant type information can be avoided (e.g. \texttt{[Float16(0)]} can be shown as {\textquotedbl}Float16[0.0]{\textquotedbl} instead of {\textquotedbl}Float16[Float16(0.0)]{\textquotedbl} : while displaying the elements of the array, the \texttt{:typeinfo} property will be set to \texttt{Float16}).


\item \texttt{:color}: Boolean specifying whether ANSI color/escape codes are supported/expected. By default, this is determined by whether \texttt{io} is a compatible terminal and by any \texttt{--color} command-line flag when \texttt{julia} was launched.

\end{itemize}
\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer();

julia> printstyled(IOContext(io, :color => true), "string", color=:red)

julia> String(take!(io))
"\e[31mstring\e[39m"

julia> printstyled(io, "string", color=:red)

julia> String(take!(io))
"string"
\end{minted}


\begin{minted}{jlcon}
julia> print(IOContext(stdout, :compact => false), 1.12341234)
1.12341234
julia> print(IOContext(stdout, :compact => true), 1.12341234)
1.12341
\end{minted}


\begin{minted}{jlcon}
julia> function f(io::IO)
           if get(io, :short, false)
               print(io, "short")
           else
               print(io, "loooooong")
           end
       end
f (generic function with 1 method)

julia> f(stdout)
loooooong
julia> f(IOContext(stdout, :short => true))
short
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/show.jl#L250-L317}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9657846139399432866}{} 
\hyperlink{9657846139399432866}{\texttt{Base.IOContext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IOContext(io::IO, context::IOContext)
\end{minted}

Create an \texttt{IOContext} that wraps an alternate \texttt{IO} but inherits the properties of \texttt{context}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/show.jl#L243-L247}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14803809014545196748}{}


\section{文本 I/O}


\hypertarget{14071376285304310153}{} 
\hyperlink{14071376285304310153}{\texttt{Base.show}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
show(x)
\end{minted}

Write an informative text representation of a value to the current output stream. New types should overload \texttt{show(io::IO, x)} where the first argument is a stream. The representation used by \texttt{show} generally includes Julia-specific formatting and type information.

\hyperlink{13076889230390082034}{\texttt{repr}} returns the output of \texttt{show} as a string.

See also \hyperlink{8248717042415202230}{\texttt{print}}, which writes un-decorated representations.

\textbf{Examples}


\begin{minted}{jlcon}
julia> show("Hello World!")
"Hello World!"
julia> print("Hello World!")
Hello World!
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/show.jl#L353-L371}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17506338626525391609}{} 
\hyperlink{17506338626525391609}{\texttt{Base.summary}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
summary(io::IO, x)
str = summary(x)
\end{minted}

Print to a stream \texttt{io}, or return a string \texttt{str}, giving a brief description of a value. By default returns \texttt{string(typeof(x))}, e.g. \hyperlink{7720564657383125058}{\texttt{Int64}}.

For arrays, returns a string of size and type info, e.g. \texttt{10-element Array\{Int64,1\}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> summary(1)
"Int64"

julia> summary(zeros(2))
"2-element Array{Float64,1}"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/show.jl#L2094-L2112}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8248717042415202230}{} 
\hyperlink{8248717042415202230}{\texttt{Base.print}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
print([io::IO], xs...)
\end{minted}

Write to \texttt{io} (or to the default output stream \hyperlink{18181294266083891471}{\texttt{stdout}} if \texttt{io} is not given) a canonical (un-decorated) text representation. The representation used by \texttt{print} includes minimal formatting and tries to avoid Julia-specific details.

\texttt{print} falls back to calling \texttt{show}, so most types should just define \texttt{show}. Define \texttt{print} if your type has a separate {\textquotedbl}plain{\textquotedbl} representation. For example, \texttt{show} displays strings with quotes, and \texttt{print} displays strings without quotes.

\hyperlink{7919678712989769360}{\texttt{string}} returns the output of \texttt{print} as a string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> print("Hello World!")
Hello World!
julia> io = IOBuffer();

julia> print(io, "Hello", ' ', :World!)

julia> String(take!(io))
"Hello World!"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/io.jl#L5-L31}{\texttt{source}}


\end{adjustwidth}
\hypertarget{783803254548423222}{} 
\hyperlink{783803254548423222}{\texttt{Base.println}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
println([io::IO], xs...)
\end{minted}

Print (using \hyperlink{8248717042415202230}{\texttt{print}}) \texttt{xs} followed by a newline. If \texttt{io} is not supplied, prints to \hyperlink{18181294266083891471}{\texttt{stdout}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> println("Hello, world")
Hello, world

julia> io = IOBuffer();

julia> println(io, "Hello, world")

julia> String(take!(io))
"Hello, world\n"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/io.jl#L54-L72}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16920681785945917903}{} 
\hyperlink{16920681785945917903}{\texttt{Base.printstyled}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
printstyled([io], xs...; bold::Bool=false, color::Union{Symbol,Int}=:normal)
\end{minted}

Print \texttt{xs} in a color specified as a symbol or integer, optionally in bold.

\texttt{color} may take any of the values \texttt{:normal}, \texttt{:default}, \texttt{:bold}, \texttt{:black}, \texttt{:blink}, \texttt{:blue}, \texttt{:cyan}, \texttt{:green}, \texttt{:hidden}, \texttt{:light\_black}, \texttt{:light\_blue}, \texttt{:light\_cyan}, \texttt{:light\_green}, \texttt{:light\_magenta}, \texttt{:light\_red}, \texttt{:light\_yellow}, \texttt{:magenta}, \texttt{:nothing}, \texttt{:red}, \texttt{:reverse}, \texttt{:underline}, \texttt{:white}, or  \texttt{:yellow} or an integer between 0 and 255 inclusive. Note that not all terminals support 256 colors. If the keyword \texttt{bold} is given as \texttt{true}, the result will be printed in bold.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/util.jl#L408-L416}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6652981552509545835}{} 
\hyperlink{6652981552509545835}{\texttt{Base.sprint}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sprint(f::Function, args...; context=nothing, sizehint=0)
\end{minted}

Call the given function with an I/O stream and the supplied extra arguments. Everything written to this I/O stream is returned as a string. \texttt{context} can be either an \hyperlink{13454403377667762339}{\texttt{IOContext}} whose properties will be used, or a \texttt{Pair} specifying a property and its value. \texttt{sizehint} suggests the capacity of the buffer (in bytes).

The optional keyword argument \texttt{context} can be set to \texttt{:key=>value} pair or an \texttt{IO} or \hyperlink{13454403377667762339}{\texttt{IOContext}} object whose attributes are used for the I/O stream passed to \texttt{f}.  The optional \texttt{sizehint} is a suggested size (in bytes) to allocate for the buffer used to write the string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sprint(show, 66.66666; context=:compact => true)
"66.6667"

julia> sprint(showerror, BoundsError([1], 100))
"BoundsError: attempt to access 1-element Array{Int64,1} at index [100]"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/strings/io.jl#L77-L99}{\texttt{source}}


\end{adjustwidth}
\hypertarget{991925725019765935}{} 
\hyperlink{991925725019765935}{\texttt{Base.showerror}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
showerror(io, e)
\end{minted}

Show a descriptive representation of an exception object \texttt{e}. This method is used to display the exception after a call to \hyperlink{16410366672587017456}{\texttt{throw}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> struct MyException <: Exception
           msg::AbstractString
       end

julia> function Base.showerror(io::IO, err::MyException)
           print(io, "MyException: ")
           print(io, err.msg)
       end

julia> err = MyException("test exception")
MyException("test exception")

julia> sprint(showerror, err)
"MyException: test exception"

julia> throw(MyException("test exception"))
ERROR: MyException: test exception
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/errorshow.jl#L3-L29}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15981569052160951906}{} 
\hyperlink{15981569052160951906}{\texttt{Base.dump}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dump(x; maxdepth=8)
\end{minted}

Show every part of the representation of a value. The depth of the output is truncated at \texttt{maxdepth}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> struct MyStruct
           x
           y
       end

julia> x = MyStruct(1, (2,3));

julia> dump(x)
MyStruct
  x: Int64 1
  y: Tuple{Int64,Int64}
    1: Int64 2
    2: Int64 3

julia> dump(x; maxdepth = 1)
MyStruct
  x: Int64 1
  y: Tuple{Int64,Int64}
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/show.jl#L2017-L2044}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11314997131411442967}{} 
\hyperlink{11314997131411442967}{\texttt{Base.Meta.@dump}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@dump expr
\end{minted}

Show every part of the representation of the given expression. Equivalent to \hyperlink{15981569052160951906}{\texttt{dump(:(expr))}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/meta.jl#L106-L111}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14199256323314707596}{} 
\hyperlink{14199256323314707596}{\texttt{Base.readline}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readline(io::IO=stdin; keep::Bool=false)
readline(filename::AbstractString; keep::Bool=false)
\end{minted}

Read a single line of text from the given I/O stream or file (defaults to \texttt{stdin}). When reading from a file, the text is assumed to be encoded in UTF-8. Lines in the input end with \texttt{{\textquotesingle}{\textbackslash}n{\textquotesingle}} or \texttt{{\textquotedbl}{\textbackslash}r{\textbackslash}n{\textquotedbl}} or the end of an input stream. When \texttt{keep} is false (as it is by default), these trailing newline characters are removed from the line before it is returned. When \texttt{keep} is true, they are returned as part of the line.

\textbf{Examples}


\begin{minted}{jlcon}
julia> open("my_file.txt", "w") do io
           write(io, "JuliaLang is a GitHub organization.\nIt has many members.\n");
       end
57

julia> readline("my_file.txt")
"JuliaLang is a GitHub organization."

julia> readline("my_file.txt", keep=true)
"JuliaLang is a GitHub organization.\n"

julia> rm("my_file.txt")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L420-L446}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16924445721840905654}{} 
\hyperlink{16924445721840905654}{\texttt{Base.readuntil}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readuntil(stream::IO, delim; keep::Bool = false)
readuntil(filename::AbstractString, delim; keep::Bool = false)
\end{minted}

Read a string from an I/O stream or a file, up to the given delimiter. The delimiter can be a \texttt{UInt8}, \texttt{AbstractChar}, string, or vector. Keyword argument \texttt{keep} controls whether the delimiter is included in the result. The text is assumed to be encoded in UTF-8.

\textbf{Examples}


\begin{minted}{jlcon}
julia> open("my_file.txt", "w") do io
           write(io, "JuliaLang is a GitHub organization.\nIt has many members.\n");
       end
57

julia> readuntil("my_file.txt", 'L')
"Julia"

julia> readuntil("my_file.txt", '.', keep = true)
"JuliaLang is a GitHub organization."

julia> rm("my_file.txt")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L393-L417}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2102076388448706590}{} 
\hyperlink{2102076388448706590}{\texttt{Base.readlines}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readlines(io::IO=stdin; keep::Bool=false)
readlines(filename::AbstractString; keep::Bool=false)
\end{minted}

Read all lines of an I/O stream or a file as a vector of strings. Behavior is equivalent to saving the result of reading \hyperlink{14199256323314707596}{\texttt{readline}} repeatedly with the same arguments and saving the resulting lines as a vector of strings.

\textbf{Examples}


\begin{minted}{jlcon}
julia> open("my_file.txt", "w") do io
           write(io, "JuliaLang is a GitHub organization.\nIt has many members.\n");
       end
57

julia> readlines("my_file.txt")
2-element Array{String,1}:
 "JuliaLang is a GitHub organization."
 "It has many members."

julia> readlines("my_file.txt", keep=true)
2-element Array{String,1}:
 "JuliaLang is a GitHub organization.\n"
 "It has many members.\n"

julia> rm("my_file.txt")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L465-L492}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3474649815265066504}{} 
\hyperlink{3474649815265066504}{\texttt{Base.eachline}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eachline(io::IO=stdin; keep::Bool=false)
eachline(filename::AbstractString; keep::Bool=false)
\end{minted}

Create an iterable \texttt{EachLine} object that will yield each line from an I/O stream or a file. Iteration calls \hyperlink{14199256323314707596}{\texttt{readline}} on the stream argument repeatedly with \texttt{keep} passed through, determining whether trailing end-of-line characters are retained. When called with a file name, the file is opened once at the beginning of iteration and closed at the end. If iteration is interrupted, the file will be closed when the \texttt{EachLine} object is garbage collected.

\textbf{Examples}


\begin{minted}{jlcon}
julia> open("my_file.txt", "w") do io
           write(io, "JuliaLang is a GitHub organization.\n It has many members.\n");
       end;

julia> for line in eachline("my_file.txt")
           print(line)
       end
JuliaLang is a GitHub organization. It has many members.

julia> rm("my_file.txt");
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L929-L953}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1969380123003883060}{} 
\hyperlink{1969380123003883060}{\texttt{Base.displaysize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
displaysize([io::IO]) -> (lines, columns)
\end{minted}

Return the nominal size of the screen that may be used for rendering output to this \texttt{IO} object. If no input is provided, the environment variables \texttt{LINES} and \texttt{COLUMNS} are read. If those are not set, a default size of \texttt{(24, 80)} is returned.

\textbf{Examples}


\begin{minted}{jlcon}
julia> withenv("LINES" => 30, "COLUMNS" => 100) do
           displaysize()
       end
(30, 100)
\end{minted}

To get your TTY size,


\begin{minted}{julia}
julia> displaysize(stdout)
(34, 147)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stream.jl#L430-L452}{\texttt{source}}


\end{adjustwidth}

\hypertarget{6006580368420106291}{}


\section{多媒体 I/O}



就像文本输出用 \hyperlink{8248717042415202230}{\texttt{print}} 实现，用户自定义类型可以通过重载 \hyperlink{14071376285304310153}{\texttt{show}} 来指定其文本化表示， Julia 提供了一个应用于富多媒体输出的标准化机制 （例如图片、格式化文本、甚至音频和视频），由以下三部分组成：



\begin{itemize}
\item 函数 \hyperlink{12073120410747960438}{\texttt{display(x)}} 来请求一个 Julia 对象 \texttt{x} 最丰富的多媒体展示，并以纯文本作为后备模式。


\item 重载 \hyperlink{14071376285304310153}{\texttt{show}} 允许指定用户自定义类型的任意多媒体表现形式（以标准MIME类型为键值）。


\item Multimedia-capable display backends may be registered by subclassing a generic \hyperlink{10910270786739084548}{\texttt{AbstractDisplay}} type 并通过 \hyperlink{13142233867690107090}{\texttt{pushdisplay}} 将其压进显示后端的栈中。

\end{itemize}


基础 Julia 运行环境只提供纯文本显示， 但是更富的显示可以通过加载外部模块或者使用图形化 Julia 环境 （比如基于 IPython 的 IJulia notebook）来实现。


\hypertarget{10910270786739084548}{} 
\hyperlink{10910270786739084548}{\texttt{Base.Multimedia.AbstractDisplay}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractDisplay
\end{minted}

Abstract supertype for rich display output devices. \hyperlink{15269032442876270904}{\texttt{TextDisplay}} is a subtype of this.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L205-L210}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12073120410747960438}{} 
\hyperlink{12073120410747960438}{\texttt{Base.Multimedia.display}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
display(x)
display(d::AbstractDisplay, x)
display(mime, x)
display(d::AbstractDisplay, mime, x)
\end{minted}

AbstractDisplay \texttt{x} using the topmost applicable display in the display stack, typically using the richest supported multimedia output for \texttt{x}, with plain-text \hyperlink{18181294266083891471}{\texttt{stdout}} output as a fallback. The \texttt{display(d, x)} variant attempts to display \texttt{x} on the given display \texttt{d} only, throwing a \hyperlink{68769522931907606}{\texttt{MethodError}} if \texttt{d} cannot display objects of this type.

In general, you cannot assume that \texttt{display} output goes to \texttt{stdout} (unlike \hyperlink{8248717042415202230}{\texttt{print(x)}} or \hyperlink{14071376285304310153}{\texttt{show(x)}}).  For example, \texttt{display(x)} may open up a separate window with an image. \texttt{display(x)} means {\textquotedbl}show \texttt{x} in the best way you can for the current output device(s).{\textquotedbl} If you want REPL-like text output that is guaranteed to go to \texttt{stdout}, use \hyperlink{552201489544217829}{\texttt{show(stdout, {\textquotedbl}text/plain{\textquotedbl}, x)}} instead.

There are also two variants with a \texttt{mime} argument (a MIME type string, such as \texttt{{\textquotedbl}image/png{\textquotedbl}}), which attempt to display \texttt{x} using the requested MIME type \emph{only}, throwing a \texttt{MethodError} if this type is not supported by either the display(s) or by \texttt{x}. With these variants, one can also supply the {\textquotedbl}raw{\textquotedbl} data in the requested MIME type by passing \texttt{x::AbstractString} (for MIME types with text-based storage, such as text/html or application/postscript) or \texttt{x::Vector\{UInt8\}} (for binary MIME types).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L295-L318}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3747338623378176831}{} 
\hyperlink{3747338623378176831}{\texttt{Base.Multimedia.redisplay}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
redisplay(x)
redisplay(d::AbstractDisplay, x)
redisplay(mime, x)
redisplay(d::AbstractDisplay, mime, x)
\end{minted}

By default, the \texttt{redisplay} functions simply call \hyperlink{12073120410747960438}{\texttt{display}}. However, some display backends may override \texttt{redisplay} to modify an existing display of \texttt{x} (if any). Using \texttt{redisplay} is also a hint to the backend that \texttt{x} may be redisplayed several times, and the backend may choose to defer the display until (for example) the next interactive prompt.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L365-L377}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18261911967873698059}{} 
\hyperlink{18261911967873698059}{\texttt{Base.Multimedia.displayable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
displayable(mime) -> Bool
displayable(d::AbstractDisplay, mime) -> Bool
\end{minted}

Returns a boolean value indicating whether the given \texttt{mime} type (string) is displayable by any of the displays in the current display stack, or specifically by the display \texttt{d} in the second variant.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L217-L224}{\texttt{source}}


\end{adjustwidth}
\hypertarget{552201489544217829}{} 
\hyperlink{552201489544217829}{\texttt{Base.show}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
show(io, mime, x)
\end{minted}

The \hyperlink{12073120410747960438}{\texttt{display}} functions ultimately call \texttt{show} in order to write an object \texttt{x} as a given \texttt{mime} type to a given I/O stream \texttt{io} (usually a memory buffer), if possible. In order to provide a rich multimedia representation of a user-defined type \texttt{T}, it is only necessary to define a new \texttt{show} method for \texttt{T}, via: \texttt{show(io, ::MIME{\textquotedbl}mime{\textquotedbl}, x::T) = ...}, where \texttt{mime} is a MIME-type string and the function body calls \hyperlink{16947913578760238729}{\texttt{write}} (or similar) to write that representation of \texttt{x} to \texttt{io}. (Note that the \texttt{MIME{\textquotedbl}{\textquotedbl}} notation only supports literal strings; to construct \texttt{MIME} types in a more flexible manner use \texttt{MIME\{Symbol({\textquotedbl}{\textquotedbl})\}}.)

For example, if you define a \texttt{MyImage} type and know how to write it to a PNG file, you could define a function \texttt{show(io, ::MIME{\textquotedbl}image/png{\textquotedbl}, x::MyImage) = ...} to allow your images to be displayed on any PNG-capable \texttt{AbstractDisplay} (such as IJulia). As usual, be sure to \texttt{import Base.show} in order to add new methods to the built-in Julia function \texttt{show}.

The default MIME type is \texttt{MIME{\textquotedbl}text/plain{\textquotedbl}}. There is a fallback definition for \texttt{text/plain} output that calls \texttt{show} with 2 arguments. Therefore, this case should be handled by defining a 2-argument \texttt{show(io::IO, x::MyType)} method.

Technically, the \texttt{MIME{\textquotedbl}mime{\textquotedbl}} macro defines a singleton type for the given \texttt{mime} string, which allows us to exploit Julia{\textquotesingle}s dispatch mechanisms in determining how to display objects of any given type.

The first argument to \texttt{show} can be an \hyperlink{13454403377667762339}{\texttt{IOContext}} specifying output format properties. See \hyperlink{13454403377667762339}{\texttt{IOContext}} for details.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L79-L107}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17009846549175764333}{} 
\hyperlink{17009846549175764333}{\texttt{Base.Multimedia.showable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
showable(mime, x)
\end{minted}

Returns a boolean value indicating whether or not the object \texttt{x} can be written as the given \texttt{mime} type.

(By default, this is determined automatically by the existence of the corresponding \hyperlink{14071376285304310153}{\texttt{show}} method for \texttt{typeof(x)}.  Some types provide custom \texttt{showable} methods; for example, if the available MIME formats depend on the \emph{value} of \texttt{x}.)

\textbf{Examples}


\begin{minted}{jlcon}
julia> showable(MIME("text/plain"), rand(5))
true

julia> showable("img/png", rand(5))
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L57-L75}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13076889230390082034}{} 
\hyperlink{13076889230390082034}{\texttt{Base.repr}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
repr(mime, x; context=nothing)
\end{minted}

Returns an \texttt{AbstractString} or \texttt{Vector\{UInt8\}} containing the representation of \texttt{x} in the requested \texttt{mime} type, as written by \hyperlink{552201489544217829}{\texttt{show(io, mime, x)}} (throwing a \hyperlink{68769522931907606}{\texttt{MethodError}} if no appropriate \texttt{show} is available). An \texttt{AbstractString} is returned for MIME types with textual representations (such as \texttt{{\textquotedbl}text/html{\textquotedbl}} or \texttt{{\textquotedbl}application/postscript{\textquotedbl}}), whereas binary data is returned as \texttt{Vector\{UInt8\}}. (The function \texttt{istextmime(mime)} returns whether or not Julia treats a given \texttt{mime} type as text.)

The optional keyword argument \texttt{context} can be set to \texttt{:key=>value} pair or an \texttt{IO} or \hyperlink{13454403377667762339}{\texttt{IOContext}} object whose attributes are used for the I/O stream passed to \texttt{show}.

As a special case, if \texttt{x} is an \texttt{AbstractString} (for textual MIME types) or a \texttt{Vector\{UInt8\}} (for binary MIME types), the \texttt{repr} function assumes that \texttt{x} is already in the requested \texttt{mime} format and simply returns \texttt{x}. This special case does not apply to the \texttt{{\textquotedbl}text/plain{\textquotedbl}} MIME type. This is useful so that raw data can be passed to \texttt{display(m::MIME, x)}.

In particular, \texttt{repr({\textquotedbl}text/plain{\textquotedbl}, x)} is typically a {\textquotedbl}pretty-printed{\textquotedbl} version of \texttt{x} designed for human consumption.  See also \hyperlink{1022185167898104929}{\texttt{repr(x)}} to instead return a string corresponding to \hyperlink{14071376285304310153}{\texttt{show(x)}} that may be closer to how the value of \texttt{x} would be entered in Julia.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4];

julia> repr("text/plain", A)
"2×2 Array{Int64,2}:\n 1  2\n 3  4"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L111-L144}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8600147476403167481}{} 
\hyperlink{8600147476403167481}{\texttt{Base.Multimedia.MIME}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
MIME
\end{minted}

A type representing a standard internet data format. {\textquotedbl}MIME{\textquotedbl} stands for {\textquotedbl}Multipurpose Internet Mail Extensions{\textquotedbl}, since the standard was originally used to describe multimedia attachments to email messages.

A \texttt{MIME} object can be passed as the second argument to \hyperlink{14071376285304310153}{\texttt{show}} to request output in that format.

\textbf{Examples}


\begin{minted}{jlcon}
julia> show(stdout, MIME("text/plain"), "hi")
"hi"
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L16-L31}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6820226512558634039}{} 
\hyperlink{6820226512558634039}{\texttt{Base.Multimedia.@MIME\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@MIME_str
\end{minted}

A convenience macro for writing \hyperlink{8600147476403167481}{\texttt{MIME}} types, typically used when adding methods to \hyperlink{14071376285304310153}{\texttt{show}}. For example the syntax \texttt{show(io::IO, ::MIME{\textquotedbl}text/html{\textquotedbl}, x::MyType) = ...} could be used to define how to write an HTML representation of \texttt{MyType}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L34-L41}{\texttt{source}}


\end{adjustwidth}

如上面提到的，用户可以定义新的显示后端。 例如，可以在窗口显示 PNG 图片的模块可以在 Julia 中注册这个能力， 以便为有 PNG 表示的类型调用 \hyperlink{12073120410747960438}{\texttt{display(x)}} 时可以在模块窗口中自动显示图片。



In order to define a new display backend, one should first create a subtype \texttt{D} of the abstract class \hyperlink{10910270786739084548}{\texttt{AbstractDisplay}}.  Then, for each MIME type (\texttt{mime} string) that can be displayed on \texttt{D}, one should define a function \texttt{display(d::D, ::MIME{\textquotedbl}mime{\textquotedbl}, x) = ...} that displays \texttt{x} as that MIME type, usually by calling \hyperlink{552201489544217829}{\texttt{show(io, mime, x)}} or \hyperlink{13076889230390082034}{\texttt{repr(io, mime, x)}}. A \hyperlink{68769522931907606}{\texttt{MethodError}} should be thrown if \texttt{x} cannot be displayed as that MIME type; this is automatic if one calls \texttt{show} or \texttt{repr}. Finally, one should define a function \texttt{display(d::D, x)} that queries \hyperlink{17009846549175764333}{\texttt{showable(mime, x)}} for the \texttt{mime} types supported by \texttt{D} and displays the {\textquotedbl}best{\textquotedbl} one; a \texttt{MethodError} should be thrown if no supported MIME types are found for \texttt{x}.  Similarly, some subtypes may wish to override \hyperlink{3747338623378176831}{\texttt{redisplay(d::D, ...)}}. (Again, one should \texttt{import Base.display} to add new methods to \texttt{display}.) The return values of these functions are up to the implementation (since in some cases it may be useful to return a display {\textquotedbl}handle{\textquotedbl} of some type).  The display functions for \texttt{D} can then be called directly, but they can also be invoked automatically from \hyperlink{12073120410747960438}{\texttt{display(x)}} simply by pushing a new display onto the display-backend stack with:


\hypertarget{13142233867690107090}{} 
\hyperlink{13142233867690107090}{\texttt{Base.Multimedia.pushdisplay}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pushdisplay(d::AbstractDisplay)
\end{minted}

Pushes a new display \texttt{d} on top of the global display-backend stack. Calling \texttt{display(x)} or \texttt{display(mime, x)} will display \texttt{x} on the topmost compatible backend in the stack (i.e., the topmost backend that does not throw a \hyperlink{68769522931907606}{\texttt{MethodError}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L260-L266}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8186818521201126118}{} 
\hyperlink{8186818521201126118}{\texttt{Base.Multimedia.popdisplay}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
popdisplay()
popdisplay(d::AbstractDisplay)
\end{minted}

Pop the topmost backend off of the display-backend stack, or the topmost copy of \texttt{d} in the second variant.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L272-L278}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15269032442876270904}{} 
\hyperlink{15269032442876270904}{\texttt{Base.Multimedia.TextDisplay}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
TextDisplay(io::IO)
\end{minted}

Returns a \texttt{TextDisplay <: AbstractDisplay}, which displays any object as the text/plain MIME type (by default), writing the text representation to the given I/O stream. (This is how objects are printed in the Julia REPL.)



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L230-L236}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14215879795817507566}{} 
\hyperlink{14215879795817507566}{\texttt{Base.Multimedia.istextmime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
istextmime(m::MIME)
\end{minted}

Determine whether a MIME type is text data. MIME types are assumed to be binary data except for a set of types known to be text data (possibly Unicode).

\textbf{Examples}


\begin{minted}{jlcon}
julia> istextmime(MIME("text/plain"))
true

julia> istextmime(MIME("img/png"))
false
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multimedia.jl#L166-L180}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4207587152343103076}{}


\section{网络 I/O}


\hypertarget{17592092836786738289}{} 
\hyperlink{17592092836786738289}{\texttt{Base.bytesavailable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
bytesavailable(io)
\end{minted}

Return the number of bytes available for reading before a read from this stream or buffer will block.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer("JuliaLang is a GitHub organization");

julia> bytesavailable(io)
34
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L337-L349}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17463337378549787661}{} 
\hyperlink{17463337378549787661}{\texttt{Base.ntoh}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ntoh(x)
\end{minted}

Convert the endianness of a value from Network byte order (big-endian) to that used by the Host.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L531-L535}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17749829108559566344}{} 
\hyperlink{17749829108559566344}{\texttt{Base.hton}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hton(x)
\end{minted}

Convert the endianness of a value from that used by the Host to Network byte order (big-endian).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L538-L542}{\texttt{source}}


\end{adjustwidth}
\hypertarget{931615445303306874}{} 
\hyperlink{931615445303306874}{\texttt{Base.ltoh}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ltoh(x)
\end{minted}

Convert the endianness of a value from Little-endian to that used by the Host.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L545-L549}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6797011189807622497}{} 
\hyperlink{6797011189807622497}{\texttt{Base.htol}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
htol(x)
\end{minted}

Convert the endianness of a value from that used by the Host to Little-endian.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L552-L556}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15528013539058180213}{} 
\hyperlink{15528013539058180213}{\texttt{Base.ENDIAN\_BOM}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ENDIAN_BOM
\end{minted}

The 32-bit byte-order-mark indicates the native byte order of the host machine. Little-endian machines will contain the value \texttt{0x04030201}. Big-endian machines will contain the value \texttt{0x01020304}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/io.jl#L522-L528}{\texttt{source}}


\end{adjustwidth}

\hypertarget{6778474211430286926}{}


\chapter{运算符与记号}



数学符号与函数的扩展文档在 \hyperlink{15384328882825997796}{这里}.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
符号 & 含义 \\
\hline
\texttt{@m} & the at-symbol invokes \hyperlink{5127151953463206825}{macro} \texttt{m}; followed by space-separated expressions or a function-call-like argument list \\
\hline
\hyperlink{4329035214952292986}{\texttt{!}} & an exclamation mark is a prefix operator for logical negation ({\textquotedbl}not{\textquotedbl}) \\
\hline
\texttt{a!} & function names that end with an exclamation mark modify one or more of their arguments by convention \\
\hline
\texttt{\#} & the number sign (or hash or pound) character begins single line comments \\
\hline
\texttt{\#=} & when followed by an equals sign, it begins a multi-line comment (these are nestable) \\
\hline
\texttt{=\#} & end a multi-line comment by immediately preceding the number sign with an equals sign \\
\hline
\texttt{\$} & the dollar sign is used for \hyperlink{4452850363638134205}{string} and \hyperlink{2110612885536688224}{expression} interpolation \\
\hline
\hyperlink{3827563084771191385}{\texttt{\%}} & the percent symbol is the remainder operator \\
\hline
\hyperlink{462277561264792021}{\texttt{{\textasciicircum}}} & the caret is the exponentiation operator. \\
\hline
\hyperlink{1494761116451616317}{\texttt{\&}} & single ampersand is bitwise and \\
\hline
\hyperlink{4714012140247170866}{\texttt{\&\&}} & double ampersands is short-circuiting boolean and \\
\hline
\hyperlink{9633687763646488853}{\texttt{|}} & single pipe character is bitwise or \\
\hline
\hyperlink{2053797086840563251}{\texttt{||}} & double pipe characters is short-circuiting boolean or \\
\hline
\hyperlink{7071880015536674935}{\texttt{\unicodeveebar{}}} & the unicode xor character is bitwise exclusive or \\
\hline
\hyperlink{2433030275488323500}{\texttt{{\textasciitilde}}} & the tilde is an operator for bitwise not \\
\hline
\texttt{{\textquotesingle}} & a trailing apostrophe is the \hyperlink{10565518144285607255}{\texttt{adjoint}} (that is, the complex transpose) operator Aᴴ \\
\hline
\hyperlink{7592762607639177347}{\texttt{*}} & the asterisk is used for multiplication, including matrix multiplication and \hyperlink{12933998460683957945}{string concatenation} \\
\hline
\hyperlink{4103478871488785445}{\texttt{/}} & forward slash divides the argument on its left by the one on its right \\
\hline
\hyperlink{4639577998029770435}{\texttt{{\textbackslash}}} & backslash operator divides the argument on its right by the one on its left, commonly used to solve matrix equations \\
\hline
\texttt{()} & parentheses with no arguments constructs an empty \hyperlink{17462354060312563026}{\texttt{Tuple}} \\
\hline
\texttt{(a,...)} & parentheses with comma-separated arguments constructs a tuple containing its arguments \\
\hline
\texttt{(a=1,...)} & parentheses with comma-separated assignments constructs a \hyperlink{3845731488275720657}{\texttt{NamedTuple}} \\
\hline
\texttt{(x;y)} & parentheses can also be used to group one or more semicolon separated expressions \\
\hline
\texttt{a[]} & \hyperlink{16717190941363337071}{array indexing} (calling \hyperlink{13720608614876840481}{\texttt{getindex}} or \hyperlink{1309244355901386657}{\texttt{setindex!}}) \\
\hline
\texttt{[,]} & \hyperlink{13961675686342166416}{vector literal constructor} (calling \hyperlink{2932104842023453623}{\texttt{vect}}) \\
\hline
\texttt{[;]} & \hyperlink{7211239115857068032}{vertical concatenation} (calling \hyperlink{14691815416955507876}{\texttt{vcat}} or \hyperlink{16279083053557795116}{\texttt{hvcat}}) \\
\hline
\texttt{[    ]} & with space-separated expressions, \hyperlink{12933998460683957945}{horizontal concatenation} (calling \hyperlink{8862791894748483563}{\texttt{hcat}} or \hyperlink{16279083053557795116}{\texttt{hvcat}}) \\
\hline
\texttt{T\{ \}} & curly braces following a type list that type{\textquotesingle}s \href{@ref Parametric-Types}{parameters} \\
\hline
\texttt{\{\}} & curly braces can also be used to group multiple \hyperlink{7395867868929900722}{\texttt{where}} expressions in function declarations \\
\hline
\texttt{;} & semicolons separate statements, begin a list of keyword arguments in function declarations or calls, or are used to separate array literals for vertical concatenation \\
\hline
\texttt{,} & commas separate function arguments or tuple or array components \\
\hline
\texttt{?} & the question mark delimits the ternary conditional operator (used like: \texttt{conditional ? if\_true : if\_false}) \\
\hline
\texttt{{\textquotedbl} {\textquotedbl}} & the single double-quote character delimits \hyperlink{2825695355940841177}{\texttt{String}} literals \\
\hline
\texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl} {\textquotedbl}{\textquotedbl}{\textquotedbl}} & three double-quote characters delimits string literals that may contain \texttt{{\textquotedbl}} and ignore leading indentation \\
\hline
\texttt{{\textquotesingle} {\textquotesingle}} & the single-quote character delimits \hyperlink{3463806064296245385}{\texttt{Char}} (that is, character) literals \\
\hline
\texttt{` `} & the backtick character delimits \href{@ref Running-External-Programs}{external process} (\hyperlink{10541952265148699805}{\texttt{Cmd}}) literals \\
\hline
\texttt{A...} & triple periods are a postfix operator that {\textquotedbl}splat{\textquotedbl} their arguments{\textquotesingle} contents into many arguments of a function call or declare a varargs function that {\textquotedbl}slurps{\textquotedbl} up many arguments into a single tuple \\
\hline
\texttt{a.b} & single periods access named fields in objects/modules (calling \hyperlink{11040282462516403506}{\texttt{getproperty}} or \hyperlink{9055518433069578344}{\texttt{setproperty!}}) \\
\hline
\texttt{f.()} & periods may also prefix parentheses (like \texttt{f.(...)}) or infix operators (like \texttt{.+}) to perform the function element-wise (calling \hyperlink{616124539803111168}{\texttt{broadcast}}) \\
\hline
\texttt{a:b} & colons (\hyperlink{1027906901078185239}{\texttt{:}}) used as a binary infix operator construct a range from \texttt{a} to \texttt{b} (inclusive) with fixed step size \texttt{1} \\
\hline
\texttt{a:s:b} & colons (\hyperlink{1027906901078185239}{\texttt{:}}) used as a ternary infix operator construct a range from \texttt{a} to \texttt{b} (inclusive) with step size \texttt{s} \\
\hline
\texttt{:} & when used by themselves, \hyperlink{13649361117037263099}{\texttt{Colon}}s represent all indices within a dimension, frequently combined with \hyperlink{16717190941363337071}{indexing} \\
\hline
\texttt{::} & double-colons represent a type annotation or \hyperlink{11044636010338290257}{\texttt{typeassert}}, depending on context, frequently used when declaring function arguments \\
\hline
\texttt{:( )} & quoted expression \\
\hline
\texttt{:a} & \hyperlink{18332791376992528422}{\texttt{Symbol}} a \\
\hline
\hyperlink{6254591906563366276}{\texttt{<:}} & subtype operator \\
\hline
\hyperlink{13074915255343859584}{\texttt{>:}} & supertype operator (reverse of subtype operator) \\
\hline
\texttt{=} & single equals sign is \hyperlink{5717755217131708382}{assignment} \\
\hline
\hyperlink{15143149452920304570}{\texttt{==}} & double equals sign is value equality comparison \\
\hline
\hyperlink{7974744969331231272}{\texttt{===}} & triple equals sign is programmatically identical equality comparison. \\
\hline
\end{tabulary}

\end{table}



\hypertarget{18182954167110420496}{}


\chapter{排序及相关函数}



Julia 拥有为数众多的灵活的 API，用于对已经排序的值数组进行排序和交互。默认情况下，Julia 会选择合理的算法并按标准升序进行排序：




\begin{minted}{jlcon}
julia> sort([2,3,1])
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



你同样可以轻松实现逆序排序：




\begin{minted}{jlcon}
julia> sort([2,3,1], rev=true)
3-element Array{Int64,1}:
 3
 2
 1
\end{minted}



对数组进行 in-place 排序时，要使用 \texttt{!} 版的排序函数：




\begin{minted}{jlcon}
julia> a = [2,3,1];

julia> sort!(a);

julia> a
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



你可以计算用于排列的索引，而不是直接对数组进行排序：




\begin{minted}{jlcon}
julia> v = randn(5)
5-element Array{Float64,1}:
  0.297288
  0.382396
 -0.597634
 -0.0104452
 -0.839027

julia> p = sortperm(v)
5-element Array{Int64,1}:
 5
 3
 4
 1
 2

julia> v[p]
5-element Array{Float64,1}:
 -0.839027
 -0.597634
 -0.0104452
  0.297288
  0.382396
\end{minted}



数组可以根据对其值任意的转换结果来进行排序；




\begin{minted}{jlcon}
julia> sort(v, by=abs)
5-element Array{Float64,1}:
 -0.0104452
  0.297288
  0.382396
 -0.597634
 -0.839027
\end{minted}



或者通过转换来进行逆序排序




\begin{minted}{jlcon}
julia> sort(v, by=abs, rev=true)
5-element Array{Float64,1}:
 -0.839027
 -0.597634
  0.382396
  0.297288
 -0.0104452
\end{minted}



如有必要，可以选择排序算法：




\begin{minted}{jlcon}
julia> sort(v, alg=InsertionSort)
5-element Array{Float64,1}:
 -0.839027
 -0.597634
 -0.0104452
  0.297288
  0.382396
\end{minted}



所有与排序和顺序相关的函数依赖于“小于”关系，该关系定义了要操纵的值的总顺序。默认情况下会调用 \texttt{isless} 函数，但可以通过 \texttt{lt} 关键字指定关系。



\hypertarget{4871241370828313347}{}


\section{排序函数}


\hypertarget{12296873681374954808}{} 
\hyperlink{12296873681374954808}{\texttt{Base.sort!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sort!(v; alg::Algorithm=defalg(v), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)
\end{minted}

Sort the vector \texttt{v} in place. \hyperlink{3128942217888095342}{\texttt{QuickSort}} is used by default for numeric arrays while \hyperlink{15702510047226101978}{\texttt{MergeSort}} is used for other arrays. You can specify an algorithm to use via the \texttt{alg} keyword (see \href{@ref}{Sorting Algorithms} for available algorithms). The \texttt{by} keyword lets you provide a function that will be applied to each element before comparison; the \texttt{lt} keyword allows providing a custom {\textquotedbl}less than{\textquotedbl} function; use \texttt{rev=true} to reverse the sorting order. These options are independent and can be used together in all possible combinations: if both \texttt{by} and \texttt{lt} are specified, the \texttt{lt} function is applied to the result of the \texttt{by} function; \texttt{rev=true} reverses whatever ordering specified via the \texttt{by} and \texttt{lt} keywords.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [3, 1, 2]; sort!(v); v
3-element Array{Int64,1}:
 1
 2
 3

julia> v = [3, 1, 2]; sort!(v, rev = true); v
3-element Array{Int64,1}:
 3
 2
 1

julia> v = [(1, "c"), (3, "a"), (2, "b")]; sort!(v, by = x -> x[1]); v
3-element Array{Tuple{Int64,String},1}:
 (1, "c")
 (2, "b")
 (3, "a")

julia> v = [(1, "c"), (3, "a"), (2, "b")]; sort!(v, by = x -> x[2]); v
3-element Array{Tuple{Int64,String},1}:
 (3, "a")
 (2, "b")
 (1, "c")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L658-L696}{\texttt{source}}



\begin{lstlisting}
sort!(A; dims::Integer, alg::Algorithm=defalg(A), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)
\end{lstlisting}

Sort the multidimensional array \texttt{A} along dimension \texttt{dims}. See \hyperlink{12296873681374954808}{\texttt{sort!}} for a description of possible keyword arguments.

To sort slices of an array, refer to \hyperlink{16302460085412736163}{\texttt{sortslices}}.

\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4 3; 1 2]
2×2 Array{Int64,2}:
 4  3
 1  2

julia> sort!(A, dims = 1); A
2×2 Array{Int64,2}:
 1  2
 4  3

julia> sort!(A, dims = 2); A
2×2 Array{Int64,2}:
 1  2
 3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L1052-L1080}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8473525809131227606}{} 
\hyperlink{8473525809131227606}{\texttt{Base.sort}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sort(v; alg::Algorithm=defalg(v), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)
\end{minted}

Variant of \hyperlink{12296873681374954808}{\texttt{sort!}} that returns a sorted copy of \texttt{v} leaving \texttt{v} itself unmodified.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [3, 1, 2];

julia> sort(v)
3-element Array{Int64,1}:
 1
 2
 3

julia> v
3-element Array{Int64,1}:
 3
 1
 2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L741-L762}{\texttt{source}}



\begin{lstlisting}
sort(A; dims::Integer, alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)
\end{lstlisting}

Sort a multidimensional array \texttt{A} along the given dimension. See \hyperlink{12296873681374954808}{\texttt{sort!}} for a description of possible keyword arguments.

To sort slices of an array, refer to \hyperlink{16302460085412736163}{\texttt{sortslices}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4 3; 1 2]
2×2 Array{Int64,2}:
 4  3
 1  2

julia> sort(A, dims = 1)
2×2 Array{Int64,2}:
 1  2
 4  3

julia> sort(A, dims = 2)
2×2 Array{Int64,2}:
 3  4
 1  2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L994-L1020}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17035770587913381438}{} 
\hyperlink{17035770587913381438}{\texttt{Base.sortperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sortperm(v; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)
\end{minted}

Return a permutation vector \texttt{I} that puts \texttt{v[I]} in sorted order. The order is specified using the same keywords as \hyperlink{12296873681374954808}{\texttt{sort!}}. The permutation is guaranteed to be stable even if the sorting algorithm is unstable, meaning that indices of equal elements appear in ascending order.

See also \hyperlink{9803303601105416895}{\texttt{sortperm!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [3, 1, 2];

julia> p = sortperm(v)
3-element Array{Int64,1}:
 2
 3
 1

julia> v[p]
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L871-L897}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6009222092275543960}{} 
\hyperlink{6009222092275543960}{\texttt{Base.Sort.InsertionSort}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
InsertionSort
\end{minted}

Indicate that a sorting function should use the insertion sort algorithm. Insertion sort traverses the collection one element at a time, inserting each element into its correct, sorted position in the output list.

Characteristics:

\begin{itemize}
\item \emph{stable}: preserves the ordering of elements which compare equal (e.g. {\textquotedbl}a{\textquotedbl} and {\textquotedbl}A{\textquotedbl} in a sort of letters which ignores case).


\item \emph{in-place} in memory.


\item \emph{quadratic performance} in the number of elements to be sorted: it is well-suited to small collections but should not be used for large ones.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L420-L435}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15702510047226101978}{} 
\hyperlink{15702510047226101978}{\texttt{Base.Sort.MergeSort}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
MergeSort
\end{minted}

Indicate that a sorting function should use the merge sort algorithm. Merge sort divides the collection into subcollections and repeatedly merges them, sorting each subcollection at each step, until the entire collection has been recombined in sorted form.

Characteristics:

\begin{itemize}
\item \emph{stable}: preserves the ordering of elements which compare equal (e.g. {\textquotedbl}a{\textquotedbl} and {\textquotedbl}A{\textquotedbl} in a sort of letters which ignores case).


\item \emph{not in-place} in memory.


\item \emph{divide-and-conquer} sort strategy.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L452-L467}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3128942217888095342}{} 
\hyperlink{3128942217888095342}{\texttt{Base.Sort.QuickSort}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
QuickSort
\end{minted}

Indicate that a sorting function should use the quick sort algorithm, which is \emph{not} stable.

Characteristics:

\begin{itemize}
\item \emph{not stable}: does not preserve the ordering of elements which compare equal (e.g. {\textquotedbl}a{\textquotedbl} and {\textquotedbl}A{\textquotedbl} in a sort of letters which ignores case).


\item \emph{in-place} in memory.


\item \emph{divide-and-conquer}: sort strategy similar to \hyperlink{15702510047226101978}{\texttt{MergeSort}}.


\item \emph{good performance} for large collections.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L437-L450}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9221207223457135076}{} 
\hyperlink{9221207223457135076}{\texttt{Base.Sort.PartialQuickSort}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
PartialQuickSort{T <: Union{Integer,OrdinalRange}}
\end{minted}

Indicate that a sorting function should use the partial quick sort algorithm. Partial quick sort returns the smallest \texttt{k} elements sorted from smallest to largest, finding them and sorting them using \hyperlink{3128942217888095342}{\texttt{QuickSort}}.

Characteristics:

\begin{itemize}
\item \emph{not stable}: does not preserve the ordering of elements which compare equal (e.g. {\textquotedbl}a{\textquotedbl} and {\textquotedbl}A{\textquotedbl} in a sort of letters which ignores case).


\item \emph{in-place} in memory.


\item \emph{divide-and-conquer}: sort strategy similar to \hyperlink{15702510047226101978}{\texttt{MergeSort}}.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L401-L414}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9803303601105416895}{} 
\hyperlink{9803303601105416895}{\texttt{Base.Sort.sortperm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sortperm!(ix, v; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward, initialized::Bool=false)
\end{minted}

Like \hyperlink{17035770587913381438}{\texttt{sortperm}}, but accepts a preallocated index vector \texttt{ix}.  If \texttt{initialized} is \texttt{false} (the default), \texttt{ix} is initialized to contain the values \texttt{1:length(v)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [3, 1, 2]; p = zeros(Int, 3);

julia> sortperm!(p, v); p
3-element Array{Int64,1}:
 2
 3
 1

julia> v[p]
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L925-L947}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16302460085412736163}{} 
\hyperlink{16302460085412736163}{\texttt{Base.sortslices}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sortslices(A; dims, alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)
\end{minted}

Sort slices of an array \texttt{A}. The required keyword argument \texttt{dims} must be either an integer or a tuple of integers. It specifies the dimension(s) over which the slices are sorted.

E.g., if \texttt{A} is a matrix, \texttt{dims=1} will sort rows, \texttt{dims=2} will sort columns. Note that the default comparison function on one dimensional slices sorts lexicographically.

For the remaining keyword arguments, see the documentation of \hyperlink{12296873681374954808}{\texttt{sort!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1) # Sort rows
3×3 Array{Int64,2}:
 -1   6  4
  7   3  5
  9  -2  8

julia> sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1, lt=(x,y)->isless(x[2],y[2]))
3×3 Array{Int64,2}:
  9  -2  8
  7   3  5
 -1   6  4

julia> sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1, rev=true)
3×3 Array{Int64,2}:
  9  -2  8
  7   3  5
 -1   6  4

julia> sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2) # Sort columns
3×3 Array{Int64,2}:
  3   5  7
 -1  -4  6
 -2   8  9

julia> sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2, alg=InsertionSort, lt=(x,y)->isless(x[2],y[2]))
3×3 Array{Int64,2}:
  5   3  7
 -4  -1  6
  8  -2  9

julia> sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2, rev=true)
3×3 Array{Int64,2}:
 7   5   3
 6  -4  -1
 9   8  -2
\end{minted}

\textbf{Higher dimensions}

\texttt{sortslices} extends naturally to higher dimensions. E.g., if \texttt{A} is a a 2x2x2 array, \texttt{sortslices(A, dims=3)} will sort slices within the 3rd dimension, passing the 2x2 slices \texttt{A[:, :, 1]} and \texttt{A[:, :, 2]} to the comparison function. Note that while there is no default order on higher-dimensional slices, you may use the \texttt{by} or \texttt{lt} keyword argument to specify such an order.

If \texttt{dims} is a tuple, the order of the dimensions in \texttt{dims} is relevant and specifies the linear order of the slices. E.g., if \texttt{A} is three dimensional and \texttt{dims} is \texttt{(1, 2)}, the orderings of the first two dimensions are re-arranged such such that the slices (of the remaining third dimension) are sorted. If \texttt{dims} is \texttt{(2, 1)} instead, the same slices will be taken, but the result order will be row-major instead.

\textbf{Higher dimensional examples}


\begin{lstlisting}
julia> A = permutedims(reshape([4 3; 2 1; 'A' 'B'; 'C' 'D'], (2, 2, 2)), (1, 3, 2))
2×2×2 Array{Any,3}:
[:, :, 1] =
 4  3
 2  1

[:, :, 2] =
 'A'  'B'
 'C'  'D'

julia> sortslices(A, dims=(1,2))
2×2×2 Array{Any,3}:
[:, :, 1] =
 1  3
 2  4

[:, :, 2] =
 'D'  'B'
 'C'  'A'

julia> sortslices(A, dims=(2,1))
2×2×2 Array{Any,3}:
[:, :, 1] =
 1  2
 3  4

[:, :, 2] =
 'D'  'C'
 'B'  'A'

julia> sortslices(reshape([5; 4; 3; 2; 1], (1,1,5)), dims=3, by=x->x[1,1])
1×1×5 Array{Int64,3}:
[:, :, 1] =
 1

[:, :, 2] =
 2

[:, :, 3] =
 3

[:, :, 4] =
 4

[:, :, 5] =
 5
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L1650-L1766}{\texttt{source}}


\end{adjustwidth}

\hypertarget{12039042665737142654}{}


\section{排列顺序相关的函数}


\hypertarget{16696594531893143583}{} 
\hyperlink{16696594531893143583}{\texttt{Base.issorted}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issorted(v, lt=isless, by=identity, rev:Bool=false, order::Ordering=Forward)
\end{minted}

Test whether a vector is in sorted order. The \texttt{lt}, \texttt{by} and \texttt{rev} keywords modify what order is considered to be sorted just as they do for \hyperlink{8473525809131227606}{\texttt{sort}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> issorted([1, 2, 3])
true

julia> issorted([(1, "b"), (2, "a")], by = x -> x[1])
true

julia> issorted([(1, "b"), (2, "a")], by = x -> x[2])
false

julia> issorted([(1, "b"), (2, "a")], by = x -> x[2], rev=true)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L69-L89}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17287969759719368562}{} 
\hyperlink{17287969759719368562}{\texttt{Base.Sort.searchsorted}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
searchsorted(a, x; by=<transform>, lt=<comparison>, rev=false)
\end{minted}

Return the range of indices of \texttt{a} which compare as equal to \texttt{x} (using binary search) according to the order specified by the \texttt{by}, \texttt{lt} and \texttt{rev} keywords, assuming that \texttt{a} is already sorted in that order. Return an empty range located at the insertion point if \texttt{a} does not contain values equal to \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> searchsorted([1, 2, 4, 5, 5, 7], 4) # single match
3:3

julia> searchsorted([1, 2, 4, 5, 5, 7], 5) # multiple matches
4:5

julia> searchsorted([1, 2, 4, 5, 5, 7], 3) # no match, insert in the middle
3:2

julia> searchsorted([1, 2, 4, 5, 5, 7], 9) # no match, insert at end
7:6

julia> searchsorted([1, 2, 4, 5, 5, 7], 0) # no match, insert at start
1:0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L313-L338}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12786822915971523090}{} 
\hyperlink{12786822915971523090}{\texttt{Base.Sort.searchsortedfirst}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
searchsortedfirst(a, x; by=<transform>, lt=<comparison>, rev=false)
\end{minted}

Return the index of the first value in \texttt{a} greater than or equal to \texttt{x}, according to the specified order. Return \texttt{length(a) + 1} if \texttt{x} is greater than all values in \texttt{a}. \texttt{a} is assumed to be sorted.

\textbf{Examples}


\begin{minted}{jlcon}
julia> searchsortedfirst([1, 2, 4, 5, 5, 7], 4) # single match
3

julia> searchsortedfirst([1, 2, 4, 5, 5, 7], 5) # multiple matches
4

julia> searchsortedfirst([1, 2, 4, 5, 5, 7], 3) # no match, insert in the middle
3

julia> searchsortedfirst([1, 2, 4, 5, 5, 7], 9) # no match, insert at end
7

julia> searchsortedfirst([1, 2, 4, 5, 5, 7], 0) # no match, insert at start
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L340-L364}{\texttt{source}}


\end{adjustwidth}
\hypertarget{572230519808649943}{} 
\hyperlink{572230519808649943}{\texttt{Base.Sort.searchsortedlast}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
searchsortedlast(a, x; by=<transform>, lt=<comparison>, rev=false)
\end{minted}

Return the index of the last value in \texttt{a} less than or equal to \texttt{x}, according to the specified order. Return \texttt{0} if \texttt{x} is less than all values in \texttt{a}. \texttt{a} is assumed to be sorted.

\textbf{Examples}


\begin{minted}{jlcon}
julia> searchsortedlast([1, 2, 4, 5, 5, 7], 4) # single match
3

julia> searchsortedlast([1, 2, 4, 5, 5, 7], 5) # multiple matches
5

julia> searchsortedlast([1, 2, 4, 5, 5, 7], 3) # no match, insert in the middle
2

julia> searchsortedlast([1, 2, 4, 5, 5, 7], 9) # no match, insert at end
6

julia> searchsortedlast([1, 2, 4, 5, 5, 7], 0) # no match, insert at start
0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L366-L390}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1055038474257484236}{} 
\hyperlink{1055038474257484236}{\texttt{Base.Sort.partialsort!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
partialsort!(v, k; by=<transform>, lt=<comparison>, rev=false)
\end{minted}

Partially sort the vector \texttt{v} in place, according to the order specified by \texttt{by}, \texttt{lt} and \texttt{rev} so that the value at index \texttt{k} (or range of adjacent values if \texttt{k} is a range) occurs at the position where it would appear if the array were fully sorted via a non-stable algorithm. If \texttt{k} is a single index, that value is returned; if \texttt{k} is a range, an array of values at those indices is returned. Note that \texttt{partialsort!} does not fully sort the input array.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1, 2, 4, 3, 4]
5-element Array{Int64,1}:
 1
 2
 4
 3
 4

julia> partialsort!(a, 4)
4

julia> a
5-element Array{Int64,1}:
 1
 2
 3
 4
 4

julia> a = [1, 2, 4, 3, 4]
5-element Array{Int64,1}:
 1
 2
 4
 3
 4

julia> partialsort!(a, 4, rev=true)
2

julia> a
5-element Array{Int64,1}:
 4
 4
 3
 2
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L103-L153}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16583557202403194142}{} 
\hyperlink{16583557202403194142}{\texttt{Base.Sort.partialsort}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
partialsort(v, k, by=<transform>, lt=<comparison>, rev=false)
\end{minted}

Variant of \hyperlink{1055038474257484236}{\texttt{partialsort!}} which copies \texttt{v} before partially sorting it, thereby returning the same thing as \texttt{partialsort!} but leaving \texttt{v} unmodified.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L158-L163}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1642559230838768770}{} 
\hyperlink{1642559230838768770}{\texttt{Base.Sort.partialsortperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
partialsortperm(v, k; by=<transform>, lt=<comparison>, rev=false)
\end{minted}

Return a partial permutation \texttt{I} of the vector \texttt{v}, so that \texttt{v[I]} returns values of a fully sorted version of \texttt{v} at index \texttt{k}. If \texttt{k} is a range, a vector of indices is returned; if \texttt{k} is an integer, a single index is returned. The order is specified using the same keywords as \texttt{sort!}. The permutation is stable, meaning that indices of equal elements appear in ascending order.

Note that this function is equivalent to, but more efficient than, calling \texttt{sortperm(...)[k]}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [3, 1, 2, 1];

julia> v[partialsortperm(v, 1)]
1

julia> p = partialsortperm(v, 1:3)
3-element view(::Array{Int64,1}, 1:3) with eltype Int64:
 2
 4
 3

julia> v[p]
3-element Array{Int64,1}:
 1
 1
 2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L767-L797}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15860704871012966363}{} 
\hyperlink{15860704871012966363}{\texttt{Base.Sort.partialsortperm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
partialsortperm!(ix, v, k; by=<transform>, lt=<comparison>, rev=false, initialized=false)
\end{minted}

Like \hyperlink{1642559230838768770}{\texttt{partialsortperm}}, but accepts a preallocated index vector \texttt{ix} the same size as \texttt{v}, which is used to store (a permutation of) the indices of \texttt{v}.

If the index vector \texttt{ix} is initialized with the indices of \texttt{v} (or a permutation thereof), \texttt{initialized} should be set to \texttt{true}.

If \texttt{initialized} is \texttt{false} (the default), then \texttt{ix} is initialized to contain the indices of \texttt{v}.

If \texttt{initialized} is \texttt{true}, but \texttt{ix} does not contain (a permutation of) the indices of \texttt{v}, the behavior of \texttt{partialsortperm!} is undefined.

(Typically, the indices of \texttt{v} will be \texttt{1:length(v)}, although if \texttt{v} has an alternative array type with non-one-based indices, such as an \texttt{OffsetArray}, \texttt{ix} must also be an \texttt{OffsetArray} with the same indices, and must contain as values (a permutation of) these same indices.)

Upon return, \texttt{ix} is guaranteed to have the indices \texttt{k} in their sorted positions, such that


\begin{minted}{julia}
partialsortperm!(ix, v, k);
v[ix[k]] == partialsort(v, k)
\end{minted}

The return value is the \texttt{k}th element of \texttt{ix} if \texttt{k} is an integer, or view into \texttt{ix} if \texttt{k} is a range.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [3, 1, 2, 1];

julia> ix = Vector{Int}(undef, 4);

julia> partialsortperm!(ix, v, 1)
2

julia> ix = [1:4;];

julia> partialsortperm!(ix, v, 2:3, initialized=true)
2-element view(::Array{Int64,1}, 2:3) with eltype Int64:
 4
 3
\end{minted}


\begin{lstlisting}

\end{lstlisting}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/sort.jl#L801-L845}{\texttt{source}}


\end{adjustwidth}

\hypertarget{16771045260393095482}{}


\section{排序算法}



目前，Julia Base 中有四种可用的排序算法：



\begin{itemize}
\item \hyperlink{6009222092275543960}{\texttt{InsertionSort}}


\item \hyperlink{3128942217888095342}{\texttt{QuickSort}}


\item \hyperlink{9221207223457135076}{\texttt{PartialQuickSort(k)}}


\item \hyperlink{15702510047226101978}{\texttt{MergeSort}}

\end{itemize}


\texttt{InsertionSort} 是一个在 \texttt{QuickSort} 中使用的时间复杂度为 O(n{\textasciicircum}2) 的稳定的排序算法，它通常在 \texttt{n} 比较小的时候才具有较高的效率。



\texttt{QuickSort} 是一个内置并且非常快，但是不稳定的时间复杂度为 O(n log n）的排序算法，例如即使数组两个元素相等的，它们排序之后的顺序也可能和在原数组中顺序不一致。\texttt{QuickSort} 是内置的包括整数和浮点数在内的数字值的默认排序算法。



\texttt{PartialQuickSort(k)} 类似于 \texttt{QuickSort}，但是如果 \texttt{k} 是一个整数，输出数组只排序到索引 \texttt{k}，如果 \texttt{k} 是 \texttt{OrdinalRange}，则输出数组排在 \texttt{k} 范围内。 例如：




\begin{minted}{julia}
x = rand(1:500, 100)
k = 50
k2 = 50:100
s = sort(x; alg=QuickSort)
ps = sort(x; alg=PartialQuickSort(k))
qs = sort(x; alg=PartialQuickSort(k2))
map(issorted, (s, ps, qs))             # => (true, false, false)
map(x->issorted(x[1:k]), (s, ps, qs))  # => (true, true, false)
map(x->issorted(x[k2]), (s, ps, qs))   # => (true, false, true)
s[1:k] == ps[1:k]                      # => true
s[k2] == qs[k2]                        # => true
\end{minted}



\texttt{MergeSort} 是一个时间复杂度为 O(n log n) 的稳定但是非 in-place 的算法，它需要一个大小为输入数组一般的临时数组——同时也不像 \texttt{QuickSort} 一样快。\texttt{MergeSort} 是非数值型数据的默认排序算法。



默认排序算法的选择是基于它们的快速稳定，或者 \emph{appear} 之类的。对于数值类型，实际上选择了 \texttt{QuickSort}，因为在这种情况下，它更快，与稳定排序没有区别(除非数组以某种方式记录了突变)



Julia选择默认排序算法的机制是通过 \texttt{Base.Sort.defalg} 来实现的，其允许将特定算法注册为特定数组的所有排序函数中的默认值。例如，这有两个默认算法 \href{https://github.com/JuliaLang/julia/blob/master/base/sort.jl}{\texttt{sort.jl}}:




\begin{minted}{julia}
defalg(v::AbstractArray) = MergeSort
defalg(v::AbstractArray{<:Number}) = QuickSort
\end{minted}



对于数值型数组，选择非稳定的默认排序算法的原则是稳定的排序算法没有必要的（例如：但两个值相比较时相等且不可区分时）。



\hypertarget{17136071574841524151}{}


\chapter{迭代相关}


\hypertarget{6781886173930121818}{} 
\hyperlink{6781886173930121818}{\texttt{Base.Iterators.Stateful}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Stateful(itr)
\end{minted}

There are several different ways to think about this iterator wrapper:

\begin{itemize}
\item[1. ] It provides a mutable wrapper around an iterator and its iteration state.


\item[2. ] It turns an iterator-like abstraction into a \texttt{Channel}-like abstraction.


\item[3. ] It{\textquotesingle}s an iterator that mutates to become its own rest iterator whenever an item is produced.

\end{itemize}
\texttt{Stateful} provides the regular iterator interface. Like other mutable iterators (e.g. \hyperlink{12548845729684045604}{\texttt{Channel}}), if iteration is stopped early (e.g. by a \hyperlink{6474422097180568887}{\texttt{break}} in a \hyperlink{9105224580875818383}{\texttt{for}} loop), iteration can be resumed from the same spot by continuing to iterate over the same iterator object (in contrast, an immutable iterator would restart from the beginning).

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = Iterators.Stateful("abcdef");

julia> isempty(a)
false

julia> popfirst!(a)
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)

julia> collect(Iterators.take(a, 3))
3-element Array{Char,1}:
 'b'
 'c'
 'd'

julia> collect(a)
2-element Array{Char,1}:
 'e'
 'f'
\end{minted}


\begin{minted}{jlcon}
julia> a = Iterators.Stateful([1,1,1,2,3,4]);

julia> for x in a; x == 1 || break; end

julia> Base.peek(a)
3

julia> sum(a) # Sum the remaining elements
7
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L1151-L1202}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11836366300100000234}{} 
\hyperlink{11836366300100000234}{\texttt{Base.Iterators.zip}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
zip(iters...)
\end{minted}

Run multiple iterators at the same time, until any of them is exhausted. The value type of the \texttt{zip} iterator is a tuple of values of its subiterators.

\begin{quote}
\textbf{Note}

\texttt{zip} orders the calls to its subiterators in such a way that stateful iterators will not advance when another iterator finishes in the current iteration.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> a = 1:5
1:5

julia> b = ["e","d","b","c","a"]
5-element Array{String,1}:
 "e"
 "d"
 "b"
 "c"
 "a"

julia> c = zip(a,b)
Base.Iterators.Zip{Tuple{UnitRange{Int64},Array{String,1}}}((1:5, ["e", "d", "b", "c", "a"]))

julia> length(c)
5

julia> first(c)
(1, "e")
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L267-L299}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2184606349967262519}{} 
\hyperlink{2184606349967262519}{\texttt{Base.Iterators.enumerate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
enumerate(iter)
\end{minted}

An iterator that yields \texttt{(i, x)} where \texttt{i} is a counter starting at 1, and \texttt{x} is the \texttt{i}th value from the given iterator. It{\textquotesingle}s useful when you need not only the values \texttt{x} over which you are iterating, but also the number of iterations so far. Note that \texttt{i} may not be valid for indexing \texttt{iter}; it{\textquotesingle}s also possible that \texttt{x != iter[i]}, if \texttt{iter} has indices that do not start at 1. See the \texttt{pairs(IndexLinear(), iter)} method if you want to ensure that \texttt{i} is an index.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = ["a", "b", "c"];

julia> for (index, value) in enumerate(a)
           println("$index $value")
       end
1 a
2 b
3 c
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L110-L132}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3784260484755044695}{} 
\hyperlink{3784260484755044695}{\texttt{Base.Iterators.rest}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rest(iter, state)
\end{minted}

An iterator that yields the same elements as \texttt{iter}, but starting at the given \texttt{state}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> collect(Iterators.rest([1,2,3,4], 2))
3-element Array{Int64,1}:
 2
 3
 4
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L504-L517}{\texttt{source}}


\end{adjustwidth}
\hypertarget{218851424586263192}{} 
\hyperlink{218851424586263192}{\texttt{Base.Iterators.countfrom}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
countfrom(start=1, step=1)
\end{minted}

An iterator that counts forever, starting at \texttt{start} and incrementing by \texttt{step}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> for v in Iterators.countfrom(5, 2)
           v > 10 && break
           println(v)
       end
5
7
9
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L563-L578}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7844855039511634473}{} 
\hyperlink{7844855039511634473}{\texttt{Base.Iterators.take}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
take(iter, n)
\end{minted}

An iterator that generates at most the first \texttt{n} elements of \texttt{iter}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = 1:2:11
1:2:11

julia> collect(a)
6-element Array{Int64,1}:
  1
  3
  5
  7
  9
 11

julia> collect(Iterators.take(a,3))
3-element Array{Int64,1}:
 1
 3
 5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L600-L625}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6722714944255905418}{} 
\hyperlink{6722714944255905418}{\texttt{Base.Iterators.takewhile}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
takewhile(pred, iter)
\end{minted}

An iterator that generates element from \texttt{iter} as long as predicate \texttt{pred} is true, afterwards, drops every element.

\begin{quote}
\textbf{Julia 1.4}

This function requires at least Julia 1.4.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> s = collect(1:5)
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia> collect(Iterators.takewhile(<(3),s))
2-element Array{Int64,1}:
 1
 2
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L713-L738}{\texttt{source}}


\end{adjustwidth}
\hypertarget{744681231854455039}{} 
\hyperlink{744681231854455039}{\texttt{Base.Iterators.drop}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
drop(iter, n)
\end{minted}

An iterator that generates all but the first \texttt{n} elements of \texttt{iter}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = 1:2:11
1:2:11

julia> collect(a)
6-element Array{Int64,1}:
  1
  3
  5
  7
  9
 11

julia> collect(Iterators.drop(a,4))
2-element Array{Int64,1}:
  9
 11
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L657-L681}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1884086427843682212}{} 
\hyperlink{1884086427843682212}{\texttt{Base.Iterators.dropwhile}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dropwhile(pred, iter)
\end{minted}

An iterator that drops element from \texttt{iter} as long as predicate \texttt{pred} is true, afterwards, returns every element.

\begin{quote}
\textbf{Julia 1.4}

This function requires at least Julia 1.4.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> s = collect(1:5)
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia> collect(Iterators.dropwhile(<(3),s))
3-element Array{Int64,1}:
 3
 4
 5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L760-L786}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13881904186147539554}{} 
\hyperlink{13881904186147539554}{\texttt{Base.Iterators.cycle}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cycle(iter)
\end{minted}

An iterator that cycles through \texttt{iter} forever. If \texttt{iter} is empty, so is \texttt{cycle(iter)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> for (i, v) in enumerate(Iterators.cycle("hello"))
           print(v)
           i > 10 && break
       end
hellohelloh
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L810-L824}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16149631071727159175}{} 
\hyperlink{16149631071727159175}{\texttt{Base.Iterators.repeated}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
repeated(x[, n::Int])
\end{minted}

An iterator that generates the value \texttt{x} forever. If \texttt{n} is specified, generates \texttt{x} that many times (equivalent to \texttt{take(repeated(x), n)}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = Iterators.repeated([1 2], 4);

julia> collect(a)
4-element Array{Array{Int64,2},1}:
 [1 2]
 [1 2]
 [1 2]
 [1 2]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L849-L866}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12093738197940348056}{} 
\hyperlink{12093738197940348056}{\texttt{Base.Iterators.product}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
product(iters...)
\end{minted}

Return an iterator over the product of several iterators. Each generated element is a tuple whose \texttt{i}th element comes from the \texttt{i}th argument iterator. The first iterator changes the fastest.

\textbf{Examples}


\begin{minted}{jlcon}
julia> collect(Iterators.product(1:2, 3:5))
2×3 Array{Tuple{Int64,Int64},2}:
 (1, 3)  (1, 4)  (1, 5)
 (2, 3)  (2, 4)  (2, 5)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L883-L897}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6994420133663892005}{} 
\hyperlink{6994420133663892005}{\texttt{Base.Iterators.flatten}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
flatten(iter)
\end{minted}

Given an iterator that yields iterators, return an iterator that yields the elements of those iterators. Put differently, the elements of the argument iterator are concatenated.

\textbf{Examples}


\begin{minted}{jlcon}
julia> collect(Iterators.flatten((1:2, 8:9)))
4-element Array{Int64,1}:
 1
 2
 8
 9
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L1005-L1021}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16897863122939587148}{} 
\hyperlink{16897863122939587148}{\texttt{Base.Iterators.partition}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
partition(collection, n)
\end{minted}

Iterate over a collection \texttt{n} elements at a time.

\textbf{Examples}


\begin{minted}{jlcon}
julia> collect(Iterators.partition([1,2,3,4,5], 2))
3-element Array{SubArray{Int64,1,Array{Int64,1},Tuple{UnitRange{Int64}},true},1}:
 [1, 2]
 [3, 4]
 [5]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L1069-L1082}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10895775009535736865}{} 
\hyperlink{10895775009535736865}{\texttt{Base.Iterators.filter}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Iterators.filter(flt, itr)
\end{minted}

Given a predicate function \texttt{flt} and an iterable object \texttt{itr}, return an iterable object which upon iteration yields the elements \texttt{x} of \texttt{itr} that satisfy \texttt{flt(x)}. The order of the original iterator is preserved.

This function is \emph{lazy}; that is, it is guaranteed to return in  \(Θ(1)\)  time and use  \(Θ(1)\)  additional space, and \texttt{flt} will not be called by an invocation of \texttt{filter}. Calls to \texttt{flt} will be made when iterating over the returned iterable object. These calls are not cached and repeated calls will be made when reiterating.

See \hyperlink{11445961893478569145}{\texttt{Base.filter}} for an eager implementation of filtering for arrays.

\textbf{Examples}


\begin{minted}{jlcon}
julia> f = Iterators.filter(isodd, [1, 2, 3, 4, 5])
Base.Iterators.Filter{typeof(isodd),Array{Int64,1}}(isodd, [1, 2, 3, 4, 5])

julia> foreach(println, f)
1
3
5
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L399-L424}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7329463517237104739}{} 
\hyperlink{7329463517237104739}{\texttt{Base.Iterators.accumulate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Iterators.accumulate(f, itr)
\end{minted}

Given a 2-argument function \texttt{f} and an iterator \texttt{itr}, return a new iterator that successively applies \texttt{f} to the previous value and the next element of \texttt{itr}.

This is effectively a lazy version of \hyperlink{318811369799573541}{\texttt{Base.accumulate}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> f = Iterators.accumulate(+, [1,2,3,4])
Base.Iterators.Accumulate{typeof(+),Array{Int64,1}}(+, [1, 2, 3, 4])

julia> foreach(println, f)
1
3
6
10
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L451-L471}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12943296479800134710}{} 
\hyperlink{12943296479800134710}{\texttt{Base.Iterators.reverse}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Iterators.reverse(itr)
\end{minted}

Given an iterator \texttt{itr}, then \texttt{reverse(itr)} is an iterator over the same collection but in the reverse order.

This iterator is {\textquotedbl}lazy{\textquotedbl} in that it does not make a copy of the collection in order to reverse it; see \hyperlink{5598774829914682536}{\texttt{Base.reverse}} for an eager implementation.

Not all iterator types \texttt{T} support reverse-order iteration.  If \texttt{T} doesn{\textquotesingle}t, then iterating over \texttt{Iterators.reverse(itr::T)} will throw a \hyperlink{68769522931907606}{\texttt{MethodError}} because of the missing \hyperlink{1722534687975587846}{\texttt{iterate}} methods for \texttt{Iterators.Reverse\{T\}}. (To implement these methods, the original iterator \texttt{itr::T} can be obtained from \texttt{r = Iterators.reverse(itr)} by \texttt{r.itr}.)

\textbf{Examples}


\begin{minted}{jlcon}
julia> foreach(println, Iterators.reverse(1:5))
5
4
3
2
1
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L50-L74}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5308857578406686427}{} 
\hyperlink{5308857578406686427}{\texttt{Base.Iterators.only}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
only(x)
\end{minted}

Returns the one and only element of collection \texttt{x}, and throws an \texttt{ArgumentError} if the collection has zero or multiple elements.

See also: \hyperlink{10301663699427216331}{\texttt{first}}, \hyperlink{7482613677577278193}{\texttt{last}}.

\begin{quote}
\textbf{Julia 1.4}

This method requires at least Julia 1.4.

\end{quote}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L1269-L1279}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16532200500820416330}{} 
\hyperlink{16532200500820416330}{\texttt{Base.Iterators.peel}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
peel(iter)
\end{minted}

Returns the first element and an iterator over the remaining elements.

\textbf{Examples}


\begin{minted}{jlcon}
julia> (a, rest) = Iterators.peel("abc");

julia> a
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)

julia> collect(rest)
2-element Array{Char,1}:
 'b'
 'c'
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/iterators.jl#L522-L539}{\texttt{source}}


\end{adjustwidth}

\hypertarget{10594336122437775517}{}


\chapter{C 接口}


\hypertarget{14245046751182637566}{} 
\hyperlink{14245046751182637566}{\texttt{ccall}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ccall((function_name, library), returntype, (argtype1, ...), argvalue1, ...)
ccall(function_name, returntype, (argtype1, ...), argvalue1, ...)
ccall(function_pointer, returntype, (argtype1, ...), argvalue1, ...)
\end{minted}

Call a function in a C-exported shared library, specified by the tuple \texttt{(function\_name, library)}, where each component is either a string or symbol. Instead of specifying a library, one can also use a \texttt{function\_name} symbol or string, which is resolved in the current process. Alternatively, \texttt{ccall} may also be used to call a function pointer \texttt{function\_pointer}, such as one returned by \texttt{dlsym}.

Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression.

Each \texttt{argvalue} to the \texttt{ccall} will be converted to the corresponding \texttt{argtype}, by automatic insertion of calls to \texttt{unsafe\_convert(argtype, cconvert(argtype, argvalue))}. (See also the documentation for \hyperlink{6011318385865707029}{\texttt{unsafe\_convert}} and \hyperlink{16487788729383051927}{\texttt{cconvert}} for further details.) In most cases, this simply results in a call to \texttt{convert(argtype, argvalue)}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L849-L867}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2746947069730856184}{} 
\hyperlink{2746947069730856184}{\texttt{Core.Intrinsics.cglobal}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cglobal((symbol, library) [, type=Cvoid])
\end{minted}

Obtain a pointer to a global variable in a C-exported shared library, specified exactly as in \hyperlink{14245046751182637566}{\texttt{ccall}}. Returns a \texttt{Ptr\{Type\}}, defaulting to \texttt{Ptr\{Cvoid\}} if no \texttt{Type} argument is supplied. The values can be read or written by \hyperlink{13744149973765810952}{\texttt{unsafe\_load}} or \hyperlink{4579672834750013041}{\texttt{unsafe\_store!}}, respectively.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L7-L16}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11617107520401351255}{} 
\hyperlink{11617107520401351255}{\texttt{Base.@cfunction}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@cfunction(callable, ReturnType, (ArgumentTypes...,)) -> Ptr{Cvoid}
@cfunction($callable, ReturnType, (ArgumentTypes...,)) -> CFunction
\end{minted}

Generate a C-callable function pointer from the Julia function \texttt{callable} for the given type signature. To pass the return value to a \texttt{ccall}, use the argument type \texttt{Ptr\{Cvoid\}} in the signature.

Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression (although it can include a splat expression). And that these arguments will be evaluated in global scope during compile-time (not deferred until runtime). Adding a {\textquotesingle}\${\textquotesingle} in front of the function argument changes this to instead create a runtime closure over the local variable \texttt{callable} (this is not supported on all architectures).

See \href{@ref Calling-C-and-Fortran-Code}{manual section on ccall and cfunction usage}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> function foo(x::Int, y::Int)
           return x + y
       end

julia> @cfunction(foo, Int, (Int, Int))
Ptr{Cvoid} @0x000000001b82fcd0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L38-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2295032871603833153}{} 
\hyperlink{2295032871603833153}{\texttt{Base.CFunction}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
CFunction struct
\end{minted}

Garbage-collection handle for the return value from \texttt{@cfunction} when the first argument is annotated with {\textquotesingle}\${\textquotesingle}. Like all \texttt{cfunction} handles, it should be passed to \texttt{ccall} as a \texttt{Ptr\{Cvoid\}}, and will be converted automatically at the call site to the appropriate type.

See \hyperlink{11617107520401351255}{\texttt{@cfunction}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L19-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6011318385865707029}{} 
\hyperlink{6011318385865707029}{\texttt{Base.unsafe\_convert}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unsafe_convert(T, x)
\end{minted}

Convert \texttt{x} to a C argument of type \texttt{T} where the input \texttt{x} must be the return value of \texttt{cconvert(T, ...)}.

In cases where \hyperlink{1846942650946171605}{\texttt{convert}} would need to take a Julia object and turn it into a \texttt{Ptr}, this function should be used to define and perform that conversion.

Be careful to ensure that a Julia reference to \texttt{x} exists as long as the result of this function will be used. Accordingly, the argument \texttt{x} to this function should never be an expression, only a variable name or field reference. For example, \texttt{x=a.b.c} is acceptable, but \texttt{x=[a,b,c]} is not.

The \texttt{unsafe} prefix on this function indicates that using the result of this function after the \texttt{x} argument to this function is no longer accessible to the program may cause undefined behavior, including program corruption or segfaults, at any later time.

See also \hyperlink{16487788729383051927}{\texttt{cconvert}}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/pointer.jl#L34-L54}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16487788729383051927}{} 
\hyperlink{16487788729383051927}{\texttt{Base.cconvert}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cconvert(T,x)
\end{minted}

Convert \texttt{x} to a value to be passed to C code as type \texttt{T}, typically by calling \texttt{convert(T, x)}.

In cases where \texttt{x} cannot be safely converted to \texttt{T}, unlike \hyperlink{1846942650946171605}{\texttt{convert}}, \texttt{cconvert} may return an object of a type different from \texttt{T}, which however is suitable for \hyperlink{6011318385865707029}{\texttt{unsafe\_convert}} to handle. The result of this function should be kept valid (for the GC) until the result of \hyperlink{6011318385865707029}{\texttt{unsafe\_convert}} is not needed anymore. This can be used to allocate memory that will be accessed by the \texttt{ccall}. If multiple objects need to be allocated, a tuple of the objects can be used as return value.

Neither \texttt{convert} nor \texttt{cconvert} should take a Julia object and turn it into a \texttt{Ptr}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/essentials.jl#L374-L387}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13744149973765810952}{} 
\hyperlink{13744149973765810952}{\texttt{Base.unsafe\_load}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unsafe_load(p::Ptr{T}, i::Integer=1)
\end{minted}

Load a value of type \texttt{T} from the address of the \texttt{i}th element (1-indexed) starting at \texttt{p}. This is equivalent to the C expression \texttt{p[i-1]}.

The \texttt{unsafe} prefix on this function indicates that no validation is performed on the pointer \texttt{p} to ensure that it is valid. Incorrect usage may segfault your program or return garbage answers, in the same manner as C.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/pointer.jl#L95-L104}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4579672834750013041}{} 
\hyperlink{4579672834750013041}{\texttt{Base.unsafe\_store!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unsafe_store!(p::Ptr{T}, x, i::Integer=1)
\end{minted}

Store a value of type \texttt{T} to the address of the \texttt{i}th element (1-indexed) starting at \texttt{p}. This is equivalent to the C expression \texttt{p[i-1] = x}.

The \texttt{unsafe} prefix on this function indicates that no validation is performed on the pointer \texttt{p} to ensure that it is valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/pointer.jl#L107-L116}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2923048042876508667}{} 
\hyperlink{2923048042876508667}{\texttt{Base.unsafe\_copyto!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unsafe_copyto!(dest::Ptr{T}, src::Ptr{T}, N)
\end{minted}

Copy \texttt{N} elements from a source pointer to a destination, with no checking. The size of an element is determined by the type of the pointers.

The \texttt{unsafe} prefix on this function indicates that no validation is performed on the pointers \texttt{dest} and \texttt{src} to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L234-L243}{\texttt{source}}


\end{adjustwidth}
\hypertarget{151396139589158542}{} 
\hyperlink{151396139589158542}{\texttt{Base.unsafe\_copyto!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unsafe_copyto!(dest::Array, do, src::Array, so, N)
\end{minted}

Copy \texttt{N} elements from a source array to a destination, starting at offset \texttt{so} in the source and \texttt{do} in the destination (1-indexed).

The \texttt{unsafe} prefix on this function indicates that no validation is performed to ensure that N is inbounds on either array. Incorrect usage may corrupt or segfault your program, in the same manner as C.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L252-L261}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12476124489163612623}{} 
\hyperlink{12476124489163612623}{\texttt{Base.copyto!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
copyto!(dest, do, src, so, N)
\end{minted}

Copy \texttt{N} elements from collection \texttt{src} starting at offset \texttt{so}, to array \texttt{dest} starting at offset \texttt{do}. Return \texttt{dest}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/array.jl#L306-L311}{\texttt{source}}



\begin{lstlisting}
copyto!(dest::AbstractArray, src) -> dest
\end{lstlisting}

Copy all elements from collection \texttt{src} to array \texttt{dest}, whose length must be greater than or equal to the length \texttt{n} of \texttt{src}. The first \texttt{n} elements of \texttt{dest} are overwritten, the other elements are left untouched.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = [1., 0., 3., 0., 5.];

julia> y = zeros(7);

julia> copyto!(y, x);

julia> y
7-element Array{Float64,1}:
 1.0
 0.0
 3.0
 0.0
 5.0
 0.0
 0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L929-L955}{\texttt{source}}



\begin{minted}{julia}
copyto!(dest, Rdest::CartesianIndices, src, Rsrc::CartesianIndices) -> dest
\end{minted}

Copy the block of \texttt{src} in the range of \texttt{Rsrc} to the block of \texttt{dest} in the range of \texttt{Rdest}. The sizes of the two regions must match.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/multidimensional.jl#L993-L998}{\texttt{source}}



\begin{lstlisting}
copyto!(dest::AbstractMatrix, src::UniformScaling)
\end{lstlisting}

Copies a \hyperlink{723087258311673942}{\texttt{UniformScaling}} onto a matrix.

\begin{quote}
\textbf{Julia 1.1}

In Julia 1.0 this method only supported a square destination matrix. Julia 1.1. added support for a rectangular matrix.

\end{quote}


\end{adjustwidth}
\hypertarget{8901246211940014300}{} 
\hyperlink{8901246211940014300}{\texttt{Base.pointer}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pointer(array [, index])
\end{minted}

Get the native address of an array or string, optionally at a given location \texttt{index}.

This function is {\textquotedbl}unsafe{\textquotedbl}. Be careful to ensure that a Julia reference to \texttt{array} exists as long as this pointer will be used. The \hyperlink{6484353991353718972}{\texttt{GC.@preserve}} macro should be used to protect the \texttt{array} argument from garbage collection within a given block of code.

Calling \hyperlink{7936024700322877457}{\texttt{Ref(array[, index])}} is generally preferable to this function as it guarantees validity.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L172-L183}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14566494858943689253}{} 
\hyperlink{14566494858943689253}{\texttt{Base.unsafe\_wrap}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unsafe_wrap(Array, pointer::Ptr{T}, dims; own = false)
\end{minted}

Wrap a Julia \texttt{Array} object around the data at the address given by \texttt{pointer}, without making a copy.  The pointer element type \texttt{T} determines the array element type. \texttt{dims} is either an integer (for a 1d array) or a tuple of the array dimensions. \texttt{own} optionally specifies whether Julia should take ownership of the memory, calling \texttt{free} on the pointer when the array is no longer referenced.

This function is labeled {\textquotedbl}unsafe{\textquotedbl} because it will crash if \texttt{pointer} is not a valid memory address to data of the requested length.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/pointer.jl#L70-L81}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9366554937543398846}{} 
\hyperlink{9366554937543398846}{\texttt{Base.pointer\_from\_objref}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pointer_from_objref(x)
\end{minted}

Get the memory address of a Julia object as a \texttt{Ptr}. The existence of the resulting \texttt{Ptr} will not protect the object from garbage collection, so you must ensure that the object remains referenced for the whole time that the \texttt{Ptr} will be used.

This function may not be called on immutable objects, since they do not have stable memory addresses.

See also: \hyperlink{10812596548944930674}{\texttt{unsafe\_pointer\_to\_objref}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/pointer.jl#L132-L143}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10812596548944930674}{} 
\hyperlink{10812596548944930674}{\texttt{Base.unsafe\_pointer\_to\_objref}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unsafe_pointer_to_objref(p::Ptr)
\end{minted}

Convert a \texttt{Ptr} to an object reference. Assumes the pointer refers to a valid heap-allocated Julia object. If this is not the case, undefined behavior results, hence this function is considered {\textquotedbl}unsafe{\textquotedbl} and should be used with care.

See also: \hyperlink{9366554937543398846}{\texttt{pointer\_from\_objref}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/pointer.jl#L121-L129}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15284219011001573060}{} 
\hyperlink{15284219011001573060}{\texttt{Base.disable\_sigint}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
disable_sigint(f::Function)
\end{minted}

Disable Ctrl-C handler during execution of a function on the current task, for calling external code that may call julia code that is not interrupt safe. Intended to be called using \texttt{do} block syntax as follows:


\begin{lstlisting}
disable_sigint() do
    # interrupt-unsafe code
    ...
end
\end{lstlisting}

This is not needed on worker threads (\texttt{Threads.threadid() != 1}) since the \texttt{InterruptException} will only be delivered to the master thread. External functions that do not call julia code or julia runtime automatically disable sigint during their execution.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L427-L443}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1880405387924190637}{} 
\hyperlink{1880405387924190637}{\texttt{Base.reenable\_sigint}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reenable_sigint(f::Function)
\end{minted}

Re-enable Ctrl-C handler during execution of a function. Temporarily reverses the effect of \hyperlink{15284219011001573060}{\texttt{disable\_sigint}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L452-L457}{\texttt{source}}


\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Base.exit\_on\_sigint}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{16566861134678143754}{} 
\hyperlink{16566861134678143754}{\texttt{Base.systemerror}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
systemerror(sysfunc[, errno::Cint=Libc.errno()])
systemerror(sysfunc, iftrue::Bool)
\end{minted}

Raises a \texttt{SystemError} for \texttt{errno} with the descriptive string \texttt{sysfunc} if \texttt{iftrue} is \texttt{true}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/error.jl#L161-L166}{\texttt{source}}


\end{adjustwidth}
\hypertarget{329703646940222502}{} 
\hyperlink{329703646940222502}{\texttt{Base.windowserror}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
windowserror(sysfunc[, code::UInt32=Libc.GetLastError()])
windowserror(sysfunc, iftrue::Bool)
\end{minted}

Like \hyperlink{16566861134678143754}{\texttt{systemerror}}, but for Windows API functions that use \hyperlink{5383660591411020262}{\texttt{GetLastError}} to return an error code instead of setting \hyperlink{6265587084343794273}{\texttt{errno}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/error.jl#L175-L181}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10630331440513004826}{} 
\hyperlink{10630331440513004826}{\texttt{Core.Ptr}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Ptr{T}
\end{minted}

A memory address referring to data of type \texttt{T}.  However, there is no guarantee that the memory is actually valid, or that it actually represents data of the specified type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/pointer.jl#L3-L8}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7936024700322877457}{} 
\hyperlink{7936024700322877457}{\texttt{Core.Ref}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Ref{T}
\end{minted}

An object that safely references data of type \texttt{T}. This type is guaranteed to point to valid, Julia-allocated memory of the correct type. The underlying data is protected from freeing by the garbage collector as long as the \texttt{Ref} itself is referenced.

In Julia, \texttt{Ref} objects are dereferenced (loaded or stored) with \texttt{[]}.

Creation of a \texttt{Ref} to a value \texttt{x} of type \texttt{T} is usually written \texttt{Ref(x)}. Additionally, for creating interior pointers to containers (such as Array or Ptr), it can be written \texttt{Ref(a, i)} for creating a reference to the \texttt{i}-th element of \texttt{a}.

When passed as a \texttt{ccall} argument (either as a \texttt{Ptr} or \texttt{Ref} type), a \texttt{Ref} object will be converted to a native pointer to the data it references.

There is no invalid (NULL) \texttt{Ref} in Julia, but a \texttt{C\_NULL} instance of \texttt{Ptr} can be passed to a \texttt{ccall} Ref argument.

\textbf{Use in broadcasting}

Broadcasting with \texttt{Ref(x)} treats \texttt{x} as a scalar:


\begin{minted}{jlcon}
julia> isa.(Ref([1,2,3]), [Array, Dict, Int])
3-element BitArray{1}:
 1
 0
 0
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/refpointer.jl#L3-L32}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1445070667463182719}{} 
\hyperlink{1445070667463182719}{\texttt{Base.Cchar}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cchar
\end{minted}

Equivalent to the native \texttt{char} c-type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L86-L90}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8681597464447377029}{} 
\hyperlink{8681597464447377029}{\texttt{Base.Cuchar}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cuchar
\end{minted}

Equivalent to the native \texttt{unsigned char} c-type (\hyperlink{6609065134969660118}{\texttt{UInt8}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L6-L10}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15152042474889311053}{} 
\hyperlink{15152042474889311053}{\texttt{Base.Cshort}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cshort
\end{minted}

Equivalent to the native \texttt{signed short} c-type (\hyperlink{6667287249103968645}{\texttt{Int16}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L14-L18}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8632604011862685836}{} 
\hyperlink{8632604011862685836}{\texttt{Base.Cstring}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cstring
\end{minted}

A C-style string composed of the native character type \hyperlink{1445070667463182719}{\texttt{Cchar}}s. \texttt{Cstring}s are NUL-terminated. For C-style strings composed of the native wide character type, see \hyperlink{510630608879002831}{\texttt{Cwstring}}. For more information about string interopability with C, see the \hyperlink{8959797014682889223}{manual}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L138-L147}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12769525139115944472}{} 
\hyperlink{12769525139115944472}{\texttt{Base.Cushort}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cushort
\end{minted}

Equivalent to the native \texttt{unsigned short} c-type (\hyperlink{7018610346698168012}{\texttt{UInt16}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L22-L26}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4506686204672235089}{} 
\hyperlink{4506686204672235089}{\texttt{Base.Cint}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cint
\end{minted}

Equivalent to the native \texttt{signed int} c-type (\hyperlink{10103694114785108551}{\texttt{Int32}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L30-L34}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11551219982691686969}{} 
\hyperlink{11551219982691686969}{\texttt{Base.Cuint}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cuint
\end{minted}

Equivalent to the native \texttt{unsigned int} c-type (\hyperlink{8690996847580776341}{\texttt{UInt32}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L38-L42}{\texttt{source}}


\end{adjustwidth}
\hypertarget{634246884863419146}{} 
\hyperlink{634246884863419146}{\texttt{Base.Clong}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Clong
\end{minted}

Equivalent to the native \texttt{signed long} c-type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L104-L108}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1371835691073233846}{} 
\hyperlink{1371835691073233846}{\texttt{Base.Culong}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Culong
\end{minted}

Equivalent to the native \texttt{unsigned long} c-type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L111-L115}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11934627959417709350}{} 
\hyperlink{11934627959417709350}{\texttt{Base.Clonglong}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Clonglong
\end{minted}

Equivalent to the native \texttt{signed long long} c-type (\hyperlink{7720564657383125058}{\texttt{Int64}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L86-L90}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12084952472844229160}{} 
\hyperlink{12084952472844229160}{\texttt{Base.Culonglong}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Culonglong
\end{minted}

Equivalent to the native \texttt{unsigned long long} c-type (\hyperlink{5500998675195555601}{\texttt{UInt64}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L94-L98}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13457418202407416700}{} 
\hyperlink{13457418202407416700}{\texttt{Base.Cintmax\_t}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cintmax_t
\end{minted}

Equivalent to the native \texttt{intmax\_t} c-type (\hyperlink{7720564657383125058}{\texttt{Int64}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L70-L74}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11180754709564572253}{} 
\hyperlink{11180754709564572253}{\texttt{Base.Cuintmax\_t}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cuintmax_t
\end{minted}

Equivalent to the native \texttt{uintmax\_t} c-type (\hyperlink{5500998675195555601}{\texttt{UInt64}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L78-L82}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12059505362233183406}{} 
\hyperlink{12059505362233183406}{\texttt{Base.Csize\_t}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Csize_t
\end{minted}

Equivalent to the native \texttt{size\_t} c-type (\texttt{UInt}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L54-L58}{\texttt{source}}


\end{adjustwidth}
\hypertarget{395962290360403795}{} 
\hyperlink{395962290360403795}{\texttt{Base.Cssize\_t}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cssize_t
\end{minted}

Equivalent to the native \texttt{ssize\_t} c-type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L62-L66}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9258508309302754837}{} 
\hyperlink{9258508309302754837}{\texttt{Base.Cptrdiff\_t}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cptrdiff_t
\end{minted}

Equivalent to the native \texttt{ptrdiff\_t} c-type (\texttt{Int}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L46-L50}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2619479148155454993}{} 
\hyperlink{2619479148155454993}{\texttt{Base.Cwchar\_t}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cwchar_t
\end{minted}

Equivalent to the native \texttt{wchar\_t} c-type (\hyperlink{10103694114785108551}{\texttt{Int32}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L118-L122}{\texttt{source}}


\end{adjustwidth}
\hypertarget{510630608879002831}{} 
\hyperlink{510630608879002831}{\texttt{Base.Cwstring}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cwstring
\end{minted}

A C-style string composed of the native wide character type \hyperlink{2619479148155454993}{\texttt{Cwchar\_t}}s. \texttt{Cwstring}s are NUL-terminated. For C-style strings composed of the native character type, see \hyperlink{8632604011862685836}{\texttt{Cstring}}. For more information about string interopability with C, see the \hyperlink{8959797014682889223}{manual}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/c.jl#L125-L135}{\texttt{source}}


\end{adjustwidth}
\hypertarget{899076182665625215}{} 
\hyperlink{899076182665625215}{\texttt{Base.Cfloat}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cfloat
\end{minted}

Equivalent to the native \texttt{float} c-type (\hyperlink{8101639384272933082}{\texttt{Float32}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L102-L106}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5889169829041130899}{} 
\hyperlink{5889169829041130899}{\texttt{Base.Cdouble}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cdouble
\end{minted}

Equivalent to the native \texttt{double} c-type (\hyperlink{5027751419500983000}{\texttt{Float64}}).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/ctypes.jl#L110-L114}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4194942111221907511}{}


\chapter{LLVM 接口}


\hypertarget{12406828992589210838}{} 
\hyperlink{12406828992589210838}{\texttt{Core.Intrinsics.llvmcall}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
llvmcall(IR::String, ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)
llvmcall((declarations::String, IR::String), ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)
\end{minted}

Call LLVM IR string in the first argument. Similar to an LLVM function \texttt{define} block, arguments are available as consecutive unnamed SSA variables (\%0, \%1, etc.).

The optional declarations string contains external functions declarations that are necessary for llvm to compile the IR string. Multiple declarations can be passed in by separating them with line breaks.

Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression.

Each \texttt{ArgumentValue} to \texttt{llvmcall} will be converted to the corresponding \texttt{ArgumentType}, by automatic insertion of calls to \texttt{unsafe\_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue))}. (See also the documentation for \hyperlink{6011318385865707029}{\texttt{unsafe\_convert}} and \hyperlink{16487788729383051927}{\texttt{cconvert}} for further details.) In most cases, this simply results in a call to \texttt{convert(ArgumentType, ArgumentValue)}.

See \texttt{test/llvmcall.jl} for usage examples.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/docs/basedocs.jl#L870-L891}{\texttt{source}}


\end{adjustwidth}

\hypertarget{18164912302030951678}{}


\chapter{C 标准库}


\hypertarget{6469711430097433314}{} 
\hyperlink{6469711430097433314}{\texttt{Base.Libc.malloc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
malloc(size::Integer) -> Ptr{Cvoid}
\end{minted}

Call \texttt{malloc} from the C standard library.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L348-L352}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13715091851486420318}{} 
\hyperlink{13715091851486420318}{\texttt{Base.Libc.calloc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
calloc(num::Integer, size::Integer) -> Ptr{Cvoid}
\end{minted}

Call \texttt{calloc} from the C standard library.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L365-L369}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1243276183164334610}{} 
\hyperlink{1243276183164334610}{\texttt{Base.Libc.realloc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
realloc(addr::Ptr, size::Integer) -> Ptr{Cvoid}
\end{minted}

Call \texttt{realloc} from the C standard library.

See warning in the documentation for \hyperlink{1633533624062187737}{\texttt{free}} regarding only using this on memory originally obtained from \hyperlink{6469711430097433314}{\texttt{malloc}}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L355-L362}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1633533624062187737}{} 
\hyperlink{1633533624062187737}{\texttt{Base.Libc.free}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
free(addr::Ptr)
\end{minted}

Call \texttt{free} from the C standard library. Only use this on memory obtained from \hyperlink{6469711430097433314}{\texttt{malloc}}, not on pointers retrieved from other C libraries. \hyperlink{10630331440513004826}{\texttt{Ptr}} objects obtained from C libraries should be freed by the free functions defined in that library, to avoid assertion failures if multiple \texttt{libc} libraries exist on the system.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L338-L345}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6265587084343794273}{} 
\hyperlink{6265587084343794273}{\texttt{Base.Libc.errno}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
errno([code])
\end{minted}

Get the value of the C library{\textquotesingle}s \texttt{errno}. If an argument is specified, it is used to set the value of \texttt{errno}.

The value of \texttt{errno} is only valid immediately after a \texttt{ccall} to a C library routine that sets it. Specifically, you cannot call \texttt{errno} at the next prompt in a REPL, because lots of code is executed between prompts.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L278-L287}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5310873199456377483}{} 
\hyperlink{5310873199456377483}{\texttt{Base.Libc.strerror}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
strerror(n=errno())
\end{minted}

Convert a system call error code to a descriptive string



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L291-L295}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5383660591411020262}{} 
\hyperlink{5383660591411020262}{\texttt{Base.Libc.GetLastError}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GetLastError()
\end{minted}

Call the Win32 \texttt{GetLastError} function [only available on Windows].



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L299-L303}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14255728048411856987}{} 
\hyperlink{14255728048411856987}{\texttt{Base.Libc.FormatMessage}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
FormatMessage(n=GetLastError())
\end{minted}

Convert a Win32 system call error code to a descriptive string [only available on Windows].



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L306-L310}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2367147567483563544}{} 
\hyperlink{2367147567483563544}{\texttt{Base.Libc.time}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
time(t::TmStruct)
\end{minted}

Converts a \texttt{TmStruct} struct to a number of seconds since the epoch.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L235-L239}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14018638426810725597}{} 
\hyperlink{14018638426810725597}{\texttt{Base.Libc.strftime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
strftime([format], time)
\end{minted}

Convert time, given as a number of seconds since the epoch or a \texttt{TmStruct}, to a formatted string using the given format. Supported formats are the same as those in the standard C library.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L183-L189}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16724851840034148355}{} 
\hyperlink{16724851840034148355}{\texttt{Base.Libc.strptime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
strptime([format], timestr)
\end{minted}

Parse a formatted time string into a \texttt{TmStruct} giving the seconds, minute, hour, date, etc. Supported formats are the same as those in the standard C library. On some platforms, timezones will not be parsed correctly. If the result of this function will be passed to \texttt{time} to convert it to seconds since the epoch, the \texttt{isdst} field should be filled in manually. Setting it to \texttt{-1} will tell the C library to use the current system settings to determine the timezone.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L201-L210}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12094049763760222314}{} 
\hyperlink{12094049763760222314}{\texttt{Base.Libc.TmStruct}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
TmStruct([seconds])
\end{minted}

Convert a number of seconds since the epoch to broken-down format, with fields \texttt{sec}, \texttt{min}, \texttt{hour}, \texttt{mday}, \texttt{month}, \texttt{year}, \texttt{wday}, \texttt{yday}, and \texttt{isdst}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L148-L153}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17297724195103628361}{} 
\hyperlink{17297724195103628361}{\texttt{Base.Libc.flush\_cstdio}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
flush_cstdio()
\end{minted}

Flushes the C \texttt{stdout} and \texttt{stderr} streams (which may have been written to by external C code).



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L105-L109}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8521588756986761846}{} 
\hyperlink{8521588756986761846}{\texttt{Base.Libc.systemsleep}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
systemsleep(s::Real)
\end{minted}

Suspends execution for \texttt{s} seconds. This function does not yield to Julia{\textquotesingle}s scheduler and therefore blocks the Julia thread that it is running on for the duration of the sleep time.

See also: \hyperlink{3231475347583891391}{\texttt{sleep}}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/libc.jl#L125-L133}{\texttt{source}}


\end{adjustwidth}

\hypertarget{6978578663907728721}{}


\chapter{堆栈跟踪}


\hypertarget{16824886840215699957}{} 
\hyperlink{16824886840215699957}{\texttt{Base.StackTraces.StackFrame}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
StackFrame
\end{minted}

Stack information representing execution context, with the following fields:

\begin{itemize}
\item \texttt{func::Symbol}

The name of the function containing the execution context.


\item \texttt{linfo::Union\{Core.MethodInstance, CodeInfo, Nothing\}}

The MethodInstance containing the execution context (if it could be found).


\item \texttt{file::Symbol}

The path to the file containing the execution context.


\item \texttt{line::Int}

The line number in the file containing the execution context.


\item \texttt{from\_c::Bool}

True if the code is from C.


\item \texttt{inlined::Bool}

True if the code is from an inlined frame.


\item \texttt{pointer::UInt64}

Representation of the pointer to the execution context as returned by \texttt{backtrace}.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stacktraces.jl#L14-L47}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12289172590874430030}{} 
\hyperlink{12289172590874430030}{\texttt{Base.StackTraces.StackTrace}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
StackTrace
\end{minted}

An alias for \texttt{Vector\{StackFrame\}} provided for convenience; returned by calls to \texttt{stacktrace}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stacktraces.jl#L68-L73}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11964270650763140298}{} 
\hyperlink{11964270650763140298}{\texttt{Base.StackTraces.stacktrace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stacktrace([trace::Vector{Ptr{Cvoid}},] [c_funcs::Bool=false]) -> StackTrace
\end{minted}

Returns a stack trace in the form of a vector of \texttt{StackFrame}s. (By default stacktrace doesn{\textquotesingle}t return C functions, but this can be enabled.) When called without specifying a trace, \texttt{stacktrace} first calls \texttt{backtrace}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stacktraces.jl#L153-L159}{\texttt{source}}


\end{adjustwidth}

\texttt{Base.StackTraces} 中以下方法和类型不会被导出，需要显式调用，例如 \texttt{StackTraces.lookup(ptr)}。


\hypertarget{1451426077045795515}{} 
\hyperlink{1451426077045795515}{\texttt{Base.StackTraces.lookup}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lookup(pointer::Ptr{Cvoid}) -> Vector{StackFrame}
\end{minted}

Given a pointer to an execution context (usually generated by a call to \texttt{backtrace}), looks up stack frame context information. Returns an array of frame information for all functions inlined at that point, innermost function first.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stacktraces.jl#L99-L105}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11320665145957459671}{} 
\hyperlink{11320665145957459671}{\texttt{Base.StackTraces.remove\_frames!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
remove_frames!(stack::StackTrace, name::Symbol)
\end{minted}

Takes a \texttt{StackTrace} (a vector of \texttt{StackFrames}) and a function name (a \texttt{Symbol}) and removes the \texttt{StackFrame} specified by the function name from the \texttt{StackTrace} (also removing all frames above the specified function). Primarily used to remove \texttt{StackTraces} functions from the \texttt{StackTrace} prior to returning it.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stacktraces.jl#L182-L189}{\texttt{source}}



\begin{lstlisting}
remove_frames!(stack::StackTrace, m::Module)
\end{lstlisting}

Returns the \texttt{StackTrace} with all \texttt{StackFrame}s from the provided \texttt{Module} removed.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/stacktraces.jl#L200-L204}{\texttt{source}}


\end{adjustwidth}

\hypertarget{13225358784905663355}{}


\chapter{SIMD 支持}



\texttt{VecElement\{T\}} 类型是为了构建 SIMD 运算符的库。实际使用中要求使用 \texttt{llvmcall}。类型按下文定义：




\begin{minted}{julia}
struct VecElement{T}
    value::T
end
\end{minted}



It has a special compilation rule: a homogeneous tuple of \texttt{VecElement\{T\}} maps to an LLVM \texttt{vector} type when \texttt{T} is a primitive bits type.



使用 \texttt{-O3} 参数时，编译器 \emph{可能} 自动为这样的元组向量化运算符。 例如接下来的程序，使用 \texttt{julia -O3} 编译，在x86系统中会生成两个 SIMD 附加指令（\texttt{addps}）：




\begin{minted}{julia}
const m128 = NTuple{4,VecElement{Float32}}

function add(a::m128, b::m128)
    (VecElement(a[1].value+b[1].value),
     VecElement(a[2].value+b[2].value),
     VecElement(a[3].value+b[3].value),
     VecElement(a[4].value+b[4].value))
end

triple(c::m128) = add(add(c,c),c)

code_native(triple,(m128,))
\end{minted}



然而，因为无法依靠自动向量化，以后将主要通过使用基于 \texttt{llvmcall} 的库来提供 SIMD 支持。
