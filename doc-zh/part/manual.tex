
\part{手册}


\hypertarget{14943148626325101976}{}


\chapter{入门}



无论是使用预编译好的二进制程序，还是自己从源码编译，安装 Julia 都是一件很简单的事情。 请按照 \href{https://julialang.org/downloads/}{https://julialang.org/downloads/} 的提示来下载并安装 Julia。



如果你是从下面的某一种语言切换到 Julia 的话，那么你应该首先阅读与这些语言有显著差异的那一部分 \hyperlink{16118462231453533890}{MATLAB}, \hyperlink{751329316482051792}{R}, \hyperlink{6816556507610262594}{Python}, \hyperlink{17325153651592351510}{C/C++} or \hyperlink{1976420457538472404}{Common Lisp}. 这将帮助你避免一些常见的编程陷阱，因为 Julia 在许多微妙的方面与这些语言不同。



启动一个交互式会话（也叫 REPL）是学习和尝试 Julia 最简单的方法。双击 Julia 的可执行文件或是从命令行运行 \texttt{julia} 就可以启动：




\begin{lstlisting}
$ julia

               _
   _       _ _(_)_     |  Documentation: https://docs.julialang.org
  (_)     | (_) (_)    |
   _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 1.6.5 (2021-12-19)
 _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release
|__/                   |


julia> 1 + 2
3

julia> ans
3
\end{lstlisting}



输入 \texttt{CTRL-D}（同时按 \texttt{Ctrl} 键和 \texttt{d} 键）或 \texttt{exit()} 便可以退出交互式会话。在交互式模式中，\texttt{julia} 会显示一条横幅并提示用户输入。一旦用户输入了一段完整的代码（表达式），例如 \texttt{1 + 2}，然后按回车，交互式会话就会执行这段代码，并将结果显示出来。如果输入的代码以分号结尾，那么结果将不会显示出来。然而不管结果显示与否，变量 \texttt{ans} 总会存储上一次执行代码的结果，需要注意的是，变量 \texttt{ans} 只在交互式会话中才有。



在交互式会话中，要运行写在源文件 \texttt{file.jl} 中的代码，只需输入 \texttt{include({\textquotedbl}file.jl{\textquotedbl})}。



如果想以非交互的方式执行文件中的代码，可以把文件名作为 \texttt{julia} 命令的第一个参数：




\begin{lstlisting}
$ julia script.jl arg1 arg2...
\end{lstlisting}



如这个例子所示，\texttt{julia} 后跟着的命令行参数会被作为程序 \texttt{script.jl} 的命令行参数。这些参数使用全局常量 \texttt{ARGS} 来传递，脚本自身的名字会以全局变量 \texttt{PROGRAM\_FILE} 传入。注意当脚本以命令行里的 \texttt{-e} 选项输入时，\texttt{ARGS} 也会被设定（详见此页末尾列表）但是 \texttt{PROGRAM\_FILE} 会是空的。例如，要把一个脚本的输入参数显示出来，你可以：




\begin{lstlisting}
$ julia -e 'println(PROGRAM_FILE); for x in ARGS; println(x); end' foo bar

foo
bar
\end{lstlisting}



或者你可以把代码写到一个脚本文件中再执行它：




\begin{lstlisting}
$ echo 'println(PROGRAM_FILE); for x in ARGS; println(x); end' > script.jl
$ julia script.jl foo bar
script.jl
foo
bar
\end{lstlisting}



可以使用 \texttt{--} 分隔符来将传给脚本文件的参数和 Julia 本身的命令行参数区分开：




\begin{lstlisting}
$ julia --color=yes -O -- script.jl arg1 arg2..
\end{lstlisting}



有关编写 Julia 脚本的更多信息，请参阅 \hyperlink{9384335615524550131}{脚本}。



使用选项 \texttt{-p} 或者 \texttt{--machine-file} 可以在并行模式下启动 Julia。 \texttt{-p n} 会启动额外的 \texttt{n} 个 worker，使用 \texttt{--machine-file file} 会为 \texttt{file} 文件中的每一行启动一个 worker。 定义在 \texttt{file} 中的机器必须能够通过一个不需要密码的 \texttt{ssh} 登陆访问到，且 Julia 的安装位置需要和当前主机相同。 定义机器的格式为 \texttt{[count*][user@]host[:port] [bind\_addr[:port]]}。 \texttt{user} 默认值是当前用户； \texttt{port} 默认值是标准 ssh 端口； \texttt{count} 是在这个节点上的 worker 的数量，默认是 1； 可选的 \texttt{bind-to bind\_addr[:port]} 指定了其它 worker 访问当前 worker 应当使用的 IP 地址与端口。



要让 Julia 每次启动都自动执行一些代码，你可以把它们放在 \texttt{{\textasciitilde}/.julia/config/startup.jl} 中：




\begin{lstlisting}
$ echo 'println("Greetings! 你好! 안녕하세요?")' > ~/.julia/config/startup.jl
$ julia
Greetings! 你好! 안녕하세요?

...
\end{lstlisting}



在你第一次运行 Julia 后，你应该多了一个 \texttt{{\textasciitilde}/.julia} 文件夹。 你还可以新建 \texttt{{\textasciitilde}/.julia/config} 文件夹和 \texttt{{\textasciitilde}/.julia/config/startup.jl} 文件来配置 Julia。



和 \texttt{perl} 和 \texttt{ruby} 程序类似，还有很多种运行 Julia 代码的方式，运行代码时也有很多选项：




\begin{lstlisting}
julia [switches] -- [programfile] [args...]
\end{lstlisting}



详细的命令选项可以在这里找到 \hyperlink{631314801744611}{Command-line Options}.



\hypertarget{17073013932993739054}{}


\section{资源}



除了本手册以外，官方网站还提供了一个有用的\textbf{\href{https://julialang.org/learning/}{学习资源列表}}来帮助新用户学习 Julia。



如果已经对 Julia 有所了解，你可以先看 \hyperlink{818954303942149020}{Performance Tips} 和 \hyperlink{6293662380888380710}{Workflow Tips}。



\hypertarget{10731958648755981077}{}


\chapter{变量}



Julia 语言中，变量是与某个值相关联（或绑定）的名字。你可以用它来保存一个值（例如某些计算得到的结果），供之后的代码使用。例如：




\begin{minted}{jlcon}
# 将 10 赋值给变量 x
julia> x = 10
10

# 使用 x 的值做计算
julia> x + 1
11

# 重新给 x 赋值
julia> x = 1 + 1
2

# 也可以给 x 赋其它类型的值, 比如字符串文本
julia> x = "Hello World!"
"Hello World!"
\end{minted}



Julia 提供了非常灵活的变量命名策略。变量名是大小写敏感的，且不包含语义，意思是说，Julia 不会根据变量的名字来区别对待它们。 （译者注：Julia \textbf{不会}自动将全大写的变量识别为常量，也\textbf{不会}将有特定前后缀的变量自动识别为某种特定类型的变量，即不会根据变量名字，自动判断变量的任何属性。）




\begin{minted}{jlcon}
julia> x = 1.0
1.0

julia> y = -3
-3

julia> Z = "My string"
"My string"

julia> customary_phrase = "Hello world!"
"Hello world!"

julia> UniversalDeclarationOfHumanRightsStart = "人人生而自由，在尊严和权利上一律平等。"
"人人生而自由，在尊严和权利上一律平等。"
\end{minted}



你还可以使用 UTF-8 编码的 Unicode 字符作为变量名：




\begin{minted}{jlcon}
julia> δ = 0.00001
1.0e-5

julia> 안녕하세요 = "Hello"
"Hello"
\end{minted}



在 Julia REPL 和一些其它 Julia 的编辑器中，很多 Unicode 数学符号可以使用反斜杠加 LaTeX 符号接 tab 健打出。例如： 变量名 \texttt{δ} 可以通过 \texttt{{\textbackslash}delta}-\emph{tab} 来输入，甚至可以用 \texttt{{\textbackslash}alpha}-\emph{tab}-\texttt{{\textbackslash}hat}-\emph{tab}-\texttt{{\textbackslash}{\textasciicircum}(2)}-\emph{tab}来输入 \texttt{α̂⁽²⁾} 这种复杂的变量名。（如果你在某个地方发现了一个不知道怎么输入的符号，比如在别人的代码里，输入\texttt{?} 接着复制那个符号，REPL的帮助功能会告诉你输入方法。）



如果有需要的话，Julia 甚至允许你重定义内置常量和函数。（这样做可能引发潜在的混淆，所以并不推荐）




\begin{minted}{jlcon}
julia> pi = 3
3

julia> pi
3

julia> sqrt = 4
4
\end{minted}



然而，如果你试图重定义一个已经在使用中的内置常量或函数，Julia 会报错：




\begin{minted}{jlcon}
julia> pi
π = 3.1415926535897...

julia> pi = 3
ERROR: cannot assign a value to variable MathConstants.pi from module Main

julia> sqrt(100)
10.0

julia> sqrt = 4
ERROR: cannot assign a value to variable Base.sqrt from module Main
\end{minted}



\hypertarget{14662919506992032303}{}


\section{合法的变量名}



变量名字必须以英文字母（A-Z 或 a-z）、下划线或编码大于 00A0 的 Unicode 字符的一个子集开头。 具体来说指的是，\href{http://www.fileformat.info/info/unicode/category/index.htm}{Unicode字符分类}中的 Lu/Ll/Lt/Lm/Lo/Nl（字母）、Sc/So（货币和其他符号）以及一些其它像字母的符号（例如 Sm 类别数学符号中的一部分）。 变量名的非首字符还允许使用惊叹号 \texttt{!}、数字（包括 0-9 和其他 Nd/No 类别中的 Unicode 字符）以及其它 Unicode 字符：变音符号和其他修改标记（Mn/Mc/Me/Sk 类别）、标点和连接符（Pc 类别）、引号和少许其他字符。



像 \texttt{+} 这样的运算符也是合法的标识符，但是它们会被特别地解析。 在一些上下文中，运算符可以像变量一样使用，比如 \texttt{(+)} 表示加函数，语句 \texttt{(+) = f}会把它重新赋值。大部分 Unicode 中缀运算符（Sm 类别），像 \texttt{⊕}，会被解析成真正的中缀运算符，并且支持用户自定义方法（举个例子，你可以使用语句 \texttt{const ⊗ = kron}将 \texttt{⊗} 定义为中缀的 Kronecker 积）。 运算符也可以使用修改标记、引号和上标/下标进行加缀，例如 \texttt{+̂ₐ″} 被解析成一个与 \texttt{+} 具有相同优先级的中缀运算符。以下标/上标字母结尾的运算符与后续变量名之间需要一个空格。举个例子，如果 \texttt{+ᵃ} 是一个运算符，那么 \texttt{+ᵃx} 应该被写为\texttt{+ᵃ x}，以区分表达式 \texttt{+ ᵃx} ，其中 \texttt{ᵃx} 是变量名。



一类特定的变量名是只包含下划线的变量名。这些标识符只能赋值，不能用于给其他变量赋值。严格来说，它们只能用作\href{https://en.wikipedia.org/wiki/Value\_(computer\_science)\#lrvalue}{左值} 而不能作\href{https://en.wikipedia.org/wiki/R-value}{右值}:




\begin{minted}{jlcon}
julia> x, ___ = size([2 2; 1 1])
(2, 2)

julia> y = ___
ERROR: syntax: all-underscore identifier used as rvalue
\end{minted}



唯一明确禁止的变量名称是内置\hyperlink{15655456628431734346}{关键字}的名称：




\begin{minted}{jlcon}
julia> else = false
ERROR: syntax: unexpected "else"

julia> try = "No"
ERROR: syntax: unexpected "="
\end{minted}



某些 Unicode 字符被认为是等效的标识符。不同的输入 Unicode 组合字符的方法（例如：重音）被视为等价的（Julia 标识符采用 \href{http://www.macchiato.com/unicode/nfc-faq}{NFC} 标准）。Julia 还加入了一些非标准的等价字符，用于在视觉上相似且易于通过某些输入法输入的字符。Unicode 字符 \texttt{ɛ} (U+025B: Latin small letter open e) 和 \texttt{µ} (U+00B5: micro sign) 被视为等同于相应的希腊字母。点 \texttt{·} (U+00B7) 和希腊字符\href{https://en.wikipedia.org/wiki/Interpunct}{间断} \texttt{·} (U+0387) 都被当作数学上的点积运算符 \texttt{⋅} (U+22C5)。减号 \texttt{−} (U+2212) 与连接号 \texttt{-} (U+002D) 也被视作相同的符号。



\hypertarget{1519367584459167025}{}


\section{命名规范}



虽然 Julia 语言对合法名字的限制非常少，但是遵循以下这些命名规范是非常有用的：



\begin{itemize}
\item 变量的名字采用小写。


\item 使用下划线（\texttt{{\textquotesingle}\_{\textquotesingle}}）来分隔名字中的单词，但是不鼓励使用下划线 除非在不使用下划线时名字会非常难读。


\item 类型 (\texttt{Type}) 和模块（\texttt{Module}）的名字使用大写字母开头，并且用大写字母 而不是用下划线分隔单词。


\item 函数（\texttt{function}）和宏（\texttt{macro}）的名字使用小写，不使用下划线。


\item 会对输入参数进行更改的函数要使用 \texttt{!} 结尾。这些函数有时叫做 “mutating” 或 “in-place” 函数，因为它们在被调用后会修改他们的输入参数的内容 而不仅仅只是返回一个值。

\end{itemize}


关于命名规范的更多信息，可查看\hyperlink{12507952184948113283}{代码风格指南}。



\hypertarget{9431281250101057989}{}


\chapter{整数和浮点数}



整数和浮点值是算术和计算的基础。这些数值的内置表示被称作原始数值类型（numeric primitive），且整数和浮点数在代码中作为立即数时称作数值字面量（numeric literal）。例如，\texttt{1} 是个整型字面量，\texttt{1.0} 是个浮点型字面量，它们在内存中作为对象的二进制表示就是原始数值类型。



Julia 提供了很丰富的原始数值类型，并基于它们定义了一整套算术操作，还提供按位运算符以及一些标准数学函数。这些函数能够直接映射到现代计算机原生支持的数值类型及运算上，因此 Julia 可以充分地利用运算资源。此外，Julia 还为\href{@ref}{任意精度算术}提供了软件支持，对于无法使用原生硬件表示的数值类型，Julia 也能够高效地处理其数值运算。当然，这需要相对的牺牲一些性能。



以下是 Julia 的原始数值类型：



\begin{itemize}
\item \textbf{整数类型：}

\end{itemize}



\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|L|L|}
\hline
类型 & 带符号？ & 比特数 & 最小值 & 最大值 \\
\hline
\hyperlink{5857518405103968275}{\texttt{Int8}} & ✓ & 8 & -2{\textasciicircum}7 & 2{\textasciicircum}7 - 1 \\
\hline
\hyperlink{6609065134969660118}{\texttt{UInt8}} &  & 8 & 0 & 2{\textasciicircum}8 - 1 \\
\hline
\hyperlink{6667287249103968645}{\texttt{Int16}} & ✓ & 16 & -2{\textasciicircum}15 & 2{\textasciicircum}15 - 1 \\
\hline
\hyperlink{7018610346698168012}{\texttt{UInt16}} &  & 16 & 0 & 2{\textasciicircum}16 - 1 \\
\hline
\hyperlink{10103694114785108551}{\texttt{Int32}} & ✓ & 32 & -2{\textasciicircum}31 & 2{\textasciicircum}31 - 1 \\
\hline
\hyperlink{8690996847580776341}{\texttt{UInt32}} &  & 32 & 0 & 2{\textasciicircum}32 - 1 \\
\hline
\hyperlink{7720564657383125058}{\texttt{Int64}} & ✓ & 64 & -2{\textasciicircum}63 & 2{\textasciicircum}63 - 1 \\
\hline
\hyperlink{5500998675195555601}{\texttt{UInt64}} &  & 64 & 0 & 2{\textasciicircum}64 - 1 \\
\hline
\hyperlink{8012327724714767060}{\texttt{Int128}} & ✓ & 128 & -2{\textasciicircum}127 & 2{\textasciicircum}127 - 1 \\
\hline
\hyperlink{14811222188335428522}{\texttt{UInt128}} &  & 128 & 0 & 2{\textasciicircum}128 - 1 \\
\hline
\hyperlink{46725311238864537}{\texttt{Bool}} & N/A & 8 & \texttt{false} (0) & \texttt{true} (1) \\
\hline
\end{tabulary}

\end{table}



\begin{itemize}
\item \textbf{浮点类型:}

\end{itemize}



\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
类型 & 精度 & 比特数 \\
\hline
\hyperlink{2727296760866702904}{\texttt{Float16}} & \href{https://en.wikipedia.org/wiki/Half-precision\_floating-point\_format}{半精度} & 16 \\
\hline
\hyperlink{8101639384272933082}{\texttt{Float32}} & \href{https://en.wikipedia.org/wiki/Single\_precision\_floating-point\_format}{单精度} & 32 \\
\hline
\hyperlink{5027751419500983000}{\texttt{Float64}} & \href{https://en.wikipedia.org/wiki/Double\_precision\_floating-point\_format}{双精度} & 64 \\
\hline
\end{tabulary}

\end{table}



此外，对\hyperlink{13366825053081777829}{复数和有理数}的完整支持是在这些原始数据类型之上建立起来的。多亏了 Julia 有一个很灵活的、用户可扩展的\hyperlink{10374023657104680331}{类型提升系统}，所有的数值类型都无需显式转换就可以很自然地相互进行运算。



\hypertarget{1329060658000677295}{}


\section{整数}



整数字面量以标准形式表示：




\begin{minted}{jlcon}
julia> 1
1

julia> 1234
1234
\end{minted}



整型字面量的默认类型取决于目标系统是 32 位还是 64 位架构：




\begin{minted}{jlcon}
# 32 位系统：
julia> typeof(1)
Int32

# 64 位系统：
julia> typeof(1)
Int64
\end{minted}



Julia 的内置变量 \hyperlink{6553323097149877235}{\texttt{Sys.WORD\_SIZE}} 表明了目标系统是 32 位还是 64 位架构：




\begin{minted}{jlcon}
# 32 位系统：
julia> Sys.WORD_SIZE
32

# 64 位系统：
julia> Sys.WORD_SIZE
64
\end{minted}



Julia 也定义了 \texttt{Int} 与 \texttt{UInt} 类型，它们分别是系统有符号和无符号的原生整数类型的别名。




\begin{minted}{jlcon}
# 32 位系统：
julia> Int
Int32
julia> UInt
UInt32

# 64 位系统：
julia> Int
Int64
julia> UInt
UInt64
\end{minted}



那些超过 32 位表示范围的大整数，如果能用 64 位表示，那么无论是什么系统都会用 64 位表示：




\begin{minted}{jlcon}
# 32 位或 64 位系统：
julia> typeof(3000000000)
Int64
\end{minted}



无符号整数会通过 \texttt{0x} 前缀以及十六进制数 \texttt{0-9a-f} 来输入和输出（输入也可以使用大写的 \texttt{A-F}）。无符号值的位数取决于十六进制数字使用的数量：




\begin{minted}{jlcon}
julia> x = 0x1
0x01

julia> typeof(x)
UInt8

julia> x = 0x123
0x0123

julia> typeof(x)
UInt16

julia> x = 0x1234567
0x01234567

julia> typeof(x)
UInt32

julia> x = 0x123456789abcdef
0x0123456789abcdef

julia> typeof(x)
UInt64

julia> x = 0x11112222333344445555666677778888
0x11112222333344445555666677778888

julia> typeof(x)
UInt128
\end{minted}



采用这种做法是因为，当人们使用无符号十六进制字面量表示整数值的时候，通常会用它们来表示一个固定的数值字节序列，而不仅仅是个整数值。



二进制和八进制字面量也是支持的：




\begin{minted}{jlcon}
julia> x = 0b10
0x02

julia> typeof(x)
UInt8

julia> x = 0o010
0x08

julia> typeof(x)
UInt8

julia> x = 0x00000000000000001111222233334444
0x00000000000000001111222233334444

julia> typeof(x)
UInt128
\end{minted}



二进制、八进制和十六进制的字面量都会产生无符号的整数类型。当字面量不是开头全是 0 时，它们二进制数据项的位数会是最少需要的位数。当开头都是 \texttt{0} 时，位数取决于一个字面量需要的最少位数，这里的字面量指的是一个有着同样长度但开头都为 \texttt{1} 的数。这样用户就可以控制位数了。那些无法使用 \texttt{UInt128} 类型存储下的值无法写成这样的字面量。



二进制、八进制和十六进制的字面量前面加一个负号 \texttt{-}，这样可以产生一个和原字面量有着同样位数而值为原数的补码的数（二补数）：




\begin{minted}{jlcon}
julia> -0x2
0xfe

julia> -0x0002
0xfffe
\end{minted}



整型等原始数值类型的最小和最大可表示的值可用 \hyperlink{3613894539247233488}{\texttt{typemin}} 和 \hyperlink{17760305803764597758}{\texttt{typemax}} 函数得到：




\begin{minted}{jlcon}
julia> (typemin(Int32), typemax(Int32))
(-2147483648, 2147483647)

julia> for T in [Int8,Int16,Int32,Int64,Int128,UInt8,UInt16,UInt32,UInt64,UInt128]
           println("$(lpad(T,7)): [$(typemin(T)),$(typemax(T))]")
       end
   Int8: [-128,127]
  Int16: [-32768,32767]
  Int32: [-2147483648,2147483647]
  Int64: [-9223372036854775808,9223372036854775807]
 Int128: [-170141183460469231731687303715884105728,170141183460469231731687303715884105727]
  UInt8: [0,255]
 UInt16: [0,65535]
 UInt32: [0,4294967295]
 UInt64: [0,18446744073709551615]
UInt128: [0,340282366920938463463374607431768211455]
\end{minted}



\hyperlink{3613894539247233488}{\texttt{typemin}} 和 \hyperlink{17760305803764597758}{\texttt{typemax}} 返回的值的类型总与所给参数的类型相同。（上面的表达式用了一些目前还没有介绍的功能，包括 \hyperlink{9034109510149997190}{for 循环}、\hyperlink{205866387929607333}{字符串}和\hyperlink{4452850363638134205}{字符串插值}，但这对于已有一些编程经验的用户应该是很容易理解的。）



\hypertarget{7600249066838051055}{}


\subsection{溢出行为}



在 Julia 里，超出一个类型可表示的最大值会导致环绕 (wraparound) 行为：




\begin{minted}{jlcon}
julia> x = typemax(Int64)
9223372036854775807

julia> x + 1
-9223372036854775808

julia> x + 1 == typemin(Int64)
true
\end{minted}



因此，Julia 的整数算术实际上是\href{https://en.wikipedia.org/wiki/Modular\_arithmetic}{模算数}的一种形式，它反映了现代计算机实现底层算术的特点。在可能有溢出产生的程序中，对最值边界出现循环进行显式检查是必要的。否则，推荐使用\hyperlink{7030973523078279877}{任意精度算术}中的 \hyperlink{423405808990690832}{\texttt{BigInt}} 类型作为替代。



下面是溢出行为的一个例子以及如何解决溢出：




\begin{minted}{jlcon}
julia> 10^19
-8446744073709551616

julia> big(10)^19
10000000000000000000
\end{minted}



\hypertarget{18099425100953658872}{}


\subsection{除法错误}



\texttt{div} 函数的整数除法有两种异常情况：除以零，以及使用 -1 去除最小的负数（\hyperlink{3613894539247233488}{\texttt{typemin}}）。 这两种情况都会抛出一个 \hyperlink{4168463413201806292}{\texttt{DivideError}} 错误。 \texttt{rem} 取余函数和 \texttt{mod} 取模函数在除零时抛出 \hyperlink{4168463413201806292}{\texttt{DivideError}} 错误。



\hypertarget{7313324545649063110}{}


\section{浮点数}



浮点数字面量以标准格式表示，必要时可使用\href{https://en.wikipedia.org/wiki/Scientific\_notation\#E\_notation}{E-表示法}。




\begin{minted}{jlcon}
julia> 1.0
1.0

julia> 1.
1.0

julia> 0.5
0.5

julia> .5
0.5

julia> -1.23
-1.23

julia> 1e10
1.0e10

julia> 2.5e-4
0.00025
\end{minted}



上面的结果都是 \hyperlink{5027751419500983000}{\texttt{Float64}} 类型的值。使用 \texttt{f} 替代 \texttt{e} 可以得到 \hyperlink{8101639384272933082}{\texttt{Float32}} 类型的字面量：




\begin{minted}{jlcon}
julia> x = 0.5f0
0.5f0

julia> typeof(x)
Float32

julia> 2.5f-4
0.00025f0
\end{minted}



数值可以很容易地转换为 \hyperlink{8101639384272933082}{\texttt{Float32}} 类型：




\begin{minted}{jlcon}
julia> x = Float32(-1.5)
-1.5f0

julia> typeof(x)
Float32
\end{minted}



也存在十六进制的浮点数字面量，但只适用于 \hyperlink{5027751419500983000}{\texttt{Float64}} 类型的值。一般使用 \texttt{p} 前缀及以 2 为底的指数来表示：




\begin{minted}{jlcon}
julia> 0x1p0
1.0

julia> 0x1.8p3
12.0

julia> x = 0x.4p-1
0.125

julia> typeof(x)
Float64
\end{minted}



Julia 也支持半精度浮点数（\hyperlink{2727296760866702904}{\texttt{Float16}}），但它们是使用 \hyperlink{8101639384272933082}{\texttt{Float32}} 进行软件模拟实现的。




\begin{minted}{jlcon}
julia> sizeof(Float16(4.))
2

julia> 2*Float16(4.)
Float16(8.0)
\end{minted}



下划线 \texttt{\_} 可用作数字分隔符：




\begin{minted}{jlcon}
julia> 10_000, 0.000_000_005, 0xdead_beef, 0b1011_0010
(10000, 5.0e-9, 0xdeadbeef, 0xb2)
\end{minted}



\hypertarget{3917895508430327726}{}


\subsection{浮点数中的零}



浮点数有\href{https://en.wikipedia.org/wiki/Signed\_zero}{两种零}，正零和负零。它们相互相等但有着不同的二进制表示，可以使用 \hyperlink{9171163989026657457}{\texttt{bitstring}} 函数来查看：




\begin{minted}{jlcon}
julia> 0.0 == -0.0
true

julia> bitstring(0.0)
"0000000000000000000000000000000000000000000000000000000000000000"

julia> bitstring(-0.0)
"1000000000000000000000000000000000000000000000000000000000000000"
\end{minted}



\hypertarget{16626704755049875766}{}


\subsection{特殊的浮点值}



有三种特定的标准浮点值不和实数轴上任何一点对应：




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|L|L|}
\hline
\texttt{Float16} & \texttt{Float32} & \texttt{Float64} & 名称 & 描述 \\
\hline
\texttt{Inf16} & \texttt{Inf32} & \texttt{Inf} & 正无穷 & 一个大于所有有限浮点数的数 \\
\hline
\texttt{-Inf16} & \texttt{-Inf32} & \texttt{-Inf} & 负无穷 & 一个小于所有有限浮点数的数 \\
\hline
\texttt{NaN16} & \texttt{NaN32} & \texttt{NaN} & 不是数（Not a Number） & 一个不和任何浮点值（包括自己）相等（\texttt{==}）的值 \\
\hline
\end{tabulary}

\end{table}



对于这些非有限浮点值相互之间以及关于其它浮点值的顺序的更多讨论，请参见\hyperlink{7125151170457482788}{数值比较}。根据 \href{https://en.wikipedia.org/wiki/IEEE\_754-2008}{IEEE 754 标准}，这些浮点值是某些算术运算的结果：




\begin{minted}{jlcon}
julia> 1/Inf
0.0

julia> 1/0
Inf

julia> -5/0
-Inf

julia> 0.000001/0
Inf

julia> 0/0
NaN

julia> 500 + Inf
Inf

julia> 500 - Inf
-Inf

julia> Inf + Inf
Inf

julia> Inf - Inf
NaN

julia> Inf * Inf
Inf

julia> Inf / Inf
NaN

julia> 0 * Inf
NaN

julia> NaN == NaN
false

julia> NaN != NaN
true

julia> NaN < NaN
false

julia> NaN > NaN
false
\end{minted}



\hyperlink{3613894539247233488}{\texttt{typemin}} 和 \hyperlink{17760305803764597758}{\texttt{typemax}} 函数同样适用于浮点类型：




\begin{minted}{jlcon}
julia> (typemin(Float16),typemax(Float16))
(-Inf16, Inf16)

julia> (typemin(Float32),typemax(Float32))
(-Inf32, Inf32)

julia> (typemin(Float64),typemax(Float64))
(-Inf, Inf)
\end{minted}



\hypertarget{7614874233242990296}{}


\subsection{机器精度}



大多数实数都无法用浮点数准确地表示，因此有必要知道两个相邻可表示的浮点数间的距离。它通常被叫做\href{https://en.wikipedia.org/wiki/Machine\_epsilon}{机器精度}。



Julia 提供了 \hyperlink{11007691776383983215}{\texttt{eps}} 函数，它可以给出 \texttt{1.0} 与下一个 Julia 能表示的浮点数之间的差值：




\begin{minted}{jlcon}
julia> eps(Float32)
1.1920929f-7

julia> eps(Float64)
2.220446049250313e-16

julia> eps() # 与 eps(Float64) 相同
2.220446049250313e-16
\end{minted}



这些值分别是 \hyperlink{8101639384272933082}{\texttt{Float32}} 中的 \texttt{2.0{\textasciicircum}-23} 和 \hyperlink{5027751419500983000}{\texttt{Float64}} 中的 \texttt{2.0{\textasciicircum}-52}。\hyperlink{11007691776383983215}{\texttt{eps}} 函数也可以接受一个浮点值作为参数，然后给出这个值与下一个可表示的浮点数值之间的绝对差。也就是说，\texttt{eps(x)} 产生一个和 \texttt{x} 类型相同的值，并且  \texttt{x + eps(x)} 恰好是比 \texttt{x} 更大的下一个可表示的浮点值：




\begin{minted}{jlcon}
julia> eps(1.0)
2.220446049250313e-16

julia> eps(1000.)
1.1368683772161603e-13

julia> eps(1e-27)
1.793662034335766e-43

julia> eps(0.0)
5.0e-324
\end{minted}



两个相邻可表示的浮点数之间的距离并不是常数，数值越小，间距越小，数值越大，间距越大。换句话说，可表示的浮点数在实数轴上的零点附近最稠密，并沿着远离零点的方向以指数型的速度变得越来越稀疏。根据定义，\texttt{eps(1.0)} 与 \texttt{eps(Float64)} 相等，因为 \texttt{1.0} 是个 64 位浮点值。



Julia 也提供了 \hyperlink{8339500090035450608}{\texttt{nextfloat}} 和 \hyperlink{14035790731013288499}{\texttt{prevfloat}} 两个函数分别返回基于参数的下一个更大或更小的可表示的浮点数：




\begin{minted}{jlcon}
julia> x = 1.25f0
1.25f0

julia> nextfloat(x)
1.2500001f0

julia> prevfloat(x)
1.2499999f0

julia> bitstring(prevfloat(x))
"00111111100111111111111111111111"

julia> bitstring(x)
"00111111101000000000000000000000"

julia> bitstring(nextfloat(x))
"00111111101000000000000000000001"
\end{minted}



这个例子体现了一般原则，即相邻可表示的浮点数也有着相邻的二进制整数表示。



\hypertarget{5125794393878787955}{}


\subsection{舍入模式}



一个数如果没有精确的浮点表示，就必须被舍入到一个合适的可表示的值。然而，如果想的话，可以根据舍入模式改变舍入的方式，如 \href{https://en.wikipedia.org/wiki/IEEE\_754-2008}{IEEE 754 标准} 所述。



Julia 所使用的默认模式总是 \hyperlink{868115654703135309}{\texttt{RoundNearest}}，指舍入到最接近的可表示的值，这个被舍入的值会使用尽量少的有效位数。



\hypertarget{15305582934630811831}{}


\subsection{背景知识与参考文献}



浮点算术带来了很多微妙之处，它们可能对于那些不熟悉底层实现细节的用户会是很出人意料的。然而，这些微妙之处在大部分科学计算的书籍中以及以下的参考资料中都有详细介绍:



\begin{itemize}
\item 浮点数算术的权威指南是 \href{https://standards.ieee.org/standard/754-2008.html}{IEEE 754-2008 标准}； 然而这篇标准在网上无法免费获得。


\item 关于浮点数是如何表示的，想要一个简单而明白的介绍的话，可以看 John D. Cook 的\href{https://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-point-number/}{文章}以及他关于从这种表示与实数理想的抽象化的差别中产生的一些问题的\href{https://www.johndcook.com/blog/2009/04/06/numbers-are-a-leaky-abstraction/}{介绍}


\item 同样推荐 Bruce Dawson 的\href{https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats}{一系列关于浮点数的博客文章}。


\item 想要一个对浮点数和使用浮点数计算时产生的数值精度问题的极好的、有深度的讨论，可以参见 David Goldberg 的文章 \href{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.6768\&rep=rep1\&type=pdf}{What Every Computer Scientist Should Know About Floating-Point Arithmetic}。


\item 更多延伸文档，包括浮点数的历史、基础理论、问题以及数值计算中很多其它主题的讨论，可以参见 \href{https://en.wikipedia.org/wiki/William\_Kahan}{William Kahan} 的\href{https://people.eecs.berkeley.edu/{\textasciitilde}wkahan/}{写作集}。他以“浮点数之父”闻名。特别感兴趣的话可以看 \href{https://people.eecs.berkeley.edu/{\textasciitilde}wkahan/ieee754status/754story.html}{An Interview with the Old Man of Floating-Point}。

\end{itemize}


\hypertarget{6510345620772143535}{}


\section{任意精度算术}



为了允许使用任意精度的整数与浮点数，Julia 分别包装了 \href{https://gmplib.org}{GNU Multiple Precision Arithmetic Library (GMP)} 以及 \href{https://www.mpfr.org}{GNU MPFR Library}。Julia 中的 \hyperlink{423405808990690832}{\texttt{BigInt}} 与 \hyperlink{749816618809421837}{\texttt{BigFloat}} 两种类型分别提供了任意精度的整数和浮点数。



可以使用构造函数从原始数据类型创建任意精度的整数和浮点数，或是使用\hyperlink{6548320458095485939}{字符串字面量} \hyperlink{4226571565562941917}{\texttt{@big\_str}}、\hyperlink{14207407853646164654}{\texttt{parse}}函数从 \texttt{AbstractString} 类型来创建。当创建的整型字面量过大而无法被其它内置的整数类型表示时，也会被输入为 \texttt{BigInt} 类型。注意到 Julia 的\texttt{Base}中并没有无符号的任意精度的整型（\texttt{BigInt}在多数情况下已经够用了），（除十进制外）也可以使用十六进制、八进制、二进制的字面量。



得益于 Julia 的\hyperlink{10374023657104680331}{类型提升和类型转换机制}，一旦被创建，它们就可以像其它数值类型一样参与算术运算。




\begin{minted}{jlcon}
julia> BigInt(typemax(Int64)) + 1
9223372036854775808

julia> big"123456789012345678901234567890" + 1
123456789012345678901234567891

julia> parse(BigInt, "123456789012345678901234567890") + 1
123456789012345678901234567891

julia> string(big"2"^200, base=16)
"100000000000000000000000000000000000000000000000000"

julia> 0x100000000000000000000000000000000-1 == typemax(UInt128)
true

julia> 0x000000000000000000000000000000000
0

julia> typeof(ans)
BigInt

julia> big"1.23456789012345678901"
1.234567890123456789010000000000000000000000000000000000000000000000000000000004

julia> parse(BigFloat, "1.23456789012345678901")
1.234567890123456789010000000000000000000000000000000000000000000000000000000004

julia> BigFloat(2.0^66) / 3
2.459565876494606882133333333333333333333333333333333333333333333333333333333344e+19

julia> factorial(BigInt(40))
815915283247897734345611269596115894272000000000
\end{minted}



然而，上面的原始类型与 \hyperlink{423405808990690832}{\texttt{BigInt}}/\hyperlink{749816618809421837}{\texttt{BigFloat}} 之间的类型提升并不是自动的，需要明确地指定：




\begin{minted}{jlcon}
julia> x = typemin(Int64)
-9223372036854775808

julia> x = x - 1
9223372036854775807

julia> typeof(x)
Int64

julia> y = BigInt(typemin(Int64))
-9223372036854775808

julia> y = y - 1
-9223372036854775809

julia> typeof(y)
BigInt
\end{minted}



\hyperlink{749816618809421837}{\texttt{BigFloat}} 的默认精度（有效数字的位数）和舍入模式可以通过调用 \hyperlink{3543074496498234209}{\texttt{setprecision}} 和 \hyperlink{16542701110177516527}{\texttt{setrounding}} 来全局地改变，所有之后的计算都会根据这些改变进行。还有一种方法，可以使用同样的函数以及 \texttt{do}-block 来只在运行一个特定代码块时改变精度和舍入模式：




\begin{minted}{jlcon}
julia> setrounding(BigFloat, RoundUp) do
           BigFloat(1) + parse(BigFloat, "0.1")
       end
1.100000000000000000000000000000000000000000000000000000000000000000000000000003

julia> setrounding(BigFloat, RoundDown) do
           BigFloat(1) + parse(BigFloat, "0.1")
       end
1.099999999999999999999999999999999999999999999999999999999999999999999999999986

julia> setprecision(40) do
           BigFloat(1) + parse(BigFloat, "0.1")
       end
1.1000000000004
\end{minted}



\hypertarget{14058350023597195643}{}


\section{数值字面量系数}



为了让常见的数值公式和表达式更清楚，Julia 允许变量直接跟在一个数值字面量后，暗指乘法。这可以让写多项式变得很清楚：




\begin{minted}{jlcon}
julia> x = 3
3

julia> 2x^2 - 3x + 1
10

julia> 1.5x^2 - .5x + 1
13.0
\end{minted}



也会让写指数函数变得更加优雅：




\begin{minted}{jlcon}
julia> 2^2x
64
\end{minted}



数值字面量系数的优先级跟一元运算符相同，比如说取相反数。所以 \texttt{2{\textasciicircum}3x} 会被解析成 \texttt{2{\textasciicircum}(3x)}，而 \texttt{2x{\textasciicircum}3} 会被解析成 \texttt{2*(x{\textasciicircum}3)}。



数值字面量也能作为被括号表达式的系数：




\begin{minted}{jlcon}
julia> 2(x-1)^2 - 3(x-1) + 1
3
\end{minted}



\begin{quote}
\textbf{Note}

用于隐式乘法的数值字面量系数的优先级高于其它的二元运算符，例如乘法（\texttt{*}）和除法（\texttt{/}、\texttt{{\textbackslash}} 以及 \texttt{//}）。这意味着，比如说，\texttt{1 / 2im} 等于 \texttt{-0.5im} 以及 \texttt{6 // 2(2+1)} 等于 \texttt{1 // 1}。

\end{quote}


此外，括号表达式可以被用作变量的系数，暗指表达式与变量相乘：




\begin{minted}{jlcon}
julia> (x-1)x
6
\end{minted}



但是，无论是把两个括号表达式并列，还是把变量放在括号表达式之前，都不会被用作暗指乘法：




\begin{minted}{jlcon}
julia> (x-1)(x+1)
ERROR: MethodError: objects of type Int64 are not callable

julia> x(x+1)
ERROR: MethodError: objects of type Int64 are not callable
\end{minted}



这两种表达式都会被解释成函数调用：所有不是数值字面量的表达式，后面紧跟一个括号，就会被解释成使用括号内的值来调用函数（更多关于函数的信息请参见\hyperlink{16900494992832782120}{函数}）。因此，在这两种情况中，都会因为左边的值并不是函数而产生错误。



上述的语法糖显著地降低了在写普通数学公式时的视觉干扰。注意数值字面量系数和后面用来相乘的标识符或括号表达式之间不能有空格。



\hypertarget{5522643503764211248}{}


\subsection{语法冲突}



并列的字面量系数语法可能和两种数值字面量语法产生冲突：十六进制、八进制、二进制整数字面量以及浮点字面量的工程表示法。下面是几种会产生语法冲突的情况：



\begin{itemize}
\item 十六进制整数字面量 \texttt{0xff} 可能被解释成数值字面量 \texttt{0} 乘以变量 \texttt{xff}。类似的，像 \texttt{0o777} 或\texttt{0b01001010} 使用八进制或二进制表示法也会形成冲突。


\item 浮点字面量表达式 \texttt{1e10} 可以被解释成数值字面量 \texttt{1} 乘以变量 \texttt{e10}，与之等价的 \texttt{E}-表示法也存在类似的情况。


\item 32-bit 的浮点数字面量 \texttt{1.5f22} 被解释成数值字面量 \texttt{1.5} 乘以变量 \texttt{f22}。

\end{itemize}


在这些所有的情况中，歧义都优先解释为数值字面量：



\begin{itemize}
\item \texttt{0x} /\texttt{0o}/\texttt{0b} 开头的表达式总是十六进制/八进制/二进制字面量。


\item 数值开头跟着 \texttt{e} 和 \texttt{E} 的表达式总是浮点字面量。


\item 数值开头跟着 \texttt{f} 的表达式总是 32-bit 浮点字面量。

\end{itemize}


由于历史原因 \texttt{E} 和 \texttt{e} 在数值字面量上是等价的，与之不同的是，\texttt{F} 只是一个行为和 \texttt{f} 不同的字母。因此开头为 \texttt{F} 的表达式将会被 解析为一个数值字面量乘以一个变量，例如 \texttt{1.5F22}等价于 \texttt{1.5 * F22}。



\hypertarget{15171481192117197140}{}


\section{零和一的字面量}



Julia 提供了 0 和 1 的字面量函数，可以返回特定类型或所给变量的类型。




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
函数 & 描述 \\
\hline
\hyperlink{240596739242881814}{\texttt{zero(x)}} & \texttt{x} 类型或变量 \texttt{x} 的类型的零字面量 \\
\hline
\hyperlink{11395333326208453101}{\texttt{one(x)}} & \texttt{x} 类型或变量 \texttt{x} 的类型的一字面量 \\
\hline
\end{tabulary}

\end{table}



这些函数在\hyperlink{7125151170457482788}{数值比较}中可以用来避免不必要的\hyperlink{10374023657104680331}{类型转换}带来的开销。



例如：




\begin{minted}{jlcon}
julia> zero(Float32)
0.0f0

julia> zero(1.0)
0.0

julia> one(Int32)
1

julia> one(BigFloat)
1.0
\end{minted}



\hypertarget{7792257531330504645}{}


\chapter{数学运算和初等函数}



Julia 为它所有的基础数值类型，提供了整套的基础算术和位运算，也提供了一套高效、可移植的标准数学函数。



\hypertarget{11578520796345832337}{}


\section{算术运算符}



以下\href{https://en.wikipedia.org/wiki/Arithmetic\#Arithmetic\_operations}{算术运算符}支持所有的原始数值类型：




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
表达式 & 名称 & 描述 \\
\hline
\texttt{+x} & 一元加法运算符 & 全等操作 \\
\hline
\texttt{-x} & 一元减法运算符 & 将值变为其相反数 \\
\hline
\texttt{x + y} & 二元加法运算符 & 执行加法 \\
\hline
\texttt{x - y} & 二元减法运算符 & 执行减法 \\
\hline
\texttt{x * y} & 乘法运算符 & 执行乘法 \\
\hline
\texttt{x / y} & 除法运算符 & 执行除法 \\
\hline
\texttt{x ÷ y} & 整除 & 取 x / y 的整数部分 \\
\hline
\texttt{x {\textbackslash} y} & 反向除法 & 等价于 \texttt{y / x} \\
\hline
\texttt{x {\textasciicircum} y} & 幂操作符 & \texttt{x} 的 \texttt{y} 次幂 \\
\hline
\texttt{x \% y} & 取余 & 等价于 \texttt{rem(x,y)} \\
\hline
\end{tabulary}

\end{table}



除了优先级比二元操作符高以外，直接放在标识符或括号前的数字，如 \texttt{2x} 或 \texttt{2(x+y)} 还会被视为乘法。详见\hyperlink{7285052708387693199}{数值字面量系数}。



Julia 的类型提升系统使得混合参数类型上的代数运算也能顺其自然的工作，请参考\hyperlink{10374023657104680331}{类型提升系统}来了解更多内容。



符号 ÷ 可以通过输入 \texttt{{\textbackslash}div<tab>}  到 REPL 或 Julia IDE 的方式来打出. 更多信息参见 \hyperlink{12388770544499622804}{Unicode 输入表}。



这里是使用算术运算符的一些简单例子：




\begin{minted}{jlcon}
julia> 1 + 2 + 3
6

julia> 1 - 2
-1

julia> 3*2/12
0.5
\end{minted}



习惯上我们会把优先运算的操作符紧邻操作数，比如 \texttt{-x + 2} 表示先要给 \texttt{x}  取反，然后再加 \texttt{2} 。



在乘法操作中，\texttt{false} 被视作 \textbf{零}。




\begin{minted}{jlcon}
julia> NaN * false
0.0

julia> false * Inf
0.0
\end{minted}



这在已知某些量为零时，可以避免 \texttt{NaN} 的传播。详细的动机参见：\href{https://arxiv.org/abs/math/9205211}{Knuth (1992)}。



\hypertarget{2190636118145801737}{}


\section{布尔运算符}



\hyperlink{46725311238864537}{\texttt{Bool}} 类型支持以下\href{https://en.wikipedia.org/wiki/Boolean\_algebra\#Operations}{布尔运算符}：




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
表达式 & 名称 \\
\hline
\texttt{!x} & 否定 \\
\hline
\texttt{x \&\& y} & \hyperlink{14451148373001501733}{短路与} \\
\hline
\texttt{x || y} & \hyperlink{14451148373001501733}{短路或} \\
\hline
\end{tabulary}

\end{table}



否定将 \texttt{true} 更改为 \texttt{false}，反之亦然。链接页面上解释了逻辑短路。



请注意，\texttt{Bool} 是一个整数类型，所有常用的类型提升规则和数字运算符仍然对它适用。



\hypertarget{17155361622718020970}{}


\section{位运算符}



所有原始整数类型都支持以下\href{https://en.wikipedia.org/wiki/Bitwise\_operation\#Bitwise\_operators}{位运算符}：




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
表达式 & 名称 \\
\hline
\texttt{{\textasciitilde}x} & 按位取反 \\
\hline
\texttt{x \& y} & 按位与 \\
\hline
\texttt{x | y} & 按位或 \\
\hline
\texttt{x \unicodeveebar{} y} & 按位异或（逻辑异或） \\
\hline
\texttt{x ⊼ y} & 按位与（非与） \\
\hline
\texttt{x ⊽ y} & 按位或（非或） \\
\hline
\texttt{x >>> y} & \href{https://en.wikipedia.org/wiki/Logical\_shift}{逻辑右移} \\
\hline
\texttt{x >> y} & \href{https://en.wikipedia.org/wiki/Arithmetic\_shift}{算术右移} \\
\hline
\texttt{x << y} & 逻辑/算术左移 \\
\hline
\end{tabulary}

\end{table}



以下是位运算符的一些示例：




\begin{minted}[escapeinside=\#\%]{jlcon}
julia> ~123
-124

julia> 123 & 234
106

julia> 123 | 234
251

julia> 123 #\unicodeveebar% 234
145

julia> xor(123, 234)
145

julia> nand(123, 123)
-124

julia> 123 ⊼ 123
-124

julia> nor(123, 124)
-128

julia> 123 ⊽ 124
-128

julia> ~UInt32(123)
0xffffff84

julia> ~UInt8(123)
0x84
\end{minted}



\hypertarget{11524779735284405729}{}


\section{复合赋值运算符}



每一个二元运算符和位运算符都可以给左操作数复合赋值：方法是把 \texttt{=} 直接放在二元运算符后面。比如，\texttt{x += 3} 等价于 \texttt{x = x + 3} 。




\begin{minted}{jlcon}
julia> x = 1
1

julia> x += 3
4

julia> x
4
\end{minted}



二元运算符和位运算符的复合赋值操作符有下面几种：




\begin{lstlisting}[escapeinside=\%\%]
+=  -=  *=  /=  \=  ÷=  %\%%=  ^=  &=  |=  %\unicodeveebar%=  >>>=  >>=  <<=
\end{lstlisting}



\begin{quote}
\textbf{Note}

复合赋值后会把变量重新绑定到左操作数上，所以变量的类型可能会改变。


\begin{minted}{jlcon}
julia> x = 0x01; typeof(x)
UInt8

julia> x *= 2 # 与 x = x * 2 相同
2

julia> typeof(x)
Int64
\end{minted}

\end{quote}


\hypertarget{6173297391052343261}{}


\section{向量化 “点” 运算符}



Julia 中，\textbf{每个}二元运算符都有一个 “点” 运算符与之对应，例如 \texttt{{\textasciicircum}} 就有对应的 \texttt{.{\textasciicircum}} 存在。这个对应的 \texttt{.{\textasciicircum}} 被 Julia \textbf{自动地}定义为逐元素地执行 \texttt{{\textasciicircum}} 运算。比如 \texttt{[1,2,3] {\textasciicircum} 3} 是非法的，因为数学上没有给（长宽不一样的）数组的立方下过定义。但是 \texttt{[1,2,3] .{\textasciicircum} 3} 在 Julia 里是合法的，它会逐元素地执行 \texttt{{\textasciicircum}} 运算（或称向量化运算），得到 \texttt{[1{\textasciicircum}3, 2{\textasciicircum}3, 3{\textasciicircum}3]}。类似地，\texttt{!} 或 \texttt{√} 这样的一元运算符，也都有一个对应的 \texttt{.√} 用于执行逐元素运算。




\begin{minted}{jlcon}
julia> [1,2,3] .^ 3
3-element Vector{Int64}:
  1
  8
 27
\end{minted}



更确切地说，\texttt{a .{\textasciicircum}b} 被解析为 \hyperlink{17801130558550430478}{“点运算” 调用} \texttt{({\textasciicircum}).(a,b)}，这会执行 \hyperlink{1924664524817847375}{广播} 操作：该操作能结合数组和标量、相同大小的数组（进行元素之间的运算），甚至不同形状的数组（例如行、列向量结合生成矩阵）。此外，就像所有向量化的点运算调用一样，这些点运算符是\emph{融合}的。例如，在计算关于数组 \texttt{A} 的表达式 \texttt{2 .* A.{\textasciicircum}2 .+ sin.(A)}（或者等价地，使用\hyperlink{16688502228717894452}{\texttt{@.}} 宏，\texttt{@. 2A{\textasciicircum}2 + sin(A)}），Julia 只对 \texttt{A} 进行做\emph{一次}循环，遍历 \texttt{A} 中的每个元素 \texttt{a} 并计算 \texttt{2a{\textasciicircum}2 + sin(a)}。特别的，类似 \texttt{f.(g.(x))} 的嵌套点运算调用也是融合的，并且“相邻的”二元运算符表达式 \texttt{x .+ 3 .* x.{\textasciicircum}2} 可以等价转换为嵌套 dot 调用：\texttt{(+).(x, (*).(3, ({\textasciicircum}).(x, 2)))}。



除了点运算符，我们还有逐点赋值运算符，类似 \texttt{a .+= b}（或者 \texttt{@. a += b}）会被解析成 \texttt{a .= a .+ b}，这里的 \texttt{.=} 是一个\textbf{融合}的 in-place 运算，更多信息请查看 \hyperlink{17801130558550430478}{\texttt{dot} 文档}）。



这个点语法，也能用在用户自定义的运算符上。例如，通过定义 \texttt{⊗(A,B) = kron(A,B)} 可以为 Kronecker 积（\hyperlink{14153417388267953812}{\texttt{kron}}）提供一个方便的中缀语法 \texttt{A ⊗ B}，那么配合点语法 \texttt{[A,B] .⊗ [C,D]} 就等价于 \texttt{[A⊗C, B⊗D]}。



将点运算符用于数值字面量可能会导致歧义。例如，\texttt{1.+x} 到底是表示 \texttt{1. + x} 还是 \texttt{1 .+ x}？这会令人疑惑。因此不允许使用这种语法，遇到这种情况时，必须明确地用空格消除歧义。



\hypertarget{2028216132575181376}{}


\section{数值比较}



标准的比较操作对所有原始数值类型有定义：




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
操作符 & 名称 \\
\hline
\hyperlink{15143149452920304570}{\texttt{==}} & 相等 \\
\hline
\hyperlink{3046079188653285114}{\texttt{!=}}, \hyperlink{3046079188653285114}{\texttt{≠}} & 不等 \\
\hline
\hyperlink{702782232449268329}{\texttt{<}} & 小于 \\
\hline
\hyperlink{11411050964021316526}{\texttt{<=}}, \hyperlink{11411050964021316526}{\texttt{≤}} & 小于等于 \\
\hline
\hyperlink{8677991761303191103}{\texttt{>}} & 大于 \\
\hline
\hyperlink{7019639580556993898}{\texttt{>=}}, \hyperlink{7019639580556993898}{\texttt{≥}} & 大于等于 \\
\hline
\end{tabulary}

\end{table}



下面是一些简单的例子：




\begin{minted}{jlcon}
julia> 1 == 1
true

julia> 1 == 2
false

julia> 1 != 2
true

julia> 1 == 1.0
true

julia> 1 < 2
true

julia> 1.0 > 3
false

julia> 1 >= 1.0
true

julia> -1 <= 1
true

julia> -1 <= -1
true

julia> -1 <= -2
false

julia> 3 < -0.5
false
\end{minted}



整数的比较方式是标准的按位比较，而浮点数的比较方式则遵循 \href{https://en.wikipedia.org/wiki/IEEE\_754-2008}{IEEE 754 标准}。



\begin{itemize}
\item 有限数的大小顺序，和我们所熟知的相同。


\item \texttt{+0} 等于但不大于 \texttt{-0}.


\item \texttt{Inf} 等于自身，并且大于除了 \texttt{NaN} 外的所有数。


\item \texttt{-Inf} 等于自身，并且小于除了 \texttt{NaN} 外的所有数。


\item \texttt{NaN} 不等于、不小于且不大于任何数值，包括它自己。

\end{itemize}


\texttt{NaN} 不等于它自己这一点可能会令人感到惊奇，所以需要注意：




\begin{minted}{jlcon}
julia> NaN == NaN
false

julia> NaN != NaN
true

julia> NaN < NaN
false

julia> NaN > NaN
false
\end{minted}



当你将 \texttt{NaN} 和 \hyperlink{16720099245556932994}{数组} 一起连用时，你就会感到头疼：




\begin{minted}{jlcon}
julia> [1 NaN] == [1 NaN]
false
\end{minted}



为此，Julia 给这些特别的数提供了下面几个额外的测试函数。这些函数在某些情况下很有用处，比如在做 hash 比较时。




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
函数 & 测试是否满足如下性质 \\
\hline
\hyperlink{269533589463185031}{\texttt{isequal(x, y)}} & \texttt{x} 与 \texttt{y} 是完全相同的 \\
\hline
\hyperlink{2906021895910968108}{\texttt{isfinite(x)}} & \texttt{x} 是有限大的数字 \\
\hline
\hyperlink{4492113908831448207}{\texttt{isinf(x)}} & \texttt{x} 是（正/负）无穷大 \\
\hline
\hyperlink{6770390199496851634}{\texttt{isnan(x)}} & \texttt{x} 是 \texttt{NaN} \\
\hline
\end{tabulary}

\end{table}



\hyperlink{269533589463185031}{\texttt{isequal}} 认为 \texttt{NaN} 之间是相等的：




\begin{minted}{jlcon}
julia> isequal(NaN, NaN)
true

julia> isequal([1 NaN], [1 NaN])
true

julia> isequal(NaN, NaN32)
true
\end{minted}



\texttt{isequal} 也能用来区分带符号的零：




\begin{minted}{jlcon}
julia> -0.0 == 0.0
true

julia> isequal(-0.0, 0.0)
false
\end{minted}



有符号整数、无符号整数以及浮点数之间的混合类型比较是很棘手的。开发者费了很大精力来确保 Julia 在这个问题上做的是正确的。



对于其它类型，\texttt{isequal} 会默认调用 \hyperlink{15143149452920304570}{\texttt{==}}，所以如果你想给自己的类型定义相等，那么就只需要为 \hyperlink{15143149452920304570}{\texttt{==}} 增加一个方法。如果你想定义一个你自己的相等函数，你可能需要定义一个对应的 \hyperlink{13797072367283572032}{\texttt{hash}} 方法，用于确保 \texttt{isequal(x,y)} 隐含着 \texttt{hash(x) == hash(y)}。



\hypertarget{9107485161550737856}{}


\subsection{链式比较}



与其他多数语言不同，就像 \href{https://en.wikipedia.org/wiki/Python\_syntax\_and\_semantics\#Comparison\_operators}{notable exception of Python} 一样，Julia 允许链式比较：




\begin{minted}{jlcon}
julia> 1 < 2 <= 2 < 3 == 3 > 2 >= 1 == 1 < 3 != 5
true
\end{minted}



链式比较在写数值代码时特别方便，它使用 \texttt{\&\&} 运算符比较标量，数组则用 \hyperlink{1494761116451616317}{\texttt{\&}} 进行按元素比较。比如，\texttt{0 .< A .< 1} 会得到一个 boolean 数组，如果 \texttt{A} 的元素都在 0 和 1 之间则数组元素就都是 true。



注意链式比较的执行顺序：




\begin{minted}{jlcon}
julia> v(x) = (println(x); x)
v (generic function with 1 method)

julia> v(1) < v(2) <= v(3)
2
1
3
true

julia> v(1) > v(2) <= v(3)
2
1
false
\end{minted}



中间的表达式只会计算一次，而如果写成 \texttt{v(1) < v(2) \&\& v(2) <= v(3)} 是计算了两次的。然而，链式比较中的顺序是不确定的。强烈建议不要在表达式中使用有副作用（比如 printing）的函数。如果的确需要，请使用短路运算符 \texttt{\&\&}（请参考\hyperlink{7551496361738057869}{短路求值}）。



\hypertarget{6116621209452494602}{}


\subsection{初等函数}



Julia 提供了强大的数学函数和运算符集合。这些数学运算定义在各种合理的数值上，包括整型、浮点数、分数和复数，只要这些定义有数学意义就行。



而且，和其它 Julia 函数一样，这些函数也能通过 \hyperlink{17801130558550430478}{点语法} \texttt{f.(A)} 以“向量化”的方式作用于数组和其它集合上。 比如，\texttt{sin.(A)} 会计算 \texttt{A} 中每个元素的 sin 值。



\hypertarget{1086128937891391302}{}


\section{运算符的优先级与结合性}



从高到低，Julia 运算符的优先级与结合性为：




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
分类 & 运算符 & 结合性 \\
\hline
语法 & \texttt{.} followed by \texttt{::} & 左结合 \\
\hline
幂运算 & \texttt{{\textasciicircum}} & 右结合 \\
\hline
一元运算符 & \texttt{+ - √} & 右结合\footnotemark[1] \\
\hline
移位运算 & \texttt{<< >> >>>} & 左结合 \\
\hline
除法 & \texttt{//} & 左结合 \\
\hline
乘法 & \texttt{* / \% \& {\textbackslash} ÷} & 左结合\footnotemark[2] \\
\hline
加法 & \texttt{+ - | \unicodeveebar{}} & 左结合\footnotemark[2] \\
\hline
语法 & \texttt{: ..} & 左结合 \\
\hline
语法 & \texttt{|>} & 左结合 \\
\hline
语法 & \texttt{<|} & 右结合 \\
\hline
比较 & \texttt{> < >= <= == === != !== <:} & 无结合性 \\
\hline
流程控制 & \texttt{\&\&} followed by \texttt{||} followed by \texttt{?} & 右结合 \\
\hline
Pair 操作 & \texttt{=>} & 右结合 \\
\hline
赋值 & \texttt{= += -= *= /= //= {\textbackslash}= {\textasciicircum}= ÷= \%= |= \&= \unicodeveebar{}= <<= >>= >>>=} & 右结合 \\
\hline
\end{tabulary}

\end{table}



\footnotetext[1]{一元运算符 \texttt{+} 和 \texttt{-} 需要显式调用，即给它们的参数加上括号，以免和 \texttt{++} 等运算符混淆。其它一元运算符的混合使用都被解析为右结合的，比如 \texttt{√√-a} 解析为 \texttt{√(√(-a))}。

}


\footnotetext[2]{The operators \texttt{+}, \texttt{++} and \texttt{*} are non-associative. \texttt{a + b + c} is parsed as \texttt{+(a, b, c)} not \texttt{+(+(a, b), c)}. However, the fallback methods for \texttt{+(a, b, c, d...)} and \texttt{*(a, b, c, d...)} both default to left-associative evaluation.

}


想查看 \emph{每个} Julia 运算符的优先级，可以参考这个文件：\href{https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm}{\texttt{src/julia-parser.scm}}。注意到有一些运算符在 \texttt{Base} 模块中没有定义但是可能是在标准库、包或者用户代码中定义的。



你也可以通过内置函数 \texttt{Base.operator\_precedence} 查看任何给定运算符的优先级数值，数值越大优先级越高：




\begin{minted}{jlcon}
julia> Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)
(11, 12, 17)

julia> Base.operator_precedence(:sin), Base.operator_precedence(:+=), Base.operator_precedence(:(=))  # (注意：等号前后必须有括号 `:(=)`)
(0, 1, 1)
\end{minted}



另外，内置函数 \texttt{Base.operator\_associativity} 可以返回运算符结合性的符号表示：




\begin{minted}{jlcon}
julia> Base.operator_associativity(:-), Base.operator_associativity(:+), Base.operator_associativity(:^)
(:left, :none, :right)

julia> Base.operator_associativity(:⊗), Base.operator_associativity(:sin), Base.operator_associativity(:→)
(:left, :none, :right)
\end{minted}



注意诸如 \texttt{:sin} 这样的符号返回优先级 \texttt{0}，此值代表无效的运算符或非最低优先级运算符。类似地，它们的结合性被认为是 \texttt{:none}。



\hyperlink{7285052708387693199}{数字字面量系数}，例如 \texttt{2x}  被视为比任何其他二元运算具有更高优先级的乘法，除了\texttt{{\textasciicircum}}，指数计算具有更高的优先级。




\begin{minted}{jlcon}
julia> x = 3; 2x^2
18

julia> x = 3; 2^2x
64
\end{minted}



并列解析就像一元运算符，它在指数周围具有相同的自然不对称性：\texttt{-x{\textasciicircum}y} 和 \texttt{2x{\textasciicircum}y}解析为 \texttt{-(x{\textasciicircum}y)} 和 \texttt{2(x{\textasciicircum}y)} 而 \texttt{x{\textasciicircum}-y} 和 \texttt{x{\textasciicircum}2y} 解析为\texttt{x{\textasciicircum}(-y)} 和 \texttt{x{\textasciicircum}(2y)}。



\hypertarget{1678218620254251806}{}


\section{数值转换}



Julia 支持三种数值转换，它们在处理不精确转换上有所不同。



\begin{itemize}
\item \texttt{T(x)} 和 \texttt{convert(T,x)} 都会把 \texttt{x} 转换为 \texttt{T}类型。

\begin{itemize}
\item 如果 \texttt{T} 是浮点类型，转换的结果就是最近的可表示值， 可能会是正负无穷大。


\item 如果 \texttt{T} 为整数类型，当 \texttt{x} 不能由 \texttt{T} 类型表示时，会抛出 \texttt{InexactError}。

\end{itemize}

\item \texttt{x \% T} 将整数 \texttt{x} 转换为整型 \texttt{T}，与 \texttt{x} 模 \texttt{2{\textasciicircum}n} 的结果一致，其中 \texttt{n} 是 \texttt{T} 的位数。换句话说，在二进制表示下被截掉了一部分。


\item \hyperlink{9997236062216946610}{舍入函数} 接收一个 \texttt{T} 类型的可选参数。比如，\texttt{round(Int,x)} 是 \texttt{Int(round(x))} 的简写版。

\end{itemize}


下面的例子展示了不同的形式




\begin{minted}{jlcon}
julia> Int8(127)
127

julia> Int8(128)
ERROR: InexactError: trunc(Int8, 128)
Stacktrace:
[...]

julia> Int8(127.0)
127

julia> Int8(3.14)
ERROR: InexactError: Int8(3.14)
Stacktrace:
[...]

julia> Int8(128.0)
ERROR: InexactError: Int8(128.0)
Stacktrace:
[...]

julia> 127 % Int8
127

julia> 128 % Int8
-128

julia> round(Int8,127.4)
127

julia> round(Int8,127.6)
ERROR: InexactError: trunc(Int8, 128.0)
Stacktrace:
[...]
\end{minted}



请参考\hyperlink{10374023657104680331}{类型转换与类型提升}一节来定义你自己的类型转换和提升规则。



\hypertarget{10733784297691347404}{}


\subsection{舍入函数}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
函数 & 描述 & 返回类型 \\
\hline
\hyperlink{2394121098218027856}{\texttt{round(x)}} & \texttt{x} 舍到最接近的整数 & \texttt{typeof(x)} \\
\hline
\hyperlink{2394121098218027856}{\texttt{round(T, x)}} & \texttt{x} 舍到最接近的整数 & \texttt{T} \\
\hline
\hyperlink{11115257331910840693}{\texttt{floor(x)}} & \texttt{x} 向 \texttt{-Inf} 舍入 & \texttt{typeof(x)} \\
\hline
\hyperlink{11115257331910840693}{\texttt{floor(T, x)}} & \texttt{x} 向 \texttt{-Inf} 舍入 & \texttt{T} \\
\hline
\hyperlink{10519509038312853061}{\texttt{ceil(x)}} & \texttt{x} 向 \texttt{+Inf} 方向取整 & \texttt{typeof(x)} \\
\hline
\hyperlink{10519509038312853061}{\texttt{ceil(T, x)}} & \texttt{x} 向 \texttt{+Inf} 方向取整 & \texttt{T} \\
\hline
\hyperlink{1728363361565303194}{\texttt{trunc(x)}} & \texttt{x} 向 0 取整 & \texttt{typeof(x)} \\
\hline
\hyperlink{1728363361565303194}{\texttt{trunc(T, x)}} & \texttt{x} 向 0 取整 & \texttt{T} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{3613448754755213273}{}


\subsection{除法函数}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
函数 & 描述 \\
\hline
\hyperlink{8020976424566491334}{\texttt{div(x,y)}}, \texttt{x÷y} & 截断除法；商向零近似 \\
\hline
\hyperlink{15067916827074788527}{\texttt{fld(x,y)}} & 向下取整除法；商向 \texttt{-Inf} 近似 \\
\hline
\hyperlink{7922388465305816555}{\texttt{cld(x,y)}} & 向上取整除法；商向 \texttt{+Inf} 近似 \\
\hline
\hyperlink{3827563084771191385}{\texttt{rem(x,y)}} & 取余；满足 \texttt{x == div(x,y)*y + rem(x,y)}；符号与 \texttt{x} 一致 \\
\hline
\hyperlink{2082041235715276573}{\texttt{mod(x,y)}} & 取模；满足 \texttt{x == fld(x,y)*y + mod(x,y)}；符号与 \texttt{y} 一致 \\
\hline
\hyperlink{13778479217547823795}{\texttt{mod1(x,y)}} & 偏移 1 的 \texttt{mod}；若 \texttt{y>0}，则返回 \texttt{r∈(0,y]}，若 \texttt{y<0}，则 \texttt{r∈[y,0)} 且满足 \texttt{mod(r, y) == mod(x, y)} \\
\hline
\hyperlink{15322754370885673769}{\texttt{mod2pi(x)}} & 对 2pi 取模；\texttt{0 <= mod2pi(x) < 2pi} \\
\hline
\hyperlink{6106909621813654214}{\texttt{divrem(x,y)}} & 返回 \texttt{(div(x,y),rem(x,y))} \\
\hline
\hyperlink{2806360720034558325}{\texttt{fldmod(x,y)}} & 返回 \texttt{(fld(x,y),mod(x,y))} \\
\hline
\hyperlink{15906911311436241979}{\texttt{gcd(x,y...)}} & \texttt{x}, \texttt{y},... 的最大公约数 \\
\hline
\hyperlink{12975400110924105221}{\texttt{lcm(x,y...)}} & \texttt{x}, \texttt{y},... 的最小公倍数 \\
\hline
\end{tabulary}

\end{table}



\hypertarget{1398763230003382412}{}


\subsection{符号和绝对值函数}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
函数 & 描述 \\
\hline
\hyperlink{9614495866226399167}{\texttt{abs(x)}} & \texttt{x} 的模 \\
\hline
\hyperlink{15686257922156163743}{\texttt{abs2(x)}} & \texttt{x} 的模的平方 \\
\hline
\hyperlink{14349105033929355161}{\texttt{sign(x)}} & 表示 \texttt{x} 的符号，返回 -1，0，或 +1 \\
\hline
\hyperlink{9457038569823603490}{\texttt{signbit(x)}} & 表示符号位是 true 或 false \\
\hline
\hyperlink{6024566200716053110}{\texttt{copysign(x,y)}} & 返回一个数，其值等于 \texttt{x} 的模，符号与 \texttt{y} 一致 \\
\hline
\hyperlink{2689022981470151558}{\texttt{flipsign(x,y)}} & 返回一个数，其值等于 \texttt{x} 的模，符号与 \texttt{x*y} 一致 \\
\hline
\end{tabulary}

\end{table}



\hypertarget{15750140405864720482}{}


\subsection{幂、对数与平方根}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
函数 & 描述 \\
\hline
\hyperlink{4551113327515323898}{\texttt{sqrt(x)}}, \texttt{√x} & \texttt{x} 的平方根 \\
\hline
\hyperlink{15104025502404840355}{\texttt{cbrt(x)}}, \texttt{∛x} & \texttt{x} 的立方根 \\
\hline
\hyperlink{18304489571285447949}{\texttt{hypot(x,y)}} & 当直角边的长度为 \texttt{x} 和 \texttt{y}时，直角三角形斜边的长度 \\
\hline
\hyperlink{5801729597955756107}{\texttt{exp(x)}} & 自然指数函数在 \texttt{x} 处的值 \\
\hline
\hyperlink{4939309737829480377}{\texttt{expm1(x)}} & 当 \texttt{x} 接近 0 时的 \texttt{exp(x)-1} 的精确值 \\
\hline
\hyperlink{14721177606508229464}{\texttt{ldexp(x,n)}} & \texttt{x*2{\textasciicircum}n} 的高效算法，\texttt{n} 为整数 \\
\hline
\hyperlink{17317607370922767936}{\texttt{log(x)}} & \texttt{x} 的自然对数 \\
\hline
\hyperlink{17317607370922767936}{\texttt{log(b,x)}} & 以 \texttt{b} 为底 \texttt{x} 的对数 \\
\hline
\hyperlink{18341149201477905713}{\texttt{log2(x)}} & 以 2 为底 \texttt{x} 的对数 \\
\hline
\hyperlink{3481560771470480868}{\texttt{log10(x)}} & 以 10 为底 \texttt{x} 的对数 \\
\hline
\hyperlink{5533050447473188877}{\texttt{log1p(x)}} & 当 \texttt{x}接近 0 时的 \texttt{log(1+x)} 的精确值 \\
\hline
\hyperlink{39736318364195845}{\texttt{exponent(x)}} & \texttt{x} 的二进制指数 \\
\hline
\hyperlink{11312242195671521747}{\texttt{significand(x)}} & 浮点数 \texttt{x} 的二进制有效数（也就是尾数） \\
\hline
\end{tabulary}

\end{table}



想大概了解一下为什么诸如 \hyperlink{18304489571285447949}{\texttt{hypot}}、\hyperlink{4939309737829480377}{\texttt{expm1}}和 \hyperlink{5533050447473188877}{\texttt{log1p}} 函数是必要和有用的，可以看一下 John D. Cook 关于这些主题的两篇优秀博文：\href{https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/}{expm1, log1p, erfc}， 和 \href{https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/}{hypot}。



\hypertarget{16706884854236336909}{}


\subsection{三角和双曲函数}



所有标准的三角和双曲函数也都已经定义了：




\begin{lstlisting}
sin    cos    tan    cot    sec    csc
sinh   cosh   tanh   coth   sech   csch
asin   acos   atan   acot   asec   acsc
asinh  acosh  atanh  acoth  asech  acsch
sinc   cosc
\end{lstlisting}



所有这些函数都是单参数函数，不过 \hyperlink{16445804261034090556}{\texttt{atan}} 也可以接收两个参数 来表示传统的 \href{https://en.wikipedia.org/wiki/Atan2}{\texttt{atan2}} 函数。



另外，\hyperlink{16554510911661822298}{\texttt{sinpi(x)}} 和 \hyperlink{2974547424856180253}{\texttt{cospi(x)}} 分别用来对 \hyperlink{10540279982054240733}{\texttt{sin(pi*x)}} 和 \hyperlink{10355926621556840804}{\texttt{cos(pi*x)}} 进行更精确的计算。



要计算角度而非弧度的三角函数，以 \texttt{d} 做后缀。 比如，\hyperlink{38337471195460170}{\texttt{sind(x)}} 计算 \texttt{x} 的 sine 值，其中 \texttt{x} 是一个角度值。 下面是角度变量的三角函数完整列表：




\begin{lstlisting}
sind   cosd   tand   cotd   secd   cscd
asind  acosd  atand  acotd  asecd  acscd
\end{lstlisting}



\hypertarget{17986622034630654775}{}


\subsection{特殊函数}



\href{https://github.com/JuliaMath/SpecialFunctions.jl}{SpecialFunctions.jl} 提供了许多其他的特殊数学函数。



\hypertarget{9739813100592614250}{}


\chapter{复数和有理数}



Julia 语言包含了预定义的复数和有理数类型，并且支持它们的各种标准\hyperlink{16865688524696028421}{数学运算和初等函数}。由于也定义了复数与分数的\hyperlink{10374023657104680331}{类型转换与类型提升}，因此对预定义数值类型（无论是原始的还是复合的）的任意组合进行的操作都会表现得如预期的一样。



\hypertarget{5868123017618904517}{}


\section{复数}



全局常量 \hyperlink{15097910740298861288}{\texttt{im}} 被绑定到复数 \emph{i}，表示 -1 的主平方根。（不应使用数学家习惯的 \texttt{i} 或工程师习惯的 \texttt{j} 来表示此全局常量，因为它们是非常常用的索引变量名。）由于 Julia 允许数值字面量作为\hyperlink{7285052708387693199}{数值字面量系数}，这种绑定就足以为复数提供很方便的语法，类似于传统的数学记法：




\begin{minted}{jlcon}
julia> 1+2im
1 + 2im
\end{minted}



你可以对复数进行各种标准算术操作：




\begin{minted}{jlcon}
julia> (1 + 2im)*(2 - 3im)
8 + 1im

julia> (1 + 2im)/(1 - 2im)
-0.6 + 0.8im

julia> (1 + 2im) + (1 - 2im)
2 + 0im

julia> (-3 + 2im) - (5 - 1im)
-8 + 3im

julia> (-1 + 2im)^2
-3 - 4im

julia> (-1 + 2im)^2.5
2.729624464784009 - 6.9606644595719im

julia> (-1 + 2im)^(1 + 1im)
-0.27910381075826657 + 0.08708053414102428im

julia> 3(2 - 5im)
6 - 15im

julia> 3(2 - 5im)^2
-63 - 60im

julia> 3(2 - 5im)^-1.0
0.20689655172413796 + 0.5172413793103449im
\end{minted}



类型提升机制也确保你可以使用不同类型的操作数的组合：




\begin{minted}{jlcon}
julia> 2(1 - 1im)
2 - 2im

julia> (2 + 3im) - 1
1 + 3im

julia> (1 + 2im) + 0.5
1.5 + 2.0im

julia> (2 + 3im) - 0.5im
2.0 + 2.5im

julia> 0.75(1 + 2im)
0.75 + 1.5im

julia> (2 + 3im) / 2
1.0 + 1.5im

julia> (1 - 3im) / (2 + 2im)
-0.5 - 1.0im

julia> 2im^2
-2 + 0im

julia> 1 + 3/4im
1.0 - 0.75im
\end{minted}



注意 \texttt{3/4im == 3/(4*im) == -(3/4*im)}，因为系数比除法的优先级更高。



Julia 提供了一些操作复数的标准函数：




\begin{minted}{jlcon}
julia> z = 1 + 2im
1 + 2im

julia> real(1 + 2im) # z 的实部
1

julia> imag(1 + 2im) # z 的虚部
2

julia> conj(1 + 2im) # z 的复共轭
1 - 2im

julia> abs(1 + 2im) # z 的绝对值
2.23606797749979

julia> abs2(1 + 2im) # 取平方后的绝对值
5

julia> angle(1 + 2im) # 以弧度为单位的相位角
1.1071487177940904
\end{minted}



按照惯例，复数的绝对值（\hyperlink{9614495866226399167}{\texttt{abs}}）是从零点到它的距离。\hyperlink{15686257922156163743}{\texttt{abs2}} 给出绝对值的平方，作用于复数上时非常有用，因为它避免了取平方根。\hyperlink{9465547375318501186}{\texttt{angle}} 返回以弧度为单位的相位角（也被称为辐角函数）。所有其它的\hyperlink{7194628046456539104}{初等函数}在复数上也都有完整的定义：




\begin{minted}{jlcon}
julia> sqrt(1im)
0.7071067811865476 + 0.7071067811865475im

julia> sqrt(1 + 2im)
1.272019649514069 + 0.7861513777574233im

julia> cos(1 + 2im)
2.0327230070196656 - 3.0518977991517997im

julia> exp(1 + 2im)
-1.1312043837568135 + 2.4717266720048188im

julia> sinh(1 + 2im)
-0.4890562590412937 + 1.4031192506220405im
\end{minted}



注意数学函数通常应用于实数就返回实数值，应用于复数就返回复数值。例如，当 \hyperlink{4551113327515323898}{\texttt{sqrt}} 应用于 \texttt{-1} 与 \texttt{-1 + 0im} 会有不同的表现，虽然 \texttt{-1 == -1 + 0im}：




\begin{minted}{jlcon}
julia> sqrt(-1)
ERROR: DomainError with -1.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
[...]

julia> sqrt(-1 + 0im)
0.0 + 1.0im
\end{minted}



从变量构建复数时，\hyperlink{7285052708387693199}{文本型数值系数记法}不再适用。相反地，乘法必须显式地写出：




\begin{minted}{jlcon}
julia> a = 1; b = 2; a + b*im
1 + 2im
\end{minted}



然而，我们\textbf{并不}推荐这样做，而应改为使用更高效的 \hyperlink{16014240202095271744}{\texttt{complex}} 函数直接通过实部与虚部构建一个复数值：




\begin{minted}{jlcon}
julia> a = 1; b = 2; complex(a, b)
1 + 2im
\end{minted}



这种构建避免了乘法和加法操作。



\hyperlink{1907914141659611007}{\texttt{Inf}} 和 \hyperlink{11449618129446476597}{\texttt{NaN}} 可能出现在复数的实部和虚部，正如\hyperlink{17731750208832839264}{特殊的浮点值}章节所描述的：




\begin{minted}{jlcon}
julia> 1 + Inf*im
1.0 + Inf*im

julia> 1 + NaN*im
1.0 + NaN*im
\end{minted}



\hypertarget{8440700082217486421}{}


\section{有理数}



Julia 有一个用于表示整数精确比值的分数类型。分数通过 \hyperlink{17539582191808611917}{\texttt{//}} 运算符构建：




\begin{minted}{jlcon}
julia> 2//3
2//3
\end{minted}



如果一个分数的分子和分母含有公因子，它们会被约分到最简形式且分母非负：




\begin{minted}{jlcon}
julia> 6//9
2//3

julia> -4//8
-1//2

julia> 5//-15
-1//3

julia> -4//-12
1//3
\end{minted}



整数比值的这种标准化形式是唯一的，所以分数值的相等性可由校验分子与分母都相等来测试。分数值的标准化分子和分母可以使用 \hyperlink{7885506453580572157}{\texttt{numerator}} 和 \hyperlink{12407209279719593434}{\texttt{denominator}} 函数得到：




\begin{minted}{jlcon}
julia> numerator(2//3)
2

julia> denominator(2//3)
3
\end{minted}



分子和分母的直接比较通常是不必要的，因为标准算术和比较操作对分数值也有定义：




\begin{minted}{jlcon}
julia> 2//3 == 6//9
true

julia> 2//3 == 9//27
false

julia> 3//7 < 1//2
true

julia> 3//4 > 2//3
true

julia> 2//4 + 1//6
2//3

julia> 5//12 - 1//4
1//6

julia> 5//8 * 3//12
5//32

julia> 6//5 / 10//7
21//25
\end{minted}



分数可以很容易地转换成浮点数：




\begin{minted}{jlcon}
julia> float(3//4)
0.75
\end{minted}



对任意整数值 \texttt{a} 和 \texttt{b}（除了 \texttt{a == 0} 且 \texttt{b == 0} 时），从分数到浮点数的转换遵从以下的一致性：




\begin{minted}{jlcon}
julia> a = 1; b = 2;

julia> isequal(float(a//b), a/b)
true
\end{minted}



Julia接受构建无穷分数值：




\begin{minted}{jlcon}
julia> 5//0
1//0

julia> x = -3//0
-1//0

julia> typeof(x)
Rational{Int64}
\end{minted}



但不接受试图构建一个 \hyperlink{11449618129446476597}{\texttt{NaN}} 分数值：




\begin{minted}{jlcon}
julia> 0//0
ERROR: ArgumentError: invalid rational: zero(Int64)//zero(Int64)
Stacktrace:
[...]
\end{minted}



像往常一样，类型提升系统使得分数可以轻松地同其它数值类型进行交互：




\begin{minted}{jlcon}
julia> 3//5 + 1
8//5

julia> 3//5 - 0.5
0.09999999999999998

julia> 2//7 * (1 + 2im)
2//7 + 4//7*im

julia> 2//7 * (1.5 + 2im)
0.42857142857142855 + 0.5714285714285714im

julia> 3//2 / (1 + 2im)
3//10 - 3//5*im

julia> 1//2 + 2im
1//2 + 2//1*im

julia> 1 + 2//3im
1//1 - 2//3*im

julia> 0.5 == 1//2
true

julia> 0.33 == 1//3
false

julia> 0.33 < 1//3
true

julia> 1//3 - 0.33
0.0033333333333332993
\end{minted}



\hypertarget{3772396547767597421}{}


\chapter{字符串}



字符串是由有限个字符组成的序列。而字符在英文中一般包括字母 \texttt{A},\texttt{B}, \texttt{C} 等、数字和常用的标点符号。这些字符由 \href{https://en.wikipedia.org/wiki/ASCII}{ASCII} 标准统一标准化并且与 0 到 127 范围内的整数一一对应。当然，还有很多非英文字符，包括 ASCII 字符在注音或其他方面的变体，例如西里尔字母和希腊字母，以及与 ASCII 和英文均完全无关的字母系统，包括阿拉伯语，中文， 希伯来语，印度语， 日本语， 和韩语。\href{https://en.wikipedia.org/wiki/Unicode}{Unicode} 标准对这些复杂的字符做了统一的定义，是一种大家普遍接受标准。 根据需求，写代码时可以忽略这种复杂性而只处理 ASCII 字符，也可针对可能出现的非 ASCII 文本而处理所有的字符或编码。Julia 可以简单高效地处理纯粹的 ASCII 文本以及 Unicode 文本。 甚至，在 Julia 中用 C 语言风格的代码来处理 ASCII 字符串，可以在不失性能和易读性的前提下达到预期效果。当遇到非 ASCII 文本时，Julia会优雅明确地提示错误信息而不是引入乱码。 这时，直接修改代码使其可以处理非 ASCII 数据即可。



关于 Julia 的字符串类型有一些值得注意的高级特性：



\begin{itemize}
\item Julia 中用于字符串（和字符串字面量）的内置具体类型是 \hyperlink{2825695355940841177}{\texttt{String}}。 它支持全部 \href{https://en.wikipedia.org/wiki/Unicode}{Unicode} 字符 通过 \href{https://en.wikipedia.org/wiki/UTF-8}{UTF-8} 编码。（\hyperlink{11147209877072452260}{\texttt{transcode}} 函数是 提供 Unicode 编码和其他编码转换的函数。）


\item 所有的字符串类型都是抽象类型 \texttt{AbstractString} 的子类型，而一些外部包定义了别的 \texttt{AbstractString} 子类型（例如为其它的编码定义的子类型）。若要定义需要字符串参数的函数，你应当声明此类型为 \texttt{AbstractString} 来让这函数接受任何字符串类型。


\item 类似 C 和 Java，但是和大多数动态语言不同的是，Julia 有优秀的表示单字符的类型，即 \hyperlink{17842511721012314372}{\texttt{AbstractChar}}。\hyperlink{3463806064296245385}{\texttt{Char}} 是 \texttt{AbstractChar} 的内置子类型，它能表示任何 Unicode 字符的 32 位原始类型（基于 UTF-8 编码）。


\item 如 Java 中那样，字符串不可改——任何 \texttt{AbstractString} 对象的值不可改变。 若要构造不同的字符串值，应当从其它字符串的部分构造一个新的字符串。


\item 从概念上讲，字符串是从索引到字符的\emph{部分函数}：对于某些索引值，它不返回字符值，而是引发异常。这允许通过编码表示形式的字节索引来实现高效的字符串索引，而不是通过字符索引——它不能简单高效地实现可变宽度的 Unicode 字符串编码。

\end{itemize}


\hypertarget{11743000381881707413}{}


\section{字符}



\texttt{Char} 类型的值代表单个字符：它只是带有特殊文本表示法和适当算术行为的 32 位原始类型，不能转化为代表 \href{https://en.wikipedia.org/wiki/Code\_point}{Unicode 代码} 的数值。（Julia 的包可能会定义别的 \texttt{AbstractChar} 子类型，比如当为了优化对其它 \href{https://en.wikipedia.org/wiki/Character\_encoding}{字符编码} 的操作时）\texttt{Char} 类型的值以这样的方式输入和显示：




\begin{minted}{jlcon}
julia> c = 'x'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia> typeof(c)
Char
\end{minted}



你可以轻松地将 \texttt{Char} 转换为其对应的整数值，即 Unicode 代码：




\begin{minted}{jlcon}
julia> c = Int('x')
120

julia> typeof(c)
Int64
\end{minted}



在 32 位的计算机中，\hyperlink{13440452181855594120}{\texttt{typeof(c)}} 将显示为 \hyperlink{10103694114785108551}{\texttt{Int32}}。你可以轻松地将一个整数值转回 Char：




\begin{minted}{jlcon}
julia> Char(120)
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)
\end{minted}



并非所有的整数值都是有效的 Unicode 代码，但是为了性能，\texttt{Char} 的转化不会检查每个值是否有效。如果你想检查每个转换的值是否为有效值，请使用 \hyperlink{9678448882095016755}{\texttt{isvalid}} 函数：




\begin{minted}{jlcon}
julia> Char(0x110000)
'\U110000': Unicode U+110000 (category In: Invalid, too high)

julia> isvalid(Char, 0x110000)
false
\end{minted}



目前，有效的 Unicode 码点为，从 \texttt{U+0000} 至 \texttt{U+D7FF}，以及从 \texttt{U+E000} 至 \texttt{U+10FFFF}。 它们还未全部被赋予明确的含义，也还没必要能被程序识别；然而，所有的这些值都被认为是有效的 Unicode 字符。



你可以在单引号中输入任何 Unicode 字符，通过使用 \texttt{{\textbackslash}u} 加上至多 ４ 个十六进制数字或者 \texttt{{\textbackslash}U} 加上至多 ８ 个十六进制数（最长的有效值也只需要 6 个）：




\begin{minted}{jlcon}
julia> '\u0'
'\0': ASCII/Unicode U+0000 (category Cc: Other, control)

julia> '\u78'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia> '\u2200'
'∀': Unicode U+2200 (category Sm: Symbol, math)

julia> '\U10ffff'
'\U10ffff': Unicode U+10FFFF (category Cn: Other, not assigned)
\end{minted}



Julia 使用系统默认的区域和语言设置来确定，哪些字符可以被正确显示，哪些需要用 \texttt{{\textbackslash}u} 或 \texttt{{\textbackslash}U} 的转义来显示。除 Unicode 转义格式之外，还可以使用所有的\href{https://en.wikipedia.org/wiki/C\_syntax\#Backslash\_escapes}{传统 C 语言转义输入形式}：




\begin{minted}{jlcon}
julia> Int('\0')
0

julia> Int('\t')
9

julia> Int('\n')
10

julia> Int('\e')
27

julia> Int('\x7f')
127

julia> Int('\177')
127
\end{minted}



你可以对 \texttt{Char} 的值进行比较和有限的算术运算：




\begin{minted}{jlcon}
julia> 'A' < 'a'
true

julia> 'A' <= 'a' <= 'Z'
false

julia> 'A' <= 'X' <= 'Z'
true

julia> 'x' - 'a'
23

julia> 'A' + 1
'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)
\end{minted}



\hypertarget{6723865345393966445}{}


\section{字符串基础}



字符串字面量由双引号或三重双引号分隔：




\begin{minted}{jlcon}
julia> str = "Hello, world.\n"
"Hello, world.\n"

julia> """Contains "quote" characters"""
"Contains \"quote\" characters"
\end{minted}



Long lines in strings can be broken up by preceding the newline with a backslash (\texttt{{\textbackslash}}):




\begin{minted}{jlcon}
julia> "This is a long \
       line"
"This is a long line"
\end{minted}



如果要字符串中提取字符，可以对其进行索引：




\begin{minted}{jlcon}
julia> str[begin]
'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)

julia> str[1]
'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)

julia> str[6]
',': ASCII/Unicode U+002C (category Po: Punctuation, other)

julia> str[end]
'\n': ASCII/Unicode U+000A (category Cc: Other, control)
\end{minted}



许多的 Julia 对象，包括字符串，都可以用整数进行索引。第一个元素的索引（字符串的第一个字符）由 \hyperlink{16943669671291374223}{\texttt{firstindex(str)}} 返回，最后一个元素（字符）的索引由 \href{@ref}{\texttt{lastindex(str)} } 返回。关键字 \texttt{begin} 和 \texttt{end} 可以在索引操作中使用，它们分别表示给定维度上的第一个和最后一个索引。字符串索引就像 Julia 中的大多数索引一样，是从 1 开始的：对于任何 \texttt{AbstractString}， \texttt{firstindex} 方法总是返回 \texttt{1}。但是，下面我们将会看到，对于一个字符串来说 \texttt{lastindex(str)} 和 \texttt{length(str)} 的结果\emph{不一定}相同，因为 Unicode 字符可能由多个编码单元组成。



你可以用 \hyperlink{11574363005673055470}{\texttt{end}} 进行算术以及其它操作，就像一个普通值一样：




\begin{minted}{jlcon}
julia> str[end-1]
'.': ASCII/Unicode U+002E (category Po: Punctuation, other)

julia> str[end÷2]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)
\end{minted}



使用小于 \texttt{begin} (\texttt{1}) 或大于 \texttt{end} 的索引会引发错误：




\begin{minted}{jlcon}
julia> str[begin-1]
ERROR: BoundsError: attempt to access 14-codeunit String at index [0]
[...]

julia> str[end+1]
ERROR: BoundsError: attempt to access 14-codeunit String at index [15]
[...]
\end{minted}



你也可以用范围索引来提取子字符串：




\begin{minted}{jlcon}
julia> str[4:9]
"lo, wo"
\end{minted}



注意，表达式 \texttt{str[k]} 和 \texttt{str[k:k]} 不会给出相同的结果：




\begin{minted}{jlcon}
julia> str[6]
',': ASCII/Unicode U+002C (category Po: Punctuation, other)

julia> str[6:6]
","
\end{minted}



前者是一个 \texttt{Char} 类型的单个字符，而后者是一个恰好只包含一个字符的字符串。在 Julia 中，这些是不同的。



范围索引复制原始字符串的选定部分。此外，可以使用类型 \hyperlink{2624824381693370630}{\texttt{SubString}}，将视图创建为字符串， 例如：




\begin{minted}{jlcon}
julia> str = "long string"
"long string"

julia> substr = SubString(str, 1, 4)
"long"

julia> typeof(substr)
SubString{String}
\end{minted}



几个标准函数，像 \hyperlink{18002354026785919806}{\texttt{chop}}, \hyperlink{5360081372937794006}{\texttt{chomp}} 或者 \hyperlink{7002432768371197450}{\texttt{strip}} 都会返回一个 \hyperlink{2624824381693370630}{\texttt{SubString}}。



\hypertarget{12357763399910926447}{}


\section{Unicode 和 UTF-8}



Julia 完全支持 Unicode 字符和字符串。\hyperlink{16744269384625214739}{如上所述}，在字符字面量中，Unicode 代码可以用 Unicode \texttt{{\textbackslash}u} 和 \texttt{{\textbackslash}U} 转义序列表示，也可以用所有标准 C 转义序列表示。这些同样可以用来写字符串字面量：




\begin{minted}{jlcon}
julia> s = "\u2200 x \u2203 y"
"∀ x ∃ y"
\end{minted}



这些 Unicode 字符是作为转义还是特殊字符显示，取决于你终端的语言环境设置以及它对 Unicode 的支持。字符串字面量用 UTF-8 编码。UTF-8 是一种可变长度的编码，也就是说并非所有字符都以相同的字节数（code units）编码。在 UTF-8 中，ASCII 字符（小于 0x80(128) 的那些）如它们在 ASCII 中一样使用单字节编码；而 0x80 及以上的字符使用最多 4 个字节编码。



在 Julia 中字符串索引指的是代码单元（对于 UTF-8 来说等同于字节/byte），固定宽度的构建块用于编码任意字符（code point）。这意味着并非每个索引到 UTF-8 字符串的字节都必须是一个字符的有效索引。如果在这种无效字节索引处索引字符串，将会报错：




\begin{minted}{jlcon}
julia> s[1]
'∀': Unicode U+2200 (category Sm: Symbol, math)

julia> s[2]
ERROR: StringIndexError: invalid index [2], valid nearby indices [1]=>'∀', [4]=>' '
Stacktrace:
[...]

julia> s[3]
ERROR: StringIndexError: invalid index [3], valid nearby indices [1]=>'∀', [4]=>' '
Stacktrace:
[...]

julia> s[4]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)
\end{minted}



在这种情况下，字符 \texttt{∀} 是一个三字节字符，因此索引 2 和 3 都是无效的，而下一个字符的索引是 4；这个接下来的有效索引可以用 \hyperlink{7455293228649070526}{\texttt{nextind(s,1)}} 来计算，再接下来的用 \texttt{nextind(s,4)}，依此类推。



如果倒数第二个字符是多字节字符，由于 \texttt{end} 总是集合中最后一个有效索引，这时 \texttt{end-1} 将会是无效索引。




\begin{minted}{jlcon}
julia> s[end-1]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)

julia> s[end-2]
ERROR: StringIndexError: invalid index [9], valid nearby indices [7]=>'∃', [10]=>' '
Stacktrace:
[...]

julia> s[prevind(s, end, 2)]
'∃': Unicode U+2203 (category Sm: Symbol, math)
\end{minted}



第一种情况可以，因为最后一个字符 \texttt{y} 和空格都是一字节的字符，而 \texttt{end-2} 索引到中间的 \texttt{∃} 由多字节表示。正确的方法是使用 \texttt{prevind(s, lastindex(s), 2)}，或者，如果你使用该值来索引\texttt{s}，则可以写为\texttt{s[prevind(s, end, 2) ]} ， \texttt{end} 展开为 \texttt{lastindex(s)}。



使用范围索引提取子字符串也需要有效的字节索引，不然就会抛出错误：  




\begin{minted}{jlcon}
julia> s[1:1]
"∀"

julia> s[1:2]
ERROR: StringIndexError: invalid index [2], valid nearby indices [1]=>'∀', [4]=>' '
Stacktrace:
[...]

julia> s[1:4]
"∀ "
\end{minted}



由于可变长度的编码，字符串中的字符数（由 \hyperlink{3699181304419743826}{\texttt{length(s)}} 给出）并不总是等于最后一个索引的数字。如果你从 1 到 \hyperlink{15780929618270241785}{\texttt{lastindex(s)}} 迭代并索引到 \texttt{s}，未报错时返回的字符序列是包含字符串 \texttt{s} 的字符序列。所以，总是有 \texttt{length(s) <= lastindex(s)}，这是因为字符串中的每个字符必须有它自己的索引。下面是对 \texttt{s} 的字符进行迭代的一个冗长而低效的方式：




\begin{minted}{jlcon}
julia> for i = firstindex(s):lastindex(s)
           try
               println(s[i])
           catch
               # ignore the index error
           end
       end
∀

x

∃

y
\end{minted}



空行上面其实是有空格的。幸运的是，上面的笨拙写法不是对字符串中字符进行迭代所必须的——因为你只需把字符串本身用作迭代对象，而不需要额外处理：




\begin{minted}{jlcon}
julia> for c in s
           println(c)
       end
∀

x

∃

y
\end{minted}



如果需要为字符串获取有效索引，可以使用 \hyperlink{7455293228649070526}{\texttt{nextind}} 和 \hyperlink{15871508897466976220}{\texttt{prevind}} 函数递增/递减到下一个/前一个有效索引，如前所述。你也可以使用 \hyperlink{4701773772897287974}{\texttt{eachindex}} 函数迭代有效的字符索引：




\begin{minted}{jlcon}
julia> collect(eachindex(s))
7-element Vector{Int64}:
  1
  4
  5
  6
  7
 10
 11
\end{minted}



要访问编码的原始代码单位（UTF-8 的字节），可以使用 \hyperlink{16983098119361955361}{\texttt{codeunit(s,i)}}函数，其中索引 \texttt{i} 从 \texttt{1} 连续运行到 \hyperlink{1775518749150675445}{\texttt{ncodeunits(s)}}。 \hyperlink{17283482973786973382}{\texttt{codeunits(s)}} 函数返回一个 \texttt{AbstractVector\{UInt8\}} 包装器，允许您以数组的形式访问这些原始代码单元（字节）。



Julia 中的字符串可以包含无效的 UTF-8 代码单元序列。这个惯例允许把任何字序列当作 \texttt{String}。在这种情形下的一个规则是，当从左到右解析代码单元序列时，字符由匹配下面开头位模式之一的最长的 8 位代码单元序列组成（每个 \texttt{x} 可以是 \texttt{0} 或者 \texttt{1}）：



\begin{itemize}
\item \texttt{0xxxxxxx};


\item \texttt{110xxxxx} \texttt{10xxxxxx};


\item \texttt{1110xxxx} \texttt{10xxxxxx} \texttt{10xxxxxx};


\item \texttt{11110xxx} \texttt{10xxxxxx} \texttt{10xxxxxx} \texttt{10xxxxxx};


\item \texttt{10xxxxxx};


\item \texttt{11111xxx}.

\end{itemize}


特别地，这意味着过长和过高的代码单元序列及其前缀将被视为单个无效字符，而不是多个无效字符。这个规则最好用一个例子来解释：




\begin{minted}{jlcon}
julia> s = "\xc0\xa0\xe2\x88\xe2|"
"\xc0\xa0\xe2\x88\xe2|"

julia> foreach(display, s)
'\xc0\xa0': [overlong] ASCII/Unicode U+0020 (category Zs: Separator, space)
'\xe2\x88': Malformed UTF-8 (category Ma: Malformed, bad data)
'\xe2': Malformed UTF-8 (category Ma: Malformed, bad data)
'|': ASCII/Unicode U+007C (category Sm: Symbol, math)

julia> isvalid.(collect(s))
4-element BitArray{1}:
 0
 0
 0
 1

julia> s2 = "\xf7\xbf\xbf\xbf"
"\U1fffff"

julia> foreach(display, s2)
'\U1fffff': Unicode U+1FFFFF (category In: Invalid, too high)
\end{minted}



我们可以看到字符串 \texttt{s} 中的前两个代码单元形成了一个过长的空格字符编码。这是无效的，但是在字符串中作为单个字符是可以接受的。接下来的两个代码单元形成了一个有效的 3 位 UTF-8 序列开头。然而，第五个代码单元 \texttt{{\textbackslash}xe2} 不是它的有效延续，所以代码单元 3 和 4 在这个字符串中也被解释为格式错误的字符。同理，由于 \texttt{|} 不是它的有效延续，代码单元 5 形成了一个格式错误的字符。最后字符串 \texttt{s2} 包含了一个太高的代码。



Julia 默认使用 UTF-8 编码，对于新编码的支持可以通过包加上。例如，\href{https://github.com/JuliaStrings/LegacyStrings.jl}{LegacyStrings.jl} 包实现了 \texttt{UTF16String} 和 \texttt{UTF32String} 类型。关于其它编码的额外讨论以及如何实现对它们的支持暂时超过了这篇文档的讨论范围。UTF-8 编码相关问题的进一步讨论参见下面的\hyperlink{1529513445769909572}{字节数组字面量}章节。\hyperlink{11147209877072452260}{\texttt{transcode}} 函数可在各种 UTF-xx 编码之间转换，主要用于外部数据和包。



\hypertarget{3486870924145745190}{}


\section{拼接}



最常见最有用的字符串操作是级联：




\begin{minted}{jlcon}
julia> greet = "Hello"
"Hello"

julia> whom = "world"
"world"

julia> string(greet, ", ", whom, ".\n")
"Hello, world.\n"
\end{minted}



意识到像对无效 UTF-8 字符进行级联这样的潜在危险情形是非常重要的。生成的字符串可能会包含和输入字符串不同的字符，并且其中字符的数目也可能少于被级联字符串中字符数目之和，例如：




\begin{minted}{jlcon}
julia> a, b = "\xe2\x88", "\x80"
("\xe2\x88", "\x80")

julia> c = a*b
"∀"

julia> collect.([a, b, c])
3-element Array{Array{Char,1},1}:
 ['\xe2\x88']
 ['\x80']
 ['∀']

julia> length.([a, b, c])
3-element Array{Int64,1}:
 1
 1
 1
\end{minted}



这种情形只可能发生于无效 UTF-8 字符串上。对于有效 UTF-8 字符串，级联保留字符串中的所有字符和字符串的总长度。



Julia 也提供 \hyperlink{5498506958944335098}{\texttt{*}} 用于字符串级联：




\begin{minted}{jlcon}
julia> greet * ", " * whom * ".\n"
"Hello, world.\n"
\end{minted}



尽管对于提供 \texttt{+} 函数用于字符串拼接的语言使用者而言，\texttt{*} 似乎是一个令人惊讶的选择，但 \texttt{*} 的这种用法在数学中早有先例，尤其是在抽象代数中。



在数学上，\texttt{+} 通常表示可交换运算（\emph{commutative} operation）——运算对象的顺序不重要。一个例子是矩阵加法：对于任何形状相同的矩阵 \texttt{A} 和 \texttt{B}，都有 \texttt{A + B == B + A}。与之相反，\texttt{*} 通常表示不可交换运算——运算对象的顺序很重要。例如，对于矩阵乘法，一般 \texttt{A * B != B * A}。同矩阵乘法类似，字符串拼接是不可交换的：\texttt{greet * whom != whom * greet}。在这一点上，对于插入字符串的拼接操作，\texttt{*} 是一个自然而然的选择，与它在数学中的用法一致。



更确切地说，有限长度字符串集合 \emph{S} 和字符串拼接操作 \texttt{*} 构成了一个\href{https://en.wikipedia.org/wiki/Free\_monoid}{自由幺半群} (\emph{S}, \texttt{*})。该集合的单位元是空字符串，\texttt{{\textquotedbl}{\textquotedbl}}。当一个自由幺半群不是交换的时，它的运算通常表示为 \texttt{{\textbackslash}cdot}，\texttt{*}，或者类似的符号，而非暗示交换性的 \texttt{+}。



\hypertarget{12583298261221600612}{}


\section{插值}



拼接构造字符串的方式有时有些麻烦。为了减少对于 \hyperlink{7919678712989769360}{\texttt{string}} 的冗余调用或者重复地做乘法，Julia 允许像 Perl 中一样使用 \texttt{\$} 对字符串字面量进行插值：




\begin{minted}{jlcon}
julia> "$greet, $whom.\n"
"Hello, world.\n"
\end{minted}



这更易读更方便，而且等效于上面的字符串拼接——系统把这个显然一行的字符串字面量重写成带参数的字符串字面量拼接 \texttt{string(greet, {\textquotedbl}, {\textquotedbl}, whom, {\textquotedbl}.{\textbackslash}n{\textquotedbl})}。



在 \texttt{\$} 之后最短的完整表达式被视为插入其值于字符串中的表达式。因此，你可以用括号向字符串中插入任何表达式：




\begin{minted}{jlcon}
julia> "1 + 2 = $(1 + 2)"
"1 + 2 = 3"
\end{minted}



拼接和插值都调用 \hyperlink{7919678712989769360}{\texttt{string}} 以转换对象为字符串形式。 然而，\texttt{string} 实际上仅仅返回了 \hyperlink{8248717042415202230}{\texttt{print}} 的输出，因此，新的类型应该添加 \hyperlink{8248717042415202230}{\texttt{print}} 或 \hyperlink{4561869563484222675}{\texttt{show}} 方法，而不是 \texttt{string} 方法。



多数非 \texttt{AbstractString} 对象被转换为和它们作为文本表达式输入的方式密切对应的字符串：




\begin{minted}{jlcon}
julia> v = [1,2,3]
3-element Vector{Int64}:
 1
 2
 3

julia> "v: $v"
"v: [1, 2, 3]"
\end{minted}



\hyperlink{7919678712989769360}{\texttt{string}} 是 \texttt{AbstractString} 和 \texttt{AbstractChar} 值的标识，所以它们作为自身被插入字符串，无需引用，无需转义：




\begin{minted}{jlcon}
julia> c = 'x'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia> "hi, $c"
"hi, x"
\end{minted}



若要在字符串字面量中包含文本 \texttt{\$}，就用反斜杠转义：




\begin{minted}{jlcon}
julia> print("I have \$100 in my account.\n")
I have $100 in my account.
\end{minted}



\hypertarget{6215712550513853493}{}


\section{三引号字符串字面量}



当使用三引号（\texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}...{\textquotedbl}{\textquotedbl}{\textquotedbl}}）创建字符串时，它们有一些在创建更长文本块时可能用到的特殊行为。



首先，三引号字符串也被反缩进到最小缩进线的水平。这在定义包含缩进的字符串时很有用。例如：




\begin{minted}{jlcon}
julia> str = """
           Hello,
           world.
         """
"  Hello,\n  world.\n"
\end{minted}



在这里，后三引号 \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}} 前面的最后一（空）行设置了缩进级别。



反缩进级别被确定为所有行中空格或制表符的最大公共起始序列，不包括前三引号 \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}} 后面的一行以及只包含空格或制表符的行（总包含结尾 \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}} 的行）。那么对于所有不包括前三引号 \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}} 后面文本的行而言，公共起始序列就被移除了（包括只含空格和制表符而以此序列开始的行），例如：




\begin{minted}{jlcon}
julia> """    This
         is
           a test"""
"    This\nis\n  a test"
\end{minted}



接下来，如果前三引号 \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}} 后面紧跟换行符，那么换行符就从生成的字符串中被剥离。




\begin{minted}{julia}
"""hello"""
\end{minted}



等价于




\begin{minted}{julia}
"""
hello"""
\end{minted}



但是




\begin{minted}{julia}
"""

hello"""
\end{minted}



将在开头包含一个文本换行符。



换行符的移除是在反缩进之后进行的。例如：




\begin{minted}{jlcon}
julia> """
         Hello,
         world."""
"Hello,\nworld."
\end{minted}



如果使用反斜杠消除换行符，下一行的缩进也会被消除：




\begin{minted}{jlcon}
julia> """
         Averylong\
         word"""
"Averylongword"
\end{minted}



尾随空格保持不变。



三引号字符串字面量可不带转义地包含 \texttt{{\textquotedbl}} 符号。



注意，无论是用单引号还是三引号，在文本字符串中换行符都会生成一个换行 (LF) 字符 \texttt{{\textbackslash}n}，即使你的编辑器使用回车组合符 \texttt{{\textbackslash}r} (CR) 或 CRLF 来结束行。为了在字符串中包含 CR，总是应该使用显式转义符 \texttt{{\textbackslash}r}；比如，可以输入文本字符串 \texttt{{\textquotedbl}a CRLF line ending{\textbackslash}r{\textbackslash}n{\textquotedbl}}。



\hypertarget{2767013232051989875}{}


\section{常见操作}



你可以使用标准的比较操作符按照字典顺序比较字符串：




\begin{minted}{jlcon}
julia> "abracadabra" < "xylophone"
true

julia> "abracadabra" == "xylophone"
false

julia> "Hello, world." != "Goodbye, world."
true

julia> "1 + 2 = 3" == "1 + 2 = $(1 + 2)"
true
\end{minted}



你可以使用 \hyperlink{13752961745140943082}{\texttt{findfirst}} 与 \hyperlink{16601358451866933976}{\texttt{findlast}} 函数搜索特定字符的索引：




\begin{minted}{jlcon}
julia> findfirst(isequal('o'), "xylophone")
4

julia> findlast(isequal('o'), "xylophone")
7

julia> findfirst(isequal('z'), "xylophone")
\end{minted}



你可以带上第三个参数，用 \hyperlink{17527118405272566171}{\texttt{findnext}} 与 \hyperlink{5485385242074595664}{\texttt{findprev}} 函数来在给定偏移量处搜索字符：




\begin{minted}{jlcon}
julia> findnext(isequal('o'), "xylophone", 1)
4

julia> findnext(isequal('o'), "xylophone", 5)
7

julia> findprev(isequal('o'), "xylophone", 5)
4

julia> findnext(isequal('o'), "xylophone", 8)
\end{minted}



你可以用 \hyperlink{7988132114328914630}{\texttt{occursin}} 函数检查在字符串中某子字符串可否找到。




\begin{minted}{jlcon}
julia> occursin("world", "Hello, world.")
true

julia> occursin("o", "Xylophon")
true

julia> occursin("a", "Xylophon")
false

julia> occursin('o', "Xylophon")
true
\end{minted}



最后那个例子表明 \hyperlink{7988132114328914630}{\texttt{occursin}} 也可用于搜寻字符字面量。



另外还有两个方便的字符串函数 \hyperlink{15426606278434194584}{\texttt{repeat}} 和 \hyperlink{18064910688022011979}{\texttt{join}}：




\begin{minted}{jlcon}
julia> repeat(".:Z:.", 10)
".:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:."

julia> join(["apples", "bananas", "pineapples"], ", ", " and ")
"apples, bananas and pineapples"
\end{minted}



其它有用的函数还包括：



\begin{itemize}
\item \hyperlink{16943669671291374223}{\texttt{firstindex(str)}} 给出可用来索引到 \texttt{str} 的最小（字节）索引（对字符串来说这总是 1，对于别的容器来说却不一定如此）。


\item \hyperlink{15780929618270241785}{\texttt{lastindex(str)}} 给出可用来索引到 \texttt{str} 的最大（字节）索引。


\item \hyperlink{3699181304419743826}{\texttt{length(str)}}，\texttt{str} 中的字符个数。


\item \hyperlink{3699181304419743826}{\texttt{length(str, i, j)}}，\texttt{str} 中从 \texttt{i} 到 \texttt{j} 的有效字符索引个数。


\item \hyperlink{1775518749150675445}{\texttt{ncodeunits(str)}}，字符串中\href{https://en.wikipedia.org/wiki/Character\_encoding\#Terminology}{代码单元}（\href{https://zh.wikipedia.org/wiki/字符编码\#字符集、代码页，与字符映射}{码元}）的数目。


\item \hyperlink{16983098119361955361}{\texttt{codeunit(str, i)}} 给出在字符串 \texttt{str} 中索引为 \texttt{i} 的代码单元值。


\item \hyperlink{11299403048911786045}{\texttt{thisind(str, i)}}，给定一个字符串的任意索引，查找索引点所在的首个索引。


\item \hyperlink{7455293228649070526}{\texttt{nextind(str, i, n=1)}} 查找在索引 \texttt{i} 之后第 \texttt{n} 个字符的开头。


\item \hyperlink{15871508897466976220}{\texttt{prevind(str, i, n=1)}} 查找在索引 \texttt{i} 之前第 \texttt{n} 个字符的开始。

\end{itemize}


\hypertarget{16709477590855265963}{}


\section{非标准字符串字面量}



有时当你想构造字符串或者使用字符串语义，标准的字符串构造却不能很好的满足需求。Julia 为这种情形提供了非标准字符串字面量。非标准字符串字面量看似常规双引号字符串字面量，但却直接加上了标识符前缀因而并不那么像普通的字符串字面量。



下面将提到，\hyperlink{17292082084708718801}{正则表达式}，\hyperlink{1529513445769909572}{字节数组字面量} 和 \hyperlink{12935585355849408291}{版本号字面量} 都是非标准字符串字面量的例子。 更详细的文档见 \hyperlink{6892717571106872427}{元编程} 章。



\hypertarget{1296431810594490609}{}


\section{正则表达式}



Julia 具有与 Perl 兼容的正则表达式 (regexes)，就像 \href{http://www.pcre.org/}{PCRE} 包所提供的那样，详细信息参见 \href{http://www.pcre.org/current/doc/html/pcre2syntax.html}{PCRE 的语法说明}。 正则表达式以两种方式和字符串相关：一个显然的关联是，正则表达式被用于找到字符串中的正则模式；另一个关联是，正则表达式自身就是作为字符串输入，它们被解析到可用来高效搜索字符串中模式的状态机中。 在 Julia 中正则表达式的输入使用了前缀各类以 \texttt{r} 开头的标识符的非标准字符串字面量。最基本的不打开任何选项的正则表达式只用到了 \texttt{r{\textquotedbl}...{\textquotedbl}}：




\begin{minted}{jlcon}
julia> re = r"^\s*(?:#|$)"
r"^\s*(?:#|$)"

julia> typeof(re)
Regex
\end{minted}



若要检查正则表达式是否匹配某字符串，就用 \hyperlink{7988132114328914630}{\texttt{occursin}}：




\begin{minted}{jlcon}
julia> occursin(r"^\s*(?:#|$)", "not a comment")
false

julia> occursin(r"^\s*(?:#|$)", "# a comment")
true
\end{minted}



可以看到，\hyperlink{7988132114328914630}{\texttt{occursin}} 只返回正确或错误，表明给定正则表达式是否在该字符串中出现。然而，通常我们不只想知道字符串是否匹配，更想了解它是如何匹配的。要捕获匹配的信息，可以改用 \hyperlink{2695862412477105800}{\texttt{match}} 函数：




\begin{minted}{jlcon}
julia> match(r"^\s*(?:#|$)", "not a comment")

julia> match(r"^\s*(?:#|$)", "# a comment")
RegexMatch("#")
\end{minted}



若正则表达式与给定字符串不匹配，\hyperlink{2695862412477105800}{\texttt{match}} 返回 \hyperlink{9331422207248206047}{\texttt{nothing}}——在交互式提示框中不打印任何东西的特殊值。除了不打印，它是一个完全正常的值，这可以用程序来测试：




\begin{minted}{julia}
m = match(r"^\s*(?:#|$)", line)
if m === nothing
    println("not a comment")
else
    println("blank or comment")
end
\end{minted}



如果正则表达式匹配，\hyperlink{2695862412477105800}{\texttt{match}} 的返回值是一个 \href{@ref}{\texttt{RegexMatch}} 对象。这些对象记录了表达式是如何匹配的，包括该模式匹配的子字符串和任何可能被捕获的子字符串。上面的例子仅仅捕获了匹配的部分子字符串，但也许我们想要捕获的是注释字符后面的任何非空文本。我们可以这样做：




\begin{minted}{jlcon}
julia> m = match(r"^\s*(?:#\s*(.*?)\s*$|$)", "# a comment ")
RegexMatch("# a comment ", 1="a comment")
\end{minted}



当调用 \hyperlink{2695862412477105800}{\texttt{match}} 时，你可以选择指定开始搜索的索引。例如：




\begin{minted}{jlcon}
julia> m = match(r"[0-9]","aaaa1aaaa2aaaa3",1)
RegexMatch("1")

julia> m = match(r"[0-9]","aaaa1aaaa2aaaa3",6)
RegexMatch("2")

julia> m = match(r"[0-9]","aaaa1aaaa2aaaa3",11)
RegexMatch("3")
\end{minted}



你可以从 \texttt{RegexMatch} 对象中提取如下信息：



\begin{itemize}
\item 匹配的整个子字符串：\texttt{m.match}


\item 作为字符串数组捕获的子字符串：\texttt{m.captures}


\item 整个匹配开始处的偏移：\texttt{m.offset}


\item 作为向量的捕获子字符串的偏移：\texttt{m.offsets}

\end{itemize}


当捕获不匹配时，\texttt{m.captures} 在该处不再包含一个子字符串，而是 \texttt{什么也不} 包含；此外，\texttt{m.offsets} 的偏移量为 0（回想一下，Julia 的索引是从 1 开始的，因此字符串的零偏移是无效的）。下面是两个有些牵强的例子：




\begin{minted}{jlcon}
julia> m = match(r"(a|b)(c)?(d)", "acd")
RegexMatch("acd", 1="a", 2="c", 3="d")

julia> m.match
"acd"

julia> m.captures
3-element Vector{Union{Nothing, SubString{String}}}:
 "a"
 "c"
 "d"

julia> m.offset
1

julia> m.offsets
3-element Vector{Int64}:
 1
 2
 3

julia> m = match(r"(a|b)(c)?(d)", "ad")
RegexMatch("ad", 1="a", 2=nothing, 3="d")

julia> m.match
"ad"

julia> m.captures
3-element Vector{Union{Nothing, SubString{String}}}:
 "a"
 nothing
 "d"

julia> m.offset
1

julia> m.offsets
3-element Vector{Int64}:
 1
 0
 2
\end{minted}



让捕获作为数组返回是很方便的，这样就可以用解构语法把它们和局域变量绑定起来。为了方便，\texttt{RegexMatch} 对象实现了传递到 \texttt{captures} 字段的迭代器方法，因此您可以直接解构匹配对象：




\begin{minted}{jlcon}
julia> first, second, third = m; first
"a"
\end{minted}



通过使用捕获组的编号或名称对 \texttt{RegexMatch} 对象进行索引，也可实现对捕获的访问：




\begin{minted}{jlcon}
julia> m=match(r"(?<hour>\d+):(?<minute>\d+)","12:45")
RegexMatch("12:45", hour="12", minute="45")

julia> m[:minute]
"45"

julia> m[2]
"45"
\end{minted}



使用 \hyperlink{2106088282730686749}{\texttt{replace}} 时利用 \texttt{{\textbackslash}n} 引用第 n 个捕获组和给替换字符串加上 \texttt{s} 的前缀，可以实现替换字符串中对捕获的引用。捕获组 0 指的是整个匹配对象。可在替换中用 \texttt{{\textbackslash}g<groupname>} 对命名捕获组进行引用。例如：




\begin{minted}{jlcon}
julia> replace("first second", r"(\w+) (?<agroup>\w+)" => s"\g<agroup> \1")
"second first"
\end{minted}



为明确起见，编号捕获组也可用 \texttt{{\textbackslash}g<n>} 进行引用，例如：




\begin{minted}{jlcon}
julia> replace("a", r"." => s"\g<0>1")
"a1"
\end{minted}



你可以在后双引号的后面加上 \texttt{i}, \texttt{m}, \texttt{s} 和 \texttt{x} 等标志对正则表达式进行修改。这些标志和 Perl 里面的含义一样，详见以下对 \href{http://perldoc.perl.org/perlre.html\#Modifiers}{perlre 手册}的摘录：




\begin{lstlisting}
i   不区分大小写的模式匹配。

    若区域设置规则有效，相应映射中代码点小于 255 的部分取自当前区域设置，更大代码点的部分取自 Unicode 规则。然而，跨越 Unicode 规则（ords 255/256）和 非 Unicode 规则边界的匹配将失败。

m   将字符串视为多行。也即更改 "^" 和 "$", 使其从匹配字符串的开头和结尾变为匹配字符串中任意一行的开头或结尾。

s   将字符串视为单行。也即更改 "." 以匹配任何字符，即使是通常不能匹配的换行符。

    像这样一起使用，r""ms，它们让 "." 匹配任何字符，同时也支持分别在字符串中换行符的后面和前面用 "^" 和 "$" 进行匹配。

x   令正则表达式解析器忽略多数既不是反斜杠也不属于字符类的空白。它可以用来把正则表达式分解成（略为）更易读的部分。和普通代码中一样，`#` 字符也被当作引入注释的元字符。
\end{lstlisting}



例如，下面的正则表达式已打开所有三个标志：




\begin{minted}{jlcon}
julia> r"a+.*b+.*?d$"ism
r"a+.*b+.*?d$"ims

julia> match(r"a+.*b+.*?d$"ism, "Goodbye,\nOh, angry,\nBad world\n")
RegexMatch("angry,\nBad world")
\end{minted}



\texttt{r{\textquotedbl}...{\textquotedbl}} 文本的构造没有插值和转义（除了引号 \texttt{{\textquotedbl}} 仍然需要转义）。下面例子展示了它和标准字符串字面量之间的差别：




\begin{minted}{jlcon}
julia> x = 10
10

julia> r"$x"
r"$x"

julia> "$x"
"10"

julia> r"\x"
r"\x"

julia> "\x"
ERROR: syntax: invalid escape sequence
\end{minted}



Julia 也支持 \texttt{r{\textquotedbl}{\textquotedbl}{\textquotedbl}...{\textquotedbl}{\textquotedbl}{\textquotedbl}} 形式的三引号正则表达式字符串（或许便于处理包含引号和换行符的正则表达式）。



\texttt{Regex()} 构造函数可以用于以编程方式创建合法的正则表达式字符串。这允许在构造正则表达式字符串时使用字符串变量的内容和其他字符串操作。上面的任何正则表达式代码可以在 \texttt{Regex()} 的单字符串参数中使用。下面是一些例子：




\begin{minted}{jlcon}
julia> using Dates

julia> d = Date(1962,7,10)
1962-07-10

julia> regex_d = Regex("Day " * string(day(d)))
r"Day 10"

julia> match(regex_d, "It happened on Day 10")
RegexMatch("Day 10")

julia> name = "Jon"
"Jon"

julia> regex_name = Regex("[\"( ]\\Q$name\\E[\") ]")  # interpolate value of name
r"[\"( ]\QJon\E[\") ]"

julia> match(regex_name, " Jon ")
RegexMatch(" Jon ")

julia> match(regex_name, "[Jon]") === nothing
true
\end{minted}



注意 \texttt{{\textbackslash}Q...{\textbackslash}E} 转义序列的使用。 \texttt{{\textbackslash}Q} 和 \texttt{{\textbackslash}E} 之间的所有字符都被解释为字符字面量（在字符串插值之后）。在插入可能是恶意的用户输入时，此转义序列非常有用。



\hypertarget{14271532611053373881}{}


\section{字节数组字面量}



另一个有用的非标准字符串字面量是字节数组字面量：\texttt{b{\textquotedbl}...{\textquotedbl}}。这种形式使你能够用字符串表示法来表达只读字面量字节数组，也即 \hyperlink{6609065134969660118}{\texttt{UInt8}} 值的数组。字节数组字面量的规则如下：



\begin{itemize}
\item ASCII 字符和 ASCII 转义生成单个字节。


\item \texttt{{\textbackslash}x} 和八进制转义序列生成与转义值对应的\emph{字节}。


\item Unicode 转义序列生成编码 UTF-8 中该代码点的字节序列。

\end{itemize}


这些规则有一些重叠，这是因为 \texttt{{\textbackslash}x} 的行为和小于 0x80(128) 的八进制转义被前两个规则同时包括了；但这两个规则又是一致的。通过这些规则可以方便地同时使用 ASCII 字符，任意字节值，以及 UTF-8 序列来生成字节数组。下面是一个用到全部三个规则的例子：




\begin{minted}{jlcon}
julia> b"DATA\xff\u2200"
8-element Base.CodeUnits{UInt8, String}:
 0x44
 0x41
 0x54
 0x41
 0xff
 0xe2
 0x88
 0x80
\end{minted}



其中，ASCII 字符串 {\textquotedbl}DATA{\textquotedbl} 对应于字节 68, 65, 84, 65。\texttt{{\textbackslash}xff} 生成单个字节 255。Unicode 转义 \texttt{{\textbackslash}u2200} 在 UTF-8 中被编码为三个字节 226, 136, 128。注意生成的字节数组不对应任何有效 UTF-8 字符串。




\begin{minted}{jlcon}
julia> isvalid("DATA\xff\u2200")
false
\end{minted}



正如前面所述，\texttt{CodeUnits\{UInt8,String\}} 类型的行为类似于只读 \texttt{UInt8} 数组。如果需要标准数组，你可使用 \texttt{Vector\{UInt8\}} 进行转换。



 




\begin{minted}{jlcon}
julia> x = b"123"
3-element Base.CodeUnits{UInt8, String}:
 0x31
 0x32
 0x33

julia> x[1]
0x31

julia> x[1] = 0x32
ERROR: setindex! not defined for Base.CodeUnits{UInt8, String}
[...]

julia> Vector{UInt8}(x)
3-element Vector{UInt8}:
 0x31
 0x32
 0x33
\end{minted}



同时，要注意到 \texttt{{\textbackslash}xff} 和 \texttt{{\textbackslash}uff} 之间的显著差别：前面的转义序列编码为\emph{字节 255}，而后者代表 \emph{代码 255}，它在 UTF-8 中编码为两个字节：




\begin{minted}{jlcon}
julia> b"\xff"
1-element Base.CodeUnits{UInt8, String}:
 0xff

julia> b"\uff"
2-element Base.CodeUnits{UInt8, String}:
 0xc3
 0xbf
\end{minted}



字符字面量也用到了相同的行为。



对于小于 \texttt{{\textbackslash}u80} 的代码，每个代码的 UTF-8 编码恰好只是由相应 \texttt{{\textbackslash}x} 转义产生的单个字节，因此忽略两者的差别无伤大雅。然而，从 \texttt{x80} 到 \texttt{{\textbackslash}xff} 的转义比起从 \texttt{u80} 到 \texttt{{\textbackslash}uff} 的转义来，就有一个主要的差别：前者都只编码为一个字节，它没有形成任何有效 UTF-8 数据，除非它后面有非常特殊的连接字节；而后者则都代表 2 字节编码的 Unicode 代码。



如果这些还是太难理解，试着读一下 \href{https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/}{{\textquotedbl}每个软件开发人员绝对必须知道的最基础 Unicode 和字符集知识{\textquotedbl}}。它是一个优质的 Unicode 和 UTF-8 指南，或许能帮助解除一些这方面的疑惑。



\hypertarget{10038787961375920908}{}


\section{版本号字面量}



版本号很容易用 \hyperlink{8914616188788850763}{\texttt{v{\textquotedbl}...{\textquotedbl}}} 形式的非标准字符串字面量表示。版本号字面量生成遵循\href{https://semver.org/}{语义版本}规范的 \hyperlink{16653194174751393225}{\texttt{VersionNumber}} 对象，因此由主、次、补丁号构成，后跟预发行 (pre-release) 和生成阿尔法数注释（build alpha-numeric）。例如，\texttt{v{\textquotedbl}0.2.1-rc1+win64{\textquotedbl}} 可分为主版本号 \texttt{0}，次版本号 \texttt{2}，补丁版本号 \texttt{1}，预发行版号 \texttt{rc1}，以及生成版本 \texttt{win64}。输入版本字面量时，除了主版本号以外所有内容都是可选的，因此 \texttt{v{\textquotedbl}0.2{\textquotedbl}} 等效于 \texttt{v{\textquotedbl}0.2.0{\textquotedbl}}（预发行号和生成注释为空），\texttt{v{\textquotedbl}2{\textquotedbl}} 等效于 \texttt{v{\textquotedbl}2.0.0{\textquotedbl}}，等等。



\texttt{VersionNumber} 对象在轻松正确地比较两个（或更多）版本时非常有用。例如，常数 \texttt{VERSION} 把 Julia 的版本号保留为一个 \texttt{VersionNumber} 对象，因此可以像下面这样用简单的声明定义一些特定版本的行为：




\begin{minted}{julia}
if v"0.2" <= VERSION < v"0.3-"
    # 针对 0.2 发行版系列做些事情
end
\end{minted}



注意在上例中用到了非标准版本号 \texttt{v{\textquotedbl}0.3-{\textquotedbl}}，其中有尾随符 \texttt{-}：这个符号是 Julia 标准的扩展，它可以用来表明低于任何 \texttt{0.3} 发行版的版本，包括所有的预发行版。所以上例中代码只能在稳定版本 \texttt{0.2} 上运行，而不能在 \texttt{v{\textquotedbl}0.3.0-rc1{\textquotedbl}} 这样的版本上运行。为了支持非稳定（即预发行）的 \texttt{0.2} 版本，下限检查应像这样应该改为：\texttt{v{\textquotedbl}0.2-{\textquotedbl} <= VERSION}。



另一个非标准版本规范扩展使得能够使用 \texttt{+} 来表示生成版本的上限，例如 \texttt{VERSION > v{\textquotedbl}0.2-rc1+{\textquotedbl}} 可以用来表示任意高于 \texttt{0.2-rc1} 和其任意生成版本的版本：它对 \texttt{v{\textquotedbl}0.2-rc1+win64{\textquotedbl}} 返回 \texttt{false} 而对 \texttt{v{\textquotedbl}0.2-rc2{\textquotedbl}} 返回 \texttt{true}。



在比较中使用这样的特殊版本是个好办法（特别是，总是应该对高版本使用尾随 \texttt{-}，除非有好理由不这样），但它们不应该被用作任何内容的实际版本，因为它们在语义版本控制方案中无效。



除了用于定义常数 \hyperlink{12605722316331458198}{\texttt{VERSION}}，\texttt{VersionNumber} 对象在 \texttt{Pkg} 模块应用广泛，常用于指定软件包的版本及其依赖。



\hypertarget{5096496368362976040}{}


\section{原始字符串字面量}



无插值和非转义的原始字符串可用 \texttt{raw{\textquotedbl}...{\textquotedbl}} 形式的非标准字符串字面量表示。原始字符串字面量生成普通的 \texttt{String} 对象，它无需插值和非转义地包含和输入完全一样的封闭式内容。这对于包含其他语言中使用 {\textquotedbl} 或 {\textbackslash}{\textquotedbl} 作为特殊字符的代码或标记的字符串很有用。



例外的是，引号仍必须转义，例如 \texttt{raw{\textquotedbl}{\textbackslash}{\textquotedbl}{\textquotedbl}} 等效于 \texttt{{\textquotedbl}{\textbackslash}{\textquotedbl}{\textquotedbl}}。为了能够表达所有字符串，反斜杠也必须转义，不过只是当它刚好出现在引号前面时。




\begin{minted}{jlcon}
julia> println(raw"\\ \\\"")
\\ \"
\end{minted}



请注意，前两个反斜杠在输出中逐字显示，这是因为它们不是在引号前面。然而，接下来的一个反斜杠字符转义了后面的一个反斜杠；又由于这些反斜杠出现在引号前面，最后一个反斜杠转义了一个引号。



\hypertarget{11836327794581856778}{}


\chapter{函数}



在 Julia 里，函数是将参数值组成的元组映射到返回值的一个对象。Julia 的函数不是纯粹的数学函数，因为这些函数可以改变程序的全局状态并且可能受其影响。在Julia中定义函数的基本语法是：




\begin{minted}{jlcon}
julia> function f(x,y)
           x + y
       end
f (generic function with 1 method)
\end{minted}



这个函数接收两个参数 \texttt{x} 和 \texttt{y} 并返回最后一个表达式的值，这里是 \texttt{x + y}。



在 Julia 中定义函数还有第二种更简洁的语法。上述的传统函数声明语法等效于以下紧凑性的“赋值形式”：




\begin{minted}{jlcon}
julia> f(x,y) = x + y
f (generic function with 1 method)
\end{minted}



尽管函数可以是复合表达式 (见 \hyperlink{14178955634857450370}{复合表达式})，但在赋值形式下，函数体必须是一个一行的表达式。简短的函数定义在 Julia 中是很常见的。非常惯用的短函数语法大大减少了打字和视觉方面的干扰。



使用传统的括号语法调用函数：




\begin{minted}{jlcon}
julia> f(2,3)
5
\end{minted}



没有括号时，表达式 \texttt{f} 指的是函数对象，可以像任何值一样被传递：




\begin{minted}{jlcon}
julia> g = f;

julia> g(2,3)
5
\end{minted}



和变量名一样，Unicode 字符也可以用作函数名：




\begin{minted}{jlcon}
julia> ∑(x,y) = x + y
∑ (generic function with 1 method)

julia> ∑(2, 3)
5
\end{minted}



\hypertarget{7147748673565495429}{}


\section{参数传递行为}



Julia 函数参数遵循有时称为 “pass-by-sharing” 的约定，这意味着变量在被传递给函数时其值并不会被复制。函数参数本身充当新的变量绑定（指向变量值的新地址），它们所指向的值与所传递变量的值完全相同。调用者可以看到对函数内可变值（如数组）的修改。这与 Scheme，大多数 Lisps，Python，Ruby 和 Perl 以及其他动态语言中的行为相同。



\hypertarget{7197754808287110454}{}


\section{参数类型声明}



您可以通过将 \texttt{::TypeName} 附加到参数名称来声明函数参数的类型，就像 Julia 中的 \href{@ref Type-Declarations}{类型声明} 一样。 例如，以下函数递归计算 \href{https://en.wikipedia.org/wiki/Fibonacci\_number}{斐波那契数列}：




\begin{lstlisting}
fib(n::Integer) = n ≤ 2 ? one(n) : fib(n-1) + fib(n-2)
\end{lstlisting}



并且 \texttt{::Integer} 规范意味着它只有在 \texttt{n} 是 \hyperlink{1549354324836889217}{抽象} \texttt{Integer} 类型的子类型时才可调用。



参数类型声明\textbf{通常对性能没有影响}：无论声明什么参数类型（如果有），Julia 都会为实际参数类型编译函数的特例版本。 例如，调用 \texttt{fib(1)} 将触发专门为 \texttt{Int} 参数优化的特例化的\texttt{fib} 的编译，它会在 \texttt{fib(7)} 或 \texttt{fib(15)} 调用时重新使用。 （参数类型声明不触发额外的编译器特化的情况很少；请参阅：\hyperlink{1848188334990571431}{注意 Julia 何时不触发特例化}。）在 Julia 中声明参数类型的最常见原因是：



\begin{itemize}
\item \textbf{派发：} 如 \hyperlink{3842379394166369470}{方法} 中所述，对于不同的参数类型，你可以有不同版本（“方法”）的函数，在这种情况下，参数类型用于确定调用哪个版本的函数。例如，你可以使用 \href{https://en.wikipedia.org/wiki/Fibonacci\_number\#Binet{\textquotesingle}s\_formula}{Binet 公式} 实现一个完全不同的算法 \texttt{fib(x::Number) = ...}，该算法扩展为了非整数值，适用于任何 \texttt{Number} 类型。


\item \textbf{正确性：} 如果函数只为某些参数类型返回正确的结果，则类型声明会很有用。例如，如果我们省略参数类型并写成 \texttt{fib(n) = n ≤ 2 ? one(n) : fib(n-1) + fib(n-2)}，然后\texttt{fib(1.5)}会默默地给我们无意义的答案\texttt{1.0}。


\item \textbf{清晰性：} 类型声明可以作为一种关于预期参数的文档形式。

\end{itemize}


但是，\textbf{过分限制参数类型是常见的错误}，这会不必要地限制函数的适用性，并防止它在未预料到的情况下被重用。例如，上面的 \texttt{fib(n::Integer)} 函数同样适用于 \texttt{Int} 参数（机器整数）和 \texttt{BigInt} 任意精度整数（参见 \hyperlink{18371658222475313580}{BigFloats 和 BigInts}），这样十分有效，因为斐波那契数以指数方式快速增长，并且会迅速溢出任何固定精度类型，如 \texttt{Int}（参见 \hyperlink{10689991880086615284}{溢出行为}）。但是，如果我们将函数声明为 \texttt{fib(n::Int)}，那么 \texttt{BigInt} 的应用就会被阻止。通常，应该对参数使用最通用的适用抽象类型，并且\textbf{如有不确定，就省略参数类型}。如果有必要，你可以随时添加参数类型规范，并且不会因为省略它们而牺牲性能或功能。



\hypertarget{8101712267958021215}{}


\section{\texttt{return} 关键字}



函数返回的值是最后计算的表达式的值，默认情况下，它是函数定义主体中的最后一个表达式。在上一小节的示例函数 \texttt{f} 中，返回值是表达式的 \texttt{x + y} 值。与在 C 语言和大多数其他命令式或函数式语言中一样，\texttt{return} 关键字会让函数立即返回，从而提供返回值的表达式：




\begin{minted}{julia}
function g(x,y)
    return x * y
    x + y
end
\end{minted}



由于函数定义可以输入到交互式会话中，因此可以很容易的比较这些定义：




\begin{minted}{jlcon}
julia> f(x,y) = x + y
f (generic function with 1 method)

julia> function g(x,y)
           return x * y
           x + y
       end
g (generic function with 1 method)

julia> f(2,3)
5

julia> g(2,3)
6
\end{minted}



当然，在一个单纯的线性执行的函数体内，例如 \texttt{g}，使用 \texttt{return} 是没有意义的，因为表达式 \texttt{x + y} 永远不会被执行到，我们可以简单地把 \texttt{x * y} 写为最后一个表达式从而省略掉 \texttt{return}。 然而在使用其他控制流程的函数体内，\texttt{return} 却是有用的。 例如，在计算两条边长分别为 \texttt{x} 和 \texttt{y} 的三角形的斜边长度时可以避免溢出：




\begin{minted}{jlcon}
julia> function hypot(x,y)
           x = abs(x)
           y = abs(y)
           if x > y
               r = y/x
               return x*sqrt(1+r*r)
           end
           if y == 0
               return zero(x)
           end
           r = x/y
           return y*sqrt(1+r*r)
       end
hypot (generic function with 1 method)

julia> hypot(3, 4)
5.0
\end{minted}



这个函数有三个可能的返回处，返回三个不同表达式的值，具体取决于 \texttt{x} 和 \texttt{y} 的值。 最后一行的 \texttt{return} 可以省略，因为它是最后一个表达式。



\hypertarget{3145756716608098346}{}


\subsection{返回类型}



也可以使用 \texttt{::} 运算符在函数声明中指定返回类型。 这可以将返回值转换为指定的类型。




\begin{minted}{jlcon}
julia> function g(x, y)::Int8
           return x * y
       end;

julia> typeof(g(1, 2))
Int8
\end{minted}



这个函数将忽略 \texttt{x} 和 \texttt{y} 的类型，返回 \texttt{Int8} 类型的值。有关返回类型的更多信息，请参见\href{@ref Type-Declarations}{类型声明}。



返回类型声明在 Julia 中\textbf{很少使用}：通常，你应该编写“类型稳定”的函数，Julia 的编译器可以在其中自动推断返回类型。更多信息请参阅 \hyperlink{818954303942149020}{性能提示} 一章。



\hypertarget{4035355918680861810}{}


\subsection{返回 nothing}



对于不需要任何返回值的函数（只用来产生副作用的函数）， Julia 中的写法为返回值\hyperlink{9331422207248206047}{\texttt{nothing}}:




\begin{minted}{julia}
function printx(x)
    println("x = $x")
    return nothing
end
\end{minted}



这在某种意义上是一个“惯例”，在 Julia 中 \texttt{nothing} 不是一个关键字，而是 \texttt{Nothing} 类型的一个单例（singleton）。 也许你已经注意到 \texttt{printx} 函数有点不自然，因为 \texttt{println} 实际上已经会返回 \texttt{nothing}，所以 \texttt{return} 语句是多余的。



有两种比 \texttt{return nothing} 更短的写法：一种是直接写 \texttt{return} 这会隐式的返回 \texttt{nothing}。 另一种是在函数的会后一行写上 \texttt{nothing}，因为函数会隐式的返回最后一个表达式的值。 三种写法使用哪一种取决于代码风格的偏好。



\hypertarget{6095699413160695994}{}


\section{操作符也是函数}



在 Julia中，大多数操作符只不过是支持特殊语法的函数（ \texttt{\&\&} 和\texttt{||} 等具有特殊评估语义的操作符除外，他们不能是函数，因为\hyperlink{7551496361738057869}{短路求值}要求在计算整个表达式的值之前不计算每个操作数）。因此，您也可以使用带括号的参数列表来使用它们，就和任何其他函数一样：




\begin{minted}{jlcon}
julia> 1 + 2 + 3
6

julia> +(1,2,3)
6
\end{minted}



中缀表达式和函数形式完全等价。—— 事实上，前一种形式会被编译器转换为函数调用。这也意味着你可以对操作符，例如 \hyperlink{3677358729494553841}{\texttt{+}} 和 \hyperlink{5498506958944335098}{\texttt{*}} ，进行赋值和传参，就像其它函数传参一样。




\begin{minted}{jlcon}
julia> f = +;

julia> f(1,2,3)
6
\end{minted}



然而，函数以\texttt{f}命名时不再支持中缀表达式。



\hypertarget{11001836393552529826}{}


\section{具有特殊名称的操作符}



有一些特殊的表达式对应的函数调用没有显示的函数名称，它们是：




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
表达式 & 函数调用 \\
\hline
\texttt{[A B C ...]} & \hyperlink{8862791894748483563}{\texttt{hcat}} \\
\hline
\texttt{[A; B; C; ...]} & \hyperlink{14691815416955507876}{\texttt{vcat}} \\
\hline
\texttt{[A B; C D; ...]} & \hyperlink{16279083053557795116}{\texttt{hvcat}} \\
\hline
\texttt{A{\textquotesingle}} & \hyperlink{10565518144285607255}{\texttt{adjoint}} \\
\hline
\texttt{A[i]} & \hyperlink{13720608614876840481}{\texttt{getindex}} \\
\hline
\texttt{A[i] = x} & \hyperlink{1309244355901386657}{\texttt{setindex!}} \\
\hline
\texttt{A.n} & \hyperlink{11040282462516403506}{\texttt{getproperty}} \\
\hline
\texttt{A.n = x} & \hyperlink{9055518433069578344}{\texttt{setproperty!}} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{8300730259363458305}{}


\section{匿名函数}



函数在Julia里是\href{https://en.wikipedia.org/wiki/First-class\_citizen}{一等公民}：可以指定给变量，并使用标准函数调用语法通过被指定的变量调用。函数可以用作参数，也可以当作返回值。函数也可以不带函数名称地匿名创建，使用语法如下：




\begin{minted}{jlcon}
julia> x -> x^2 + 2x - 1
#1 (generic function with 1 method)

julia> function (x)
           x^2 + 2x - 1
       end
#3 (generic function with 1 method)
\end{minted}



这样就创建了一个接受一个参数 \texttt{x} 并返回当前值的多项式 \texttt{x{\textasciicircum}2+2x-1} 的函数。注意结果是个泛型函数，但是带了编译器生成的连续编号的名字。



匿名函数最主要的用法是传递给接收函数作为参数的函数。一个经典的例子是 \hyperlink{11483231213869150535}{\texttt{map}} ，为数组的每个元素应用一次函数，然后返回一个包含结果值的新数组：




\begin{minted}{jlcon}
julia> map(round, [1.2, 3.5, 1.7])
3-element Vector{Float64}:
 1.0
 4.0
 2.0
\end{minted}



如果做为第一个参数传递给 \hyperlink{11483231213869150535}{\texttt{map}} 的转换函数已经存在，那直接使用函数名称是没问题的。但是通常要使用的函数还没有定义好，这样使用匿名函数就更加方便：




\begin{minted}{jlcon}
julia> map(x -> x^2 + 2x - 1, [1, 3, -1])
3-element Vector{Int64}:
  2
 14
 -2
\end{minted}



接受多个参数的匿名函数写法可以使用语法 \texttt{(x,y,z)->2x+y-z}，而无参匿名函数写作 \texttt{()->3} 。无参函数的这种写法看起来可能有些奇怪，不过它对于延迟计算很有必要。这种用法会把代码块包进一个无参函数中，后续把它当做 \texttt{f} 调用。



例如，考虑对 \hyperlink{282460992333585641}{\texttt{get}} 的调用：




\begin{minted}{julia}
get(dict, key) do
    # default value calculated here
    time()
end
\end{minted}



上面的代码等效于使用包含代码的匿名函数调用\texttt{get}。 被包围在do和end之间，如下所示




\begin{minted}{julia}
get(()->time(), dict, key)
\end{minted}



这里对 \hyperlink{2441622941271736623}{\texttt{time}} 的调用，被包裹了它的一个无参数的匿名函数延迟了。该匿名函数只当 \texttt{dict} 缺少被请求的键时，才被调用。



\hypertarget{9218398227562398910}{}


\section{元组}



Julia 有一个和函数参数与返回值密切相关的内置数据结构叫做元组（\emph{tuple}）。 一个元组是一个固定长度的容器，可以容纳任何值，但不可以被修改(是\emph{immutable}的)。 元组通过圆括号和逗号来构造，其内容可以通过索引来访问：




\begin{minted}{jlcon}
julia> (1, 1+1)
(1, 2)

julia> (1,)
(1,)

julia> x = (0.0, "hello", 6*7)
(0.0, "hello", 42)

julia> x[2]
"hello"
\end{minted}



注意，长度为1的元组必须使用逗号 \texttt{(1,)}，而 \texttt{(1)} 只是一个带括号的值。\texttt{()} 表示空元组（长度为0）。



\hypertarget{14936898299796428859}{}


\section{具名元组}



元组的元素可以有名字，这时候就有了\emph{具名元组}：




\begin{minted}{jlcon}
julia> x = (a=2, b=1+2)
(a = 2, b = 3)

julia> x[1]
2

julia> x.a
2
\end{minted}



具名元组和元组十分类似，区别在于除了一般的下标语法（\texttt{x[1]}），还可以使用点运算符语法（\texttt{x.a}）通过元素的名字来访问它的元素。



\hypertarget{14913135952669439020}{}


\section{解构赋值和多返回值}



逗号分隔的变量列表（可选地用括号括起来）可以出现在赋值的左侧：右侧的值通过迭代并依次分配给每个变量来\emph{解构}：




\begin{minted}{jlcon}
julia> (a,b,c) = 1:3
1:3

julia> b
2
\end{minted}



右边的值应该是一个至少与左边的变量数量一样长的迭代器（参见\hyperlink{3897660032678469808}{迭代接口}）（迭代器的任何多余元素会被忽略）。



可用于通过返回元组或其他可迭代值从函数返回多个值。例如，以下函数返回两个值：




\begin{minted}{jlcon}
julia> function foo(a,b)
           a+b, a*b
       end
foo (generic function with 1 method)
\end{minted}



如果你在交互式会话中调用它且不把返回值赋值给任何变量，你会看到返回的元组：




\begin{minted}{jlcon}
julia> foo(2,3)
(5, 6)
\end{minted}



解构赋值将每个值提取到一个变量中：




\begin{minted}{jlcon}
julia> x, y = foo(2,3)
(5, 6)

julia> x
5

julia> y
6
\end{minted}



另一个常见用途是交换变量：




\begin{minted}{jlcon}
julia> y, x = x, y
(5, 6)

julia> x
6

julia> y
5
\end{minted}



如果只需要迭代器元素的一个子集，一个常见的惯例是将忽略的元素分配给一个只包含下划线 \texttt{\_} 的变量（这是一个无效的变量名，请参阅 [合法的变量名]（@ref man -allowed-variable-names)):




\begin{minted}{jlcon}
julia> _, _, _, d = 1:10
1:10

julia> d
4
\end{minted}



其他有效的左侧表达式可以用作赋值列表的元素，它们将调用 \hyperlink{1309244355901386657}{\texttt{setindex!}} 或 \hyperlink{9055518433069578344}{\texttt{setproperty!}}，或者递归地解构迭代器的各个元素：




\begin{minted}{jlcon}
julia> X = zeros(3);

julia> X[1], (a,b) = (1, (2, 3))
(1, (2, 3))

julia> X
3-element Vector{Float64}:
 1.0
 0.0
 0.0

julia> a
2

julia> b
3
\end{minted}



\begin{quote}
\textbf{Julia 1.6}

带 \texttt{...} 的赋值需要 Julia 1.6

\end{quote}


如果赋值列表中的最后一个符号后缀为 \texttt{...}（称为 \emph{slurping}），那么它将被分配给右侧迭代器剩余元素的集合或其惰性迭代器：




\begin{minted}{jlcon}
julia> a, b... = "hello"
"hello"

julia> a
'h': ASCII/Unicode U+0068 (category Ll: Letter, lowercase)

julia> b
"ello"

julia> a, b... = Iterators.map(abs2, 1:4)
Base.Generator{UnitRange{Int64}, typeof(abs2)}(abs2, 1:4)

julia> a
1

julia> b
Base.Iterators.Rest{Base.Generator{UnitRange{Int64}, typeof(abs2)}, Int64}(Base.Generator{UnitRange{Int64}, typeof(abs2)}(abs2, 1:4), 1)
\end{minted}



有关特定迭代器的精确处理和自定义的详细信息，请参阅 \hyperlink{16112033990685296573}{\texttt{Base.rest}}。



\hypertarget{13913778167558632631}{}


\section{参数解构}



析构特性也可以被用在函数参数中。 如果一个函数的参数被写成了元组形式 (如  \texttt{(x, y)}) 而不是简单的符号，那么一个赋值运算 \texttt{(x, y) = argument} 将会被默认插入：




\begin{minted}{julia}
julia> minmax(x, y) = (y < x) ? (y, x) : (x, y)

julia> gap((min, max)) = max - min

julia> gap(minmax(10, 2))
8
\end{minted}



注意在定义函数 \texttt{gap} 时额外的括号。 没有它们，\texttt{gap} 函数将会是一个双参数函数，这个例子也会无法正常运行。



对于匿名函数，解构单个元组需要一个额外的逗号：




\begin{lstlisting}
julia> map(((x,y),) -> x + y, [(1,2), (3,4)])
2-element Array{Int64,1}:
 3
 7
\end{lstlisting}



\hypertarget{2609189760420802889}{}


\section{变参函数}



定义有任意个参数的函数会带来很多便利。这类函数通常被称为“变参”函数，即“参数数量可变”的简称。你可以通过在最后一个参数后增加省略号来定义一个变参函数:




\begin{minted}{jlcon}
julia> bar(a,b,x...) = (a,b,x)
bar (generic function with 1 method)
\end{minted}



变量 \texttt{a} 和 \texttt{b} 和以前一样被绑定给前两个参数，后面的参数整个做为迭代集合被绑定到变量 \texttt{x} 上 :




\begin{minted}{jlcon}
julia> bar(1,2)
(1, 2, ())

julia> bar(1,2,3)
(1, 2, (3,))

julia> bar(1, 2, 3, 4)
(1, 2, (3, 4))

julia> bar(1,2,3,4,5,6)
(1, 2, (3, 4, 5, 6))
\end{minted}



在所有这些情况下，\texttt{x} 被绑定到传递给 \texttt{bar} 的尾随值的元组。



也可以限制可以传递给函数的参数的数量，这部分内容稍后在  \hyperlink{14394864568540094383}{参数化约束的可变参数方法}  中讨论。



另一方面，将可迭代集中包含的值拆解为单独的参数进行函数调用通常很方便。 要实现这一点，需要在函数调用中额外使用 \texttt{...} 而不仅仅只是变量：




\begin{minted}{jlcon}
julia> x = (3, 4)
(3, 4)

julia> bar(1,2,x...)
(1, 2, (3, 4))
\end{minted}



在这个情况下一组值会被精确切片成一个可变参数调用，这里参数的数量是可变的。但是并不需要成为这种情况：




\begin{minted}{jlcon}
julia> x = (2, 3, 4)
(2, 3, 4)

julia> bar(1,x...)
(1, 2, (3, 4))

julia> x = (1, 2, 3, 4)
(1, 2, 3, 4)

julia> bar(x...)
(1, 2, (3, 4))
\end{minted}



进一步，拆解给函数调用中的可迭代对象不需要是个元组：




\begin{minted}{jlcon}
julia> x = [3,4]
2-element Vector{Int64}:
 3
 4

julia> bar(1,2,x...)
(1, 2, (3, 4))

julia> x = [1,2,3,4]
4-element Vector{Int64}:
 1
 2
 3
 4

julia> bar(x...)
(1, 2, (3, 4))
\end{minted}



此外，参数被放入的函数不一定是可变参数函数（尽管经常是）：




\begin{minted}{jlcon}
julia> baz(a,b) = a + b;

julia> args = [1,2]
2-element Vector{Int64}:
 1
 2

julia> baz(args...)
3

julia> args = [1,2,3]
3-element Vector{Int64}:
 1
 2
 3

julia> baz(args...)
ERROR: MethodError: no method matching baz(::Int64, ::Int64, ::Int64)
Closest candidates are:
  baz(::Any, ::Any) at none:1
\end{minted}



正如你所见，如果要拆解的容器（比如元组或数组）元素数量不匹配就会报错，和直接给多个参数报错一样。



\hypertarget{16207703858977287144}{}


\section{可选参数}



在很多情况下，函数参数有合理的默认值，因此也许不需要显式地传递。例如，\texttt{Dates} 模块中的 \hyperlink{4488183467971164548}{\texttt{Date(y, [m, d])}} 函数对于给定的年（year）\texttt{y}、月（mouth）\texttt{m}、日（data）\texttt{d} 构造了 \texttt{Date} 类型。但是，\texttt{m} 和 \texttt{d} 参数都是可选的，默认值都是 \texttt{1}。这行为可以简述为：




\begin{minted}{julia}
function Date(y::Int64, m::Int64=1, d::Int64=1)
    err = validargs(Date, y, m, d)
    err === nothing || throw(err)
    return Date(UTD(totaldays(y, m, d)))
end
\end{minted}



注意，这个定义调用了 \texttt{Date} 函数的另一个方法，该方法带有一个 \texttt{UTInstant\{Day\}} 类型的参数。



通过此定义，函数调用时可以带有一个、两个或三个参数，并且在只有一个或两个参数被指定时后，自动传递 \texttt{1} 为未指定参数值：




\begin{minted}{jlcon}
julia> using Dates

julia> Date(2000, 12, 12)
2000-12-12

julia> Date(2000, 12)
2000-12-01

julia> Date(2000)
2000-01-01
\end{minted}



可选参数实际上只是一种方便的语法，用于编写多种具有不同数量参数的方法定义（请参阅 \hyperlink{15680937628543940678}{可选参数和关键字的参数的注意事项}）。这可通过调用 \texttt{methods} 函数来检查我们的 \texttt{Date} 函数示例。



\hypertarget{8084690442149965313}{}


\section{关键字参数}



某些函数需要大量参数，或者具有大量行为。记住如何调用这样的函数可能很困难。关键字参数允许通过名称而不是仅通过位置来识别参数，使得这些复杂接口易于使用和扩展。



例如，考虑绘制一条线的函数 \texttt{plot}。这个函数可能有很多选项，用来控制线条的样式、宽度、颜色等。如果它接受关键字参数，一个可行的调用可能看起来像 \texttt{plot(x, y, width=2)}，这里我们仅指定线的宽度。请注意，这样做有两个目的。调用更可读，因为我们能以其意义标记参数。也使得大量参数的任意子集都能以任意次序传递。



具有关键字参数的函数在签名中使用分号定义：




\begin{minted}{julia}
function plot(x, y; style="solid", width=1, color="black")
    ###
end
\end{minted}



在函数调用时，分号是可选的：可以调用 \texttt{plot(x, y, width=2)} 或 \texttt{plot(x, y; width=2)}，但前者的风格更为常见。显式的分号只有在传递可变参数或下文中描述的需计算的关键字时是必要的。



关键字参数的默认值只在必需时求值（当相应的关键字参数没有被传入），并且按从左到右的顺序求值，因为默认值的表达式可能会参照先前的关键字参数。



关键字参数的类型可以通过如下的方式显式指定：




\begin{minted}{julia}
function f(;x::Int=1)
    ###
end
\end{minted}



关键字参数也可以在变参函数中使用：




\begin{minted}{julia}
function plot(x...; style="solid")
    ###
end
\end{minted}



附加的关键字参数可用 \texttt{...} 收集，正如在变参函数中：




\begin{minted}{julia}
function f(x; y=0, kwargs...)
    ###
end
\end{minted}



在 \texttt{f} 中，\texttt{kwargs} 将是一个在命名元组上的不可变键值迭代器。 具名元组（以及带有\texttt{Symbol}键的字典）可以在调用中使用分号作为关键字参数传递，例如 \texttt{f(x, z=1; kwargs...)}。



如果一个关键字参数在方法定义中未指定默认值，那么它就是\emph{必需的}：如果调用者没有为其赋值，那么将会抛出一个 \hyperlink{14325831233857471256}{\texttt{UndefKeywordError}} 异常：




\begin{minted}{julia}
function f(x; y)
    ###
end
f(3, y=5) # ok, y is assigned
f(3)      # throws UndefKeywordError(:y)
\end{minted}



在分号后也可传递 \texttt{key => value} 表达式。例如，\texttt{plot(x, y; :width => 2)} 等价于 \texttt{plot(x, y, width=2)}。当关键字名称需要在运行时被计算时，这就很实用了。



当分号后出现裸标识符或点表达式时，标识符或字段名称隐含关键字参数名称。 例如\texttt{plot(x, y; width)} 等价于\texttt{plot(x, y; width=width)}，\texttt{plot(x, y; options.width)} 等价于\texttt{plot(x, y; width=options.width)}。



可选参数的性质使得可以多次指定同一参数的值。例如，在调用 \texttt{plot(x, y; options..., width=2)} 的过程中，\texttt{options} 结构也能包含一个 \texttt{width} 的值。在这种情况下，最右边的值优先级最高；在此例中，\texttt{width} 的值可以确定是 \texttt{2}。但是，显式地多次指定同一参数的值是不允许的，例如 \texttt{plot(x, y, width=2, width=3)}，这会导致语法错误。



\hypertarget{5412457164020493169}{}


\section{默认值作用域的计算}



当计算可选和关键字参数的默认值表达式时，只有\emph{先前}的参数才在作用域内。例如，给出以下定义：




\begin{minted}{julia}
function f(x, a=b, b=1)
    ###
end
\end{minted}



\texttt{a=b} 中的 \texttt{b} 指的是外部作用域内的 \texttt{b}，而不是后续参数中的 \texttt{b}。



\hypertarget{1892968097837414739}{}


\section{函数参数中的 Do 结构}



把函数作为参数传递给其他函数是一种强大的技术，但它的语法并不总是很方便。当函数参数占据多行时，这样的调用便特别难以编写。例如，考虑在具有多种情况的函数上调用 \hyperlink{11483231213869150535}{\texttt{map}}：




\begin{minted}{julia}
map(x->begin
           if x < 0 && iseven(x)
               return 0
           elseif x == 0
               return 1
           else
               return x
           end
       end,
    [A, B, C])
\end{minted}



Julia 提供了一个保留字 \texttt{do}，用于更清楚地重写此代码：




\begin{minted}{julia}
map([A, B, C]) do x
    if x < 0 && iseven(x)
        return 0
    elseif x == 0
        return 1
    else
        return x
    end
end
\end{minted}



\texttt{do x} 语法创建一个带有参数 \texttt{x} 的匿名函数，并将其作为第一个参数传递给 \hyperlink{11483231213869150535}{\texttt{map}}。 类似地，\texttt{do a,b} 将创建一个有两个参数的匿名函数。 请注意，\texttt{do (a,b)} 将创建一个单参数匿名函数，其参数是一个要解构的元组。 一个简单的 \texttt{do} 会声明接下来是一个形式为 \texttt{() -> ...} 的匿名函数。



这些参数如何初始化取决于「外部」函数；在这里，\hyperlink{11483231213869150535}{\texttt{map}} 将会依次将 \texttt{x} 设置为 \texttt{A}、\texttt{B}、\texttt{C}，再分别调用调用匿名函数，正如在 \texttt{map(func, [A, B, C])} 语法中所发生的。



这种语法使得更容易使用函数来有效地扩展语言，因为调用看起来就像普通代码块。有许多可能的用法与 \hyperlink{11483231213869150535}{\texttt{map}} 完全不同，比如管理系统状态。例如，有一个版本的 \hyperlink{300818094931158296}{\texttt{open}} 可以通过运行代码来确保已经打开的文件最终会被关闭：




\begin{minted}{julia}
open("outfile", "w") do io
    write(io, data)
end
\end{minted}



这是通过以下定义实现的：




\begin{minted}{julia}
function open(f::Function, args...)
    io = open(args...)
    try
        f(io)
    finally
        close(io)
    end
end
\end{minted}



在这里，\hyperlink{300818094931158296}{\texttt{open}} 首先打开要写入的文件，接着将结果输出流传递给你在 \texttt{do ... end} 代码快中定义的匿名函数。在你的函数退出后，\hyperlink{300818094931158296}{\texttt{open}} 将确保流被正确关闭，无论你的函数是正常退出还是抛出了一个异常（\texttt{try/finally} 结构会在 \hyperlink{6880586223574224557}{流程控制} 中描述）。



使用 \texttt{do} 代码块语法时，查阅文档或实现有助于了解用户函数的参数是如何初始化的。



类似于其他的内部函数， \texttt{do} 代码块也可以“捕获”上一个作用域的变量。例如，上一个 \texttt{open...do} 的例子中变量 \texttt{data} 是从外部作用域捕获的。捕获变量可能会给性能优化带来挑战，详见 \hyperlink{627547588659365489}{性能建议}。



\hypertarget{3483234324604369167}{}


\section{函数的复合与链式调用}



Julia中的多个函数可以用函数复合或管道连接（链式调用）组合起来。



函数的复合指的是把多个函数绑定到一起，然后作用于最先调用那个函数的参数。 你可以使用函数复合运算符 (\texttt{∘}) 来组合函数，这样一来 \texttt{(f ∘ g)(args...)} 就等价于 \texttt{f(g(args...))}.



你可以在REPL和合理配置的编辑器中用 \texttt{{\textbackslash}circ<tab>} 输入函数复合运算符。



例如， \texttt{sqrt} 和 \texttt{+} 可以用下面这种方式组合：




\begin{minted}{jlcon}
julia> (sqrt ∘ +)(3, 6)
3.0
\end{minted}



这个语句先把数字相加，再对结果求平方根。



下一个例子组合了三个函数并把新函数作用到一个字符串组成的数组上：




\begin{minted}{jlcon}
julia> map(first ∘ reverse ∘ uppercase, split("you can compose functions like this"))
6-element Vector{Char}:
 'U': ASCII/Unicode U+0055 (category Lu: Letter, uppercase)
 'N': ASCII/Unicode U+004E (category Lu: Letter, uppercase)
 'E': ASCII/Unicode U+0045 (category Lu: Letter, uppercase)
 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)
 'E': ASCII/Unicode U+0045 (category Lu: Letter, uppercase)
 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)
\end{minted}



函数的链式调用（有时也称“使用管道”把数据送到一系列函数中去）指的是把一个函数作用到前一个函数的输出上：




\begin{minted}{jlcon}
julia> 1:10 |> sum |> sqrt
7.416198487095663
\end{minted}



在这里， \texttt{sum} 函数求出的和被传递到 \texttt{sqrt} 函数作为参数。等价的函数复合写法是：




\begin{minted}{jlcon}
julia> (sqrt ∘ sum)(1:10)
7.416198487095663
\end{minted}



管道运算符还可以和广播一起使用（\texttt{.|>}），这提供了一个有用的链式调用/管道+向量化运算的组合语法（接下来将描述）。




\begin{minted}{jlcon}
julia> ["a", "list", "of", "strings"] .|> [uppercase, reverse, titlecase, length]
4-element Vector{Any}:
  "A"
  "tsil"
  "Of"
 7
\end{minted}



\hypertarget{13590013989415065742}{}


\section{向量化函数的点语法}



在科学计算语言中，通常会有函数的「向量化」版本，它简单地将给定函数 \texttt{f(x)} 作用于数组 \texttt{A} 的每个元素，接着通过 \texttt{f(A)} 生成一个新数组。这种语法便于数据处理，但在其它语言中，向量化通常也是性能所需要的：如果循环很慢，函数的「向量化」版本可以调用由低级语言编写的、快速的库代码。在 Julia 中，向量化函数\emph{不}是性能所必需的，实际上编写自己的循环通常也是有益的（请参阅 \hyperlink{818954303942149020}{Performance Tips}），但它们仍然很方便。因此，\emph{任何} Julia 函数 \texttt{f} 能够以元素方式作用于任何数组（或者其它集合），这通过语法 \texttt{f.(A)} 实现。例如，\texttt{sin} 可以作用于向量 \texttt{A} 中的所有元素，如下所示：




\begin{minted}{jlcon}
julia> A = [1.0, 2.0, 3.0]
3-element Vector{Float64}:
 1.0
 2.0
 3.0

julia> sin.(A)
3-element Vector{Float64}:
 0.8414709848078965
 0.9092974268256817
 0.1411200080598672
\end{minted}



当然，你如果为 \texttt{f} 编写了一个专门的「向量化」方法，例如通过 \texttt{f(A::AbstractArray) = map(f, A)}，可以省略点号，这和 \texttt{f.(A)} 一样高效。但这种方法要求你事先决定要进行向量化的函数。



更一般地，\texttt{f.(args...)} 实际上等价于 \texttt{broadcast(f, args...)}，它允许你操作多个数组（甚至是不同形状的），或是数组和标量的混合（请参阅 \hyperlink{1924664524817847375}{Broadcasting}）。例如，如果有 \texttt{f(x,y) = 3x + 4y}，那么 \texttt{f.(pi,A)} 将为 \texttt{A} 中的每个 \texttt{a} 返回一个由 \texttt{f(pi,a)} 组成的新数组，而 \texttt{f.(vector1,vector2)} 将为每个索引 \texttt{i} 返回一个由 \texttt{f(vector1[i],vector2[i])} 组成的新向量（如果向量具有不同的长度则会抛出异常）。




\begin{minted}{jlcon}
julia> f(x,y) = 3x + 4y;

julia> A = [1.0, 2.0, 3.0];

julia> B = [4.0, 5.0, 6.0];

julia> f.(pi, A)
3-element Vector{Float64}:
 13.42477796076938
 17.42477796076938
 21.42477796076938

julia> f.(A, B)
3-element Vector{Float64}:
 19.0
 26.0
 33.0
\end{minted}



此外，\emph{嵌套的} \texttt{f.(args...)} 调用会被\emph{融合}到一个 \texttt{broadcast} 循环中。例如，\texttt{sin.(cos.(X))} 等价于 \texttt{broadcast(x -> sin(cos(x)), X)}，类似于 \texttt{[sin(cos(x)) for x in X]}：在 \texttt{X} 上只有一个循环，并且只为结果分配了一个数组。[ 相反，在典型的「向量化」语言中，\texttt{sin(cos(X))} 首先会为 \texttt{tmp=cos(X)} 分配第一个临时数组，然后在单独的循环中计算 \texttt{sin(tmp)}，再分配第二个数组。] 这种循环融合不是可能发生也可能不发生的编译器优化，只要遇到了嵌套的 \texttt{f.(args...)} 调用，它就是一个\emph{语法保证}。技术上，一旦遇到「非点」函数调用，融合就会停止；例如，在 \texttt{sin.(sort(cos.(X)))} 中，由于插入的 \texttt{sort} 函数，\texttt{sin} 和 \texttt{cos} 无法被合并。



最后，最大效率通常在向量化操作的输出数组被\emph{预分配}时实现，这样重复调用就不会一次又一次地为结果分配新数组（请参阅 \href{@ref}{输出预分配}）。一个方便的语法是 \texttt{X .= ...}，它等价于 \texttt{broadcast!(identity, X, ...)}，除了上面提到的，\texttt{broadcast!} 循环可与任何嵌套的「点」调用融合。例如，\texttt{X .= sin.(Y)} 等价于 \texttt{broadcast!(sin, X, Y)}，用 \texttt{sin.(Y)} in-place 覆盖 \texttt{X}。如果左边是数组索引表达式，例如 \texttt{X[2:end] .= sin.(Y)}，那就将 \texttt{broadcast!} 转换在一个 \texttt{view} 上，例如 \texttt{broadcast!(sin, view(X, 2:lastindex(X)), Y)}，这样左侧就被 in-place 更新了。



由于在表达式中为许多操作和函数调用添加点可能很乏味并导致难以阅读的代码，宏 \hyperlink{16688502228717894452}{\texttt{@.}} 用于将表达式中的\emph{每个}函数调用、操作和赋值转换为「点」版本。




\begin{minted}{jlcon}
julia> Y = [1.0, 2.0, 3.0, 4.0];

julia> X = similar(Y); # pre-allocate output array

julia> @. X = sin(cos(Y)) # equivalent to X .= sin.(cos.(Y))
4-element Vector{Float64}:
  0.5143952585235492
 -0.4042391538522658
 -0.8360218615377305
 -0.6080830096407656
\end{minted}



像 \texttt{.+} 这样的二元（或一元）运算符使用相同的机制进行管理：它们等价于 \texttt{broadcast} 调用且可与其它嵌套的「点」调用融合。\texttt{X .+= Y} 等等价于 \texttt{X .= X .+ Y}，结果为一个融合的 in-place 赋值；另见 \hyperlink{15967322336376951940}{dot operators}。



您也可以使用 \hyperlink{5135459825603202944}{\texttt{|>}} 将点操作与函数链组合在一起，如本例所示：




\begin{minted}{jlcon}
julia> [1:5;] .|> [x->x^2, inv, x->2*x, -, isodd]
5-element Vector{Real}:
    1
    0.5
    6
   -4
 true
\end{minted}



\hypertarget{17965614568943116111}{}


\section{更多阅读}



我们应该在这里提到，这远不是定义函数的完整图景。Julia 拥有一个复杂的类型系统并且允许对参数类型进行多重分派。这里给出的示例都没有为它们的参数提供任何类型注释，意味着它们可以作用于任何类型的参数。类型系统在\hyperlink{8510890508040013186}{类型}中描述，而\hyperlink{3842379394166369470}{方法}则描述了根据运行时参数类型上的多重分派所选择的方法定义函数。



\hypertarget{8001618391799989953}{}


\chapter{流程控制}



Julia 提供了大量的流程控制构件：



\begin{itemize}
\item \hyperlink{14178955634857450370}{复合表达式}：\texttt{begin} 和 \texttt{;}。


\item \hyperlink{14451148373001501733}{条件表达式}：\texttt{if}-\texttt{elseif}-\texttt{else} 和 \texttt{?:} (三元运算符)。


\item \hyperlink{7551496361738057869}{短路求值}：逻辑运算符 \texttt{\&\&}（与）和 \texttt{||}（或），以及链式比较。


\item \hyperlink{9034109510149997190}{重复执行：循环}：\texttt{while} 和 \texttt{for}。


\item \hyperlink{17887694433469406627}{异常处理}：\texttt{try}-\texttt{catch}、\hyperlink{17992125292605951734}{\texttt{error}} 和 \hyperlink{16410366672587017456}{\texttt{throw}}。


\item \hyperlink{17473131347184639576}{\texttt{Task}（协程）}：\hyperlink{4920987536368477483}{\texttt{yieldto}}。

\end{itemize}


前五个流程控制机制是高级编程语言的标准。\hyperlink{7131243650304654155}{\texttt{Task}} 不是那么的标准：它提供了非局部的流程控制，这使得在暂时挂起的计算任务之间进行切换成为可能。这是一个功能强大的构件：Julia 中的异常处理和协同多任务都是通过 \texttt{Task} 实现的。虽然日常编程并不需要直接使用 \texttt{Task}，但某些问题用 \texttt{Task} 处理会更加简单。



\hypertarget{16096814372489430927}{}


\section{复合表达式}



有时一个表达式能够有序地计算若干子表达式，并返回最后一个子表达式的值作为它的值是很方便的。Julia 有两个组件来完成这个： \texttt{begin} 代码块 和 \texttt{;} 链。这两个复合表达式组件的值都是最后一个子表达式的值。下面是一个 \texttt{begin} 代码块的例子：




\begin{minted}{jlcon}
julia> z = begin
           x = 1
           y = 2
           x + y
       end
3
\end{minted}



因为这些是非常简短的表达式，它们可以简单地被放到一行里，这也是 \texttt{;} 链的由来：




\begin{minted}{jlcon}
julia> z = (x = 1; y = 2; x + y)
3
\end{minted}



这个语法在定义简洁的单行函数的时候特别有用，参见\href{@id man-functions}{函数}。尽管很典型，但是并不要求 \texttt{begin} 代码块是多行的，或者 \texttt{;} 链是单行的：




\begin{minted}{jlcon}
julia> begin x = 1; y = 2; x + y end
3

julia> (x = 1;
        y = 2;
        x + y)
3
\end{minted}



\hypertarget{9876835618453764646}{}


\section{条件表达式}



条件表达式（Conditional evaluation）可以根据布尔表达式的值，让部分代码被执行或者不被执行。下面是对 \texttt{if}-\texttt{elseif}-\texttt{else} 条件语法的分析：




\begin{minted}{julia}
if x < y
    println("x is less than y")
elseif x > y
    println("x is greater than y")
else
    println("x is equal to y")
end
\end{minted}



如果表达式 \texttt{x < y} 是 \texttt{true}，那么对应的代码块会被执行；否则判断条件表达式 \texttt{x > y}，如果它是 \texttt{true}，则执行对应的代码块；如果没有表达式是 true，则执行 \texttt{else} 代码块。下面是一个例子：




\begin{minted}{jlcon}
julia> function test(x, y)
           if x < y
               println("x is less than y")
           elseif x > y
               println("x is greater than y")
           else
               println("x is equal to y")
           end
       end
test (generic function with 1 method)

julia> test(1, 2)
x is less than y

julia> test(2, 1)
x is greater than y

julia> test(1, 1)
x is equal to y
\end{minted}



\texttt{elseif} 和 \texttt{else} 代码块是可选的，并且可以使用任意多个 \texttt{elseif} 代码块。 \texttt{if}-\texttt{elseif}-\texttt{else} 组件中的第一个条件表达式为 \texttt{true} 时，其他条件表达式才会被执行，当对应的代码块被执行后，其余的表达式或者代码块将不会被执行。



\texttt{if} 代码块是{\textquotedbl}有渗漏的{\textquotedbl}，也就是说它们不会引入局部作用域。这意味着在 \texttt{if} 语句中新定义的变量依然可以在 \texttt{if} 代码块之后使用，尽管这些变量没有在 \texttt{if} 语句之前定义过。所以，我们可以将上面的 \texttt{test} 函数定义为




\begin{minted}{jlcon}
julia> function test(x,y)
           if x < y
               relation = "less than"
           elseif x == y
               relation = "equal to"
           else
               relation = "greater than"
           end
           println("x is ", relation, " y.")
       end
test (generic function with 1 method)

julia> test(2, 1)
x is greater than y.
\end{minted}



变量 \texttt{relation} 是在 \texttt{if} 代码块内部声明的，但可以在外部使用。然而，在利用这种行为的时候，要保证变量在所有的分支下都进行了定义。对上述函数做如下修改会导致运行时错误




\begin{minted}{jlcon}
julia> function test(x,y)
           if x < y
               relation = "less than"
           elseif x == y
               relation = "equal to"
           end
           println("x is ", relation, " y.")
       end
test (generic function with 1 method)

julia> test(1,2)
x is less than y.

julia> test(2,1)
ERROR: UndefVarError: relation not defined
Stacktrace:
 [1] test(::Int64, ::Int64) at ./none:7
\end{minted}



\texttt{if} 代码块也会返回一个值，这可能对于一些从其他语言转过来的用户来说不是很直观。 这个返回值就是被执行的分支中最后一个被执行的语句的返回值。 所以




\begin{minted}{jlcon}
julia> x = 3
3

julia> if x > 0
           "positive!"
       else
           "negative..."
       end
"positive!"
\end{minted}



需要注意的是，在 Julia 中，经常会用短路求值来表示非常短的条件表达式（单行），这会在下一节中介绍。



与 C, MATLAB, Perl, Python，以及 Ruby 不同，但跟 Java，还有一些别的严谨的类型语言类似：一个条件表达式的值如果不是 \texttt{true} 或者 \texttt{false} 的话，会返回错误：




\begin{minted}{jlcon}
julia> if 1
           println("true")
       end
ERROR: TypeError: non-boolean (Int64) used in boolean context
\end{minted}



这个错误是说，条件判断结果的类型：\hyperlink{7720564657383125058}{\texttt{Int64}} 是错的，而不是期望的 \hyperlink{46725311238864537}{\texttt{Bool}}。



所谓的 {\textquotedbl}三元运算符{\textquotedbl}, \texttt{?:}，很类似 \texttt{if}-\texttt{elseif}-\texttt{else} 语法，它用于选择性获取单个表达式的值，而不是选择性执行大段的代码块。它因在很多语言中是唯一一个有三个操作数的运算符而得名：




\begin{minted}{julia}
a ? b : c
\end{minted}



在 \texttt{?} 之前的表达式 \texttt{a}, 是一个条件表达式，如果条件 \texttt{a} 是 \texttt{true}，三元运算符计算在 \texttt{:} 之前的表达式 \texttt{b}；如果条件 \texttt{a} 是 \texttt{false}，则执行 \texttt{:} 后面的表达式 \texttt{c}。注意，\texttt{?} 和 \texttt{:} 旁边的空格是强制的，像 \texttt{a?b:c} 这种表达式不是一个有效的三元表达式（但在\texttt{?} 和 \texttt{:} 之后的换行是允许的）。



理解这种行为的最简单方式是看一个实际的例子。在前一个例子中，虽然在三个分支中都有调用 \texttt{println}，但实质上是选择打印哪一个字符串。在这种情况下，我们可以用三元运算符更紧凑地改写。为了简明，我们先尝试只有两个分支的版本：




\begin{minted}{jlcon}
julia> x = 1; y = 2;

julia> println(x < y ? "less than" : "not less than")
less than

julia> x = 1; y = 0;

julia> println(x < y ? "less than" : "not less than")
not less than
\end{minted}



如果表达式 \texttt{x < y} 为真，整个三元运算符会执行字符串 \texttt{{\textquotedbl}less than{\textquotedbl}}，否则执行字符串 \texttt{{\textquotedbl}not less than{\textquotedbl}}。原本的三个分支的例子需要链式嵌套使用三元运算符：




\begin{minted}{jlcon}
julia> test(x, y) = println(x < y ? "x is less than y"    :
                            x > y ? "x is greater than y" : "x is equal to y")
test (generic function with 1 method)

julia> test(1, 2)
x is less than y

julia> test(2, 1)
x is greater than y

julia> test(1, 1)
x is equal to y
\end{minted}



为了方便链式传值，运算符从右到左连接到一起。



重要地是，与 \texttt{if}-\texttt{elseif}-\texttt{else} 类似，\texttt{:} 之前和之后的表达式只有在条件表达式为 \texttt{true} 或者 \texttt{false} 时才会被相应地执行：




\begin{minted}{jlcon}
julia> v(x) = (println(x); x)
v (generic function with 1 method)

julia> 1 < 2 ? v("yes") : v("no")
yes
"yes"

julia> 1 > 2 ? v("yes") : v("no")
no
"no"
\end{minted}



\hypertarget{736299957672008833}{}


\section{短路求值}



Julia 中的 \texttt{\&\&} 和 \texttt{||} 运算符分别对应于逻辑“与”和“或”操作，并通常都这样使用。 但是，它们具有 \emph{逻辑短路} 的特殊性质：不一定评估其第二个参数，下面会详细介绍。 （也有按位 \texttt{\&} 和 \texttt{|} 运算符可用作逻辑“与”和“或”的\emph{无}短路行为，但要注意 \texttt{\&} 和 \texttt{|} 的评估时的优先级高于 \texttt{\&\&} 和 \texttt{||} 。）



短路求值与条件求值非常相似。 这种行为在大多数具有 \texttt{\&\&} 和 \texttt{||} 布尔运算符的命令式编程语言中都可以找到：在一系列由这些运算符连接的布尔表达式中，为了得到整个链的最终布尔值，仅仅只有最小数量的表达式被计算。 一些语言（如 Python）将它们称为\texttt{and}（\texttt{\&\&}）和\texttt{or}（\texttt{||}）。 更准确地说，这意味着：



\begin{itemize}
\item 在表达式 \texttt{a \&\& b} 中，子表达式 \texttt{b} 仅当 \texttt{a} 为 \texttt{true} 的时候才会被执行。


\item 在表达式 \texttt{a || b} 中，子表达式 \texttt{b} 仅在 \texttt{a} 为 \texttt{false} 的时候才会被执行。

\end{itemize}


这里的原因是：如果 \texttt{a} 是 \texttt{false}，那么无论 \texttt{b} 的值是多少，\texttt{a \&\& b} 一定是 \texttt{false}。同理，如果 \texttt{a} 是 \texttt{true}，那么无论 \texttt{b} 的值是多少，\texttt{a || b} 的值一定是 true。\texttt{\&\&} 和 \texttt{||} 都依赖于右边，但是 \texttt{\&\&} 比 \texttt{||} 有更高的优先级。我们可以简单地测试一下这个行为：




\begin{minted}{jlcon}
julia> t(x) = (println(x); true)
t (generic function with 1 method)

julia> f(x) = (println(x); false)
f (generic function with 1 method)

julia> t(1) && t(2)
1
2
true

julia> t(1) && f(2)
1
2
false

julia> f(1) && t(2)
1
false

julia> f(1) && f(2)
1
false

julia> t(1) || t(2)
1
true

julia> t(1) || f(2)
1
true

julia> f(1) || t(2)
1
2
true

julia> f(1) || f(2)
1
2
false
\end{minted}



你可以用同样的方式测试不同 \texttt{\&\&} 和 \texttt{||} 运算符的组合条件下的关联和优先级。



这种行为在 Julia 中经常被用来作为简短 \texttt{if} 语句的替代。 可以用 \texttt{<cond> \&\& <statement>} (可读为: <cond> \emph{and then} <statement>)来替换 \texttt{if <cond> <statement> end}。 类似的， 可以用 \texttt{<cond> || <statement>} (可读为: <cond> \emph{or else} <statement>)来替换 \texttt{if ! <cond> <statement> end}.



例如，可以像这样定义递归阶乘：




\begin{minted}{jlcon}
julia> function fact(n::Int)
           n >= 0 || error("n must be non-negative")
           n == 0 && return 1
           n * fact(n-1)
       end
fact (generic function with 1 method)

julia> fact(5)
120

julia> fact(0)
1

julia> fact(-1)
ERROR: n must be non-negative
Stacktrace:
 [1] error at ./error.jl:33 [inlined]
 [2] fact(::Int64) at ./none:2
 [3] top-level scope
\end{minted}



\textbf{无}短路求值的布尔运算可以用位布尔运算符来完成，见\hyperlink{16865688524696028421}{数学运算和初等函数}：\texttt{\&} 和 \texttt{|}。这些是普通的函数，同时也刚好支持中缀运算符语法，但总是会计算它们的所有参数：




\begin{minted}{jlcon}
julia> f(1) & t(2)
1
2
false

julia> t(1) | t(2)
1
2
true
\end{minted}



与 \texttt{if}, \texttt{elseif} 或者三元运算符中的条件表达式相同，\texttt{\&\&} 或者 \texttt{||} 的操作数必须是布尔值（\texttt{true} 或者 \texttt{false}）。在链式嵌套的条件表达式中， 除最后一项外，使用非布尔值会导致错误：




\begin{minted}{jlcon}
julia> 1 && true
ERROR: TypeError: non-boolean (Int64) used in boolean context
\end{minted}



但在链的末尾允许使用任意类型的表达式，此表达式会根据前面的条件被执行并返回：




\begin{minted}{jlcon}
julia> true && (x = (1, 2, 3))
(1, 2, 3)

julia> false && (x = (1, 2, 3))
false
\end{minted}



\hypertarget{6800841505698205300}{}


\section{重复执行：循环}



有两个用于重复执行表达式的组件：\texttt{while} 循环和 \texttt{for} 循环。下面是一个 \texttt{while} 循环的例子：




\begin{minted}{jlcon}
julia> i = 1;

julia> while i <= 5
           println(i)
           global i += 1
       end
1
2
3
4
5
\end{minted}



\texttt{while} 循环会执行条件表达式（例子中为 \texttt{i <= 5}），只要它为 \texttt{true}，就一直执行\texttt{while} 循环的主体部分。当 \texttt{while} 循环第一次执行时，如果条件表达式为 \texttt{false}，那么主体代码就一次也不会被执行。



\texttt{for} 循环使得常见的重复执行代码写起来更容易。 像之前 \texttt{while} 循环中用到的向上和向下计数是可以用 \texttt{for} 循环更简明地表达：




\begin{minted}{jlcon}
julia> for i = 1:5
           println(i)
       end
1
2
3
4
5
\end{minted}



这里的 \texttt{1:5} 是一个范围对象，代表数字 1, 2, 3, 4, 5 的序列。\texttt{for} 循环在这些值之中迭代，对每一个变量 \texttt{i} 进行赋值。\texttt{for} 循环与之前 \texttt{while} 循环的一个非常重要区别是作用域，即变量的可见性。如果变量 \texttt{i} 没有在另一个作用域里引入，在 \texttt{for} 循环内，它就只在 \texttt{for} 循环内部可见，在外部和后面均不可见。你需要一个新的交互式会话实例或者一个新的变量名来测试这个特性：




\begin{minted}{jlcon}
julia> for j = 1:5
           println(j)
       end
1
2
3
4
5

julia> j
ERROR: UndefVarError: j not defined
\end{minted}



参见\hyperlink{11957539949537805757}{变量作用域}中对变量作用域的详细解释以及它在 Julia 中是如何工作的。



一般来说，\texttt{for} 循环组件可以用于迭代任一个容器。在这种情况下，相比 \texttt{=}，另外的（但完全相同）关键字 \texttt{in} 或者 \texttt{∈} 则更常用，因为它使得代码更清晰：




\begin{minted}{jlcon}
julia> for i in [1,4,0]
           println(i)
       end
1
4
0

julia> for s ∈ ["foo","bar","baz"]
           println(s)
       end
foo
bar
baz
\end{minted}



在手册后面的章节中会介绍和讨论各种不同的迭代容器（比如，\hyperlink{16720099245556932994}{多维数组}）。



为了方便，我们可能会在测试条件不成立之前终止一个 \texttt{while} 循环，或者在访问到迭代对象的结尾之前停止一个 \texttt{for} 循环，这可以用关键字 \texttt{break} 来完成：




\begin{minted}{jlcon}
julia> i = 1;

julia> while true
           println(i)
           if i >= 5
               break
           end
           global i += 1
       end
1
2
3
4
5

julia> for j = 1:1000
           println(j)
           if j >= 5
               break
           end
       end
1
2
3
4
5
\end{minted}



没有关键字 \texttt{break} 的话，上面的 \texttt{while} 循环永远不会自己结束，而 \texttt{for} 循环会迭代到 1000，这些循环都可以使用 \texttt{break} 来提前结束。



在某些场景下，需要直接结束此次迭代，并立刻进入下次迭代，\texttt{continue} 关键字可以用来完成此功能：




\begin{minted}{jlcon}
julia> for i = 1:10
           if i % 3 != 0
               continue
           end
           println(i)
       end
3
6
9
\end{minted}



这是一个有点做作的例子，因为我们可以通过否定这个条件，把 \texttt{println} 调用放到 \texttt{if} 代码块里来更简洁的实现同样的功能。在实际应用中，在 \texttt{continue} 后面还会有更多的代码要运行，并且调用 \texttt{continue} 的地方可能会有多个。



多个嵌套的 \texttt{for} 循环可以合并到一个外部循环，可以用来创建其迭代对象的笛卡尔积：




\begin{minted}{jlcon}
julia> for i = 1:2, j = 3:4
           println((i, j))
       end
(1, 3)
(1, 4)
(2, 3)
(2, 4)
\end{minted}



有了这个语法，迭代变量依然可以正常使用循环变量来进行索引，例如 \texttt{for i = 1:n, j = 1:i} 是合法的，但是在一个循环里面使用 \texttt{break} 语句则会跳出整个嵌套循环，不仅仅是内层循环。每次内层循环运行的时候，变量（\texttt{i} 和 \texttt{j}）会被赋值为他们当前的迭代变量值。所以对 \texttt{i} 的赋值对于接下来的迭代是不可见的：




\begin{minted}{jlcon}
julia> for i = 1:2, j = 3:4
           println((i, j))
           i = 0
       end
(1, 3)
(1, 4)
(2, 3)
(2, 4)
\end{minted}



如果这个例子给每个变量一个关键字 \texttt{for} 来重写，那么输出会不一样：第二个和第四个变量包含 \texttt{0}。



可以使用 \hyperlink{11836366300100000234}{\texttt{zip}} 在单个 \texttt{for} 循环中同时迭代多个容器：




\begin{minted}{jlcon}
julia> for (j, k) in zip([1 2 3], [4 5 6 7])
           println((j,k))
       end
(1, 4)
(2, 5)
(3, 6)
\end{minted}



使用 \hyperlink{11836366300100000234}{\texttt{zip}} 将创建一个迭代器，它是一个包含传递给它的容器的子迭代器的元组。 \texttt{zip} 迭代器将按顺序迭代所有子迭代器，在 \texttt{for} 循环的第  \(i\)  次迭代中选择每个子迭代器的第  \(i\)  个元素。 一旦任何子迭代器用完，\texttt{for} 循环就会停止。



\hypertarget{11112426789887598982}{}


\section{异常处理}



当一个意外条件发生时，一个函数可能无法向调用者返回一个合理的值。在这种情况下，最好让意外条件终止程序并打印出调试的错误信息，或者根据程序员预先提供的异常处理代码来采取恰当的措施。



\hypertarget{18218681852389631555}{}


\subsection{内置的 \texttt{Exception}}



当一个意外的情况发生时，会抛出 \texttt{Exception}。下面列出的内置 \texttt{Exception} 都会中断正常的控制流程。




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|}
\hline
\texttt{Exception} \\
\hline
\hyperlink{9721838137887538764}{\texttt{ArgumentError}} \\
\hline
\hyperlink{9731558909100893938}{\texttt{BoundsError}} \\
\hline
\hyperlink{15047752250898038281}{\texttt{CompositeException}} \\
\hline
\hyperlink{13752533629496758140}{\texttt{DimensionMismatch}} \\
\hline
\hyperlink{4168463413201806292}{\texttt{DivideError}} \\
\hline
\hyperlink{14085880504701688639}{\texttt{DomainError}} \\
\hline
\hyperlink{2683611566077490148}{\texttt{EOFError}} \\
\hline
\hyperlink{12102596058483452470}{\texttt{ErrorException}} \\
\hline
\hyperlink{5399118524830636312}{\texttt{InexactError}} \\
\hline
\hyperlink{15248096136337910028}{\texttt{InitError}} \\
\hline
\hyperlink{11255134339055983338}{\texttt{InterruptException}} \\
\hline
\texttt{InvalidStateException} \\
\hline
\hyperlink{12862287453053981792}{\texttt{KeyError}} \\
\hline
\hyperlink{15548397364092946520}{\texttt{LoadError}} \\
\hline
\hyperlink{9656432107553099418}{\texttt{OutOfMemoryError}} \\
\hline
\hyperlink{5617183776424836760}{\texttt{ReadOnlyMemoryError}} \\
\hline
\hyperlink{10250718604436154991}{\texttt{RemoteException}} \\
\hline
\hyperlink{68769522931907606}{\texttt{MethodError}} \\
\hline
\hyperlink{10461069697702909970}{\texttt{OverflowError}} \\
\hline
\hyperlink{6896679243086513948}{\texttt{Meta.ParseError}} \\
\hline
\hyperlink{16303515589950241655}{\texttt{SystemError}} \\
\hline
\hyperlink{2622693721821893139}{\texttt{TypeError}} \\
\hline
\hyperlink{7764749529861419421}{\texttt{UndefRefError}} \\
\hline
\hyperlink{4452889246677411554}{\texttt{UndefVarError}} \\
\hline
\hyperlink{414193743931514144}{\texttt{StringIndexError}} \\
\hline
\end{tabulary}

\end{table}



例如，当输入参数为负实数时，\hyperlink{4551113327515323898}{\texttt{sqrt}} 函数会抛出一个 \hyperlink{14085880504701688639}{\texttt{DomainError}} ：




\begin{minted}{jlcon}
julia> sqrt(-1)
ERROR: DomainError with -1.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
[...]
\end{minted}



你可能需要根据下面的方式来定义你自己的异常：




\begin{minted}{jlcon}
julia> struct MyCustomException <: Exception end
\end{minted}



\hypertarget{11451631637715363921}{}


\subsection{\texttt{throw} 函数}



我们可以用 \hyperlink{16410366672587017456}{\texttt{throw}} 显式地创建异常。例如，若一个函数只对非负数有定义，当输入参数是负数的时候，可以用 \hyperlink{16410366672587017456}{\texttt{throw}} 抛出一个 \hyperlink{14085880504701688639}{\texttt{DomainError}}。




\begin{minted}{jlcon}
julia> f(x) = x>=0 ? exp(-x) : throw(DomainError(x, "argument must be nonnegative"))
f (generic function with 1 method)

julia> f(1)
0.36787944117144233

julia> f(-1)
ERROR: DomainError with -1:
argument must be nonnegative
Stacktrace:
 [1] f(::Int64) at ./none:1
\end{minted}



注意 \hyperlink{14085880504701688639}{\texttt{DomainError}} 后面不接括号的话不是一个异常，而是一个异常类型。我们需要调用它来获得一个 \texttt{Exception} 对象：




\begin{minted}{jlcon}
julia> typeof(DomainError(nothing)) <: Exception
true

julia> typeof(DomainError) <: Exception
false
\end{minted}



另外，一些异常类型会接受一个或多个参数来进行错误报告：




\begin{minted}{jlcon}
julia> throw(UndefVarError(:x))
ERROR: UndefVarError: x not defined
\end{minted}



我们可以仿照 \hyperlink{4452889246677411554}{\texttt{UndefVarError}} 的写法，用自定义异常类型来轻松实现这个机制：




\begin{minted}{jlcon}
julia> struct MyUndefVarError <: Exception
           var::Symbol
       end

julia> Base.showerror(io::IO, e::MyUndefVarError) = print(io, e.var, " not defined")
\end{minted}



\begin{quote}
\textbf{Note}

错误信息的第一个单词最好用小写。例如：

\texttt{size(A) == size(B) || throw(DimensionMismatch({\textquotedbl}size of A not equal to size of B{\textquotedbl}))}

就比

\texttt{size(A) == size(B) || throw(DimensionMismatch({\textquotedbl}Size of A not equal to size of B{\textquotedbl}))}.

更好。

但是，有时保留大写首字母是有意义的，例如函数的参数就是大写字母时：

\texttt{size(A,1) == size(B,2) || throw(DimensionMismatch({\textquotedbl}A has first dimension...{\textquotedbl}))}.

\end{quote}


\hypertarget{18278096073868016389}{}


\subsection{错误}



我们可以用 \hyperlink{17992125292605951734}{\texttt{error}} 函数生成一个 \hyperlink{12102596058483452470}{\texttt{ErrorException}} 来中断正常的控制流程。



假设我们希望在计算负数的平方根时让程序立即停止执行。为了实现它，我们可以定义一个挑剔的 \hyperlink{4551113327515323898}{\texttt{sqrt}} 函数，当它的参数是负数时，产生一个错误：




\begin{minted}{jlcon}
julia> fussy_sqrt(x) = x >= 0 ? sqrt(x) : error("negative x not allowed")
fussy_sqrt (generic function with 1 method)

julia> fussy_sqrt(2)
1.4142135623730951

julia> fussy_sqrt(-1)
ERROR: negative x not allowed
Stacktrace:
 [1] error at ./error.jl:33 [inlined]
 [2] fussy_sqrt(::Int64) at ./none:1
 [3] top-level scope
\end{minted}



如果另一个函数调用 \texttt{fussy\_sqrt} 和一个负数, 它会立马返回， 在交互会话中显示错误信息，而不会继续执行调用的函数：




\begin{minted}{jlcon}
julia> function verbose_fussy_sqrt(x)
           println("before fussy_sqrt")
           r = fussy_sqrt(x)
           println("after fussy_sqrt")
           return r
       end
verbose_fussy_sqrt (generic function with 1 method)

julia> verbose_fussy_sqrt(2)
before fussy_sqrt
after fussy_sqrt
1.4142135623730951

julia> verbose_fussy_sqrt(-1)
before fussy_sqrt
ERROR: negative x not allowed
Stacktrace:
 [1] error at ./error.jl:33 [inlined]
 [2] fussy_sqrt at ./none:1 [inlined]
 [3] verbose_fussy_sqrt(::Int64) at ./none:3
 [4] top-level scope
\end{minted}



\hypertarget{11842305126309838851}{}


\subsection{\texttt{try/catch} 语句}



通过 \texttt{try / catch} 语句，可以测试 Exception 并 优雅处理可能会破坏应用程序的事情。 例如， 在下面的代码中，平方根函数会引发异常。 通过 在其周围放置 \texttt{try / catch} 块可以缓解。 您可以选择如何 处理此异常，无论是记录它，返回占位符值还是 就像下面仅打印一句话。 要注意的是 在决定如何处理异常时，使用\texttt{try / catch} 块 比使用条件分支处理要慢得多。 以下是使用\texttt{try / catch} 块处理异常的更多示例：




\begin{minted}{jlcon}
julia> try
sqrt("ten")
catch e
println("You should have entered a numeric value")
end
You should have entered a numeric value
\end{minted}



\texttt{try/catch} 语句允许保存 \texttt{Exception} 到一个变量中。在下面这个做作的例子中，如果 \texttt{x} 是可索引的，则计算 \texttt{x} 的第二项的平方根，否则就假设 \texttt{x} 是一个实数，并返回它的平方根：




\begin{minted}{jlcon}
julia> sqrt_second(x) = try
           sqrt(x[2])
       catch y
           if isa(y, DomainError)
               sqrt(complex(x[2], 0))
           elseif isa(y, BoundsError)
               sqrt(x)
           end
       end
sqrt_second (generic function with 1 method)

julia> sqrt_second([1 4])
2.0

julia> sqrt_second([1 -4])
0.0 + 2.0im

julia> sqrt_second(9)
3.0

julia> sqrt_second(-9)
ERROR: DomainError with -9.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
[...]
\end{minted}



注意 \texttt{catch} 后面的字符会被一直认为是异常的名字，所以在写 \texttt{try/catch} 单行表达式时，需要特别小心。下面的代码\textbf{不会}在错误的情况下返回 \texttt{x} 的值：




\begin{minted}{julia}
try bad() catch x end
\end{minted}



正确的做法是在 \texttt{catch} 后添加一个分号或者直接换行：




\begin{minted}{julia}
try bad() catch; x end

try bad()
catch
    x
end
\end{minted}



\texttt{try/catch} 结构的强大之处在于能够立即将深度嵌套的计算展开到调用函数堆栈中的更高级别。 在某些情况下，没有发生错误，但需要能够展开堆栈并将值传递到更高级别。 Julia 提供了 \hyperlink{2102349972401293064}{\texttt{rethrow}}、\hyperlink{6187626674327343338}{\texttt{backtrace}}、\hyperlink{98342946516168163}{\texttt{catch\_backtrace}} 和 \href{@ref}{\texttt{current\_exceptions}} 函数来进行更高级的错误处理。



\hypertarget{13560047635024894791}{}


\subsection{\texttt{finally} 子句}



在进行状态改变或者使用类似文件的资源的编程时，经常需要在代码结束的时候进行必要的清理工作（比如关闭文件）。由于异常会使得部分代码块在正常结束之前退出，所以可能会让上述工作变得复杂。\texttt{finally} 关键字提供了一种方式，无论代码块是如何退出的，都能够让代码块在退出时运行某段代码。



这里是一个确保一个打开的文件被关闭的例子：




\begin{minted}{julia}
f = open("file")
try
    # operate on file f
finally
    close(f)
end
\end{minted}



当控制流离开 \texttt{try} 代码块（例如，遇到 \texttt{return}，或者正常结束），\texttt{close(f)} 就会被执行。如果 \texttt{try} 代码块由于异常退出，这个异常会继续传递。\texttt{catch} 代码块可以和 \texttt{try} 还有 \texttt{finally} 配合使用。这时 \texttt{finally} 代码块会在 \texttt{catch} 处理错误之后才运行。



\hypertarget{15038256797533490288}{}


\section{ Tasks 任务（或协程）}



\texttt{Task} 是一种允许计算以更灵活的方式被中断或者恢复的流程控制特性。 我们提及它只是为了说明的完整性；详细的介绍参见：\hyperlink{12788188476310754107}{异步编程}。



\hypertarget{14993622729045334657}{}


\chapter{变量作用域}



变量的 \textbf{作用域} 是代码的一个区域，在这个区域中这个变量是可见的。给变量划分作用域有助于解决变量命名冲突。这个概念是符合直觉的：两个函数可能同时都有叫做 \texttt{x} 的参量，而这两个 \texttt{x} 并不指向同一个东西。 相似地，也有很多其他的情况，代码的不同块会使用同样名字，但并不指向同一个东西。相同的变量名是否指向同一个东西的规则被称为作用域规则；这一节会详细地把这个规则讲清楚。



语言中的某些结构会引入\emph{作用域块}，这是可以成为一些变量集合的作用域的代码区域。一个变量的作用域不是源代码行的任意集合；相反，它始终与这些块之一关系密切。在 Julia 中主要有两种作用域，\emph{全局作用域} 与 \emph{局部作用域}，后者可以嵌套。 在 Julia 中还存在引入“硬作用域”的构造和只引入“软作用域”的构造之间的区别，这影响到是否允许以相同的名称\href{https://en.wikipedia.org/wiki/Variable\_shadowing}{遮蔽}全局变量。



\hypertarget{10787034693073583413}{}


\subsection{作用域结构}



引入作用域块的结构有：




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
结构 & 作用域类型 & 允许使用在 \\
\hline
\hyperlink{16285380181904025577}{\texttt{module}}, \hyperlink{13329108222158426840}{\texttt{baremodule}} & 全局 & 全局 \\
\hline
\hyperlink{4119979838407461137}{\texttt{struct}} & 局部（软） & 全局 \\
\hline
\hyperlink{9105224580875818383}{\texttt{for}}, \hyperlink{15133348314455964692}{\texttt{while}}, \hyperlink{16338536928035025961}{\texttt{try}} & 局部（软） & global, local \\
\hline
\hyperlink{4625593635027008869}{\texttt{macro}} & 局部（硬） & 全局 \\
\hline
函数， \hyperlink{16455129305818705265}{\texttt{do}} 语句块, \hyperlink{4956741936243461891}{\texttt{let}}语句块, 数组推导, 生成器 & 局部（硬） & global, local \\
\hline
\end{tabulary}

\end{table}



值得注意的是，这个表内没有的是 \hyperlink{14178955634857450370}{begin 块}和\hyperlink{14451148373001501733}{ if 块}，这两个块\textbf{不会}引进新的作用域块。这两种作用域遵循的规则有点不一样，会在下面解释。



Julia 使用\href{https://en.wikipedia.org/wiki/Scope\_\%28computer\_science\%29\#Lexical\_scoping\_vs.\_dynamic\_scoping}{词法作用域}，也就是说一个函数的作用域不继承自调用了函数的调用者作用域，而继承自该函数定义处作用域。举例如下，\texttt{foo} 中的 \texttt{x} 指向模块 \texttt{Bar} 的全局作用域中 \texttt{x}。




\begin{minted}{jlcon}
julia> module Bar
           x = 1
           foo() = x
       end;
\end{minted}



而非调用了 \texttt{foo} 的作用域中的 \texttt{x}：




\begin{minted}{jlcon}
julia> import .Bar

julia> x = -1;

julia> Bar.foo()
1
\end{minted}



因此\textbf{词法作用域}意味着，某段代码内某变量的指向只从它出现之处就可以推断出来，而不依赖于程序的执行方式。在嵌套的作用域结构里，内层作用域能”看“到所有外层作用域内变量。相对地，外层作用域不能看到内层作用域的变量。



\hypertarget{4662569705122519760}{}


\section{全局作用域}



每个模块会引进一个新全局作用域，与其他所有模块的全局作用域分开；无所不包的全局作用域不存在。模块可以把其他模块的变量引入到它的作用域中，通过\hyperlink{16725527896995457152}{using 或者 import}语句或者通过点符号这种有资格的通路，也就是说每个模块都是所谓的\emph{命名空间}或者关联着含值的名字的第一类数据结构。值得注意的是，即便变量绑定能在外部被读取，变量绑定也只能在它们的全局作用域中改变。 作为一个逃生窗口，你总是可以执行该模块内代码来修改一个变量；这特别保证了不调用 \texttt{eval} 的外部代码绝不会修改模块绑定。




\begin{minted}{jlcon}
julia> module A
           a = 1 # a global in A's scope
       end;

julia> module B
           module C
               c = 2
           end
           b = C.c    # can access the namespace of a nested global scope
                      # through a qualified access
           import ..A # makes module A available
           d = A.a
       end;

julia> module D
           b = a # errors as D's global scope is separate from A's
       end;
ERROR: UndefVarError: a not defined

julia> module E
           import ..A # make module A available
           A.a = 2    # throws below error
       end;
ERROR: cannot assign variables in other modules
\end{minted}



注意交互式提示行（即REPL）是在模块\texttt{Main}的全局作用域中。



\hypertarget{8604224695833880734}{}


\section{局部作用域}



大多数代码块都引入了新的局部作用域（完整\hyperlink{8072811582823893323}{列表}请参见上表）。如果这样的代码块在语法上嵌套在另一个局部作用域内，则它创建的作用域嵌套在它出现的所有局部作用域内，这些局部作用域最终都嵌套在评估代码的模块的全局作用域内。 外部作用域中的变量在它们包含的任何作用域中都是可见的——这意味着它们可以在内部作用域中读取和写入——除非有一个同名的局部变量“遮蔽”了同名的外部变量。 即使外部的本地变量是在内部块之后（在下面的文本意义上）声明的，也是如此。 当我们说一个变量在给定范围内“存在”时，这意味着具有该名称的变量存在于当前范围嵌套在其中的任何范围内，包括当前范围。



一些编程语言需要在使用新变量之前显式声明它们。显式声明也适用于 Julia：在任何局部作用域中，编写 \texttt{local x} 都会在该作用域中声明一个新的局部变量，无论外部作用域中是否已经存在名为 \texttt{x} 的变量。像这样声明每个新变量有点冗长乏味，但是，与许多其他语言一样，Julia 考虑对不存在的变量名称进行赋值以隐式声明该变量。如果当前作用域是全局的，则新变量是全局的；如果当前作用域是局部的，则新变量对最内部的局部作用域是局部的，并且在该作用域内可见，但在该作用域外不可见。如果你给现有的局部变量赋值，它\emph{总是}更新现有的局部变量：你只能通过使用 \texttt{local} 关键字在嵌套范围内显式声明新的局部变量来隐藏原局部变量。特别是，这适用于在内部函数中分配的变量，这可能会让来自 Python 的用户感到惊讶，其中内部函数中的赋值会创建一个新的局部变量，除非该变量被明确声明为非局部变量。



大多数情况下，这是非常直观的，但与许多直觉行为一样，细节比人们天真地想象的要微妙得多。



当 \texttt{x = <value>} 出现在某局部作用域，Julia 根据赋值表达式出现位置、 \texttt{x} 在此处已经引用的内容，采取如下规则确定表达式的意义：



\begin{itemize}
\item[1. ] \textbf{现存的局部变量：}如果 \texttt{x} \textbf{已经是一个局部变量}，那现存的局部变量 \texttt{x} 将被 赋值；


\item[2. ] **硬作用域：如果 \texttt{x} 还\emph{不是局部变量}并且赋值发生的作用域结构是硬作用域（即在 \texttt{let} 语句块、函数体、宏、推导式或生成器中），则会在赋值作用域中创建一个名为 \texttt{x} 的新局部变量；


\item[3. ] \textbf{软作用域：}如果 \texttt{x} \textbf{并非已经是局部变量}，并且所有包含 此次赋值的作用域结构是软作用域（循环、\texttt{try}/\texttt{catch} 块、或者 \texttt{struct} 块）， 最后行为取决于全局变量 \texttt{x} 是否被定义：

\begin{itemize}
\item 如果全局变量 \texttt{x} 是\textbf{未定义}，最终此次赋值会在该作用域创建一个名为 \texttt{x} 的新局部变量 ；


\item 如果全局变量 \texttt{x} 是\textbf{已定义}，此次赋值会被认为是有歧义的：

\begin{itemize}
\item 在\textbf{非交互}的上下文（文件、eval）中，会打印一个有歧义警告，同时创建一个新 局部变量；


\item 在\textbf{交互}的上下文（REPL, notebooks）中，会向全局变量 \texttt{x} 赋值。

\end{itemize}
\end{itemize}
\end{itemize}


你或许注意到，当某隐性局部变量（比如未经 \texttt{local x} 声明）遮掩某全局变量，非交互的上下文中硬作用域和软作用域有相同行为，除了会输出警告。方便起见，交互的上下文遵从一套更复杂的启发式规则。下面的例子将会深入讲解。



既然你知道这个规则，那就看看一些例子。每个例子都是一个新的REPL会话中进行的，因此每个片段中唯一的全局变量就是在该代码块中分配的全局变量。



我们将从一个良好且明确的情况开始——在一个硬作用域内赋值，在这个情况下是一个函数体，当同名的局部变量不存在时：




\begin{minted}{jlcon}
julia> function greet()
           x = "hello" # new local
           println(x)
       end
greet (generic function with 1 method)

julia> greet()
hello

julia> x # global
ERROR: UndefVarError: x not defined
\end{minted}



在 \texttt{greet} 函数内部，赋值 \texttt{x = {\textquotedbl}hello{\textquotedbl}} 导致 \texttt{x} 成为函数作用域中的一个新局部变量。 有两个相关的事实：赋值发生在局部作用域内，并且没有现有的局部 \texttt{x} 变量。 由于 \texttt{x} 是局部的，所以是否存在名为 \texttt{x} 的全局变量并不重要。 例如，我们在定义和调用 \texttt{greet} 之前定义了 \texttt{x = 123}：




\begin{minted}{jlcon}
julia> x = 123 # global
123

julia> function greet()
           x = "hello" # new local
           println(x)
       end
greet (generic function with 1 method)

julia> greet()
hello

julia> x # global
123
\end{minted}



由于 \texttt{greet} 中的 \texttt{x} 是局部的，全局 \texttt{x} 的值（或缺少值）不会受到调用 \texttt{greet} 的影响。 硬作用域规则不关心名为 \texttt{x} 的全局变量是否存在：在硬作用域中对 \texttt{x} 的赋值是局部的（除非 \texttt{x} 被声明为全局的）。



我们将考虑的下一个明确的情况是已经有一个名为\texttt{x}的局部变量，在这种情况下，\texttt{x = 1}总是赋值给这个现有的局部\texttt{x}。 无论赋值发生在同一局部作用域、同一函数体的内部局部作用域，还是嵌套在另一个函数内部的函数体（也称为 \href{https://en.wikipedia.org/wiki/Closure\_(computer\_programming)}{闭包}）。



我们将使用 \texttt{sum\_to} 函数，它计算从 1 到 \texttt{n} 的整数之和，例如：




\begin{minted}{julia}
function sum_to(n)
    s = 0 # new local
    for i = 1:n
        s = s + i # assign existing local
    end
    return s # same local
end
\end{minted}



与前面的示例一样，在 \texttt{sum\_to} 函数先对 \texttt{s} 的第一次赋值导致 \texttt{s} 成为函数体中的一个新局部变量。 \texttt{for} 循环在函数作用域内有自己的内部局部作用域。 在 \texttt{s = s + i} 出现的地方，\texttt{s} 已经是一个局部变量，所以赋值更新了现有的 \texttt{s} 而不是创建一个新的局部变量。 我们可以通过在 REPL 中调用 \texttt{sum\_to} 来测试：




\begin{minted}{jlcon}
julia> function sum_to(n)
           s = 0 # new local
           for i = 1:n
               s = s + i # assign existing local
           end
           return s # same local
       end
sum_to (generic function with 1 method)

julia> sum_to(10)
55

julia> s # global
ERROR: UndefVarError: s not defined
\end{minted}



由于 \texttt{s} 是函数 \texttt{sum\_to} 的局部变量，调用该函数对全局变量 \texttt{s} 没有影响。 我们还可以看到，\texttt{for} 循环中的更新 \texttt{s = s + i} 必须更新由初始化 \texttt{s = 0} 创建的相同 \texttt{s}，因为我们得到了整数 1 到 10 的正确总和 55。



让我们通过编写一个稍微详细一点的变体来深入了解一下 \texttt{for} 循环体有自己的作用域，我们将其称为 \texttt{sum\_to\_def}，其中，在更新 \texttt{s} 之前，我们将和 \texttt{s + i} 保存在一个变量中\texttt{t} ：




\begin{minted}{jlcon}
julia> function sum_to_def(n)
           s = 0 # new local
           for i = 1:n
               t = s + i # new local `t`
               s = t # assign existing local `s`
           end
           return s, @isdefined(t)
       end
sum_to_def (generic function with 1 method)

julia> sum_to_def(10)
(55, false)
\end{minted}



这个版本像先前一样返回 \texttt{s}，但它也使用 \texttt{@isdefined} 宏返回一个布尔值，指示是否在函数的最外层局部作用域中定义了一个名为 \texttt{t} 的局部变量。 正如你所看到的，在 \texttt{for} 循环体之外没有定义 \texttt{t}。 这又是因为硬作用域规则：由于对 \texttt{t} 的赋值发生在一个函数内部，这引入了一个硬作用域，赋值导致 \texttt{t} 在它出现的局部作用域中成为一个新的局部变量，即循环体内部。 即使有一个名为 \texttt{t} 的全局变量，它也没有任何区别——硬作用域规则不受全局作用域中的任何内容的影响。



请注意，for 循环体的局部作用域与内部函数的局部作用域没有区别。 这意味着我们可以重写此示例，以便将循环体实现为对内部辅助函数的调用，并且其行为方式相同：




\begin{minted}{jlcon}
julia> function sum_to_def_closure(n)
           function loop_body(i)
               t = s + i # new local `t`
               s = t # assign same local `s` as below
           end
           s = 0 # new local
           for i = 1:n
               loop_body(i)
           end
           return s, @isdefined(t)
       end
sum_to_def_closure (generic function with 1 method)

julia> sum_to_def_closure(10)
(55, false)
\end{minted}



这个例子说明了几个要点：



\begin{itemize}
\item[1. ] 内部函数作用域就像任何其他嵌套的局部作用域一样。 特别是，如果一个变量已经是内部函数之外的局部变量，并且你在内部函数中为其赋值，则外部局部变量会被更新。


\item[2. ] 外部的局部变量的定义是否发生在更新位置的下方并不重要，规则保持不变。在解析内部的局部变量含义之前，解析整个封闭局部作用域并确定其局部变量。

\end{itemize}


这种设计意味着你通常可以将代码移入或移出内部函数而不改变其含义，这给使用闭包语言中的许多常见习语提供了便利。（参见 \hyperlink{1155949704550919454}{do blocks})。



让我们继续讨论软作用域规则涵盖的一些更模糊的情况。 我们将通过将 \texttt{gree}t 和 \texttt{sum\_to\_def}函数的主体提取到软作用域上下文中来探索这一点。 首先，让我们将 \texttt{greet} 的主体放在一个 \texttt{for} 循环中——它是软的，而不是硬的——并在 REPL 中运行：




\begin{minted}{jlcon}
julia> for i = 1:3
           x = "hello" # new local
           println(x)
       end
hello
hello
hello

julia> x
ERROR: UndefVarError: x not defined
\end{minted}



由于在执行\texttt{for}循环时未定义全局变量\texttt{x}，因此软作用域规则的第一个子句适用，并且\texttt{x}被创建为\texttt{for}循环内的局部变量，因此循环执行完后全局变量\texttt{x}一直没有定义 。 接下来，让我们考虑提取到全局作用域内的 \texttt{sum\_to\_def} 的函数体，将其参数固定为 \texttt{n = 10}




\begin{minted}{julia}
s = 0
for i = 1:10
    t = s + i
    s = t
end
s
@isdefined(t)
\end{minted}



这段代码有什么作用？ 提示：这是一个小把戏。 答案是“视情况而定”。 如果此代码以交互方式输入，则其行为方式与在函数体中的行为方式相同。 但是如果代码出现在文件中，它会打印一个歧义警告并抛出一个未定义的变量错误。 让我们先看看它在 REPL 中的情况：




\begin{minted}{jlcon}
julia> s = 0 # global
0

julia> for i = 1:10
           t = s + i # new local `t`
           s = t # assign global `s`
       end

julia> s # global
55

julia> @isdefined(t) # global
false
\end{minted}



REPL 内行为接近于函数体内，决定循环内部的赋值是分配给一个全局变量还是创建新的局部变量，取决于是否定义了具有该名称的全局变量。 如果存在同名的全局变量，则赋值会更新它。 如果不存在全局变量，则赋值会创建一个新的局部变量。 在这个例子中，我们看到两种情况都在起作用：



\begin{itemize}
\item 没有名为 \texttt{t} 的全局变量，因此 \texttt{t = s + i} 创建了一个新的 \texttt{t}，它是 \texttt{for} 循环的局部变量；


\item 有一个名为 \texttt{s} 的全局变量，因此将 \texttt{s = t} 赋值给它。

\end{itemize}


第二个情况解释了为什么循环的执行会改变 \texttt{s} 的全局值，第一个情况解释了为什么在循环执行后 \texttt{t} 仍未定义。 现在，让我们尝试运行相同的代码，就像它在文件中一样：




\begin{minted}{jlcon}
julia> code = """
       s = 0 # global
       for i = 1:10
           t = s + i # new local `t`
           s = t # new local `s` with warning
       end
       s, # global
       @isdefined(t) # global
       """;

julia> include_string(Main, code)
┌ Warning: Assignment to `s` in soft scope is ambiguous because a global variable by the same name exists: `s` will be treated as a new local. Disambiguate by using `local s` to suppress this warning or `global s` to assign to the existing global variable.
└ @ string:4
ERROR: LoadError: UndefVarError: s not defined
\end{minted}



这里我们使用 \hyperlink{2796348696499086186}{\texttt{include\_string}} 来评估 \texttt{code}，就好像它是文件的内容一样。 我们也可以将 \texttt{code} 保存到一个文件中，然后对该文件调用 \texttt{include}——结果是一样的。 如你所见，这与在 REPL 中评估相同代码的行为完全不同。 让我们分解一下这里发生的事情：



\begin{itemize}
\item 在循环运行之前，全局 \texttt{s} 被定义为值 \texttt{0}


\item 赋值 \texttt{s = t} 发生在软作用域中——任何函数体或其他硬作用域结构之外的 \texttt{for} 循环


\item 因此软作用域规则的第二个子句适用，并且分配不明确，因此发出警告


\item 继续执行，使 \texttt{s} 成为 \texttt{for} 循环体中的局部作用域


\item 由于 \texttt{s} 是 \texttt{for} 循环的局部变量，所以在计算 \texttt{t = s + i} 时它是未定义的，从而导致错误


\item 求值到此就结束了，但如果到了 \texttt{s} 和 \texttt{@isdefined(t)}，它将返回 \texttt{0} 和 \texttt{false}。

\end{itemize}


这展示了作用域的一些重要方面：在一个作用域中，每个变量只能有一个含义，而该含义的确定与表达式的顺序无关。 循环中表达式 \texttt{s = t} 的存在导致 \texttt{s} 在循环中是局部的，这意味着当它出现在 \texttt{t = s + i} 的右侧时它也是局部的，即使该表达式首先出现并首先计算。 有人可能会想象循环第一行上的 \texttt{s} 可以是全局的，而循环第二行上的 \texttt{s} 是局部的，但这是不可能的，因为这两行在同一个作用域块中并且每个变量 在给定的作用域内只能有一种含义。



\hypertarget{3860142823548396729}{}


\subsubsection{在软作用域}



我们现在已经涵盖了所有局部作用域规则，但在结束本节之前，也许应该说几句关于为什么在交互式和非交互式上下文中处理模糊软作用域的情况不同。 人们可以问两个明显的问题：



\begin{itemize}
\item[1. ] 为什么不都像REPL那样？


\item[2. ] 为什么不都表现得像在文件中那样？并跳过警告？

\end{itemize}


在 Julia ≤ 0.6 的版本中，所有全局作用域确实像当前的 REPL 一样工作：当 \texttt{x = <value>} 发生在循环中（或 \texttt{try}/\texttt{catch} ，\texttt{struct}内）但在函数体（或 \texttt{let} 语句块或推导式）之外时，它根据是否定义了一个名为 \texttt{x} 的全局变量来决定 \texttt{x} 是否应该是循环的局部变量。这种行为具有直观和方便的优点，因为它尽可能接近函数体内部的行为。特别是，当尝试调试函数时，它可以轻松地在函数体和 REPL 之间来回移动代码。 但是，它有一些缺点。首先，这是一种相当复杂的行为：多年来，许多人对这种行为感到困惑，并抱怨说它既复杂又难以解释和理解。这是有道理的。其次，可以说更糟的是，它不利于“大规模”编程。 当你在这样的地方看到一小段代码时，很清楚发生了什么：




\begin{minted}{julia}
s = 0
for i = 1:10
    s += i
end
\end{minted}



显然，代码的意图是修改现有的全局变量\texttt{s}。 这还能是什么意思？ 然而，并非所有现实世界的代码都如此简短或清晰。 我们发现像下面这样的代码经常出现：




\begin{minted}{julia}
x = 123

# much later
# maybe in a different file

for i = 1:10
    x = "hello"
    println(x)
end

# much later
# maybe in yet another file
# or maybe back in the first one where `x = 123`

y = x + 234
\end{minted}



我们非常不清楚这里应该发生什么。 由于 \texttt{x + {\textquotedbl}hello{\textquotedbl}} 是一个方法错误，似乎意图是让 \texttt{x} 在 \texttt{for} 循环中是局部的。 但是运行时值和碰巧存在的方法不能用于确定变量的范围。 对于 Julia ≤ 0.6 的行为，尤其令人担忧的是，有人可能先编写了 \texttt{for} 循环，让它工作得很好，但后来当其他人在远处添加了一个新的全局时——可能是在不同的文件——代码突然改变了含义，要么中断，要么更糟糕的是，默默地做执行了错误的命令。 这种 \href{https://en.wikipedia.org/wiki/Action\_at\_a\_distance\_(computer\_programming)}{“幽灵般的远距离动作”} 是好的编程语言设计应该防止的。



因此，在 Julia 1.0 中，我们简化了作用域的规则：在任何局部作用域中，对一个还不是局部变量的名称进行赋值会创建一个新的局部变量。 这完全消除了软作用域的概念，并消除了幽灵行为的可能性。 由于移除了软作用域，我们发现并修复了大量错误，证明我们选择摆脱它是正确的。我们有很多的欣喜！ 嗯，不，不是真的。 因为有些人很生气，他们现在不得不写：




\begin{minted}{julia}
s = 0
for i = 1:10
    global s += i
end
\end{minted}



你看到那里的\texttt{global}注解了吗？非常令人讨厌。 显然，这种情况是不能容忍的。但更严重的是，这种需要\texttt{global}顶层代码的情况有两个主要问题：



\begin{itemize}
\item[1. ] 从函数体内部复制和粘贴代码到 REPL 来debug不再方便——你必须加上\texttt{global}注释，然后把它删了再复制回去。


\item[2. ] 初学者编写这种代码往往不会加 \texttt{global} ，并且不知道为什么他们的代码不起作用 - 他们得到的错误是 \texttt{s} 未定义，这似乎并没有启发犯错的人。

\end{itemize}


从 Julia 1.5 开始，此代码在 REPL 或 Jupyter 笔记本（就像 Julia 0.6）等交互式上下文中无需\texttt{global}注解即可正确执行，同时，在文件和其他非交互式上下文中，它会打印出以下非常直接的警告：



\begin{quote}
在软作用域中对 \texttt{s} 的赋值是不明确的，因为存在同名的全局变量：\texttt{s} 将被视为新的局部变量。 通过使用 \texttt{local s} 来消除此警告或使用 \texttt{global s} 赋值给现有的全局变量来消除歧义。

\end{quote}


这解决了这两个问题，同时保留了 1.0 行为的“大规模编程”好处：全局变量对可能很远的代码的含义没有幽灵般的影响； 在 REPL 复制粘贴调试工作，初学者没有任何问题； 任何时候有人忘记\texttt{global}注解或不小心用软作用域中的局部变量遮蔽了现有的全局变量，这无论如何都会令人困惑，他们会得到一个很好的明确警告。



这种设计的一个重要特点是，在没有警告的情况下在文件中执行的任何代码在新的 REPL 中的行为方式相同。 另一方面，如果您使用 REPL 会话并将其保存到文件中，如果它的行为与 REPL 中的行为不同，那么您将收到警告。



\hypertarget{10497572111867317266}{}


\subsection{Let 块}



\texttt{let} 语句创建一个新的 \emph{硬作用域} 块（见上文）并在每次运行时引入新的变量绑定。 赋值可能会为现有值地址重新分配一个新值，而 \texttt{let} 总是会创建一个新地址。 这种差异通常并不重要，并且只有在通过闭包超出其作用域的变量的情况下才能检测到。 \texttt{let} 语法接受以逗号分隔的一系列赋值和变量名：




\begin{minted}{jlcon}
julia> x, y, z = -1, -1, -1;

julia> let x = 1, z
           println("x: $x, y: $y") # x is local variable, y the global
           println("z: $z") # errors as z has not been assigned yet but is local
       end
x: 1, y: -1
ERROR: UndefVarError: z not defined
\end{minted}



赋值将按次序执行：作用域右侧先于左侧引入新变量前被执行。这使得类似 \texttt{let x = x} 的写法是有意义的，因为这两个 \texttt{x} 变量并不一样，拥有不同存储位置。\texttt{let} 的行为在如下例子中是必要的：




\begin{minted}{jlcon}
julia> Fs = Vector{Any}(undef, 2); i = 1;

julia> while i <= 2
           Fs[i] = ()->i
           global i += 1
       end

julia> Fs[1]()
3

julia> Fs[2]()
3
\end{minted}



在这里，我们创建并存储了两个返回变量 \texttt{i} 的闭包。但是因为始终是同一个变量\texttt{i}，所以这两个闭包行为是相同的。我们可以使用 \texttt{let} 为 \texttt{i} 创建新绑定：




\begin{minted}{jlcon}
julia> Fs = Vector{Any}(undef, 2); i = 1;

julia> while i <= 2
           let i = i
               Fs[i] = ()->i
           end
           global i += 1
       end

julia> Fs[1]()
1

julia> Fs[2]()
2
\end{minted}



由于 \texttt{begin} 结构不会引入新的作用域，使用零参数 \texttt{let} 来引入一个新的作用域块而不立即创建任何新的绑定是很有用的：




\begin{minted}{jlcon}
julia> let
           local x = 1
           let
               local x = 2
           end
           x
       end
1
\end{minted}



由于\texttt{let} 引入了一个新的作用域块，内部局部变量\texttt{x} 与外部局部变量\texttt{x} 是一个不同的变量。这个特定的例子相当于：




\begin{minted}{jlcon}
julia> let x = 1
           let x = 2
           end
           x
       end
1
\end{minted}



\hypertarget{3992679446378106754}{}


\subsection{循环和数组推导}



对于循环和\hyperlink{3967134426571365188}{数组推导}：在其内部作用域中引入的新变量在每次循环迭代中都会被新分配一块内存，如同被 \texttt{let} 块包围。




\begin{minted}{jlcon}
julia> Fs = Vector{Any}(undef, 2);

julia> for j = 1:2
           Fs[j] = ()->j
       end

julia> Fs[1]()
1

julia> Fs[2]()
2
\end{minted}



\texttt{for} 循环或者推导式的迭代变量始终是个新变量：




\begin{lstlisting}
julia> function f()
           i = 0
           for i = 1:3
               # empty
           end
           return i
       end;

julia> f()
0
\end{lstlisting}



但是偶然地，把一个已有的局部变量作为迭代变量也是有用的。 添加关键字 \texttt{outer} 就能方便地做到：




\begin{minted}{jlcon}
julia> function f()
           i = 0
           for outer i = 1:3
               # empty
           end
           return i
       end;

julia> f()
3
\end{minted}



\hypertarget{5407065244463689569}{}


\section{常量}



变量普遍地用于命名一个特定、不变的值。这些变量只被赋值一次。向编译器传递 \hyperlink{8421885763632484758}{\texttt{const}} 关键字，即可声明这个意图：




\begin{minted}{jlcon}
julia> const e  = 2.71828182845904523536;

julia> const pi = 3.14159265358979323846;
\end{minted}



单个 \texttt{const} 关键字能同时声明多个变量：




\begin{minted}{jlcon}
julia> const a, b = 1, 2
(1, 2)
\end{minted}



\texttt{const} 声明只应使用在全局作用域中的全局变量。因为全局变量的值（甚至类型）可以随时改变，编译器很难优化包含全局变量的代码。而用 \texttt{const} 声明一个不变的全局变量，就能处理这个问题。



局部常量却大有不同。编译器能够自动确定一个局部变量什么时候是不变的，所以局部常量声明是不必要的，其实现在也并不支持。



一些特殊的顶层赋值，比如用了 \texttt{function} 和 \texttt{structure} 关键字，默认就是常量。



注意 \texttt{const} 只会影响变量绑定；变量可能会绑定到一个可变的对象上（比如一个数组）使得其仍然能被改变。另外当尝试给一个声明为常量的变量赋值时，可能出现下列情景：



\begin{itemize}
\item 如果新赋值的类型与原常量类型不一样，会扔出一个错误：

\end{itemize}



\begin{minted}{jlcon}
julia> const x = 1.0
1.0

julia> x = 1
ERROR: invalid redefinition of constant x
\end{minted}



\begin{itemize}
\item 如果新赋值的类型与原常量一样，会打印一个警告：

\end{itemize}



\begin{minted}{jlcon}
julia> const y = 1.0
1.0

julia> y = 2.0
WARNING: redefinition of constant y. This may fail, cause incorrect answers, or produce other errors.
2.0
\end{minted}



\begin{itemize}
\item 如果赋值不导致原变量值变化，则不会给出任何信息：

\end{itemize}



\begin{minted}{jlcon}
julia> const z = 100
100

julia> z = 100
100
\end{minted}



最后一条规则也适用于不可变对象，即使变量绑定的地址改变了，例如：




\begin{minted}{jlcon}
julia> const s1 = "1"
"1"

julia> s2 = "1"
"1"

julia> pointer.([s1, s2], 1)
2-element Array{Ptr{UInt8},1}:
 Ptr{UInt8} @0x00000000132c9638
 Ptr{UInt8} @0x0000000013dd3d18

julia> s1 = s2
"1"

julia> pointer.([s1, s2], 1)
2-element Array{Ptr{UInt8},1}:
 Ptr{UInt8} @0x0000000013dd3d18
 Ptr{UInt8} @0x0000000013dd3d18
\end{minted}



然而对于可变对象，警告会如预期出现：




\begin{minted}{jlcon}
julia> const a = [1]
1-element Vector{Int64}:
 1

julia> a = [1]
WARNING: redefinition of constant a. This may fail, cause incorrect answers, or produce other errors.
1-element Vector{Int64}:
 1
\end{minted}



注意，虽然有时是可能更改常量的值，但是十分不推荐这样做。这样做仅仅是为了便于交互式使用。更改常量可引发多种问题或者非预期行为。举个例子，如果一个方法引用了一个常量并且在常量被更改前已经被编译了，那么该函数很有可能继续使用旧值：




\begin{minted}{jlcon}
julia> const x = 1
1

julia> f() = x
f (generic function with 1 method)

julia> f()
1

julia> x = 2
WARNING: redefinition of constant x. This may fail, cause incorrect answers, or produce other errors.
2

julia> f()
1
\end{minted}



\hypertarget{2141690262982725665}{}


\chapter{类型}



通常，我们把程序语言中的类型系统划分成两类：静态类型和动态类型。对于静态类型系统，在程序运行之前，我们就可计算每一个表达式的类型。而对于动态类型系统，我们只有通过运行那个程序，得到表达式具体的值，才能确定其具体的类型。通过让编写的代码无需在编译时知道值的确切类型，面向对象允许静态类型语言具有一定的灵活性。可以编写在不同类型上都能运行的代码的能力被称为多态。在经典的动态类型语言中，所有的代码都是多态的，这意味着这些代码对于其中值的类型没有约束，除非在代码中去具体的判断一个值的类型，或者对对象做一些它不支持的操作。



Julia 类型系统是动态的，但由于允许指出某些变量具有特定类型，因此占有静态类型系统的一些优势。这对于生成高效的代码非常有帮助，但更重要的是，它允许针对函数参数类型的方法派发与语言深度集成。方法派发将在\hyperlink{3842379394166369470}{方法}中详细探讨，但它根植于此处提供的类型系统。



在类型被省略时，Julia 的默认行为是允许值为任何类型。因此，可以编写许多有用的 Julia 函数，而无需显式使用类型。然而，当需要额外的表达力时，很容易逐渐将显式的类型注释引入先前的「无类型」代码中。添加类型注释主要有三个目的：利用 Julia 强大的多重派发机制、提高代码可读性以及捕获程序错误。



用\href{https://zh.wikipedia.org/wiki/类型系统}{类型系统}的术语描述，Julia是动态（dynamic）、主格（nominative）和参数（parametric）的。泛型可以被参数化，并且类型之间的层次关系可以被\href{https://en.wikipedia.org/wiki/Nominal\_type\_system}{显式地声明}，而不是\href{https://en.wikipedia.org/wiki/Structural\_type\_system}{隐含地通过兼容的结构}。Julia 类型系统的一个特别显著的特征是具体类型相互之间不能是子类型：所有具体类型都是最终的，并且超类只能是抽象类型。虽然这乍一看可能过于严格，但它有许多益处，且缺点却少得出奇。事实证明，能够继承行为比继承结构更重要，同时继承两者在传统的面向对象语言中导致了重大困难。Julia 类型系统的其它高级方面应当在先言明：



\begin{itemize}
\item 对象值和非对象值之间没有分别：Julia 中的所有值都是具有类型的真实对象且其类型属于一个单独的、完全连通的类型图，该类型图的所有节点作为类型一样都是头等的。


\item 「编译期类型」是没有任何意义的概念：变量所具有的唯一类型是程序运行时的实际类型。这在面向对象被称为「运行时类型」，其中静态编译和多态的组合使得这种区别变得显著。


\item 只有值，而不是变量，有类型——变量只是绑定到值的名称，尽管为了简单起见，我们可以说“变量的类型”作为“变量所引用的值的类型”的简写。


\item 抽象类型和具体类型都可以通过其它类型进行参数化。它们的参数化还可通过符号、使得 \hyperlink{12980593021531333073}{\texttt{isbits}} 返回 true 的任意类型的值（实质上，也就是像数字或布尔变量这样的东西，存储方式像 C 类型或不包含指向其它对象的指针的 \texttt{struct}）和其元组。类型参数在不需要被引用或限制时可以省略。

\end{itemize}


Julia 的类型系统设计得强大而富有表现力，却清晰、直观且不引人注目。许多 Julia 程序员可能从未感觉需要编写明确使用类型的代码。但是，某些场景的编程可通过声明类型变得更加清晰、简单、快速和稳健。



\hypertarget{11271598028486730305}{}


\section{类型声明}



\texttt{::} 运算符可以用来在程序中给表达式和变量附加类型注释。这有两个主要原因：



\begin{itemize}
\item[1. ] 作为断言，帮助程序确认能是否正常运行，


\item[2. ] 给编译器提供额外的类型信息，在一些情况下这可以提升程序性能。

\end{itemize}


置于到计算值的表达式后面时，\texttt{::} 操作符读作「是······的实例（is an instance of）」。在任何地方都可以用它来断言左侧表达式的值是右侧类型的实例。当右侧类型是具体类型时，左侧的值必须能够以该类型作为其实现——回想一下，所有具体类型都是最终的，因此没有任何实现是任何其它具体类型的子类型。当右侧类型是抽象类型时，值是由该抽象类型子类型中的某个具体类型实现的才能满足该断言。如果类型断言非真，抛出一个异常，否则返回左侧的值：




\begin{minted}{jlcon}
julia> (1+2)::AbstractFloat
ERROR: TypeError: in typeassert, expected AbstractFloat, got a value of type Int64

julia> (1+2)::Int
3
\end{minted}



这将允许类型断言作用在任意表达式上。



置于赋值语句左侧的变量之后，或作为 \texttt{local} 声明的一部分时，\texttt{::} 操作符的意义有所不同：它声明变量始终具有指定的类型，就像静态类型语言（如 C）中的类型声明。每个被赋给该变量的值都将使用 \hyperlink{1846942650946171605}{\texttt{convert}} 转换为被声明的类型：




\begin{minted}{jlcon}
julia> function foo()
           x::Int8 = 100
           x
       end
foo (generic function with 1 method)

julia> x = foo()
100

julia> typeof(x)
Int8
\end{minted}



这个特性对避免特定的性能「陷阱」很有帮助，比如给一个变量赋值时意外地更改了其类型。



此「声明」行为仅发生在特定上下文中：




\begin{minted}{julia}
local x::Int8  # in a local declaration
x::Int8 = 10   # as the left-hand side of an assignment
\end{minted}



并应用于整个当前作用域，甚至在该声明之前。目前，类型声明不能在全局作用域中使用，例如在 REPL 中就不可以，因为 Julia 还没有常量类型的全局变量。



声明也可以附加到函数定义：




\begin{minted}{julia}
function sinc(x)::Float64
    if x == 0
        return 1
    end
    return sin(pi*x)/(pi*x)
end
\end{minted}



从函数返回时就如同给一个已被声明类型的变量赋值：返回值始终会被转换为\texttt{Float64}。



\hypertarget{5929227155379782502}{}


\section{抽象类型}



抽象类型不能实例化，只能作为类型图中的节点使用，从而描述相关具体类型的集，即那些作为其后代的具体类型。即便抽象类型没有实例， 由于它们是类型系统的主干，故我们首先从抽象类型谈起：抽象类型形成了概念的层次结构，这使得 Julia 的类型系统不只是对象实现的集合。



回想一下，在\hyperlink{8249022581856827126}{整数和浮点数}中，我们介绍了各种数值的具体类型：\hyperlink{5857518405103968275}{\texttt{Int8}}、\hyperlink{6609065134969660118}{\texttt{UInt8}}、\hyperlink{6667287249103968645}{\texttt{Int16}}、\hyperlink{7018610346698168012}{\texttt{UInt16}}、\hyperlink{10103694114785108551}{\texttt{Int32}}、\hyperlink{8690996847580776341}{\texttt{UInt32}}、\hyperlink{7720564657383125058}{\texttt{Int64}}、\hyperlink{5500998675195555601}{\texttt{UInt64}}、\hyperlink{8012327724714767060}{\texttt{Int128}}、\hyperlink{14811222188335428522}{\texttt{UInt128}}、\hyperlink{2727296760866702904}{\texttt{Float16}}、\hyperlink{8101639384272933082}{\texttt{Float32}} 和 \hyperlink{5027751419500983000}{\texttt{Float64}}。尽管 \texttt{Int8}、\texttt{Int16}、\texttt{Int32}、\texttt{Int64} 和 \texttt{Int128} 具有不同的表示大小，但都具有共同的特征，即它们都是带符号的整数类型。类似地，\texttt{UInt8}、\texttt{UInt16}、\texttt{UInt32}、\texttt{UInt64} 和 \texttt{UInt128} 都是无符号整数类型，而 \texttt{Float16}、\texttt{Float32} 和 \texttt{Float64} 是不同的浮点数类型而非整数类型。一段代码只对某些类型有意义是很常见的，比如，只在其参数是某种类型的整数，而不真正取决于特定\emph{类型}的整数时有意义。例如，最大公分母算法适用于所有类型的整数，但不适用于浮点数。抽象类型允许构造类型的层次结构，这给具体类型提供了可以适应的环境。例如，你可以轻松地为任何类型的整数编程，而不用将算法限制为某种特殊类型的整数。



抽象类型可以由 \hyperlink{12403756508738429935}{\texttt{abstract type}} 关键字来声明。声明抽象类型的一般语法是：




\begin{lstlisting}
abstract type «name» end
abstract type «name» <: «supertype» end
\end{lstlisting}



该 \texttt{abstract type} 关键字引入了一个新的抽象类型，\texttt{«name»} 为其名称。此名称后面可以跟 \hyperlink{6254591906563366276}{\texttt{<:}} 和一个已存在的类型，表示新声明的抽象类型是此「父」类型的子类型。



如果没有给出超类型，则默认超类型为 \texttt{Any}——一个已经定义好的抽象类型，所有对象都是 \texttt{Any} 的实例并且所有类型都是 \texttt{Any} 的子类型。在类型理论中，\texttt{Any} 通常称为「top」，因为它位于类型图的顶点。Julia 还有一个预定义了的抽象「bottom」类型，在类型图的最低点，写成 \texttt{Union\{\}}。这与 \texttt{Any} 完全相反：任何对象都不是 \texttt{Union\{\}} 的实例，所有的类型都是 \texttt{Union\{\}} 的超类型。



让我们考虑一些构成 Julia 数值类型层次结构的抽象类型：




\begin{minted}{julia}
abstract type Number end
abstract type Real     <: Number end
abstract type AbstractFloat <: Real end
abstract type Integer  <: Real end
abstract type Signed   <: Integer end
abstract type Unsigned <: Integer end
\end{minted}



\hyperlink{1990584313715697055}{\texttt{Number}} 类型为 \texttt{Any} 类型的直接子类型，并且 \hyperlink{6175959395021454412}{\texttt{Real}} 为它的子类型。接下来，\texttt{Real} 有两个子类型（它还有更多的子类型，但这里只展示了两个，稍后将会看到其它的子类型）： \hyperlink{8469131683393450448}{\texttt{Integer}} 和 \hyperlink{11465394427882483091}{\texttt{AbstractFloat}}，将世界分为整数的表示和实数的表示。实数的表示当然包括浮点类型，但也包括其他类型，例如有理数。因此，\texttt{AbstractFloat} 是一个 \texttt{Real} 的子类型，仅包括实数的浮点表示。整数被进一步细分为 \hyperlink{14154866400772377486}{\texttt{Signed}} 和 \hyperlink{4780971278803506664}{\texttt{Unsigned}} 两类。



\texttt{<:} 运算符的通常意义为「是······的子类型（is a subtype of）」，可以用在声明中，声明右侧类型是新声明类型的直接超类型；也可以在表达式中用作子类型运算符，在其左操作数为其右操作数的子类型时返回 \texttt{true}：




\begin{minted}{jlcon}
julia> Integer <: Number
true

julia> Integer <: AbstractFloat
false
\end{minted}



抽象类型的一个重要用途是为具体类型提供默认实现。举个简单的例子，考虑：




\begin{minted}{julia}
function myplus(x,y)
    x+y
end
\end{minted}



首先需要注意的是上述的参数声明等价于 \texttt{x::Any} 和 \texttt{y::Any}。当函数被调用时，例如 \texttt{myplus(2,5)}，派发器会选择与给定参数相匹配的名称为 \texttt{myplus} 的最具体方法。（有关多重派发的更多信息，请参阅\hyperlink{3842379394166369470}{方法}。）



假设没有找到比上述方法更具体的方法，Julia 则会基于上面给出的泛型函数，在内部定义并编译一个名为 \texttt{myplus} 的方法，专门用于处理两个 \texttt{Int} 参数，即它隐式地定义并编译：




\begin{minted}{julia}
function myplus(x::Int,y::Int)
    x+y
end
\end{minted}



最后，调用这个具体的方法。



因此，抽象类型允许程序员编写泛型函数，泛型函数可以通过许多具体类型的组合用作默认方法。多重派发使得程序员可以完全控制是使用默认方法还是更具体的方法。



需要注意的重点是，即使程序员依赖参数为抽象类型的函数，性能也不会有任何损失，因为它会针对每个调用它的参数元组的具体类型重新编译。（但在函数参数是抽象类型的容器的情况下，可能存在性能问题；请参阅\hyperlink{16419743784254835624}{性能建议}。）



\hypertarget{7048513132833584013}{}


\section{原始类型}



\begin{quote}
\textbf{Warning}

通常情况下更建议在新的复合类型中封装现有的原始类型，而不是重新定义自己的原始类型。

这个功能的存在是为了允许 Julia 能引导受 LLVM 支持的标准基本类型。一旦一些标准类型被定义，就不需要再定义更多了。

\end{quote}


原始类型是具体类型，其数据是由简单的位组成。原始类型的经典示例是整数和浮点数。与大多数语言不同，Julia 允许你声明自己的原始类型，而不是只提供一组固定的内置原始类型。实际上，标准原始类型都是在语言本身中定义的：




\begin{minted}{julia}
primitive type Float16 <: AbstractFloat 16 end
primitive type Float32 <: AbstractFloat 32 end
primitive type Float64 <: AbstractFloat 64 end

primitive type Bool <: Integer 8 end
primitive type Char <: AbstractChar 32 end

primitive type Int8    <: Signed   8 end
primitive type UInt8   <: Unsigned 8 end
primitive type Int16   <: Signed   16 end
primitive type UInt16  <: Unsigned 16 end
primitive type Int32   <: Signed   32 end
primitive type UInt32  <: Unsigned 32 end
primitive type Int64   <: Signed   64 end
primitive type UInt64  <: Unsigned 64 end
primitive type Int128  <: Signed   128 end
primitive type UInt128 <: Unsigned 128 end
\end{minted}



声明原始类型的一般语法是：




\begin{lstlisting}
primitive type «name» «bits» end
primitive type «name» <: «supertype» «bits» end
\end{lstlisting}



bits 的数值表示该类型需要多少存储空间，name 为新类型指定名称。可以选择将一个原始类型声明为某个超类型的子类型。如果省略超类型，则默认 \texttt{Any} 为其直接超类型。上述声明中意味着 \hyperlink{46725311238864537}{\texttt{Bool}} 类型需要 8 位来储存，并且直接超类型为 \hyperlink{8469131683393450448}{\texttt{Integer}}。目前支持的大小只能是 8 位的倍数，不然你就会遇到 LLVM 的 bug。因此，布尔值虽然确实只需要一位，但不能声明为小于 8 位的值。



\hyperlink{46725311238864537}{\texttt{Bool}}，\hyperlink{5857518405103968275}{\texttt{Int8}} 和 \hyperlink{6609065134969660118}{\texttt{UInt8}} 类型都具有相同的表现形式：它们都是 8 位内存块。然而，由于 Julia 的类型系统是主格的，它们尽管具有相同的结构，但不是通用的。它们之间的一个根本区别是它们具有不同的超类型：\hyperlink{46725311238864537}{\texttt{Bool}} 的直接超类型是 \hyperlink{8469131683393450448}{\texttt{Integer}}、\hyperlink{5857518405103968275}{\texttt{Int8}} 的是 \hyperlink{14154866400772377486}{\texttt{Signed}} 而 \hyperlink{6609065134969660118}{\texttt{UInt8}} 的是 \hyperlink{4780971278803506664}{\texttt{Unsigned}}。\hyperlink{46725311238864537}{\texttt{Bool}}，\hyperlink{5857518405103968275}{\texttt{Int8}} 和 \hyperlink{6609065134969660118}{\texttt{UInt8}} 的所有其它差异是行为上的——定义函数的方式在这些类型的对象作为参数给定时起作用。这也是为什么主格的类型系统是必须的：如果结构确定类型，类型决定行为，就不可能使 \hyperlink{46725311238864537}{\texttt{Bool}} 的行为与 \hyperlink{5857518405103968275}{\texttt{Int8}} 或 \hyperlink{6609065134969660118}{\texttt{UInt8}} 有任何不同。



\hypertarget{805665046800217201}{}


\section{复合类型}



\href{https://en.wikipedia.org/wiki/Composite\_data\_type}{复合类型}在各种语言中被称为 record、struct 和 object。复合类型是命名字段的集合，其实例可以视为单个值。复合类型在许多语言中是唯一一种用户可定义的类型，也是 Julia 中最常用的用户定义类型。



在主流的面向对象语言中，比如 C++、Java、Python 和 Ruby，复合类型也具有与它们相关的命名函数，并且该组合称为「对象」。在纯粹的面向对象语言中，例如 Ruby 或 Smalltalk，所有值都是对象，无论它们是否为复合类型。在不太纯粹的面向对象语言中，包括 C++ 和 Java，一些值，比如整数和浮点值，不是对象，而用户定义的复合类型是具有相关方法的真实对象。在 Julia 中，所有值都是对象，但函数不与它们操作的对象捆绑在一起。这是必要的，因为 Julia 通过多重派发选择函数使用的方法，这意味着在选择方法时考虑\emph{所有}函数参数的类型，而不仅仅是第一个（有关方法和派发的更多信息，请参阅\hyperlink{3842379394166369470}{方法}）。因此，函数仅仅「属于」它们的第一个参数是不合适的。将方法组织到函数对象中而不是在每个对象「内部」命名方法最终成为语言设计中一个非常有益的方面。



\hyperlink{4119979838407461137}{\texttt{struct}} 关键字与复合类型一起引入，后跟一个字段名称的块，可选择使用 \texttt{::} 运算符注释类型：




\begin{minted}{jlcon}
julia> struct Foo
           bar
           baz::Int
           qux::Float64
       end
\end{minted}



没有类型注释的字段默认为 \texttt{Any} 类型，所以可以包含任何类型的值。



类型为 \texttt{Foo} 的新对象通过将 \texttt{Foo} 类型对象像函数一样应用于其字段的值来创建：




\begin{minted}{jlcon}
julia> foo = Foo("Hello, world.", 23, 1.5)
Foo("Hello, world.", 23, 1.5)

julia> typeof(foo)
Foo
\end{minted}



像函数一样使用的类型称为\textbf{构造函数}。有两个构造函数已被自动生成（这些构造函数称为\textbf{默认构造函数}）。其中一个接受任何参数并调用 \hyperlink{1846942650946171605}{\texttt{convert}} 函数将它其转换为字段的类型，另一个接受与字段类型完全匹配的参数。两者都生成的原因是，这使得更容易添加新定义而不会在无意中替换默认构造函数。



由于 \texttt{bar} 字段在类型上不受限制，因此任何值都可以。但是 \texttt{baz} 的值必须可转换为 \texttt{Int} 类型：




\begin{minted}{jlcon}
julia> Foo((), 23.5, 1)
ERROR: InexactError: Int64(23.5)
Stacktrace:
[...]
\end{minted}



可以使用 \hyperlink{17481253338332315021}{\texttt{fieldnames}} 函数找到字段名称列表。




\begin{minted}{jlcon}
julia> fieldnames(Foo)
(:bar, :baz, :qux)
\end{minted}



可以使用传统的 \texttt{foo.bar} 表示法访问复合对象的字段值：




\begin{minted}{jlcon}
julia> foo.bar
"Hello, world."

julia> foo.baz
23

julia> foo.qux
1.5
\end{minted}



用 \texttt{struct} 声明的复合对象是\emph{不可变的}；创建后不能修改。乍一看这似乎很奇怪，但它有几个优点：



\begin{itemize}
\item 它可以更高效。某些 struct 可以被高效地打包到数组中，并且在某些情况下，编译器可以避免完全分配不可变对象。


\item 不可能违反类型构造函数提供的不变性。


\item 使用不可变对象的代码更容易推理。

\end{itemize}


不可变对象可以包含可变对象（比如数组）作为字段。那些被包含的对象将保持可变；只是不可变对象本身的字段不能更改为指向不同的对象。



如果需要，可以使用关键字 \hyperlink{15383430693516362700}{\texttt{mutable struct}} 声明可变复合对象，这将在下一节中讨论。



如果一个不可变结构的所有字段都是不可区分的（\texttt{===}），那么包含这些字段的两个不可变值也是不可区分的：




\begin{minted}{jlcon}
julia> struct X
            a::Int
            b::Float64
        end

julia> X(1, 2) === X(1, 2)
true
\end{minted}



关于如何构造复合类型的实例还有很多要说的，但这种讨论依赖于\href{@ref}{参数类型}和\hyperlink{3842379394166369470}{方法}，并且这是非常重要的，应该在专门的章节中讨论：\hyperlink{1489967485005487723}{构造函数}。



\hypertarget{17783679803569553227}{}


\section{可变复合类型}



如果使用 \texttt{mutable struct} 而不是 \texttt{struct} 声明复合类型，则它的实例可以被修改：




\begin{minted}{jlcon}
julia> mutable struct Bar
           baz
           qux::Float64
       end

julia> bar = Bar("Hello", 1.5);

julia> bar.qux = 2.0
2.0

julia> bar.baz = 1//2
1//2
\end{minted}



为了支持修改，这种对象通常分配在堆上，并且具有稳定的内存地址。可变对象就像一个小容器，随着时间的推移，可能保持不同的值，因此只能通过其地址可靠地识别。相反地，不可变类型的实例与特定字段值相关——仅字段值就告诉你该对象的所有内容。在决定是否使类型为可变类型时，请询问具有相同字段值的两个实例是否被视为相同，或者它们是否可能需要随时间独立更改。如果它们被认为是相同的，该类型就应该是不可变的。



总结一下，Julia 的两个基本属性定义了不变性：



\begin{itemize}
\item 不允许修改不可变类型的值。

\begin{itemize}
\item 对于位类型，这意味着值的位模式一旦设置将不再改变，并且该值是位类型的标识。


\item 对于复合类型，这意味着其字段值的标识将不再改变。当字段是位类型时，这意味着它们的位将不再改变，对于其值是可变类型（如数组）的字段，这意味着字段将始终引用相同的可变值，尽管该可变值的内容本身可能被修改。

\end{itemize}

\item 具有不可变类型的对象可以被编译器自由复制，因为其不可变性使得不可能以编程方式区分原始对象和副本。

\begin{itemize}
\item 特别地，这意味着足够小的不可变值（如整数和浮点数）通常在寄存器（或栈分配）中传递给函数。


\item 另一方面，可变值是堆分配的，并作为指向堆分配值的指针传递给函数，除非编译器确定没有办法知道这不是正在发生的事情。

\end{itemize}
\end{itemize}


\hypertarget{10034263194628846298}{}


\section{已声明的类型}



前面章节中讨论的三种类型（抽象、原始、复合）实际上都是密切相关的。它们共有相同的关键属性：



\begin{itemize}
\item 它们都是显式声明的。


\item 它们都具有名称。


\item 它们都已经显式声明超类型。


\item 它们可以有参数。

\end{itemize}


由于这些共有属性，它们在内部表现为相同概念 \texttt{DataType} 的实例，其是任何这些类型的类型：




\begin{minted}{jlcon}
julia> typeof(Real)
DataType

julia> typeof(Int)
DataType
\end{minted}



\texttt{DataType} 可以是抽象的或具体的。它如果是具体的，就具有指定的大小、存储布局和字段名称（可选）。因此，原始类型是具有非零大小的 \texttt{DataType}，但没有字段名称。复合类型是具有字段名称或者为空（大小为零）的 \texttt{DataType}。



每一个具体的值在系统里都是某个 \texttt{DataType} 的实例。



\hypertarget{5785180493438363730}{}


\section{类型共用体}



类型共用体是一种特殊的抽象类型，它包含作为对象的任何参数类型的所有实例，使用特殊\hyperlink{5087820771052303592}{\texttt{Union}}关键字构造：




\begin{minted}{jlcon}
julia> IntOrString = Union{Int,AbstractString}
Union{Int64, AbstractString}

julia> 1 :: IntOrString
1

julia> "Hello!" :: IntOrString
"Hello!"

julia> 1.0 :: IntOrString
ERROR: TypeError: in typeassert, expected Union{Int64, AbstractString}, got a value of type Float64
\end{minted}



许多语言都有内建的共用体结构来推导类型；Julia 简单地将它暴露给程序员。Julia 编译器能在 \texttt{Union} 类型只具有少量类型\footnotemark[1]的情况下生成高效的代码，方法是为每个可能类型的不同分支都生成专用代码。



\texttt{Union} 类型的一种特别有用的情况是 \texttt{Union\{T, Nothing\}}，其中 \texttt{T} 可以是任何类型，\hyperlink{13508459519898889544}{\texttt{Nothing}} 是单态类型，其唯一实例是对象 \hyperlink{9331422207248206047}{\texttt{nothing}}。此模式是其它语言中 \href{https://en.wikipedia.org/wiki/Nullable\_type}{\texttt{Nullable}、\texttt{Option} 或 \texttt{Maybe}} 类型在 Julia 的等价。通过将函数参数或字段声明为 \texttt{Union\{T, Nothing\}}，可以将其设置为类型为 \texttt{T} 的值，或者 \texttt{nothing} 来表示没有值。有关详细信息，请参阅\hyperlink{11397816795210039176}{常见问题的此条目}。



\hypertarget{1236004098330686506}{}


\section{参数类型}



Julia 类型系统的一个重要和强大的特征是它是参数的：类型可以接受参数，因此类型声明实际上引入了一整套新类型——每一个参数值的可能组合引入一个新类型。许多语言支持某种版本的\href{https://en.wikipedia.org/wiki/Generic\_programming}{泛型编程}，其中，可以指定操作泛型的数据结构和算法，而无需指定所涉及的确切类型。例如，某些形式的泛型编程存在于 ML、Haskell、Ada、Eiffel、C++、Java、C\#、F\#、和 Scala 中，这只是其中的一些例子。这些语言中的一些支持真正的参数多态（例如 ML、Haskell、Scala），而其它语言基于模板的泛型编程风格（例如 C++、Java）。由于在不同语言中有多种不同种类的泛型编程和参数类型，我们甚至不会尝试将 Julia 的参数类型与其它语言的进行比较，而是专注于解释 Julia 系统本身。然而，我们将注意到，因为 Julia 是动态类型语言并且不需要在编译时做出所有类型决定，所以许多在静态参数类型系统中遇到的传统困难可以被相对容易地处理。



所有已声明的类型（\texttt{DataType} 类型）都可被参数化，在每种情况下都使用一样的语法。我们将按一下顺序讨论它们：首先是参数复合类型，接着是参数抽象类型，最后是参数原始类型。



\hypertarget{3401660112009333580}{}


\subsection{参数复合类型}



类型参数在类型名称后引入，用大括号扩起来：




\begin{minted}{jlcon}
julia> struct Point{T}
           x::T
           y::T
       end
\end{minted}



此声明定义了一个新的参数类型，\texttt{Point\{T\}}，拥有类型为 \texttt{T} 的两个「坐标」。有人可能会问 \texttt{T} 是什么？嗯，这恰恰是参数类型的重点：它可以是任何类型（或者任何位类型值，虽然它实际上在这里显然用作类型）。\texttt{Point\{Float64\}} 是一个具体类型，该类型等价于通过用 \hyperlink{5027751419500983000}{\texttt{Float64}} 替换 \texttt{Point} 的定义中的 \texttt{T} 所定义的类型。因此，单独这一个声明实际上声明了无限个类型：\texttt{Point\{Float64\}}，\texttt{Point\{AbstractString\}}，\texttt{Point\{Int64\}}，等等。这些类型中的每一个类型现在都是可用的具体类型：




\begin{minted}{jlcon}
julia> Point{Float64}
Point{Float64}

julia> Point{AbstractString}
Point{AbstractString}
\end{minted}



\texttt{Point\{Float64\}} 类型是坐标为 64 位浮点值的点，而 \texttt{Point\{AbstractString\}} 类型是「坐标」为字符串对象（请参阅 \href{@id man-strings}{Strings}）的「点」。



\texttt{Point} 本身也是一个有效的类型对象，包括所有实例 \texttt{Point\{Float64\}}、\texttt{Point\{AbstractString\}} 等作为子类型：




\begin{minted}{jlcon}
julia> Point{Float64} <: Point
true

julia> Point{AbstractString} <: Point
true
\end{minted}



当然，其他类型不是它的子类型：




\begin{minted}{jlcon}
julia> Float64 <: Point
false

julia> AbstractString <: Point
false
\end{minted}



\texttt{Point} 不同 \texttt{T} 值所声明的具体类型之间，不能互相作为子类型：




\begin{minted}{jlcon}
julia> Point{Float64} <: Point{Int64}
false

julia> Point{Float64} <: Point{Real}
false
\end{minted}



\begin{quote}
\textbf{Warning}

最后一点\emph{非常}重要：即使 \texttt{Float64 <: Real} 也\textbf{没有} \texttt{Point\{Float64\} <: Point\{Real\}}。

\end{quote}


换成类型理论说法，Julia 的类型参数是\emph{不变的}，而不是\href{https://en.wikipedia.org/wiki/Covariance\_and\_contravariance\_\%28computer\_science\%29}{协变的（或甚至是逆变的）}。这是出于实际原因：虽然任何 \texttt{Point\{Float64\}} 的实例在概念上也可能像是 \texttt{Point\{Real\}} 的实例，但这两种类型在内存中有不同的表示：



\begin{itemize}
\item \texttt{Point\{Float64\}} 的实例可以紧凑而高效地表示为一对 64 位立即数；


\item \texttt{Point\{Real\}} 的实例必须能够保存任何一对 \hyperlink{6175959395021454412}{\texttt{Real}} 的实例。由于 \texttt{Real} 实例的对象可以具有任意的大小和结构，\texttt{Point\{Real\}} 的实例实际上必须表示为一对指向单独分配的 \texttt{Real} 对象的指针。

\end{itemize}


在数组的情况下，能够以立即数存储 \texttt{Point\{Float64\}} 对象会极大地提高效率：\texttt{Array\{Float64\}} 可以存储为一段 64 位浮点值组成的连续内存块，而 \texttt{Array\{Real\}} 必须是一个由指向单独分配的 \hyperlink{6175959395021454412}{\texttt{Real}} 的指针组成的数组——这可能是 \href{https://en.wikipedia.org/wiki/Object\_type\_\%28object-oriented\_programming\%29\#Boxing}{boxed} 64 位浮点值，但也可能是任意庞大和复杂的对象，且其被声明为 \texttt{Real} 抽象类型的表示。



由于 \texttt{Point\{Float64\}} 不是 \texttt{Point\{Real\}} 的子类型，下面的方法不适用于类型为 \texttt{Point\{Float64\}} 的参数：




\begin{minted}{julia}
function norm(p::Point{Real})
    sqrt(p.x^2 + p.y^2)
end
\end{minted}



一种正确的方法来定义一个接受类型的所有参数的方法，\texttt{Point\{T\}}其中\texttt{T}是一个子类型\hyperlink{6175959395021454412}{\texttt{Real}}：




\begin{minted}{julia}
function norm(p::Point{<:Real})
    sqrt(p.x^2 + p.y^2)
end
\end{minted}



（等效地，另一种定义方法 \texttt{function norm(p::Point\{T\} where T<:Real)} 或 \texttt{function norm(p::Point\{T\}) where T<:Real}；查看 \hyperlink{11072845175692859046}{UnionAll 类型}。）



稍后将在\hyperlink{3842379394166369470}{方法}中讨论更多示例。



如何构造一个 \texttt{Point} 对象？可以为复合类型定义自定义的构造函数，这将在\hyperlink{1489967485005487723}{构造函数}中详细讨论，但在没有任何特别的构造函数声明的情况下，有两种默认方式可以创建新的复合对象，一种是显式地给出类型参数，另一种是通过传给对象构造函数的参数隐式地推断出。



由于 \texttt{Point\{Float64\}} 类型等价于在 \texttt{Point} 声明时用 \hyperlink{5027751419500983000}{\texttt{Float64}} 替换 \texttt{T} 得到的具体类型，它可以相应地作为构造函数使用：




\begin{minted}{jlcon}
julia> p = Point{Float64}(1.0, 2.0)
Point{Float64}(1.0, 2.0)

julia> typeof(p)
Point{Float64}
\end{minted}



对于默认的构造函数，必须为每个字段提供一个参数：




\begin{minted}{jlcon}
julia> Point{Float64}(1.0)
ERROR: MethodError: no method matching Point{Float64}(::Float64)
[...]

julia> Point{Float64}(1.0,2.0,3.0)
ERROR: MethodError: no method matching Point{Float64}(::Float64, ::Float64, ::Float64)
[...]
\end{minted}



参数类型只生成一个默认的构造函数，因为它无法覆盖。这个构造函数接受任何参数并将它们转换为字段的类型。



许多情况下，没有必要提供想要构造的 \texttt{Point} 对象的类型，因为构造函数调用参数的类型已经隐式地提供了类型信息。因此，你也可以将 \texttt{Point} 本身用作构造函数，前提是参数类型 \texttt{T} 的隐含值是明确的：




\begin{minted}{jlcon}
julia> p1 = Point(1.0,2.0)
Point{Float64}(1.0, 2.0)

julia> typeof(p1)
Point{Float64}

julia> p2 = Point(1,2)
Point{Int64}(1, 2)

julia> typeof(p2)
Point{Int64}
\end{minted}



在 \texttt{Point} 的例子中，当且仅当 \texttt{Point} 的两个参数类型相同时，\texttt{T} 的类型才确实是隐含的。如果不是这种情况，构造函数将失败并出现 \hyperlink{68769522931907606}{\texttt{MethodError}}：




\begin{minted}{jlcon}
julia> Point(1,2.5)
ERROR: MethodError: no method matching Point(::Int64, ::Float64)
Closest candidates are:
  Point(::T, !Matched::T) where T at none:2
\end{minted}



可以定义适当处理此类混合情况的函数构造方法，将在后面的\hyperlink{1489967485005487723}{构造函数}中讨论。



\hypertarget{2167251626535554270}{}


\subsection{参数抽象类型}



参数抽象类型声明以非常相似的方式声明了一族抽象类型：




\begin{minted}{jlcon}
julia> abstract type Pointy{T} end
\end{minted}



在此声明中，对于每个类型或整数值 \texttt{T}，\texttt{Pointy\{T\}} 都是不同的抽象类型。与参数复合类型一样，每个此类型的实例都是 \texttt{Pointy} 的子类型：




\begin{minted}{jlcon}
julia> Pointy{Int64} <: Pointy
true

julia> Pointy{1} <: Pointy
true
\end{minted}



参数抽象类型是不变的，就像参数复合类型：




\begin{minted}{jlcon}
julia> Pointy{Float64} <: Pointy{Real}
false

julia> Pointy{Real} <: Pointy{Float64}
false
\end{minted}



符号 \texttt{Pointy\{<:Real\}} 可用于表示\emph{协变}类型的 Julia 类似物，而 \texttt{Pointy\{>:Int\}} 类似于\emph{逆变}类型，但从技术上讲，它们都代表了类型的\emph{集合}（参见 \hyperlink{11072845175692859046}{UnionAll 类型}）。




\begin{minted}{jlcon}
julia> Pointy{Float64} <: Pointy{<:Real}
true

julia> Pointy{Real} <: Pointy{>:Int}
true
\end{minted}



正如之前的普通抽象类型用于在具体类型上创建实用的类型层次结构一样，参数抽象类型在参数复合类型上具有相同的用途。例如，我们可以将 \texttt{Point\{T\}} 声明为 \texttt{Pointy\{T\}} 的子类型，如下所示：




\begin{minted}{jlcon}
julia> struct Point{T} <: Pointy{T}
           x::T
           y::T
       end
\end{minted}



鉴于此类声明，对每个 \texttt{T}，都有 \texttt{Point\{T\}} 是 \texttt{Pointy\{T\}} 的子类型：




\begin{minted}{jlcon}
julia> Point{Float64} <: Pointy{Float64}
true

julia> Point{Real} <: Pointy{Real}
true

julia> Point{AbstractString} <: Pointy{AbstractString}
true
\end{minted}



下面的关系依然不变：




\begin{minted}{jlcon}
julia> Point{Float64} <: Pointy{Real}
false

julia> Point{Float64} <: Pointy{<:Real}
true
\end{minted}



参数抽象类型（比如 \texttt{Pointy}）的用途是什么？考虑一下如果点都在对角线 \emph{x = y} 上，那我们创建的点的实现可以只有一个坐标：




\begin{minted}{jlcon}
julia> struct DiagPoint{T} <: Pointy{T}
           x::T
       end
\end{minted}



现在，\texttt{Point\{Float64\}} 和 \texttt{DiagPoint\{Float64\}} 都是抽象 \texttt{Pointy\{Float64\}} 的实现，每个类型 \texttt{T} 的其它可能选择与之类似。这允许对被所有 \texttt{Pointy} 对象共享的公共接口进行编程，接口都由 \texttt{Point} 和 \texttt{DiagPoint} 实现。但是，直到我们在下一节\hyperlink{3842379394166369470}{方法}中引入方法和分派前，这无法完全证明。



有时，类型参数取遍所有可能类型也许是无意义的。在这种情况下，可以像这样约束 \texttt{T} 的范围：




\begin{minted}{jlcon}
julia> abstract type Pointy{T<:Real} end
\end{minted}



在这样的声明中，可以使用任何 \hyperlink{6175959395021454412}{\texttt{Real}} 的子类型替换 \texttt{T}，但不能使用不是 \texttt{Real} 子类型的类型：




\begin{minted}{jlcon}
julia> Pointy{Float64}
Pointy{Float64}

julia> Pointy{Real}
Pointy{Real}

julia> Pointy{AbstractString}
ERROR: TypeError: in Pointy, in T, expected T<:Real, got Type{AbstractString}

julia> Pointy{1}
ERROR: TypeError: in Pointy, in T, expected T<:Real, got a value of type Int64
\end{minted}



参数化复合类型的类型参数可用相同的方式限制：




\begin{minted}{julia}
struct Point{T<:Real} <: Pointy{T}
    x::T
    y::T
end
\end{minted}



这里给出了一个真实示例，展示了所有这些参数类型机制如何发挥作用，下面是 Julia 的不可变类型 \hyperlink{8304566144531167610}{\texttt{Rational}} 的实际定义（除了我们为了简单起见省略了的构造函数），用来表示准确的整数比例：




\begin{minted}{julia}
struct Rational{T<:Integer} <: Real
    num::T
    den::T
end
\end{minted}



只有接受整数值的比例才是有意义的，因此参数类型 \texttt{T} 被限制为 \hyperlink{8469131683393450448}{\texttt{Integer}} 的子类型，又整数的比例代表实数轴上的值，因此任何 \hyperlink{8304566144531167610}{\texttt{Rational}} 都是抽象 \hyperlink{6175959395021454412}{\texttt{Real}} 的实现。



\hypertarget{5158816437121320312}{}


\subsection{元组类型}



元组类型是函数参数的抽象化——不带函数本身。函数参数的突出特征是它们的顺序和类型。因此，元组类型类似于参数化的不可变类型，其中每个参数都是一个字段的类型。例如，二元元组类型类似于以下不可变类型：




\begin{minted}{julia}
struct Tuple2{A,B}
    a::A
    b::B
end
\end{minted}



然而，有三个主要差异：



\begin{itemize}
\item 元组类型可以具有任意数量的参数。


\item 元组类型的参数是\textbf{协变的}（covariant）：\texttt{Tuple\{Int\}} 是 \texttt{Tuple\{Any\}} 的子类型。因此，\texttt{Tuple\{Any\}} 被认为是一种抽象类型，且元组类型只有在它们的参数都是具体类型时才是具体类型。


\item 元组没有字段名称; 字段只能通过索引访问。

\end{itemize}


元组值用括号和逗号书写。构造元组时，会根据需要生成适当的元组类型：




\begin{minted}{jlcon}
julia> typeof((1,"foo",2.5))
Tuple{Int64, String, Float64}
\end{minted}



请注意协变性的含义：




\begin{minted}{jlcon}
julia> Tuple{Int,AbstractString} <: Tuple{Real,Any}
true

julia> Tuple{Int,AbstractString} <: Tuple{Real,Real}
false

julia> Tuple{Int,AbstractString} <: Tuple{Real,}
false
\end{minted}



直观地，这对应于函数参数的类型是函数签名（当函数签名匹配时）的子类型。



\hypertarget{5746534767732668628}{}


\subsection{变参元组类型}



元组类型的最后一个参数可以是特殊值\hyperlink{5941806424098279588}{\texttt{Vararg}}，它表示任意数量的尾随参数：  




\begin{minted}{jlcon}
julia> mytupletype = Tuple{AbstractString,Vararg{Int}}
Tuple{AbstractString, Vararg{Int64}}

julia> isa(("1",), mytupletype)
true

julia> isa(("1",1), mytupletype)
true

julia> isa(("1",1,2), mytupletype)
true

julia> isa(("1",1,2,3.0), mytupletype)
false
\end{minted}



此外，\texttt{Vararg\{T\}} 对应于零个或更多的类型为 \texttt{T} 的元素。变参元组类型被用来表示变参方法接受的参数（请参阅\hyperlink{9965084594348935329}{变参函数}）。  



特殊值 \texttt{Vararg\{T,N\}}（当用作元组类型的最后一个参数时）正好对应于类型为 \texttt{T} 的 \texttt{N} 个元素。 \texttt{NTuple\{N,T\}} 是 \texttt{Tuple\{Vararg\{T,N\}\}} 的一个方便的别名，即一个包含正好包含 \texttt{T} 类型的 \texttt{N} 个元素的元组类型。



\hypertarget{6997324644254770141}{}


\subsection{具名元组类型}



具名元组是 \hyperlink{3845731488275720657}{\texttt{NamedTuple}} 类型的实例，该类型有两个参数：一个给出字段名称的符号元组，和一个给出字段类型的元组类型。




\begin{minted}{jlcon}
julia> typeof((a=1,b="hello"))
NamedTuple{(:a, :b), Tuple{Int64, String}}
\end{minted}



\hyperlink{6227584413761290041}{\texttt{@NamedTuple}} 宏提供了类结构体（\texttt{struct}）的具名元组（\texttt{NamedTuple}）声明，使用 \texttt{key::Type} 的语法，如果省略 \texttt{::Type} 则默认为 \texttt{::Any}。




\begin{minted}{jlcon}
julia> @NamedTuple{a::Int, b::String}
NamedTuple{(:a, :b), Tuple{Int64, String}}

julia> @NamedTuple begin
           a::Int
           b::String
       end
NamedTuple{(:a, :b), Tuple{Int64, String}}
\end{minted}



\texttt{NamedTuple} 类型可以用作构造函数，接受一个单独的元组作为参数。构造出来的 \texttt{NamedTuple} 类型可以是具体类型，如果参数都被指定，也可以是只由字段名称所指定的类型：




\begin{minted}{jlcon}
julia> @NamedTuple{a::Float32,b::String}((1,""))
(a = 1.0f0, b = "")

julia> NamedTuple{(:a, :b)}((1,""))
(a = 1, b = "")
\end{minted}



如果指定了字段类型，参数会被转换。否则，就直接使用参数的类型。



\hypertarget{2858316496912626713}{}


\subsection{参数原始类型}



原始类型也可以参数化声明，例如，指针都能表示为原始类型，其在 Julia 中以如下方式声明：




\begin{minted}{julia}
# 32-bit system:
primitive type Ptr{T} 32 end

# 64-bit system:
primitive type Ptr{T} 64 end
\end{minted}



与典型的参数复合类型相比，此声明中略显奇怪的特点是类型参数 \texttt{T} 并未在类型本身的定义里使用——它实际上只是一个抽象的标记，定义了一整族具有相同结构的类型，类型间仅由它们的类型参数来区分。因此，\texttt{Ptr\{Float64\}} 和 \texttt{Ptr\{Int64\}} 是不同的类型，就算它们具有相同的表示。当然，所有特定的指针类型都是总类型 \hyperlink{10630331440513004826}{\texttt{Ptr}} 的子类型：




\begin{minted}{jlcon}
julia> Ptr{Float64} <: Ptr
true

julia> Ptr{Int64} <: Ptr
true
\end{minted}



\hypertarget{1421020605730253291}{}


\section{UnionAll 类型}



我们已经说过，像 \texttt{Ptr} 这样的参数类型可充当它所有实例（\texttt{Ptr\{Int64\}} 等）的超类型。这是如何办到的？\texttt{Ptr} 本身不能是普通的数据类型，因为在不知道引用数据的类型时，该类型显然不能用于存储器操作。答案是 \texttt{Ptr}（或其它参数类型像 \texttt{Array}）是一种不同种类的类型，称为 \hyperlink{13291956087044414878}{\texttt{UnionAll}} 类型。这种类型表示某些参数的所有值的类型的\emph{迭代并集}。



\texttt{UnionAll} 类型通常使用关键字 \texttt{where} 编写。例如，\texttt{Ptr} 可以更精确地写为 \texttt{Ptr\{T\} where T}，也就是对于 \texttt{T} 的某些值，所有类型为 \texttt{Ptr\{T\}} 的值。在这种情况下，参数 \texttt{T} 也常被称为「类型变量」，因为它就像一个取值范围为类型的变量。每个 \texttt{where} 只引入一个类型变量，因此在具有多个参数的类型中这些表达式会被嵌套，例如 \texttt{Array\{T,N\} where N where T}。



类型应用语法 \texttt{A\{B,C\}} 要求 \texttt{A} 是个 \texttt{UnionAll} 类型，并先代入 \texttt{B} 作为 \texttt{A} 中最外层的类型变量。结果应该是另一个 \texttt{UnionAll} 类型，然后再将 \texttt{C} 代入。所以 \texttt{A\{B,C\}} 等价于 \texttt{A\{B\}\{C\}}。这解释了为什么可以部分实例化一个类型，比如 \texttt{Array\{Float64\}}：第一个参数已经被固定，但第二个参数仍取遍所有可能值。通过使用 \texttt{where} 语法，任何参数子集都能被固定。例如，所有一维数组的类型可以写为 \texttt{Array\{T,1\} where T}。



类型变量可以用子类型关系来加以限制。\texttt{Array\{T\} where T<:Integer} 指的是元素类型是某种 \hyperlink{8469131683393450448}{\texttt{Integer}} 的所有数组。语法 \texttt{Array\{<:Integer\}} 是 \texttt{Array\{T\} where T<:Integer} 的便捷的缩写。类型变量可同时具有上下界。\texttt{Array\{T\} where Int<:T<:Number} 指的是元素类型为能够包含 \texttt{Int} 的 \hyperlink{1990584313715697055}{\texttt{Number}} 的所有数组（因为 \texttt{T} 至少和 \texttt{Int} 一样大）。语法 \texttt{where T>:Int} 也能用来只指定类型变量的下界，且 \texttt{Array\{>:Int\}} 等价于 \texttt{Array\{T\} where T>:Int}。



由于 \texttt{where} 表达式可以嵌套，类型变量界可以引用更外层的类型变量。比如 \texttt{Tuple\{T,Array\{S\}\} where S<:AbstractArray\{T\} where T<:Real} 指的是二元元组，其第一个元素是某个 \hyperlink{6175959395021454412}{\texttt{Real}}，而第二个元素是数组的数组 \texttt{Array}，其包含的内部数组的元素类型由元组的第一个元素类型决定。



\texttt{where} 关键字本身可以嵌套在更复杂的声明里。例如，考虑由以下声明创建的两个类型：




\begin{minted}{jlcon}
julia> const T1 = Array{Array{T, 1} where T, 1}
Vector{Vector} (alias for Array{Array{T, 1} where T, 1})

julia> const T2 = Array{Array{T, 1}, 1} where T
Array{Vector{T}, 1} where T
\end{minted}



类型 \texttt{T1} 定义了由一维数组组成的一维数组；每个内部数组由相同类型的对象组成，但此类型对于不同内部数组可以不同。另一方面，类型 \texttt{T2} 定义了由一维数组组成的一维数组，其中的每个内部数组必须具有相同的类型。请注意，\texttt{T2} 是个抽象类型，比如 \texttt{Array\{Array\{Int,1\},1\} <: T2}，而 \texttt{T1} 是个具体类型。因此，\texttt{T1} 可由零参数构造函数 \texttt{a=T1()} 构造，但 \texttt{T2} 不行。



命名此类型有一种方便的语法，类似于函数定义语法的简短形式：




\begin{minted}{julia}
Vector{T} = Array{T, 1}
\end{minted}



这等价于 \texttt{const Vector = Array\{T,1\} where T}。编写 \texttt{Vector\{Float64\}} 等价于编写 \texttt{Array\{Float64,1\}}，总类型 \texttt{Vector} 具有所有 \texttt{Array} 对象的实例，其中 \texttt{Array} 对象的第二个参数——数组维数——是 1，而不考虑元素类型是什么。在参数类型必须总被完整指定的语言中，这不是特别有用，但在 Julia 中，这允许只编写 \texttt{Vector} 来表示包含任何元素类型的所有一维密集数组的抽象类型。



\hypertarget{647919389478144252}{}


\section{单例类型}



没有字段的不可变复合类型称为 \emph{单例类型}。正式地，如果



\begin{itemize}
\item[1. ] \texttt{T} 是一个不可变的复合类型（即用 \texttt{struct} 定义），


\item[2. ] \texttt{a isa T \&\& b isa T} 暗含 \texttt{a === b},

\end{itemize}


那么\texttt{T}是单例类型。\footnotemark[2] \hyperlink{1553131089235872077}{\texttt{Base.issingletontype}} 可以用来检查一个类型是否是单例类型。 \hyperlink{1549354324836889217}{抽象类型} 不能通过构造成为单例类型。



根据定义，此类类型只能有一个实例：




\begin{minted}{jlcon}
julia> struct NoFields
       end

julia> NoFields() === NoFields()
true

julia> Base.issingletontype(NoFields)
true
\end{minted}



\hyperlink{7974744969331231272}{\texttt{===}} 函数确认\texttt{NoFields} 的构造实例实际上是一个且相同的。



当上述条件成立时，参数类型可以是单例类型。例如，




\begin{minted}{jlcon}
julia> struct NoFieldsParam{T}
       end

julia> Base.issingletontype(NoFieldsParam) # can't be a singleton type ...
false

julia> NoFieldsParam{Int}() isa NoFieldsParam # ... because it has ...
true

julia> NoFieldsParam{Bool}() isa NoFieldsParam # ... multiple instances
true

julia> Base.issingletontype(NoFieldsParam{Int}) # parametrized, it is a singleton
true

julia> NoFieldsParam{Int}() === NoFieldsParam{Int}()
true
\end{minted}



\hypertarget{17554473119913222331}{}


\section{\texttt{Type\{T\}} 类型选择器}



对于每个类型\texttt{T}，\texttt{Type\{T\}} 是一个抽象的参数类型，它的唯一实例是对象\texttt{T}。 在我们讨论 \hyperlink{5820282638415739482}{参数方法} 和 \hyperlink{10374023657104680331}{类型转换} 之前，很难解释这个构造的效用，但简而言之，它允许人们专门针对特定类型的函数行为 作为\emph{值}。 这对于编写其行为取决于作为显式参数给出的类型而不是由其参数之一的类型隐含的类型的方法（尤其是参数方法）很有用。



由于定义有点难理解，我们来看一些例子：




\begin{minted}{jlcon}
julia> isa(Float64, Type{Float64})
true

julia> isa(Real, Type{Float64})
false

julia> isa(Real, Type{Real})
true

julia> isa(Float64, Type{Real})
false
\end{minted}



换句话说，\href{@ref}{\texttt{is(A, Type\{B\})}} 当且仅当 \texttt{A} 和 \texttt{B} 是同一个对象并且该对象是一个类型时才为真。



特别的，由于参数类型是 \hyperlink{17413469367194810249}{不变量}，我们有




\begin{minted}{jlcon}
julia> struct TypeParamExample{T}
           x::T
       end

julia> TypeParamExample isa Type{TypeParamExample}
true

julia> TypeParamExample{Int} isa Type{TypeParamExample}
false

julia> TypeParamExample{Int} isa Type{TypeParamExample{Int}}
true
\end{minted}



如果没有参数，\texttt{Type} 只是一个抽象类型，所有类型对象都是其实例：




\begin{minted}{jlcon}
julia> isa(Type{Float64}, Type)
true

julia> isa(Float64, Type)
true

julia> isa(Real, Type)
true
\end{minted}



不是类型的对象不是 \texttt{Type} 的实例：




\begin{minted}{jlcon}
julia> isa(1, Type)
false

julia> isa("foo", Type)
false
\end{minted}



虽然 \texttt{Type} 与任何其他抽象参数类型一样是 Julia 类型层次结构的一部分，但它并不常用在方法签名之外，除非在某些特殊情况下。 \texttt{Type} 的另一个重要用法是使不太精确的字段类型更加清晰，例如\hyperlink{10085633296969666313}{\texttt{DataType}} 在下面的示例中，默认构造函数可能会导致依赖精确包装类型的代码出现性能问题（类似于 [抽象类型参数](@ref man-performance-abstract-container））。




\begin{minted}{jlcon}
julia> struct WrapType{T}
       value::T
       end

julia> WrapType(Float64) # default constructor, note DataType
WrapType{DataType}(Float64)

julia> WrapType(::Type{T}) where T = WrapType{Type{T}}(T)
WrapType

julia> WrapType(Float64) # sharpened constructor, note more precise Type{Float64}
WrapType{Type{Float64}}(Float64)
\end{minted}



\hypertarget{11325503690546832900}{}


\section{类型别名}



有时为一个已经可表达的类型引入新名称是很方便的。这可通过一个简单的赋值语句完成。例如，\texttt{UInt} 是 \hyperlink{8690996847580776341}{\texttt{UInt32}} 或 \hyperlink{5500998675195555601}{\texttt{UInt64}} 的别名，因为它的大小与系统上的指针大小是相适应的。




\begin{minted}{jlcon}
# 32-bit system:
julia> UInt
UInt32

# 64-bit system:
julia> UInt
UInt64
\end{minted}



这是由 \texttt{base/boot.jl} 中以下代码实现的：




\begin{minted}{julia}
if Int === Int64
    const UInt = UInt64
else
    const UInt = UInt32
end
\end{minted}



当然，这依赖于 \texttt{Int} 的别名，但它被预定义成正确的类型—— \hyperlink{10103694114785108551}{\texttt{Int32}} 或 \hyperlink{7720564657383125058}{\texttt{Int64}}。



（注意，与 \texttt{Int} 不同，\texttt{Float} 不作为特定大小的 \hyperlink{11465394427882483091}{\texttt{AbstractFloat}} 类型的别名而存在。与整数寄存器不同，浮点数寄存器大小由 IEEE-754 标准指定，而 \texttt{Int} 的大小反映了该机器上本地指针的大小。）



\hypertarget{17381545984694686313}{}


\section{类型操作}



因为 Julia 中的类型本身就是对象，所以一般的函数可以对它们进行操作。已经引入了一些对于使用或探索类型特别有用的函数，例如 \texttt{<:} 运算符，它表示其左操作数是否为其右操作数的子类型。



\hyperlink{7066325108767373297}{\texttt{isa}} 函数测试对象是否具有给定类型并返回 true 或 false：




\begin{minted}{jlcon}
julia> isa(1, Int)
true

julia> isa(1, AbstractFloat)
false
\end{minted}



在文档示例中随处可见的 \hyperlink{13440452181855594120}{\texttt{typeof}} 函数返回其参数的类型。如上所述，因为类型都是对象，所以它们也有类型，我们可以询问它们的类型：




\begin{minted}{jlcon}
julia> typeof(Rational{Int})
DataType

julia> typeof(Union{Real,String})
Union
\end{minted}



如果我们重复这个过程会怎样？一个类型的类型是什么？碰巧，每个类型都是复合值，因此都具有 \texttt{DataType} 类型：




\begin{minted}{jlcon}
julia> typeof(DataType)
DataType

julia> typeof(Union)
DataType
\end{minted}



\texttt{DataType} 是它自己的类型。



另一个适用于某些类型的操作是 \hyperlink{12192788431675298651}{\texttt{supertype}}，它显示了类型的超类型。只有已声明的类型（\texttt{DataType}）才有明确的超类型：




\begin{minted}{jlcon}
julia> supertype(Float64)
AbstractFloat

julia> supertype(Number)
Any

julia> supertype(AbstractString)
Any

julia> supertype(Any)
Any
\end{minted}



如果将 \hyperlink{12192788431675298651}{\texttt{supertype}} 应用于其它类型对象（或非类型对象），则会引发 \hyperlink{68769522931907606}{\texttt{MethodError}}：




\begin{minted}{jlcon}
julia> supertype(Union{Float64,Int64})
ERROR: MethodError: no method matching supertype(::Type{Union{Float64, Int64}})
Closest candidates are:
[...]
\end{minted}



\hypertarget{10200728548672135026}{}


\section{自定义 pretty-printing}



通常，人们会想要自定义显示类型实例的方式。这可通过重载 \hyperlink{4561869563484222675}{\texttt{show}} 函数来完成。举个例子，假设我们定义一个类型来表示极坐标形式的复数：




\begin{minted}{jlcon}
julia> struct Polar{T<:Real} <: Number
           r::T
           Θ::T
       end

julia> Polar(r::Real,Θ::Real) = Polar(promote(r,Θ)...)
Polar
\end{minted}



在这里，我们添加了一个自定义的构造函数，这样就可以接受不同 \hyperlink{6175959395021454412}{\texttt{Real}} 类型的参数并将它们类型提升为共同类型（请参阅\hyperlink{1489967485005487723}{构造函数}和\hyperlink{10374023657104680331}{类型转换和类型提升}）。（当然，为了让它表现地像个 \hyperlink{1990584313715697055}{\texttt{Number}}，我们需要定义许多其它方法，例如 \texttt{+}、\texttt{*}、\texttt{one}、\texttt{zero} 及类型提升规则等。）默认情况下，此类型的实例只是相当简单地显示有关类型名称和字段值的信息，比如，\texttt{Polar\{Float64\}(3.0,4.0)}。



如果我们希望它显示为 \texttt{3.0 * exp(4.0im)}，我们可定义以下方法来将对象打印到给定的输出对象 \texttt{io}（其代表文件、终端、及缓冲区等；请参阅\hyperlink{4176621353987521289}{网络和流}）：




\begin{minted}{jlcon}
julia> Base.show(io::IO, z::Polar) = print(io, z.r, " * exp(", z.Θ, "im)")
\end{minted}



\texttt{Polar} 对象的输出可以被更精细地控制。特别是，人们有时想要啰嗦的多行打印格式，用于在 REPL 和其它交互式环境中显示单个对象，以及一个更紧凑的单行格式，用于 \hyperlink{8248717042415202230}{\texttt{print}} 函数或在作为其它对象（比如一个数组）的部分是显示该对象。虽然在两种情况下默认都会调用 \texttt{show(io, z)} 函数，你仍可以定义一个\emph{不同}的多行格式来显示单个对象，这通过重载三参数形式的 \texttt{show} 函数，该函数接收 \texttt{text/plain} MIME 类型（请参阅 \hyperlink{9485638019478733873}{多媒体 I/O}）作为它的第二个参数，举个例子：




\begin{minted}{jlcon}
julia> Base.show(io::IO, ::MIME"text/plain", z::Polar{T}) where{T} =
           print(io, "Polar{$T} complex number:\n   ", z)
\end{minted}



（请注意 \texttt{print(..., z)} 在这里调用的是双参数的 \texttt{show(io, z)} 方法。）这导致：




\begin{minted}{jlcon}
julia> Polar(3, 4.0)
Polar{Float64} complex number:
   3.0 * exp(4.0im)

julia> [Polar(3, 4.0), Polar(4.0,5.3)]
2-element Vector{Polar{Float64}}:
 3.0 * exp(4.0im)
 4.0 * exp(5.3im)
\end{minted}



其中单行格式的 \texttt{show(io, z)} 仍用于由 \texttt{Polar} 值组成的数组。从技术上讲，REPL 调用 \texttt{display(z)} 来显示单行的执行结果，其默认为 \texttt{show(stdout, MIME({\textquotedbl}text/plain{\textquotedbl}), z)}，而后者又默认为 \texttt{show(stdout, z)}，但是你\emph{不应该}定义新的 \hyperlink{12073120410747960438}{\texttt{display}} 方法，除非你正在定义新的多媒体显示管理器（请参阅\hyperlink{9485638019478733873}{多媒体 I/O}）。



此外，你还可以为其它 MIME 类型定义 \texttt{show} 方法，以便在支持的环境（比如 IJulia）中实现更丰富的对象显示（HTML、图像等）。例如，我们可以定义 \texttt{Polar} 对象的 HTML 显示格式，使其带有上标和斜体：




\begin{minted}{jlcon}
julia> Base.show(io::IO, ::MIME"text/html", z::Polar{T}) where {T} =
           println(io, "<code>Polar{$T}</code> complex number: ",
                   z.r, " <i>e</i><sup>", z.Θ, " <i>i</i></sup>")
\end{minted}



之后会在支持 HTML 显示的环境中自动使用 HTML 显示 \texttt{Polar} 对象，但你也可以手动调用 \texttt{show} 来获取 HTML 输出：




\begin{minted}{jlcon}
julia> show(stdout, "text/html", Polar(3.0,4.0))
<code>Polar{Float64}</code> complex number: 3.0 <i>e</i><sup>4.0 <i>i</i></sup>
\end{minted}





根据经验，单行 \texttt{show} 方法应为创建的显示对象打印有效的 Julia 表达式。当这个 \texttt{show} 方法包含中缀运算符时，比如上面的 \texttt{Polar} 的单行 \texttt{show} 方法里的乘法运算符（\texttt{*}），在作为另一个对象的部分打印时，它可能无法被正确解析。要查看此问题，请考虑下面的表达式对象（请参阅\hyperlink{10559372927865899180}{程序表示}），它代表 \texttt{Polar} 类型的特定实例的平方：




\begin{minted}{jlcon}
julia> a = Polar(3, 4.0)
Polar{Float64} complex number:
   3.0 * exp(4.0im)

julia> print(:($a^2))
3.0 * exp(4.0im) ^ 2
\end{minted}



因为运算符 \texttt{{\textasciicircum}} 的优先级高于 \texttt{*}（请参阅\hyperlink{1006859879084707050}{运算符的优先级与结合性}），所以此输出错误地表示了表达式 \texttt{a {\textasciicircum} 2}，而该表达式等价于 \texttt{(3.0 * exp(4.0im)) {\textasciicircum} 2}。为了解决这个问题，我们必须为 \texttt{Base.show\_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)} 创建一个自定义方法，在打印时，表达式对象会在内部调用它：




\begin{minted}{jlcon}
julia> function Base.show_unquoted(io::IO, z::Polar, ::Int, precedence::Int)
           if Base.operator_precedence(:*) <= precedence
               print(io, "(")
               show(io, z)
               print(io, ")")
           else
               show(io, z)
           end
       end

julia> :($a^2)
:((3.0 * exp(4.0im)) ^ 2)
\end{minted}



当正在调用的运算符的优先级大于等于乘法的优先级时，上面定义的方法会在 \texttt{show} 调用的两侧加上括号。这个检查允许，在没有括号时也可被正确解析的表达式（例如 \texttt{:(\$a + 2)} 和 \texttt{:(\$a == 2)}），在打印时省略括号：




\begin{minted}{jlcon}
julia> :($a + 2)
:(3.0 * exp(4.0im) + 2)

julia> :($a == 2)
:(3.0 * exp(4.0im) == 2)
\end{minted}



在某些情况下，根据上下文调整 \texttt{show} 方法的行为是很有用的。这可通过 \hyperlink{13454403377667762339}{\texttt{IOContext}} 类型实现，它允许同时传递上下文属性和封装后的 IO 流。例如，我们可以在 \texttt{:compact} 属性设置为 \texttt{true} 时创建一个更短的表示，而在该属性为 \texttt{false} 或不存在时返回长的表示：




\begin{minted}{jlcon}
julia> function Base.show(io::IO, z::Polar)
           if get(io, :compact, false)
               print(io, z.r, "ℯ", z.Θ, "im")
           else
               print(io, z.r, " * exp(", z.Θ, "im)")
           end
       end
\end{minted}



当传入的 IO 流是设置了 \texttt{:compact}（译注：该属性还应当设置为 \texttt{true}）属性的 \texttt{IOContext} 对象时，新的紧凑表示将被使用。特别地，当打印具有多列的数组（由于水平空间有限）时就是这种情况：




\begin{minted}{jlcon}
julia> show(IOContext(stdout, :compact=>true), Polar(3, 4.0))
3.0ℯ4.0im

julia> [Polar(3, 4.0) Polar(4.0,5.3)]
1×2 Matrix{Polar{Float64}}:
 3.0ℯ4.0im  4.0ℯ5.3im
\end{minted}



有关调整打印效果的常用属性列表，请参阅文档 \hyperlink{13454403377667762339}{\texttt{IOContext}}。



\hypertarget{764608991862279222}{}


\section{值类型}



在 Julia 中，你无法根据诸如 \texttt{true} 或 \texttt{false} 之类的\emph{值}进行分派。然而，你可以根据参数类型进行分派，Julia 允许你包含「plain bits」值（类型、符号、整数、浮点数和元组等）作为类型参数。\texttt{Array\{T,N\}} 里的维度参数就是一个常见的例子，在这里 \texttt{T} 是类型（比如 \hyperlink{5027751419500983000}{\texttt{Float64}}），而 \texttt{N} 只是个 \texttt{Int}。



你可以创建把值作为参数的自定义类型，并使用它们控制自定义类型的分派。为了说明这个想法，让我们引入参数类型 \texttt{Val\{x\}} 和构造函数 \texttt{Val(x) = Val\{x\}()}，在不需要更精细的层次结构时，这是利用此技巧的一种习惯的方式。



\hyperlink{1312938105781775871}{\texttt{Val}} 的定义为：




\begin{minted}{jlcon}
julia> struct Val{x}
       end

julia> Val(x) = Val{x}()
Val
\end{minted}



\texttt{Val} 的实现就只需要这些。一些 Julia 标准库里的函数接收 \texttt{Val} 的实例作为参数，你也可以使用它来编写你自己的函数，例如：




\begin{minted}{jlcon}
julia> firstlast(::Val{true}) = "First"
firstlast (generic function with 1 method)

julia> firstlast(::Val{false}) = "Last"
firstlast (generic function with 2 methods)

julia> firstlast(Val(true))
"First"

julia> firstlast(Val(false))
"Last"
\end{minted}



为了保证 Julia 的一致性，调用处应当始终传递 \texttt{Val} \textbf{实例} 而不是 \textbf{类型}，也就是使用 \texttt{foo(Val(:bar))} 而不是 \texttt{foo(Val\{:bar\})}。



值得注意的是，参数「值」类型非常容易被误用，包括 \texttt{Val}；在不适用的情形下，你很容易使代码性能变得更\emph{糟糕}。特别是，你可能永远都不会想要写出如上所示的代码。有关 \texttt{Val} 的正确（和不正确）使用的更多信息，请阅读\hyperlink{17259605703392147735}{性能建议}中更广泛的讨论。



\footnotetext[1]{「少数」由常数 \texttt{MAX\_UNION\_SPLITTING} 定义，目前设置为 4。

}


\footnotetext[2]{一些流行的编程语言具有单例类型，包括 Haskell、Scala 和 Ruby。

}


\hypertarget{12379207465798704957}{}


\chapter{方法}



我们回想一下，在\hyperlink{645008301484218813}{函数}中我们知道函数是这么一个对象，它把一组参数映射成一个返回值，或者当没有办法返回恰当的值时扔出一个异常。具有相同概念的函数或者运算，经常会根据参数类型的不同而进行有很大差异的实现：两个整数的加法与两个浮点数的加法是相当不一样的，整数与浮点数之间的加法也不一样。除了它们实现上的不同，这些运算都归在{\textquotedbl}加法{\textquotedbl}这么一个广义的概念之下，因此在 Julia 中这些行为都属于同一个对象：\texttt{+} 函数。



为了让对同样的概念使用许多不同的实现这件事更顺畅，函数没有必要马上全部都被定义，反而应该是一块一块地定义，为特定的参数类型和数量的组合提供指定的行为。对于一个函数的一个可能行为的定义叫做\emph{方法}。直到这里，我们只展示了那些只定了一个方法的，对参数的所有类型都适用的函数。但是方法定义的特征是不仅能表明参数的数量，也能表明参数的类型，并且能提供多个方法定义。当一个函数被应用于特殊的一组参数时，能用于这一组参数的最特定的方法会被使用。所以，函数的全体行为是他的不同的方法定义的行为的组合。如果这个组合被设计得好，即使方法们的实现之间会很不一样，函数的外部行为也会显得无缝而自洽。



当一个函数被应用时执行方法的选择被称为 \textbf{分派}。Julia 允许分派过程基于给定的参数个数和所有参数的类型来选择调用函数的哪个方法。这与传统的面对对象的语言不一样，面对对象语言的分派只基于第一参数，经常有特殊的参数语法，并且有时是暗含而非显式写成一个参数。 \footnotemark[1] 使用函数的所有参数，而非只用第一个，来决定调用哪个方法被称为\href{https://en.wikipedia.org/wiki/Multiple\_dispatch}{多重分派}。多重分派对于数学代码来说特别有用，人工地将运算视为对于其中一个参数的属于程度比其他所有的参数都强的这个概念对于数学代码是几乎没有意义的：\texttt{x + y} 中的加法运算对 \texttt{x} 的属于程度比对 \texttt{y} 更强？一个数学运算符的实现普遍基于它所有的参数的类型。即使跳出数学运算，多重分派是对于结构和组织程序来说也是一个强大而方便的范式。



\footnotetext[1]{In C++ or Java, for example, in a method call like \texttt{obj.meth(arg1,arg2)}, the object obj {\textquotedbl}receives{\textquotedbl} the method call and is implicitly passed to the method via the \texttt{this} keyword, rather than as an explicit method argument. When the current \texttt{this} object is the receiver of a method call, it can be omitted altogether, writing just \texttt{meth(arg1,arg2)}, with \texttt{this} implied as the receiving object.

}


\begin{quote}
\textbf{Note}

本章中的所有示例都假定是为\emph{相同}模块中的函数定义模块。 如果你想给\emph{另一个}模块中的函数添加方法，你必须\texttt{import}它或使用模块名称限定的名称。 请参阅有关 \hyperlink{15504003297523876122}{命名空间管理} 的部分。

\end{quote}


\hypertarget{17361934126771506898}{}


\section{定义方法}



直到这里，在我们的例子中，我们定义的函数只有一个不限制参数类型的方法。这种函数的行为就与传统动态类型语言中的函数一样。不过，我们已经在没有意识到的情况下已经使用了多重分派和方法：所有 Julia 标准函数和运算符，就像之前提到的 \texttt{+} 函数，都根据参数的类型和数量的不同组合而定义了大量方法。



当定义一个函数时，可以根据需要使用在\hyperlink{4168730090950432836}{复合类型}中介绍的 \texttt{::} 类型断言运算符来限制参数类型，




\begin{minted}{jlcon}
julia> f(x::Float64, y::Float64) = 2x + y
f (generic function with 1 method)
\end{minted}



这个函数只在 \texttt{x} 和 \texttt{y} 的类型都是 \hyperlink{5027751419500983000}{\texttt{Float64}} 的情况下才会被调用：




\begin{minted}{jlcon}
julia> f(2.0, 3.0)
7.0
\end{minted}



用其它任意的参数类型则会导致 \hyperlink{68769522931907606}{\texttt{MethodError}}:




\begin{minted}{jlcon}
julia> f(2.0, 3)
ERROR: MethodError: no method matching f(::Float64, ::Int64)
Closest candidates are:
  f(::Float64, !Matched::Float64) at none:1

julia> f(Float32(2.0), 3.0)
ERROR: MethodError: no method matching f(::Float32, ::Float64)
Closest candidates are:
  f(!Matched::Float64, ::Float64) at none:1

julia> f(2.0, "3.0")
ERROR: MethodError: no method matching f(::Float64, ::String)
Closest candidates are:
  f(::Float64, !Matched::Float64) at none:1

julia> f("2.0", "3.0")
ERROR: MethodError: no method matching f(::String, ::String)
\end{minted}



如同你所看到的，参数必须精确地是 \hyperlink{5027751419500983000}{\texttt{Float64}} 类型。其它数字类型，比如整数或者 32 位浮点数值，都不会自动转化成 64 位浮点数，字符串也不会解析成数字。由于 \texttt{Float64} 是一个具体类型，且在 Julia 中具体类型无法拥有子类，所以这种定义方式只能适用于函数的输入类型精确地是 \texttt{Float64} 的情况，但一个常见的做法是用抽象类型来定义通用的方法：




\begin{minted}{jlcon}
julia> f(x::Number, y::Number) = 2x - y
f (generic function with 2 methods)

julia> f(2.0, 3)
1.0
\end{minted}



用上面这种方式定义的方法可以接收任意一对 \hyperlink{1990584313715697055}{\texttt{Number}} 的实例参数，且它们不需要是同一类型的，只要求都是数值。如何根据不同的类型来做相应的处理就可以委托给表达式 \texttt{2x - y} 中的代数运算。



为了定义一个有多个方法的函数，只需简单定义这个函数多次，使用不同的参数数量和类型。函数的第一个方法定义会建立这个函数对象，后续的方法定义会添加新的方法到存在的函数对象中去。当函数被应用时，最符合参数的数量和类型的特定方法会被执行。所以，上面的两个方法定义在一起定义了函数\texttt{f}对于所有的一对虚拟类型\texttt{Number}实例的行为 – 但是针对一对\hyperlink{5027751419500983000}{\texttt{Float64}}值有不同的行为。如果一个参数是64位浮点数而另一个不是，\texttt{f(Float64,Float64)}方法不会被调用，而一定使用更加通用的\texttt{f(Number,Number)}方法：




\begin{minted}{jlcon}
julia> f(2.0, 3.0)
7.0

julia> f(2, 3.0)
1.0

julia> f(2.0, 3)
1.0

julia> f(2, 3)
1
\end{minted}



\texttt{2x + y} 定义只用于第一个情况，\texttt{2x - y} 定义用于其他的情况。没有使用任何自动的函数参数的指派或者类型转换：Julia中的所有转换都不是 magic 的，都是完全显式的。然而\hyperlink{10374023657104680331}{类型转换和类型提升}显示了足够先进的技术的智能应用能够与 magic 不可分辨到什么程度。\footnotemark[2] 对于非数字值，和比两个参数更多或者更少的情况，函数 \texttt{f} 并没有定义，应用会导致 \hyperlink{68769522931907606}{\texttt{MethodError}}：




\begin{minted}{jlcon}
julia> f("foo", 3)
ERROR: MethodError: no method matching f(::String, ::Int64)
Closest candidates are:
  f(!Matched::Number, ::Number) at none:1

julia> f()
ERROR: MethodError: no method matching f()
Closest candidates are:
  f(!Matched::Float64, !Matched::Float64) at none:1
  f(!Matched::Number, !Matched::Number) at none:1
\end{minted}



可以简单地看到对于函数存在哪些方法，通过在交互式会话中键入函数对象本身：




\begin{minted}{jlcon}
julia> f
f (generic function with 2 methods)
\end{minted}



这个输出展示了\texttt{f}有两个方法。为了找到这些方法的前面，使用\hyperlink{3025953302266245919}{\texttt{methods}}函数：




\begin{minted}{jlcon}
julia> methods(f)
# 2 methods for generic function "f":
[1] f(x::Float64, y::Float64) in Main at none:1
[2] f(x::Number, y::Number) in Main at none:1
\end{minted}



这表示\texttt{f}有两个方法，一个接受两个\texttt{Float64}参数一个接受两个\texttt{Number}类型的参数。它也显示了这些方法定义所在的文件和行数：因为这些方法是在REPL中定义的，我们得到了表面上的行数\texttt{none:1}.



没有\texttt{::}的类型声明，方法参数的类型默认为\texttt{Any}，这就意味着没有约束，因为Julia中的所有的值都是抽象类型\texttt{Any}的实例。所以，我们可以为\texttt{f}定义一个接受所有的方法，像这样：




\begin{minted}{jlcon}
julia> f(x,y) = println("Whoa there, Nelly.")
f (generic function with 3 methods)

julia> methods(f)
# 3 methods for generic function "f":
[1] f(x::Float64, y::Float64) in Main at none:1
[2] f(x::Number, y::Number) in Main at none:1
[3] f(x, y) in Main at none:1

julia> f("foo", 1)
Whoa there, Nelly.
\end{minted}



这个接受所有参数类型的方法比其他的对一对参数值的其他任意可能的方法定义更不专用。所以他只会被没有其他方法定义应用的一对参数调用。



注意到第三个方法的签名中并没有指定参数\texttt{x}和\texttt{y}的类型。它是\texttt{f(x::Any, y::Any)}的简写。



尽管这看起来很简单，但对值类型的多重派发可能是 Julia 语言最强大和最核心的特性。 核心运算通常有几十种方法：




\begin{minted}{jlcon}
julia> methods(+)
# 180 methods for generic function "+":
[1] +(x::Bool, z::Complex{Bool}) in Base at complex.jl:227
[2] +(x::Bool, y::Bool) in Base at bool.jl:89
[3] +(x::Bool) in Base at bool.jl:86
[4] +(x::Bool, y::T) where T<:AbstractFloat in Base at bool.jl:96
[5] +(x::Bool, z::Complex) in Base at complex.jl:234
[6] +(a::Float16, b::Float16) in Base at float.jl:373
[7] +(x::Float32, y::Float32) in Base at float.jl:375
[8] +(x::Float64, y::Float64) in Base at float.jl:376
[9] +(z::Complex{Bool}, x::Bool) in Base at complex.jl:228
[10] +(z::Complex{Bool}, x::Real) in Base at complex.jl:242
[11] +(x::Char, y::Integer) in Base at char.jl:40
[12] +(c::BigInt, x::BigFloat) in Base.MPFR at mpfr.jl:307
[13] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt, e::BigInt) in Base.GMP at gmp.jl:392
[14] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt) in Base.GMP at gmp.jl:391
[15] +(a::BigInt, b::BigInt, c::BigInt) in Base.GMP at gmp.jl:390
[16] +(x::BigInt, y::BigInt) in Base.GMP at gmp.jl:361
[17] +(x::BigInt, c::Union{UInt16, UInt32, UInt64, UInt8}) in Base.GMP at gmp.jl:398
...
[180] +(a, b, c, xs...) in Base at operators.jl:424
\end{minted}



多重分派和灵活的参数类型系统让Julia有能力抽象地表达高层级算法，而与实现细节解耦，也能生成高效而专用的代码来在运行中处理每个情况。



\hypertarget{8405464025999625028}{}


\section{方法歧义}



在一系列的函数方法定义时有可能没有单独的最专用的方法能适用于参数的某些组合：




\begin{minted}{jlcon}
julia> g(x::Float64, y) = 2x + y
g (generic function with 1 method)

julia> g(x, y::Float64) = x + 2y
g (generic function with 2 methods)

julia> g(2.0, 3)
7.0

julia> g(2, 3.0)
8.0

julia> g(2.0, 3.0)
ERROR: MethodError: g(::Float64, ::Float64) is ambiguous. Candidates:
  g(x::Float64, y) in Main at none:1
  g(x, y::Float64) in Main at none:1
Possible fix, define
  g(::Float64, ::Float64)
\end{minted}



这里\texttt{g(2.0,3.0)}的调用使用\texttt{g(Float64, Any)}和\texttt{g(Any, Float64)}都能处理，并且两个都不更加专用。在这样的情况下，Julia会扔出\hyperlink{68769522931907606}{\texttt{MethodError}}而非任意选择一个方法。你可以通过对交叉情况指定一个合适的方法来避免方法歧义：




\begin{minted}{jlcon}
julia> g(x::Float64, y::Float64) = 2x + 2y
g (generic function with 3 methods)

julia> g(2.0, 3)
7.0

julia> g(2, 3.0)
8.0

julia> g(2.0, 3.0)
10.0
\end{minted}



建议先定义没有歧义的方法，因为不这样的话，歧义就会存在，即使是暂时性的，直到更加专用的方法被定义。



在更加复杂的情况下，解决方法歧义会会涉及到设计的某一个元素；这个主题将会在\hyperlink{15846346227037149553}{下面}进行进一步的探索。



\hypertarget{14064657876301533350}{}


\section{参数方法}



方法定义可以视需要存在限定特征的类型参数：




\begin{minted}{jlcon}
julia> same_type(x::T, y::T) where {T} = true
same_type (generic function with 1 method)

julia> same_type(x,y) = false
same_type (generic function with 2 methods)
\end{minted}



第一个方法应用于两个参数都是同一个具体类型时，不管类型是什么，而第二个方法接受一切，涉及其他所有情况。所以，总得来说，这个定义了一个布尔函数来检查两个参数是否是同样的类型：




\begin{minted}{jlcon}
julia> same_type(1, 2)
true

julia> same_type(1, 2.0)
false

julia> same_type(1.0, 2.0)
true

julia> same_type("foo", 2.0)
false

julia> same_type("foo", "bar")
true

julia> same_type(Int32(1), Int64(2))
false
\end{minted}



这样的定义对应着那些类型签名是 \texttt{UnionAll} 类型的方法（参见 \hyperlink{11072845175692859046}{UnionAll 类型}）。



在Julia中这种通过分派进行函数行为的定义是十分常见的，甚至是惯用的。方法类型参数并不局限于用作参数的类型：他们可以用在任意地方，只要值会在函数或者函数体的特征中。这里有个例子，例子中方法类型参数\texttt{T}用作方法特征中的参数类型\texttt{Vector\{T\}}的类型参数：




\begin{minted}{jlcon}
julia> myappend(v::Vector{T}, x::T) where {T} = [v..., x]
myappend (generic function with 1 method)

julia> myappend([1,2,3],4)
4-element Vector{Int64}:
 1
 2
 3
 4

julia> myappend([1,2,3],2.5)
ERROR: MethodError: no method matching myappend(::Vector{Int64}, ::Float64)
Closest candidates are:
  myappend(::Vector{T}, !Matched::T) where T at none:1
Stacktrace:
[...]

julia> myappend([1.0,2.0,3.0],4.0)
4-element Vector{Float64}:
 1.0
 2.0
 3.0
 4.0

julia> myappend([1.0,2.0,3.0],4)
ERROR: MethodError: no method matching myappend(::Vector{Float64}, ::Int64)
Closest candidates are:
  myappend(::Vector{T}, !Matched::T) where T at none:1
Stacktrace:
[...]
\end{minted}



如你所看到的，追加的元素的类型必须匹配它追加到的向量的元素类型，否则会引起\hyperlink{68769522931907606}{\texttt{MethodError}}。在下面的例子中，方法类型参量\texttt{T}用作返回值：




\begin{minted}{jlcon}
julia> mytypeof(x::T) where {T} = T
mytypeof (generic function with 1 method)

julia> mytypeof(1)
Int64

julia> mytypeof(1.0)
Float64
\end{minted}



就像你能在类型声明时通过类型参数对子类型进行约束一样（参见\href{@ref}{参数类型}），你也可以约束方法的类型参数：




\begin{minted}{jlcon}
julia> same_type_numeric(x::T, y::T) where {T<:Number} = true
same_type_numeric (generic function with 1 method)

julia> same_type_numeric(x::Number, y::Number) = false
same_type_numeric (generic function with 2 methods)

julia> same_type_numeric(1, 2)
true

julia> same_type_numeric(1, 2.0)
false

julia> same_type_numeric(1.0, 2.0)
true

julia> same_type_numeric("foo", 2.0)
ERROR: MethodError: no method matching same_type_numeric(::String, ::Float64)
Closest candidates are:
  same_type_numeric(!Matched::T, ::T) where T<:Number at none:1
  same_type_numeric(!Matched::Number, ::Number) at none:1

julia> same_type_numeric("foo", "bar")
ERROR: MethodError: no method matching same_type_numeric(::String, ::String)

julia> same_type_numeric(Int32(1), Int64(2))
false
\end{minted}



\texttt{same\_type\_numeric}函数的行为与上面定义的\texttt{same\_type}函数基本相似，但是它只对一对数定义。



参数方法允许与 \texttt{where} 表达式同样的语法用来写类型（参见 \hyperlink{11072845175692859046}{UnionAll 类型}）。如果只有一个参数，封闭的大括号（在 \texttt{where \{T\}} 中）可以省略，但是为了清楚起见推荐写上。多个参数可以使用逗号隔开，例如 \texttt{where \{T, S <: Real\}}，或者使用嵌套的 \texttt{where} 来写，例如 \texttt{where S<:Real where T}。



\hypertarget{18141577506112006209}{}


\section{重定义方法}



当重定义一个方法或者增加一个方法时，知道这个变化不会立即生效很重要。这是Julia能够静态推断和编译代码使其运行很快而没有惯常的JIT技巧和额外开销的关键。实际上，任意新的方法定义不会对当前运行环境可见，包括Tasks和线程（和所有的之前定义的\texttt{@generated}函数）。让我们通过一个例子说明这意味着什么：




\begin{minted}{jlcon}
julia> function tryeval()
           @eval newfun() = 1
           newfun()
       end
tryeval (generic function with 1 method)

julia> tryeval()
ERROR: MethodError: no method matching newfun()
The applicable method may be too new: running in world age xxxx1, while current world is xxxx2.
Closest candidates are:
  newfun() at none:1 (method too new to be called from this world context.)
 in tryeval() at none:1
 ...

julia> newfun()
1
\end{minted}



在这个例子中看到\texttt{newfun}的新定义已经被创建，但是并不能立即调用。新的全局变量立即对\texttt{tryeval}函数可见，所以你可以写\texttt{return newfun}（没有小括号）。但是你，你的调用器，和他们调用的函数等等都不能调用这个新的方法定义！



但是这里有个例外：之后的\emph{在 REPL 中}的 \texttt{newfun} 的调用会按照预期工作，能够见到并调用\texttt{newfun} 的新定义。



但是，之后的 \texttt{tryeval} 的调用将会继续看到 \texttt{newfun} 的定义，因为该定义\emph{位于 REPL 的前一个语句中}并因此在之后的 \texttt{tryeval} 的调用之前。



你可以试试这个来让自己了解这是如何工作的。



这个行为的实现通过一个「world age 计数器」。这个单调递增的值会跟踪每个方法定义操作。此计数器允许用单个数字描述「对于给定运行时环境可见的方法定义集」，或者说「world age」。它还允许仅仅通过其序数值来比较在两个 world 中可用的方法。在上例中，我们看到（方法 \texttt{newfun} 所存在的）「current world」比局部于任务的「runtime world」大一，后者在 \texttt{tryeval} 开始执行时是固定的。



有时规避这个是必要的（例如，如果你在实现上面的REPL）。幸运的是这里有个简单地解决方法：使用\hyperlink{15240876280767285272}{\texttt{Base.invokelatest}}调用函数：




\begin{minted}{jlcon}
julia> function tryeval2()
           @eval newfun2() = 2
           Base.invokelatest(newfun2)
       end
tryeval2 (generic function with 1 method)

julia> tryeval2()
2
\end{minted}



最后，让我们看一些这个规则生效的更复杂的例子。 定义一个函数\texttt{f(x)}，最开始有一个方法：




\begin{minted}{jlcon}
julia> f(x) = "original definition"
f (generic function with 1 method)
\end{minted}



开始一些使用\texttt{f(x)}的运算：




\begin{minted}{jlcon}
julia> g(x) = f(x)
g (generic function with 1 method)

julia> t = @async f(wait()); yield();
\end{minted}



现在我们给\texttt{f(x)}加上一些新的方法：




\begin{minted}{jlcon}
julia> f(x::Int) = "definition for Int"
f (generic function with 2 methods)

julia> f(x::Type{Int}) = "definition for Type{Int}"
f (generic function with 3 methods)
\end{minted}



比较一下这些结果如何不同：




\begin{minted}{jlcon}
julia> f(1)
"definition for Int"

julia> g(1)
"definition for Int"

julia> fetch(schedule(t, 1))
"original definition"

julia> t = @async f(wait()); yield();

julia> fetch(schedule(t, 1))
"definition for Int"
\end{minted}



\hypertarget{1696520674414442593}{}


\section{使用参数方法设计样式}



虽然复杂的分派逻辑对于性能或者可用性并不是必须的，但是有时这是表达某些算法的最好的方法。 这里有一些常见的设计样式，在以这个方法使用分派时有时会出现。



\hypertarget{13813570673284607064}{}


\subsection{从超类型中提取出类型参数}



以下是一个正确的代码模板，用于返回具有明确定义的元素类型的 \texttt{AbstractArray} 的任意子类型的元素类型 \texttt{T}：




\begin{minted}{julia}
abstract type AbstractArray{T, N} end
eltype(::Type{<:AbstractArray{T}}) where {T} = T
\end{minted}



使用所谓的三角派发。 请注意，\texttt{UnionAll} 类型，对于示例\texttt{eltype(AbstractArray\{T\} where T <: Integer)}，与上述方法不符。 在这种情况下，\texttt{Base} 中 \texttt{eltype} 的实现为 \texttt{Any} 增加了一个回退方法。



一个常见的错误是试着使用内省来得到元素类型：




\begin{minted}{julia}
eltype_wrong(::Type{A}) where {A<:AbstractArray} = A.parameters[1]
\end{minted}



但是创建一个这个方法会失败的情况不难：




\begin{minted}{julia}
struct BitVector <: AbstractArray{Bool, 1}; end
\end{minted}



这里我们已经创建了一个没有参数的类型\texttt{BitVector}，但是元素类型已经完全指定了，\texttt{T}等于\texttt{Bool}！



另一个错误是尝试使用 \texttt{supertype} 沿着类型层次结构向上走：




\begin{minted}{julia}
eltype_wrong(::Type{AbstractArray{T}}) where {T} = T
eltype_wrong(::Type{AbstractArray{T, N}}) where {T, N} = T
eltype_wrong(::Type{A}) where {A<:AbstractArray} = eltype_wrong(supertype(A))
\end{minted}



虽然这适用于声明的类型，但对于不适用于没有超类型的类型：




\begin{minted}{jlcon}
julia> eltype_wrong(Union{AbstractArray{Int}, AbstractArray{Float64}})
ERROR: MethodError: no method matching supertype(::Type{Union{AbstractArray{Float64,N} where N, AbstractArray{Int64,N} where N}})
Closest candidates are:
  supertype(::DataType) at operators.jl:43
  supertype(::UnionAll) at operators.jl:48
\end{minted}



\hypertarget{7211262558234007578}{}


\subsection{用不同的类型参数构建相似的类型}



当构建通用代码时，通常需要创建一些类似对象，在类型的布局上有一些变化，这就也让类型参数的变化变得必要。 例如，你会有一些任意元素类型的抽象数组，想使用特定的元素类型来编写你基于它的计算。你必须实现为每个\texttt{AbstractArray\{T\}}的子类型实现方法，这些方法描述了如何计算类型转换。从一个子类型转化成拥有一个不同参数的另一个子类型的通用方法在这里不存在。（快速复习：你明白为什么吗？）



\texttt{AbstractArray}的子类型典型情况下会实现两个方法来完成这个： 一个方法把输入输入转换成特定的\texttt{AbstractArray\{T,N\}}抽象类型的子类型；一个方法用特定的元素类型构建一个新的未初始化的数组。这些的样例实现可以在Julia Base里面找到。这里是一个基础的样例使用，保证\texttt{输入}与\texttt{输出}是同一种类型：




\begin{minted}{julia}
input = convert(AbstractArray{Eltype}, input)
output = similar(input, Eltype)
\end{minted}



作为这个的扩展，在算法需要输入数组的拷贝的情况下，\hyperlink{1846942650946171605}{\texttt{convert}}使无法胜任的，因为返回值可能只是原始输入的别名。把\hyperlink{15525808546723795098}{\texttt{similar}}（构建输出数组）和\hyperlink{12476124489163612623}{\texttt{copyto!}}（用输入数据填满）结合起来是需要给出输入参数的可变拷贝的一个范用方法：




\begin{minted}{julia}
copy_with_eltype(input, Eltype) = copyto!(similar(input, Eltype), input)
\end{minted}



\hypertarget{6940352566710127049}{}


\subsection{迭代分派}



为了分派一个多层的参数参量列表，将每一层分派分开到不同的函数中常常是最好的。这可能听起来跟单分派的方法相似，但是你会在下面见到，这个更加灵活。



例如，尝试按照数组的元素类型进行分派常常会引起歧义。相反地，常见的代码会首先按照容易类型分派，然后基于eltype递归到更加更加专用的方法。在大部分情况下，算法会很方便地就屈从与这个分层方法，在其他情况下，这种严苛的工作必须手动解决。这个分派分支能被观察到，例如在两个矩阵的加法的逻辑中：




\begin{minted}{julia}
# 首先分派选择了逐元素相加的map算法。
+(a::Matrix, b::Matrix) = map(+, a, b)
# 然后分派处理了每个元素然后选择了计算的
# 恰当的常见元素类型。
+(a, b) = +(promote(a, b)...)
# 一旦元素有了相同类型，它们就可以相加。
# 例如，通过处理器暴露出的原始运算。
+(a::Float64, b::Float64) = Core.add(a, b)
\end{minted}



\hypertarget{5085783943422577248}{}


\subsection{基于 Trait 的分派}



对于上面的可迭代分派的一个自然扩展是给方法选择加一个内涵层，这个层允许按照那些与类型层级定义的集合相独立的类型的集合来分派。我们可以通过写出问题中的类型的一个\texttt{Union}来创建这个一个集合，但是这不能够扩展，因为\texttt{Union}类型在创建之后无法改变。但是这么一个可扩展的集合可以通过一个叫做\href{https://github.com/JuliaLang/julia/issues/2345\#issuecomment-54537633}{{\textquotedbl}Holy-trait{\textquotedbl}}的一个设计样式来实现。



这个样式是通过定义一个范用函数来实现，这个函数为函数参数可能属于的每个trait集合都计算出不同的单例值（或者类型）。如果这个函数是单纯的，这与通常的分派对于性能没有任何影响。



上一部分中的示例掩盖了 \hyperlink{11483231213869150535}{\texttt{map}} 和 \hyperlink{1760874576431605095}{\texttt{promote}} 的实现细节，这两个都是依据trait来进行运算的。 在迭代矩阵时，例如在 \texttt{map} 的实现中，一个重要的问题是使用什么顺序遍历数据。 当 \texttt{AbstractArray} 子类型实现 \hyperlink{7782790551324367092}{\texttt{Base.IndexStyle}} trait 时，\texttt{map} 等其他函数可以根据此信息进行派发以选择最佳算法（请参阅 [抽象数组接口](@ref man-interface-array））。这意味着每个子类型不需要实现\texttt{map}的自定义版本，因为通用定义+trait类将使系统能够选择最快的版本。 下面是 \texttt{map} 的一个简单实现，说明了基于 trait 的调度：




\begin{minted}{julia}
map(f, a::AbstractArray, b::AbstractArray) = map(Base.IndexStyle(a, b), f, a, b)
# generic implementation:
map(::Base.IndexCartesian, f, a::AbstractArray, b::AbstractArray) = ...
# linear-indexing implementation (faster)
map(::Base.IndexLinear, f, a::AbstractArray, b::AbstractArray) = ...
\end{minted}



这个基于trait的方法也出现在\hyperlink{1760874576431605095}{\texttt{promote}}机制中，被标量\texttt{+}使用。 它使用了\hyperlink{15048881762587391286}{\texttt{promote\_type}}，这在知道两个计算对象的类型的情况下返回计算这个运算的最佳的常用类型。这就使得我们不用为每一对可能的类型参数实现每一个函数，而把问题简化为对于每个类型实现一个类型转换运算这样一个小很多的问题，还有一个优选的逐对的类型提升规则的表格。



\hypertarget{8273619992944815153}{}


\subsection{输出类型计算}



基于trait的类型提升的讨论可以过渡到我们的下一个设计样式：为矩阵运算计算输出元素类型。



为了实现像加法这样的原始运算，我们使用\hyperlink{15048881762587391286}{\texttt{promote\_type}}函数来计算想要的输出类型。（像之前一样，我们在\texttt{+}调用中的\texttt{promote}调用中见到了这个工作）。



对于矩阵的更加复杂的函数，对于更加复杂的运算符序列来计算预期的返回类型是必要的。这经常按下列步骤进行：



\begin{itemize}
\item[1. ] 编写一个小函数\texttt{op}来表示算法核心中使用的运算的集合。


\item[2. ] 使用\texttt{promote\_op(op, argument\_types...)}计算结果矩阵的元素类型\texttt{R}， 这里\texttt{argument\_types}是通过应用到每个输入数组的\texttt{eltype}计算的。


\item[3. ] 创建类似于\texttt{similar(R, dims)}的输出矩阵，这里\texttt{dims}是输出矩阵的预期维度数。

\end{itemize}


作为一个更加具体的例子，一个范用的方阵乘法的伪代码是：




\begin{minted}{julia}
function matmul(a::AbstractMatrix, b::AbstractMatrix)
    op = (ai, bi) -> ai * bi + ai * bi

    ## this is insufficient because it assumes `one(eltype(a))` is constructable:
    # R = typeof(op(one(eltype(a)), one(eltype(b))))

    ## this fails because it assumes `a[1]` exists and is representative of all elements of the array
    # R = typeof(op(a[1], b[1]))

    ## this is incorrect because it assumes that `+` calls `promote_type`
    ## but this is not true for some types, such as Bool:
    # R = promote_type(ai, bi)

    # this is wrong, since depending on the return value
    # of type-inference is very brittle (as well as not being optimizable):
    # R = Base.return_types(op, (eltype(a), eltype(b)))

    ## but, finally, this works:
    R = promote_op(op, eltype(a), eltype(b))
    ## although sometimes it may give a larger type than desired
    ## it will always give a correct type

    output = similar(b, R, (size(a, 1), size(b, 2)))
    if size(a, 2) > 0
        for j in 1:size(b, 2)
            for i in 1:size(a, 1)
                ## here we don't use `ab = zero(R)`,
                ## since `R` might be `Any` and `zero(Any)` is not defined
                ## we also must declare `ab::R` to make the type of `ab` constant in the loop,
                ## since it is possible that typeof(a * b) != typeof(a * b + a * b) == R
                ab::R = a[i, 1] * b[1, j]
                for k in 2:size(a, 2)
                    ab += a[i, k] * b[k, j]
                end
                output[i, j] = ab
            end
        end
    end
    return output
end
\end{minted}



\hypertarget{1067448927897925814}{}


\subsection{分离转换和内核逻辑}



能有效减少编译时间和测试复杂度的一个方法是将预期的类型和计算转换的逻辑隔离。这会让编译器将与大型内核的其他部分相独立的类型转换逻辑特别化并内联。



将更大的类型类转换成被算法实际支持的特定参数类是一个常见的设计样式：




\begin{minted}{julia}
complexfunction(arg::Int) = ...
complexfunction(arg::Any) = complexfunction(convert(Int, arg))

matmul(a::T, b::T) = ...
matmul(a, b) = matmul(promote(a, b)...)
\end{minted}



\hypertarget{3661198273813942193}{}


\section{参数化约束的可变参数方法}



函数参数也可以用于约束应用于{\textquotedbl}可变参数{\textquotedbl}函数（\hyperlink{9965084594348935329}{变参函数}）的参数的数量。\texttt{Vararg\{T,N\}} 可用于表明这么一个约束。举个例子：




\begin{minted}{jlcon}
julia> bar(a,b,x::Vararg{Any,2}) = (a,b,x)
bar (generic function with 1 method)

julia> bar(1,2,3)
ERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64)
Closest candidates are:
  bar(::Any, ::Any, ::Any, !Matched::Any) at none:1

julia> bar(1,2,3,4)
(1, 2, (3, 4))

julia> bar(1,2,3,4,5)
ERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64, ::Int64, ::Int64)
Closest candidates are:
  bar(::Any, ::Any, ::Any, ::Any) at none:1
\end{minted}



更加有用的是，用一个参数就约束可变参数的方法是可能的。例如：




\begin{minted}{julia}
function getindex(A::AbstractArray{T,N}, indices::Vararg{Number,N}) where {T,N}
\end{minted}



只会在\texttt{indices}的个数与数组的维数相同时才会调用。



当只有提供的参数的类型需要被约束时，\texttt{Vararg\{T\}}可以写成\texttt{T...}。例如\texttt{f(x::Int...) = x}是\texttt{f(x::Vararg\{Int\}) = x}的简便写法。



\hypertarget{6114459498123607412}{}


\section{可选参数和关键字的参数的注意事项}



与在\hyperlink{645008301484218813}{函数}中简要提到的一样，可选参数是使用多方法定义语法来实现的。例如，这个定义：




\begin{minted}{julia}
f(a=1,b=2) = a+2b
\end{minted}



翻译成下列三个方法：




\begin{minted}{julia}
f(a,b) = a+2b
f(a) = f(a,2)
f() = f(1,2)
\end{minted}



这就意味着调用\texttt{f()}等于调用\texttt{f(1,2)}。在这个情况下结果是\texttt{5}，因为\texttt{f(1,2)}使用的是上面\texttt{f}的第一个方法。但是，不总是需要是这种情况。如果你定义了第四个对于整数更加专用的方法：




\begin{minted}{julia}
f(a::Int,b::Int) = a-2b
\end{minted}



此时\texttt{f()}和\texttt{f(1,2)}的结果都是\texttt{-3}。换句话说，可选参数只与函数捆绑，而不是函数的任意一个特定的方法。这个决定于使用的方法的可选参数的类型。当可选参数是用全局变量的形式定义时，可选参数的类型甚至会在运行时改变。



关键字参数与普通的位置参数的行为很不一样。特别地，他们不参与到方法分派中。方法只基于位置参数分派，在匹配得方法确定之后关键字参数才会被处理。



\hypertarget{12721694880938168924}{}


\section{类函数对象}



方法与类型相关，所以可以通过给类型加方法使得任意一个Julia类型变得{\textquotedbl}可被调用{\textquotedbl}。（这个{\textquotedbl}可调用{\textquotedbl}的对象有时称为{\textquotedbl}函子{\textquotedbl}。）



例如，你可以定义一个类型，存储着多项式的系数，但是行为像是一个函数，可以为多项式求值：




\begin{minted}{jlcon}
julia> struct Polynomial{R}
           coeffs::Vector{R}
       end

julia> function (p::Polynomial)(x)
           v = p.coeffs[end]
           for i = (length(p.coeffs)-1):-1:1
               v = v*x + p.coeffs[i]
           end
           return v
       end

julia> (p::Polynomial)() = p(5)
\end{minted}



注意函数是通过类型而非名字来指定的。如同普通函数一样这里有一个简洁的语法形式。在函数体内，\texttt{p}会指向被调用的对象。\texttt{Polynomial}会按如下方式使用：




\begin{minted}{jlcon}
julia> p = Polynomial([1,10,100])
Polynomial{Int64}([1, 10, 100])

julia> p(3)
931

julia> p()
2551
\end{minted}



这个机制也是Julia中类型构造函数和闭包（指向其环境的内部函数）的工作原理。



\hypertarget{117540638029415517}{}


\section{空泛型函数}



有时引入一个没有添加方法的范用函数是有用的。这会用于分离实现与接口定义。这也可为了文档或者代码可读性。为了这个的语法是没有参数组的一个空\texttt{函数}块：




\begin{minted}{julia}
function emptyfunc end
\end{minted}



\hypertarget{11088607530909626670}{}


\section{方法设计与避免歧义}



Julia的方法多态性是其最有力的特性之一，利用这个功能会带来设计上的挑战。特别地，在更加复杂的方法层级中出现\hyperlink{1524461975045594238}{歧义}不能说不常见。



在上面我们曾经指出我们可以像这样解决歧义




\begin{minted}{julia}
f(x, y::Int) = 1
f(x::Int, y) = 2
\end{minted}



靠定义一个方法




\begin{minted}{julia}
f(x::Int, y::Int) = 3
\end{minted}



这通常是正确的方案； 然而，在某些情况下，盲目地遵循这一建议可能会适得其反。 特别是，泛型函数的方法越多，产生歧义的可能性就越大。 当方法层次结构变得比这个简单的示例更复杂时，仔细考虑替代策略可能是值得的。



下面我们会讨论特别的一些挑战和解决这些挑战的一些可选方法。



\hypertarget{17193104641044635373}{}


\subsection{元组和N元组参数}



\texttt{Tuple}（和\texttt{NTuple}）参数会带来特别的挑战。例如，




\begin{minted}{julia}
f(x::NTuple{N,Int}) where {N} = 1
f(x::NTuple{N,Float64}) where {N} = 2
\end{minted}



是有歧义的，因为存在\texttt{N == 0}的可能性：没有元素去确定\texttt{Int}还是\texttt{Float64}变体应该被调用。为了解决歧义，一个方法是为空元组定义方法：




\begin{minted}{julia}
f(x::Tuple{}) = 3
\end{minted}



作为一种选择，对于其中一个方法之外的所有的方法可以坚持元组中至少有一个元素：




\begin{minted}{julia}
f(x::NTuple{N,Int}) where {N} = 1           # this is the fallback
f(x::Tuple{Float64, Vararg{Float64}}) = 2   # this requires at least one Float64
\end{minted}



\hypertarget{2934107525015609338}{}


\subsection{正交化你的设计}



当你打算根据两个或更多的参数进行分派时，考虑一下，一个「包裹」函数是否会让设计简单一些。举个例子，与其编写多变量：




\begin{minted}{julia}
f(x::A, y::A) = ...
f(x::A, y::B) = ...
f(x::B, y::A) = ...
f(x::B, y::B) = ...
\end{minted}



不如考虑定义




\begin{minted}{julia}
f(x::A, y::A) = ...
f(x, y) = f(g(x), g(y))
\end{minted}



这里\texttt{g}把参数转变为类型\texttt{A}。这是更加普遍的\href{https://en.wikipedia.org/wiki/Orthogonality\_(programming)}{正交设计}原理的一个特别特殊的例子，在正交设计中不同的概念被分配到不同的方法中去。这里\texttt{g}最可能需要一个fallback定义




\begin{minted}{julia}
g(x::A) = x
\end{minted}



一个相关的方案使用\texttt{promote}来把\texttt{x}和\texttt{y}变成常见的类型：




\begin{minted}{julia}
f(x::T, y::T) where {T} = ...
f(x, y) = f(promote(x, y)...)
\end{minted}



这个设计的一个隐患是：如果没有合适的把 \texttt{x} 和 \texttt{y} 转换到同样类型的类型提升方法，第二个方法就可能无限自递归然后引发堆溢出。



\hypertarget{2211158616759162982}{}


\subsection{一次只根据一个参数分派}



如果你你需要根据多个参数进行分派，并且有太多的为了能定义所有可能的变量而存在的组合，而存在很多回退函数，你可以考虑引入{\textquotedbl}名字级联{\textquotedbl}，这里（例如）你根据第一个参数分配然后调用一个内部的方法：




\begin{minted}{julia}
f(x::A, y) = _fA(x, y)
f(x::B, y) = _fB(x, y)
\end{minted}



接着内部方法\texttt{\_fA}和\texttt{\_fB}可以根据\texttt{y}进行分派，而不考虑有关\texttt{x}的歧义存在。



需要意识到这个方案至少有一个主要的缺点：在很多情况下，用户没有办法通过进一步定义你的输出函数\texttt{f}的具体行为来进一步定制\texttt{f}的行为。相反，他们需要去定义你的内部方法\texttt{\_fA}和\texttt{\_fB}的具体行为，这会模糊输出方法和内部方法之间的界线。



\hypertarget{7624993517486343641}{}


\subsection{抽象容器与元素类型}



在可能的情况下要试图避免定义根据抽象容器的具体元素类型来分派的方法。举个例子，




\begin{minted}{julia}
-(A::AbstractArray{T}, b::Date) where {T<:Date}
\end{minted}



会引起歧义，当定义了这个方法：




\begin{minted}{julia}
-(A::MyArrayType{T}, b::T) where {T}
\end{minted}



最好的方法是不要定义这些方法中的\emph{任何一个}。相反，使用范用方法\texttt{-(A::AbstractArray, b)}并确认这个方法是使用\emph{分别}对于每个容器类型和元素类型都是适用的通用调用(像\texttt{similar}和\texttt{-})实现的。这只是建议\hyperlink{1356336112225694303}{正交化}你的方法的一个更加复杂的变种而已。



当这个方法不可行时，这就值得与其他开发者开始讨论如果解决歧义；只是因为一个函数先定义并不总是意味着他不能改变或者被移除。作为最后一个手段，开发者可以定义{\textquotedbl}创可贴{\textquotedbl}方法




\begin{minted}{julia}
-(A::MyArrayType{T}, b::Date) where {T<:Date} = ...
\end{minted}



可以暴力解决歧义。



\hypertarget{5733743229509139145}{}


\subsection{与默认参数的复杂方法{\textquotedbl}级联{\textquotedbl}}



如果你定义了提供默认的方法{\textquotedbl}级联{\textquotedbl}，要小心去掉对应着潜在默认的任何参数。例如，假设你在写一个数字过滤算法，你有一个通过应用padding来出来信号的边的方法：




\begin{minted}{julia}
function myfilter(A, kernel, ::Replicate)
    Apadded = replicate_edges(A, size(kernel))
    myfilter(Apadded, kernel)  # now perform the "real" computation
end
\end{minted}



这会与提供默认padding的方法产生冲突：




\begin{minted}{julia}
myfilter(A, kernel) = myfilter(A, kernel, Replicate()) # replicate the edge by default
\end{minted}



这两个方法一起会生成无限的递归，\texttt{A}会不断变大。



更好的设计是像这样定义你的调用层级：




\begin{minted}{julia}
struct NoPad end  # indicate that no padding is desired, or that it's already applied

myfilter(A, kernel) = myfilter(A, kernel, Replicate())  # default boundary conditions

function myfilter(A, kernel, ::Replicate)
    Apadded = replicate_edges(A, size(kernel))
    myfilter(Apadded, kernel, NoPad())  # indicate the new boundary conditions
end

# other padding methods go here

function myfilter(A, kernel, ::NoPad)
    # Here's the "real" implementation of the core computation
end
\end{minted}



\texttt{NoPad} 被置于与其他 padding 类型一致的参数位置上，这保持了分派层级的良好组织，同时降低了歧义的可能性。而且，它扩展了「公开」的 \texttt{myfilter} 接口：想要显式控制 padding 的用户可以直接调用 \texttt{NoPad} 变量。



\footnotetext[2]{Arthur C. Clarke, \emph{Profiles of the Future} (1961): Clarke{\textquotesingle}s Third Law.

}


\hypertarget{17317810227993044854}{}


\chapter{构造函数}



构造函数 \footnotemark[1] 是用来创建新对象的函数 – 确切地说，它创建的是\hyperlink{4168730090950432836}{复合类型}的实例。在 Julia 中，类型对象也同时充当构造函数的角色：可以用类名加参数元组的方式像函数调用一样来创建新实例。这一点在介绍复合类型（Composite Types）时已经大致谈过了。例如：




\begin{minted}{jlcon}
julia> struct Foo
           bar
           baz
       end

julia> foo = Foo(1, 2)
Foo(1, 2)

julia> foo.bar
1

julia> foo.baz
2
\end{minted}



对很多类型来说，通过给所有字段赋值来创建新对象的这种方式就足以用于产生新实例了。然而，在某些情形下，创建复合对象需要更多的功能。有时必须通过检查或转化参数来确保固有属性不变。\href{https://en.wikipedia.org/wiki/Recursion\_\%28computer\_science\%29\#Recursive\_data\_structures\_.28structural\_recursion.29}{递归数据结构}，特别是那些可能引用自身的数据结构，它们通常不能被干净地构造，而是需要首先被不完整地构造，然后再通过编程的方式完成补全。为了方便，有时需要用较少的参数或者不同类型的参数来创建对象，Julia 的对象构造系统解决了所有这些问题。



\footnotetext[1]{命名法：虽然术语「构造函数」通常是指用于构造类型对象的函数全体，但通常会略微滥用术语将特定的构造方法称为「构造函数」。在这种情况下，通常可以从上下文中清楚地辨别出术语表示的是「构造方法」而不是「构造函数」，尤其是在讨论某个特别的「构造方法」的时候。

}


\hypertarget{8095711241800911617}{}


\section{外部构造方法}



构造函数与 Julia 中的其他任何函数一样，其整体行为由其各个方法的组合行为定义。因此，只要定义新方法就可以向构造函数添加功能。例如，假设你想为 \texttt{Foo} 对象添加一个构造方法，该方法只接受一个参数并其作为 \texttt{bar} 和 \texttt{baz} 的值。这很简单：




\begin{minted}{jlcon}
julia> Foo(x) = Foo(x,x)
Foo

julia> Foo(1)
Foo(1, 1)
\end{minted}



你也可以为 \texttt{Foo} 添加新的零参数构造方法，它为 \texttt{bar} 和 \texttt{baz} 提供默认值：




\begin{minted}{jlcon}
julia> Foo() = Foo(0)
Foo

julia> Foo()
Foo(0, 0)
\end{minted}



这里零参数构造方法会调用单参数构造方法，单参数构造方法又调用了自动提供默认值的双参数构造方法。上面附加的这类构造方法，它们的声明方式与普通的方法一样，像这样的构造方法被称为\textbf{外部}构造方法，下文很快就会揭示这样称呼的原因。外部构造方法只能通过调用其他构造方法来创建新实例，比如自动提供默认值的构造方法。



\hypertarget{3020780065533340945}{}


\section{内部构造方法}



尽管外部构造方法可以成功地为构造对象提供了额外的便利，但它无法解决另外两个在本章导言里提到的问题：确保固有属性不变和允许创建自引用对象。因此，我们需要\textbf{内部}构造方法。内部构造方法和外部构造方法很相像，但有两点不同：



\begin{itemize}
\item[1. ] 内部构造方法在类型声明代码块的内部，而不是和普通方法一样在外部。


\item[2. ] 内部构造方法能够访问一个特殊的局部函数 \hyperlink{13888762393600028594}{\texttt{new}}，此函数能够创建该类型的对象。

\end{itemize}


例如，假设你要声明一个保存一对实数的类型，但要约束第一个数不大于第二个数。你可以像这样声明它：




\begin{minted}{jlcon}
julia> struct OrderedPair
           x::Real
           y::Real
           OrderedPair(x,y) = x > y ? error("out of order") : new(x,y)
       end
\end{minted}



现在 \texttt{OrderedPair} 对象只能在 \texttt{x <= y} 时被成功构造：




\begin{minted}{jlcon}
julia> OrderedPair(1, 2)
OrderedPair(1, 2)

julia> OrderedPair(2,1)
ERROR: out of order
Stacktrace:
 [1] error at ./error.jl:33 [inlined]
 [2] OrderedPair(::Int64, ::Int64) at ./none:4
 [3] top-level scope
\end{minted}



如果类型被声明为 \texttt{mutable}，你可以直接更改字段值来打破这个固有属性，然而，在未经允许的情况下，随意摆弄对象的内核一般都是不好的行为。你（或者其他人）可以在以后任何时候提供额外的外部构造方法，但一旦类型被声明了，就没有办法来添加更多的内部构造方法了。由于外部构造方法只能通过调用其它的构造方法来创建对象，所以最终构造对象的一定是某个内部构造函数。这保证了已声明类型的对象必须通过调用该类型的内部构造方法才得已存在，从而在某种程度上保证了类型的固有属性。



只要定义了任何一个内部构造方法，Julia 就不会再提供默认的构造方法：它会假定你已经为自己提供了所需的所有内部构造方法。默认构造方法等效于一个你自己编写的内部构造函数，该函数将所有成员作为参数（如果相应的字段具有类型，则约束为正确的类型），并将它们传递给 \texttt{new}，最后返回结果对象：




\begin{minted}{jlcon}
julia> struct Foo
           bar
           baz
           Foo(bar,baz) = new(bar,baz)
       end

\end{minted}



这个声明与前面没有显式内部构造方法的 \texttt{Foo} 类型的定义效果相同。 以下两个类型是等价的 – 一个具有默认构造方法，另一个具有显式构造方法：




\begin{minted}{jlcon}
julia> struct T1
           x::Int64
       end

julia> struct T2
           x::Int64
           T2(x) = new(x)
       end

julia> T1(1)
T1(1)

julia> T2(1)
T2(1)

julia> T1(1.0)
T1(1)

julia> T2(1.0)
T2(1)
\end{minted}



提供尽可能少的内部构造方法是一种良好的形式：仅在需要显式地处理所有参数，以及强制执行必要的错误检查和转换时候才使用内部构造。其它用于提供便利的构造方法，比如提供默认值或辅助转换，应该定义为外部构造函数，然后再通过调用内部构造函数来执行繁重的工作。这种解耦是很自然的。



\hypertarget{7871769496419060352}{}


\section{不完整初始化}



最后一个还没提到的问题是，如何构造具有自引用的对象，更广义地来说是构造递归数据结构。由于这其中的困难并不是那么显而易见，这里我们来简单解释一下，考虑如下的递归类型声明：




\begin{minted}{jlcon}
julia> mutable struct SelfReferential
           obj::SelfReferential
       end

\end{minted}



这种类型可能看起来没什么大不了，直到我们考虑如何来构造它的实例。 如果 \texttt{a} 是 \texttt{SelfReferential} 的一个实例，则第二个实例可以用如下的调用来创建：




\begin{minted}{jlcon}
julia> b = SelfReferential(a)
\end{minted}



但是，当没有实例存在的情况下，即没有可以传递给 \texttt{obj} 成员变量的有效值时，如何构造第一个实例？唯一的解决方案是允许使用未初始化的 \texttt{obj} 成员来创建一个未完全初始化的 \texttt{SelfReferential} 实例，并使用该不完整的实例作为另一个实例的 \texttt{obj} 成员的有效值，例如，它本身。



为了允许创建未完全初始化的对象，Julia 允许使用少于该类型成员数的参数来调用 \href{@ ref}{\texttt{new}} 函数，并返回一个具有某个未初始化成员的对象。然后，内部构造函数可以使用不完整的对象，在返回之前完成初始化。例如，我们在定义 \texttt{SelfReferential} 类型时采用了另一个方法，使用零参数内部构造函数来返回一个实例，此实例的 \texttt{obj} 成员指向其自身：




\begin{minted}{jlcon}
julia> mutable struct SelfReferential
           obj::SelfReferential
           SelfReferential() = (x = new(); x.obj = x)
       end

\end{minted}



我们可以验证这一构造函数有效性，且由其构造的对象确实是自引用的：




\begin{minted}{jlcon}
julia> x = SelfReferential();

julia> x === x
true

julia> x === x.obj
true

julia> x === x.obj.obj
true
\end{minted}



虽然从一个内部构造函数中返回一个完全初始化的对象是很好的，但是也可以返回未完全初始化的对象：




\begin{minted}{jlcon}
julia> mutable struct Incomplete
           data
           Incomplete() = new()
       end

julia> z = Incomplete();
\end{minted}



尽管允许创建含有未初始化成员的对象，然而任何对未初始化引用的访问都会立即报错：




\begin{minted}{jlcon}
julia> z.data
ERROR: UndefRefError: access to undefined reference
\end{minted}



这避免了不断地检测 \texttt{null} 值的需要。然而，并不是所有的对象成员都是引用。Julia 会将一些类型当作纯数据（{\textquotedbl}plain data{\textquotedbl}），这意味着它们的数据是自包含的，并且没有引用其它对象。这些纯数据包括原始类型（比如 \texttt{Int} ）和由其它纯数据类型构成的不可变结构体。纯数据类型的初始值是未定义的：




\begin{minted}{jlcon}
julia> struct HasPlain
           n::Int
           HasPlain() = new()
       end

julia> HasPlain()
HasPlain(438103441441)
\end{minted}



由纯数据组成的数组也具有一样的行为。



在内部构造函数中，你可以将不完整的对象传递给其它函数来委托其补全构造：




\begin{minted}{jlcon}
julia> mutable struct Lazy
           data
           Lazy(v) = complete_me(new(), v)
       end
\end{minted}



与构造函数返回的不完整对象一样，如果 \texttt{complete\_me} 或其任何被调用者尝试在初始化之前访问 \texttt{Lazy} 对象的 \texttt{data} 字段，就会立刻报错。



\hypertarget{12775137678629941390}{}


\section{参数类型的构造函数}



参数类型的存在为构造函数增加了更多的复杂性。首先，让我们回顾一下\href{@ref}{参数类型}。在默认情况下，我们可以用两种方法来实例化参数复合类型，一种是显式地提供类型参数，另一种是让 Julia 根据构造函数输入参数的类型来隐式地推导类型参数。这里有一些例子：




\begin{minted}{jlcon}
julia> struct Point{T<:Real}
           x::T
           y::T
       end

julia> Point(1,2) ## 隐式的 T ##
Point{Int64}(1, 2)

julia> Point(1.0,2.5) ## 隐式的 T ##
Point{Float64}(1.0, 2.5)

julia> Point(1,2.5) ## 隐式的 T ##
ERROR: MethodError: no method matching Point(::Int64, ::Float64)
Closest candidates are:
  Point(::T, ::T) where T<:Real at none:2

julia> Point{Int64}(1, 2) ## 显式的 T ##
Point{Int64}(1, 2)

julia> Point{Int64}(1.0,2.5) ## 显式的 T ##
ERROR: InexactError: Int64(2.5)
Stacktrace:
[...]

julia> Point{Float64}(1.0, 2.5) ## 显式的 T ##
Point{Float64}(1.0, 2.5)

julia> Point{Float64}(1,2) ## 显式的 T ##
Point{Float64}(1.0, 2.0)
\end{minted}



就像你看到的那样，用类型参数显式地调用构造函数，其参数会被转换为指定的类型：\texttt{Point\{Int64\}(1,2)} 可以正常工作，但是 \texttt{Point\{Int64\}(1.0,2.5)} 则会在将 \texttt{2.5} 转换为 \hyperlink{7720564657383125058}{\texttt{Int64}} 的时候报一个 \hyperlink{5399118524830636312}{\texttt{InexactError}}。当类型是从构造函数的参数隐式推导出来的时候，比如在例子 \texttt{Point(1,2)} 中，输入参数的类型必须一致，否则就无法确定 \texttt{T} 是什么，但 \texttt{Point} 的构造函数仍可以适配任意同类型的实数对。



实际上，这里的 \texttt{Point}，\texttt{Point\{Float64\}} 以及 \texttt{Point\{Int64\}} 是不同的构造函数。\texttt{Point\{T\}} 表示对于每个类型 \texttt{T} 都存在一个不同的构造函数。如果不显式提供内部构造函数，在声明复合类型 \texttt{Point\{T<:Real\}} 的时候，Julia 会对每个满足 \texttt{T<:Real} 条件的类型都提供一个默认的内部构造函数 \texttt{Point\{T\}}，它们的行为与非参数类型的默认内部构造函数一致。Julia 同时也会提供了一个通用的外部构造函数 \texttt{Point}，用于适配任意同类型的实数对。Julia 默认提供的构造函数等价于下面这种显式的声明：




\begin{minted}{jlcon}
julia> struct Point{T<:Real}
           x::T
           y::T
           Point{T}(x,y) where {T<:Real} = new(x,y)
       end

julia> Point(x::T, y::T) where {T<:Real} = Point{T}(x,y);
\end{minted}



注意，每个构造函数定义的方式与调用它们的方式是一样的。调用 \texttt{Point\{Int64\}(1,2)} 会触发 \texttt{struct} 块内部的 \texttt{Point\{T\}(x,y)}。另一方面，外部构造函数声明的 \texttt{Point} 构造函数只会被同类型的实数对触发，它使得我们可以直接以 \texttt{Point(1,2)} 和 \texttt{Point(1.0,2.5)} 这种方式来创建实例，而不需要显示地使用类型参数。由于此方法的声明方式已经对输入参数的类型施加了约束，像 \texttt{Point(1,2.5)} 这种调用自然会导致 {\textquotedbl}no method{\textquotedbl} 错误。



假如我们想让 \texttt{Point(1,2.5)} 这种调用方式正常工作，比如，通过将整数 \texttt{1} 自动「提升」为浮点数 \texttt{1.0}，最简单的方法是像下面这样定义一个额外的外部构造函数：




\begin{minted}{jlcon}
julia> Point(x::Int64, y::Float64) = Point(convert(Float64,x),y);
\end{minted}



此方法使用 \hyperlink{1846942650946171605}{\texttt{convert}} 函数将 \texttt{x} 显式转换为 \hyperlink{5027751419500983000}{\texttt{Float64}}，然后在两个参数都是 \hyperlink{5027751419500983000}{\texttt{Float64}} 的情况下使用通用的构造函数。通过这个方法定义，以前的报\hyperlink{68769522931907606}{\texttt{MethodError}}的代码现在可以成功地创建一个类型为 \texttt{Point\{Float64\}} 的点：




\begin{minted}{jlcon}
julia> p = Point(1,2.5)
Point{Float64}(1.0, 2.5)

julia> typeof(p)
Point{Float64}
\end{minted}



然而，其它类似的调用依然有问题：




\begin{minted}{jlcon}
julia> Point(1.5,2)
ERROR: MethodError: no method matching Point(::Float64, ::Int64)
Closest candidates are:
  Point(::T, !Matched::T) where T<:Real at none:1
\end{minted}



如果你想要找到一种方法可以使类似的调用都可以正常工作，请参阅\hyperlink{10374023657104680331}{类型转换与类型提升}。这里稍稍“剧透”一下，我们可以利用下面的这个外部构造函数来满足需求，无论输入参数的类型如何，它都可以触发通用的 \texttt{Point} 构造函数：




\begin{minted}{jlcon}
julia> Point(x::Real, y::Real) = Point(promote(x,y)...);
\end{minted}



这里的 \texttt{promote} 函数会将它的输入转化为同一类型，在此例中是 \hyperlink{5027751419500983000}{\texttt{Float64}}。定义了这个方法，\texttt{Point} 构造函数会自动提升输入参数的类型，且提升机制与算术运算符相同，比如 \hyperlink{3677358729494553841}{\texttt{+}}，因此对所有的实数输入参数都适用：




\begin{minted}{jlcon}
julia> Point(1.5,2)
Point{Float64}(1.5, 2.0)

julia> Point(1,1//2)
Point{Rational{Int64}}(1//1, 1//2)

julia> Point(1.0,1//2)
Point{Float64}(1.0, 0.5)
\end{minted}



因此，虽然 Julia 中默认提供的隐式类型参数构造函数相当严格，但可以很容易地使它们以更轻松且明智的方式运行。 此外，由于构造函数可以利用类型系统、方法和多重派发的所有功能，因此定义复杂的行为通常非常简单。



\hypertarget{16487801695295609688}{}


\section{示例学习：有理数}



也许将所有这些部分联系在一起的最佳方法是展示参数复合类型及其构造方法的真实示例。 为此，我们实现了自己的有理数类型 \texttt{OurRational}，类似于 Julia 的内置 \hyperlink{8304566144531167610}{\texttt{Rational}} 类型，定义在 [\texttt{rational.jl}](https://github.com/JuliaLang /julia/blob/master/base/rational.jl）：




\begin{minted}{jlcon}
julia> struct OurRational{T<:Integer} <: Real
           num::T
           den::T
           function OurRational{T}(num::T, den::T) where T<:Integer
               if num == 0 && den == 0
                    error("invalid rational: 0//0")
               end
               num = flipsign(num, den)
               den = flipsign(den, den)
               g = gcd(num, den)
               num = div(num, g)
               den = div(den, g)
               new(num, den)
           end
       end

julia> OurRational(n::T, d::T) where {T<:Integer} = OurRational{T}(n,d)
OurRational

julia> OurRational(n::Integer, d::Integer) = OurRational(promote(n,d)...)
OurRational

julia> OurRational(n::Integer) = OurRational(n,one(n))
OurRational

julia> ⊘(n::Integer, d::Integer) = OurRational(n,d)
⊘ (generic function with 1 method)

julia> ⊘(x::OurRational, y::Integer) = x.num ⊘ (x.den*y)
⊘ (generic function with 2 methods)

julia> ⊘(x::Integer, y::OurRational) = (x*y.den) ⊘ y.num
⊘ (generic function with 3 methods)

julia> ⊘(x::Complex, y::Real) = complex(real(x) ⊘ y, imag(x) ⊘ y)
⊘ (generic function with 4 methods)

julia> ⊘(x::Real, y::Complex) = (x*y') ⊘ real(y*y')
⊘ (generic function with 5 methods)

julia> function ⊘(x::Complex, y::Complex)
           xy = x*y'
           yy = real(y*y')
           complex(real(xy) ⊘ yy, imag(xy) ⊘ yy)
       end
⊘ (generic function with 6 methods)
\end{minted}



第一行 – \texttt{struct OurRational\{T<:Integer\} <: Real} – 声明了 \texttt{OurRational} 会接收一个整数类型的类型参数，且它自己属于实数类型。它声明了两个成员：\texttt{num::T} 和 \texttt{den::T}。这表明一个 \texttt{OurRational\{T\}} 的实例中会包含一对整数，且类型为 \texttt{T}，其中一个表示分子，另一个表示分母。



现在事情变得有趣了。 \texttt{OurRational} 有一个内部构造器方法，它检查 \texttt{num} 和 \texttt{den} 不都为零，并确保每个有理数都是以非负分母的“最低项”构造的。 这是通过首先翻转分子和分母的符号（如果分母为负）来实现的。 然后，两者都除以它们的最大公约数（\texttt{gcd} 总是返回一个非负数，无论其参数的符号如何）。 因为这是 \texttt{OurRational} 唯一的内部构造函数，我们可以确定 \texttt{OurRational} 对象总是以这种规范化形式构造的。



为了方便，\texttt{OurRational} 也提供了一些其它的外部构造函数。第一个外部构造函数是“标准的”通用构造函数，当分子和分母的类型一致时，它就可以推导出类型参数 \texttt{T}。第二个外部构造函数可以用于分子和分母的类型不一致的情景，它会将分子和分母的类型提升至一个共同的类型，然后再委托第一个外部构造函数进行构造。第三个构造函数会将一个整数转化为分数，方法是将 1 当作分母。



在定义了外部构造函数之后，我们为 \texttt{⊘} 算符定义了一系列的方法，之后就可以使用 \texttt{⊘} 算符来写分数，（比如 \texttt{1 ⊘ 2}）。Julia 的 \texttt{Rational} 类型采用的是 \hyperlink{17539582191808611917}{\texttt{//}} 算符。在做上述定义之前，\texttt{⊘} 是一个无意的且未被定义的算符。定义之后，它的行为与在 \href{@ref Rational-Numbers}{有理数} 一节中描述的一致——注意它的所有行为都是那短短几行定义的。第一个也是最基础的定义只是将 \texttt{a ⊘ b} 中的 \texttt{a} 和 \texttt{b} 当作参数传递给 \texttt{OurRational} 的构造函数来实例化 \texttt{OurRational}，这要求 \texttt{a} 和 \texttt{b} 分别都是整数。在 \texttt{⊘} 的某个操作数已经是分数的情况下，我们采用了一个有点不一样的方法来构建新的分数，这实际上等价于用分数除以一个整数。最后，我们也可以让 \texttt{⊘} 作用于复数，用来创建一个类型为 \texttt{Complex\{<:OurRational\}} 的对象——即一个实部和虚部都是分数的复数：




\begin{minted}{jlcon}
julia> z = (1 + 2im) ⊘ (1 - 2im);

julia> typeof(z)
Complex{OurRational{Int64}}

julia> typeof(z) <: Complex{<:OurRational}
true
\end{minted}



因此，尽管 \texttt{⊘} 算符通常会返回一个 \texttt{OurRational} 的实例，但倘若其中一个操作数是复整数，那么就会返回 \texttt{Complex\{<:OurRational\}}。感兴趣的话可以读一读 \href{https://github.com/JuliaLang/julia/blob/master/base/rational.jl}{\texttt{rational.jl}}：它实现了一个完整的 Julia 基本类型，但却非常的简短，而且是自恰的。



\hypertarget{1423089157217028680}{}


\section{仅外部的构造函数}



正如我们所看到的，典型的参数类型都有一个内部构造函数，它仅在全部的类型参数都已知的情况下才会被调用。例如，可以用 \texttt{Point\{Int\}}调用，但\texttt{Point} 就不行。我们可以选择性的添加外部构造函数来自动推导并添加类型参数，比如，调用 \texttt{Point(1,2)} 来构造 \texttt{Point\{Int\}}。外部构造函数调用内部构造函数来实际创建实例。然而，在某些情况下，我们可能并不想要内部构造函数，从而达到禁止手动指定类型参数的目的。



例如，假设我们要定义一个类型用于存储向量以及其累加和：




\begin{minted}{jlcon}
julia> struct SummedArray{T<:Number,S<:Number}
           data::Vector{T}
           sum::S
       end

julia> SummedArray(Int32[1; 2; 3], Int32(6))
SummedArray{Int32, Int32}(Int32[1, 2, 3], 6)
\end{minted}



问题在于我们想让 \texttt{S} 的类型始终比 \texttt{T} 大，这样做是为了确保累加过程不会丢失信息。例如，当 \texttt{T} 是 \hyperlink{10103694114785108551}{\texttt{Int32}} 时，我们想让 \texttt{S} 是 \hyperlink{7720564657383125058}{\texttt{Int64}}。所以我们想要一种接口来禁止用户创建像 \texttt{SummedArray\{Int32,Int32\}} 这种类型的实例。一种实现方式是只提供一个 \texttt{SummedArray} 构造函数，当需要将其放入 \texttt{struct}-block 中，从而不让 Julia 提供默认的构造函数：




\begin{minted}{jlcon}
julia> struct SummedArray{T<:Number,S<:Number}
           data::Vector{T}
           sum::S
           function SummedArray(a::Vector{T}) where T
               S = widen(T)
               new{T,S}(a, sum(S, a))
           end
       end

julia> SummedArray(Int32[1; 2; 3], Int32(6))
ERROR: MethodError: no method matching SummedArray(::Vector{Int32}, ::Int32)
Closest candidates are:
  SummedArray(::Vector{T}) where T at none:4
Stacktrace:
[...]
\end{minted}



此构造函数将会被 \texttt{SummedArray(a)} 这种写法触发。\texttt{new\{T,S\}} 的这种写法允许指定待构建类型的参数，也就是说调用它会返回一个 \texttt{SummedArray\{T,S\}} 的实例。\texttt{new\{T,S\}} 也可以用于其它构造函数的定义中，但为了方便，Julia 会根据正在构造的类型自动推导出 \texttt{new\{\}} 花括号里的参数（如果可行的话）。



\hypertarget{10686378388163930476}{}


\chapter{类型转换和类型提升}



Julia 有一个提升系统，可以将数学运算符的参数提升为通用类型，如在前面章节中提到的\hyperlink{8249022581856827126}{整数和浮点数}、\hyperlink{16865688524696028421}{数学运算和初等函数}、\hyperlink{8510890508040013186}{类型}和\hyperlink{3842379394166369470}{方法}。在本节中，我们将解释类型提升系统如何工作，以及如何将其扩展到新的类型，并将其应用于除内置数学运算符之外的其他函数。传统上，编程语言在参数的类型提升上分为两大阵营:



\begin{itemize}
\item \textbf{内置数学类型和运算符的自动类型提升。}大多数语言中，内置数值类型，当作为带有中缀语法的算术运算符的操作数时，例如 \texttt{+}、\texttt{-}、\texttt{*} 和 \texttt{/} 将自动提升为通用类型，以产生预期的结果。举例来说，C、Java、Perl 和 Python，都将 \texttt{1 + 1.5} 的和作为浮点值 \texttt{2.5}，即使 \texttt{+} 的一个操作数是整数。这些系统非常方便且设计得足够精细，以至于它对于程序员来讲通常是不可见的：在编写这样的表达式时，几乎没有人有意识地想到这种类型提升，但编译器和解释器必须在相加前执行转换，因为整数和浮点值无法按原样相加。因此，这种自动类型转换的复杂规则不可避免地是这些语言的规范和实现的一部分。


\item \textbf{没有自动类型提升。}这个阵营包括 Ada 和 ML——非常「严格的」 静态类型语言。在这些语言中，每个类型转换都必须由程序员明确指定。因此，示例表达式 \texttt{1 + 1.5} 在 Ada 和 ML 中都会导致编译错误。相反地，必须编写 \texttt{real(1) + 1.5}，来在执行加法前将整数 \texttt{1} 显式转换为浮点值。然而，处处都显式转换是如此地不方便，以至于连 Ada 也有一定程度的自动类型转换：整数字面量被类型提升为预期的整数类型，浮点字面量同样被类型提升为适当的浮点类型。

\end{itemize}


在某种意义上，Julia 属于「无自动类型提升」类别：数学操作符只是具有特殊语法的函数，函数的参数永远不会自动转换。然而，人们可能会发现数学运算能应用于各种混合的参数类型，但这只是多态的多重分派的极端情况——这是 Julia 的分派和类型系统特别适合处理的情况。数学操作数的「自动」类型提升只是作为一个特殊的应用出现：Julia 带有预定义的数学运算符的 catch-all 分派规则，其在某些操作数类型的组合没有特定实现时调用。这些 catch-all 分派规则首先使用用户可定义的类型提升规则将所有操作数提升到一个通用的类型，然后针对结果值（现在已属于相同类型）调用相关运算符的特定实现。用户定义的类型可简单地加入这个类型提升系统，这需要先定义与其它类型进行相互类型转换的方法，接着提供一些类型提升规则来定义与其它类型混合时应该提升到什么类型。



\hypertarget{5183188243565893084}{}


\section{类型转换}



获取某种类型 \texttt{T} 的值的标准方法是调用该类型的构造函数 \texttt{T(x)}。但是，有些情况下，在程序员没有明确要求时，仍将值从一种类型转换为另一种类型是很方便的。其中一个例子是将值赋给一个数组：假设 \texttt{A} 是个 \texttt{Vector\{Float64\}}，表达式 \texttt{A[1] = 2} 执行时应该自动将 \texttt{2} 从 \texttt{Int} 转换为 \texttt{Float}，并将结果存储在该数组中。这通过 \hyperlink{1846942650946171605}{\texttt{convert}} 函数完成。



\texttt{convert} 函数通常接受两个参数：第一个是类型对象，第二个是需要转换为该类型的值。返回的是已转换后的值。理解这个函数最简单的办法就是尝试：




\begin{minted}{jlcon}
julia> x = 12
12

julia> typeof(x)
Int64

julia> xu = convert(UInt8, x)
0x0c

julia> typeof(xu)
UInt8

julia> xf = convert(AbstractFloat, x)
12.0

julia> typeof(xf)
Float64

julia> a = Any[1 2 3; 4 5 6]
2×3 Matrix{Any}:
 1  2  3
 4  5  6

julia> convert(Array{Float64}, a)
2×3 Matrix{Float64}:
 1.0  2.0  3.0
 4.0  5.0  6.0
\end{minted}



类型转换并不总是可行的，有时 \texttt{convert} 函数并不知道该如何执行所请求的类型转换就会抛出 \hyperlink{68769522931907606}{\texttt{MethodError}} 错误。例如下例：




\begin{minted}{jlcon}
julia> convert(AbstractFloat, "foo")
ERROR: MethodError: Cannot `convert` an object of type String to an object of type AbstractFloat
[...]
\end{minted}



一些语言考虑将解析字符串为数字或格式化数字为字符串来进行转换（许多动态语言甚至会自动执行转换），但 Julia 不会：尽管某些字符串可以解析为数字，但大多数字符串都不是有效的数字表示形式，只有非常有限的子集才是。因此，在 Julia 中，必须使用专用的 \hyperlink{14207407853646164654}{\texttt{parse}} 函数来执行此操作，这使其更加明确。



\hypertarget{7039772400060801175}{}


\subsection{什么时候使用 \texttt{convert} 函数?}



构造以下语言结构时需要调用 \texttt{convert} 函数：



\begin{itemize}
\item 对一个数组赋值会转换为数组元素的类型。


\item 对一个对象的字段赋值会转换为已声明的字段类型。


\item 使用 \hyperlink{13888762393600028594}{\texttt{new}} 构造对象会转换为该对象已声明的字段类型。


\item 对已声明类型的变量赋值（例如 \texttt{local x::T}）会转换为该类型。


\item 已声明返回类型的函数会转换其返回值为该类型。


\item 把值传递给 \hyperlink{14245046751182637566}{\texttt{ccall}} 会将其转换为相应参数的类型。

\end{itemize}


\hypertarget{11541557100875125079}{}


\subsection{类型转换与构造}



注意到 \texttt{convert(T, x)} 的行为似乎与 \texttt{T(x)} 几乎相同，它的确通常是这样。但是，有一个关键的语义差别：因为 \texttt{convert} 能被隐式调用，所以它的方法仅限于被认为是「安全」或「意料之内」的情况。\texttt{convert} 只会在表示事物的相同基本种类的类型之间进行转换（例如，不同的数字表示和不同的字符串编码）。它通常也是无损的；将值转换为其它类型并再次转换回去应该产生完全相同的值。



这是四种一般的构造函数与 \texttt{convert} 不同的情况：



\hypertarget{17931790162561418365}{}


\subsubsection{与其参数类型无关的类型的构造函数}



一些构造函数没有体现「转换」的概念。例如，\texttt{Timer(2)} 创建一个时长 2 秒的定时器，它实际上并不是从整数到定时器的「转换」。



\hypertarget{8367796589961400339}{}


\subsubsection{可变的集合}



如果 \texttt{x} 类型已经为 \texttt{T}，\texttt{convert(T, x)} 应该返回原本的 \texttt{x}。相反地，如果 \texttt{T} 是一个可变的集合类型，那么 \texttt{T(x)} 应该总是创建一个新的集合（从 \texttt{x} 复制元素）。



\hypertarget{13864114731640700485}{}


\subsubsection{封装器类型}



对于某些「封装」其它值的类型，构造函数可能会将其参数封装在一个新对象中，即使它已经是所请求的类型。例如，用 \texttt{Some(x)} 表示封装了一个 \texttt{x} 值（在上下文中，其结果可能是一个 \texttt{Some} 或 \texttt{nothing}）。但是，\texttt{x} 本身可能是对象 \texttt{Some(y)}，在这种情况下，结果为 \texttt{Some(Some(y))}，封装了两层。然而，\texttt{convert(Some, x)} 只会返回 \texttt{x}，因为它已经是 \texttt{Some} 的实例了。



\hypertarget{1440871335026577968}{}


\subsubsection{不返回自身类型的实例的构造函数}



在\emph{极少见}的情况下，构造函数 \texttt{T(x)} 返回一个类型不为 \texttt{T} 的对象是有意义的。如果封装器类型是它自身的反转（例如 \texttt{Flip(Flip(x)) === x}），或者在重构库时为了支持某个旧的调用语法以实现向后兼容，则可能发生这种情况。但是，\texttt{convert(T, x)} 应该总是返回一个类型为 \texttt{T} 的值。



\hypertarget{16585115796165922811}{}


\subsection{定义新的类型转换}



在定义新类型时，最初创建它的所有方法都应定义为构造函数。如果隐式类型转换很明显是有用的，并且某些构造函数满足上面的「安全」标准，那么可以考虑添加 \texttt{convert} 方法。这些方法通常非常简单，因为它们只需要调用适当的构造函数。此类定义可能会像这样：




\begin{minted}{julia}
convert(::Type{MyType}, x) = MyType(x)
\end{minted}



这个方法的第一个参数的类型是\hyperlink{5449736533675714976}{\texttt{Type\{MyType\}}}，它的唯一实例是\texttt{MyType}。 因此，仅当第一个参数是类型值\texttt{MyType}时才会调用此方法。注意第一个参数使用的语法：在\texttt{::}符号之前省略参数名称，只给出类型。 这是 Julia 中指定类型但不需要通过名称引用其值的函数参数的语法。



某些抽象类型的所有实例默认都被认为是「足够相似的」，在 Julia Base 中也提供了通用的 \texttt{convert} 定义。例如，这个定义声明通过调用单参数构造函数将任何 \texttt{Number} 类型 \texttt{convert} 为其它任何 \texttt{Number} 类型是有效的：




\begin{minted}{julia}
convert(::Type{T}, x::Number) where {T<:Number} = T(x)
\end{minted}



这意味着新的 \texttt{Number} 类型只需要定义构造函数，因为此定义将为它们处理 \texttt{convert}。在参数已经是所请求的类型的情况下，用恒同变换来处理 \texttt{convert}。




\begin{minted}{julia}
convert(::Type{T}, x::T) where {T<:Number} = x
\end{minted}



\texttt{AbstractString}、\hyperlink{6514416309183787338}{\texttt{AbstractArray}} 和 \hyperlink{6373987858401217649}{\texttt{AbstractDict}} 也存在类似的定义。



\hypertarget{701866407360133120}{}


\section{类型提升}



类型提升是指将一组混合类型的值转换为单个通用类型。尽管不是绝对必要的，但一般暗示被转换的值的通用类型可以忠实地表示所有原始值。此意义下，术语「类型提升」是合适的，因为值被转换为「更大」的类型——即能用一个通用类型表示所有输入值的类型。但重要的是，不要将它与面向对象（结构）超类或 Julia 的抽象超类型混淆：类型提升与类型层次结构无关，而与备选的表示之间的转换有关。例如，尽管每个 \hyperlink{10103694114785108551}{\texttt{Int32}} 值可以表示为 \hyperlink{5027751419500983000}{\texttt{Float64}} 值，但 \texttt{Int32} 不是 \texttt{Float64} 的子类型。



在 Julia 中，类型提升到一个通用的「更大」类型的操作是通过 \hyperlink{1760874576431605095}{\texttt{promote}} 函数执行的，该函数接受任意数量的参数，并返回由相同数量的值组成的元组，值会被转换为一个通用类型，或在无法类型提升时抛出异常。类型提升的最常见用途是将数字参数转换为通用类型：




\begin{minted}{jlcon}
julia> promote(1, 2.5)
(1.0, 2.5)

julia> promote(1, 2.5, 3)
(1.0, 2.5, 3.0)

julia> promote(2, 3//4)
(2//1, 3//4)

julia> promote(1, 2.5, 3, 3//4)
(1.0, 2.5, 3.0, 0.75)

julia> promote(1.5, im)
(1.5 + 0.0im, 0.0 + 1.0im)

julia> promote(1 + 2im, 3//4)
(1//1 + 2//1*im, 3//4 + 0//1*im)
\end{minted}



浮点值被提升为最大的浮点参数类型。整数值会被提升为本机机器字大小或最大的整数参数类型中较大的一个。整数和浮点值的混合会被提升为一个足以包含所有值的浮点类型。与有理数混合的整数会被提升有理数。与浮点数混合的有理数会被提升为浮点数。与实数值混合的复数值会被提升为合适类型的复数值。



这就是使用类型提升的全部内容。剩下的只是聪明的应用，最典型的「聪明」应用是数值操作（如 \texttt{+}、\texttt{-}、\texttt{*} 和 \texttt{/}）的 catch-all 方法的定义。以下是在 \href{https://github.com/JuliaLang/julia/blob/master/base/promotion.jl}{\texttt{promotion.jl}} 中给出的几个 catch-all 方法的定义：




\begin{minted}{julia}
+(x::Number, y::Number) = +(promote(x,y)...)
-(x::Number, y::Number) = -(promote(x,y)...)
*(x::Number, y::Number) = *(promote(x,y)...)
/(x::Number, y::Number) = /(promote(x,y)...)
\end{minted}



这些方法的定义表明，如果没有更特殊的规则来加、减、乘及除一对数值，则将这些值提升为通用类型并再试一次。这就是它的全部内容：在其它任何地方都不需要为数值操作担心到通用数值类型的类型提升——它会自动进行。许多算术和数学函数的 catch-all 类型提升方法的定义在 \href{https://github.com/JuliaLang/julia/blob/master/base/promotion.jl}{\texttt{promotion.jl}} 中，但除此之外，Julia Base 中几乎不再需要调用 \texttt{promote}。\texttt{promote} 最常用于外部构造方法中，为了更方便，可允许使用混合类型的构造函数调用委托给一个内部构造函数，并将字段提升为适当的通用类型。例如，回想一下，\href{https://github.com/JuliaLang/julia/blob/master/base/rational.jl}{\texttt{rational.jl}} 提供了以下外部构造方法：




\begin{minted}{julia}
Rational(n::Integer, d::Integer) = Rational(promote(n,d)...)
\end{minted}



这允许像下面这样的调用正常工作：




\begin{minted}{jlcon}
julia> x = Rational(Int8(15),Int32(-5))
-3//1

julia> typeof(x)
Rational{Int32}
\end{minted}



对于大多数用户定义的类型，最好要求程序员明确地向构造函数提供期待的类型，但有时，尤其是对于数值问题，自动进行类型提升会很方便。



\hypertarget{13578530399861722948}{}


\subsection{定义类型提升规则}



虽然原则上可以直接为 \texttt{promote} 函数定义方法，但这需要为参数类型的所有可能排列下许多冗余的定义。相反地，\texttt{promote} 的行为是根据名为 \hyperlink{16547112220540026290}{\texttt{promote\_rule}} 的辅助函数定义的，该辅助函数可以为其提供方法。\texttt{promote\_rule} 函数接受一对类型对象并返回另一个类型对象，这样参数类型的实例会被提升为被返回的类型。 因此，通过定义规则：




\begin{minted}{julia}
promote_rule(::Type{Float64}, ::Type{Float32}) = Float64
\end{minted}



声明当同时类型提升 64 位和 32 位浮点值时，它们应该被类型提升为 64 位浮点数。但是，提升类型不需要是参数类型之一；例如，在 Julia Base 中有以下类型提升规则：




\begin{minted}{julia}
promote_rule(::Type{BigInt}, ::Type{Float64}) = BigFloat
promote_rule(::Type{BigInt}, ::Type{Int8}) = BigInt
\end{minted}



在后一种情况下，输出类型是 \hyperlink{423405808990690832}{\texttt{BigInt}}，因为 \texttt{BigInt} 是唯一一个足以容纳任意精度整数运算结果的类型。还要注意，不需要同时定义 \texttt{promote\_rule(::Type\{A\}, ::Type\{B\})} 和 \texttt{promote\_rule(::Type\{B\}, ::Type\{A\})}——对称性隐含在类型提升过程中使用 \texttt{promote\_rule} 的方式。



以 \texttt{promote\_rule} 函数为基础定义了 \hyperlink{15048881762587391286}{\texttt{promote\_type}} 函数，在给定任意数量的类型对象时，它返回这些值作为 \texttt{promote} 的参数应被提升的通用类型。因此，如果想知道在没有实际值情况下，具有确定类型的一些值会被类型提升为什么类型，可以使用 \texttt{promote\_type}：




\begin{minted}{jlcon}
julia> promote_type(Int8, Int64)
Int64
\end{minted}



在内部，\texttt{promote\_type} 在 \texttt{promote} 中用于确定参数值应被转换为什么类型以便进行类型提升。但是，它本身可能是有用的。好奇的读者可以阅读 \href{https://github.com/JuliaLang/julia/blob/master/base/promotion.jl}{\texttt{promotion.jl}}，该文件用大概 35 行定义了完整的类型提升规则。



\hypertarget{8231690970182763012}{}


\subsection{案例研究：有理数的类型提升}



最后，我们来完成关于 Julia 的有理数类型的案例研究，该案例通过以下类型提升规则相对复杂地使用了类型提升机制：




\begin{minted}{julia}
promote_rule(::Type{Rational{T}}, ::Type{S}) where {T<:Integer,S<:Integer} = Rational{promote_type(T,S)}
promote_rule(::Type{Rational{T}}, ::Type{Rational{S}}) where {T<:Integer,S<:Integer} = Rational{promote_type(T,S)}
promote_rule(::Type{Rational{T}}, ::Type{S}) where {T<:Integer,S<:AbstractFloat} = promote_type(T,S)
\end{minted}



第一条规则说，使用其它整数类型类型提升有理数类型会得到个有理数类型，其分子/分母类型是使用其它整数类型提升该有理数分子/分母类型的结果。第二条规则将相同的逻辑应用于两种不同的有理数类型，它们进行类型提升会得到有理数类型，其分子/分母类型是它们各自的分子/分母类型进行提升的结果。第三个也是最后一个规则规定，使用浮点数类型提升有理数类型与使用该浮点数类型提升其分子/分母类型会产生相同的类型。



这一小部分的类型提升规则，连同该类型的构造函数和数字的默认 \texttt{convert} 方法，便足以使有理数与 Julia 的其它数值类型——整数、浮点数和复数——完全自然地互操作。通过以相同的方式提供类型转换方法和类型提升规则，任何用户定义的数值类型都可像 Julia 的预定义数值类型一样自然地进行互操作。



\hypertarget{5506253490972465797}{}


\chapter{接口}



Julia 的很多能力和扩展性都来自于一些非正式的接口。通过为自定义的类型扩展一些特定的方法，自定义类型的对象不但获得那些方法的功能，而且也能够用于其它的基于那些行为而定义的通用方法中。



\hypertarget{5510379658285713272}{}


\section{迭代}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
必需方法 &  & 简短描述 \\
\hline
\texttt{iterate(iter)} &  & 通常返回由第一项及其初始状态组成的元组，但如果为空，则返回 \hyperlink{9331422207248206047}{\texttt{nothing}} \\
\hline
\texttt{iterate(iter, state)} &  & 通常返回由下一项及其状态组成的元组，或者在没有下一项存在时返回 \texttt{nothing}。 \\
\hline
\textbf{重要可选方法} & \textbf{默认定义} & \textbf{简短描述} \\
\hline
\texttt{IteratorSize(IterType)} & \texttt{HasLength()} & \texttt{HasLength()}，\texttt{HasShape\{N\}()}，\texttt{IsInfinite()} 或者 \texttt{SizeUnknown()} 中合适的一个 \\
\hline
\texttt{IteratorEltype(IterType)} & \texttt{HasEltype()} & \texttt{EltypeUnknown()} 或 \texttt{HasEltype()} 中合适的一个 \\
\hline
\texttt{eltype(IterType)} & \texttt{Any} & 由 \texttt{iterate()} 返回元组中第一项的类型。 \\
\hline
\texttt{length(iter)} & (\emph{未定义}) & 项数，如果已知 \\
\hline
\texttt{size(iter, [dim])} & (\emph{未定义}) & 在各个维度上项数，如果已知 \\
\hline
\end{tabulary}

\end{table}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
由 \texttt{IteratorSize(IterType)} 返回的值 & 必需方法 \\
\hline
\texttt{HasLength()} & \hyperlink{3699181304419743826}{\texttt{length(iter)}} \\
\hline
\texttt{HasShape\{N\}()} & \texttt{length(iter)} 和 \texttt{size(iter, [dim])} \\
\hline
\texttt{IsInfinite()} & (\emph{无}) \\
\hline
\texttt{SizeUnknown()} & (\emph{无}) \\
\hline
\end{tabulary}

\end{table}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
由 \texttt{IteratorEltype(IterType)} 返回的值 & 必需方法 \\
\hline
\texttt{HasEltype()} & \texttt{eltype(IterType)} \\
\hline
\texttt{EltypeUnknown()} & (\emph{none}) \\
\hline
\end{tabulary}

\end{table}



顺序迭代由 \hyperlink{1722534687975587846}{\texttt{iterate}} 函数实现。 Julia 的迭代器可以从对象外部跟踪迭代状态，而不是在迭代过程中改变对象本身。 迭代过程中的返回一个包含了当前迭代值及其状态的元组，或者在没有元素存在的情况下返回 \texttt{nothing}。 状态对象将在下一次迭代时传递回 iterate 函数，并且通常被认为是可迭代对象的私有实现细节。



任何定义了这个函数的对象都是可迭代的，并且可以被应用到\hyperlink{16454089156260356769}{许多依赖迭代的函数上} 。 也可以直接被应用到  \hyperlink{9105224580875818383}{\texttt{for}} 循环中，因为根据语法：




\begin{minted}{julia}
for item in iter   # or  "for item = iter"
    # body
end
\end{minted}



以上代码被解释为：




\begin{minted}{julia}
next = iterate(iter)
while next !== nothing
    (item, state) = next
    # body
    next = iterate(iter, state)
end
\end{minted}



举一个简单的例子：一组定长数据的平方数迭代序列：




\begin{minted}{jlcon}
julia> struct Squares
           count::Int
       end

julia> Base.iterate(S::Squares, state=1) = state > S.count ? nothing : (state*state, state+1)
\end{minted}



仅仅定义了 \hyperlink{1722534687975587846}{\texttt{iterate}} 函数的 \texttt{Squares} 类型就已经很强大了。 我们现在可以迭代所有的元素了：




\begin{minted}{jlcon}
julia> for item in Squares(7)
           println(item)
       end
1
4
9
16
25
36
49
\end{minted}



我们可以利用许多内置方法来处理迭代，比如标准库 \texttt{Statistics}  中的 \hyperlink{17277603976666670638}{\texttt{in}}，\hyperlink{15061550543970113934}{\texttt{mean}} 和 \hyperlink{1955374586742019663}{\texttt{std}} 。




\begin{minted}{jlcon}
julia> 25 in Squares(10)
true

julia> using Statistics

julia> mean(Squares(100))
3383.5

julia> std(Squares(100))
3024.355854282583
\end{minted}



我们可以扩展一些其它的方法，为 Julia 提供有关此可迭代集合的更多信息。我们知道 \texttt{Squares} 序列中的元素总是 \texttt{Int} 型的。通过扩展 \hyperlink{6396209842929672718}{\texttt{eltype}} 方法，我们可以给 Julia 更多信息来帮助其在更复杂的方法中生成更具体的代码。我们同时也知道该序列中的元素数目，故同样地也可以扩展 \hyperlink{9362803119463040896}{\texttt{length}}：




\begin{minted}{jlcon}
julia> Base.eltype(::Type{Squares}) = Int # Note that this is defined for the type

julia> Base.length(S::Squares) = S.count
\end{minted}



现在，当我们让 Julia 去 \hyperlink{6278865767444641812}{\texttt{collect}} 所有元素到一个数组中时，Julia 可以预分配一个适当大小的 \texttt{Vector\{Int\}}，而不是朴素地 \hyperlink{18026893834387542681}{\texttt{push!}} 每一个元素到 \texttt{Vector\{Any\}}：




\begin{minted}{jlcon}
julia> collect(Squares(4))
4-element Vector{Int64}:
  1
  4
  9
 16
\end{minted}



尽管大多时候我们都可以依赖一些通用的实现，但某些时候，如果我们知道一个更简单的算法，可以用其扩展具体方法。例如，计算平方和有公式，因此可以扩展出一个更高效的解法来替代通用方法：




\begin{minted}{jlcon}
julia> Base.sum(S::Squares) = (n = S.count; return n*(n+1)*(2n+1)÷6)

julia> sum(Squares(1803))
1955361914
\end{minted}



这种模式在 Julia Base 中很常见，一些必须实现的方法构成了一个小的集合，从而定义出一个非正式的接口，用于实现一些更加炫酷的操作。某些应用场景中，一些类型有更高效的算法，故可以扩展出额外的专用方法。



能以\emph{逆序}迭代集合也很有用，这可由 \hyperlink{12943296479800134710}{\texttt{Iterators.reverse(iterator)}} 迭代实现。但是，为了实际支持逆序迭代，迭代器类型 \texttt{T} 需要为 \texttt{Iterators.Reverse\{T\}} 实现 \texttt{iterate}。（给定 \texttt{r::Iterators.Reverse\{T\}}，类型 \texttt{T} 的底层迭代器是 \texttt{r.itr}。）在我们的 \texttt{Squares} 示例中，我们可以实现 \texttt{Iterators.Reverse\{Squares\}} 方法：




\begin{minted}{jlcon}
julia> Base.iterate(rS::Iterators.Reverse{Squares}, state=rS.itr.count) = state < 1 ? nothing : (state*state, state-1)

julia> collect(Iterators.reverse(Squares(4)))
4-element Vector{Int64}:
 16
  9
  4
  1
\end{minted}



\hypertarget{14566118977838625303}{}


\section{Indexing}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Methods to implement & Brief description \\
\hline
\texttt{getindex(X, i)} & \texttt{X[i]}, indexed element access \\
\hline
\texttt{setindex!(X, v, i)} & \texttt{X[i] = v}, indexed assignment \\
\hline
\texttt{firstindex(X)} & The first index, used in \texttt{X[begin]} \\
\hline
\texttt{lastindex(X)} & The last index, used in \texttt{X[end]} \\
\hline
\end{tabulary}

\end{table}



For the \texttt{Squares} iterable above, we can easily compute the \texttt{i}th element of the sequence by squaring it.  We can expose this as an indexing expression \texttt{S[i]}. To opt into this behavior, \texttt{Squares} simply needs to define \hyperlink{13720608614876840481}{\texttt{getindex}}:




\begin{minted}{jlcon}
julia> function Base.getindex(S::Squares, i::Int)
           1 <= i <= S.count || throw(BoundsError(S, i))
           return i*i
       end

julia> Squares(100)[23]
529
\end{minted}



另外，为了支持语法 \texttt{S[begin]} 和 \texttt{S[end]}，我们必须定义 \hyperlink{15780929618270241785}{\texttt{lastindex}} 来指定最后一个有效索引。建议也定义 \hyperlink{16943669671291374223}{\texttt{firstindex}} 来指定第一个有效索引：




\begin{minted}{jlcon}
julia> Base.firstindex(S::Squares) = 1

julia> Base.lastindex(S::Squares) = length(S)

julia> Squares(23)[end]
529
\end{minted}



对多维的 \texttt{begin}/\texttt{end}索引，例如，像是 \texttt{a[3, begin, 7]}，你应该定义 \texttt{firstindex(a, dim)} 和 \texttt{lastindex(a, dim)}（它们默认各自在 \texttt{axes(a, dim)} 上调用 \texttt{first}和\texttt{last}）



注意，上面\emph{只}定义了一个整数索引的 \hyperlink{13720608614876840481}{\texttt{getindex}} 方法，用除一个整数之外的其它东西索引会抛出\hyperlink{68769522931907606}{\texttt{MethodError}}，因为现在还没有匹配的方法。为了支持 \texttt{Int} 的范围或向量索引，必须另外写一个方法：




\begin{minted}{jlcon}
julia> Base.getindex(S::Squares, i::Number) = S[convert(Int, i)]

julia> Base.getindex(S::Squares, I) = [S[i] for i in I]

julia> Squares(10)[[3,4.,5]]
3-element Vector{Int64}:
  9
 16
 25
\end{minted}



虽然这开始支持更多\hyperlink{16717190941363337071}{某些内置类型支持的索引操作}，但仍然有很多行为不支持。因为我们为 \texttt{Squares} 序列所添加的行为，它开始看起来越来越像向量。我们可以正式定义其为 \hyperlink{6514416309183787338}{\texttt{AbstractArray}} 的子类型，而不是自己定义所有这些行为。



\hypertarget{522338241536202486}{}


\section{抽象数组}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
需要实现的方法 &  & 简短描述 \\
\hline
\texttt{size(A)} &  & 返回包含 \texttt{A} 各维度大小的元组 \\
\hline
\texttt{getindex(A, i::Int)} &  & （若为 \texttt{IndexLinear}）线性标量索引 \\
\hline
\texttt{getindex(A, I::Vararg\{Int, N\})} &  & （若为 \texttt{IndexCartesian}，其中 \texttt{N = ndims(A)}）N 维标量索引 \\
\hline
\texttt{setindex!(A, v, i::Int)} &  & （若为 \texttt{IndexLinear}）线性索引元素赋值 \\
\hline
\texttt{setindex!(A, v, I::Vararg\{Int, N\})} &  & （若为 \texttt{IndexCartesian}，其中 \texttt{N = ndims(A)}）N 维标量索引元素赋值 \\
\hline
\textbf{可选方法} & \textbf{默认定义} & \textbf{简短描述} \\
\hline
\texttt{IndexStyle(::Type)} & \texttt{IndexCartesian()} & 返回 \texttt{IndexLinear()} 或 \texttt{IndexCartesian()}。请参阅下文描述。 \\
\hline
\texttt{getindex(A, I...)} & 基于标量 \texttt{getindex} 定义 & \hyperlink{16717190941363337071}{多维非标量索引} \\
\hline
\texttt{setindex!(A, X, I...)} & 基于标量 \texttt{setindex!} 定义 & \hyperlink{16717190941363337071}{多维非标量索引元素赋值} \\
\hline
\texttt{iterate} & 基于标量 \texttt{getindex} 定义 & Iteration \\
\hline
\texttt{length(A)} & \texttt{prod(size(A))} & 元素数 \\
\hline
\texttt{similar(A)} & \texttt{similar(A, eltype(A), size(A))} & 返回具有相同形状和元素类型的可变数组 \\
\hline
\texttt{similar(A, ::Type\{S\})} & \texttt{similar(A, S, size(A))} & 返回具有相同形状和指定元素类型的可变数组 \\
\hline
\texttt{similar(A, dims::Dims)} & \texttt{similar(A, eltype(A), dims)} & 返回具有相同元素类型和大小为 \emph{dims} 的可变数组 \\
\hline
\texttt{similar(A, ::Type\{S\}, dims::Dims)} & \texttt{Array\{S\}(undef, dims)} & 返回具有指定元素类型及大小的可变数组 \\
\hline
\textbf{不遵循惯例的索引} & \textbf{默认定义} & \textbf{简短描述} \\
\hline
\texttt{axes(A)} & \texttt{map(OneTo, size(A))} & 返回有效索引的 \texttt{AbstractUnitRange\{<:Integer\}} \\
\hline
\texttt{similar(A, ::Type\{S\}, inds)} & \texttt{similar(A, S, Base.to\_shape(inds))} & 返回使用特殊索引 \texttt{inds} 的可变数组（详见下文） \\
\hline
\texttt{similar(T::Union\{Type,Function\}, inds)} & \texttt{T(Base.to\_shape(inds))} & 返回类似于 \texttt{T} 的使用特殊索引 \texttt{inds} 的数组（详见下文） \\
\hline
\end{tabulary}

\end{table}



如果一个类型被定义为 \texttt{AbstractArray} 的子类型，那它就继承了一大堆丰富的行为，包括构建在单元素访问之上的迭代和多维索引。有关更多支持的方法，请参阅文档 \hyperlink{16720099245556932994}{多维数组} 及 \hyperlink{3951748617092839742}{Julia Base}。



定义 \texttt{AbstractArray} 子类型的关键部分是 \hyperlink{7782790551324367092}{\texttt{IndexStyle}}。由于索引是数组的重要部分且经常出现在 hot loops 中，使索引和索引赋值尽可能高效非常重要。数组数据结构通常以两种方式定义：要么仅使用一个索引（即线性索引）来最高效地访问其元素，要么实际上使用由各个维度确定的索引访问其元素。这两种方式被 Julia 标记为 \texttt{IndexLinear()} 和 \texttt{IndexCartesian()}。把线性索引转换为多重索引下标通常代价高昂，因此这提供了基于 traits 机制，以便能为所有矩阵类型提供高效的通用代码。



此区别决定了该类型必须定义的标量索引方法。\texttt{IndexLinear()} 很简单：只需定义 \texttt{getindex(A::ArrayType, i::Int)}。当数组后用多维索引集进行索引时，回退 \texttt{getindex(A::AbstractArray, I...)()} 高效地将该索引转换为线性索引，然后调用上述方法。另一方面，\texttt{IndexCartesian()} 数组需要为每个支持的、使用 \texttt{ndims(A)} 个 \texttt{Int} 索引的维度定义方法。例如，\texttt{SparseArrays} 标准库里的 \hyperlink{15099699527958384292}{\texttt{SparseMatrixCSC}} 只支持二维，所以它只定义了 \texttt{getindex(A::SparseMatrixCSC, i::Int, j::Int)}。\hyperlink{1309244355901386657}{\texttt{setindex!}} 也是如此。



回到上面的平方数序列，我们可以将它定义为 \texttt{AbstractArray\{Int, 1\}} 的子类型：




\begin{minted}{jlcon}
julia> struct SquaresVector <: AbstractArray{Int, 1}
           count::Int
       end

julia> Base.size(S::SquaresVector) = (S.count,)

julia> Base.IndexStyle(::Type{<:SquaresVector}) = IndexLinear()

julia> Base.getindex(S::SquaresVector, i::Int) = i*i
\end{minted}



请注意，指定 \texttt{AbstractArray} 的两个参数非常重要；第一个参数定义了 \hyperlink{6396209842929672718}{\texttt{eltype}}，第二个则定义了 \hyperlink{1688406579181746010}{\texttt{ndims}}。该超类型和这三个方法就足以使 \texttt{SquaresVector} 变成一个可迭代、可索引且功能齐全的数组：




\begin{minted}{jlcon}
julia> s = SquaresVector(4)
4-element SquaresVector:
  1
  4
  9
 16

julia> s[s .> 8]
2-element Vector{Int64}:
  9
 16

julia> s + s
4-element Vector{Int64}:
  2
  8
 18
 32

julia> sin.(s)
4-element Vector{Float64}:
  0.8414709848078965
 -0.7568024953079282
  0.4121184852417566
 -0.2879033166650653
\end{minted}



作为一个更复杂的例子，让我们在 \hyperlink{3089397136845322041}{\texttt{Dict}} 之上定义自己的玩具性质的 N 维稀疏数组类型。




\begin{minted}{jlcon}
julia> struct SparseArray{T,N} <: AbstractArray{T,N}
           data::Dict{NTuple{N,Int}, T}
           dims::NTuple{N,Int}
       end

julia> SparseArray(::Type{T}, dims::Int...) where {T} = SparseArray(T, dims);

julia> SparseArray(::Type{T}, dims::NTuple{N,Int}) where {T,N} = SparseArray{T,N}(Dict{NTuple{N,Int}, T}(), dims);

julia> Base.size(A::SparseArray) = A.dims

julia> Base.similar(A::SparseArray, ::Type{T}, dims::Dims) where {T} = SparseArray(T, dims)

julia> Base.getindex(A::SparseArray{T,N}, I::Vararg{Int,N}) where {T,N} = get(A.data, I, zero(T))

julia> Base.setindex!(A::SparseArray{T,N}, v, I::Vararg{Int,N}) where {T,N} = (A.data[I] = v)
\end{minted}



请注意，这是个 \texttt{IndexCartesian} 数组，因此我们必须在数组的维度上手动定义 \hyperlink{13720608614876840481}{\texttt{getindex}} 和 \hyperlink{1309244355901386657}{\texttt{setindex!}}。与 \texttt{SquaresVector} 不同，我们可以定义 \hyperlink{1309244355901386657}{\texttt{setindex!}}，这样便能更改数组：




\begin{minted}{jlcon}
julia> A = SparseArray(Float64, 3, 3)
3×3 SparseArray{Float64, 2}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0

julia> fill!(A, 2)
3×3 SparseArray{Float64, 2}:
 2.0  2.0  2.0
 2.0  2.0  2.0
 2.0  2.0  2.0

julia> A[:] = 1:length(A); A
3×3 SparseArray{Float64, 2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
 3.0  6.0  9.0
\end{minted}



索引 \texttt{AbstractArray} 的结果本身可以是数组（例如，在使用 \texttt{AbstractRange} 时）。\texttt{AbstractArray} 回退方法使用 \hyperlink{15525808546723795098}{\texttt{similar}} 来分配具有适当大小和元素类型的 \texttt{Array}，该数组使用上述的基本索引方法填充。但是，在实现数组封装器时，你通常希望也封装结果：




\begin{minted}{jlcon}
julia> A[1:2,:]
2×3 SparseArray{Float64, 2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
\end{minted}



在此例中，创建合适的封装数组通过定义 \texttt{Base.similar(A::SparseArray, ::Type\{T\}, dims::Dims) where T} 来实现。（请注意，虽然 \texttt{similar} 支持 1 参数和 2 参数形式，但在大多数情况下，你只需要专门定义 3 参数形式。）为此，\texttt{SparseArray} 是可变的（支持 \texttt{setindex!}）便很重要。为 \texttt{SparseArray} 定义 \texttt{similar}、\texttt{getindex} 和 \texttt{setindex!} 也使得该数组能够 \hyperlink{15665284441316555522}{\texttt{copy}} 。




\begin{minted}{jlcon}
julia> copy(A)
3×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
 3.0  6.0  9.0
\end{minted}



除了上面的所有可迭代和可索引方法之外，这些类型还能相互交互，并使用在 Julia Base 中为 \texttt{AbstractArray} 定义的大多数方法：




\begin{minted}{jlcon}
julia> A[SquaresVector(3)]
3-element SparseArray{Float64, 1}:
 1.0
 4.0
 9.0

julia> sum(A)
45.0
\end{minted}



如果要定义允许非传统索引（索引以 1 之外的数字开始）的数组类型，你应该专门指定 \hyperlink{7074821531920287868}{\texttt{axes}}。你也应该专门指定 \hyperlink{15525808546723795098}{\texttt{similar}}，以便 \texttt{dims} 参数（通常是大小为 \texttt{Dims} 的元组）可以接收 \texttt{AbstractUnitRange} 对象，它也许是你自己设计的 range 类型 \texttt{Ind}。有关更多信息，请参阅\hyperlink{1238988360302116626}{使用自定义索引的数组}。



\hypertarget{2800090857858949975}{}


\section{等步长数组}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
实习方法 &  & 简要描述 \\
\hline
\texttt{strides(A)} &  & 返回每个维度中相邻元素之间的内存距离（以内存元素数量的形式）组成的元组。如果 \texttt{A} 是 \texttt{AbstractArray\{T,0\}}，这应该返回空元组。 \\
\hline
\texttt{Base.unsafe\_convert(::Type\{Ptr\{T\}\}, A)} &  & 返回数组的本地内存地址 \\
\hline
\texttt{Base.elsize(::Type\{<:A\})} &  & 返回数组中连续元素的步长 \\
\hline
\textbf{可选方法} & \textbf{默认定义} & \textbf{简要描述} \\
\hline
\texttt{stride(A, i::Int)} & \texttt{strides(A)[i]} & 返回维度 i（译注：原文为 k）上相邻元素之间的内存距离（以内存元素数量的形式）。 \\
\hline
\end{tabulary}

\end{table}



等步长数组是 \texttt{AbstractArray} 的子类型，其条目以固定步长储存在内存中。如果数组的元素类型与 BLAS 兼容，则 strided 数组可以利用 BLAS 和 LAPACK 例程来实现更高效的线性代数例程。用户定义的 strided 数组的典型示例是把标准 \texttt{Array} 用附加结构进行封装的数组。



警告：如果底层存储实际上不是 strided，则不要实现这些方法，因为这可能导致错误的结果或段错误。



下面是一些示例，用来演示哪些数组类型是 strided 数组，哪些不是：




\begin{minted}{julia}
1:5   # not strided (there is no storage associated with this array.)
Vector(1:5)  # is strided with strides (1,)
A = [1 5; 2 6; 3 7; 4 8]  # is strided with strides (1,4)
V = view(A, 1:2, :)   # is strided with strides (1,4)
V = view(A, 1:2:3, 1:2)   # is strided with strides (2,4)
V = view(A, [1,2,4], :)   # is not strided, as the spacing between rows is not fixed.
\end{minted}



\hypertarget{8927705294232715192}{}


\section{自定义广播}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
需要实现的方法 & 简短描述 \\
\hline
\texttt{Base.BroadcastStyle(::Type\{SrcType\}) = SrcStyle()} & \texttt{SrcType} 的广播行为 \\
\hline
\texttt{Base.similar(bc::Broadcasted\{DestStyle\}, ::Type\{ElType\})} & 输出容器的分配 \\
\hline
\textbf{可选方法} &  \\
\hline
\texttt{Base.BroadcastStyle(::Style1, ::Style2) = Style12()} & 混合广播风格的优先级规则 \\
\hline
\texttt{Base.axes(x)} & 用于广播的 \texttt{x} 的索引的声明（默认为 \hyperlink{7074821531920287868}{\texttt{axes(x)}}） \\
\hline
\texttt{Base.broadcastable(x)} & 将 \texttt{x} 转换为一个具有 \texttt{axes} 且支持索引的对象 \\
\hline
\textbf{绕过默认机制} &  \\
\hline
\texttt{Base.copy(bc::Broadcasted\{DestStyle\})} & \texttt{broadcast} 的自定义实现 \\
\hline
\texttt{Base.copyto!(dest, bc::Broadcasted\{DestStyle\})} & 专门针对 \texttt{DestStyle} 的自定义 \texttt{broadcast!} 实现 \\
\hline
\texttt{Base.copyto!(dest::DestType, bc::Broadcasted\{Nothing\})} & 专门针对 \texttt{DestStyle} 的自定义 \texttt{broadcast!} 实现 \\
\hline
\texttt{Base.Broadcast.broadcasted(f, args...)} & 覆盖融合表达式中的默认惰性行为 \\
\hline
\texttt{Base.Broadcast.instantiate(bc::Broadcasted\{DestStyle\})} & 覆盖惰性广播的 axes 的计算 \\
\hline
\end{tabulary}

\end{table}



\href{@ref}{广播}可由 \texttt{broadcast} 或 \texttt{broadcast!} 的显式调用、或者像 \texttt{A .+ b} 或 \texttt{f.(x, y)} 这样的「点」操作隐式触发。任何具有 \hyperlink{7074821531920287868}{\texttt{axes}} 且支持索引的对象都可作为参数参与广播，默认情况下，广播结果储存在 \texttt{Array} 中。这个基本框架可通过三个主要方式扩展：



\begin{itemize}
\item 确保所有参数都支持广播


\item 为给定参数集选择合适的输出数组


\item 为给定参数集选择高效的实现

\end{itemize}


不是所有类型都支持 \texttt{axes} 和索引，但许多类型便于支持广播。\hyperlink{3229213625072672556}{\texttt{Base.broadcastable}} 函数会在每个广播参数上调用，它能返回与广播参数不同的支持 \texttt{axes} 和索引的对象。默认情况下，对于所有 \texttt{AbstractArray} 和 \texttt{Number} 来说这是 identity 函数——因为它们已经支持 \texttt{axes} 和索引了。少数其它类型（包括但不限于类型本身、函数、像 \hyperlink{14596725676261444434}{\texttt{missing}} 和 \hyperlink{9331422207248206047}{\texttt{nothing}} 这样的特殊单态类型以及日期）为了能被广播，\texttt{Base.broadcastable} 会返回封装在 \texttt{Ref} 的参数来充当 0 维「标量」。自定义类型可以类似地指定 \texttt{Base.broadcastable} 来定义其形状，但是它们应当遵循 \texttt{collect(Base.broadcastable(x)) == collect(x)} 的约定。一个值得注意的例外是 \texttt{AbstractString}；字符串是个特例，为了能被广播其表现为标量，尽管它们是其字符的可迭代集合（详见 \href{@id man-strings}{字符串}）。



接下来的两个步骤（选择输出数组和实现）依赖于如何确定给定参数集的唯一解。广播必须接受其参数的所有不同类型，并把它们折叠到一个输出数组和实现。广播称此唯一解为“风格”。每个可广播对象都有自己的首选风格，并使用类似于类型提升的系统将这些风格组合成一个唯一解——“目标风格”。



\hypertarget{5448969838863032993}{}


\subsection{广播风格}



抽象类型 \texttt{Base.BroadcastStyle} 派生了所有的广播风格。其在用作函数时有两种可能的形式，分别为一元形式（单参数）和二元形式。使用一元形式表明你打算实现特定的广播行为和/或输出类型，并且不希望依赖于默认的回退 \hyperlink{5203521679854231580}{\texttt{Broadcast.DefaultArrayStyle}}。



为了覆盖这些默认值，你可以为对象自定义 \texttt{BroadcastStyle}：




\begin{minted}{julia}
struct MyStyle <: Broadcast.BroadcastStyle end
Base.BroadcastStyle(::Type{<:MyType}) = MyStyle()
\end{minted}



在某些情况下，无需定义 \texttt{MyStyle} 也许很方便，在这些情况下，你可以利用一个通用的广播封装器：



\begin{itemize}
\item \texttt{Base.BroadcastStyle(::Type\{<:MyType\}) = Broadcast.Style\{MyType\}()} 可用于任意类型。


\item 如果 \texttt{MyType} 是一个 \texttt{AbstractArray}，首选是 \texttt{Base.BroadcastStyle(::Type\{<:MyType\}) = Broadcast.ArrayStyle\{MyType\}()}。


\item 对于只支持某个具体维度的 \texttt{AbstractArrays}，请创建 \texttt{Broadcast.AbstractArrayStyle\{N\}} 的子类型（请参阅下文）。

\end{itemize}


当你的广播操作涉及多个参数，各个广播风格将合并，来确定唯一一个 \texttt{DestStyle} 以控制输出容器的类型。有关更多详细信息，请参阅\hyperlink{17567878480973592299}{下文}。



\hypertarget{4710253435053989143}{}


\subsection{选择合适的输出数组}



每个广播操作都会计算广播风格以便支持派发和专门化。结果数组的实际分配由 \texttt{similar} 处理，其使用 Broadcasted 对象作为其第一个参数。




\begin{minted}{julia}
Base.similar(bc::Broadcasted{DestStyle}, ::Type{ElType})
\end{minted}



回退定义是




\begin{minted}{julia}
similar(bc::Broadcasted{DefaultArrayStyle{N}}, ::Type{ElType}) where {N,ElType} =
    similar(Array{ElType}, axes(bc))
\end{minted}



但是，如果需要，你可以专门化任何或所有这些参数。最后的参数 \texttt{bc} 是（还可能是融合的）广播操作的惰性表示，即 \texttt{Broadcasted} 对象。出于这些目的，该封装器中最重要的字段是 \texttt{f} 和 \texttt{args}，分别描述函数和参数列表。请注意，参数列表可以——并且经常——包含其它嵌套的 \texttt{Broadcasted} 封装器。



举个完整的例子，假设你创建了类型 \texttt{ArrayAndChar}，该类型存储一个数组和单个字符：




\begin{minted}{julia}
struct ArrayAndChar{T,N} <: AbstractArray{T,N}
    data::Array{T,N}
    char::Char
end
Base.size(A::ArrayAndChar) = size(A.data)
Base.getindex(A::ArrayAndChar{T,N}, inds::Vararg{Int,N}) where {T,N} = A.data[inds...]
Base.setindex!(A::ArrayAndChar{T,N}, val, inds::Vararg{Int,N}) where {T,N} = A.data[inds...] = val
Base.showarg(io::IO, A::ArrayAndChar, toplevel) = print(io, typeof(A), " with char '", A.char, "'")
\end{minted}



你可能想要广播保留“元数据”\texttt{char}。为此，我们首先定义




\begin{minted}{julia}
Base.BroadcastStyle(::Type{<:ArrayAndChar}) = Broadcast.ArrayStyle{ArrayAndChar}()
\end{minted}



这意味着我们还必须定义相应的 \texttt{similar} 方法：




\begin{minted}{julia}
function Base.similar(bc::Broadcast.Broadcasted{Broadcast.ArrayStyle{ArrayAndChar}}, ::Type{ElType}) where ElType
    # Scan the inputs for the ArrayAndChar:
    A = find_aac(bc)
    # Use the char field of A to create the output
    ArrayAndChar(similar(Array{ElType}, axes(bc)), A.char)
end

"`A = find_aac(As)` returns the first ArrayAndChar among the arguments."
find_aac(bc::Base.Broadcast.Broadcasted) = find_aac(bc.args)
find_aac(args::Tuple) = find_aac(find_aac(args[1]), Base.tail(args))
find_aac(x) = x
find_aac(::Tuple{}) = nothing
find_aac(a::ArrayAndChar, rest) = a
find_aac(::Any, rest) = find_aac(rest)
\end{minted}



在这些定义中，可以得到以下行为：




\begin{minted}{jlcon}
julia> a = ArrayAndChar([1 2; 3 4], 'x')
2×2 ArrayAndChar{Int64, 2} with char 'x':
 1  2
 3  4

julia> a .+ 1
2×2 ArrayAndChar{Int64, 2} with char 'x':
 2  3
 4  5

julia> a .+ [5,10]
2×2 ArrayAndChar{Int64, 2} with char 'x':
  6   7
 13  14
\end{minted}



\hypertarget{5201970122303370123}{}


\subsection{使用自定义实现扩展广播}



一般来说，广播操作由一个惰性 \texttt{Broadcasted} 容器表示，该容器保存要应用的函数及其参数。这些参数可能本身是嵌套得更深的 \texttt{Broadcasted} 容器，并一起形成了一个待求值的大型表达式树。嵌套的 \texttt{Broadcasted} 容器树可由隐式的点语法直接构造；例如，\texttt{5 .+ 2.*x} 由 \texttt{Broadcasted(+, 5, Broadcasted(*, 2, x))} 暂时表示。这对于用户是不可见的，因为它是通过调用 \texttt{copy} 立即实现的，但是此容器为自定义类型的作者提供了广播可扩展性的基础。然后，内置的广播机制将根据参数确定结果的类型和大小，为它分配内存，并最终通过默认的 \texttt{copyto!(::AbstractArray, ::Broadcasted)} 方法将 \texttt{Broadcasted} 对象复制到其中。内置的回退 \texttt{broadcast} 和 \texttt{broadcast!} 方法类似地构造操作的暂时 \texttt{Broadcasted} 表示，因此它们共享相同的代码路径。这便允许自定义的数组实现通过提供它们自己的专门化 \texttt{copyto!} 来定义和优化广播。这再次由计算后的广播风格确定。此广播风格在广播操作中非常重要，以至于它被存储为 \texttt{Broadcasted} 类型的第一个类型参数，且允许派发和专门化。



对于某些类型，跨越层层嵌套的广播的「融合」操作无法实现，或者无法更高效地逐步完成。在这种情况下，你可能需要或者想要求值 \texttt{x .* (x .+ 1)}，就好像该式已被编写成 \texttt{broadcast(*, x, broadcast(+, x, 1))}，其中内部广播操作会在处理外部广播操作前进行求值。这种直接的操作以有点间接的方式得到直接支持；Julia 不会直接构造 \texttt{Broadcasted} 对象，而会将 待融合的表达式 \texttt{x .* (x .+ 1)} 降低为 \texttt{Broadcast.broadcasted(*, x, Broadcast.broadcasted(+, x, 1))}。现在，默认情况下，\texttt{broadcasted} 只会调用 \texttt{Broadcasted} 构造函数来创建待融合表达式树的惰性表示，但是你可以选择为函数和参数的特定组合覆盖它。



举个例子，内置的 \texttt{AbstractRange} 对象使用此机制优化广播表达式的片段，这些表达式片段可以只根据 start、step 和 length（或 stop）直接进行求值，而无需计算每个元素。与所有其它机制一样，\texttt{broadcasted} 也会计算并暴露其参数的组合广播风格，所以你可以为广播风格、函数和参数的任意组合专门化 \texttt{broadcasted(::DestStyle, f, args...)}，而不是专门化 \texttt{broadcasted(f, args...)}。



例如，以下定义支持 range 的负运算：




\begin{minted}{julia}
broadcasted(::DefaultArrayStyle{1}, ::typeof(-), r::OrdinalRange) = range(-first(r), step=-step(r), length=length(r))
\end{minted}



\hypertarget{13437862742050583795}{}


\subsection{扩展 in-place 广播}



In-place 广播可通过定义合适的 \texttt{copyto!(dest, bc::Broadcasted)} 方法来支持。由于你可能想要专门化 \texttt{dest} 或 \texttt{bc} 的特定子类型，为了避免包之间的歧义，我们建议采用以下约定。



如果你想要专门化特定的广播风格 \texttt{DestStyle}，请为其定义一个方法




\begin{minted}{julia}
copyto!(dest, bc::Broadcasted{DestStyle})
\end{minted}



你可选择使用此形式，如果使用，你还可以专门化 \texttt{dest} 的类型。



如果你想专门化目标类型 \texttt{DestType} 而不专门化 \texttt{DestStyle}，那么你应该定义一个带有以下签名的方法：




\begin{minted}{julia}
copyto!(dest::DestType, bc::Broadcasted{Nothing})
\end{minted}



这利用了 \texttt{copyto!} 的回退实现，它将该封装器转换为一个 \texttt{Broadcasted\{Nothing\}} 对象。因此，专门化 \texttt{DestType} 的方法优先级低于专门化 \texttt{DestStyle} 的方法。



同样，你可以使用 \texttt{copy(::Broadcasted)} 方法完全覆盖 out-of-place 广播。



\hypertarget{2171470859232296256}{}


\subsubsection{使用 \texttt{Broadcasted} 对象}



当然，为了实现这样的 \texttt{copy} 或 \texttt{copyto!} 方法，你必须使用 \texttt{Broadcasted} 封装器来计算每个元素。这主要有两种方式：



\begin{itemize}
\item \texttt{Broadcast.flatten} 将可能的嵌套操作重新计算为单个函数并平铺参数列表。你自己负责实现广播形状规则，但这在有限的情况下可能会有所帮助。


\item 迭代 \texttt{axes(::Broadcasted)} 的 \texttt{CartesianIndices} 并使用所生成的 \texttt{CartesianIndex} 对象的索引来计算结果。

\end{itemize}


\hypertarget{13308248870533973226}{}


\subsection{编写二元广播规则}



广播风格的优先级规则由二元 \texttt{BroadcastStyle} 调用定义：




\begin{minted}{julia}
Base.BroadcastStyle(::Style1, ::Style2) = Style12()
\end{minted}



其中，\texttt{Style12} 是你要为输出所选择的 \texttt{BroadcastStyle}，所涉及的参数具有 \texttt{Style1} 及 \texttt{Style2}。例如，




\begin{minted}{julia}
Base.BroadcastStyle(::Broadcast.Style{Tuple}, ::Broadcast.AbstractArrayStyle{0}) = Broadcast.Style{Tuple}()
\end{minted}



表示 \texttt{Tuple}「胜过」零维数组（输出容器将是元组）。值得注意的是，你不需要（也不应该）为此调用的两个参数顺序下定义；无论用户提供的以何种顺序提供参数，定义一个就够了。



对于 \texttt{AbstractArray} 类型，定义 \texttt{BroadcastStyle} 将取代回退选择 \hyperlink{5203521679854231580}{\texttt{Broadcast.DefaultArrayStyle}}。\texttt{DefaultArrayStyle} 及其抽象超类型 \texttt{AbstractArrayStyle} 将维度存储为类型参数，以支持具有固定维度需求的特定数组类型。



由于以下方法，\texttt{DefaultArrayStyle}「输给」任何其它已定义的 \texttt{AbstractArrayStyle}：




\begin{minted}{julia}
BroadcastStyle(a::AbstractArrayStyle{Any}, ::DefaultArrayStyle) = a
BroadcastStyle(a::AbstractArrayStyle{N}, ::DefaultArrayStyle{N}) where N = a
BroadcastStyle(a::AbstractArrayStyle{M}, ::DefaultArrayStyle{N}) where {M,N} =
    typeof(a)(Val(max(M, N)))
\end{minted}



除非你想要为两个或多个非 \texttt{DefaultArrayStyle} 的类型建立优先级，否则不需要编写二元 \texttt{BroadcastStyle} 规则。



如果你的数组类型确实有固定的维度需求，那么你应该定义一个 \texttt{AbstractArrayStyle} 的子类型。例如，稀疏数组的代码中有以下定义：




\begin{minted}{julia}
struct SparseVecStyle <: Broadcast.AbstractArrayStyle{1} end
struct SparseMatStyle <: Broadcast.AbstractArrayStyle{2} end
Base.BroadcastStyle(::Type{<:SparseVector}) = SparseVecStyle()
Base.BroadcastStyle(::Type{<:SparseMatrixCSC}) = SparseMatStyle()
\end{minted}



每当你定义一个 \texttt{AbstractArrayStyle} 的子类型，你还需要定义用于组合维度的规则，这通过为你的广播风格创建带有一个 \texttt{Val(N)} 参数的构造函数。例如：




\begin{minted}{julia}
SparseVecStyle(::Val{0}) = SparseVecStyle()
SparseVecStyle(::Val{1}) = SparseVecStyle()
SparseVecStyle(::Val{2}) = SparseMatStyle()
SparseVecStyle(::Val{N}) where N = Broadcast.DefaultArrayStyle{N}()
\end{minted}



这些规则表明 \texttt{SparseVecStyle} 与 0 维或 1 维数组的组合会产生另一个 \texttt{SparseVecStyle}，与 2 维数组的组合会产生 \texttt{SparseMatStyle}，而与维度更高的数组则回退到任意维密集矩阵的框架中。这些规则允许广播为产生一维或二维输出的操作保持其稀疏表示，但为任何其它维度生成 \texttt{Array}。



\hypertarget{10438697863683890874}{}


\chapter{模块}



Julia 中的模块有助于将代码组织成连贯的部分。 它们在语法上以 \texttt{module Name ... end} 界定，并具有以下特点：



\begin{itemize}
\item[1. ] 模块是独立的命名空间，每个都引入了一个新的全局作用域。 这很有用，因为它允许对不同的函数或全局变量使用相同的名称而不会发生冲突，只要它们在不同的模块中即可。


\item[2. ] 模块具有用于命名空间管理的工具：每个模块定义一组它\texttt{export}的名称，并且可以使用 \texttt{using} 和 \texttt{import} 从其他模块导入名称（我们将在下面解释这些）。


\item[3. ] 模块可以预编译以加快加载速度，并包含用于运行时初始化的代码。

\end{itemize}


通常，在较大的 Julia 包中，你会看到模块的代码组织成文件，例如




\begin{minted}{julia}
module SomeModule

# export, using, import statements are usually here; we discuss these below

include("file1.jl")
include("file2.jl")

end
\end{minted}



文件和文件名大多与模块无关； 模块仅与模块表达式相关联。 每个模块可以有多个文件，每个文件可以有多个模块。 \texttt{include} 的行为就像在包含模块的全局作用域内执行源文件的内容一样。 在本章中，我们使用简短和简化的示例，因此我们不会使用\texttt{include}。



我们推荐不要缩进模块的主体，因为这通常会导致整个文件被缩进。 此外，通常使用 \texttt{UpperCamelCase} 作为模块名称（就像类型一样），并在适用时使用复数形式，特别是如果模块包含类似命名的标识符，以避免名称冲突。 例如，




\begin{minted}{julia}
module FastThings

struct FastThing
    ...
end

end
\end{minted}



\hypertarget{7538295366457379059}{}


\section{命名空间管理}



命名空间管理是指语言提供的设施，用于使模块中的名称在其他模块中可用。 我们在下面详细讨论相关的概念和功能。



\hypertarget{14172365012073631390}{}


\subsection{合格的名称}



全局作用域内的函数、变量和类型的名称，如\texttt{sin}、\texttt{ARGS}和\texttt{UnitRange}始终属于一个模块，称为\emph{母模块}，例如，可以与\hyperlink{10164029261176394442}{\texttt{parentmodule}}交互来找到该模块




\begin{minted}{jlcon}
julia> parentmodule(UnitRange)
Base
\end{minted}



也可以通过在它们的模块前面加上前缀来引用它们的父模块之外的这些名称，例如\texttt{Base.UnitRange}。 这称为\emph{限定名称}。 父模块可以使用像\texttt{Base.Math.sin}这样的子模块链来访问，其中\texttt{Base.Math}被称为\emph{模块路径}。 由于句法歧义，限定只包含符号的名称，例如运算符，需要插入冒号，例如 \texttt{Base.:+}。 少数运算符还需要括号，例如 \texttt{Base.:(==)}。



如果一个名称是限定的，那么它总是\emph{可访问的}，在函数的情况下，它也可以通过使用限定的名称作为函数名称来添加方法。



在一个模块中，一个变量名可以通过将其声明 \texttt{global x} 不赋值而“保留”。 这可以防止在加载时间后初始化的全局变量的名称冲突。 语法\texttt{M.x = y} 不适用于在另一个模块中分配一个全局变量； 全局分配需要在模块本地进行操作。



\hypertarget{2370835204364650501}{}


\subsection{导出列表}



名称（指函数、类型、全局变量和常量）可以通过 \texttt{export} 添加到模块的 *导出列表 *。 通常，它们位于或靠近模块定义的顶部，以便源代码的读者可以轻松找到它们，如




\begin{minted}{julia}
module NiceStuff

export nice, DOG

struct Dog end      # singleton type, not exported

const DOG = Dog()   # named instance, exported

nice(x) = "nice $x" # function, exported

end
\end{minted}



但这只是一个风格建议——一个模块可以在任意位置有多个 \texttt{export} 语句。



导出构成 API（应用程序接口）一部分的名称是很常见的。 在上面的代码中，导出列表建议用户应该使用\texttt{nice}和\texttt{DOG}。 然而，由于限定名称总是使标识符可访问，这只是组织 API 的一个选项：与其他语言不同，Julia 没有真正隐藏模块内部的功能。



此外，某些模块根本不导出名称。 这通常是因为他们的 API 中使用常用词（例如\texttt{derivative}），这很容易与其他模块的导出列表发生冲突。 我们将在下面看到如何管理名称冲突。



\hypertarget{11570243363614655937}{}


\subsection{单独使用\texttt{using}和\texttt{import}}



加载模块最常见的方式可能是\texttt{using ModuleName}。 这 \hyperlink{11949095373261797528}{加载} 与 \texttt{ModuleName} 关联的代码，并引入



\begin{itemize}
\item[1. ] 模块名称


\item[2. ] 和导出列表的元素到周围的全局命名空间中。

\end{itemize}


严格来说，声明 \texttt{using ModuleName} 意味着一个名为 \texttt{ModuleName} 的模块可用于根据需要解析名称。 当遇到当前模块中没有定义的全局变量时，系统会在\texttt{ModuleName}导出的变量中查找，找到就使用。 这意味着当前模块中该全局变量的所有使用都将解析为\texttt{ModuleName}中该变量的定义。



继续我们的例子，




\begin{minted}{julia}
using NiceStuff
\end{minted}



将加载上面的代码，使 \texttt{NiceStuff}（模块名称）、\texttt{DOG} 和 \texttt{nice} 可用。 \texttt{Dog} 不在导出列表中，但如果名称被模块路径（这里只是模块名称）限定为 \texttt{NiceStuff.Dog}，则可以访问它。



重要的是，\textbf{导出列表只在\texttt{using ModuleName} 的形式下起作用}。



相反，




\begin{minted}{julia}
import NiceStuff
\end{minted}



\emph{仅}将模块名称带入作用域。 用户需要使用 \texttt{NiceStuff.DOG}、\texttt{NiceStuff.Dog} 和 \texttt{NiceStuff.nice} 来访问其内容。 通常，当用户想要保持命名空间干净时，在上下文中使用 \texttt{import ModuleName}。 正如我们将在下一节中看到的，\texttt{import NiceStuff} 等同于 \texttt{using NiceStuff: NiceStuff}。



你可以用逗号分隔符来组合相同类型的多个\texttt{using}和\texttt{import}语句，例如：




\begin{minted}{julia}
using LinearAlgebra, Statistics
\end{minted}



\hypertarget{54362131503587802}{}


\subsection{具有特定标识符的\texttt{using} 和 \texttt{import} ，并添加方法}



当 \texttt{using ModuleName:} 或 \texttt{import ModuleName:} 后跟以逗号分隔的名称列表时，模块会被加载，但 \emph{只有那些特定的名称才会被语句带入命名空间}。 例如，




\begin{minted}{julia}
using NiceStuff: nice, DOG
\end{minted}



将导入名称\texttt{nice}和\texttt{DOG}。



重要的是，模块名称\texttt{NiceStuff} \emph{不会}出现在命名空间中。 如果要使其可访问，则必须明确列出它，如




\begin{minted}{julia}
using NiceStuff: nice, DOG, NiceStuff
\end{minted}



Julia有两种形式来表示似乎相同的内容，因为只有 \texttt{import ModuleName:f} 允许在 \emph{没有模块路径}的情况下向 \texttt{f} 添加方法。也就是说，以下示例将给出一个错误：




\begin{minted}{julia}
using NiceStuff: nice
struct Cat end
nice(::Cat) = "nice 😸"
\end{minted}



此错误可防止意外将方法添加到你仅打算使用的其他模块中的函数。



有两种方法可以解决这个问题。 你始终可以使用模块路径限定函数名称：




\begin{minted}{julia}
using NiceStuff
struct Cat end
NiceStuff.nice(::Cat) = "nice 😸"
\end{minted}



或者，你可以\texttt{import}特定的函数名称：




\begin{minted}{julia}
import NiceStuff: nice
struct Cat end
nice(::Cat) = "nice 😸"
\end{minted}



你选择哪一个取决于你的代码风格。第一种形式表明你正在向另一个模块中的函数添加一个方法（请记住，导入和方法定义可能在单独的文件中），而第二种形式较短，如果你定义了多个方法，这一点尤其方便。



一旦一个变量通过 \texttt{using} 或 \texttt{import} 引入，当前模块就不能创建同名的变量了。而且导入的变量是只读的，给全局变量赋值只能影响到由当前模块拥有的变量，否则会报错。



\hypertarget{18154480065808854921}{}


\subsection{用\texttt{as}来重命名}



由\texttt{import} 或\texttt{using} 引入作用域的标识符可以用关键字\texttt{as} 重命名。 这对于解决名称冲突以及缩短名称很有用。 例如，\texttt{Base} 导出函数名\texttt{read}，但CSV.jl 包也提供了\texttt{CSV.read}。 如果我们要多次调用 CSV 读取，删除 \texttt{CSV.} 限定符会很方便。 但是，我们指的是\texttt{Base.read}还是\texttt{CSV.read}是模棱两可的：




\begin{minted}{julia}
julia> read;

julia> import CSV: read
WARNING: ignoring conflicting import of CSV.read into Main
\end{minted}



重命名提供了一个解决方案：




\begin{minted}{julia}
julia> import CSV: read as rd
\end{minted}



导入的包本身也可以重命名：




\begin{minted}{julia}
import BenchmarkTools as BT
\end{minted}



\texttt{as} 仅在将单个标识符引入作用域时才与 \texttt{using} 一起使用。 例如，\texttt{using CSV: read as rd} 有效，但\texttt{using CSV as C} 无效，因为它对 \texttt{CSV} 中的所有导出名称进行操作。



\hypertarget{16794125395847682495}{}


\subsection{混合使用多个 \texttt{using} 和 \texttt{import} 语句}



当使用上述任何形式的多个 \texttt{using} 或 \texttt{import} 语句时，它们的效果将按照它们出现的顺序组合。 例如，




\begin{minted}{julia}
using NiceStuff         # exported names and the module name
import NiceStuff: nice  # allows adding methods to unqualified functions
\end{minted}



会将 \texttt{NiceStuff} 的所有导出名称和模块名称本身带入作用域，并且还允许向 \texttt{nice} 添加方法而不用模块名称作为前缀。



\hypertarget{1363363241812450828}{}


\subsection{处理名称冲突}



考虑两个（或更多）包导出相同名称的情况，如




\begin{minted}{julia}
module A
export f
f() = 1
end

module B
export f
f() = 2
end
\end{minted}



\texttt{using A, B} 语句有效，但是当你尝试调用 \texttt{f} 时，你会收到警告




\begin{minted}{julia}
WARNING: both B and A export "f"; uses of it in module Main must be qualified
ERROR: LoadError: UndefVarError: f not defined
\end{minted}



在这里，Julia 无法确定您指的是哪个 \texttt{f}，因此你必须做出选择。 常用的解决方法有以下几种：



\begin{itemize}
\item[1. ] 只需继续使用限定名称，如\texttt{A.f} 和\texttt{B.f}。 这使代码的读者可以清楚地了解上下文，特别是如果 \texttt{f} 恰好重合但在不同的包中具有不同的含义。 例如，\texttt{degree}在数学、自然科学和日常生活中有多种用途，这些含义应该分开。


\item[2. ] 使用上面的 \texttt{as} 关键字重命名一个或两个标识符，例如


\begin{minted}{julia}
using A: f as f
using B: f as g
\end{minted}

会使\texttt{B.f} 可用作\texttt{g}。 在这里，我们假设您之前没有使用 \texttt{using A}， 这会把\texttt{f}代入命名空间。


\item[3. ] 当问题中的多个名称\emph{确实}有相同的含义时，通常一个模块会从另一个模块导入它，或者有一个轻量级的“基础”包，它的唯一功能是定义这样的接口，可以被其他包使用。按照惯例，这些包名以 \texttt{...Base} 结尾（这与 Julia 的 \texttt{Base} 模块无关）

\end{itemize}


\hypertarget{3653095448809961286}{}


\subsection{默认顶层定义以及裸模块}



模块自动包含 \texttt{using Core}、\texttt{using Base} 以及 \hyperlink{7507639810592563424}{\texttt{eval}} 和 \hyperlink{7507443674556842580}{\texttt{include}} 函数的定义，这些函数在该模块的全局作用域内计算表达式/文件 .



如果不需要这些默认定义，可以使用关键字 \hyperlink{13329108222158426840}{\texttt{baremodule}} 来定义模块（注意：\texttt{Core} 仍然是导入的）。 就 \texttt{baremodule} 而言，一个标准的 \texttt{module} 看起来像这样：




\begin{lstlisting}
baremodule Mod

using Base

eval(x) = Core.eval(Mod, x)
include(p) = Base.include(Mod, p)

...

end
\end{lstlisting}



\hypertarget{2129272965593313585}{}


\subsection{标准模块}



有三个重要的标准模块：



\begin{itemize}
\item \hyperlink{14876339894285762624}{\texttt{Core}} 包含了语言“内置”的所有功能。


\item \hyperlink{464144976511314225}{\texttt{Base}} 包含了绝大多数情况下都会用到的基本功能。


\item \href{@ref}{\texttt{Main}} 是顶层模块，当 julia 启动时，也是当前模块。

\end{itemize}


\begin{quote}
\textbf{Standard library modules}

默认情况下，Julia 附带了一些标准库模块。 除了你不需要显式安装它们之外，它们的行为与常规 Julia 包类似。 例如，如果您想执行一些单元测试，你可以按如下方式加载 \texttt{Test} 标准库：


\begin{minted}{julia}
using Test
\end{minted}

\end{quote}


\hypertarget{3656127271295886220}{}


\section{子模块和相对路径}



模块可以包含 \emph{子模块}，嵌套相同的语法\texttt{module ... end}。 它们可用于引入单独的命名空间，这有助于组织复杂的代码库。 请注意，每个 \texttt{module} 都引入了自己的 \hyperlink{11957539949537805757}{作用域}，因此子模块不会自动从其父模块“继承”名称。



建议子模块在 \texttt{using} 和 \texttt{import} 语句中使用 \emph{相对模块限定符} 来引用封闭父模块中的其他模块（包括后者）。 相对模块限定符以句点 (\texttt{.}) 开头，它对应于当前模块，每个连续的 \texttt{.} 都指向当前模块的父级。 如有必要，这应该跟在模块之后，最后是要访问的实际名称，所有名称都以\texttt{.}分隔。



考虑以下示例，其中子模块\texttt{SubA}定义了一个函数，然后在其“兄弟”模块中进行扩展：




\begin{minted}{julia}
module ParentModule

module SubA
export add_D  # exported interface
const D = 3
add_D(x) = x + D
end

using .SubA  # brings `add_D` into the namespace

export add_D # export it from ParentModule too

module SubB
import ..SubA: add_D # relative path for a “sibling” module
struct Infinity end
add_D(x::Infinity) = x
end

end
\end{minted}



你可能会在包中看到代码，在类似的情况下，它使用




\begin{minted}{julia}
import ParentModule.SubA: add_D
\end{minted}



然而，这是通过 \hyperlink{11949095373261797528}{代码加载} 操作的，因此仅当 \texttt{ParentModule} 在包中时才有效。 最好使用相对路径。



请注意，如果你正在评估值，定义的顺序也很重要。 考虑




\begin{minted}{julia}
module TestPackage

export x, y

x = 0

module Sub
using ..TestPackage
z = y # ERROR: UndefVarError: y not defined
end

y = 1

end
\end{minted}



其中 \texttt{Sub} 在定义之前尝试使用 \texttt{TestPackage.y}，因此它没有值。



出于类似的原因，你不能使用循环顺序：




\begin{minted}{julia}
module A

module B
using ..C # ERROR: UndefVarError: C not defined
end

module C
using ..B
end

end
\end{minted}



\hypertarget{10308651053456408379}{}


\subsection{模块初始化和预编译}



因为执行模块中的所有语句通常需要编译大量代码，大型模块可能需要几秒钟才能加载。Julia 会创建模块的预编译缓存以减少这个时间。



当用 \texttt{import} 或 \texttt{using} 加载一个模块时，模块增量预编译文件会自动创建并使用。这会让模块在第一次加载时自动编译。 另外，你也可以手工调用 \hyperlink{15403934372637978246}{\texttt{Base.compilecache(modulename)}}，产生的缓存文件会放在 \texttt{DEPOT\_PATH[1]/compiled/} 目录下。 之后，当该模块的任何一个依赖发生变更时，该模块会在 \texttt{using} 或 \texttt{import} 时自动重新编译； 模块的依赖指的是：任何它导入的模块、Julia 自身、include 的文件或由 \hyperlink{13423629850785876688}{\texttt{include\_dependency(path)}} 显式声明的依赖。



对于文件依赖项，通过检查由 \texttt{include} 加载或由 \texttt{include\_dependency} 显式添加的每个文件的修改时间（\texttt{mtime}）是否保持不变，或是否等于截断到最接近秒的修改时间（以适应无法以亚秒精度复制 mtime的系统），来确定更改。它还考虑由 \texttt{require} 中的搜索逻辑选择的文件路径是否与创建预编译文件的路径匹配。它还考虑了已加载到当前进程中的依赖项集，并且不会重新编译这些模块，即使它们的文件更改或消失，以避免在正在运行的系统和预编译缓存之间创建不兼容。



如果你知道一个模块预编译\emph{不}安全（例如，由于下面描述的原因之一），你应该把\texttt{\_\_precompile\_\_(false)}放在模块文件中（通常放在顶部）。 这会导致\texttt{Base.compilecache} 抛出错误，并且会导致\texttt{using} / \texttt{import} 将其直接加载到当前进程中并跳过预编译和缓存。 这也因此防止了模块被任何其他预编译模块导入。



在开发模块的时候，你可能需要了解一些与增量编译相关的固有行为。例如，外部状态不会被保留。为了解决这个问题，需要显式分离运行时与编译期的部分。Julia 允许你定义一个 \texttt{\_\_init\_\_()} 函数来执行任何需要在运行时发生的初始化。在编译期（\texttt{--output-*}），此函数将不会被调用。你可以假设在代码的生存周期中，此函数只会被运行一次。当然，如果有必要，你也可以手动调用它，但在默认的情况下，请假定此函数是为了处理与本机状态相关的信息，注意这些信息不需要，更不应该存入预编译镜像。此函数会在模块被导入到当前进程之后被调用，这包括在一个增量编译中导入该模块的时候（\texttt{--output-incremental=yes}），但在完整编译时该函数不会被调用。



特别的，如果你在模块里定义了一个名为 \texttt{\_\_init\_\_()} 的函数，那么 Julia 在加载这个模块之后会在第一次运行时（runtime）立刻调用这个函数（例如，通过 \texttt{import}，\texttt{using}，或者 \texttt{require} 加载时），也就是说 \texttt{\_\_init\_\_} 只会在模块中所有其它命令都执行完以后被调用一次。因为这个函数将在模块完全载入后被调用，任何子模块或者已经载入的模块都将在当前模块调用 \texttt{\_\_init\_\_} \textbf{之前} 调用自己的 \texttt{\_\_init\_\_} 函数。



\texttt{\_\_init\_\_}的典型用法有二，一是用于调用外部 C 库的运行时初始化函数，二是用于初始化涉及到外部库所返回的指针的全局常量。例如，假设我们正在调用一个 C 库 \texttt{libfoo}，它要求我们在运行时调用\texttt{foo\_init()} 这个初始化函数。假设我们还想定义一个全局常量 \texttt{foo\_data\_ptr}，它保存 \texttt{libfoo} 所定义的 \texttt{void *foo\_data()} 函数的返回值——必须在运行时（而非编译时）初始化这个常量，因为指针地址不是固定的。可以通过在模块中定义 \texttt{\_\_init\_\_} 函数来完成这个操作。




\begin{minted}{julia}
const foo_data_ptr = Ref{Ptr{Cvoid}}(0)
function __init__()
    ccall((:foo_init, :libfoo), Cvoid, ())
    foo_data_ptr[] = ccall((:foo_data, :libfoo), Ptr{Cvoid}, ())
    nothing
end
\end{minted}



注意，在像 \texttt{\_\_init\_\_} 这样的函数里定义一个全局变量是完全可以的，这是动态语言的优点之一。但是把全局作用域的值定义成常量，可以让编译器能确定该值的类型，并且能让编译器生成更好的优化过的代码。显然，你的模块（Module）中，任何其他依赖于 \texttt{foo\_data\_ptr} 的全局量也必须在 \texttt{\_\_init\_\_} 中被初始化。



涉及大多数不是由 \hyperlink{14245046751182637566}{\texttt{ccall}} 生成的 Julia 对象的常量不需要放在 \texttt{\_\_init\_\_} 中：它们的定义可以从缓存的模块映像中预编译和加载。 这包括复杂的堆分配对象，如数组。 但是，任何返回原始指针值的例程都必须在运行时调用才能使预编译工作（\hyperlink{10630331440513004826}{\texttt{Ptr}} 对象将变成空指针，除非它们隐藏在 \hyperlink{12980593021531333073}{\texttt{isbits}} 目的）。 这包括 Julia 函数 \hyperlink{11617107520401351255}{\texttt{@cfunction}} 和 \hyperlink{8901246211940014300}{\texttt{pointer}} 的返回值。



字典和集合类型，或者通常任何依赖于 \texttt{hash(key)} 方法的类型，都是比较棘手的情况。 通常当键是数字、字符串、符号、范围、\texttt{Expr} 或这些类型的组合（通过数组、元组、集合、映射对等）时，可以安全地预编译它们。但是，对于一些其它的键类型，例如 \texttt{Function} 或 \texttt{DataType}、以及还没有定义散列方法的通用用户定义类型，回退（fallback）的散列（\texttt{hash}）方法依赖于对象的内存地址（通过 \texttt{objectid}），因此可能会在每次运行时发生变化。 如果您有这些关键类型中的一种，或者您不确定，为了安全起见，您可以在您的 \texttt{\_\_init\_\_} 函数中初始化这个字典。或者，您可以使用 \hyperlink{14088500196255451490}{\texttt{IdDict}} 字典类型，它是由预编译专门处理的，因此在编译时初始化是安全的。



当使用预编译时，我们必须要清楚地区分代码的编译阶段和运行阶段。在此模式下，我们会更清楚发现 Julia 的编译器可以执行任何 Julia 代码，而不是一个用于生成编译后代码的独立的解释器。



其它已知的潜在失败场景包括：



\begin{itemize}
\item[1. ] 全局计数器，例如：为了试图唯一的标识对象。考虑以下代码片段：


\begin{minted}{julia}
mutable struct UniquedById
    myid::Int
    let counter = 0
        UniquedById() = new(counter += 1)
    end
end
\end{minted}

尽管这段代码的目标是给每个实例赋一个唯一的 ID，但计数器的值会在代码编译结束时被记录。任何对此增量编译模块的后续使用，计数器都将从同一个值开始计数。

注意 \texttt{objectid} （工作原理是取内存指针的 hash）也有类似的问题，请查阅下面关于 \texttt{Dict} 的用法。

一种解决方案是用宏捕捉 \hyperlink{8796901235206560169}{\texttt{@\_\_MODULE\_\_}}，并将它与目前的 \texttt{counter} 值一起保存。然而，更好的方案是对代码进行重新设计，不要依赖这种全局状态变量。


\item[2. ] 像 \texttt{Dict} 和 \texttt{Set} 这种关联集合需要在 \texttt{\_\_init\_\_} 中 re-hash。Julia 在未来很可能会提供一个机制来注册初始化函数。


\item[3. ] 依赖编译期的副作用会在加载时蔓延。例子包括：更改其它 Julia 模块里的数组或变量，操作文件或设备的句柄，保存指向其它系统资源（包括内存）的指针。


\item[4. ] 无意中从其它模块中“拷贝”了全局状态：通过直接引用的方式而不是通过查找的方式。例如，在全局作用域下：


\begin{minted}{julia}
#mystdout = Base.stdout #= will not work correctly, since this will copy Base.stdout into this module =#
# instead use accessor functions:
getstdout() = Base.stdout #= best option =#
# or move the assignment into the runtime:
__init__() = global mystdout = Base.stdout #= also works =#
\end{minted}

\end{itemize}


此处为预编译中的操作附加了若干限制，以帮助用户避免其他误操作：



\begin{itemize}
\item[1. ] 调用 \hyperlink{7507639810592563424}{\texttt{eval}} 来在另一个模块中引发副作用。当增量预编译被标记时，该操作同时会导致抛出一个警告。


\item[2. ] 当 \texttt{\_\_init\_\_()} 已经开始执行后，在局部作用域中声明 \texttt{global const}（见 issue \#12010，计划为此情况添加一个错误提示）


\item[3. ] 在增量预编译时替换模块是一个运行时错误。

\end{itemize}


一些其他需要注意的点：



\begin{itemize}
\item[1. ] 在源代码文件本身被修改之后，不会执行代码重载或缓存失效化处理（包括由 \texttt{Pkg.update} 执行的修改，此外在 \texttt{Pkg.rm} 执行后也没有清理操作）


\item[2. ] 变形数组的内存共享特性会被预编译忽略（每个数组样貌都会获得一个拷贝）


\item[3. ] 文件系统在编译期间和运行期间被假设为不变的，比如使用 \hyperlink{1518763743618824993}{\texttt{@\_\_FILE\_\_}}/\texttt{source\_path()} 在运行期间寻找资源、或使用 BinDeps 宏 \texttt{@checked\_lib}。有时这是不可避免的。但是可能的话，在编译期将资源复制到模块里面是个好做法，这样在运行期间，就不需要去寻找它们了。


\item[4. ] \texttt{WeakRef} 对象和完成器目前在序列化器中无法被恰当地处理（在接下来的发行版中将修复）。


\item[5. ] 通常，最好避免去捕捉内部元数据对象的引用，如 \texttt{Method}、\texttt{MethodInstance}、\texttt{TypeMapLevel}、\texttt{TypeMapEntry} 及这些对象的字段，因为这会迷惑序列化器，且可能会引发你不想要的结果。此操作不足以成为一个错误，但你需做好准备：系统会尝试拷贝一部分，然后创建其余部分的单个独立实例。

\end{itemize}


在开发模块时，关闭增量预编译可能会有所帮助。命令行标记 \texttt{--compiled-modules=\{yes|no\}} 可以让你切换预编译的开启和关闭。当 Julia 附加 \texttt{--compiled-modules=no} 启动，在载入模块和模块依赖时，编译缓存中的序列化模块会被忽略。\texttt{Base.compilecache} 仍可以被手动调用。此命令行标记的状态会被传递给 \texttt{Pkg.build}，禁止其在安装、更新、显式构建包时触发自动预编译。



\hypertarget{17356560956725341158}{}


\chapter{文档}



Julia允许开发者和用户，使用其内置的文档系统更加便捷地为函数、类型以及其他对象编写文档。  



基础语法很简单：紧接在对象（函数，宏，类型和实例）之前的字符串都会被认为是对应对象的文档（称作 \emph{docstrings}）。 注意不要在 docstring 和文档对象之间有空行或者注释。 这里有个基础的例子：




\begin{minted}{julia}
"Tell whether there are too foo items in the array."
foo(xs::Array) = ...
\end{minted}



文档会被翻译成 \href{https://en.wikipedia.org/wiki/Markdown}{Markdown}，所以你可以 使用缩进和代码块来分隔代码示例和文本。从技术上来说，任何对象 都可以作为 metadata 与任何其他对象关联；Markdown 是默认的，但是可以创建 其它字符串宏并传递给 \texttt{@doc} 宏来使用其他格式。



\begin{quote}
\textbf{Note}

Markdown 支持由 \texttt{Markdown} 标准库实现，有关支持语法的完整列表，请参阅其\hyperlink{4003493111480691691}{文档}。

\end{quote}


这里是一个更加复杂的例子，但仍然使用 Markdown：




\begin{minted}{julia}
"""
    bar(x[, y])

Compute the Bar index between `x` and `y`.

If `y` is unspecified, compute the Bar index between all pairs of columns of `x`.

# Examples
```julia-repl
julia> bar([1, 2], [1, 2])
1
```
"""
function bar(x, y) ...
\end{minted}



如上例所示，我们推荐在写文档时遵守一些简单约定：



\begin{itemize}
\item[1.  ] 始终在文档顶部显示函数的签名并带有四空格缩进，以便能够显示成 Julia 代码。

这和在 Julia 代码中的签名是一样的（比如 \texttt{mean(x::AbstractArray)}），或是简化版。可选参数应该尽可能与默认值一同显示（例如 \texttt{f(x, y=1)}），这与实际的 Julia 语法一致。没有默认值的可选参数应该放在括号中（例如 \texttt{f(x[, y])} 和 \texttt{f(x[, y[, z]])}）。可选的解决方法是使用多行：一个没有可选参数，其他的拥有可选参数（或者多个可选参数）。这个解决方案也可以用作给某个函数的多个方法来写文档。当一个函数接收到多个关键字参数，只在签名中包含占位符 \texttt{<keyword arguments>}（例如 \texttt{f(x; <keyword arguments>)}），并在 \texttt{\# Arguments} 章节给出完整列表（参照下列第 4 点）。


\item[2.  ] 在简化的签名块后请包含一个描述函数能做什么或者对象代表什么的单行句。如果需要的话，在一个空行之后，在第二段提供更详细的信息。

撰写函数的文档时，单行语句应使用祈使结构（比如「Do this」、「Return that」）而非第三人称（不要写「Returns the length...」）。并且应以句号结尾。如果函数的意义不能简单地总结，更好的方法是分成分开的组合句（虽然这不应被看做是对于每种情况下的绝对要求）。


\item[3.  ] 不要自我重复。

因为签名给出了函数名，所以没有必要用「The function \texttt{bar}...」开始文档：直接说要点。类似地，如果签名指定了参数的类型，在描述中提到这些是多余的。


\item[4.  ] 只在确实必要时提供参数列表。

对于简单函数，直接在函数目的的描述中提到参数的作用常常更加清楚。参数列表只会重复再其他地方提供过的信息。但是，对于拥有多个参数的（特别是含有关键字参数的）复杂函数来说，提供一个参数列表是个好主意。在这种情况下，请在函数的一般描述之后、标题 \texttt{\# Arguments} 之下插入参数列表，并在每个参数前加个着重号 \texttt{-}。参数列表应该提到参数的类型和默认值（如果有）：


\begin{minted}{julia}
"""
...
# Arguments
- `n::Integer`: the number of elements to compute.
- `dim::Integer=1`: the dimensions along which to perform the computation.
...
"""
\end{minted}


\item[5.  ] 给相关函数提供提示。

有时会存在具有功能相联系的函数。为了更易于发现相关函数，请在段落 \texttt{See also:} 中为其提供一个小列表。


\begin{lstlisting}
See also [`bar!`](@ref), [`baz`](@ref), [`baaz`](@ref).
\end{lstlisting}


\item[6.  ] 请在 \texttt{\# Examples} 中包含一些代码例子。

例子应尽可能按照 \emph{doctest} 来写。\emph{doctest} 是一个栅栏分隔开的代码块（请参阅\hyperlink{14660894509460337656}{代码块}），其以 \texttt{```jldoctest} 开头并包含任意数量的提示符 \texttt{julia>} 以及用来模拟 Julia REPL 的输入和预期输出。

\begin{quote}
\textbf{Note}

Doctest 由 \href{https://github.com/JuliaDocs/Documenter.jl}{\texttt{Documenter.jl}} 支持。有关更详细的文档，请参阅 Documenter 的\href{https://juliadocs.github.io/Documenter.jl/}{手册}。

\end{quote}
例如在下面的 docstring 中定义了变量 \texttt{a}，预期的输出，跟在 Julia REPL 中打印的一样，出现在后面。


\begin{minted}{julia}
"""
Some nice documentation here.

# Examples
```jldoctest
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4
```
"""
\end{minted}

\begin{quote}
\textbf{Warning}

Calling \texttt{rand} and other RNG-related functions should be avoided in doctests since they will not produce consistent outputs during different Julia sessions. If you would like to show some random number generation related functionality, one option is to explicitly construct and seed your own RNG object (see \hyperlink{6526948166346290584}{\texttt{Random}}) and pass it to the functions you are doctesting.

Operating system word size (\hyperlink{10103694114785108551}{\texttt{Int32}} or \hyperlink{7720564657383125058}{\texttt{Int64}}) as well as path separator differences (\texttt{/} or \texttt{{\textbackslash}}) will also affect the reproducibility of some doctests.

Note that whitespace in your doctest is significant! The doctest will fail if you misalign the output of pretty-printing an array, for example.

\end{quote}
你可以运行 \texttt{make -C doc doctest=true} 来运行在 Julia 手册和 API 文档中的 doctests，这样可以确保你的例子都能正常运行。

为了表示输出结果被截断了，你应该在校验应该停止的一行写上 \texttt{[...]}。这个在当 doctest 显示有个异常被抛出时隐藏堆栈跟踪时很有用（堆栈跟踪包含对 julia 代码的行的非永久引用），例如：


\begin{minted}{julia}
```jldoctest
julia> div(1, 0)
ERROR: DivideError: integer division error
[...]
```
\end{minted}

那些不能进行测试的例子应该写在以 \texttt{```julia} 开头的栅栏分隔的代码块中，以便在生成的文档中正确地高亮显示。

\begin{quote}
\textbf{Tip}

例子应尽可能\textbf{独立}和\textbf{可运行}以便读者可以在不需要引入任何依赖的情况下对它们进行实验。

\end{quote}

\item[7.  ] 使用倒引号来标识代码和方程。

Julia 标识符和代码摘录应该出现在倒引号 \texttt{`} 之间来使其能高亮显示。LaTeX 语法下的方程应该插入到双倒引号 \texttt{``} 之间。请使用 Unicode 字符而非 LaTeX 转义序列，比如 \texttt{``α = 1``} 而非 \texttt{``{\textbackslash}{\textbackslash}alpha = 1``}。


\item[8.  ] 请将起始和结束的\texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}}符号单独成行。

也就是说，请写：


\begin{minted}{julia}
"""
...

...
"""
f(x, y) = ...
\end{minted}

而非：


\begin{minted}{julia}
"""...

..."""
f(x, y) = ...
\end{minted}

这将让 docstring 的起始和结束位置更加清楚。


\item[9.  ] 请在代码中遵守单行长度限制。

Docstring 是使用与代码相同的工具编辑的。所以应运用同样的约定。 建议一行 92 个字符后换行。


\item[10. ] 请在 \texttt{\# Implementation} 章节中提供自定义类型如何实现该函数的信息。这些实现细节是针对开发者而非用户的，解释了例如哪些函数应该被重写、哪些函数自动使用恰当的回退函数等信息，最好与描述函数的主体描述分开。


\item[11. ] 对于长文档字符串，可以考虑使用 \texttt{\# Extended help} 头拆分文档。典型的帮助模式将只显示标题上方的内容；你可以通过添加一个 \texttt{?} 在表达的开头来查看完整的文档（即 \texttt{??foo} 而不是 \texttt{?foo}）。

\end{itemize}


\hypertarget{10486321714157126961}{}


\section{访问文档}



文档可以在REPL中访问，也可以在 \href{https://github.com/JuliaLang/IJulia.jl}{IJulia} 中通过键入\texttt{?}紧接函数或者宏的名字并按下\texttt{Enter}访问。例如，




\begin{minted}{julia}
?cos
?@time
?r""
\end{minted}



会分别为相应的函数，宏或者字符显示文档。在 \href{http://junolab.org}{Juno} 中，使用 \texttt{Ctrl-J, Ctrl-D} 会为光标处的对象显示文档。



\hypertarget{5384792468741396562}{}


\section{函数与方法}



在Julia中函数可能有多种实现，被称为方法。虽然通用函数 一般只有一个目的，Julia允许在必要时可以对方法独立写文档。 通常，应该只有最通用的方法才有文档，或者甚至只是函数本身 （也就是在\texttt{function bar end}之前没有任何方法的对象）。特定方法应该 只因为其行为与其他通用方法有所区别才写文档。在任何情况下都不应 重复其他地方有的信息。例如




\begin{minted}{julia}
"""
    *(x, y, z...)

Multiplication operator. `x * y * z *...` calls this function with multiple
arguments, i.e. `*(x, y, z...)`.
"""
function *(x, y, z...)
    # ... [implementation sold separately] ...
end

"""
    *(x::AbstractString, y::AbstractString, z::AbstractString...)

When applied to strings, concatenates them.
"""
function *(x::AbstractString, y::AbstractString, z::AbstractString...)
    # ... [insert secret sauce here] ...
end

help?> *
search: * .*

  *(x, y, z...)

  Multiplication operator. x * y * z *... calls this function with multiple
  arguments, i.e. *(x,y,z...).

  *(x::AbstractString, y::AbstractString, z::AbstractString...)

  When applied to strings, concatenates them.
\end{minted}



当从通用函数里抽取文档时，每个方法的元数据会用函数\texttt{catdoc}拼接，其当然可以被自定义类型重写。



\hypertarget{9947466122062338539}{}


\section{进阶用法}



\texttt{@doc} 宏将它的第一个参数与它的第二个参数关联在各个模块的名为 \texttt{META} 的字典中。



为了让写文档更加简单，语法分析器对宏名\texttt{@doc}特殊对待：如果\texttt{@doc}的调用只有一个参数，但是在下一行出现了另外一个表达式，那么这个表达式就会追加为宏的参数。所以接下来的语法会被分析成\texttt{@doc}的2个参数的调用：




\begin{minted}{julia}
@doc raw"""
...
"""
f(x) = x
\end{minted}



这就让使用任意对象（这里指的是原始字符串 \texttt{raw{\textquotedbl}{\textquotedbl}}）作为 docstring 变得简单。



当\texttt{@doc}宏（或者\texttt{doc}函数）用作抽取文档时，他会在所有的\texttt{META}字典寻找与对象相关的元数据并且返回。返回的对象（例如一些Markdown内容）会默认智能地显示。这个设计也让以编程方法使用文档系统变得容易；例如，在一个函数的不同版本中重用文档：




\begin{minted}{julia}
@doc "..." foo!
@doc (@doc foo!) foo
\end{minted}



或者与Julia的元编程功能一起使用：




\begin{minted}{julia}
for (f, op) in ((:add, :+), (:subtract, :-), (:multiply, :*), (:divide, :/))
    @eval begin
        $f(a,b) = $op(a,b)
    end
end
@doc "`add(a,b)` adds `a` and `b` together" add
@doc "`subtract(a,b)` subtracts `b` from `a`" subtract
\end{minted}



写在非顶级块，比如\texttt{begin}, \texttt{if}, \texttt{for}, 和 \texttt{let}，中的文档会根据块的评估情况加入文档系统中，例如：




\begin{minted}{julia}
if condition()
    "..."
    f(x) = x
end
\end{minted}



会被加到\texttt{f(x)}的文档中，当\texttt{condition()}是\texttt{true}的时候。注意即使\texttt{f(x)}在块的末尾离开了作用域，他的文档还会保留。



可以利用元编程来帮助创建文档。当在文档字符串中使用字符串插值时，需要使用额外的 \texttt{\$} 例如：\texttt{\$(\$name)}




\begin{minted}{julia}
for func in (:day, :dayofmonth)
    name = string(func)
    @eval begin
        @doc """
            $($name)(dt::TimeType) -> Int64

        The day of month of a `Date` or `DateTime` as an `Int64`.
        """ $func(dt::Dates.TimeType)
    end
end
\end{minted}



\hypertarget{7588661187190124361}{}


\subsection{动态写文档}



有些时候类型的实例的合适的文档并非只取决于类型本身，也取决于实例的值。在这些情况下，你可以添加一个方法给自定义类型的\texttt{Docs.getdoc}函数，返回基于每个实例的文档。例如，




\begin{minted}{julia}
struct MyType
    value::Int
end

Docs.getdoc(t::MyType) = "Documentation for MyType with value $(t.value)"

x = MyType(1)
y = MyType(2)
\end{minted}



\texttt{?x} 将显示“Documentation for MyType with value 1”，而\texttt{?y} 将显示“Documentation for MyType with value 2”。



\hypertarget{12360783788480513081}{}


\section{语法指南}



本指南提供了如何将文档附加到所有可能的 Julia 语法构造的全面概述。



在下述例子中\texttt{{\textquotedbl}...{\textquotedbl}}用来表示任意的docstring。



\hypertarget{7018953543534741329}{}


\subsection{\texttt{\$} 与 \texttt{{\textbackslash}} 字符}



\texttt{\$} 和 \texttt{{\textbackslash}} 字符仍然被解析为字符串插值或转义序列的开始字符。 \texttt{raw{\textquotedbl}{\textquotedbl}} 字符串宏和 \texttt{@doc} 宏可以用来避免对它们进行转义。 当文档字符串包含 LaTeX 或 Julia 源代码，且示例中包含插值时，这是很方便的:




\begin{minted}{julia}
@doc raw"""
```math
\LaTeX
```
"""
function f end
\end{minted}



\hypertarget{198065463690830309}{}


\subsection{函数与方法}




\begin{minted}{julia}
"..."
function f end

"..."
f
\end{minted}



把 docstring \texttt{{\textquotedbl}...{\textquotedbl}} 添加给了函数 \texttt{f}。首选的语法是第一种，虽然两者是等价的。




\begin{minted}{julia}
"..."
f(x) = x

"..."
function f(x)
    x
end

"..."
f(x)
\end{minted}



把 docstring \texttt{{\textquotedbl}...{\textquotedbl}} 添加给了方法 \texttt{f(::Any)}。




\begin{minted}{julia}
"..."
f(x, y = 1) = x + y
\end{minted}



把 docstring \texttt{{\textquotedbl}...{\textquotedbl}} 添加给了两个方法，分别为 \texttt{f(::Any)} 和 \texttt{f(::Any, ::Any)}。



\hypertarget{958098821246331521}{}


\subsection{宏}




\begin{minted}{julia}
"..."
macro m(x) end
\end{minted}



把 docstring \texttt{{\textquotedbl}...{\textquotedbl}} 添加给了宏 \texttt{@m(::Any)} 的定义。




\begin{minted}{julia}
"..."
:(@m)
\end{minted}



把 docstring \texttt{{\textquotedbl}...{\textquotedbl}} 添加给了名为 \texttt{@m} 的宏。



\hypertarget{5145884598618557277}{}


\subsection{类型}




\begin{lstlisting}
"..."
abstract type T1 end

"..."
mutable struct T2
    ...
end

"..."
struct T3
    ...
end
\end{lstlisting}



把 docstring \texttt{{\textquotedbl}...{\textquotedbl}} 添加给了类型 \texttt{T1}、\texttt{T2} 和 \texttt{T3}。




\begin{minted}{julia}
"..."
struct T
    "x"
    x
    "y"
    y
end
\end{minted}



把 docstring \texttt{{\textquotedbl}...{\textquotedbl}} 添加给了类型 \texttt{T}，\texttt{{\textquotedbl}x{\textquotedbl}} 添加给字段 \texttt{T.x}，\texttt{{\textquotedbl}y{\textquotedbl}} 添加给字段 \texttt{T.y}。也可以运用于\texttt{mutable struct} 类型。



\hypertarget{18307601734386005108}{}


\subsection{模块}




\begin{minted}{julia}
"..."
module M end

module M

"..."
M

end
\end{minted}



把 docstring \texttt{{\textquotedbl}...{\textquotedbl}} 添加给了模块 \texttt{M}。首选的语法是在模块之前添加 docstring，虽然两者是等价的。




\begin{minted}{julia}
"..."
baremodule M
# ...
end

baremodule M

import Base: @doc

"..."
f(x) = x

end
\end{minted}



通过在表达式上方放置一个 docstring 来记录 \texttt{baremodule} 会自动将 \texttt{@doc} 导入到模块中。 当没有记录模块表达式时，必须手动完成这些导入。



\hypertarget{17299710876257759093}{}


\subsection{全局变量}




\begin{minted}{julia}
"..."
const a = 1

"..."
b = 2

"..."
global c = 3
\end{minted}



把docstring\texttt{{\textquotedbl}...{\textquotedbl}}添加给了\texttt{绑定} \texttt{a}，\texttt{b}和\texttt{c}。



\texttt{绑定}是用来在\texttt{模块}中存储对于特定\texttt{符号}的引用而非存储被引用的值本身。



\begin{quote}
\textbf{Note}

当一个 \texttt{const} 定义只是用作定义另外一个定义的别名时，比如函数 \texttt{div} 和其在 \texttt{Base} 中的别名 \texttt{÷}，并不要为别名写文档，转而去为实际的函数写文档。

如果别名写了文档而实际定义没有，那么文档系统（\texttt{?} 模式）在寻找实际定义的文档时将不会返回别名的对应文档。

比如你应该写


\begin{minted}{julia}
"..."
f(x) = x + 1
const alias = f
\end{minted}

而非


\begin{minted}{julia}
f(x) = x + 1
"..."
const alias = f
\end{minted}

\end{quote}



\begin{minted}{julia}
"..."
sym
\end{minted}



把 docstring \texttt{{\textquotedbl}...{\textquotedbl}} 添加给值 \texttt{sym}。但是应首选在 \texttt{sym} 的定义处写文档。



\hypertarget{6306013858572164490}{}


\subsection{多重对象}




\begin{minted}{julia}
"..."
a, b
\end{minted}



把docstring \texttt{{\textquotedbl}...{\textquotedbl}} 添加给\texttt{a}和\texttt{b}，两个都应该是可以写文档的表达式。这个语法等价于




\begin{minted}{julia}
"..."
a

"..."
b
\end{minted}



这种方法可以给任意数量的表达式写文档。当两个函数相关，比如非变版本\texttt{f}和可变版本\texttt{f!}，这个语法是有用的。



\hypertarget{5068022185116881179}{}


\subsection{宏生成代码}




\begin{minted}{julia}
"..."
@m expression
\end{minted}



把docstring \texttt{{\textquotedbl}...{\textquotedbl}} 添加给通过展开 \texttt{@m expression} 生成的表达式。 这就允许由 \texttt{@inline}、\texttt{@noinline}、\texttt{@generated} 或者任意其他宏装饰的表达式，能和没有装饰的表达式以同样的方式写文档。



宏作者应该注意到只有只生成单个表达式的宏才会自动支持docstring。如果宏返回的是含有多个子表达式的块，需要写文档的子表达式应该使用宏 \hyperlink{8194145670752069829}{\texttt{@\_\_doc\_\_}} 标记。



\hyperlink{18177775477210803027}{\texttt{@enum}} 宏使用了 \texttt{@\_\_doc\_\_} 来允许给 \texttt{Enum} 写文档。它的做法可以作为如何正确使用 \texttt{@\_\_doc\_\_} 的范例。


\hypertarget{8194145670752069829}{}
\hyperlink{8194145670752069829}{\texttt{Core.@\_\_doc\_\_}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@__doc__(ex)
\end{minted}

Low-level macro used to mark expressions returned by a macro that should be documented. If more than one expression is marked then the same docstring is applied to each expression.


\begin{lstlisting}
macro example(f)
    quote
        $(f)() = 0
        @__doc__ $(f)(x) = 1
        $(f)(x, y) = 2
    end |> esc
end
\end{lstlisting}

\texttt{@\_\_doc\_\_} has no effect when a macro that uses it is not documented.



\href{https://github.com/JuliaLang/julia/blob/9058264a69f9efc1af805c4473c946f87859b731/base/docs/Docs.jl#L440-L455}{\texttt{source}}


\end{adjustwidth}

\hypertarget{16614739534143995624}{}


\chapter{元编程}



Lisp 留给 Julia 最大的遗产就是它的元编程支持。和 Lisp 一样，Julia 把自己的代码表示为语言中的数据结构。既然代码被表示为了可以在语言中创建和操作的对象，程序就可以变换和生成自己的代码。这允许在没有额外构建步骤的情况下生成复杂的代码，并且还允许在 \href{https://en.wikipedia.org/wiki/Abstract\_syntax\_tree}{abstract syntax trees} 级别上运行的真正的 Lisp 风格的宏。与之相对的是预处理器“宏”系统，比如 C 和 C++ 中的，它们在解析和解释代码之前进行文本操作和变换。由于 Julia 中的所有数据类型和代码都被表示为 Julia 的 数据结构，强大的 \href{https://en.wikipedia.org/wiki/Reflection\_omputer\_\%28cprogramming\%29}{reflection} 功能可用于探索程序的内部及其类型，就像任何其他数据一样。



\hypertarget{13890173916214395200}{}


\section{程序表示}



每个 Julia 程序均以字符串开始：




\begin{minted}{jlcon}
julia> prog = "1 + 1"
"1 + 1"
\end{minted}



\textbf{接下来会发生什么？}



下一步是 \href{https://en.wikipedia.org/wiki/Parsing\#Computer\_languages}{parse} 每个字符串到一个称为表达式的对象，由 Julia 的类型 \hyperlink{17120496304147995299}{\texttt{Expr}} 表示：




\begin{minted}{jlcon}
julia> ex1 = Meta.parse(prog)
:(1 + 1)

julia> typeof(ex1)
Expr
\end{minted}



\texttt{Expr} 对象包含两个部分：



\begin{itemize}
\item 一个标识表达式类型的 \hyperlink{18332791376992528422}{\texttt{Symbol}}。

\end{itemize}


Symbol 就是一个 \href{https://en.wikipedia.org/wiki/String\_interning}{interned string}     标识符（下面会有更多讨论）




\begin{minted}{jlcon}
julia> ex1.head
:call
\end{minted}



\begin{itemize}
\item 表达式的参数，可能是符号、其他表达式或字面量：

\end{itemize}



\begin{minted}{jlcon}
julia> ex1.args
3-element Vector{Any}:
  :+
 1
 1
\end{minted}



表达式也可能直接用 \href{https://en.wikipedia.org/wiki/Polish\_notation}{prefix notation} 构造：




\begin{minted}{jlcon}
julia> ex2 = Expr(:call, :+, 1, 1)
:(1 + 1)
\end{minted}



上面构造的两个表达式 – 一个通过解析构造一个通过直接构造 – 是等价的：




\begin{minted}{jlcon}
julia> ex1 == ex2
true
\end{minted}



\textbf{这里的关键点是 Julia 的代码在内部表示为可以从语言本身访问的数据结构}



函数 \hyperlink{15981569052160951906}{\texttt{dump}} 可以带有缩进和注释地显示 \texttt{Expr} 对象：




\begin{minted}{jlcon}
julia> dump(ex2)
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Int64 1
    3: Int64 1
\end{minted}



\texttt{Expr} 对象也可以嵌套：




\begin{minted}{jlcon}
julia> ex3 = Meta.parse("(4 + 4) / 2")
:((4 + 4) / 2)
\end{minted}



另外一个查看表达式的方法是使用 \texttt{Meta.show\_sexpr}，它能显示给定 \texttt{Expr} 的 \href{https://en.wikipedia.org/wiki/S-expression}{S-expression}，对 Lisp 用户来说，这看着很熟悉。下面是一个示例，阐释了如何显示嵌套的 \texttt{Expr}：




\begin{minted}{jlcon}
julia> Meta.show_sexpr(ex3)
(:call, :/, (:call, :+, 4, 4), 2)
\end{minted}



\hypertarget{17960433860062790097}{}


\subsection{符号}



字符 \texttt{:} 在 Julia 中有两个作用。第一种形式构造一个 \hyperlink{18332791376992528422}{\texttt{Symbol}}，这是作为表达式组成部分的一个 \href{https://en.wikipedia.org/wiki/String\_interning}{interned string}：




\begin{minted}{jlcon}
julia> s = :foo
:foo

julia> typeof(s)
Symbol
\end{minted}



构造函数 \hyperlink{18332791376992528422}{\texttt{Symbol}} 接受任意数量的参数并通过把它们的字符串表示连在一起创建一个新的符号：




\begin{minted}{jlcon}
julia> :foo == Symbol("foo")
true

julia> Symbol("func",10)
:func10

julia> Symbol(:var,'_',"sym")
:var_sym
\end{minted}



注意，要使用 \texttt{:} 语法，符号的名称必须是有效的标识符。否则，必须使用 \texttt{Symbol(str)} 构造函数。



在表达式的上下文中，符号用来表示对变量的访问；当一个表达式被求值时，符号会被替换为这个符号在合适的 \hyperlink{11957539949537805757}{scope} 中所绑定的值。



有时需要在 \texttt{:} 的参数两边加上额外的括号，以避免在解析时出现歧义：




\begin{minted}{jlcon}
julia> :(:)
:(:)

julia> :(::)
:(::)
\end{minted}



\hypertarget{3051242913122022314}{}


\section{表达式与求值}



\hypertarget{12430289445905702597}{}


\subsection{引用}



\texttt{:} 的第二个语义是不显式调用 \hyperlink{17120496304147995299}{\texttt{Expr}} 构造器来创建表达式对象。这被称为\emph{引用}。\texttt{:} 后面跟着包围着单个 Julia 语句括号，可以基于被包围的代码生成一个 \texttt{Expr} 对象。下面是一个引用算数表达式的例子：




\begin{minted}{jlcon}
julia> ex = :(a+b*c+1)
:(a + b * c + 1)

julia> typeof(ex)
Expr
\end{minted}



（为了查看这个表达式的结构，可以试一试 \texttt{ex.head} 和 \texttt{ex.args}，或者使用 \hyperlink{15981569052160951906}{\texttt{dump}} 同时查看 \texttt{ex.head} 和 \texttt{ex.args} 或者 \hyperlink{11314997131411442967}{\texttt{Meta.@dump}}）



注意等价的表达式也可以使用 \hyperlink{9794549254908071788}{\texttt{Meta.parse}} 或者直接用 \texttt{Expr} 构造：




\begin{minted}{jlcon}
julia>      :(a + b*c + 1)       ==
       Meta.parse("a + b*c + 1") ==
       Expr(:call, :+, :a, Expr(:call, :*, :b, :c), 1)
true
\end{minted}



解析器提供的表达式通常只有符号、其它表达式和字面量值作为其参数，而由 Julia 代码构造的表达式能以非字面量形式的任意运行期值作为其参数。在此特例中，\texttt{+} 和 \texttt{a} 都是符号，\texttt{*(b,c)} 是子表达式，而 \texttt{1} 是 64 位带符号整数字面量。



引用多个表达式有第二种语法形式：在 \texttt{quote ... end} 中包含代码块。




\begin{minted}{jlcon}
julia> ex = quote
           x = 1
           y = 2
           x + y
       end
quote
    #= none:2 =#
    x = 1
    #= none:3 =#
    y = 2
    #= none:4 =#
    x + y
end

julia> typeof(ex)
Expr
\end{minted}



\hypertarget{6473060285850683914}{}


\subsection{插值}



使用值参数直接构造 \hyperlink{17120496304147995299}{\texttt{Expr}} 对象虽然很强大，但与「通常的」 Julia 语法相比，\texttt{Expr} 构造函数可能让人觉得乏味。作为替代方法，Julia 允许将字面量或表达式插入到被引用的表达式中。表达式插值由前缀 \texttt{\$} 表示。



在此示例中，插入了变量 \texttt{a} 的值：




\begin{minted}{jlcon}
julia> a = 1;

julia> ex = :($a + b)
:(1 + b)
\end{minted}



对未被引用的表达式进行插值是不支持的，这会导致编译期错误：




\begin{minted}{jlcon}
julia> $a + b
ERROR: syntax: "$" expression outside quote
\end{minted}



在此示例中，元组 \texttt{(1,2,3)} 作为表达式插入到条件测试中：




\begin{minted}{jlcon}
julia> ex = :(a in $:((1,2,3)) )
:(a in (1, 2, 3))
\end{minted}



在表达式插值中使用 \texttt{\$} 是有意让人联想到\hyperlink{4452850363638134205}{字符串插值}和\hyperlink{3603331931999023419}{命令插值}。表达式插值使得复杂 Julia 表达式的程序化构造变得方便和易读。



\hypertarget{12062767751485347352}{}


\subsection{Splatting 插值}



请注意，\texttt{\$} 插值语法只允许插入单个表达式到包含它的表达式中。有时，你手头有个由表达式组成的数组，需要它们都变成其所处表达式的参数，而这可通过 \texttt{\$(xs...)} 语法做到。例如，下面的代码生成了一个函数调用，其参数数量通过编程确定：




\begin{minted}{jlcon}
julia> args = [:x, :y, :z];

julia> :(f(1, $(args...)))
:(f(1, x, y, z))
\end{minted}



\hypertarget{15842920146318002847}{}


\subsection{嵌套引用}



自然地，引用表达式可以包含在其它引用表达式中。插值在这些情形中的工作方式可能会有点难以理解。考虑这个例子：




\begin{minted}{jlcon}
julia> x = :(1 + 2);

julia> e = quote quote $x end end
quote
    #= none:1 =#
    $(Expr(:quote, quote
    #= none:1 =#
    $(Expr(:$, :x))
end))
end
\end{minted}



Notice that the result contains \texttt{\$x}, which means that \texttt{x} has not been evaluated yet. In other words, the \texttt{\$} expression {\textquotedbl}belongs to{\textquotedbl} the inner quote expression, and so its argument is only evaluated when the inner quote expression is:




\begin{minted}{jlcon}
julia> eval(e)
quote
    #= none:1 =#
    1 + 2
end
\end{minted}



但是，外部 \texttt{quote} 表达式可以把值插入到内部引用表达式的 \texttt{\$} 中去。这通过多个 \texttt{\$} 实现：




\begin{minted}{jlcon}
julia> e = quote quote $$x end end
quote
    #= none:1 =#
    $(Expr(:quote, quote
    #= none:1 =#
    $(Expr(:$, :(1 + 2)))
end))
end
\end{minted}



Notice that \texttt{(1 + 2)} now appears in the result instead of the symbol \texttt{x}. Evaluating this expression yields an interpolated \texttt{3}:




\begin{minted}{jlcon}
julia> eval(e)
quote
    #= none:1 =#
    3
end
\end{minted}



这种行为背后的直觉是每个 \texttt{\$} 都将 \texttt{x} 求值一遍：一个 \texttt{\$} 工作方式类似于 \texttt{eval(:x)}，其返回 \texttt{x} 的值，而两个 \texttt{\$} 行为相当于 \texttt{eval(eval(:x))}。



\hypertarget{15194695339988120385}{}


\subsection{QuoteNode}



\texttt{quote} 形式在 AST 中通常表示为一个 head 为 \texttt{:quote} 的 \hyperlink{17120496304147995299}{\texttt{Expr}} ：




\begin{minted}{jlcon}
julia> dump(Meta.parse(":(1+2)"))
Expr
  head: Symbol quote
  args: Array{Any}((1,))
    1: Expr
      head: Symbol call
      args: Array{Any}((3,))
        1: Symbol +
        2: Int64 1
        3: Int64 2
\end{minted}



正如我们所看到的，这些表达式支持插值符号 \texttt{\$}。但是，在某些情况下，需要在\emph{不执行}插值的情况下引用代码。 这种引用还没有语法，但在内部表示为 \texttt{QuoteNode} 类型的对象：




\begin{minted}{jlcon}
julia> eval(Meta.quot(Expr(:$, :(1+2))))
3

julia> eval(QuoteNode(Expr(:$, :(1+2))))
:($(Expr(:$, :(1 + 2))))
\end{minted}



解析器为简单的引用项（如符号）生成 \texttt{QuoteNode}：




\begin{minted}{jlcon}
julia> dump(Meta.parse(":x"))
QuoteNode
  value: Symbol x
\end{minted}



\texttt{QuoteNode} 也可用于某些高级的元编程任务。



\hypertarget{6779457931563322820}{}


\subsection{表达式求值}



给定一个表达式对象，可以使用 \hyperlink{7507639810592563424}{\texttt{eval}} 使 Julia 在全局作用域内评估（执行）它：




\begin{minted}{jlcon}
julia> ex1 = :(1 + 2)
:(1 + 2)

julia> eval(ex1)
3

julia> ex = :(a + b)
:(a + b)

julia> eval(ex)
ERROR: UndefVarError: b not defined
[...]

julia> a = 1; b = 2;

julia> eval(ex)
3
\end{minted}



每个\hyperlink{16725527896995457152}{模块}有自己的 \hyperlink{7507639810592563424}{\texttt{eval}} 函数，该函数在其全局作用域内对表达式求值。传给 \hyperlink{7507639810592563424}{\texttt{eval}} 的表达式不止可以返回值——它们还能具有改变封闭模块的环境状态的副作用：




\begin{minted}{jlcon}
julia> ex = :(x = 1)
:(x = 1)

julia> x
ERROR: UndefVarError: x not defined

julia> eval(ex)
1

julia> x
1
\end{minted}



这里，表达式对象的求值导致一个值被赋值给全局变量 \texttt{x}。



由于表达式只是 \texttt{Expr} 对象，而其可以通过编程方式构造然后对它求值，因此可以动态地生成任意代码，然后使用 \hyperlink{7507639810592563424}{\texttt{eval}} 运行所生成的代码。这是个简单的例子：




\begin{minted}{jlcon}
julia> a = 1;

julia> ex = Expr(:call, :+, a, :b)
:(1 + b)

julia> a = 0; b = 2;

julia> eval(ex)
3
\end{minted}



\texttt{a} 的值被用于构造表达式 \texttt{ex}，该表达式将函数 \texttt{+} 作用于值 1 和变量 \texttt{b}。请注意 \texttt{a} 和 \texttt{b} 使用方式间的重要区别：



\begin{itemize}
\item \emph{变量} \texttt{a} 在表达式构造时的值在表达式中用作立即值。因此，在对表达式求值时，\texttt{a} 的值就无关紧要了：表达式中的值已经是 \texttt{1}，与 \texttt{a} 的值无关。


\item 另一方面，因为在表达式构造时用的是符号 \texttt{:b}，所以变量 \texttt{b} 的值无关紧要——\texttt{:b} 只是一个符号，变量 \texttt{b} 甚至无需被定义。然而，在表达式求值时，符号 \texttt{:b} 的值通过寻找变量 \texttt{b} 的值来解析。

\end{itemize}


\hypertarget{2578517908282982662}{}


\subsection{关于表达式的函数}



如上所述，Julia 能在其内部生成和操作 Julia 代码，这是个非常有用的功能。我们已经见过返回 \hyperlink{17120496304147995299}{\texttt{Expr}} 对象的函数例子：\hyperlink{14207407853646164654}{\texttt{parse}} 函数，它接受字符串形式的 Julia 代码并返回相应的 \texttt{Expr}。函数也可以接受一个或多个 \texttt{Expr} 对象作为参数，并返回另一个 \texttt{Expr}。这是个简单、提神的例子：




\begin{minted}{jlcon}
julia> function math_expr(op, op1, op2)
           expr = Expr(:call, op, op1, op2)
           return expr
       end
math_expr (generic function with 1 method)

julia>  ex = math_expr(:+, 1, Expr(:call, :*, 4, 5))
:(1 + 4 * 5)

julia> eval(ex)
21
\end{minted}



作为另一个例子，这个函数将数值参数加倍，但不处理表达式：




\begin{minted}{jlcon}
julia> function make_expr2(op, opr1, opr2)
           opr1f, opr2f = map(x -> isa(x, Number) ? 2*x : x, (opr1, opr2))
           retexpr = Expr(:call, op, opr1f, opr2f)
           return retexpr
       end
make_expr2 (generic function with 1 method)

julia> make_expr2(:+, 1, 2)
:(2 + 4)

julia> ex = make_expr2(:+, 1, Expr(:call, :*, 5, 8))
:(2 + 5 * 8)

julia> eval(ex)
42
\end{minted}



\hypertarget{11146454106624591870}{}


\section{宏}



宏提供了一种机制，可以将生成的代码包含在程序的最终主体中。 宏将一组参数映射到返回的 \emph{表达式}，并且生成的表达式被直接编译，而不需要运行时 \hyperlink{7507639810592563424}{\texttt{eval}} 调用。 宏参数可能包括表达式、字面量和符号。



\hypertarget{13022711559815737661}{}


\subsection{基础}



这是一个非常简单的宏：




\begin{minted}{jlcon}
julia> macro sayhello()
           return :( println("Hello, world!") )
       end
@sayhello (macro with 1 method)
\end{minted}



宏在Julia的语法中有一个专门的字符 \texttt{@} (at-sign)，紧接着是其使用\texttt{macro NAME ... end} 形式来声明的唯一的宏名。在这个例子中，编译器会把所有的\texttt{@sayhello} 替换成：




\begin{minted}{julia}
:( println("Hello, world!") )
\end{minted}



当 \texttt{@sayhello} 在REPL中被输入时，解释器立即执行，因此我们只会看到计算后的结果：




\begin{minted}{jlcon}
julia> @sayhello()
Hello, world!
\end{minted}



现在，考虑一个稍微复杂一点的宏：




\begin{minted}{jlcon}
julia> macro sayhello(name)
 return :( println("Hello, ", $name) )
 end
@sayhello (macro with 1 method)
\end{minted}



这个宏接受一个参数\texttt{name}。当遇到\texttt{@sayhello}时，quoted 表达式会被\emph{展开}并将参数中的值插入到最终的表达式中：




\begin{minted}{jlcon}
julia> @sayhello("human")
Hello, human
\end{minted}



我们可以使用函数 \hyperlink{8018172489611994488}{\texttt{macroexpand}} 查看引用的返回表达式（\textbf{重要提示：} 这是一个非常有用的调试宏的工具）：




\begin{lstlisting}
julia> ex = macroexpand(Main, :(@sayhello("human")) )
:(Main.println("Hello, ", "human"))

julia> typeof(ex)
Expr
\end{lstlisting}



我们可以看到 \texttt{{\textquotedbl}human{\textquotedbl}} 字面量已被插入到表达式中了。



还有一个宏 \href{@ ref}{\texttt{@ macroexpand}}，它可能比 \texttt{macroexpand} 函数更方便：




\begin{minted}{jlcon}
julia> @macroexpand @sayhello "human"
:(println("Hello, ", "human"))
\end{minted}



\hypertarget{3309771807091105309}{}


\subsection{停：为什么需要宏？}



我们已经在上一节中看到了一个函数 \texttt{f(::Expr...) -> Expr}。 其实\hyperlink{8018172489611994488}{\texttt{macroexpand}}也是这样一个函数。 那么，为什么会要设计宏呢？



宏是必需的，因为它们在解析代码时执行，因此，宏允许程序员在运行完整程序\emph{之前}生成定制代码的片段。 为了说明差异，请考虑以下示例：




\begin{lstlisting}
julia> macro twostep(arg)
           println("I execute at parse time. The argument is: ", arg)
           return :(println("I execute at runtime. The argument is: ", $arg))
       end
@twostep (macro with 1 method)

julia> ex = macroexpand(Main, :(@twostep :(1, 2, 3)) );
I execute at parse time. The argument is: :((1, 2, 3))
\end{lstlisting}



第一个 \hyperlink{783803254548423222}{\texttt{println}} 调用在调用 \hyperlink{8018172489611994488}{\texttt{macroexpand}} 时执行。生成的表达式\emph{只}包含第二个 \texttt{println}：




\begin{lstlisting}
julia> typeof(ex)
Expr

julia> ex
:(println("I execute at runtime. The argument is: ", $(Expr(:copyast, :($(QuoteNode(:((1, 2, 3)))))))))

julia> eval(ex)
I execute at runtime. The argument is: (1, 2, 3)
\end{lstlisting}



\hypertarget{14488850884072492512}{}


\subsection{宏的调用}



宏的通常调用语法如下：




\begin{minted}{julia}
@name expr1 expr2 ...
@name(expr1, expr2, ...)
\end{minted}



请注意，在宏名称前的标志 \texttt{@}，且在第一种形式中参数表达式间没有逗号，而在第二种形式中 \texttt{@name} 后没有空格。这两种风格不应混淆。例如，下列语法不同于上述例子；它把元组 \texttt{(expr1, expr2, ...)} 作为参数传给宏：




\begin{minted}{julia}
@name (expr1, expr2, ...)
\end{minted}



在数组字面量（或推导式）上调用宏的另一种方法是不使用括号直接并列两者。在这种情况下，数组将是唯一的传给宏的表达式。以下语法等价（且与 \texttt{@name [a b] * v} 不同）：




\begin{minted}{julia}
@name[a b] * v
@name([a b]) * v
\end{minted}



在这着重强调，宏把它们的参数作为表达式、字面量或符号接收。浏览宏参数的一种方法是在宏的内部调用 \hyperlink{4561869563484222675}{\texttt{show}} 函数：




\begin{minted}{jlcon}
julia> macro showarg(x)
           show(x)
           # ... remainder of macro, returning an expression
       end
@showarg (macro with 1 method)

julia> @showarg(a)
:a

julia> @showarg(1+1)
:(1 + 1)

julia> @showarg(println("Yo!"))
:(println("Yo!"))
\end{minted}



除了给定的参数列表，每个宏都会传递名为 \texttt{\_\_source\_\_} 和 \texttt{\_\_module\_\_} 的额外参数。



参数 \texttt{\_\_source\_\_} 提供 \texttt{@} 符号在宏调用处的解析器位置的相关信息（以 \texttt{LineNumberNode} 对象的形式）。这使得宏能包含更好的错误诊断信息，其通常用于日志记录、字符串解析器宏和文档，比如，用于实现 \hyperlink{277452200962288519}{\texttt{@\_\_LINE\_\_}}、\hyperlink{1518763743618824993}{\texttt{@\_\_FILE\_\_}} 和 \hyperlink{12719499456415901450}{\texttt{@\_\_DIR\_\_}} 宏。



引用 \texttt{\_\_source\_\_.line} 和 \texttt{\_\_source\_\_.file} 即可访问位置信息：




\begin{minted}{jlcon}
julia> macro __LOCATION__(); return QuoteNode(__source__); end
@__LOCATION__ (macro with 1 method)

julia> dump(
            @__LOCATION__(
       ))
LineNumberNode
  line: Int64 2
  file: Symbol none
\end{minted}



参数 \texttt{\_\_module\_\_} 提供宏调用展开处的上下文相关信息（以 \texttt{Module} 对象的形式）。这允许宏查找上下文相关的信息，比如现有的绑定，或者将值作为附加参数插入到一个在当前模块中进行自我反射的运行时函数调用中。



\hypertarget{12271969370439662350}{}


\subsection{构建高级的宏}



这是 Julia 的 \hyperlink{4796942656392369899}{\texttt{@assert}} 宏的简化定义：




\begin{minted}{jlcon}
julia> macro assert(ex)
           return :( $ex ? nothing : throw(AssertionError($(string(ex)))) )
       end
@assert (macro with 1 method)
\end{minted}



这个宏可以像这样使用：




\begin{minted}{jlcon}
julia> @assert 1 == 1.0

julia> @assert 1 == 0
ERROR: AssertionError: 1 == 0
\end{minted}



宏调用在解析时扩展为其返回结果，并替代已编写的语法。这相当于编写：




\begin{minted}{julia}
1 == 1.0 ? nothing : throw(AssertionError("1 == 1.0"))
1 == 0 ? nothing : throw(AssertionError("1 == 0"))
\end{minted}



也就是说，在第一个调用中，表达式 \texttt{:(1 == 1.0)} 拼接到测试条件槽中，而 \texttt{string(:(1 == 1.0))} 拼接到断言信息槽中。如此构造的表达式会被放置在发生 \texttt{@assert} 宏调用处的语法树。然后在执行时，如果测试表达式的计算结果为真，则返回 \hyperlink{9331422207248206047}{\texttt{nothing}}，但如果测试结果为假，则会引发错误，表明声明的表达式为假。请注意，将其编写为函数是不可能的，因为能获取的只有条件的\emph{值}而无法在错误信息中显示计算出它的表达式。



在 Julia Base 中，\texttt{@assert} 的实际定义更复杂。它允许用户可选地制定自己的错误信息，而不仅仅是打印断言失败的表达式。与函数一样，具有可变数量的参数（ \hyperlink{9965084594348935329}{变参函数}）可在最后一个参数后面用省略号指定：




\begin{minted}{jlcon}
julia> macro assert(ex, msgs...)
           msg_body = isempty(msgs) ? ex : msgs[1]
           msg = string(msg_body)
           return :($ex ? nothing : throw(AssertionError($msg)))
       end
@assert (macro with 1 method)
\end{minted}



现在\texttt{@assert} 有两种操作模式，这取决于它接收到的参数数量！如果只有一个参数，\texttt{msgs} 捕获的表达式元组将为空，并且其行为与上面更简单的定义相同。 但是现在如果用户指定了第二个参数，它会打印在消息正文中而不是不相等的表达式中。你可以使用恰当命名的 \hyperlink{14913190777653949565}{\texttt{@macroexpand}} 宏检查宏展开的结果：




\begin{lstlisting}
julia> @macroexpand @assert a == b
:(if Main.a == Main.b
        Main.nothing
    else
        Main.throw(Main.AssertionError("a == b"))
    end)

julia> @macroexpand @assert a==b "a should equal b!"
:(if Main.a == Main.b
        Main.nothing
    else
        Main.throw(Main.AssertionError("a should equal b!"))
    end)
\end{lstlisting}



实际的 \texttt{@assert} 宏还处理了另一种情形：我们如果除了打印「a should equal b」外还想打印它们的值？有人也许会天真地尝试在自定义消息中使用字符串插值，例如，\texttt{@assert a==b {\textquotedbl}a (\$a) should equal b (\$b)!{\textquotedbl}}，但这不会像上面的宏一样按预期工作。你能想到为什么吗？回想一下\hyperlink{4452850363638134205}{字符串插值}，内插字符串会被重写为 \hyperlink{7919678712989769360}{\texttt{string}} 的调用。比较：




\begin{minted}{jlcon}
julia> typeof(:("a should equal b"))
String

julia> typeof(:("a ($a) should equal b ($b)!"))
Expr

julia> dump(:("a ($a) should equal b ($b)!"))
Expr
  head: Symbol string
  args: Array{Any}((5,))
    1: String "a ("
    2: Symbol a
    3: String ") should equal b ("
    4: Symbol b
    5: String ")!"
\end{minted}



所以，现在宏在 \texttt{msg\_body} 中获得的不是单纯的字符串，其接收了一个完整的表达式，该表达式需进行求值才能按预期显示。这可作为 \hyperlink{7919678712989769360}{\texttt{string}} 调用的参数直接拼接到返回的表达式中；有关完整实现，请参阅 \href{https://github.com/JuliaLang/julia/blob/master/base/error.jl}{\texttt{error.jl}}。



\texttt{@assert} 宏充分利用拼接被引用的表达式，以便简化对宏内部表达式的操作。



\hypertarget{12123968542051578223}{}


\subsection{卫生宏}



在更复杂的宏中会出现关于\href{https://en.wikipedia.org/wiki/Hygienic\_macro}{卫生宏} 的问题。简而言之，宏必须确保在其返回表达式中引入的变量不会意外地与其展开处周围代码中的现有变量相冲突。相反，作为参数传递给宏的表达式通常被\emph{认为}在其周围代码的上下文中进行求值，与现有变量交互并修改之。另一个问题源于这样的事实：宏可以在不同于其定义所处模块的模块中调用。在这种情况下，我们需要确保所有全局变量都被解析到正确的模块中。Julia 比使用文本宏展开的语言（比如 C）具有更大的优势，因为它只需要考虑返回的表达式。所有其它变量（例如上面\texttt{@assert} 中的 \texttt{msg}）遵循\hyperlink{11957539949537805757}{通常的作用域块规则}。



为了演示这些问题，让我们来编写宏 \texttt{@time}，其以表达式为参数，记录当前时间，对表达式求值，再次记录当前时间，打印前后的时间差，然后以表达式的值作为其最终值。该宏可能看起来就像这样：




\begin{minted}{julia}
macro time(ex)
    return quote
        local t0 = time_ns()
        local val = $ex
        local t1 = time_ns()
        println("elapsed time: ", (t1-t0)/1e9, " seconds")
        val
    end
end
\end{minted}



在这里，我们希望 \texttt{t0}、\texttt{t1} 和 \texttt{val} 成为私有临时变量，并且我们希望 \texttt{time\_ns} 引用 Julia Base 中的 \hyperlink{3638234932564609978}{\texttt{time\_ns}} 函数，而不是任何用户可能拥有的 \texttt{time\_ns} 变量（同样适用于 \texttt{println}）。 想象一下，如果用户表达式 \texttt{ex} 还包含对名为 \texttt{t0} 的变量的赋值，或者定义了自己的 \texttt{time\_ns} 变量，可能会出现什么问题。 程序可能会报错，或者进行未知的行为。



Julia 的宏展开器通过以下方式解决了这些问题。 首先，宏结果中的变量分为局部变量或全局变量。 如果变量被赋值（并且不是声明为全局的）、声明为局部、或用作函数参数名称，则该变量被视为局部变量。 否则，它被认为是全局的。 然后将局部变量重命名为唯一的（使用 \hyperlink{3515345868651201289}{\texttt{gensym}} 函数，该函数生成新符号），并在宏定义环境中解析全局变量。 因此，上述两个问题都得到了处理； 宏的局部变量不会与任何用户变量冲突，并且 \texttt{time\_ns} 和 \texttt{println} 将引用 Julia Base 定义。



然而，仍有另外的问题。考虑此宏的以下用法：




\begin{minted}{julia}
module MyModule
import Base.@time

time_ns() = ... # compute something

@time time_ns()
end
\end{minted}



这里的用户表达式\texttt{ex} 是对\texttt{time\_ns} 的调用，但与宏使用的\texttt{time\_ns} 函数不同。 它清楚地指向\texttt{MyModule.time\_ns}。 因此我们必须安排在宏调用环境中解析\texttt{ex}中的代码。 这是通过使用 \hyperlink{17861659594346526773}{\texttt{esc}}“转义”表达式来完成的：




\begin{minted}{julia}
macro time(ex)
    ...
    local val = $(esc(ex))
    ...
end
\end{minted}



以这种方式封装的表达式会被宏展开器单独保留，并将其简单地逐字粘贴到输出中。因此，它将在宏调用所处环境中解析。



这种转义机制可以在必要时用于「违反」卫生，以便于引入或操作用户变量。例如，以下宏在其调用所处环境中将 \texttt{x} 设置为零：




\begin{minted}{jlcon}
julia> macro zerox()
           return esc(:(x = 0))
       end
@zerox (macro with 1 method)

julia> function foo()
           x = 1
           @zerox
           return x # is zero
       end
foo (generic function with 1 method)

julia> foo()
0
\end{minted}



应当明智地使用这种变量操作，但它偶尔会很方便。



获得正确的规则也许是个艰巨的挑战。在使用宏之前，你可以去考虑是否函数闭包便已足够。另一个有用的策略是将尽可能多的工作推迟到运行时。例如，许多宏只是将其参数封装为 \texttt{QuoteNode} 或类似的 \hyperlink{17120496304147995299}{\texttt{Expr}}。这方面的例子有 \texttt{@task body}，它只返回 \texttt{schedule(Task(() -> \$body))}， 和 \texttt{@eval expr}，它只返回 \texttt{eval(QuoteNode(expr))}。



为了演示，我们可以将上面的 \texttt{@time} 示例重新编写成：




\begin{minted}{julia}
macro time(expr)
    return :(timeit(() -> $(esc(expr))))
end
function timeit(f)
    t0 = time_ns()
    val = f()
    t1 = time_ns()
    println("elapsed time: ", (t1-t0)/1e9, " seconds")
    return val
end
\end{minted}



但是，我们不这样做也是有充分理由的：将 \texttt{expr} 封装在新的作用域块（该匿名函数）中也会稍微改变该表达式的含义（其中任何变量的作用域），而我们想要 \texttt{@time} 使用时对其封装的代码影响最小。



\hypertarget{11371303288264026631}{}


\subsection{宏与派发}



与 Julia 函数一样，宏也是泛型的。由于多重派发，这意味着宏也能有多个方法定义：




\begin{minted}{jlcon}
julia> macro m end
@m (macro with 0 methods)

julia> macro m(args...)
           println("$(length(args)) arguments")
       end
@m (macro with 1 method)

julia> macro m(x,y)
           println("Two arguments")
       end
@m (macro with 2 methods)

julia> @m "asd"
1 arguments

julia> @m 1 2
Two arguments
\end{minted}



但是应该记住，宏派发基于传递给宏的 AST 的类型，而不是 AST 在运行时进行求值的类型：




\begin{minted}{jlcon}
julia> macro m(::Int)
           println("An Integer")
       end
@m (macro with 3 methods)

julia> @m 2
An Integer

julia> x = 2
2

julia> @m x
1 arguments
\end{minted}



\hypertarget{4927517878935278303}{}


\section{代码生成}



当需要大量重复的样板代码时，为了避免冗余，通常以编程方式生成它。在大多数语言中，这需要一个额外的构建步骤以及生成重复代码的独立程序。在 Julia 中，表达式插值和 \hyperlink{7507639810592563424}{\texttt{eval}} 允许在通常的程序执行过程中生成这些代码。例如，考虑下列自定义类型




\begin{minted}{julia}
struct MyNumber
    x::Float64
end
# output

\end{minted}



我们想为该类型添加一些方法。在下面的循环中，我们以编程的方式完成此工作：




\begin{minted}{julia}
for op = (:sin, :cos, :tan, :log, :exp)
    eval(quote
        Base.$op(a::MyNumber) = MyNumber($op(a.x))
    end)
end
# output

\end{minted}



现在，我们对自定义类型调用这些函数：




\begin{minted}{jlcon}
julia> x = MyNumber(π)
MyNumber(3.141592653589793)

julia> sin(x)
MyNumber(1.2246467991473532e-16)

julia> cos(x)
MyNumber(-1.0)
\end{minted}



在这种方法中，Julia 充当了自己的\href{https://en.wikipedia.org/wiki/Preprocessor}{预处理器}，并且允许从语言内部生成代码。使用 \texttt{:} 前缀的引用形式编写上述代码会使其更简洁：




\begin{minted}{julia}
for op = (:sin, :cos, :tan, :log, :exp)
    eval(:(Base.$op(a::MyNumber) = MyNumber($op(a.x))))
end
\end{minted}



不管怎样，这种使用 \texttt{eval(quote(...))} 模式生成语言内部的代码很常见，为此，Julia 自带了一个宏来缩写该模式：




\begin{minted}{julia}
for op = (:sin, :cos, :tan, :log, :exp)
    @eval Base.$op(a::MyNumber) = MyNumber($op(a.x))
end
\end{minted}



\hyperlink{12895501458291832858}{\texttt{@eval}} 重写此调用，使其与上面的较长版本完全等价。为了生成较长的代码块，可以把一个代码块作为表达式参数传给 \hyperlink{12895501458291832858}{\texttt{@eval}}：




\begin{minted}{julia}
@eval begin
    # multiple lines
end
\end{minted}



\hypertarget{978710492036418407}{}


\section{非标准字符串字面量}



回想一下在\hyperlink{6548320458095485939}{字符串}的文档中，以标识符为前缀的字符串字面量被称为非标准字符串字面量，它们可以具有与未加前缀的字符串字面量不同的语义。例如：



\begin{itemize}
\item \texttt{r{\textquotedbl}{\textasciicircum}{\textbackslash}s*(?:\#|\$){\textquotedbl}} 产生一个\hyperlink{17292082084708718801}{正则表达式对象}而不是一个字符串


\item \texttt{b{\textquotedbl}DATA{\textbackslash}xff{\textbackslash}u2200{\textquotedbl}} 是一个\hyperlink{1529513445769909572}{字节数组字面量} ，表示\texttt{[68,65,84,65,255,226,136,128]}。

\end{itemize}


可能令人惊讶的是，这些行为并没有被硬编码到 Julia 的解释器或编译器中。相反，它们是由一个通用机制实现的自定义行为，且任何人都可以使用该机制：带前缀的字符串字面量被解析为特定名称的宏的调用。例如，正则表达式宏如下：




\begin{minted}{julia}
macro r_str(p)
    Regex(p)
end
\end{minted}



这便是全部代码。这个宏说的是字符串字面量 \texttt{r{\textquotedbl}{\textasciicircum}{\textbackslash}s*(?:\#|\$){\textquotedbl}} 的字面内容应该传给宏 \texttt{@r\_str}，并且展开后的结果应当放在该字符串字面量出现处的语法树中。换句话说，表达式 \texttt{r{\textquotedbl}{\textasciicircum}{\textbackslash}s*(?:\#|\$){\textquotedbl}} 等价于直接把下列对象放进语法树中：




\begin{minted}{julia}
Regex("^\\s*(?:#|\$)")
\end{minted}



字符串字面量形式不仅更短、更方便，也更高效：因为正则表达式需要编译，\texttt{Regex} 对象实际上是\emph{在编译代码时}创建的，所以编译只发生一次，而不是每次执行代码时都再编译一次。请考虑如果正则表达式出现在循环中：




\begin{minted}{julia}
for line = lines
    m = match(r"^\s*(?:#|$)", line)
    if m === nothing
        # non-comment
    else
        # comment
    end
end
\end{minted}



因为正则表达式 \texttt{r{\textquotedbl}{\textasciicircum}{\textbackslash}s*(?:\#|\$){\textquotedbl}} 在这段代码解析时便已编译并被插入到语法树中，所以它只编译一次，而不是每次执行循环时都再编译一次。要在不使用宏的情况下实现此效果，必须像这样编写此循环：




\begin{minted}{julia}
re = Regex("^\\s*(?:#|\$)")
for line = lines
    m = match(re, line)
    if m === nothing
        # non-comment
    else
        # comment
    end
end
\end{minted}



此外，如果编译器无法确定在所有循环中正则表达式对象都是常量，可能无法进行某些优化，使得此版本的效率依旧低于上面的更方便的字面量形式。当然，在某些情况下，非字面量形式更方便：如果需要向正则表达式中插入变量，就必须采用这种更冗长的方法；如果正则表达式模式本身是动态的，可能在每次循环迭代时发生变化，就必须在每次迭代中构造新的正则表达式对象。然而，在绝大多数用例中，正则表达式不是基于运行时的数据构造的。在大多数情况下，将正则表达式编写为编译期值的能力是无法估量的。



用户定义字符串文字的机制非常强大。不仅使用它实现了 Julia 的非标准字面量，而且还使用以下看起来无害的宏实现了命令行字面量语法（\texttt{`echo {\textquotedbl}Hello, \$person{\textquotedbl}`}）：




\begin{minted}{julia}
macro cmd(str)
    :(cmd_gen($(shell_parse(str)[1])))
end
\end{minted}



当然，这个宏的定义中使用的函数隐藏了许多复杂性，但它们只是函数且完全用 Julia 编写。你可以阅读它们的源代码并精确地看到它们的行为——它们所做的一切就是构造要插入到你的程序的语法树的表达式对象。



与字符串字面量一样，命令行字面量也可以以标识符为前缀，以形成所谓的非标准命令行字面量。 这些命令行字面量被解析为对特殊命名的宏的调用。 例如，语法 \texttt{custom`literal`} 被解析为 \texttt{@custom\_cmd {\textquotedbl}literal{\textquotedbl}}。 Julia 本身不包含任何非标准的命令行字面量，但包可以使用这种语法。 除了不同的语法和 \texttt{\_cmd} 后缀而不是 \texttt{\_str} 后缀，非标准命令行字面量的行为与非标准字符串字面量完全一样。



如果两个模块提供了同名的非标准字符串或命令字面量，能使用模块名限定该字符串或命令字面量。例如，如果 \texttt{Foo} 和 \texttt{Bar} 提供了相同的字符串字面量 \texttt{@x\_str}，那么可以编写 \texttt{Foo.x{\textquotedbl}literal{\textquotedbl}} 或 \texttt{Bar.x{\textquotedbl}literal{\textquotedbl}} 来消除两者的歧义。



以下是另一种定义宏的方式：




\begin{minted}{julia}
macro foo_str(str, flag)
    # do stuff
end
\end{minted}



可以使用如下语法来调用这个宏




\begin{minted}{julia}
foo"str"flag
\end{minted}



上述语法中 flag 的类型可以是一个\texttt{String}，在字符串字面量之后包含的内容。



\hypertarget{925665269920917597}{}


\section{生成函数}



有个非常特殊的宏叫 \hyperlink{11479538870805927749}{\texttt{@generated}}，它允许你定义所谓的\emph{生成函数}。它们能根据其参数类型生成专用代码，与用多重派发所能实现的代码相比，其代码更灵活和/或少。虽然宏在解析时使用表达式且无法访问其输入值的类型，但是生成函数在参数类型已知时会被展开，但该函数尚未编译。



生成函数的声明不会执行某些计算或操作，而会返回一个被引用的表达式，接着该表达式构成参数类型所对应方法的主体。在调用生成函数时，其返回的表达式会被编译然后执行。为了提高效率，通常会缓存结果。为了能推断是否缓存结果，只能使用语言的受限子集。因此，生成函数提供了一个灵活的方式来将工作重运行时移到编译时，代价则是其构造能力受到更大的限制。



定义生成函数与普通函数有五个主要区别：



\begin{itemize}
\item[1. ] 使用 \texttt{@generated} 标注函数声明。这会向 AST 附加一些信息，让编译器知道这个函数是生成函数。


\item[2. ] 在生成函数的主体中，你只能访问参数的\emph{类型}，而不能访问其值，以及在生成函数的定义之前便已定义的任何函数。


\item[3. ] 不应计算某些东西或执行某些操作，应返回一个\emph{被引用的}表达式，它会在被求值时执行你想要的操作。


\item[4. ] 生成函数只允许调用在生成函数定义之前定义的函数。（如果不遵循这一点，引用来自未来世界的函数可能会导致 \texttt{MethodErrors} ）


\item[5. ] 生成函数不能\emph{更改}或\emph{观察}任何非常量的全局状态。（例如，其包括 IO、锁、非局部的字典或者使用 \texttt{hasmethod}）即它们只能读取全局常量，且没有任何副作用。换句话说，它们必须是纯函数。由于实现限制，这也意味着它们目前无法定义闭包或生成器。

\end{itemize}


举例子来说明这个是最简单的。我们可以将生成函数 \texttt{foo} 声明为




\begin{minted}{jlcon}
julia> @generated function foo(x)
           Core.println(x)
           return :(x * x)
       end
foo (generic function with 1 method)
\end{minted}



请注意，代码主体返回一个被引用的表达式，即 \texttt{:(x * x)}，而不仅仅是 \texttt{x * x} 的值。



从调用者的角度看，这与通常的函数等价；实际上，你无需知道你所调用的是通常的函数还是生成函数。让我们看看 \texttt{foo} 的行为：




\begin{minted}{jlcon}
julia> x = foo(2); # note: output is from println() statement in the body
Int64

julia> x           # now we print x
4

julia> y = foo("bar");
String

julia> y
"barbar"
\end{minted}



因此，我们知道在生成函数的主体中，\texttt{x} 是所传递参数的\emph{类型}，并且，生成函数的返回值是其定义所返回的被引用的表达式的求值结果，在该表达式求值时 \texttt{x} 表示其\emph{值}。



如果我们使用我们已经使用过的类型再次对 \texttt{foo} 求值会发生什么？




\begin{minted}{jlcon}
julia> foo(4)
16
\end{minted}



请注意，这里并没有打印 \hyperlink{7720564657383125058}{\texttt{Int64}}。我们可以看到对于特定的参数类型集来说，生成函数的主体只执行一次，且结果会被缓存。此后，对于此示例，生成函数首次调用返回的表达式被重新用作方法主体。但是，实际的缓存行为是由实现定义的性能优化，过于依赖此行为并不实际。



生成函数\emph{可能}只生成一次函数,但也\emph{可能}多次生成，或者看起来根本就没有生成过函数。因此，你应该\emph{从不}编写有副作用的生成函数——因为副作用发生的时间和频率是不确定的。（对于宏来说也是如此——跟宏一样，在生成函数中使用 \hyperlink{7507639810592563424}{\texttt{eval}} 也许意味着你正以错误的方式做某事。）但是，与宏不同，运行时系统无法正确处理对 \hyperlink{7507639810592563424}{\texttt{eval}} 的调用，所以不允许这样做。



理解 \texttt{@generated} 函数与方法的重定义间如何相互作用也很重要。遵循正确的 \texttt{@generated} 函数不能观察任何可变状态或导致全局状态的任何更改的原则，我们看到以下行为。观察到，生成函数\emph{不能}调用在生成函数本身的\emph{定义}之前未定义的任何方法。



一开始 \texttt{f(x)} 有一个定义




\begin{minted}{jlcon}
julia> f(x) = "original definition";
\end{minted}



定义使用 \texttt{f(x)} 的其它操作：




\begin{minted}{jlcon}
julia> g(x) = f(x);

julia> @generated gen1(x) = f(x);

julia> @generated gen2(x) = :(f(x));
\end{minted}



我们现在为 \texttt{f(x)} 添加几个新定义：




\begin{minted}{jlcon}
julia> f(x::Int) = "definition for Int";

julia> f(x::Type{Int}) = "definition for Type{Int}";
\end{minted}



并比较这些结果的差异：




\begin{minted}{jlcon}
julia> f(1)
"definition for Int"

julia> g(1)
"definition for Int"

julia> gen1(1)
"original definition"

julia> gen2(1)
"definition for Int"
\end{minted}



生成函数的每个方法都有自己的已定义函数视图：




\begin{minted}{jlcon}
julia> @generated gen1(x::Real) = f(x);

julia> gen1(1)
"definition for Type{Int}"
\end{minted}



上例中的生成函数 \texttt{foo} 能做的，通常的函数 \texttt{foo(x) = x * x} 也能做（除了在第一次调用时打印类型，并产生了更高的开销）。但是，生成函数的强大之处在于其能够根据传递给它的类型计算不同的被引用的表达式：




\begin{minted}{jlcon}
julia> @generated function bar(x)
           if x <: Integer
               return :(x ^ 2)
           else
               return :(x)
           end
       end
bar (generic function with 1 method)

julia> bar(4)
16

julia> bar("baz")
"baz"
\end{minted}



（当然，这个刻意的例子可以更简单地通过多重派发实现······）



滥用它会破坏运行时系统并导致未定义行为：




\begin{minted}{jlcon}
julia> @generated function baz(x)
           if rand() < .9
               return :(x^2)
           else
               return :("boo!")
           end
       end
baz (generic function with 1 method)
\end{minted}



由于生成函数的主体具有不确定性，其行为和\emph{所有后续代码的行为}并未定义。



\emph{不要复制这些例子！}



这些例子有助于说明生成函数定义和调用的工作方式；但是，\emph{不要复制它们}，原因如下：



\begin{itemize}
\item \texttt{foo} 函数有副作用（对 \texttt{Core.println} 的调用），并且未确切定义这些副作用发生的时间、频率和次数。


\item \texttt{bar} 函数解决的问题可通过多重派发被更好地解决——定义 \texttt{bar(x) = x} 和 \texttt{bar(x::Integer) = x {\textasciicircum} 2} 会做同样的事，但它更简单和快捷。


\item \texttt{baz} 函数是病态的

\end{itemize}


请注意，不应在生成函数中尝试的操作并无严格限制，且运行时系统现在只能检测一部分无效操作。还有许多操作只会破坏运行时系统而没有通知，通常以微妙的方式而非显然地与错误的定义相关联。因为函数生成器是在类型推导期间运行的，所以它必须遵守该代码的所有限制。



一些不应该尝试的操作包括：



\begin{itemize}
\item[1. ] 缓存本地指针。


\item[2. ] 以任何方式与 \texttt{Core.Compiler} 的内容或方法交互。


\item[3. ] 观察任何可变状态。

\begin{itemize}
\item 生成函数的类型推导可以在\emph{任何}时候运行，包括你的代码正在尝试观察或更改此状态时。

\end{itemize}

\item[4. ] 采用任何锁：你调用的 C 代码可以在内部使用锁（例如，调用 \texttt{malloc} 不会有问题，即使大多数实现在内部需要锁），但是不要试图在执行 Julia 代码时保持或请求任何锁。


\item[5. ] 调用在生成函数的主体后定义的任何函数。对于增量加载的预编译模块，则放宽此条件，以允许调用模块中的任何函数。

\end{itemize}


那好，我们现在已经更好地理解了生成函数的工作方式，让我们使用它来构建一些更高级（和有效）的功能……



\hypertarget{13559476639927770222}{}


\subsection{一个高级的例子}



Julia 的 base 库有个内部函数 \texttt{sub2ind}，用于根据一组 n 重线性索引计算 n 维数组的线性索引——换句话说，用于计算索引 \texttt{i}，其可用于使用 \texttt{A[i]} 来索引数组 \texttt{A}，而不是用 \texttt{A[x,y,z,...]}。一种可能的实现如下：




\begin{minted}{jlcon}
julia> function sub2ind_loop(dims::NTuple{N}, I::Integer...) where N
           ind = I[N] - 1
           for i = N-1:-1:1
               ind = I[i]-1 + dims[i]*ind
           end
           return ind + 1
       end
sub2ind_loop (generic function with 1 method)

julia> sub2ind_loop((3, 5), 1, 2)
4
\end{minted}



用递归可以完成同样的事情：




\begin{minted}{jlcon}
julia> sub2ind_rec(dims::Tuple{}) = 1;

julia> sub2ind_rec(dims::Tuple{}, i1::Integer, I::Integer...) =
           i1 == 1 ? sub2ind_rec(dims, I...) : throw(BoundsError());

julia> sub2ind_rec(dims::Tuple{Integer, Vararg{Integer}}, i1::Integer) = i1;

julia> sub2ind_rec(dims::Tuple{Integer, Vararg{Integer}}, i1::Integer, I::Integer...) =
           i1 + dims[1] * (sub2ind_rec(Base.tail(dims), I...) - 1);

julia> sub2ind_rec((3, 5), 1, 2)
4
\end{minted}



这两种实现虽然不同，但本质上做同样的事情：在数组维度上的运行时循环，将每个维度上的偏移量收集到最后的索引中。



然而，循环所需的信息都已嵌入到参数的类型信息中。因此，我们可以利用生成函数将迭代移动到编译期；用编译器的说法，我们用生成函数手动展开循环。代码主体变得几乎相同，但我们不是计算线性索引，而是建立计算索引的\emph{表达式}：




\begin{minted}{jlcon}
julia> @generated function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N
           ex = :(I[$N] - 1)
           for i = (N - 1):-1:1
               ex = :(I[$i] - 1 + dims[$i] * $ex)
           end
           return :($ex + 1)
       end
sub2ind_gen (generic function with 1 method)

julia> sub2ind_gen((3, 5), 1, 2)
4
\end{minted}



\textbf{这会生成什么代码？}



找出所生成代码的一个简单方法是将生成函数的主体提取到另一个（通常的）函数中：




\begin{minted}{jlcon}
julia> @generated function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N
           return sub2ind_gen_impl(dims, I...)
       end
sub2ind_gen (generic function with 1 method)

julia> function sub2ind_gen_impl(dims::Type{T}, I...) where T <: NTuple{N,Any} where N
           length(I) == N || return :(error("partial indexing is unsupported"))
           ex = :(I[$N] - 1)
           for i = (N - 1):-1:1
               ex = :(I[$i] - 1 + dims[$i] * $ex)
           end
           return :($ex + 1)
       end
sub2ind_gen_impl (generic function with 1 method)
\end{minted}



我们现在可以执行 \texttt{sub2ind\_gen\_impl} 并检查它所返回的表达式：




\begin{minted}{jlcon}
julia> sub2ind_gen_impl(Tuple{Int,Int}, Int, Int)
:(((I[1] - 1) + dims[1] * (I[2] - 1)) + 1)
\end{minted}



因此，这里使用的方法主体根本不包含循环——只有两个元组的索引、乘法和加法/减法。所有循环都是在编译期执行的，我们完全避免了在执行期间的循环。因此，我们只需对每个类型循环\emph{一次}，在本例中每个 \texttt{N} 循环一次（除了在该函数被多次生成的边缘情况——请参阅上面的免责声明）。



\hypertarget{2054450996027567500}{}


\subsection{可选地生成函数}



生成函数可以在运行时实现高效率，但需要编译时间成本：必须为具体的参数类型的每个组合生成新的函数体。通常，Julia 能够编译函数的「泛型」版本，其适用于任何参数，但对于生成函数，这是不可能的。这意味着大量使用生成函数的程序可能无法静态编译。



为了解决这个问题，语言提供用于编写生成函数的通常、非生成的替代实现的语法。应用于上面的 \texttt{sub2ind} 示例，它看起来像这样：




\begin{minted}{julia}
function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N
    if N != length(I)
        throw(ArgumentError("Number of dimensions must match number of indices."))
    end
    if @generated
        ex = :(I[$N] - 1)
        for i = (N - 1):-1:1
            ex = :(I[$i] - 1 + dims[$i] * $ex)
        end
        return :($ex + 1)
    else
        ind = I[N] - 1
        for i = (N - 1):-1:1
            ind = I[i] - 1 + dims[i]*ind
        end
        return ind + 1
    end
end
\end{minted}



在内部，这段代码创建了函数的两个实现：一个生成函数的实现，其使用 \texttt{if @generated} 中的第一个块，一个通常的函数的实现，其使用 \texttt{else} 块。在 \texttt{if @generated} 块的 \texttt{then} 部分中，代码与其它生成函数具有相同的语义：参数名称引用类型，且代码应返回表达式。可能会出现多个 \texttt{if @generated} 块，在这种情况下，生成函数的实现使用所有的 \texttt{then} 块，而替代实现使用所有的 \texttt{else} 块。



请注意，我们在函数顶部添加了错误检查。此代码对两个版本都是通用的，且是两个版本中的运行时代码（它将被引用并返回为生成函数版本中的表达式）。这意味着局部变量的值和类型在代码生成时不可用——用于代码生成的代码只能看到参数类型。



在这种定义方式中，代码生成功能本质上只是一种可选的优化。如果方便，编译器将使用它，否则可能选择使用通常的实现。这种方式是首选的，因为它允许编译器做出更多决策和以更多方式编译程序，还因为通常代码比由代码生成的代码更易读。但是，使用哪种实现取决于编译器实现细节，因此，两个实现的行为必须相同。



\hypertarget{12380164357355707963}{}


\chapter{多维数组}



与大多数科学计算语言一样，Julia 提供原生的数组实现。 大多数科学计算语言非常重视其数组实现，而牺牲了其他容器。Julia 没有以任何特殊方式处理数组。就像和其它用 Julia 写的代码一样，Julia 的数组库几乎完全是用 Julia 自身实现的，并且由编译器保证其性能。因此，也可以通过继承 \hyperlink{6514416309183787338}{\texttt{AbstractArray}} 来定义自定义数组类型。 有关实现自定义数组类型的更多详细信息，请参阅 \hyperlink{9718377734213742156}{AbstractArray 接口的手册部分}。



数组是存储在多维网格中对象的集合。在最一般的情况下， 数组中的对象可能是 \hyperlink{15014186392807667022}{\texttt{Any}} 类型。 对于大多数计算上的需求，数组中对象的类型应该更加具体，例如 \hyperlink{5027751419500983000}{\texttt{Float64}} 或 \hyperlink{10103694114785108551}{\texttt{Int32}}。



一般来说，与许多其他科学计算语言不同，Julia 不希望为了性能而以向量化的方式编写程序。Julia 的编译器使用类型推断，并为标量数组索引生成优化的代码，从而能够令用户方便地编写可读性良好的程序，而不牺牲性能，并且时常会减少内存使用。



在 Julia 中，所有函数的参数都是 \href{https://en.wikipedia.org/wiki/Evaluation\_strategy\#Call\_by\_sharing}{非复制的方式进行传递}的（比如说，通过指针传递）。一些科学计算语言用传值的方式传递数组，尽管这样做可以防止数组在被调函数中被意外地篡改，但这也会导致不必要的数组拷贝。作为 Julia 的一个惯例，以一个 \texttt{!} 结尾的函数名它会对自己的一个或者多个参数的值进行修改或者销毁（例如，请比较 \hyperlink{8473525809131227606}{\texttt{sort}} 和 \hyperlink{12296873681374954808}{\texttt{sort!}}）。被调函数必须进行显式拷贝，以确保它们不会无意中修改输入参数。很多不以\texttt{!}结尾的函数在实现的时候，都会先进行显式拷贝，然后调用一个以 \texttt{!} 结尾的同名函数，最后返回之前拷贝的副本。



\hypertarget{3050591823172658870}{}


\section{基本函数}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
函数 & 描述 \\
\hline
\hyperlink{6396209842929672718}{\texttt{eltype(A)}} & \texttt{A} 中元素的类型 \\
\hline
\hyperlink{3699181304419743826}{\texttt{length(A)}} & \texttt{A} 中元素的数量 \\
\hline
\hyperlink{1688406579181746010}{\texttt{ndims(A)}} & \texttt{A} 的维数 \\
\hline
\hyperlink{17888996102305087038}{\texttt{size(A)}} & 一个包含 \texttt{A} 各个维度上元素数量的元组 \\
\hline
\hyperlink{17888996102305087038}{\texttt{size(A,n)}} & \texttt{A} 第 \texttt{n} 维中的元素数量 \\
\hline
\hyperlink{7074821531920287868}{\texttt{axes(A)}} & 一个包含 \texttt{A} 有效索引的元组 \\
\hline
\hyperlink{7074821531920287868}{\texttt{axes(A,n)}} & 第 \texttt{n} 维有效索引的范围 \\
\hline
\hyperlink{4701773772897287974}{\texttt{eachindex(A)}} & 一个访问 \texttt{A} 中每一个位置的高效迭代器 \\
\hline
\hyperlink{97811245619734938}{\texttt{stride(A,k)}} & 在第 \texttt{k} 维上的间隔（stride）（相邻元素间的线性索引距离） \\
\hline
\hyperlink{13576557637670855932}{\texttt{strides(A)}} & 包含每一维上的间隔（stride）的元组 \\
\hline
\end{tabulary}

\end{table}



\hypertarget{10907259792659637782}{}


\section{构造和初始化}



Julia 提供了许多用于构造和初始化数组的函数。在下列函数中，参数 \texttt{dims ...} 可以是一个元组 tuple 来表示维数，也可以是一个可变长度的整数值作为维数。大部分函数的第一个参数都表示数组的元素类型 \texttt{T} 。如果类型 \texttt{T} 被省略，那么将默认为 \hyperlink{5027751419500983000}{\texttt{Float64}}。




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
函数 & 描述 \\
\hline
\hyperlink{15492651498431872487}{\texttt{Array\{T\}(undef, dims...)}} & 一个没有初始化的密集 \hyperlink{15492651498431872487}{\texttt{Array}} \\
\hline
\hyperlink{13837674686090348619}{\texttt{zeros(T, dims...)}} & 一个全零 \texttt{Array} \\
\hline
\hyperlink{5858390260510292771}{\texttt{ones(T, dims...)}} & 一个元素均为 1 的 \texttt{Array} \\
\hline
\hyperlink{12844393578243965152}{\texttt{trues(dims...)}} & 一个每个元素都为 \texttt{true} 的 \hyperlink{18015155802543401629}{\texttt{BitArray}} \\
\hline
\hyperlink{12518029339635756199}{\texttt{falses(dims...)}} & 一个每个元素都为 \texttt{false} 的 \texttt{BitArray} \\
\hline
\hyperlink{3388738163419525310}{\texttt{reshape(A, dims...)}} & 一个包含跟 \texttt{A} 相同数据但维数不同的数组 \\
\hline
\hyperlink{15665284441316555522}{\texttt{copy(A)}} & 拷贝 \texttt{A} \\
\hline
\hyperlink{3259459540194502889}{\texttt{deepcopy(A)}} & 深拷贝，即拷贝 \texttt{A}，并递归地拷贝其元素 \\
\hline
\hyperlink{15525808546723795098}{\texttt{similar(A, T, dims...)}} & 一个与\texttt{A}具有相同类型（这里指的是密集，稀疏等）的未初始化数组，但具有指定的元素类型和维数。第二个和第三个参数都是可选的，如果省略则默认为元素类型和 \texttt{A} 的维数。 \\
\hline
\hyperlink{293815781001952115}{\texttt{reinterpret(T, A)}} & 与 \texttt{A} 具有相同二进制数据的数组，但元素类型为 \texttt{T} \\
\hline
\hyperlink{7668863842145012694}{\texttt{rand(T, dims...)}} & 一个随机 \texttt{Array}，元素值是  \([0, 1)\)  半开区间中的均匀分布且服从一阶独立同分布 \footnotemark[1] \\
\hline
\hyperlink{7347069443766288058}{\texttt{randn(T, dims...)}} & 一个随机 \texttt{Array}，元素为标准正态分布，服从独立同分布 \\
\hline
\hyperlink{5448927444601277512}{\texttt{Matrix\{T\}(I, m, n)}} & \texttt{m} 行 \texttt{n} 列的单位矩阵 （需要先执行 \texttt{using LinearAlgebra} 来才能使用 \hyperlink{15346645596018210602}{\texttt{I}}） \\
\hline
\hyperlink{737600656772861535}{\texttt{range(start, stop=stop, length=n)}} & 从 \texttt{start} 到 \texttt{stop} 的带有 \texttt{n} 个线性间隔元素的范围 \\
\hline
\hyperlink{5162290739791026948}{\texttt{fill!(A, x)}} & 用值 \texttt{x} 填充数组 \texttt{A} \\
\hline
\hyperlink{2836152204730819918}{\texttt{fill(x, dims...)}} & 一个被值 \texttt{x} 填充的 \texttt{Array} \\
\hline
\end{tabulary}

\end{table}



\footnotetext[1]{\emph{iid}，独立同分布

}


要查看各种方法，我们可以将不同维数传递给这些构造函数，请考虑以下示例：




\begin{minted}{jlcon}
julia> zeros(Int8, 2, 3)
2×3 Matrix{Int8}:
 0  0  0
 0  0  0

julia> zeros(Int8, (2, 3))
2×3 Matrix{Int8}:
 0  0  0
 0  0  0

julia> zeros((2, 3))
2×3 Matrix{Float64}:
 0.0  0.0  0.0
 0.0  0.0  0.0
\end{minted}



此处, \texttt{(2, 3)} 是一个元组 \hyperlink{17462354060312563026}{\texttt{Tuple}} 并且第一个参数——元素类型是可选的, 默认值为 \texttt{Float64}.



\hypertarget{15443953423472878802}{}


\section{数组常量}



数组也可以直接用方括号来构造; 语法为 \texttt{[A, B, C, ...]} 创建一个一维数组(即一个向量)，该一维数组的元素用逗号分隔。所创建的数组中元素的类型(\hyperlink{6396209842929672718}{\texttt{eltype}}) 自动由括号内参数的类型确定。如果所有参数类型都相同，则该类型称为数组的 \texttt{eltype}。 如果所有元素都有相同的\hyperlink{10374023657104680331}{promotion type}，那么个元素都由\hyperlink{1846942650946171605}{\texttt{convert}}转换成该类型并且该类型为数组的 \texttt{eltype}. 否则, 生成一个可以包含任意类型的异构数组—— \texttt{Vector\{Any\}} ;该构造方法包含字符 \texttt{[]}，此时构造过程无参数给出。




\begin{minted}{jlcon}
julia> [1,2,3] # 元素类型为 Int 的向量
3-element Vector{Int64}:
 1
 2
 3

julia> promote(1, 2.3, 4//5) # Int, Float64 以及 Rational 类型放在一起则会提升到 Float64
(1.0, 2.3, 0.8)

julia> [1, 2.3, 4//5] # 从而它就是这个矩阵的元素类型
3-element Vector{Float64}:
 1.0
 2.3
 0.8

julia> []
Any[]
\end{minted}



\hypertarget{8665822927896221545}{}


\subsection{数组拼接}



如果方括号里的参数不是由逗号分隔，而是由单个分号(\texttt{;}) 或者换行符分隔，那么每一个参数就不再解析为一个单独的数组元素，而是纵向拼接起来。  




\begin{minted}{jlcon}
julia> [1:2, 4:5] # 这里有一个逗号，因此并不会发生矩阵的拼接。这里居然的元素本身就是这些 range
2-element Vector{UnitRange{Int64}}:
 1:2
 4:5

julia> [1:2; 4:5]
4-element Vector{Int64}:
 1
 2
 4
 5

julia> [1:2
        4:5
        6]
5-element Vector{Int64}:
 1
 2
 4
 5
 6
\end{minted}



类似的，如果这些参数是被制表符、空格符或者两个分号所分隔，那么它们的内容就\emph{横向拼接}在一起。




\begin{minted}{jlcon}
julia> [1:2  4:5  7:8]
2×3 Matrix{Int64}:
 1  4  7
 2  5  8

julia> [[1,2]  [4,5]  [7,8]]
2×3 Matrix{Int64}:
 1  4  7
 2  5  8

julia> [1 2 3] # 数字可以被横向拼接
1×3 Matrix{Int64}:
 1  2  3

julia> [1;; 2;; 3;; 4]
1×4 Matrix{Int64}:
 1  2  3  4
\end{minted}



单个分号（或换行符）和空格（或制表符）可以被结合起来使用进行横向或者纵向的拼接。




\begin{minted}{jlcon}
julia> [1 2
        3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia> [zeros(Int, 2, 2) [1; 2]
        [3 4]            5]
3×3 Matrix{Int64}:
 0  0  1
 0  0  2
 3  4  5

julia> [[1 1]; 2 3; [4 4]]
3×2 Matrix{Int64}:
 1  1
 2  3
 4  4
\end{minted}



空格（和制表符）的优先级高于分号，首先执行任何纵向拼接，然后拼接结果。 另一方面，使用双分号进行水平连接时，先纵向拼接再横向拼接。




\begin{minted}{jlcon}
julia> [zeros(Int, 2, 2) ; [3 4] ;; [1; 2] ; 5]
3×3 Matrix{Int64}:
 0  0  1
 0  0  2
 3  4  5

julia> [1:2; 4;; 1; 3:4]
3×2 Matrix{Int64}:
 1  1
 2  3
 4  4
\end{minted}



正如 \texttt{;} 和 \texttt{;;} 在第一维和第二维中拼接一样，使用更多的分号扩展了相同的通用方案。 分隔符中的分号数指定了特定的维度，因此\texttt{;;;} 在第三个维度中拼接，\texttt{;;;;} 在第四个维度中，依此类推。 较少的分号优先级高，因此较低的维度通常首先拼接。




\begin{minted}{jlcon}
julia> [1; 2;; 3; 4;; 5; 6;;;
        7; 8;; 9; 10;; 11; 12]
2×3×2 Array{Int64, 3}:
[:, :, 1] =
 1  3  5
 2  4  6

[:, :, 2] =
 7   9  11
 8  10  12
\end{minted}



像之前一样，用于水平拼接的空格（和制表符）的优先级高于任何数量的分号。 因此，高维数组也可以通过首先指定它们的行来编写，它们的元素以类似于它们的布局的方式进行文本排列：




\begin{minted}{jlcon}
julia> [1 3 5
        2 4 6;;;
        7 9 11
        8 10 12]
2×3×2 Array{Int64, 3}:
[:, :, 1] =
 1  3  5
 2  4  6

[:, :, 2] =
 7   9  11
 8  10  12

julia> [1 2;;; 3 4;;;; 5 6;;; 7 8]
1×2×2×2 Array{Int64, 4}:
[:, :, 1, 1] =
 1  2

[:, :, 2, 1] =
 3  4

[:, :, 1, 2] =
 5  6

[:, :, 2, 2] =
 7  8

julia> [[1 2;;; 3 4];;;; [5 6];;; [7 8]]
1×2×2×2 Array{Int64, 4}:
[:, :, 1, 1] =
 1  2

[:, :, 2, 1] =
 3  4

[:, :, 1, 2] =
 5  6

[:, :, 2, 2] =
 7  8
\end{minted}



尽管它们都表示第二维中的连接，但空格（或制表符）和 \texttt{;;} 不能出现在同一个数组表达式中，除非双分号只是作为“行继续”字符。 这允许单个水平拼接跨越多行（不会将换行符解释为垂直拼接）。




\begin{minted}{jlcon}
julia> [1 2 ;;
       3 4]
1×4 Matrix{Int64}:
 1  2  3  4
\end{minted}



终止分号也可用于在最后添加 1 个长度为1的维度。




\begin{minted}{jlcon}
julia> [1;;]
1×1 Matrix{Int64}:
 1

julia> [2; 3;;;]
2×1×1 Array{Int64, 3}:
[:, :, 1] =
 2
 3
\end{minted}



更一般地，可以通过\hyperlink{9868138443525443234}{\texttt{cat}} 函数来实现数组元素的拼接功能。 以下这些的语法为这些函数的简写形式，它们本身也是非常方便使用的：




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
语法 & 函数 & 描述 \\
\hline
 & \hyperlink{9868138443525443234}{\texttt{cat}} & 沿着 s 的第 \texttt{k} 维拼接数组 \\
\hline
\texttt{[A; B; C; ...]} & \hyperlink{14691815416955507876}{\texttt{vcat}} & `cat(A...; dims=1) 的简写 \\
\hline
\texttt{[A B C ...]} & \hyperlink{8862791894748483563}{\texttt{hcat}} & `cat(A...; dims=2) 的简写 \\
\hline
\texttt{[A B; C D; ...]} & \hyperlink{16279083053557795116}{\texttt{hvcat}} & 同时沿垂直和水平方向拼接 \\
\hline
\texttt{[A; C;; B; D;;; ...]} & \href{@ref}{\texttt{hvncat}} & 同时进行 n 维拼接，其中分号的数量表示拼接所在的维度 \\
\hline
\end{tabulary}

\end{table}



\hypertarget{6678793664119592343}{}


\subsection{指定类型的数组字面量}



可以用 \texttt{T[A, B, C, ...]} 的方式声明一个元素为某种特定类型的数组。该方法定义一个元素类型为 \texttt{T} 的一维数组并且初始化元素为 \texttt{A}, \texttt{B}, \texttt{C}, ....。比如，\texttt{Any[x, y, z]} 会构建一个异构数组，该数组可以包含任意类型的元素。



类似的，拼接也可以用类型为前缀来指定结果的元素类型。




\begin{minted}{jlcon}
julia> [[1 2] [3 4]]
1×4 Matrix{Int64}:
 1  2  3  4

julia> Int8[[1 2] [3 4]]
1×4 Matrix{Int8}:
 1  2  3  4
\end{minted}



\hypertarget{12661687782855472919}{}


\section{数组推导}



（数组）推导提供了构造数组的通用且强大的方法。其语法类似于数学中的集合构造的写法：




\begin{lstlisting}
A = [ F(x,y,...) for x=rx, y=ry, ... ]
\end{lstlisting}



这种形式的含义是 \texttt{F(x,y,...)} 取其给定列表中变量 \texttt{x}，\texttt{y} 等的每个值进行计算。值可以指定为任何可迭代对象，但通常是 \texttt{1:n} 或 \texttt{2:(n-1)} 之类的范围，或者像 \texttt{[1.2, 3.4, 5.7]} 这样的显式数组值。结果是一个 N 维密集数组，将变量范围 \texttt{rx}，\texttt{ry} 等的维数拼接起来得到其维数，并且每次 \texttt{F(x,y,...)} 计算返回一个标量。



下面的示例计算当前元素和沿一维网格其左，右相邻元素的加权平均值：




\begin{minted}{jlcon}
julia> x = rand(8)
8-element Array{Float64,1}:
 0.843025
 0.869052
 0.365105
 0.699456
 0.977653
 0.994953
 0.41084
 0.809411

julia> [ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]
6-element Array{Float64,1}:
 0.736559
 0.57468
 0.685417
 0.912429
 0.8446
 0.656511
\end{minted}



生成的数组的类型取决于参与计算元素的类型，就像\hyperlink{13961675686342166416}{数组字面量}一样。为了显式地控制类型，可以在数组推导之前指定类型。例如，我们可以要求推导的结果为单精度类型：




\begin{minted}{julia}
Float32[ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]
\end{minted}



\hypertarget{5737546333215614116}{}


\section{生成器表达式}



也可以在没有方括号的情况下编写（数组）推导，从而产生称为生成器的对象。可以迭代此对象以按需生成值，而不是预先分配数组并存储它们（请参阅 \hyperlink{9973578417281662233}{迭代}）。例如，以下表达式在不分配内存的情况下对一个序列进行求和：




\begin{minted}{jlcon}
julia> sum(1/n^2 for n=1:1000)
1.6439345666815615
\end{minted}



在参数列表中使用具有多个维度的生成器表达式时，需要使用括号将生成器与后续参数分开：




\begin{minted}{jlcon}
julia> map(tuple, 1/(i+j) for i=1:2, j=1:2, [1:4;])
ERROR: syntax: invalid iteration specification
\end{minted}



\texttt{for} 后面所有逗号分隔的表达式都被解释为范围。 添加括号让我们可以向 \hyperlink{11483231213869150535}{\texttt{map}} 中添加第三个参数：




\begin{minted}{jlcon}
julia> map(tuple, (1/(i+j) for i=1:2, j=1:2), [1 3; 2 4])
2×2 Matrix{Tuple{Float64, Int64}}:
 (0.5, 1)       (0.333333, 3)
 (0.333333, 2)  (0.25, 4)
\end{minted}



生成器是通过内部函数实现。 与本语言中别处使用的内部函数一样，封闭作用域中的变量可以在内部函数中被「捕获」。例如，\texttt{sum(p[i] - q[i] for i=1:n)} 从封闭作用域中捕获三个变量 \texttt{p}、\texttt{q} 和 \texttt{n}。但是变量捕获可能会带来性能挑战；请参阅 \hyperlink{818954303942149020}{性能提示}。



通过编写多个 \texttt{for} 关键字，生成器和推导中的范围可以取决于之前的范围：




\begin{minted}{jlcon}
julia> [(i,j) for i=1:3 for j=1:i]
6-element Vector{Tuple{Int64, Int64}}:
 (1, 1)
 (2, 1)
 (2, 2)
 (3, 1)
 (3, 2)
 (3, 3)
\end{minted}



在这些情况下，结果都是一维的。



可以使用 \texttt{if} 关键字过滤生成的值：




\begin{minted}{jlcon}
julia> [(i,j) for i=1:3 for j=1:i if i+j == 4]
2-element Vector{Tuple{Int64, Int64}}:
 (2, 2)
 (3, 1)
\end{minted}



\hypertarget{14469287548874312017}{}


\section{索引}



索引 n 维数组 \texttt{A} 的一般语法是：




\begin{lstlisting}
X = A[I_1, I_2, ..., I_n]
\end{lstlisting}



其中每个 \texttt{I\_k} 可以是标量整数，整数数组或任何其他\hyperlink{3335763678693018755}{支持的索引类型}。这包括 \hyperlink{13649361117037263099}{\texttt{Colon}} (\texttt{:}) 来选择整个维度中的所有索引，形式为 \texttt{a:c} 或 \texttt{a:b:c} 的范围来选择连续或跨步的子区间，以及布尔数组以选择索引为 \texttt{true} 的元素。



如果所有索引都是标量，则结果 \texttt{X} 是数组 \texttt{A} 中的单个元素。否则，\texttt{X} 是一个数组，其维数与所有索引的维数之和相同。



如果所有索引 \texttt{I\_k} 都是向量，则 \texttt{X} 的形状将是 \texttt{(length(I\_1), length(I\_2), ..., length(I\_n))}，其中，\texttt{X} 中位于 \texttt{i\_1, i\_2, ..., i\_n} 处的元素为 \texttt{A[I\_1[i\_1], I\_2[i\_2], ..., I\_n[i\_n]]}。



例如：




\begin{minted}{jlcon}
julia> A = reshape(collect(1:16), (2, 2, 2, 2))
2×2×2×2 Array{Int64, 4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia> A[1, 2, 1, 1] # 全部为标量索引
3

julia> A[[1, 2], [1], [1, 2], [1]] # 全部为向量索引
2×1×2×1 Array{Int64, 4}:
[:, :, 1, 1] =
 1
 2

[:, :, 2, 1] =
 5
 6

julia> A[[1, 2], [1], [1, 2], 1] # 标量与向量索引的混合使用
2×1×2 Array{Int64, 3}:
[:, :, 1] =
 1
 2

[:, :, 2] =
 5
 6
\end{minted}



请注意最后两种情况下得到的数组大小为何是不同的。



如果 \texttt{I\_1} 是二维矩阵，则 \texttt{X} 是 \texttt{n+1} 维数组，其形状为 \texttt{(size(I\_1, 1), size(I\_1, 2), length(I\_2), ..., length(I\_n))}。矩阵会添加一个维度。



例如：




\begin{minted}{jlcon}
julia> A = reshape(collect(1:16), (2, 2, 2, 2));

julia> A[[1 2; 1 2]]
2×2 Matrix{Int64}:
 1  2
 1  2

julia> A[[1 2; 1 2], 1, 2, 1]
2×2 Matrix{Int64}:
 5  6
 5  6
\end{minted}



位于 \texttt{i\_1, i\_2, i\_3, ..., i\_\{n+1\}} 处的元素值是 \texttt{A[I\_1[i\_1, i\_2], I\_2[i\_3], ..., I\_n[i\_\{n+1\}]]}。所有使用标量索引的维度都将被丢弃，例如，假设 \texttt{J} 是索引数组，那么 \texttt{A[2，J，3]} 的结果是一个大小为 \texttt{size(J)} 的数组、其第 j 个元素由 \texttt{A[2, J[j], 3]} 填充。



作为此语法的特殊部分，\texttt{end} 关键字可用于表示索引括号内每个维度的最后一个索引，由索引的最内层数组的大小决定。没有 \texttt{end} 关键字的索引语法相当于调用\hyperlink{13720608614876840481}{\texttt{getindex}}：




\begin{lstlisting}
X = getindex(A, I_1, I_2, ..., I_n)
\end{lstlisting}



例如：




\begin{minted}{jlcon}
julia> x = reshape(1:16, 4, 4)
4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> x[2:3, 2:end-1]
2×2 Matrix{Int64}:
 6  10
 7  11

julia> x[1, [2 3; 4 1]]
2×2 Matrix{Int64}:
  5  9
 13  1
\end{minted}



\hypertarget{7105044708769418916}{}


\section{索引赋值}



在 n 维数组 \texttt{A} 中赋值的一般语法是：




\begin{lstlisting}
A[I_1, I_2, ..., I_n] = X
\end{lstlisting}



其中每个 \texttt{I\_k} 可以是标量整数，整数数组或任何其他\hyperlink{3335763678693018755}{支持的索引类型}。这包括 \hyperlink{13649361117037263099}{\texttt{Colon}} (\texttt{:}) 来选择整个维度中的所有索引，形式为 \texttt{a:c} 或 \texttt{a:b:c} 的范围来选择连续或跨步的子区间，以及布尔数组以选择索引为 \texttt{true} 的元素。



如果所有 \texttt{I\_k} 都为整数，则数组 \texttt{A} 中 \texttt{I\_1, I\_2, ..., I\_n} 位置的值将被 \texttt{X} 的值覆盖，必要时将 \hyperlink{1846942650946171605}{\texttt{convert}} 为数组 \texttt{A} 的 \hyperlink{6396209842929672718}{\texttt{eltype}}。



如果索引 \texttt{I\_k} 本身就是一个数组，那么右侧的 \texttt{X} 也必须是一个与索引 \texttt{A[I\_1, I\_2, ..., I\_n]} 的结果具有相同形状的数组或是具有相同数量元素的向量。 \texttt{A} 的位置 \texttt{I\_1[i\_1], I\_2[i\_2], ..., I\_n[i\_n]} 中的值被值 \texttt{X[I\_1, I\_2, ..., I\_n]} 覆盖，如果必要也会进行类型转换。 元素分配运算符 \texttt{.=} 可以用于沿着所选区域 \hyperlink{1924664524817847375}{广播} \texttt{X}：




\begin{lstlisting}
A[I_1, I_2, ..., I_n] .= X
\end{lstlisting}



就像在\hyperlink{16717190941363337071}{索引}中一样，\texttt{end}关键字可用于表示索引括号中每个维度的最后一个索引，由被赋值的数组大小决定。 没有\texttt{end}关键字的索引赋值语法相当于调用\hyperlink{1309244355901386657}{\texttt{setindex!}}：




\begin{lstlisting}
setindex!(A, X, I_1, I_2, ..., I_n)
\end{lstlisting}



例如：




\begin{minted}{jlcon}
julia> x = collect(reshape(1:9, 3, 3))
3×3 Matrix{Int64}:
 1  4  7
 2  5  8
 3  6  9

julia> x[3, 3] = -9;

julia> x[1:2, 1:2] = [-1 -4; -2 -5];

julia> x
3×3 Matrix{Int64}:
 -1  -4   7
 -2  -5   8
  3   6  -9
\end{minted}



\hypertarget{982887983034702059}{}


\section{支持的索引类型}



在表达式 \texttt{A[I\_1, I\_2, ..., I\_n]} 中，每个 \texttt{I\_k} 可以是标量索引，标量索引数组，或者用 \hyperlink{10027537986402266830}{\texttt{to\_indices}} 转换成的表示标量索引数组的对象：



\begin{itemize}
\item[1. ] 标量索引。默认情况下，这包括：

\begin{itemize}
\item 非布尔的整数


\item \hyperlink{4571802376991525093}{\texttt{CartesianIndex\{N\}}} 用来表达多个维度的信息（详见下文），其内部实际为 N个整数组成的元组。

\end{itemize}

\item[2. ] 标量索引数组。这包括：

\begin{itemize}
\item 整数向量和多维整数数组


\item 像 \texttt{[]} 这样的空数组，它不选择任何元素


\item 如 \texttt{a:c} 或 \texttt{a:b:c} 的范围，从 \texttt{a} 到 \texttt{c}（包括）选择连续或间隔的部分元素


\item 任何自定义标量索引数组，它是 \texttt{AbstractArray} 的子类型


\item \texttt{CartesianIndex\{N\}} 数组（详见下文）

\end{itemize}

\item[3. ] 一个表示标量索引数组的对象，可以通过\hyperlink{10027537986402266830}{\texttt{to\_indices}}转换为这样的对象。 默认情况下，这包括：

\begin{itemize}
\item \hyperlink{13649361117037263099}{\texttt{Colon()}} (\texttt{:})，表示整个维度内或整个数组中的所有索引


\item 布尔数组，选择其中值为 \texttt{true} 的索引对应的元素（更多细节见下文）

\end{itemize}
\end{itemize}


一些例子：




\begin{minted}{jlcon}
julia> A = reshape(collect(1:2:18), (3, 3))
3×3 Matrix{Int64}:
 1   7  13
 3   9  15
 5  11  17

julia> A[4]
7

julia> A[[2, 5, 8]]
3-element Vector{Int64}:
  3
  9
 15

julia> A[[1 4; 3 8]]
2×2 Matrix{Int64}:
 1   7
 5  15

julia> A[[]]
Int64[]

julia> A[1:2:5]
3-element Vector{Int64}:
 1
 5
 9

julia> A[2, :]
3-element Vector{Int64}:
  3
  9
 15

julia> A[:, 3]
3-element Vector{Int64}:
 13
 15
 17
\end{minted}



\hypertarget{6884198732360978942}{}


\subsection{笛卡尔索引}



特殊的 \texttt{CartesianIndex\{N\}} 对象表示一个标量索引，其行为类似于张成多个维度的 \texttt{N} 维整数元组。例如：




\begin{minted}{jlcon}
julia> A = reshape(1:32, 4, 4, 2);

julia> A[3, 2, 1]
7

julia> A[CartesianIndex(3, 2, 1)] == A[3, 2, 1] == 7
true
\end{minted}



单独来看的话，这看起来很平凡：\texttt{CartesianIndex} 单纯只是将多个整数捆绑在一起作为一个对象来表示一个多维下标。当与其他取下标方式和生成 \texttt{CartesianIndex} 的迭代器进行工作的时候，它才真正能展现出它的简洁与高效。关于这个你可以参考 \hyperlink{9973578417281662233}{迭代器} 这一部分，你也可以参考 \href{https://julialang.org/blog/2016/02/iteration}{关于多维算法和迭代器的介绍} 这篇博客来了解更进阶的用法。



元素类型为 \texttt{CartesianIndex\{N\}}  的矩阵也是支持的。每一个元素都单独表示一个 \texttt{N} 维空间的 索引下标，作为一个整体这样一个矩阵则表示一些 \texttt{N} 维空间的点的坐标，因此这种形式有时 也称为逐点索引。例如：你可以通过它来访问上面所定义的三维矩阵  \texttt{A} 的第一页 (第三维指标为1）的对角线元素：




\begin{minted}{jlcon}
julia> page = A[:,:,1]
4×4 Matrix{Int64}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> page[[CartesianIndex(1,1),
             CartesianIndex(2,2),
             CartesianIndex(3,3),
             CartesianIndex(4,4)]]
4-element Vector{Int64}:
  1
  6
 11
 16
\end{minted}



这可以通过 \hyperlink{17801130558550430478}{dot broadcasting} 以及普通整数索引（而不是把从 \texttt{A} 中提取第一“页”作为单独的步骤）更加简单地表达。它甚至可以与 \texttt{:} 结合使用，同时从两个页面中提取两个对角线：




\begin{minted}{jlcon}
julia> A[CartesianIndex.(axes(A, 1), axes(A, 2)), 1]
4-element Vector{Int64}:
  1
  6
 11
 16

julia> A[CartesianIndex.(axes(A, 1), axes(A, 2)), :]
4×2 Matrix{Int64}:
  1  17
  6  22
 11  27
 16  32
\end{minted}



\begin{quote}
\textbf{Warning}

\texttt{CartesianIndex} 和 \texttt{CartesianIndex} 数组与用来表示维度的最后一个索引的 \texttt{end} 关键字不兼容。 不要在可能包含\texttt{CartesianIndex}或其数组的索引表达式中使用\texttt{end}。

\end{quote}


\hypertarget{16147573404656390381}{}


\subsection{逻辑索引}



通常被称为逻辑索引或带有逻辑掩码的索引，通过布尔数组进行索引选择其值为\texttt{true}的索引处的元素。 通过布尔向量\texttt{B}进行索引实际上与通过\hyperlink{16067208921941164599}{\texttt{findall(B)}}返回的整数向量进行索引相同。 类似地，通过\texttt{N}维布尔数组进行索引与通过其值为\texttt{true}的\texttt{CartesianIndex\{N\}}的向量进行索引实际上是相同的。 一个逻辑索引必须是一个与它所索引的维度长度相同的向量，或者它必须是唯一提供的索引并且匹配它所索引到的数组的大小和维度。 通常直接使用布尔数组作为索引更有效，而不是调用 \hyperlink{16067208921941164599}{\texttt{findall}}。




\begin{minted}{jlcon}
julia> x = reshape(1:16, 4, 4)
4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> x[[false, true, true, false], :]
2×4 Matrix{Int64}:
 2  6  10  14
 3  7  11  15

julia> mask = map(ispow2, x)
4×4 Matrix{Bool}:
 1  0  0  0
 1  0  0  0
 0  0  0  0
 1  1  0  1

julia> x[mask]
5-element Vector{Int64}:
  1
  2
  4
  8
 16
\end{minted}



\hypertarget{17064129854874388099}{}


\subsection{索引数}



\hypertarget{16914248248713404385}{}


\subsubsection{笛卡尔索引}



通常，为一个N维数组元素使用索引的方式是使用N个数字作为索引，每一个索引值确定一个具体的维度。例如，一个三维数组\texttt{A = rand(4, 3, 2)}, \texttt{A[2, 3, 1]} 将选择的第二行第三列第一“页”中的元素。这种方式通常也被成为笛卡尔索引。



\hypertarget{9085041942168456552}{}


\subsubsection{线性索引}



当恰好提供了一个索引\texttt{i}时，该索引不再表示数组特定维度中的位置。 相反，它使用线性遍历整个数组的列主迭代顺序选择第 \texttt{i} 个元素。 这称为\emph{线性索引}。 它本质上将数组视为使用 \hyperlink{18435874855636770528}{\texttt{vec}} 将其重新整形为一维向量。




\begin{minted}{jlcon}
julia> A = [2 6; 4 7; 3 1]
3×2 Matrix{Int64}:
 2  6
 4  7
 3  1

julia> A[5]
7

julia> vec(A)[5]
7
\end{minted}



数组 \texttt{A} 中的线性索引可以转换为 \texttt{CartesianIndex} 以使用 \texttt{CartesianIndices(A)[i]} 进行笛卡尔索引（参见 \hyperlink{16831958174907250244}{\texttt{CartesianIndices}}），一组 \texttt{N} 维笛卡尔索引可以通过\texttt{LinearIndices(A)[i\_1, i\_2, ..., i\_N]} 转换为线性索引（参见\hyperlink{12250457823889413092}{\texttt{LinearIndices}}）。




\begin{minted}{jlcon}
julia> CartesianIndices(A)[5]
CartesianIndex(2, 2)

julia> LinearIndices(A)[2, 2]
5
\end{minted}



需要注意的是，这些转换的性能存在很大的不对称性。 将线性索引转换为一组笛卡尔索引需要做除法取余数，而相反的转换只是相乘和相加。 在现代处理器中，整数除法比乘法慢 10-50 倍。 虽然一些数组——比如 \hyperlink{15492651498431872487}{\texttt{Array}} 本身——是使用线性内存块实现的，并在它们的实现中直接使用线性索引，但其他数组——比如 \hyperlink{3300114559258360989}{\texttt{Diagonal}}——需要完整的笛卡尔索引集进行查找（请参阅 \hyperlink{7782790551324367092}{\texttt{IndexStyle}} 以仔细推敲）。 因此，当遍历整个数组时，最好遍历 \hyperlink{4701773772897287974}{\texttt{eachindex(A)}} 而不是 \texttt{1:length(A)}。 在 \texttt{A} 是 \texttt{IndexCartesian} 的情况下，前者不仅会快得多，而且它还支持 OffsetArrays（译者注：OffsetArrays.jl是Julia的一个包，支持矩阵的下标不从1开始）。



\hypertarget{3274469472431833212}{}


\subsubsection{省略和额外的索引}



除了线性索引，在某些情况下， \texttt{N} 维数组的可能少于或多余  \texttt{N} 。



如果未索引的剩余维度的长度均为 1，则可以省略索引。 换句话说，只有当那些省略的索引对于索引表达式只有一个可能的值时，才可以省略剩余索引。 例如，一个大小为\texttt{(3, 4, 2, 1)}的四维数组可能只用三个索引进行索引，因为被跳过的维度（第四维）的长度为 1。 请注意，线性索引优先级高于此规则。




\begin{minted}{jlcon}
julia> A = reshape(1:24, 3, 4, 2, 1)
3×4×2×1 reshape(::UnitRange{Int64}, 3, 4, 2, 1) with eltype Int64:
[:, :, 1, 1] =
 1  4  7  10
 2  5  8  11
 3  6  9  12

[:, :, 2, 1] =
 13  16  19  22
 14  17  20  23
 15  18  21  24

julia> A[1, 3, 2] # Omits the fourth dimension (length 1)
19

julia> A[1, 3] # Attempts to omit dimensions 3 & 4 (lengths 2 and 1)
ERROR: BoundsError: attempt to access 3×4×2×1 reshape(::UnitRange{Int64}, 3, 4, 2, 1) with eltype Int64 at index [1, 3]

julia> A[19] # Linear indexing
19
\end{minted}



当用\texttt{A[]} 省略\emph{全部} 索引时，这种语义提供了一种简单的习惯用法来检索数组中的唯一元素，同时确保只有一个元素。



类似地，如果超出数组维数的所有索引都是\texttt{1}（或更一般地说是\texttt{axes(A, d)}的第一个也是唯一的元素，其中\texttt{d}是特定的维数），可以使用超过\texttt{N}维的索引。这允许向量像一列矩阵一样被索引，例如：




\begin{minted}{jlcon}
julia> A = [8,6,7]
3-element Vector{Int64}:
 8
 6
 7

julia> A[2,1]
6
\end{minted}



\hypertarget{36994114593650767}{}


\section{迭代}



迭代整个数组的推荐方法是




\begin{minted}{julia}
for a in A
    # Do something with the element a
end

for i in eachindex(A)
    # Do something with i and/or A[i]
end
\end{minted}



当你需要每个元素的值而不是索引时，使用第一个构造。 在第二个构造中，如果 \texttt{A} 是具有快速线性索引的数组类型，\texttt{i} 将是 \texttt{Int}; 否则，它将是一个 \texttt{CartesianIndex}：




\begin{minted}{jlcon}
julia> A = rand(4,3);

julia> B = view(A, 1:3, 2:3);

julia> for i in eachindex(B)
           @show i
       end
i = CartesianIndex(1, 1)
i = CartesianIndex(2, 1)
i = CartesianIndex(3, 1)
i = CartesianIndex(1, 2)
i = CartesianIndex(2, 2)
i = CartesianIndex(3, 2)
\end{minted}



与 \texttt{for i = 1:length(A)} 相比，\hyperlink{4701773772897287974}{\texttt{eachindex}} 提供了一种迭代任何数组类型的有效方法。



\hypertarget{10166346050354504892}{}


\section{Array traits}



如果你编写一个自定义的 \hyperlink{6514416309183787338}{\texttt{AbstractArray}} 类型，你可以用以下代码指定它使用快速线性索引




\begin{minted}{julia}
Base.IndexStyle(::Type{<:MyArray}) = IndexLinear()
\end{minted}



此设置将导致 \texttt{myArray} 上的 \texttt{eachindex} 迭代使用整数。如果未指定此特征，则使用默认值 \texttt{IndexCartesian()}。



\hypertarget{1179855062476093403}{}


\section{数组和向量化的算子与函数}



以下运算符支持对数组操作



\begin{itemize}
\item[1. ] 一元运算符 – \texttt{-}, \texttt{+}


\item[2. ] 二元运算符 – \texttt{-}, \texttt{+}, \texttt{*}, \texttt{/}, \texttt{{\textbackslash}}, \texttt{{\textasciicircum}}


\item[3. ] 比较操作符 – \texttt{==}, \texttt{!=}, \texttt{≈} (\hyperlink{12499503887608197213}{\texttt{isapprox}}), \texttt{≉}

\end{itemize}


另外，为了便于数学上和其他运算的向量化，Julia \hyperlink{17801130558550430478}{提供了点语法（dot syntax）} \texttt{f.(args...)}，例如，\texttt{sin.(x)} 或 \texttt{min.(x,y)}，用于数组或数组和标量的混合上的按元素运算（\hyperlink{1924664524817847375}{广播}运算）；当与其他点调用（dot call）结合使用时，它们的额外优点是能「融合」到单个循环中，例如，\texttt{sin.(cos.(x))}。



此外，\emph{每个}二元运算符支持相应的\hyperlink{15967322336376951940}{点操作版本}，可以应用于此类\hyperlink{17801130558550430478}{融合 broadcasting 操作}的数组（以及数组和标量的组合），例如 \texttt{z .== sin.(x .* y)}。



请注意，类似 \texttt{==} 的比较运算在作用于整个数组时，得到一个布尔结果。使用像 \texttt{.==} 这样的点运算符进行按元素的比较。（对于像 \texttt{<} 这样的比较操作，\emph{只有}按元素运算的版本 \texttt{.<} 适用于数组。）



还要注意 \texttt{max.(a,b)} 和 \hyperlink{14719513931696680717}{\texttt{maximum(a)}} 之间的区别，\texttt{max.(a,b)} 对 \texttt{a} 和 \texttt{b} 的每个元素 \hyperlink{616124539803111168}{\texttt{broadcast}}s \hyperlink{7839419811914289844}{\texttt{max}}，\hyperlink{14719513931696680717}{\texttt{maximum(a)}} 寻找在 \texttt{a} 中的最大值。\texttt{min.(a,b)} 和 \texttt{minimum(a)} 也有同样的关系。



\hypertarget{14784211786235072140}{}


\section{广播}



有时需要在不同尺寸的数组上执行元素对元素的操作，例如将矩阵的每一列加一个向量。一种低效的方法是将向量复制成矩阵的大小：




\begin{minted}{jlcon}
julia> a = rand(2,1); A = rand(2,3);

julia> repeat(a,1,3)+A
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846
\end{minted}



当维度较大的时候，这种方法将会十分浪费，所以 Julia 提供了广播 \hyperlink{616124539803111168}{\texttt{broadcast}}，它将会将参数中低维度的参数扩展，使得其与其他维度匹配，且不会使用额外的内存，并将所给的函数逐元素地应用。




\begin{minted}{jlcon}
julia> broadcast(+, a, A)
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846

julia> b = rand(1,2)
1×2 Array{Float64,2}:
 0.867535  0.00457906

julia> broadcast(+, a, b)
2×2 Array{Float64,2}:
 1.71056  0.847604
 1.73659  0.873631
\end{minted}



\hyperlink{15967322336376951940}{点运算符} 如\texttt{.+} 和\texttt{.*} 等价于\texttt{broadcast} 调用（除了它们结合使用，\hyperlink{4802910107640435151}{如上所述}）。 还有一个 \hyperlink{7631985657411687574}{\texttt{broadcast!}} 函数来指定一个明确的方式（也可以通过\texttt{.=} 赋值以融合方式访问）。 事实上，\texttt{f.(args...)} 等价于\texttt{broadcast(f, args...)}，提供了一种方便的语法来广播任何函数(\hyperlink{17801130558550430478}{dot syntax})。 嵌套的“点运算符调用”\texttt{f.(...)}（包括对\texttt{.+} 等的调用）\hyperlink{15967322336376951940}{自动融合} 到单个\texttt{broadcast} 调用中。



此外，\hyperlink{616124539803111168}{\texttt{broadcast}} 不限于数组（参见函数文档）； 它还处理标量、元组和其它容器。 默认情况下，只有一些参数类型被认为是标量，包括（但不限于）\texttt{Number}s、\texttt{String}s、\texttt{Symbol}s、\texttt{Type}s、\texttt{Function}s 和一些常见的单例，如 \texttt{missing} 和\texttt{nothing}。 所有其他参数都被迭代或逐个索引。




\begin{minted}{jlcon}
julia> convert.(Float32, [1, 2])
2-element Vector{Float32}:
 1.0
 2.0

julia> ceil.(UInt8, [1.2 3.4; 5.6 6.7])
2×2 Matrix{UInt8}:
 0x02  0x04
 0x06  0x07

julia> string.(1:3, ". ", ["First", "Second", "Third"])
3-element Vector{String}:
 "1. First"
 "2. Second"
 "3. Third"
\end{minted}



有时，你希望一个通常参与广播的容器（如数组）受到“保护”，使其免受广播迭代其所有元素的行为的影响。 通过将其放置在另一个容器中（如单个元素 \hyperlink{17462354060312563026}{\texttt{Tuple}}），广播会将其视为单个值。




\begin{minted}{jlcon}
julia> ([1, 2, 3], [4, 5, 6]) .+ ([1, 2, 3],)
([2, 4, 6], [5, 7, 9])

julia> ([1, 2, 3], [4, 5, 6]) .+ tuple([1, 2, 3])
([2, 4, 6], [5, 7, 9])
\end{minted}



\hypertarget{2709595058891761459}{}


\section{实现}



Julia 中的基本数组类型是抽象类型 \hyperlink{6514416309183787338}{\texttt{AbstractArray\{T,N\}}}。它通过维数 \texttt{N} 和元素类型 \texttt{T} 进行参数化。\hyperlink{12517057979818647811}{\texttt{AbstractVector}} 和 \hyperlink{17966587371929951201}{\texttt{AbstractMatrix}} 是一维和二维情况下的别名。\texttt{AbstractArray} 对象的操作是使用更高级别的运算符和函数定义的，其方式独立于底层存储。这些操作可以正确地被用于任何特定数组实现的回退操作。



\texttt{AbstractArray} 类型包括任何类似数组的东西，它的实现可能与传统数组完全不同。例如，元素可能根据请求计算而不是存储。然而，任何具体的 \texttt{AbstractArray\{T,N\}} 类型通常应该至少实现 \hyperlink{17888996102305087038}{\texttt{size(A)}}（返回一个 \texttt{Int} 元组），\href{ @ref}{\texttt{getindex(A,i)}} 和 \hyperlink{13720608614876840481}{\texttt{getindex(A,i1,...,iN)}};可变数组也应该实现 \hyperlink{1309244355901386657}{\texttt{setindex!}}。建议这些操作具有常数时间复杂度，否则某些数组函数可能会出乎意料的慢。具体类型通常还应该提供一个 \hyperlink{15525808546723795098}{\texttt{similar(A,T=eltype(A),dims=size(A))}} 方法，用于为 \href{ @ref}{\texttt{copy}} 和其他不合适的操作。无论 \texttt{AbstractArray\{T,N\}} 在内部如何表示，\texttt{T} 都是由 \emph{整数} 索引（\texttt{A[1, ..., 1]}，当 \texttt{A} 非空） 返回的对象类型并且 \texttt{N} 应该是 \hyperlink{17888996102305087038}{\texttt{size}} 返回的元组的长度。有关自定义 \texttt{AbstractArray} 实现的更多详细信息，请参阅 \hyperlink{9718377734213742156}{接口章节中的数组接口指南}。



\texttt{DenseArray} 是 \texttt{AbstractArray} 的抽象子类型，旨在包括元素以列优先顺序连续存储的所有数组（请参阅 \hyperlink{11239800376478112527}{性能提示中的附加说明}）。 \hyperlink{15492651498431872487}{\texttt{Array}} 类型是\texttt{DenseArray} 的一个特定实例； \hyperlink{10571362059486397014}{\texttt{Vector}} 和 \hyperlink{5448927444601277512}{\texttt{Matrix}} 是一维和二维情况的别名。 除了所有\texttt{AbstractArray}s所需的操作之外，很少有专门为\texttt{Array}实现的操作；大部分数组库都是以泛型方式实现的，允许所有自定义数组的行为类似。



\texttt{SubArray} 是 \texttt{AbstractArray} 的特例，它通过与原始数组共享内存而不是复制它来执行索引。 使用\hyperlink{4861450464669906845}{\texttt{view}} 函数创建 \texttt{SubArray}，它的调用方式与\hyperlink{13720608614876840481}{\texttt{getindex}} 相同（作用于数组和一系列索引参数）。 \hyperlink{4861450464669906845}{\texttt{view}} 的结果看起来与 \hyperlink{13720608614876840481}{\texttt{getindex}} 的结果相同，只是数据保持不变。 \hyperlink{4861450464669906845}{\texttt{view}} 将输入索引向量存储在 \texttt{SubArray} 对象中，该对象稍后可用于间接索引原始数组。 通过将  \hyperlink{4544474300423667148}{\texttt{@views}} 宏放在表达式或代码块之前，该表达式中的任何 \texttt{array [...]} 切片将被转换为创建一个 \texttt{SubArray} 视图。



\hyperlink{18015155802543401629}{\texttt{BitArray}} 是节省空间“压缩”的布尔数组，每个比特（bit）存储一个布尔值。 它们可以类似于 \texttt{Array\{Bool\}} 数组（每个字节（byte）存储一个布尔值），并且可以分别通过 \texttt{Array(bitarray)} 和 \texttt{BitArray(array)} 相互转换。



如果数组存储在内存中，其元素之间具有明确定义的间距（步长），则该数组是“等步长的”的。 通过简单地传递其 \hyperlink{8901246211940014300}{\texttt{pointer}} 和每个维度的步长，可以将有支持元素类型的等步长数组传递给外部（非 Julia）库，如 BLAS 或 LAPACK。 \hyperlink{97811245619734938}{\texttt{stride(A, d)}} 是元素之间沿维度 \texttt{d} 的距离。 例如，\texttt{rand(5,7,2)} 返回的内置 \texttt{Array} 的元素按列优先顺序连续排列。 这意味着第一个维度的步长——同一列中元素之间的间距——是\texttt{1}：




\begin{minted}{jlcon}
julia> A = rand(5,7,2);

julia> stride(A,1)
1
\end{minted}



第二个维度的步长是同一行中元素之间的间距，跳过与单列（\texttt{5}）中的元素一样多的元素。 类似地，在两个“页面”（在第三维中）之间跳转需要跳过 \texttt{5*7 == 35} 元素。 这个数组的 \hyperlink{13576557637670855932}{\texttt{strides}} 是这三个数字组成的元组：




\begin{minted}{jlcon}
julia> strides(A)
(1, 5, 35)
\end{minted}



在这种特殊情况下，在\emph{内存}中跳过的元素数与跳过的\emph{线性索引}数相匹配。 这仅适用于像 \texttt{Array}（和其他 \texttt{DenseArray} 子类型）这样的连续数组，通常情况下并非如此。 具有范围索引的视图是 \emph{非连续} 等步长数组的一个很好的例子； 考虑\texttt{V = @view A[1:3:4, 2:2:6, 2:-1:1]}。 这个视图 \texttt{V} 与 \texttt{A} 引用了相同的内存，但它跳过并重新排列了它的一些元素。 \texttt{V} 的第一维的步幅是 \texttt{3}，因为我们只从原始数组中选择每第三行：




\begin{minted}{jlcon}
julia> V = @view A[1:3:4, 2:2:6, 2:-1:1];

julia> stride(V, 1)
3
\end{minted}



这个视图类似于从我们原来的\texttt{A}中每隔一列选择一列——因此当在第二维的索引之间移动时，它需要跳过相当于两个五元素列的内容：




\begin{minted}{jlcon}
julia> stride(V, 2)
10
\end{minted}



第三维很有趣因为它的顺序颠倒了! 因此从第一 {\textquotedbl}页{\textquotedbl} 到第二页它必须在内存中到 \emph{backwards}，所以它在这一维的 strides 是负的!




\begin{minted}{jlcon}
julia> stride(V, 3)
-35
\end{minted}



这意味着\texttt{V} 的\texttt{pointer} 实际上指向\texttt{A} 的内存块的中间，并且它在内存中指向元素是同时向后和向前的。 有关定义你自己的跨距数组的更多详细信息，请参阅 \hyperlink{3010450308855105276}{等步长数组的接口指南}。 \hyperlink{18350706206094827862}{\texttt{StridedVector}} 和 \hyperlink{3855703768476610836}{\texttt{StridedMatrix}} 被认为是等步长数组的内置数组类型的方便别名，允许它们仅使用指针和步幅，来分派选择调用调整和优化后的 BLAS 和 LAPACK 函数。



需要强调的是 strides 是关于内存而不是索引中的偏移。如果你在找在线性（单索引）索引和笛卡尔（多索引）索引间切换的方法，见 \hyperlink{12250457823889413092}{\texttt{LinearIndices}} 和 \hyperlink{16831958174907250244}{\texttt{CartesianIndices}}.



\hypertarget{16922701023279192482}{}


\chapter{缺失值}



Julia 支持表示统计意义上的缺失值，即某个变量在观察中没有可用值，但在理论上存在有效值的情况。缺失值由 \hyperlink{14596725676261444434}{\texttt{missing}} 对象表示，该对象是 \hyperlink{9306488559141158579}{\texttt{Missing}} 类型的唯一实例。\texttt{missing} 等价于 \href{https://en.wikipedia.org/wiki/NULL\_(SQL)}{SQL 中的 \texttt{NULL}} 以及 \href{https://cran.r-project.org/doc/manuals/r-release/R-lang.html\#NA-handling}{R 中的 \texttt{NA}}，并在大多数情况下表现得与它们一样。



\hypertarget{16983381017967078050}{}


\section{缺失值的传播}



\texttt{missing}  值会自动在标准数学运算符和函数中\emph{传播}。对于这类函数，其某个运算对象的值的不确定性会导致其结果的不确定性。在应用中，上述情形意味着若在数学操作中包括 \texttt{missing}  值，其结果也常常返回 \texttt{missing} 值。




\begin{minted}{jlcon}
julia> missing + 1
missing

julia> "a" * missing
missing

julia> abs(missing)
missing
\end{minted}



由于\texttt{missing} 是 Julia 中的正常对象，此传播规则仅在可实现该对象的函数中应用。这可通过定义包含 \texttt{Missing} 类的实参的特定方法，或是简单地让函数可接受此类实参，并将该它们传入已具备传播规则的函数（如标准数学运算符）中实现。在包中定义新传播规则时，应考虑缺失值的传播是否具有实际意义，并在传播有意义时定义合适的方法。在某个不包含接受 \texttt{Missing} 类实参方法的函数中传递缺失值，则抛出 \hyperlink{68769522931907606}{\texttt{MethodError}}的报错，正如其它类型一样。



若希望函数不传播缺失值，可将其按照 \href{https://github.com/JuliaData/Missings.jl}{Missings.jl} 库中的 \texttt{passmissing} 函数封装起来。例如，将 \texttt{f(x)} 封装为 \texttt{passmissing(f)(x)}。



\hypertarget{13926030736377467708}{}


\section{相等和比较运算符}



标准相等和比较运算符遵循上面给出的传播规则：如果任何操作数是 \texttt{missing}，那么结果是 \texttt{missing}。这是一些例子




\begin{minted}{jlcon}
julia> missing == 1
missing

julia> missing == missing
missing

julia> missing < 1
missing

julia> 2 >= missing
missing
\end{minted}



特别要注意，\texttt{missing == missing} 返回 \texttt{missing}，所以 \texttt{==} 不能用于测试值是否为缺失值。要测试 \texttt{x} 是否为 \texttt{missing}，请用 \hyperlink{3452327148507948899}{\texttt{ismissing(x)}}。



特殊的比较运算符 \hyperlink{269533589463185031}{\texttt{isequal}} 和 \hyperlink{7974744969331231272}{\texttt{===}} 是传播规则的例外：它们总返回一个 \texttt{Bool} 值，即使存在 \texttt{missing} 值，并认为 \texttt{missing} 与 \texttt{missing} 相等且其与任何其它值不同。因此，它们可用于测试某个值是否为 \texttt{missing}。




\begin{minted}{jlcon}
julia> missing === 1
false

julia> isequal(missing, 1)
false

julia> missing === missing
true

julia> isequal(missing, missing)
true
\end{minted}



\hyperlink{8062916604071842790}{\texttt{isless}} 运算符是另一个例外：\texttt{missing} 被认为比任何其它值大。此运算符被用于 \hyperlink{8473525809131227606}{\texttt{sort}}，因此 \texttt{missing} 值被放置在所有其它值之后。




\begin{minted}{jlcon}
julia> isless(1, missing)
true

julia> isless(missing, Inf)
false

julia> isless(missing, missing)
false
\end{minted}



\hypertarget{2677689633086417735}{}


\section{逻辑运算符}



逻辑（或布尔）运算符 \hyperlink{9633687763646488853}{\texttt{|}}、\hyperlink{1494761116451616317}{\texttt{\&}} 和 \hyperlink{7071880015536674935}{\texttt{xor}} 是另一种特殊情况，因为它们只有在逻辑上是必需的时传递 \texttt{missing} 值。对于这些运算符来说，结果是否不确定取决于具体操作，其遵循\href{https://en.wikipedia.org/wiki/Three-valued\_logic}{\emph{三值逻辑}}的既定规则，这些规则也由 SQL 中的 \texttt{NULL} 以及 R 中的 \texttt{NA} 实现。这个抽象的定义实际上对应于一系列相对自然的行为，这最好通过具体的例子来解释。



让我们用逻辑「或」运算符 \hyperlink{9633687763646488853}{\texttt{|}} 来说明这个原理。按照布尔逻辑的规则，如果其中一个操作数是 \texttt{true}，则另一个操作数对结果没影响，结果总是 \texttt{true}。




\begin{minted}{jlcon}
julia> true | true
true

julia> true | false
true

julia> false | true
true
\end{minted}



基于观察，我们可以得出结论，如果其中一个操作数是 \texttt{true} 而另一个是 \texttt{missing}，我们知道结果为 \texttt{true}，尽管另一个参数的实际值存在不确定性。如果我们能观察到第二个操作数的实际值，那么它只能是 \texttt{true} 或 \texttt{false}，在两种情况下结果都是 \texttt{true}。因此，在这种特殊情况下，值的缺失不会传播




\begin{minted}{jlcon}
julia> true | missing
true

julia> missing | true
true
\end{minted}



相反地，如果其中一个操作数是 \texttt{false}，结果可能是 \texttt{true} 或 \texttt{false}，这取决于另一个操作数的值。因此，如果一个操作数是 \texttt{missing}，那么结果也是 \texttt{missing}。




\begin{minted}{jlcon}
julia> false | true
true

julia> true | false
true

julia> false | false
false

julia> false | missing
missing

julia> missing | false
missing
\end{minted}



逻辑「且」运算符 \hyperlink{1494761116451616317}{\texttt{\&}} 的行为与 \texttt{|} 运算符相似，区别在于当其中一个操作数为 \texttt{false} 时，值的缺失不会传播。例如，当第一个操作数是 \texttt{false} 时




\begin{minted}{jlcon}
julia> false & false
false

julia> false & true
false

julia> false & missing
false
\end{minted}



另一方面，当其中一个操作数为 \texttt{true} 时，值的缺失会传播，例如，当第一个操作数是 \texttt{true} 时




\begin{minted}{jlcon}
julia> true & true
true

julia> true & false
false

julia> true & missing
missing
\end{minted}



最后，逻辑「异或」运算符 \hyperlink{7071880015536674935}{\texttt{xor}} 总传播 \texttt{missing} 值，因为两个操作数都总是对结果产生影响。还要注意，否定运算符 \hyperlink{4329035214952292986}{\texttt{!}} 在操作数是 \texttt{missing} 时返回 \texttt{missing}，这就像其它一元运算符。



\hypertarget{354241034752728129}{}


\section{流程控制和短路运算符}



流程控制操作符，包括 \hyperlink{11624168233949720742}{\texttt{if}}、\hyperlink{15133348314455964692}{\texttt{while}} 和\hyperlink{14451148373001501733}{三元运算符} \texttt{x ? y : z}，不允许缺失值。这是因为如果我们能够观察实际值，它是 \texttt{true} 还是 \texttt{false} 是不确定的，这意味着我们不知道程序应该如何运行。一旦在以下上下文中遇到 \texttt{missing} 值，就会抛出 \hyperlink{2622693721821893139}{\texttt{TypeError}}




\begin{minted}{jlcon}
julia> if missing
           println("here")
       end
ERROR: TypeError: non-boolean (Missing) used in boolean context
\end{minted}



出于同样的原因，并与上面给出的逻辑运算符相反，短路布尔运算符 \hyperlink{4714012140247170866}{\texttt{\&\&}} 和 \hyperlink{2053797086840563251}{\texttt{||}} 在当前操作数的值决定下一个操作数是否求值时不允许 \texttt{missing} 值。例如




\begin{minted}{jlcon}
julia> missing || false
ERROR: TypeError: non-boolean (Missing) used in boolean context

julia> missing && false
ERROR: TypeError: non-boolean (Missing) used in boolean context

julia> true && missing && false
ERROR: TypeError: non-boolean (Missing) used in boolean context
\end{minted}



另一方面，如果无需 \texttt{missing} 值即可确定结果，则不会引发错误。代码在对 \texttt{missing} 操作数求值前短路，以及 \texttt{missing} 是最后一个操作数都是这种情况。




\begin{minted}{jlcon}
julia> true && missing
missing

julia> false && missing
false
\end{minted}



\hypertarget{929400294062348079}{}


\section{包含缺失值的数组}



包含缺失值的数组的创建就像其它数组




\begin{minted}{jlcon}
julia> [1, missing]
2-element Vector{Union{Missing, Int64}}:
 1
  missing
\end{minted}



如此示例所示，此类数组的元素类型为 \texttt{Union\{Missing, T\}}，其中 \texttt{T} 为非缺失值的类型。这简单地反映了以下事实：数组条目可以具有类型 \texttt{T}（此处为 \texttt{Int64}）或类型 \texttt{Missing}。此类数组使用高效的内存存储，其等价于一个 \texttt{Array\{T\}} 和一个 \texttt{Array\{UInt8\}} 的组合，前者保存实际值，后者表示条目类型（即它是 \texttt{Missing} 还是 \texttt{T}）。



允许缺失值的数组可以使用标准语法构造。使用 \texttt{Array\{Union\{Missing, T\}\}(missing, dims)} 来创建填充缺失值的数组：




\begin{minted}{jlcon}
julia> Array{Union{Missing, String}}(missing, 2, 3)
2×3 Matrix{Union{Missing, String}}:
 missing  missing  missing
 missing  missing  missing
\end{minted}



\begin{quote}
\textbf{Note}

使用 \texttt{undef} 或 \texttt{similar} 目前可能会给出一个填充有 \texttt{missing} 的数组，但这不是获得这样一个数组的正确方法。 请使用如上所示的 \texttt{missing} 构造函数。

\end{quote}


允许但不包含 \texttt{missing} 值的数组可使用 \hyperlink{1846942650946171605}{\texttt{convert}} 转换回不允许缺失值的数组。如果该数组包含 \texttt{missing} 值，在类型转换时会抛出 \texttt{MethodError}




\begin{minted}{jlcon}
julia> x = Union{Missing, String}["a", "b"]
2-element Vector{Union{Missing, String}}:
 "a"
 "b"

julia> convert(Array{String}, x)
2-element Vector{String}:
 "a"
 "b"

julia> y = Union{Missing, String}[missing, "b"]
2-element Vector{Union{Missing, String}}:
 missing
 "b"

julia> convert(Array{String}, y)
ERROR: MethodError: Cannot `convert` an object of type Missing to an object of type String
\end{minted}



\hypertarget{12164012210983849465}{}


\section{跳过缺失值}



由于 \texttt{missing} 会随着标准数学运算符传播，归约函数会在调用的数组包含缺失值时返回 \texttt{missing}




\begin{minted}{jlcon}
julia> sum([1, missing])
missing
\end{minted}



在这种情况下，使用 \hyperlink{2012470681884771400}{\texttt{skipmissing}} 即可跳过缺失值




\begin{minted}{jlcon}
julia> sum(skipmissing([1, missing]))
1
\end{minted}



此函数方便地返回一个可高效滤除 \texttt{missing} 值的迭代器。因此，它可应用于所有支持迭代器的函数




\begin{minted}{jlcon}
julia> x = skipmissing([3, missing, 2, 1])
skipmissing(Union{Missing, Int64}[3, missing, 2, 1])

julia> maximum(x)
3

julia> mean(x)
2.0

julia> mapreduce(sqrt, +, x)
4.146264369941973

\end{minted}



通过在某数组中调用 \texttt{skipmissing} 生成的对象能以其在所属数组中的位置进行索引。对应缺失值的指标并不有效，若尝试使用之会丢出报错（它们在 \texttt{keys} 和 \texttt{eachindex} 中同样是被跳过的）。




\begin{minted}{jlcon}
julia> x[1]
3

julia> x[2]
ERROR: MissingException: the value at index (2,) is missing
[...]
\end{minted}



这允许对索引进行操作的函数与\texttt{skipmissing}结合使用。搜索和查找函数尤其如此，它们返回对\texttt{skipmissing} 函数返回的对象有效的索引，这些索引也是\emph{在父数组中}匹配条目的索引。




\begin{minted}{jlcon}
julia> findall(==(1), x)
1-element Vector{Int64}:
 4

julia> findfirst(!iszero, x)
1

julia> argmax(x)
1
\end{minted}



使用 \hyperlink{6278865767444641812}{\texttt{collect}} 提取非 \texttt{missing} 值并将它们存储在一个数组里




\begin{minted}{jlcon}
julia> collect(x)
3-element Vector{Int64}:
 3
 2
 1
\end{minted}



\hypertarget{15378768208982642165}{}


\section{数组上的逻辑运算}



上面描述的逻辑运算符的三值逻辑也适用于针对数组的函数。因此，使用 \hyperlink{15143149452920304570}{\texttt{==}} 运算符的数组相等性测试中，若在未知 \texttt{missing} 条目实际值时无法确定结果，就返回 \texttt{missing}。在实际应用中意味着，在待比较数组中所有非缺失值都相等，且某个或全部数组包含缺失值（也许在不同位置）时会返回 \texttt{missing}。




\begin{minted}{jlcon}
julia> [1, missing] == [2, missing]
false

julia> [1, missing] == [1, missing]
missing

julia> [1, 2, missing] == [1, missing, 2]
missing
\end{minted}



对于单个值，\hyperlink{269533589463185031}{\texttt{isequal}} 会将 \texttt{missing} 值视为与其它 \texttt{missing} 值相等但与非缺失值不同。




\begin{minted}{jlcon}
julia> isequal([1, missing], [1, missing])
true

julia> isequal([1, 2, missing], [1, missing, 2])
false
\end{minted}



函数 \hyperlink{14612039032155203548}{\texttt{any}} 和 \hyperlink{7942004983516218646}{\texttt{all}} 遵循三值逻辑的规则，会在结果无法被确定时返回 \texttt{missing}。




\begin{minted}{jlcon}
julia> all([true, missing])
missing

julia> all([false, missing])
false

julia> any([true, missing])
true

julia> any([false, missing])
missing
\end{minted}



\hypertarget{15469988008975030780}{}


\chapter{网络和流}



Julia 提供了一个功能丰富的接口来处理流式 I/O 对象，如终端、管道和 TCP 套接字。此接口虽然在系统级是异步的，但是其以同步的方式展现给程序员，通常也不需要考虑底层的异步操作。这是通过大量使用 Julia 协作线程（\hyperlink{17473131347184639576}{协程}）功能实现的。



\hypertarget{16725310763095786332}{}


\section{基础流 I/O}



所有 Julia stream 都暴露了 \hyperlink{8104134490906192097}{\texttt{read}} 和 \hyperlink{16947913578760238729}{\texttt{write}} 方法，将 stream 作为它们的第一个参数，如：




\begin{minted}{jlcon}
julia> write(stdout, "Hello World");  # suppress return value 11 with ;
Hello World
julia> read(stdin, Char)

'\n': ASCII/Unicode U+000a (category Cc: Other, control)
\end{minted}



注意，\hyperlink{16947913578760238729}{\texttt{write}} 返回 11，字节数（\texttt{{\textquotedbl}Hello World{\textquotedbl}}）写入 \hyperlink{18181294266083891471}{\texttt{stdout}}，但是返回值使用 \texttt{;} 抑制。



这里按了两次回车，以便 Julia 能够读取到换行符。正如你在这个例子中所看到的，\hyperlink{16947913578760238729}{\texttt{write}} 以待写入的数据作为其第二个参数，而 \hyperlink{8104134490906192097}{\texttt{read}} 以待读取的数据的类型作为其第二个参数。



例如，为了读取一个简单的字节数组，我们可以这样做：




\begin{minted}{jlcon}
julia> x = zeros(UInt8, 4)
4-element Array{UInt8,1}:
 0x00
 0x00
 0x00
 0x00

julia> read!(stdin, x)
abcd
4-element Array{UInt8,1}:
 0x61
 0x62
 0x63
 0x64
\end{minted}



但是，因为这有些繁琐，所以提供了几个方便的方法。例如，我们可以把上面的代码编写为：




\begin{minted}{jlcon}
julia> read(stdin, 4)
abcd
4-element Array{UInt8,1}:
 0x61
 0x62
 0x63
 0x64
\end{minted}



或者如果我们想要读取一整行：




\begin{minted}{jlcon}
julia> readline(stdin)
abcd
"abcd"
\end{minted}



请注意，根据你的终端设置，你的 TTY 可能是行缓冲的，因此在数据发送给 Julia 前可能需要额外的回车。



若要读取 \hyperlink{3330957653919693521}{\texttt{stdin}} 的每一行，可以使用 \hyperlink{3474649815265066504}{\texttt{eachline}}：




\begin{minted}{julia}
for line in eachline(stdin)
    print("Found $line")
end
\end{minted}



或者如果你想要按字符读取的话，使用 \hyperlink{8104134490906192097}{\texttt{read}} ：




\begin{minted}{julia}
while !eof(stdin)
    x = read(stdin, Char)
    println("Found: $x")
end
\end{minted}



\hypertarget{14803809014545196748}{}


\section{文本 I/O}



请注意，上面提到的 \hyperlink{16947913578760238729}{\texttt{write}} 方法对二进制流进行操作。具体来说，值不会转换为任何规范的文本表示形式，而是按原样输出：




\begin{minted}{jlcon}
julia> write(stdout, 0x61);  # suppress return value 1 with ;
a
\end{minted}



请注意，\texttt{a} 被 \hyperlink{16947913578760238729}{\texttt{write}} 函数写入到 \hyperlink{18181294266083891471}{\texttt{stdout}} 并且返回值为 \texttt{1}（因为 \texttt{0x61} 为一个字节）。



对于文本 I/O，请根据需要使用 \hyperlink{8248717042415202230}{\texttt{print}} 或 \hyperlink{4561869563484222675}{\texttt{show}} 方法（有关这两个方法之间的差异的详细讨论，请参阅它们的文档）：




\begin{minted}{jlcon}
julia> print(stdout, 0x61)
97
\end{minted}



有关如何实现自定义类型的显示方法的更多信息，请参阅 \hyperlink{5246022684399876238}{自定义 pretty-printing}。



\hypertarget{11059597754503252223}{}


\section{IO 输出的上下文信息}



有时，IO 输出可受益于将上下文信息传递到 show 方法的能力。\hyperlink{13454403377667762339}{\texttt{IOContext}} 对象提供了将任意元数据与 IO 对象相关联的框架。例如，\texttt{:compact => true} 向 IO 对象添加一个参数来提示调用的 show 方法应该打印一个较短的输出（如果适用）。有关常用属性的列表，请参阅 \hyperlink{13454403377667762339}{\texttt{IOContext}} 文档。



\hypertarget{17626527008259433393}{}


\section{使用文件}



和其他环境一样，Julia 有 \hyperlink{300818094931158296}{\texttt{open}} 函数，它接收文件名并返回一个 \hyperlink{12496894737220238417}{\texttt{IOStream}} 对象，你可以用该对象来对文件进行读取和写入。例如，如果我们有文件 \texttt{hello.txt}，其内容为 \texttt{Hello, World!}：




\begin{minted}{jlcon}
julia> f = open("hello.txt")
IOStream(<file hello.txt>)

julia> readlines(f)
1-element Array{String,1}:
 "Hello, World!"
\end{minted}



若要写入文件，则可以带着 write（\texttt{{\textquotedbl}w{\textquotedbl}}）标志来打开它：




\begin{minted}{jlcon}
julia> f = open("hello.txt","w")
IOStream(<file hello.txt>)

julia> write(f,"Hello again.")
12
\end{minted}



你如果在此刻检查 \texttt{hello.txt} 的内容，会注意到它是空的；改动实际上还没有写入到磁盘中。这是因为 \texttt{IOStream} 必须在写入实际刷新到磁盘前关闭：




\begin{minted}{jlcon}
julia> close(f)
\end{minted}



再次检查 \texttt{hello.txt} 将显示其内容已被更改。



打开文件，对其内容执行一些操作，并再次关闭它是一种非常常见的模式。为了使这更容易，\hyperlink{300818094931158296}{\texttt{open}} 还有另一种调用方式，它以一个函数作为其第一个参数，以文件名作为其第二个参数，以该文件为参数调用该函数，然后再次关闭它。例如，给定函数：




\begin{minted}{julia}
function read_and_capitalize(f::IOStream)
    return uppercase(read(f, String))
end
\end{minted}



可以调用：




\begin{minted}{jlcon}
julia> open(read_and_capitalize, "hello.txt")
"HELLO AGAIN."
\end{minted}



来打开 \texttt{hello.txt}，对它调用 \texttt{read\_and\_capitalize}，关闭 \texttt{hello.txt} 并返回大写的内容。



为了避免被迫定义一个命名函数，你可以使用 \texttt{do} 语法，它可以动态地创建匿名函数：




\begin{minted}{jlcon}
julia> open("hello.txt") do f
           uppercase(read(f, String))
       end
"HELLO AGAIN."
\end{minted}



\hypertarget{15377875155010529137}{}


\section{一个简单的 TCP 示例}



让我们直接进入一个 TCP 套接字相关的简单示例。此功能位于名为 \texttt{Sockets} 的标准库中。让我们先创建一个简单的服务器：




\begin{minted}{jlcon}
julia> using Sockets

julia> errormonitor(@async begin
           server = listen(2000)
           while true
               sock = accept(server)
               println("Hello World\n")
           end
       end)
Task (runnable) @0x00007fd31dc11ae0
\end{minted}



对于那些熟悉 Unix 套接字 API 的人，这些方法名称会让人感觉很熟悉，可是它们的用法比原始的 Unix 套接字 API 要简单些。在本例中，首次调用 \hyperlink{780704944207038170}{\texttt{listen}} 会创建一个服务器，等待传入指定端口（2000）的连接。




\begin{minted}{jlcon}
julia> listen(2000) # 监听（IPv4 下的）localhost:2000
Sockets.TCPServer(active)

julia> listen(ip"127.0.0.1",2000) # 等价于第一个
Sockets.TCPServer(active)

julia> listen(ip"::1",2000) # 监听（IPv6 下的）localhost:2000
Sockets.TCPServer(active)

julia> listen(IPv4(0),2001) # 监听所有 IPv4 接口的端口 2001
Sockets.TCPServer(active)

julia> listen(IPv6(0),2001) # 监听所有 IPv6 接口的端口 2001
Sockets.TCPServer(active)

julia> listen("testsocket") # 监听 UNIX 域套接字
Sockets.PipeServer(active)

julia> listen("\\\\.\\pipe\\testsocket") # 监听 Windows 命名管道
Sockets.PipeServer(active)
\end{minted}



请注意，最后一次调用返回的类型是不同的。这是因为此服务器不监听 TCP，而是监听命名管道（Windows）或 UNIX 域套接字。还请注意 Windows 命名管道格式必须具有特定的模式，即名称前缀（\texttt{{\textbackslash}{\textbackslash}.{\textbackslash}pipe{\textbackslash}}），以便唯一标识\href{https://docs.microsoft.com/windows/desktop/ipc/pipe-names}{文件类型}。TCP 和命名管道或 UNIX 域套接字之间的区别是微妙的，这与 \hyperlink{1426793569216032849}{\texttt{accept}} 和 \hyperlink{5152827542417649360}{\texttt{connect}} 方法有关。\hyperlink{1426793569216032849}{\texttt{accept}} 方法检索到连接到我们刚创建的服务器的客户端的连接，而 \hyperlink{5152827542417649360}{\texttt{connect}} 函数使用指定的方法连接到服务器。\hyperlink{5152827542417649360}{\texttt{connect}} 函数接收与 \hyperlink{780704944207038170}{\texttt{listen}} 相同的参数，因此，假设环境（即 host、cwd 等）相同，你应该能够将相同的参数传递给 \hyperlink{5152827542417649360}{\texttt{connect}}，就像你在监听建立连接时所做的那样。那么让我们尝试一下（在创建上面的服务器之后）：




\begin{minted}{jlcon}
julia> connect(2000)
TCPSocket(open, 0 bytes waiting)

julia> Hello World
\end{minted}



不出所料，我们看到「Hello World」被打印出来。那么，让我们分析一下幕后发生的事情。在我们调用 \hyperlink{5152827542417649360}{\texttt{connect}} 时，我们连接到刚刚创建的服务器。与此同时，accept 函数返回到新创建的套接字的服务器端连接，并打印「Hello World」来表明连接成功。



Julia 的强大优势在于，即使 I/O 实际上是异步发生的，API 也以同步方式暴露，我们不必担心回调，甚至不必确保服务器能够运行。在我们调用 \hyperlink{5152827542417649360}{\texttt{connect}} 时，当前任务等待建立连接，并在这之后才继续执行。在此暂停中，服务器任务恢复执行（因为现在有一个连接请求是可用的），接受该连接，打印信息并等待下一个客户端。读取和写入以同样的方式运行。为了理解这一点，请考虑以下简单的 echo 服务器：




\begin{minted}{jlcon}
julia> errormonitor(@async begin
           server = listen(2001)
           while true
               sock = accept(server)
               @async while isopen(sock)
                   write(sock, readline(sock, keep=true))
               end
           end
       end)
Task (runnable) @0x00007fd31dc12e60

julia> clientside = connect(2001)
TCPSocket(RawFD(28) open, 0 bytes waiting)

julia> errormonitor(@async while isopen(clientside)
           write(stdout, readline(clientside, keep=true))
       end)
Task (runnable) @0x00007fd31dc11870

julia> println(clientside,"Hello World from the Echo Server")
Hello World from the Echo Server
\end{minted}



与其他流一样，使用 \hyperlink{5331333469799487255}{\texttt{close}} 即可断开该套接字：




\begin{minted}{jlcon}
julia> close(clientside)
\end{minted}



\hypertarget{8798664283149579111}{}


\section{解析 IP 地址}



与 \hyperlink{780704944207038170}{\texttt{listen}} 方法不一致的 \hyperlink{5152827542417649360}{\texttt{connect}} 方法之一是 \texttt{connect(host::String,port)}，它将尝试连接到由 \texttt{host} 参数给定的主机上的由 \texttt{port} 参数给定的端口。它允许你执行以下操作：




\begin{minted}{jlcon}
julia> connect("google.com", 80)
TCPSocket(RawFD(30) open, 0 bytes waiting)
\end{minted}



此功能的基础是 \hyperlink{10301989504197190983}{\texttt{getaddrinfo}}，它将执行适当的地址解析：




\begin{minted}{jlcon}
julia> getaddrinfo("google.com")
ip"74.125.226.225"
\end{minted}



\hypertarget{10935005933197236630}{}


\section{异步 I/O}



\hyperlink{8104134490906192097}{\texttt{Base.read}} 和 \hyperlink{16947913578760238729}{\texttt{Base.write}} 的所有 I/O 操作都可以通过使用 \hyperlink{17473131347184639576}{coroutines} 异步执行。 你可以使用 \hyperlink{10770947021537241619}{\texttt{@async}} 宏创建一个新的协程来读取或写入流：




\begin{minted}{jlcon}
julia> task = @async open("foo.txt", "w") do io
           write(io, "Hello, World!")
       end;

julia> wait(task)

julia> readlines("foo.txt")
1-element Array{String,1}:
 "Hello, World!"
\end{minted}



通常会遇到您想要同时执行多个异步操作并等待它们全部完成的情况。你可以使用\href{@ ref}{\texttt{@ sync}}宏，这会阻塞你的程序直到它所包裹的所有协程运行完毕。




\begin{minted}{jlcon}
julia> using Sockets

julia> @sync for hostname in ("google.com", "github.com", "julialang.org")
           @async begin
               conn = connect(hostname, 80)
               write(conn, "GET / HTTP/1.1\r\nHost:$(hostname)\r\n\r\n")
               readline(conn, keep=true)
               println("Finished connection to $(hostname)")
           end
       end
Finished connection to google.com
Finished connection to julialang.org
Finished connection to github.com
\end{minted}



\hypertarget{6184253979084926}{}


\chapter{并行计算}



Julia 支持这四类并发和并行编程：



\begin{itemize}
\item[1. ] \textbf{异步“任务”或协程}：

Julia Tasks 允许暂停和恢复 I/O、事件处理、生产者-消费者进程和类似模式的计算。 Tasks 可以通过\href{@ref}{\texttt{wail}} 和\hyperlink{11007884648860062495}{\texttt{fetch}} 等操作进行同步，并通过 \hyperlink{12548845729684045604}{\texttt{Channel}} 进行通信。 虽然严格来说不是并行计算，但 Julia 允许在多个线程上调度任务。


\item[2. ] \textbf{多线程}：

Julia 的\hyperlink{3839117367442451534}{多线程}提供了在多个线程、CPU 内核或共享内存上同时调度任务的能力。这通常是在个人 PC 或单个大型多核服务器上获得并行性的最简单方法。 Julia 的多线程是可组合的。当一个多线程函数调用另一个多线程函数时，Julia 将在可用资源上全局调度所有线程，而不会超额使用。


\item[3. ] \textbf{分布式计算}:

分布式计算运行多个具有独立内存空间的 Julia 进程。 这些可以在同一台计算机或多台计算机上。 \texttt{Distributed} 标准库提供了远程执行 Julia 函数的能力。 使用这个基本构建块，可以构建许多不同类型的分布式计算抽象。 像 \href{https://github.com/JuliaParallel/DistributedArrays.jl}{\texttt{DistributedArrays.jl}} 这样的包就是这种抽象的一个示例。 另一方面，像 \href{https://github.com/JuliaParallel/MPI.jl}{\texttt{MPI.jl}} 和 \href{https://github.com/JuliaParallel/Elemental.jl}{\texttt{Elemental.jl}} 这样的包提供对现有 MPI 生态库的访问。


\item[4. ] \textbf{GPU 计算}:

Julia GPU 编译器提供了在 GPU 上本地运行 Julia 代码的能力。 有一个针对 GPU 的丰富的 Julia 软件包生态系统。 \href{https://juliagpu.org}{JuliaGPU.org} 网站提供了功能列表、支持的 GPU、相关包和文档。

\end{itemize}


\hypertarget{2579276902393370275}{}


\chapter{异步编程}



当程序需要与外部世界交互时，例如通过互联网与另一台机器通信时，程序中的操作可能需要以无法预测的顺序发生。假设你的程序需要下载一个文件。我们想启动下载操作，在等待下载完成的同时执行其他操作，然后在空闲时继续执行下载文件的代码。这种场景属于异步编程，有时也称为并发编程（因为从概念上讲，同时发生多种事情）。



为了解决这些可能的情况，Julia 提供了任务 \hyperlink{7131243650304654155}{\texttt{Task}}（也有其他几个名称，例如对称协程、轻量级线程、协作多任务处理或one-shot continuations）。当一项计算工作（实际上，执行特定功能）被指定为 \hyperlink{7131243650304654155}{\texttt{Task}} 时，可以通过切换到另一个 \hyperlink{7131243650304654155}{\texttt{Task}} 来中断它。 最初的 \hyperlink{7131243650304654155}{\texttt{Task}} 稍后可以恢复，此时它将从上次中断的地方开始。 初看这似乎类似于函数调用。 但是，有两个关键区别。 首先，切换任务不占用任何空间，因此可以在不消耗调用堆栈的情况下进行任意数量的任务切换。 其次，任务之间的切换可以以任何顺序发生，这与函数调用不同，在函数调用中，被调用的函数必须在返回到调用函数之前完成执行。



\hypertarget{10912874536153090251}{}


\section{基本 \texttt{Task} 操作}



你可以将\texttt{Task}视为要执行的计算工作单元的句柄。 它有一个创建-开始-运行-结束的生命周期。 Task 是通过在要运行的 0 参数函数上调用 \texttt{Task} 构造函数来创建的，或者使用 \hyperlink{16142823989571622868}{\texttt{@task}} 宏：




\begin{minted}{jlcon}
julia> t = @task begin; sleep(5); println("done"); end
Task (runnable) @0x00007f13a40c0eb0
\end{minted}



\texttt{@task x} 等价于 \texttt{Task(()->x)}。



此任务将等待五秒钟，然后打印\texttt{done}。 但是，它还没有开始运行。 我们可以随时通过调用 \hyperlink{9185853093207176818}{\texttt{schedule}} 来运行它：




\begin{minted}{jlcon}
julia> schedule(t);
\end{minted}



如果你在 REPL 中尝试这个，你会看到 \texttt{schedule} 立即有返回值。那是因为它只是将 \texttt{t} 添加到要运行的内部任务队列中。然后，REPL 将打印下一个提示并等待更多输入。等待键盘输入为其他任务提供了运行的机会，因此此时 \texttt{t} 将启动。 \texttt{t} 调用 \hyperlink{3231475347583891391}{\texttt{sleep}}，它设置一个计时器并停止执行。 如果已经安排了其他任务，那么它们就可以运行了。五秒后，计时器触发并重新启动\texttt{t}，你将看到打印的\texttt{done}。 然后\texttt{t} 执行完毕了。



\hyperlink{13761789780433862250}{\texttt{wait}} 函数会阻塞调用任务，直到其他任务完成。 例如，如果输入：




\begin{minted}{jlcon}
julia> schedule(t); wait(t)
\end{minted}



在下一个输入提示出现之前，你将看到五秒钟的停顿，而不是只调用 \texttt{schedule}。 那是因为 REPL 等待 \texttt{t} 完成之后才继续。



一般来说，创建一个任务会想立即执行它，为此提供了宏 \hyperlink{10770947021537241619}{\texttt{@async}} –- \texttt{@async x} 等价于 \texttt{schedule(@task x )}。



\hypertarget{2837362571325865994}{}


\section{在 Channel 中进行通信}



在某些问题中，所需的各种工作并不是通过函数调用自然关联的； 在需要完成的工作中没有明显的“调用者”或“被调用者”。 一个典型的例子是生产者-消费者问题，其中一个复杂的过程正在生成值，而另一个复杂的过程正在消耗它们。消费者不能简单地调用生产者函数来获取一个值，因为生产者可能有更多的值要生成，因此可能还没有准备好返回。对于任务，生产者和消费者都可以根据需要运行，根据需要来回传递值。



Julia 提供了 \hyperlink{12548845729684045604}{\texttt{Channel}} 机制来解决这个问题。一个 \hyperlink{12548845729684045604}{\texttt{Channel}} 是一个先进先出的队列，允许多个 \texttt{Task} 对它可以进行读和写。



让我们定义一个生产者任务，调用 \hyperlink{10812715779190652189}{\texttt{put!}} 来生产数值。为了消费数值，我们需要对生产者开始新任务进行排班。可以使用一个特殊的 \hyperlink{12548845729684045604}{\texttt{Channel}} 组件来运行一个与其绑定的 \texttt{Task}，它能接受单参数函数作为其参数，然后可以用 \hyperlink{4963355246106153560}{\texttt{take!}} 从 \hyperlink{12548845729684045604}{\texttt{Channel}} 对象里不断地提取值：




\begin{minted}{jlcon}
julia> function producer(c::Channel)
           put!(c, "start")
           for n=1:4
               put!(c, 2n)
           end
           put!(c, "stop")
       end;

julia> chnl = Channel(producer);

julia> take!(chnl)
"start"

julia> take!(chnl)
2

julia> take!(chnl)
4

julia> take!(chnl)
6

julia> take!(chnl)
8

julia> take!(chnl)
"stop"
\end{minted}



一种思考这种行为的方式是，“生产者”能够多次返回。在两次调用 \hyperlink{10812715779190652189}{\texttt{put!}} 之间，生产者的执行是挂起的，此时由消费者接管控制。



返回的 \hyperlink{12548845729684045604}{\texttt{Channel}} 可以被用作一个 \texttt{for} 循环的迭代对象，此时循环变量会依次取到所有产生的值。当 \hyperlink{12548845729684045604}{\texttt{Channel}} 关闭时，循环就会终止。




\begin{minted}{jlcon}
julia> for x in Channel(producer)
           println(x)
       end
start
2
4
6
8
stop
\end{minted}



注意我们并不需要显式地在生产者中关闭 \hyperlink{12548845729684045604}{\texttt{Channel}}。这是因为 \hyperlink{12548845729684045604}{\texttt{Channel}} 对 \hyperlink{7131243650304654155}{\texttt{Task}} 的绑定同时也意味着 \texttt{Channel} 的生命周期与绑定的 \texttt{Task} 一致。当 \texttt{Task} 结束时，\texttt{Channel} 对象会自动关闭。多个 \texttt{Channel} 可以绑定到一个 \texttt{Task}，反之亦然。



\hyperlink{7131243650304654155}{\texttt{Task}} 构造函数需要一个不带参数的函数，而创建任务绑定的 channel 的 \hyperlink{12548845729684045604}{\texttt{Channel}} 方法需要一个接受 \hyperlink{12548845729684045604}{\texttt{Channel}}类型的单个参数的函数。 一个常见的模式是对生产者进行参数化，在这种情况下，需要一个偏函数来创建一个 0 或 1 个参数 \hyperlink{5206910466103540848}{匿名函数}。



对于 \hyperlink{7131243650304654155}{\texttt{Task}} 对象，可以直接用，也可以为了方便用宏。




\begin{minted}{julia}
function mytask(myarg)
    ...
end

taskHdl = Task(() -> mytask(7))
# or, equivalently
taskHdl = @task mytask(7)
\end{minted}



为了安排更高级的工作分配模式，\hyperlink{13811388816704022260}{\texttt{bind}} 和 \hyperlink{9185853093207176818}{\texttt{schedule}} 可以与 \hyperlink{7131243650304654155}{\texttt{Task}} 和 \hyperlink{12548845729684045604}{\texttt{Channel}} 构造函数配合使用，显式地连接一些 \texttt{Channel} 和生产者或消费者 \texttt{Task}。



\hypertarget{9800357313740140825}{}


\subsection{更多关于 Channel 的知识}



一个管道可以形象得看做是一个管子，一端可读，另一端可写：



\begin{itemize}
\item 不同的 task 可以通过 \hyperlink{10812715779190652189}{\texttt{put!}} 往同一个 channel 并发地写入。


\item 不同的 task 也可以通过 \hyperlink{4963355246106153560}{\texttt{take!}} 从同一个 channel 并发地取数据


\item 举个例子：


\begin{minted}{julia}
# Given Channels c1 and c2,
c1 = Channel(32)
c2 = Channel(32)

# and a function `foo` which reads items from c1, processes the item read
# and writes a result to c2,
function foo()
    while true
        data = take!(c1)
        [...]               # process data
        put!(c2, result)    # write out result
    end
end

# we can schedule `n` instances of `foo` to be active concurrently.
for _ in 1:n
    errormonitor(@async foo())
end
\end{minted}


\item Channel 可以通过 \texttt{Channel\{T\}(sz)} 构造，得到的 channel 只能存储类型 \texttt{T} 的数据。如果 \texttt{T} 没有指定，那么 channel 可以存任意类型。\texttt{sz} 表示该 channel 能够存储的最大元素个数。比如 \texttt{Channel(32)} 得到的 channel 最多可以存储32个元素。而 \texttt{Channel\{MyType\}(64)} 则可以最多存储64个 \texttt{MyType} 类型的数据。


\item 如果一个 \hyperlink{12548845729684045604}{\texttt{Channel}} 是空的，读取的 task(即执行 \hyperlink{4963355246106153560}{\texttt{take!}} 的 task)会被阻塞直到有新的数据准备好了。


\item 如果一个 \hyperlink{12548845729684045604}{\texttt{Channel}} 是满的，那么写入的 task(即执行 \hyperlink{10812715779190652189}{\texttt{put!}} 的 task)则会被阻塞，直到 Channel 有空余。


\item
\item 一个 \hyperlink{12548845729684045604}{\texttt{Channel}} 一开始处于开启状态，也就是说可以被 \hyperlink{4963355246106153560}{\texttt{take!}} 读取和 \hyperlink{10812715779190652189}{\texttt{put!}} 写入。\hyperlink{5331333469799487255}{\texttt{close}} 会关闭一个 \hyperlink{12548845729684045604}{\texttt{Channel}}，对于一个已经关闭的 \hyperlink{12548845729684045604}{\texttt{Channel}}，\hyperlink{10812715779190652189}{\texttt{put!}} 会失败，例如：


\begin{minted}{jlcon}
julia> c = Channel(2);

julia> put!(c, 1) # `put!` on an open channel succeeds
1

julia> close(c);

julia> put!(c, 2) # `put!` on a closed channel throws an exception.
ERROR: InvalidStateException("Channel is closed.",:closed)
Stacktrace:
[...]
\end{minted}


\item \hyperlink{4963355246106153560}{\texttt{take!}} 和 \hyperlink{11007884648860062495}{\texttt{fetch}} (只读取，不会将元素从 channel 中删掉)仍然可以从一个已经关闭的 channel 中读数据，直到 channel 被取空了为止。继续上面的例子：


\begin{minted}{jlcon}
julia> fetch(c) # Any number of `fetch` calls succeed.
1

julia> fetch(c)
1

julia> take!(c) # The first `take!` removes the value.
1

julia> take!(c) # No more data available on a closed channel.
ERROR: InvalidStateException("Channel is closed.",:closed)
Stacktrace:
[...]
\end{minted}

\end{itemize}


考虑这样一个用 channel 做 task 之间通信的例子。首先，起 4 个 task 来处理一个 \texttt{jobs} channel 中的数据。\texttt{jobs} 中的每个任务通过 \texttt{job\_id} 来表示，然后每个 task 模拟读取一个 \texttt{job\_id}，然后随机等待一会儿，然后往一个 results channel 中写入一个元组，它分别包含 \texttt{job\_id} 和执行的时间，最后将结果打印出来：




\begin{minted}{jlcon}
julia> const jobs = Channel{Int}(32);

julia> const results = Channel{Tuple}(32);

julia> function do_work()
           for job_id in jobs
               exec_time = rand()
               sleep(exec_time)                # simulates elapsed time doing actual work
                                               # typically performed externally.
               put!(results, (job_id, exec_time))
           end
       end;

julia> function make_jobs(n)
           for i in 1:n
               put!(jobs, i)
           end
       end;

julia> n = 12;

julia> errormonitor(@async make_jobs(n)); # feed the jobs channel with "n" jobs

julia> for i in 1:4 # start 4 tasks to process requests in parallel
           errormonitor(@async do_work())
       end

julia> @elapsed while n > 0 # print out results
           job_id, exec_time = take!(results)
           println("$job_id finished in $(round(exec_time; digits=2)) seconds")
           global n = n - 1
       end
4 finished in 0.22 seconds
3 finished in 0.45 seconds
1 finished in 0.5 seconds
7 finished in 0.14 seconds
2 finished in 0.78 seconds
5 finished in 0.9 seconds
9 finished in 0.36 seconds
6 finished in 0.87 seconds
8 finished in 0.79 seconds
10 finished in 0.64 seconds
12 finished in 0.5 seconds
11 finished in 0.97 seconds
0.029772311
\end{minted}



不用 \texttt{errormonitor(t)}，一个更稳健的解决方案是使用 \texttt{bind(results, t)}，这不仅会记录任何意外故障，还会强制相关资源关闭并向上抛出错误。



\hypertarget{6751487137488414273}{}


\section{更多任务操作}



任务操作建立在称为 \hyperlink{4920987536368477483}{\texttt{yieldto}} 的底层原始运算上。 \texttt{yieldto(task, value)} 挂起当前 task，然后切换到指定的 \texttt{task}，并使该任务的最后一个 \hyperlink{4920987536368477483}{\texttt{yieldto}} 调用返回指定的 \texttt{value}。 请注意，\hyperlink{4920987536368477483}{\texttt{yieldto}} 是使用任务式流程控制所需的唯一操作；我们总是切换到不同的任务，而不是调用和返回。 这就是为什么这个特性也被称为“对称协程”； 每个任务都使用相同的机制来回切换。



\hyperlink{4920987536368477483}{\texttt{yieldto}} 功能强大，但大多数 \texttt{Task} 的使用都不会直接调用它。思考为什么会这样。如果你切换当前 \texttt{Task}，你很可能会在某个时候想切换回来。但知道什么时候切换回来和那个 \texttt{Task} 负责切换回来需要大量的协调。例如，\hyperlink{10812715779190652189}{\texttt{put!}} 和 \hyperlink{4963355246106153560}{\texttt{take!}} 是阻塞操作，当在渠道环境中使用时，维持状态以记住消费者是谁。不需要人为地记录消费 \texttt{Task}，正是使得 \hyperlink{10812715779190652189}{\texttt{put!}} 比底层 \hyperlink{4920987536368477483}{\texttt{yieldto}} 易用的原因。



除了 \hyperlink{4920987536368477483}{\texttt{yieldto}} 之外，也需要一些其它的基本函数来更高效地使用 \texttt{Task}。



\begin{itemize}
\item \hyperlink{12929971401717674174}{\texttt{current\_task}} 获取当前运行 \texttt{Task} 的索引。


\item \hyperlink{7432450399685996831}{\texttt{istaskdone}} 查询一个 \texttt{Task} 是否退出.


\item \hyperlink{188637489024602838}{\texttt{istaskstarted}} 查询一个 \texttt{Task} 是否已经开始运行。


\item \hyperlink{8292907206163344794}{\texttt{task\_local\_storage}} 操纵针对当前 \texttt{Task} 的键值存储。

\end{itemize}


\hypertarget{18351392990270521875}{}


\section{\texttt{Task} 和事件}



多数 \texttt{Task} 切换是在等待如 I/O 请求的事件，由 Julia Base 里的调度器执行。调度器维持一个可运行 \texttt{Task} 的队列，并执行一个事件循环，来根据例如收到消息等外部事件来重启 \texttt{Task}。



等待一个事件的基本函数是 \hyperlink{13761789780433862250}{\texttt{wait}}。很多对象都实现了 \hyperlink{13761789780433862250}{\texttt{wait}} 函数；例如，给定一个 \texttt{Process} 对象，\hyperlink{13761789780433862250}{\texttt{wait}} 将等待它退出。\hyperlink{13761789780433862250}{\texttt{wait}} 通常是隐式的，例如，\hyperlink{13761789780433862250}{\texttt{wait}} 可能发生在调用 \hyperlink{8104134490906192097}{\texttt{read}} 时等待数据可用。



在所有这些情况下，\hyperlink{13761789780433862250}{\texttt{wait}} 最终会操作一个 \hyperlink{286351753995469758}{\texttt{Condition}} 对象，由它负责排队和重启 \texttt{Task}。当 \texttt{Task} 在一个 \hyperlink{286351753995469758}{\texttt{Condition}} 上调用 \hyperlink{13761789780433862250}{\texttt{wait}} 时，该 Task 就被标记为不可执行，加到条件的队列中，并切回调度器。调度器将选择另一个 \texttt{Task} 来运行，或者阻止外部事件的等待。如果所有运行良好，最终一个事件处理器将在这个条件下调用 \hyperlink{2865179286002578885}{\texttt{notify}}，使得等待该条件的 \texttt{Task} 又变成可运行。



通过调用 \hyperlink{7131243650304654155}{\texttt{Task}} 显式创建的任务，一开始并不被调度器知道。这允许你根据需要使用 \hyperlink{4920987536368477483}{\texttt{yieldto}} 手动管理任务。 但是，当此类任务等待事件时，它仍会在事件发生时自动重新启动，正如你所期望。



\hypertarget{7129488293979654813}{}


\chapter{多线程}



访问此 \href{https://julialang.org/blog/2019/07/multithreading/}{博客文章} 以了解 Julia 多线程特性。



\hypertarget{17964156815953179574}{}


\section{启用Julia多线程}



Julia 默认启动一个线程执行代码，这点可以通过 \hyperlink{11061583461116144745}{\texttt{Threads.nthreads()}} 来确认：




\begin{minted}{jlcon}
julia> Threads.nthreads()
1
\end{minted}



执行线程的数量通过使用\texttt{-t}/\texttt{--threads} 命令行参数或使用\hyperlink{16384778780724552380}{\texttt{JULIA\_NUM\_THREADS}} 环境变量。 当两者都被指定时，\texttt{-t}/\texttt{--threads} 优先级更高。



\begin{quote}
\textbf{Julia 1.5}

\texttt{-t}/\texttt{--threads} 命令行参数至少需要 Julia 1.5。在旧版本中，你必须改用环境变量。

\end{quote}


让我们以4个线程启动Julia




\begin{lstlisting}
$ julia --threads 4
\end{lstlisting}



现在确认下确实有4个线程：




\begin{minted}{jlcon}
julia> Threads.nthreads()
4
\end{minted}



不过我们现在是在 master 线程，用 \hyperlink{12668125807854133993}{\texttt{Threads.threadid}} 确认下：




\begin{minted}{jlcon}
julia> Threads.threadid()
1
\end{minted}



\begin{quote}
\textbf{Note}

如果你更喜欢使用环境变量，可以按如下方式设置它 Bash (Linux/macOS):


\begin{lstlisting}
export JULIA_NUM_THREADS=4
\end{lstlisting}

C shell on Linux/macOS, CMD on Windows:


\begin{lstlisting}
set JULIA_NUM_THREADS=4
\end{lstlisting}

Powershell on Windows:


\begin{lstlisting}
$env:JULIA_NUM_THREADS=4
\end{lstlisting}

Note that this must be done \emph{before} starting Julia.

\end{quote}


\begin{quote}
\textbf{Note}

使用 \texttt{-t}/\texttt{--threads} 指定的线程数传播到使用 \texttt{-p}/\texttt{--procs} 或 \texttt{--machine-file} 命令行选项产生的工作进程。 例如，\texttt{julia -p2 -t2} 产生 1 个主进程和 2 个工作进程，并且所有三个进程都启用了 2 个线程。 要对工作线程进行更细粒度的控制，请使用 \hyperlink{2657399037748470653}{\texttt{addprocs}} 并将 \texttt{-t}/\texttt{--threads} 作为 \texttt{exeflags} 传递。

\end{quote}


\hypertarget{3389279084104754524}{}


\section{数据竞争自由}



你有责任确保程序没有数据竞争，如果你不遵守该要求，则不能假设这里承诺的任何内容。 观察到的结果可能是反直觉的。



为了确保这一点，最好的办法是获取多线程同时访问的数据的锁。 例如，在大多数情况下，你应该使用以下代码模板：




\begin{minted}{jlcon}
julia> lock(lk) do
           use(a)
       end

julia> begin
           lock(lk)
           try
               use(a)
           finally
               unlock(lk)
           end
       end
\end{minted}



其中 \texttt{lk} 是一个锁（例如 \texttt{ReentrantLock()}）， \texttt{a} 是数据。



此外，Julia 在出现数据竞争时不是内存安全的。如果另一个线程可能会写入数据，则在读取\emph{任何}数据时都要非常小心！ 相反，在更改其他线程访问的数据（例如分配给全局或闭包变量）时，请始终使用上述锁模式。




\begin{minted}{julia}
Thread 1:
global b = false
global a = rand()
global b = true

Thread 2:
while !b; end
bad_read1(a) # it is NOT safe to access `a` here!

Thread 3:
while !@isdefined(a); end
bad_read2(a) # it is NOT safe to access `a` here
\end{minted}



\hypertarget{5846243171627332000}{}


\section{\texttt{@threads}宏}



下面用一个简单的例子测试我们原生的线程，首先创建一个全零的数组：




\begin{minted}{jlcon}
julia> a = zeros(10)
10-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
\end{minted}



现在用4个线程模拟操作这个数组，每个线程往对应的位置写入线程ID。



Julia 用 \hyperlink{15582842999596899869}{\texttt{Threads.@threads}} 宏实现并行循环，该宏加在 \texttt{for} 循环前面，提示 Julia 循环部分是一个多线程的区域：




\begin{minted}{jlcon}
julia> Threads.@threads for i = 1:10
           a[i] = Threads.threadid()
       end
\end{minted}



根据线程调度，迭代在各线程中进行拆分，之后各线程将自己的线程ID写入对应区域。




\begin{minted}{jlcon}
julia> a
10-element Vector{Float64}:
 1.0
 1.0
 1.0
 2.0
 2.0
 2.0
 3.0
 3.0
 4.0
 4.0
\end{minted}



注意 \hyperlink{15582842999596899869}{\texttt{Threads.@threads}} 并没有一个像 \hyperlink{4581929266257108937}{\texttt{@distributed}} 一样的可选的 reduction 参数。



\hypertarget{3709065031863484492}{}


\section{原子操作}



Julia 支持访问和修改值的\textbf{原子}操作，即以一种线程安全的方式来避免\href{https://en.wikipedia.org/wiki/Race\_condition}{竞态条件}。一个值（必须是基本类型的，primitive type）可以通过 \hyperlink{1140117372581270616}{\texttt{Threads.Atomic}} 来包装起来从而支持原子操作。下面看个例子：




\begin{minted}{jlcon}
julia> i = Threads.Atomic{Int}(0);

julia> ids = zeros(4);

julia> old_is = zeros(4);

julia> Threads.@threads for id in 1:4
           old_is[id] = Threads.atomic_add!(i, id)
           ids[id] = id
       end

julia> old_is
4-element Vector{Float64}:
 0.0
 1.0
 7.0
 3.0

julia> i[]
 10

julia> ids
4-element Vector{Float64}:
 1.0
 2.0
 3.0
 4.0
\end{minted}



如果不加 \texttt{Atomic} 的话，那么会因为竞态条件而得到错误的结果，下面是一个没有避免竞态条件的例子：




\begin{minted}{jlcon}
julia> using Base.Threads

julia> nthreads()
4

julia> acc = Ref(0)
Base.RefValue{Int64}(0)

julia> @threads for i in 1:1000
          acc[] += 1
       end

julia> acc[]
926

julia> acc = Atomic{Int64}(0)
Atomic{Int64}(0)

julia> @threads for i in 1:1000
          atomic_add!(acc, 1)
       end

julia> acc[]
1000
\end{minted}



\hypertarget{12362166886003697681}{}


\section{field粒度的原子操作}



我们还可以使用\href{@ref Base.@atomic}{\texttt{@atomic}}、\href{@ref Base.@atomicswap}{\texttt{@atomicswap}}和\href{@ref Base.@atomicreplace}{\texttt{@atomicreplace}} 宏在更细粒度的级别上使用原子。



内存模型的具体细节和设计的其他细节写在\href{https://gist.github.com/vtjnash/11b0031f2e2a66c9c24d33e810b34ec0}{Julia Atomics Manifesto}中，稍后将正式发布。



struct 声明中的任何字段都可以用 \texttt{@atomic} 修饰，然后任何写入也必须用 \texttt{@atomic} 标记，并且必须使用定义的原子顺序之一（:monotonic、:acquire、:release、:acquire \_release 或 :sequentially\_consistent)。 对原子字段的任何读取也可以使用原子排序约束进行注释，或者如果未指定，将使用单调（宽松）排序完成。



\begin{quote}
\textbf{Julia 1.7}

field粒度的原子操作至少需要 Julia 1.7.

\end{quote}


\hypertarget{7991639019614529846}{}


\section{副作用和可变的函数参数}



使用多线程时，我们必须小心使用非 \href{https://en.wikipedia.org/wiki/Pure\_function}{纯} 的函数，因为我们可能会得到错误的答案。 例如，按照惯例具有 \hyperlink{8429867064470859454}{名称以\texttt{!} 结尾} 的函数会修改它们的参数，因此不是纯函数。



\hypertarget{16383628308663463272}{}


\section{@threadcall}



外部库，例如通过 \hyperlink{14245046751182637566}{\texttt{ccall}} 调用的库，给 Julia 基于任务的 I/O 机制带来了问题。 如果 C 库执行阻塞操作，这会阻止 Julia 调度程序执行任何其他任务，直到调用返回。（例外情况是调用回调到 Julia 的自定义 C 代码，然后它可能会 yield，或者调用 \texttt{jl\_yield()} 的 C 代码，\texttt{jl\_yield} 是 \hyperlink{13455314829114364187}{\texttt{yield}} 的 C 等价物。）



\hyperlink{4118169676263419404}{\texttt{@threadcall}} 宏提供了一种避免在这种情况下停止执行的方法。它调度一个 C 函数以在单独的线程中执行。为此使用默认大小为 4 的线程池。线程池的大小由环境变量\texttt{UV\_THREADPOOL\_SIZE}控制。 在等待空闲线程时，以及一旦线程可用后的函数执行期间，请求任务（在主 Julia 事件循环上）让步给其他任务。 注意，\texttt{@threadcall} 在执行完成之前不会返回。 因此，从用户的角度来看，它与其他 Julia API 一样是一个阻塞调用。



非常关键的一点是，被调用的函数不会再调用回 Julia。



\texttt{@threadcall} 在 Julia 未来的版本中可能会被移除或改变。



\hypertarget{16893517570550920968}{}


\section{注意！}



此时，如果用户代码没有数据竞争，Julia 运行时和标准库中的大多数操作都可以以线程安全的方式使用。 然而，在某些领域，稳定线程支持的工作正在进行中。多线程编程有许多内在的困难，如果使用线程的程序表现出异常或与预期不符的行为（例如崩溃或神秘的结果），通常应该首先怀疑线程交互。



在 Julia 中使用线程时需要注意以下这些特定的限制和警告：



\begin{itemize}
\item 如果多个线程同时使用基本容器类型，且至少有一个线程修改容器时，需要手动加锁（常见示例包括 \texttt{push!} 数组，或将项插入 \texttt{Dict}）。


\item 任务开始在某个线程上运行后（例如通过\texttt{@spawn}），它会在阻塞后始终在同一线程上重新启动。 将来这个限制将被移除，任务会在线程之间迁移。


\item \texttt{@threads} 当前使用静态调度，使用所有线程并为每个线程分配相等的迭代计数。将来，默认时间表可能会更改为动态的。


\item \texttt{@spawn} 使用的时间表是不确定的，不应依赖。


\item 计算绑定、非内存分配任务可以防止垃圾回收在其他正在分配内存的线程中运行。 在这些情况下，可能需要手动调用 \texttt{GC.safepoint()} 以允许 GC 运行。

该限制在未来会被移除。


\item 避免并行运行顶层操作，例如，\texttt{include} 或 \texttt{eval} 评估类型、方法和模块定义。


\item 请注意，如果启用线程，则库注册的终结器可能会中断。 这可能需要在整个生态系统中进行一些过渡工作，然后才能放心地广泛采用线程。 有关更多详细信息，请参阅下一节。

\end{itemize}


\hypertarget{16021882968975399694}{}


\section{终结器的安全使用}



因为终结器可以中断任何代码，所以它们在如何与任何全局状态交互时必须非常小心。 不幸的是，使用终结器的主要原因是更新全局状态（纯函数作为终结器通常毫无意义）。 这让我们陷入了一个难题。 有几种方法可以处理这个问题：



\begin{itemize}
\item[1. ] 当单线程时，代码可以调用内部 \texttt{jl\_gc\_enable\_finalizers} C 函数以防止在关键区域内调度终结器。 在内部，这在某些函数（例如我们的 C locks）中使用，以防止在执行某些操作（增量包加载、代码生成等）时发生递归。 锁和此标志的组合可用于使终结器安全。


\item[2. ] Base 在几个地方采用的第二种策略是显式延迟终结器，直到它可以非递归地获取其锁。 以下示例演示了如何将此策略应用于 \texttt{Distributed.finalize\_ref}：


\begin{minted}{julia}
function finalize_ref(r::AbstractRemoteRef)
    if r.where > 0 # Check if the finalizer is already run
        if islocked(client_refs) || !trylock(client_refs)
            # delay finalizer for later if we aren't free to acquire the lock
            finalizer(finalize_ref, r)
            return nothing
        end
        try # `lock` should always be followed by `try`
            if r.where > 0 # Must check again here
                # Do actual cleanup here
                r.where = 0
            end
        finally
            unlock(client_refs)
        end
    end
    nothing
end
\end{minted}


\item[3. ] 相关的第三种策略是使用不需要 yield 的队列。 我们目前没有在 Base 中实现无锁队列，但 \texttt{Base.InvasiveLinkedListSynchronized\{T\}} 是合适的。 这通常是用于带有事件循环的代码的好策略。 例如，这个策略被 \texttt{Gtk.jl} 用来管理生命周期引用计数。 在这种方法中，我们不会在终结器内部做任何显式工作，而是将其添加到队列中以在更安全的时间运行。 事实上，Julia 的任务调度器已经使用了这种方法，因此将终结器定义为 \texttt{x -> @spawn do\_cleanup(x)} 就是这种方法的一个示例。 但是请注意，这并不控制 \texttt{do\_cleanup} 在哪个线程上运行，因此 \texttt{do\_cleanup} 仍需要获取锁。 如果你实现自己的队列，则不必如此，因为你只能明确地从线程中排出该队列。

\end{itemize}


\hypertarget{5767475590552724220}{}


\chapter{多进程和分布式计算}



分布式内存并行计算的实现由模块 \hyperlink{11988382873486720115}{\texttt{Distributed}} 作为 Julia 附带的标准库的一部分提供。



大多数现代计算机都拥有不止一个 CPU，而且多台计算机可以组织在一起形成一个集群。借助多个 CPU 的计算能力，许多计算过程能够更快地完成，这其中影响性能的两个主要因素分别是：CPU 自身的速度以及它们访问内存的速度。显然，在一个集群中，一个 CPU 访问同一个节点的 RAM 速度是最快的，不过令人吃惊的是，在一台典型的多核笔记本电脑上，由于访问主存和\href{https://www.akkadia.org/drepper/cpumemory.pdf}{缓存}的速度存在差别，类似的现象也会存在。因此，一个良好的多进程环境应该能够管理好某一片内存区域“所属”的CPU。Julia提供的多进程环境是基于消息传递来实现的，可以做到同时让程序在多个进程的不同内存区域中运行。



Julia 的消息传递实现不同于其他环境，例如 MPI\footnotemark[1]。 Julia 中的通信通常是“单方面的”，这意味着程序员只需在双进程操作中显式管理一个进程。 此外，这些操作通常看起来不像“消息发送”和“消息接收”，而是类似于更高级别的操作，例如调用用户函数。



Julia 中的分布式编程基于两个基本概念：\textbf{远程引用}(\emph{remote references})和\textbf{远程调用}(\emph{remote calls})。远程引用是一个对象，任意一个进程可以通过它访问存储在某个特定进程上的对象。远程调用指是某个进程发起的执行函数的请求，该函数会在另一个（也可能是同一个）进程中执行。



远程引用有两种形式：\hyperlink{4170271048165085864}{\texttt{Future}} 和 \hyperlink{16773267780467157552}{\texttt{RemoteChannel}}。



远程调用返回 \hyperlink{4170271048165085864}{\texttt{Future}} 作为其结果。 远程调用立即返回；当远程调用发生在其他地方后，发出调用的进程继续执行下一个操作。你可以通过在返回的 \hyperlink{4170271048165085864}{\texttt{Future}} 上调用 \hyperlink{13761789780433862250}{\texttt{wait}} 来等待远程调用完成，并且可以使用 \hyperlink{11007884648860062495}{\texttt{fetch}}。



对于 \hyperlink{16773267780467157552}{\texttt{RemoteChannel}} 而言，它可以被反复写入。例如，多个进程可以通过引用同一个远程 \texttt{Channel} 来协调相互之间的操作。



每个进程都有一个关联的标识符。 提供交互式 Julia 提示符的进程的 \texttt{id} 总是等于 1。默认情况下用于并行操作的进程被称为“workers”。 当只有一个进程时，进程 1 被认为是一个worker。 否则，workers 被认为是进程 1 之外的所有进程。因此，需要添加 2 个或更多进程才能从 \hyperlink{9432281416771383761}{\texttt{pmap}} 等并行处理方法中获益。 如果你只想在主进程中做其他事情，同时在工作进程上运行长时间的计算，那么添加单个进程是有益的。



让我们开始尝试。 以 \texttt{julia -p n} 开始，在本地机器上提供 \texttt{n} 个工作进程。 通常，\texttt{n} 等于机器上的 CPU 线程（逻辑核心）的数量是有意义的。 请注意，\texttt{-p} 参数隐式加载模块 \hyperlink{11988382873486720115}{\texttt{Distributed}}。




\begin{minted}{julia}
$ julia -p 2

julia> r = remotecall(rand, 2, 2, 2)
Future(2, 1, 4, nothing)

julia> s = @spawnat 2 1 .+ fetch(r)
Future(2, 1, 5, nothing)

julia> fetch(s)
2×2 Array{Float64,2}:
 1.18526  1.50912
 1.16296  1.60607
\end{minted}



\hyperlink{5405028821457292937}{\texttt{remotecall}} 的第一个参数是想要调用的函数，第二个参数是执行函数的进程 \texttt{id}，其余的参数会喂给将要被调用的函数。在 Julia 中进行并行编程时，一般不需要显示地指明具体在哪个进程上执行，不过 \hyperlink{5405028821457292937}{\texttt{remotecall}} 是一个相对底层的接口用来提供细粒度的管理。



可以看到，第一行代码请求进程2构建一个随机矩阵，第二行代码对该矩阵执行加一操作。每次执行的结果存在对应的 Future 中，即 \texttt{r} 和 \texttt{s}。这里 \hyperlink{11231712027010946923}{\texttt{@spawnat}} 宏会在第一个参数所指定的进程中执行后面第二个参数中的表达式。



有时候，你可能会希望立即获取远程计算的结果，比如，在接下来的操作中就需要读取远程调用的结果，这时候你可以使用 \hyperlink{17262349333771600150}{\texttt{remotecall\_fetch}} 函数，其效果相当于 \texttt{fetch(remotecall(...))}，不过更高效些。




\begin{minted}{jlcon}
julia> remotecall_fetch(r-> fetch(r)[1, 1], 2, r)
0.18526337335308085
\end{minted}



这将获取 worker 2 上的数组并返回第一个值。 请注意，在这种情况下，\texttt{fetch} 不会移动任何数据，因为它是在拥有该数组的 worker 上执行的。 还可以这样写：




\begin{minted}{jlcon}
julia> remotecall_fetch(getindex, 2, r, 1, 1)
0.10824216411304866
\end{minted}



回忆下，这里 \hyperlink{16989482368752175706}{\texttt{getindex(r,1,1)}} \hyperlink{16717190941363337071}{相当于} \texttt{r[1,1]}，因此，上面的调用相当于获取 \texttt{r} 的第一个元素。



为方便起见，可以将符号 \texttt{:any} 传递给 \hyperlink{11231712027010946923}{\texttt{@spawnat}}，它会为你选择执行操作的位置：




\begin{minted}{jlcon}
julia> r = @spawnat :any rand(2,2)
Future(2, 1, 4, nothing)

julia> s = @spawnat :any 1 .+ fetch(r)
Future(3, 1, 5, nothing)

julia> fetch(s)
2×2 Array{Float64,2}:
 1.38854  1.9098
 1.20939  1.57158
\end{minted}



请注意，我们使用了 \texttt{1 .+ fetch(r)} 而不是 \texttt{1 .+ r}。 这是因为我们不知道代码将在哪里运行，因此通常可能需要一个 \hyperlink{11007884648860062495}{\texttt{fetch}} 将 \texttt{r} 移动到执行添加的进程。 在这种情况下，\hyperlink{11231712027010946923}{\texttt{@spawnat}} 足够聪明，可以在拥有 \texttt{r} 的进程上执行计算，因此 \hyperlink{11007884648860062495}{\texttt{fetch}} 将是一个空操作（没有工作被完成）。



（值得注意的是， \hyperlink{11231712027010946923}{\texttt{@spawnat}} 不是内置的，而是在 Julia 中定义的 [宏](@ref man-macros）。你也可以自己定义此类构造。）



需要记住的重要一点是，一旦 fetch，\hyperlink{4170271048165085864}{\texttt{Future}} 将在本地缓存其值。 进一步的 \hyperlink{11007884648860062495}{\texttt{fetch}} 调用不需要网络跃点。 一旦所有引用 \hyperlink{4170271048165085864}{\texttt{Future}} 都已获取，远程存储的值将被删除。



\hyperlink{10770947021537241619}{\texttt{@async}} 类似于 \hyperlink{11231712027010946923}{\texttt{@spawnat}}，但只在本地进程上运行任务。我们使用它为每个进程创建一个“feeder”任务。每个任务选择需要计算的下一个索引，然后等待其进程完成，然后重复直到我们用完索引。请注意，feeder任务直到主任务到达 \hyperlink{7188613740509403855}{\texttt{@sync}} 块的末尾才开始执行，此时它放弃控制并等待所有本地任务完成，然后从主任务返回功能。对于 v0.7 及更高版本，feeder 任务能够通过 \texttt{nextidx} 共享状态，因为它们都运行在同一个进程上。即使\texttt{Tasks} 是协作调度的，在某些上下文中可能仍然需要锁定，例如在 \hyperlink{13392280388075867710}{asynchronous I/O} 中。这意味着上下文切换只发生在明确定义的点：在这种情况下，当 \hyperlink{17262349333771600150}{\texttt{remotecall\_fetch}} 被调用时。这是当前的实现状态，它可能会在未来的 Julia 版本中发生变化，因为它旨在使在 M个 \texttt{Process} 上运行最多 N 个 \texttt{Tasks} 成为可能，也就是 \href{https://en.wikipedia.org/wiki/Thread\_(computing)\#Models}{M:N Threading}。然后，需要为 \texttt{nextidx} 提供锁获取/释放模型，因为让多个进程同时读写一个资源是不安全的。



\hypertarget{8031006575124915656}{}


\section{访问代码以及加载库}



对于想要并行执行的代码，需要所有对所有进程都可见。例如，在 Julia 命令行中输入以下命令：




\begin{minted}{jlcon}
julia> function rand2(dims...)
           return 2*rand(dims...)
       end

julia> rand2(2,2)
2×2 Array{Float64,2}:
 0.153756  0.368514
 1.15119   0.918912

julia> fetch(@spawnat :any rand2(2,2))
ERROR: RemoteException(2, CapturedException(UndefVarError(Symbol("#rand2"))
Stacktrace:
[...]
\end{minted}



进程1知道函数 \texttt{rand2} 的存在，但进程2并不知道。



大多数情况下，你会从文件或者库中加载代码，在此过程中你可以灵活地控制哪个进程加载哪部分代码。假设有这样一个文件，\texttt{DummyModule.jl}，其代码如下：




\begin{minted}{julia}
module DummyModule

export MyType, f

mutable struct MyType
    a::Int
end

f(x) = x^2+1

println("loaded")

end
\end{minted}



为了在所有进程中引用 \texttt{MyType}，\texttt{DummyModule.jl} 需要在每个进程中载入。单独执行 \texttt{include({\textquotedbl}DummyModule.jl{\textquotedbl})} 只会在一个进程中将其载入。为了让每个进程都载入它，可以用 \hyperlink{4972064255482407966}{\texttt{@everywhere}} 宏来实现(启动 Julia 的时候，执行 \texttt{julia -p 2})。




\begin{minted}{jlcon}
julia> @everywhere include("DummyModule.jl")
loaded
      From worker 3:    loaded
      From worker 2:    loaded
\end{minted}



像往常一样，这不会将 \texttt{DummyModule} 引入任何进程的作用域，这需要 \hyperlink{169458112978175560}{\texttt{using}} 或 \hyperlink{16252475688663093021}{\texttt{import}}。 此外，当 \texttt{DummyModule} 被带入一个进程的作用域时，它不在任何其他进程中：




\begin{minted}{jlcon}
julia> using .DummyModule

julia> MyType(7)
MyType(7)

julia> fetch(@spawnat 2 MyType(7))
ERROR: On worker 2:
UndefVarError: MyType not defined
⋮

julia> fetch(@spawnat 2 DummyModule.MyType(7))
MyType(7)
\end{minted}



不过，我们仍然可以在已经包含(include)过 \texttt{DummyModule} 的进程中，发送 \texttt{MyType} 类型的实例，尽管此时该进程的命名空间中并没有 \texttt{MyType} 变量:




\begin{minted}{jlcon}
julia> put!(RemoteChannel(2), MyType(7))
RemoteChannel{Channel{Any}}(2, 1, 13)
\end{minted}



文件代码还可以在启动的时候，通过 \texttt{-L} 参数指定，从而提前在多个进程中载入，然后通过一个 driver.jl 文件控制执行逻辑:




\begin{lstlisting}
julia -p <n> -L file1.jl -L file2.jl driver.jl
\end{lstlisting}



上面执行 \texttt{driver.jl} 的进程 id 为1，就跟提供交互式命令行的 Julia 进程一样。



最后，如果\texttt{DummyModule.jl}不是一个独立的文件，而是一个包，那么\texttt{using DummyModule}将在所有进程上\emph{加载} \texttt{DummyModule.jl}，但只在调用[\texttt{using}]（@ref）的进程上将其纳入作用域。



\hypertarget{5057018227750534701}{}


\section{启动和管理 worker 进程}



Julia 自带两种集群管理模式：



\begin{itemize}
\item 本地集群，前面通过启动时指定 \texttt{-p} 参数就是这种模式


\item 跨机器的集群，通过 \texttt{--machine-file} 指定。这种模式采用没有密码的 \texttt{ssh} 登陆并对应的机器上（与 host 相同的路径下）启动 Julia 的 worker 进程。每个机器定义都采用 \texttt{[count*][user@]host[:port] [bind\_addr[:port]]} 的形式。 \texttt{user} 默认为当前用户，\texttt{port} 为标准 ssh 端口。\texttt{count} 是在节点上生成的 worker 数量，默认为 1。可选的 \texttt{bind-to bind\_addr[:port]} 指定其他 worker 应该用来连接到这个 worker 的 IP 地址和端口。

\end{itemize}


\hyperlink{2657399037748470653}{\texttt{addprocs}}, \hyperlink{16165500032398890398}{\texttt{rmprocs}}, \hyperlink{7474509137601932173}{\texttt{workers}} 这些函数可以分别用来对集群中的进程进行增加，删除和修改。




\begin{minted}{jlcon}
julia> using Distributed

julia> addprocs(2)
2-element Array{Int64,1}:
 2
 3
\end{minted}



模块 \hyperlink{11988382873486720115}{\texttt{Distributed}} 必须在调用 \hyperlink{2657399037748470653}{\texttt{addprocs}} 之前显式加载到主进程上。 它在工作进程上自动可用。



请注意，worker 不会运行 \texttt{{\textasciitilde}/.julia/config/startup.jl} 启动脚本，也不会将其全局状态（例如全局变量、新方法定义和加载的模块）与任何其他正在运行的进程同步 。你可以使用 \texttt{addprocs(exeflags={\textquotedbl}--project{\textquotedbl})} 来初始化具有特定环境的 worker，然后使用 \texttt{@everywhere using <modulename>} 或 \texttt{@everywhere include({\textquotedbl}file.jl{\textquotedbl})}。



其它类型的集群可以通过自己写一个 \texttt{ClusterManager} 来实现，下面 \hyperlink{8944798907386301797}{集群管理器} 部分会介绍。



\hypertarget{1534769292279176592}{}


\section{数据转移}



分布式程序的性能瓶颈主要是由发送消息和数据转移造成的，减少发送消息和转移数据的数量对于获取高性能和可扩展性至关重要，因此，深入了解 Julia 分布式程序是如何转移数据的非常有必要。



\hyperlink{11007884648860062495}{\texttt{fetch}} 可以被认为是一个显式的数据转移操作，因为它直接要求将一个对象移动到本地机器。 \hyperlink{11231712027010946923}{\texttt{@spawnat}}（以及一些相关的结构体）也移动数据，但这并不明显，因此可以称为隐式数据转移操作。 考虑这两种构造和平方一个随机矩阵的方法：



方法一：




\begin{minted}{jlcon}
julia> A = rand(1000,1000);

julia> Bref = @spawnat :any A^2;

[...]

julia> fetch(Bref);
\end{minted}



方法二：




\begin{minted}{jlcon}
julia> Bref = @spawnat :any rand(1000,1000)^2;

[...]

julia> fetch(Bref);
\end{minted}



这种差异看起来微不足道，但实际上由于 \hyperlink{11231712027010946923}{\texttt{@spawnat}} 的行为而非常显着。 在第一种方法中，在本地构造一个随机矩阵，然后将其发送到另一个进程进行平方。 在第二种方法中，随机矩阵在另一个进程中被构造和平方。 因此，第二种方法发送的数据比第一种方法少得多。



在这个简单示例中，这两种方法很容易区分和选择。 然而，在一个真正的程序设计数据转移可能需要更多的思考和一些测量。 例如，如果第一个进程需要矩阵\texttt{A}，那么第一种方法可能更好。 或者，如果计算 \texttt{A} 很昂贵并且只有当前进程拥有它，那么将它移到另一个进程可能是不可避免的。 或者，如果当前进程在 \hyperlink{11231712027010946923}{\texttt{@spawnat}} 和 \texttt{fetch(Bref)} 之间几乎没有什么关系，最好完全消除并行性。 或者想象一下 \texttt{rand(1000,1000)} 被更昂贵的操作取代。 那么为这一步添加另一个 \hyperlink{11231712027010946923}{\texttt{@spawnat}} 语句可能是有意义的。



\hypertarget{17299710876257759093}{}


\section{全局变量}



通过 \hyperlink{11231712027010946923}{\texttt{@spawnat}} 远程执行的表达式，或使用 \hyperlink{5405028821457292937}{\texttt{remotecall}} 为远程执行指定的闭包可能会引用全局变量。 与其他模块中的全局绑定相比，模块 \texttt{Main} 下的全局绑定的处理方式略有不同。 考虑以下代码片段：




\begin{minted}{jlcon}
A = rand(10,10)
remotecall_fetch(()->sum(A), 2)
\end{minted}



在这种情况下，\hyperlink{8666686648688281595}{\texttt{sum}} 必须在远程进程中定义。请注意，\texttt{A} 是在本地工作区中定义的全局变量。 worker 2 在 \texttt{Main} 下没有名为 \texttt{A} 的变量。 将闭包 \texttt{()->sum(A)} 传送到 worker 2 的行为导致 \texttt{Main.A} 被定义在 2 上。即使在调用 \hyperlink{17262349333771600150}{\texttt{remotecall\_fetch}} 返回之后， \texttt{Main.A} 仍然存在于 worker 2 上。带有嵌入式全局引用的远程调用（仅在\texttt{Main} 模块下）以如下的方式管理全局变量：



\begin{itemize}
\item 在全局调用中引用的全局绑定会在将要执行该调用的 worker 中被创建。


\item 全局常量仍然在远端结点定义为常量。


\item 全局绑定会在下一次远程调用中引用到的时候，当其值发生改变时，再次发送给目标 worker。此外，集群并不会所有结点的全局绑定。例如：


\begin{minted}{julia}
A = rand(10,10)
remotecall_fetch(()->sum(A), 2) # worker 2
A = rand(10,10)
remotecall_fetch(()->sum(A), 3) # worker 3
A = nothing
\end{minted}

可以看到，\texttt{A} 作为全局变量在 worker 2中有定义，而 \texttt{B} 是一个局部变量，因而最后在 worker 2 中并没有 \texttt{B} 的绑定。 执行以上代码之后，worker 2 和 worker 3中的 \texttt{Main.A} 的值是不同的，同时，节点1上的值则为 \texttt{nothing}。

\end{itemize}


也许你也注意到了，在 master 主节点上被赋值为 \texttt{nothing} 之后，全局变量的内存会被回收，但在 worker 节点上的全局变量并没有被回收掉。执行 \href{@ref}{\texttt{clear}} 可以手动将远端结点上的特定全局变量置为 \texttt{nothing}，然后对应的内存会被周期性的垃圾回收机制回收。



因此，在远程调用中，需要非常小心地引用全局变量。事实上，应当尽量避免引用全局变量，如果必须引用，那么可以考虑用\texttt{let}代码块将全局变量局部化：




\begin{minted}{jlcon}
julia> A = rand(10,10);

julia> remotecall_fetch(()->A, 2);

julia> B = rand(10,10);

julia> let B = B
           remotecall_fetch(()->B, 2)
       end;

julia> @fetchfrom 2 InteractiveUtils.varinfo()
name           size summary
––––––––– ––––––––– ––––––––––––––––––––––
A         800 bytes 10×10 Array{Float64,2}
Base                Module
Core                Module
Main                Module
\end{minted}



可以看到，\texttt{A} 作为全局变量在 worker 2中有定义，而 \texttt{B} 是一个局部变量，因而最后在 worker 2 中并没有 \texttt{B} 的绑定。



\hypertarget{3256700896084516736}{}


\section{并行的Map和Loop}



幸运的是，许多有用的并行计算不需要数据转移。 一个常见的例子是蒙特卡罗模拟，其中多个进程可以同时处理独立的模拟试验。 我们可以使用 \hyperlink{11231712027010946923}{\texttt{@spawnat}} 在两个进程上抛硬币。 首先，在 \texttt{count\_heads.jl} 中编写以下函数：




\begin{minted}{julia}
function count_heads(n)
    c::Int = 0
    for i = 1:n
        c += rand(Bool)
    end
    c
end
\end{minted}



函数 \texttt{count\_heads} 只是简单地将 \texttt{n} 个随机 0-1 值累加，下面在两个机器上进行试验，并将结果叠加：




\begin{minted}{jlcon}
julia> @everywhere include_string(Main, $(read("count_heads.jl", String)), "count_heads.jl")

julia> a = @spawnat :any count_heads(100000000)
Future(2, 1, 6, nothing)

julia> b = @spawnat :any count_heads(100000000)
Future(3, 1, 7, nothing)

julia> fetch(a)+fetch(b)
100001564
\end{minted}



上面的例子展示了一种非常常见而且有用的并行编程模式，在一些进程中执行多次独立的迭代，然后将它们的结果通过某个函数合并到一起，这个合并操作通常称作\textbf{聚合}(\emph{reduction})，也就是一般意义上的\textbf{张量降维}(tensor-rank-reducing)，比如将一个向量降维成一个数，或者是将一个 tensor 降维到某一行或者某一列等。在代码中，通常具有 \texttt{x = f(x, v[i])} 这种形式，其中 \texttt{x} 是一个叠加器，\texttt{f} 是一个聚合函数，而 \texttt{v[i]} 则是将要被聚合的值。一般来说，\texttt{f} 要求满足结合律，这样不管执行的顺序如何，都不会影响计算结果。



请注意，我们可以将这种\texttt{count\_heads} 模式推广。 我们使用了两个显式的 \hyperlink{11231712027010946923}{\texttt{@spawnat}} 语句，将并行性限制为两个进程。 要在任意数量的进程上运行，我们可以使用 \emph{并行for循环}，在分布式内存中运行，可以在 Julia 中使用 \hyperlink{4581929266257108937}{\texttt{@distributed}} 编写，如下所示：




\begin{minted}{julia}
nheads = @distributed (+) for i = 1:200000000
    Int(rand(Bool))
end
\end{minted}



上面的写法将多次迭代分配到了不同的进程，然后通过一个聚合函数（这里是 \texttt{(+)}）合并计算结果，其中，每次迭代的结果作为 \texttt{for} 循环中的表达式的结果，最后整个循环的结果聚合后得到最终的结果。



注意，尽管这里 for 循环看起来跟串行的 for 循环差不多，实际表现完全不同。这里的迭代并没有特定的执行顺序，而且由于所有的迭代都在不同的进程中进行，其中变量的写入对全局来说不可见。所有并行的 for 循环中的变量都会复制并广播到每个进程。



比如，下面这段代码并不会像你想要的那样执行：




\begin{minted}{julia}
a = zeros(100000)
@distributed for i = 1:100000
    a[i] = i
end
\end{minted}



这段代码并不会把 \texttt{a} 的所有元素初始化，因为每个进程都会有一份 \texttt{a} 的拷贝，因此类似的 for 循环一定要避免。幸运的是，\hyperlink{879185136139543918}{共享数组} 可以用来突破这种限制：




\begin{minted}{julia}
using SharedArrays

a = SharedArray{Float64}(10)
@distributed for i = 1:10
    a[i] = i
end
\end{minted}



当然，对于 for 循环外面的变量来说，如果是只读的话，使用起来完全没问题：




\begin{minted}{julia}
a = randn(1000)
@distributed (+) for i = 1:100000
    f(a[rand(1:end)])
end
\end{minted}



这里每次迭代都会从共享给每个进程的向量 \texttt{a} 中随机选一个样本，然后用来计算 \texttt{f}。



如你所见，如果不需要，可以省略归约运算符。 在这种情况下，循环异步执行，即它在所有可用的 worker 上产生独立的任务，并立即返回一个 \hyperlink{4170271048165085864}{\texttt{Future}} 数组，而无需等待完成。 调用者可以稍后通过调用 \hyperlink{11007884648860062495}{\texttt{fetch}} 来等待 \hyperlink{4170271048165085864}{\texttt{Future}} 完成，或者通过添加前缀 \hyperlink{7188613740509403855}{\texttt{@sync}}，比如 \texttt{@sync @distributed for}，来等待循环结束。



在一些不需要聚合函数的情况下，我们可能只是像对某个范围内的整数应用一个函数(或者，更一般地，某个序列中的所有元素)，这种操作称作\textbf{并行的 map}，在 Julia 中有一个对应的函数 \hyperlink{9432281416771383761}{\texttt{pmap}}。例如，可以像下面这样计算一些随机大矩阵的奇异值：




\begin{minted}{jlcon}
julia> M = Matrix{Float64}[rand(1000,1000) for i = 1:10];

julia> pmap(svdvals, M);
\end{minted}



Julia 中的 \hyperlink{9432281416771383761}{\texttt{pmap}} 是被设计用来处理一些计算量比较复杂的函数的并行化的。与之对比的是，\texttt{@distributed for} 是用来处理一些每次迭代计算都很轻量的计算，比如简单地对两个数求和。\hyperlink{9432281416771383761}{\texttt{pmap}} 和 \texttt{@distributed for} 都只会用到 worker 的进程。对于 \texttt{@distributed for} 而言，最后的聚合计算由发起者的进程完成。



\hypertarget{14860671192412743510}{}


\section{远程引用和 AbstractChannel}



远程引用通常指某种 \texttt{AbstractChannel} 的实现。



\texttt{AbstractChannel}（如\texttt{Channel}）的具体实现，需要实现 \hyperlink{10812715779190652189}{\texttt{put!}}, \hyperlink{4963355246106153560}{\texttt{take!}}, \hyperlink{11007884648860062495}{\texttt{fetch}} , \hyperlink{15888554370655089980}{\texttt{isready}} 和 \hyperlink{13761789780433862250}{\texttt{wait}}。 \hyperlink{4170271048165085864}{\texttt{Future}} 所引用的远程对象存储在\texttt{Channel\{Any\}(1)} 中，即大小为 1 的、能够容纳 \texttt{Any} 类型对象的 \texttt{Channel} 。



\hyperlink{16773267780467157552}{\texttt{RemoteChannel}} 可以被反复写入，可以指向任意大小和类型的 channel（或者是任意 \texttt{AbstractChannel} 的实现）。



\texttt{RemoteChannel(f::Function, pid)()} 构造器可以构造一些引用，而这些引用指向的 channel 可以容纳多个某种具体类型的数据。其中 \texttt{f} 是将要在 \texttt{pid} 上执行的函数，其返回值必须是 \texttt{AbstractChannel} 类型。



例如，\texttt{RemoteChannel(()->Channel\{Int\}(10), pid)} 会创建一个 channel，其类型是 \texttt{Int}，容量是 10，这个 channel 存在于 \texttt{pid} 进程中。



针对 \hyperlink{16773267780467157552}{\texttt{RemoteChannel}} 的 \hyperlink{10812715779190652189}{\texttt{put!}}, \hyperlink{4963355246106153560}{\texttt{take!}}, \hyperlink{11007884648860062495}{\texttt{fetch}}, \hyperlink{15888554370655089980}{\texttt{isready}} 和 \hyperlink{13761789780433862250}{\texttt{wait}} 方法会被重定向到其底层存储着 channel 的进程。



因此，\hyperlink{16773267780467157552}{\texttt{RemoteChannel}} 可以用来引用用户自定义的 \texttt{AbstractChannel} 对象。在 \href{https://github.com/JuliaAttic/Examples}{Examples repository} 中的 \texttt{dictchannel.jl} 文件中有一个简单的例子，其中使用了一个字典用于远端存储。



\hypertarget{1217793571907460984}{}


\section{Channel 和 RemoteChannel}



\begin{itemize}
\item 一个 \hyperlink{12548845729684045604}{\texttt{Channel}} 仅对局部的进程可见，worker 2 无法直接访问 worker 3 上的 \texttt{Channel}，反之亦如此。不过 \hyperlink{16773267780467157552}{\texttt{RemoteChannel}} 可以跨 worker 获取和写入数据。


\item \hyperlink{16773267780467157552}{\texttt{RemoteChannel}} 可以看作是对 \texttt{Channel} 的封装。


\item \hyperlink{16773267780467157552}{\texttt{RemoteChannel}} 的 \texttt{pid} 就是其封装的 channel 所在的进程 id。


\item 任意拥有 \hyperlink{16773267780467157552}{\texttt{RemoteChannel}} 引用的进程都可以对其进行读写，数据会自动发送到 \hyperlink{16773267780467157552}{\texttt{RemoteChannel}} 底层 channel 的进程（或从中获取数据）


\item 序列化 \texttt{Channel} 会将其中的所有数据也都序列化，因此反序列化的时候也就可以得到一个原始数据的拷贝。


\item 不过，对 \hyperlink{16773267780467157552}{\texttt{RemoteChannel}} 的序列化则只会序列化其底层指向的 channel 的 id，因此反序列化之后得到的对象仍然会指向之前存储的对象。

\end{itemize}


如上的通道示例可以修改为进程间通信，如下所示



首先，起 4 个 worker 进程处理同一个 remote channel \texttt{jobs}，其中的每个 job 都有一个对应的 \texttt{job\_id}，然后每个 task 读取一个 \texttt{job\_id}，然后模拟随机等待一段时间，然后往存储结果的 \texttt{RemoteChannel} 中写入一个 Tuple 对象，其中包含 \texttt{job\_id} 和等待的时间。最后将结果打印出来。




\begin{minted}{jlcon}
julia> addprocs(4); # add worker processes

julia> const jobs = RemoteChannel(()->Channel{Int}(32));

julia> const results = RemoteChannel(()->Channel{Tuple}(32));

julia> @everywhere function do_work(jobs, results) # define work function everywhere
           while true
               job_id = take!(jobs)
               exec_time = rand()
               sleep(exec_time) # simulates elapsed time doing actual work
               put!(results, (job_id, exec_time, myid()))
           end
       end

julia> function make_jobs(n)
           for i in 1:n
               put!(jobs, i)
           end
       end;

julia> n = 12;

julia> errormonitor(@async make_jobs(n)); # feed the jobs channel with "n" jobs

julia> for p in workers() # start tasks on the workers to process requests in parallel
           remote_do(do_work, p, jobs, results)
       end

julia> @elapsed while n > 0 # print out results
           job_id, exec_time, where = take!(results)
           println("$job_id finished in $(round(exec_time; digits=2)) seconds on worker $where")
           global n = n - 1
       end
1 finished in 0.18 seconds on worker 4
2 finished in 0.26 seconds on worker 5
6 finished in 0.12 seconds on worker 4
7 finished in 0.18 seconds on worker 4
5 finished in 0.35 seconds on worker 5
4 finished in 0.68 seconds on worker 2
3 finished in 0.73 seconds on worker 3
11 finished in 0.01 seconds on worker 3
12 finished in 0.02 seconds on worker 3
9 finished in 0.26 seconds on worker 5
8 finished in 0.57 seconds on worker 4
10 finished in 0.58 seconds on worker 2
0.055971741
\end{minted}



\hypertarget{46384012603971123}{}


\subsection{远程调用和分布式垃圾回收}



远程引用所指向的对象可以在其所有引用都被集群删除之后被释放掉。



存储值的节点会跟踪哪些 worker 引用了它。 每次将 \hyperlink{16773267780467157552}{\texttt{RemoteChannel}} 或（未获取的）\hyperlink{4170271048165085864}{\texttt{Future}} 序列化为 worker 时，都会通知引用指向的节点。 并且每次在本地对 \hyperlink{16773267780467157552}{\texttt{RemoteChannel}} 或（未获取的）\hyperlink{4170271048165085864}{\texttt{Future}} 进行垃圾回收时，都会再次通知拥有该值的节点。 这是在内部集群感知序列化程序中实现的。 远程引用仅在正在运行的集群的上下文中有效。 不支持对常规\texttt{IO}对象的引用进行序列化和反序列化。



上面说到的\textbf{通知}都是通过发送{\textquotedbl}跟踪{\textquotedbl}信息来实现的，当一个引用被序列化的时候，就会发送{\textquotedbl}添加引用{\textquotedbl}的信息，而一个引用被本地的垃圾回收器回收的时候，就会发送一个{\textquotedbl}删除引用{\textquotedbl}的信息。



由于 \hyperlink{4170271048165085864}{\texttt{Future}} 是一次性写入并在本地缓存，因此 \hyperlink{11007884648860062495}{\texttt{fetch}}ing 一个 \hyperlink{4170271048165085864}{\texttt{Future}} 的行为也会更新拥有该值的节点上的引用跟踪信息。



一旦指向某个值的引用都被删除了，对应的节点会将其释放。



使用 [\texttt{Future}]（@ref Distributed.Future），将已获取的[\texttt{Future}]（@ref Distributed.Future）序列化到其他节点也会发送该值，因为此时原始远程存储可能已收集该值了。



此外需要注意的是，本地的垃圾回收到底发生在什么时候取决于具体对象的大小以及当时系统的内存压力。



在远程引用的情况下，本地引用对象的大小非常小，而存储在远程节点上的值可能非常大。 由于可能不会立即收集本地对象，因此在 \hyperlink{16773267780467157552}{\texttt{RemoteChannel}} 的本地实例或未获取的 \hyperlink{4170271048165085864}{\texttt{Future}} 上显式调用 \hyperlink{6584919147438336166}{\texttt{finalize}} 是一个好习惯 。 由于在 \hyperlink{4170271048165085864}{\texttt{Future}} 上调用 \hyperlink{11007884648860062495}{\texttt{fetch}} 也会从远程存储中删除其引用，因此在获取的 \hyperlink{4170271048165085864}{\texttt{Future}} 上不需要这样做。 显式调用 \hyperlink{6584919147438336166}{\texttt{finalize}} 会导致立即向远程节点发送消息以继续并删除其对该值的引用。



一旦执行了 finalize 之后，引用就不可用了。



\hypertarget{13178697960111882092}{}


\section{本地调用}



数据必须复制到远程节点以供执行。 远程调用和数据存储到不同节点上的 \hyperlink{16773267780467157552}{\texttt{RemoteChannel}} / \hyperlink{4170271048165085864}{\texttt{Future}} 时都是这种情况。 正如预期的那样，这会在远程节点上生成序列化对象的副本。 但是，当目的节点是本地节点时，即调用进程id与远程节点id相同，则作为本地调用执行。 它通常（并非总是）在不同的 Task 中执行 - 但没有数据的序列化/反序列化。 因此，该调用引用了与传递相同的对象实例 - 没有创建副本。 这种行为在下面突出显示：




\begin{minted}{jlcon}
julia> using Distributed;

julia> rc = RemoteChannel(()->Channel(3));   # RemoteChannel created on local node

julia> v = [0];

julia> for i in 1:3
           v[1] = i                          # Reusing `v`
           put!(rc, v)
       end;

julia> result = [take!(rc) for _ in 1:3];

julia> println(result);
Array{Int64,1}[[3], [3], [3]]

julia> println("Num Unique objects : ", length(unique(map(objectid, result))));
Num Unique objects : 1

julia> addprocs(1);

julia> rc = RemoteChannel(()->Channel(3), workers()[1]);   # RemoteChannel created on remote node

julia> v = [0];

julia> for i in 1:3
           v[1] = i
           put!(rc, v)
       end;

julia> result = [take!(rc) for _ in 1:3];

julia> println(result);
Array{Int64,1}[[1], [2], [3]]

julia> println("Num Unique objects : ", length(unique(map(objectid, result))));
Num Unique objects : 3
\end{minted}



可以看出，本地拥有的 \hyperlink{16773267780467157552}{\texttt{RemoteChannel}} 上的 \hyperlink{10812715779190652189}{\texttt{put!}} 在调用之间修改了相同的对象 \texttt{v} 会导致存储相同的单个对象实例。 与当拥有 \texttt{rc} 的节点是不同节点时创建的 \texttt{v} 副本相反。



需要注意的是，这通常不是问题。 只有当对象既存储在本地又在调用后被修改时，才需要考虑这一点。 在这种情况下，存储对象的 \texttt{deepcopy} 可能是合适的。



对于本地节点上的远程调用也是如此，如下例所示：




\begin{minted}{jlcon}
julia> using Distributed; addprocs(1);

julia> v = [0];

julia> v2 = remotecall_fetch(x->(x[1] = 1; x), myid(), v);     # Executed on local node

julia> println("v=$v, v2=$v2, ", v === v2);
v=[1], v2=[1], true

julia> v = [0];

julia> v2 = remotecall_fetch(x->(x[1] = 1; x), workers()[1], v); # Executed on remote node

julia> println("v=$v, v2=$v2, ", v === v2);
v=[0], v2=[1], false
\end{minted}



再次可以看出，对本地节点的远程调用就像直接调用一样。调用修改作为参数传递的本地对象。 在远程调用中，它对参数的副本进行操作。



重复一遍，一般来说这不是问题。 如果本地节点也被用作计算节点，并且在调用后使用的参数，则需要考虑此行为，并且如果需要，必须将参数的深拷贝传递给在本地节点上唤起的调用。 对远程节点的调用将始终对参数的副本进行操作。



\hypertarget{16489506716059563786}{}


\section{共享数组}



共享数组使用系统共享内存将数组映射到多个进程上，尽管和 \href{https://github.com/JuliaParallel/DistributedArrays.jl}{\texttt{DArray}} 有点像，但其实际表现有很大不同。在 \href{https://github.com/JuliaParallel/DistributedArrays.jl}{\texttt{DArray}} 中，每个进程可以访问数据中的一块，但任意两个进程都不能共享同一块数据，而对于 \hyperlink{15069300442338861576}{\texttt{SharedArray}}，每个进程都可以访问整个数组。如果你想在一台机器上，让一大块数据能够被多个进程访问到，那么 \hyperlink{15069300442338861576}{\texttt{SharedArray}} 是个不错的选择。



共享数组由 \texttt{SharedArray} 提供，必须在所有相关的 worker 中都显式地加载。



对 \hyperlink{15069300442338861576}{\texttt{SharedArray}} 索引（访问和复制）操作就跟普通的数组一样，由于底层的内存对本地的进程是可见的，索引的效率很高，因此大多数单进程上的算法对 \hyperlink{15069300442338861576}{\texttt{SharedArray}} 来说都是适用的，除非某些算法必须使用 \hyperlink{15492651498431872487}{\texttt{Array}} 类型（此时可以通过调用 \hyperlink{5828642841105091437}{\texttt{sdata}} 来获取 \hyperlink{15069300442338861576}{\texttt{SharedArray}} 数组）。对于其它类型的 \texttt{AbstractArray} 类型数组来说，\hyperlink{5828642841105091437}{\texttt{sdata}} 仅仅会返回数组本身，因此，可以放心地使用 \hyperlink{5828642841105091437}{\texttt{sdata}} 对任意类型的 \texttt{Array} 进行操作。



共享数组可以通过以下形式构造：




\begin{minted}{julia}
SharedArray{T,N}(dims::NTuple; init=false, pids=Int[])
\end{minted}



它在由 \texttt{pids} 指定的进程中创建了一个位类型为 \texttt{T} 和形状为 \texttt{dims} 的 \texttt{N} 维共享数组。 与分布式数组不同，共享数组只能从由\texttt{pids} 命名参数指定的那些参与 worker 访问（如果创建过程在同一主机上，也是如此）。 请注意，SharedArray 中仅支持 \hyperlink{12980593021531333073}{\texttt{isbits}} 元素。



如果提供了一个类型为 \texttt{initfn(S::SharedArray)} 的 \texttt{init} 函数，那么所有相关的 worker 都会调用它。你可以让每个 worker 都在共享数组不同的地方执行 \texttt{init} 函数，从而实现并行初始化。



下面是个例子：




\begin{minted}{jlcon}
julia> using Distributed

julia> addprocs(3)
3-element Array{Int64,1}:
 2
 3
 4

julia> @everywhere using SharedArrays

julia> S = SharedArray{Int,2}((3,4), init = S -> S[localindices(S)] = repeat([myid()], length(localindices(S))))
3×4 SharedArray{Int64,2}:
 2  2  3  4
 2  3  3  4
 2  3  4  4

julia> S[3,2] = 7
7

julia> S
3×4 SharedArray{Int64,2}:
 2  2  3  4
 2  3  3  4
 2  7  4  4
\end{minted}



\hyperlink{12447667054613272081}{\texttt{SharedArrays.localindices}} 提供了一个以为的切片，可以很方便地用来将 task 分配到各个进程上。当然你可以按你想要的方式做区分：




\begin{minted}{jlcon}
julia> S = SharedArray{Int,2}((3,4), init = S -> S[indexpids(S):length(procs(S)):length(S)] = repeat([myid()], length( indexpids(S):length(procs(S)):length(S))))
3×4 SharedArray{Int64,2}:
 2  2  2  2
 3  3  3  3
 4  4  4  4
\end{minted}



由于所有的进程都能够访问底层的数据，因此一定要小心避免出现冲突：




\begin{minted}{julia}
@sync begin
    for p in procs(S)
        @async begin
            remotecall_wait(fill!, p, S, p)
        end
    end
end
\end{minted}



上面的代码会导致不确定的结果，因为每个进程都将\textbf{整个}数组赋值为其 \texttt{pid}，从而导致最后一个执行完成的进程会保留其 \texttt{pid}。



考虑更复杂的一种情况：




\begin{minted}{julia}
q[i,j,t+1] = q[i,j,t] + u[i,j,t]
\end{minted}



这个例子中，如果首先将任务用按照一维的索引作区分，那么就会出问题：如果 \texttt{q[i,j,t]} 位于分配给某个 worker 的最后一个位置，而 \texttt{q[i,j,t+1]} 位于下一个 worker 的开始位置，那么后面这个 worker 开始计算的时候，可能 \texttt{q[i,j,t]} 还没有准备好，这时候，更好的做法是，手动分区，比如可以定义一个函数，按照 \texttt{(irange,jrange)} 给每个 worker 分配任务。




\begin{minted}{jlcon}
julia> @everywhere function myrange(q::SharedArray)
           idx = indexpids(q)
           if idx == 0 # This worker is not assigned a piece
               return 1:0, 1:0
           end
           nchunks = length(procs(q))
           splits = [round(Int, s) for s in range(0, stop=size(q,2), length=nchunks+1)]
           1:size(q,1), splits[idx]+1:splits[idx+1]
       end
\end{minted}



然后定义计算内核：




\begin{minted}{jlcon}
julia> @everywhere function advection_chunk!(q, u, irange, jrange, trange)
           @show (irange, jrange, trange)  # display so we can see what's happening
           for t in trange, j in jrange, i in irange
               q[i,j,t+1] = q[i,j,t] + u[i,j,t]
           end
           q
       end
\end{minted}



然后定义一个 wrapper：




\begin{minted}{jlcon}
julia> @everywhere advection_shared_chunk!(q, u) =
           advection_chunk!(q, u, myrange(q)..., 1:size(q,3)-1)
\end{minted}



接下来，比较三个不同的版本，第一个是单进程版本：




\begin{minted}{jlcon}
julia> advection_serial!(q, u) = advection_chunk!(q, u, 1:size(q,1), 1:size(q,2), 1:size(q,3)-1);
\end{minted}



然后是使用 \hyperlink{4581929266257108937}{\texttt{@distributed}}:




\begin{minted}{jlcon}
julia> function advection_parallel!(q, u)
           for t = 1:size(q,3)-1
               @sync @distributed for j = 1:size(q,2)
                   for i = 1:size(q,1)
                       q[i,j,t+1]= q[i,j,t] + u[i,j,t]
                   end
               end
           end
           q
       end;
\end{minted}



最后是使用分区：




\begin{minted}{jlcon}
julia> function advection_shared!(q, u)
           @sync begin
               for p in procs(q)
                   @async remotecall_wait(advection_shared_chunk!, p, q, u)
               end
           end
           q
       end;
\end{minted}



如果创建好了 \texttt{SharedArray} 之后，计算这些函数的执行时间，那么可以得到以下结果（用 \texttt{julia -p 4} 启动）：




\begin{minted}{jlcon}
julia> q = SharedArray{Float64,3}((500,500,500));

julia> u = SharedArray{Float64,3}((500,500,500));
\end{minted}



先执行一次以便 JIT 编译，然后用 \hyperlink{8029752041511656628}{\texttt{@time}} 宏测试其第二次执行的时间：




\begin{minted}{jlcon}
julia> @time advection_serial!(q, u);
(irange,jrange,trange) = (1:500,1:500,1:499)
 830.220 milliseconds (216 allocations: 13820 bytes)

julia> @time advection_parallel!(q, u);
   2.495 seconds      (3999 k allocations: 289 MB, 2.09% gc time)

julia> @time advection_shared!(q,u);
        From worker 2:       (irange,jrange,trange) = (1:500,1:125,1:499)
        From worker 4:       (irange,jrange,trange) = (1:500,251:375,1:499)
        From worker 3:       (irange,jrange,trange) = (1:500,126:250,1:499)
        From worker 5:       (irange,jrange,trange) = (1:500,376:500,1:499)
 238.119 milliseconds (2264 allocations: 169 KB)
\end{minted}



这里 \texttt{advection\_shared!} 最大的优势在于，最小程度地降低了 woker 之间的通信，从而让每个 worker 能针对被分配的部分持续地计算一段时间。



\hypertarget{4244431560597105149}{}


\subsection{共享数组与分布式垃圾回收}



和远程引用一样，共享数组也依赖于创建节点上的垃圾回收来释放所有参与的 worker 上的引用。因此，创建大量生命周期比较短的数组，并尽可能快地显式 finilize 这些对象，代码会更高效，这样与之对用的内存和文件句柄都会更快地释放。



\hypertarget{9723253901891653661}{}


\section{集群管理器}



Julia 通过集群管理器实现对多个进程（所构成的逻辑上的集群）的启动，管理以及网络通信。一个 \texttt{ClusterManager} 负责：



\begin{itemize}
\item 在一个集群环境中启动 worker 进程


\item 管理每个 worker 生命周期内的事件


\item （可选），提供数据传输

\end{itemize}


一个 Julia 集群由以下特点：



\begin{itemize}
\item 初始进程，称为 \texttt{master}，其 \texttt{id} 为 1


\item 只有 master 进程可以增加或删除 worker 进程


\item 所有进程之间都可以直接通信

\end{itemize}


worker 之间的连接（用的是内置的 TCP/IP 传输）按照以下方式进行：



\begin{itemize}
\item master 进程对一个 \texttt{ClusterManager} 对象调用 \hyperlink{2657399037748470653}{\texttt{addprocs}}


\item \hyperlink{2657399037748470653}{\texttt{addprocs}} 调用对应的 \hyperlink{7346188534454273843}{\texttt{launch}} 方法，然后在对应的机器上启动相应数量的 worker 进程


\item 每个 worker 监听一个端口，然后将其 host 和 port 信息传给 \hyperlink{18181294266083891471}{\texttt{stdout}}


\item 集群管理器捕获 \hyperlink{18181294266083891471}{\texttt{stdout}} 中每个 worker 的信息，并提供给 master 进程


\item master 进程解析信息并与相应的 worker 建立 TCP/IP 连接


\item 每个 worker 都会被通知集群中的其它 worker


\item 每个 worker 与 \texttt{id} 小于自己的 worker 连接


\item 这样，一个网络就建立了，从而，每个 worker 都可以与其它 worker 建立连接

\end{itemize}


尽管默认的传输层使用的是 \hyperlink{5453047654537213204}{\texttt{TCPSocket}}，对于一个自定义的集群管理器来说，完全可以使用其它传输方式。



Julia 提供了两种内置的集群管理器：



\begin{itemize}
\item \texttt{LocalManager}，调用 \hyperlink{2657399037748470653}{\texttt{addprocs()}} 或 \hyperlink{2657399037748470653}{\texttt{addprocs(np::Integer)}} 时会用到。


\item \texttt{SSHManager}，调用 \hyperlink{2657399037748470653}{\texttt{addprocs(hostnames::Array)}} 时，传递一个 hostnames 的列表。

\end{itemize}


\texttt{LocalManager} 用来在同一个 host 上启动多个 worker，从而利用多核/多处理器硬件。



因此，一个最小的集群管理器需要：



\begin{itemize}
\item 是一个 \texttt{ClusterManager} 抽象类的一个子类


\item 实现 \hyperlink{7346188534454273843}{\texttt{launch}} 接口，用来启动新的 worker


\item 实现 \hyperlink{8462349151012734144}{\texttt{manage}}，在一个 worker 的生命周期中多次被调用（例如，发送中断信号）

\end{itemize}


\hyperlink{2657399037748470653}{\texttt{addprocs(manager::FooManager)}} 需要 \texttt{FooManager} 实现：




\begin{minted}{julia}
function launch(manager::FooManager, params::Dict, launched::Array, c::Condition)
    [...]
end

function manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)
    [...]
end
\end{minted}



作为一个例子，我们来看下 \texttt{LocalManager} 是怎么实现的：




\begin{minted}{julia}
struct LocalManager <: ClusterManager
    np::Integer
end

function launch(manager::LocalManager, params::Dict, launched::Array, c::Condition)
    [...]
end

function manage(manager::LocalManager, id::Integer, config::WorkerConfig, op::Symbol)
    [...]
end
\end{minted}



\hyperlink{7346188534454273843}{\texttt{launch}} 方法接收以下参数：



\begin{itemize}
\item \texttt{manager::ClusterManager}: 调用 \hyperlink{2657399037748470653}{\texttt{addprocs}} 时所用到的集群管理器


\item \texttt{params::Dict}: 所有的关键字参数都会传递到 \hyperlink{2657399037748470653}{\texttt{addprocs}} 中


\item \texttt{launched::Array}: 用来存储一个或多个 \texttt{WorkerConfig}


\item \texttt{c::Condition}: 在 workers 启动后被通知的条件变量

\end{itemize}


\hyperlink{7346188534454273843}{\texttt{launch}} 会在一个异步的task中调用，该 task 结束之后，意味着所有请求的 worker 都已经启动好了。因此，\hyperlink{7346188534454273843}{\texttt{launch}} 函数\textbf{必须}在所有 worker 启动之后，尽快退出。



新启动的 worker 之间采用的是多对多的连接方式。在命令行中指定参数 \texttt{--worker[=<cookie>]} 会让所有启动的进程把自己当作 worker，然后通过 TCP/IP 构建连接。



集群中所有的 worker 默认使用同一个 master 的 \hyperlink{12947285545876463888}{cookie}。如果 cookie 没有指定，（比如没有通过 \texttt{--worker} 指定），那么 worker 会尝试从它的标准输入中读取。\texttt{LocalManager} 和 \texttt{SSHManager} 都是通过标准输入来将 cookie 传递给新启动的 worker。



默认情况下，一个 worker 会监听从 \hyperlink{11265435361532665287}{\texttt{getipaddr()}} 函数返回的地址上的一个开放端口。若要指定监听的地址，可以通过额外的参数 \texttt{--bind-to bind\_addr[:port]} 指定，这对于多 host 的情况来说很方便。



对于非 TCP/IP 传输，可以选择 MPI 作为一种实现，此时一定\textbf{不要}指定 \texttt{--worker} 参数，另外，新启动的 worker 必须调用 \texttt{init\_worker(cookie)} 之后再使用并行的结构体。



对于每个已经启动的 worker，\hyperlink{7346188534454273843}{\texttt{launch}} 方法必须往 \texttt{launched} 中添加一个 \texttt{WorkerConfig} 对象（相应的值已经初始化）。




\begin{minted}{julia}
mutable struct WorkerConfig
    # Common fields relevant to all cluster managers
    io::Union{IO, Nothing}
    host::Union{AbstractString, Nothing}
    port::Union{Integer, Nothing}

    # Used when launching additional workers at a host
    count::Union{Int, Symbol, Nothing}
    exename::Union{AbstractString, Cmd, Nothing}
    exeflags::Union{Cmd, Nothing}

    # External cluster managers can use this to store information at a per-worker level
    # Can be a dict if multiple fields need to be stored.
    userdata::Any

    # SSHManager / SSH tunnel connections to workers
    tunnel::Union{Bool, Nothing}
    bind_addr::Union{AbstractString, Nothing}
    sshflags::Union{Cmd, Nothing}
    max_parallel::Union{Integer, Nothing}

    # Used by Local/SSH managers
    connect_at::Any

    [...]
end
\end{minted}



\texttt{WorkerConfig} 中的大多数字段都是内置的集群管理器会用到，对于自定义的管理器，通常只需要指定 \texttt{io} 或 \texttt{host}/\texttt{port}:



\begin{itemize}
\item 如果指定了 \texttt{io}，那么就会用来读取 host/port 信息。每个 worker 会在启动时打印地址和端口，这样 worker 就可以自由监听可用的端口，而不必手动配置 worker 的端口。


\item 如果 \texttt{io} 没有指定，那么 \texttt{host} 和 \texttt{port} 就会用来连接。


\item \texttt{count}，\texttt{exename} 和 \texttt{exeflags} 用于从一个 worker 上启动额外的 worker。例如，一个集群管理器可能对每个节点都只启动一个 worker，然后再用它来启动额外的 worker。

\begin{itemize}
\item \texttt{count} 可以是一个整数 \texttt{n}，用来指定启动 \texttt{n} 个 worker


\item \texttt{count} 还可以是 \texttt{:auto}，用来启动跟那台机器上 CPU 个数（逻辑上的核的个数）相同的 worker


\item \texttt{exename} 是 \texttt{julia} 可执行文件的全路径


\item \texttt{exeflags} 应该设置成传递给将要启动的 worker 命令行参数

\end{itemize}

\item \texttt{tunnel}, \texttt{bind\_addr}, \texttt{sshflags} 和 \texttt{max\_parallel} 会在从 worker 与 master 进程建立 ssh 隧道时用到


\item \texttt{userdata} 用来提供给自定义集群管理器存储自己的 worker 相关的信息

\end{itemize}


\texttt{manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)} 会在一个 worker 生命周期中的不同时刻被调用，其中 op 的值可能是：



\begin{itemize}
\item \texttt{:register}/\texttt{:deregister}，从 Julia 的 worker 池子中添加/删除一个 worker


\item \texttt{:interrupt}，当 \texttt{interrupt(workers)} 被调用是，此时，\texttt{ClusterManager} 应该给相应的 worker 发送终端信号


\item \texttt{:finalize}，用于清理操作。

\end{itemize}


\hypertarget{5280019525649403200}{}


\subsection{自定义集群管理器的传输方式}



将默认的 TCP/IP 多对多 socket 连接替换成一个自定义的传输层需要做很多工作。每个 Julia 进程都有与其连接的 worker 数量相同的通信 task。例如，在一个有 32 个进程的多对多集群中：



\begin{itemize}
\item 每个进程都有31个通信task


\item 每个 task 在一个\textbf{消息处理循环}中从一个远端 worker 读取所有的输入信息


\item 每个消息处理循环等待一个 \texttt{IO} 对象（比如，在默认实现中是一个 \hyperlink{5453047654537213204}{\texttt{TCPSocket}}），然后读取整个信息，处理，等待下一个


\item 发送消息则可以直接在任意 Julia task 中完成，而不只是通信 task，同样，也是通过相应的 \texttt{IO} 对象

\end{itemize}


要替换默认的传输方式，需要新的实现能够在远程 worker 之间建立连接，同时提供一个可以用来被消息处理循环等待的 \texttt{IO} 对象。集群管理器的回调函数需要实现如下函数：




\begin{minted}{julia}
connect(manager::FooManager, pid::Integer, config::WorkerConfig)
kill(manager::FooManager, pid::Int, config::WorkerConfig)
\end{minted}



默认的实现（使用的是 TCP/IP socket）是 \texttt{connect(manager::ClusterManager, pid::Integer, config::WorkerConfig)}。



\texttt{connect} 需要返回一对 \texttt{IO} 对象，一个用于从 \texttt{pid} worker 读取数据，另一个用于往 \texttt{pid} 写数据。自定义的集群管理器可以用内存中的 \texttt{BUfferStream} 作为一个管道将自定义的（很可能是非 \texttt{IO} 的）传输与 Julia 内置的并行基础设施衔接起来。



\texttt{BufferStream} 是一个内存中的 \hyperlink{15789326112236459498}{\texttt{IOBuffer}}，其表现很像 \texttt{IO}，就是一个\textbf{流}（stream），可以异步地处理。



在 \href{https://github.com/JuliaAttic/Examples}{Examples repository} 的 \texttt{clustermanager/0mq} 目录中，包含一个使用 ZeroMQ 连接 Julia worker 的例子，用的是星型拓补结构。需要注意的是：Julia 的进程仍然是\textbf{逻辑上}相互连接的，任意 worker 都可以与其它 worker 直接相连而无需感知到 0MQ 作为传输层的存在。



在使用自定义传输的时候：



\begin{itemize}
\item Julia 的 workers 必须\textbf{不能}通过 \texttt{--worker} 启动。如果启动的时候使用了 \texttt{--worker}，那么新启动的 worker 会默认使用基于 TCP/IP socket 的实现


\item 对于每个 worker 逻辑上的输入连接，必须调用 \texttt{Base.process\_messages(rd::IO, wr::IO)()}，这会创建一个新的 task 来处理 worker 消息的读写


\item \texttt{init\_worker(cookie, manager::FooManager)} 必须作为 worker 进程初始化的一部分呢被调用


\item \texttt{WorkerConfig}中的 \texttt{connect\_at::Any} 字段可以被集群管理器在调用 \hyperlink{7346188534454273843}{\texttt{launch}} 的时候设置，该字段的值会发送到所有的 \hyperlink{5152827542417649360}{\texttt{connect}} 回调中。通常，其中包含的是\textbf{如何连接到}一个 worker 的信息。例如，在 TCP/IP socket 传输中，用这个字段存储 \texttt{(host, port)} 来声明如何连接到一个 worker。

\end{itemize}


\texttt{kill(manager, pid, config)} 用来从一个集群中删除一个 worker，在 master 进程中，对应的 \texttt{IO} 对象必须通过对应的实现来关闭，从而保证正确地释放资源。默认的实现简单地对指定的远端 worker 执行 \texttt{exit()} 即可。



在例子目录中，\texttt{clustermanager/simple} 展示了一个简单地实现，使用的是 UNIX 下的 socket。



\hypertarget{6223669855960438168}{}


\subsection{LocalManager 和 SSHManager 的网络要求}



Julia 集群设计的时候，默认是在一个安全的环境中执行，比如本地的笔记本，部门的集群，甚至是云端。这部分将介绍 \texttt{LocalManager} 和 \texttt{SSHManager} 的网络安全要点：



\begin{itemize}
\item master 进程不监听任何端口，它只负责向外连接 worker


\item 每个 worker 都只绑定一个本地的接口，同时监听一个操作系统分配的临时端口。


\item \texttt{addprocs(N)} 使用的 \texttt{LocalManager}，默认只会绑定到回环接口（loopback interface），这就意味着，之后在远程主机上（恶意）启动的 worker 无法连接到集群中，在执行 \texttt{addprocs(4)} 之后，又跟一个 \texttt{addprocs([{\textquotedbl}remote\_host{\textquotedbl}])} 会失败。有些用户可能希望创建一个集群同时管理本地系统和几个远端系统，这可以通过在绑定 \texttt{LocalManager} 到外部网络接口的时候，指定一个 \texttt{restrict} 参数：\texttt{addprocs(4; restrict=false)}


\item \texttt{addprocs(list\_of\_remote\_hosts)} 使用的 \texttt{SSHManager} 会通过 SSH 启动远程机上的 worker。

\end{itemize}


默认 SSH 只会用来启动 Julia 的 worker。随后的 master-worker 和 worker-worker 连接使用的是普通的、未加密的 TCP/IP 通信。     远程机必须开启免密登陆。     额外的 SSH 标记或认证信息会通过关键字参数 \texttt{sshflags} 指定。



\begin{itemize}
\item \texttt{addprocs(list\_of\_remote\_hosts; tunnel=true, sshflags=<ssh keys and other flags>)} 在我们希望给 master-worker 也使用 SSH 连接的时候很有用。 一个典型的场景是本地的笔记本 运行 Julia ERPL （做为 master）和云上的其他机器，比如 Amazon EC2，构成集群。 这时候远程机器只要开启 22 端口就可以，然后要有 SSH 客户端 通过公约基础设施（PKI）认证过。授权信息可以通过 \texttt{sshflags} 生效，比如 \texttt{sshflags=`-i <keyfile>`}。

在一个所有节点联通的拓扑网中（默认情况下是这样的），所有的 worker 节点都通过普通 TCP socket 通信互相连接。 这样集群的安全策略就必须允许 worker 节点间 通过操作系统分配的临时端口范围自由连接。

所有 worker-worker 间（都是 SSH）的安全和加密或者信息的加密 都可以通过自定义 \texttt{ClusterManager} 完成。


\item 如果将 \texttt{multiplex=true} 指定为 \hyperlink{2657399037748470653}{\texttt{addprocs}} 的选项，则 SSH 多路复用用于在 master 和 worker 之间创建隧道。 如果你自己配置了 SSH 多路复用并且已经建立了连接，则无论 \texttt{multiplex} 选项如何，都会使用 SSH 多路复用。 如果启用了多路复用，则使用现有连接（ssh 中的 \texttt{-O forward} 选项）设置转发。 如果你的服务器需要密码验证，那么这就很有用了；

你可以通过在 \hyperlink{2657399037748470653}{\texttt{addprocs}} 之前登录服务器来避免在 Julia 中进行身份验证。 除非使用现有的多路复用连接，否则在会话期间控制套接字将位于 \texttt{{\textasciitilde}/.ssh/julia-\%r@\%h:\%p}。 请注意，如果你在一个节点上创建多个进程并启用多路复用，带宽可能会受到限制，因为在这种情况下，进程共享一个多路复用 TCP 连接。

\end{itemize}


\hypertarget{2147150475887832470}{}


\subsection{集群 Cookie}



集群上所有的进程都共享同一个 cookie，默认是 master 进程随机生成的字符串。



\begin{itemize}
\item \hyperlink{914110747490695974}{\texttt{cluster\_cookie()}} 返回 cookie，而 \texttt{cluster\_cookie(cookie)()} 设置并返回新的 cookie。


\item 所有的连接都进行双向认证，从而保证只有 master 启动的 worker 才能相互连接。


\item cookie 可以在 worker 启动的时候，通过参数 \texttt{--worker=<cookie>} 指定，如果参数 \texttt{--worker} 没有指定 cookie，那么 worker 会从它的标准输入中 (\hyperlink{3330957653919693521}{\texttt{stdin}}) 读取， \texttt{stdin} 会在 cookie 获取之后立即关闭。


\item \texttt{ClusterManager} 可以通过 \hyperlink{914110747490695974}{\texttt{cluster\_cookie()}} 从 master 中过去 cookie，不适用默认 TCP/IP 传输的集群管理器（即没有指定 \texttt{--worker}）必须用于 master 相同的 cookie 调用 \texttt{init\_worker(cookie, manager)}。

\end{itemize}


注意，在对安全性要求很高的环境中，可以通过自定义 \texttt{ClusterManager} 实现。例如，cookie 可以提前共享，然后不必再启动参数中指定。



\hypertarget{850726815620521431}{}


\section{指定网络拓补结构（实验性功能）}



传递给 \hyperlink{2657399037748470653}{\texttt{addprocs}} 的关键字参数 \texttt{topology} 用于指定 workers 必须如何相互连接：



\begin{itemize}
\item \texttt{:all\_to\_all}，默认的，所有 worker 之间相互都连接


\item \texttt{:master\_worker}，只有主进程，即 \texttt{pid} 为 1 的进程能够与 worker 建立连接


\item \texttt{:custom}: 集群管理器的 \texttt{launch} 方法通过 \texttt{WorkerConfig} 中的 \texttt{ident} 和 \texttt{connect\_idents} 指定连接的拓补结构。一个 worker 通过集群管理器提供的 \texttt{ident} 来连接到所有 \texttt{connect\_idents} 指定的 worker。

\end{itemize}


关键字参数 \texttt{lazy=true|false} 只会影响 \texttt{topology} 选项中的 \texttt{:all\_to\_all}。如果是 \texttt{true}，那么集群启动的时候 master 会连接所有的 worker，然后 worker 之间的特定连接会在初次唤醒的是建立连接，这有利于降低集群初始化的时候对资源的分配。\texttt{lazy} 的默认值是 \texttt{true}。



目前，在没有建立连接的两个 worker 之间传递消息会出错，目前该行为是实验性的，未来的版本中可能会改变。



\hypertarget{739481912811734032}{}


\section{一些值得关注的外部库}



除了 Julia 自带的并行机制之外，还有许多外部的库值得一提。例如 \href{https://github.com/JuliaParallel/MPI.jl}{MPI.jl} 提供了一个 \texttt{MPI} 协议的 Julia 的封装，或者是在 \hyperlink{9426129202976203184}{共享数组} 提到的 \href{https://github.com/JuliaParallel/Distributedarrays.jl}{DistributedArrays.jl}，此外尤其值得一提的是 Julia 的 GPU 编程生态，其包括：



\begin{itemize}
\item[1. ] 底层（C内核）的 \href{https://github.com/JuliaGPU/OpenCL.jl}{OpenCL.jl} 和 \href{https://github.com/JuliaGPU/CUDAdrv.jl}{CUDAdrv.jl}，分别提供了 OpenCL 和 CUDA 的封装。


\item[2. ] 底层（Julia 内核）的接口，如 \href{https://github.com/JuliaGPU/CUDAnative.jl}{CUDAnative.jl}，提供了 Julia 原生的 CUDA 实现。


\item[3. ] 高层的特定抽象，如 \href{https://github.com/JuliaGPU/CuArrays.jl}{CuArrays.jl} 和 \href{https://github.com/JuliaGPU/CLArrays.jl}{CLArrays.jl}。


\item[4. ] 高层的库，如 \href{https://github.com/JuliaComputing/ArrayFire.jl}{ArrayFire.jl} 和 \href{https://github.com/JuliaGPU/GPUArrays.jl}{GPUArrays.jl}。

\end{itemize}


下面的例子将介绍如何用 \texttt{DistributedArrays.jl} 和 \texttt{CuArrays.jl} 通过 \texttt{distribute()} 和 \texttt{CuArray()} 将数组分配到多个进程。



记住在载入 \texttt{DistributedArrays.jl} 时，需要用 \hyperlink{4972064255482407966}{\texttt{@everywhere}} 将其载入到多个进程中。




\begin{minted}{jlcon}
$ ./julia -p 4

julia> addprocs()

julia> @everywhere using DistributedArrays

julia> using CuArrays

julia> B = ones(10_000) ./ 2;

julia> A = ones(10_000) .* π;

julia> C = 2 .* A ./ B;

julia> all(C .≈ 4*π)
true

julia> typeof(C)
Array{Float64,1}

julia> dB = distribute(B);

julia> dA = distribute(A);

julia> dC = 2 .* dA ./ dB;

julia> all(dC .≈ 4*π)
true

julia> typeof(dC)
DistributedArrays.DArray{Float64,1,Array{Float64,1}}

julia> cuB = CuArray(B);

julia> cuA = CuArray(A);

julia> cuC = 2 .* cuA ./ cuB;

julia> all(cuC .≈ 4*π);
true

julia> typeof(cuC)
CuArray{Float64,1}
\end{minted}



请记住，CUDAnative.jl\footnotemark[2] 目前不支持某些 Julia 功能，尤其是像 \texttt{sin} 这样的一些函数需要替换为 \texttt{CUDAnative.sin}（cc：@maleadt）。



下面的例子中，通过 \texttt{DistributedArrays.jl} 和 \texttt{CuArrays.jl} 将一个数组分配到多个进程，然后调用一个函数。




\begin{minted}{julia}
function power_method(M, v)
    for i in 1:100
        v = M*v
        v /= norm(v)
    end

    return v, norm(M*v) / norm(v)  # or  (M*v) ./ v
end
\end{minted}



\texttt{power\_method} 重复创建一个新的向量然后对其归一化，这里并没有在函数中指定类型信息，来看看是否对前面提到的类型适用：




\begin{minted}{jlcon}
julia> M = [2. 1; 1 1];

julia> v = rand(2)
2-element Array{Float64,1}:
0.40395
0.445877

julia> power_method(M,v)
([0.850651, 0.525731], 2.618033988749895)

julia> cuM = CuArray(M);

julia> cuv = CuArray(v);

julia> curesult = power_method(cuM, cuv);

julia> typeof(curesult)
CuArray{Float64,1}

julia> dM = distribute(M);

julia> dv = distribute(v);

julia> dC = power_method(dM, dv);

julia> typeof(dC)
Tuple{DistributedArrays.DArray{Float64,1,Array{Float64,1}},Float64}
\end{minted}



最后，我们来看看 \texttt{MPI.jl}，这个库时 Julia 对 MPI 协议的封装。一一介绍其中的每个函数太累赘了，这里领会其实现协议的方法就够了。



考虑下面这个简单的脚本，它做的只是调用每个子进程，然后初始化其 rank，然后在 master 访问时，对 rank 求和。




\begin{minted}{julia}
import MPI

MPI.Init()

comm = MPI.COMM_WORLD
MPI.Barrier(comm)

root = 0
r = MPI.Comm_rank(comm)

sr = MPI.Reduce(r, MPI.SUM, root, comm)

if(MPI.Comm_rank(comm) == root)
   @printf("sum of ranks: %s\n", sr)
end

MPI.Finalize()
\end{minted}




\begin{lstlisting}
mpirun -np 4 ./julia example.jl
\end{lstlisting}



\footnotetext[1]{In this context, MPI refers to the MPI-1 standard. Beginning with MPI-2, the MPI standards committee introduced a new set of communication mechanisms, collectively referred to as Remote Memory Access (RMA). The motivation for adding rma to the MPI standard was to facilitate one-sided communication patterns. For additional information on the latest MPI standard, see \href{https://mpi-forum.org/docs}{https://mpi-forum.org/docs}.

}


\footnotetext[2]{\href{http://juliagpu.github.io/CUDAnative.jl/stable/man/usage.html\#Julia-support-1}{Julia GPU man pages}

}


\hypertarget{12867141128563676518}{}


\chapter{运行外部程序}



Julia 中命令的反引号记法借鉴于 shell、Perl 和 Ruby。然而，在 Julia 中编写




\begin{minted}{jlcon}
julia> `echo hello`
`echo hello`
\end{minted}



在多个方面上与 shell、Perl 和 Ruby 中的行为有所不同：



\begin{itemize}
\item 反引号创建一个 \hyperlink{10541952265148699805}{\texttt{Cmd}} 对象来表示命令，而不是立即运行命令。 你可以使用此对象将命令通过管道连接到其它命令、\hyperlink{18309243184998755104}{\texttt{run}} 它以及对它进行 \hyperlink{8104134490906192097}{\texttt{read}} 或 \hyperlink{16947913578760238729}{\texttt{write}}。


\item 在命令运行时，Julia 不会捕获命令的输出结果，除非你对它专门安排。相反，在默认情况下，命令的输出会被定向到 \hyperlink{18181294266083891471}{\texttt{stdout}}，因为它将使用 \texttt{libc} 的 \texttt{system} 调用。


\item 命令从不会在 shell 中运行。相反地，Julia 会直接解析命令语法，适当地插入变量并像 shell 那样拆分单词，同时遵从 shell 的引用语法。命令会作为 \texttt{julia} 的直接子进程运行，使用 \texttt{fork} 和 \texttt{exec} 调用。

\end{itemize}


\begin{quote}
\textbf{Note}

下面假设在 Linux 或 MacOS 上使用 Posix 环境。 在 Windows 上，许多类似的命令，例如 \texttt{echo} 和 \texttt{dir}，不是外部程序，而是内置在 shell \texttt{cmd.exe} 本身中。 运行这些命令的一种选择是调用 \texttt{cmd.exe}，例如 \texttt{cmd /C echo hello}。 或者，Julia 可以在 Posix 环境中运行，例如 Cygwin。

\end{quote}


这是运行外部程序的简单示例：




\begin{minted}{jlcon}
julia> mycommand = `echo hello`
`echo hello`

julia> typeof(mycommand)
Cmd

julia> run(mycommand);
hello
\end{minted}



\texttt{hello} 是 \texttt{echo} 命令的输出，发送到 \hyperlink{18181294266083891471}{\texttt{stdout}}。 如果外部命令无法成功运行，则 run 方法会抛出 \hyperlink{12102596058483452470}{\texttt{ErrorException}}。



如果要读取外部命令的输出，可以使用 \hyperlink{8104134490906192097}{\texttt{read}} 或 \hyperlink{1622401395685476756}{\texttt{readchomp}} 代替：




\begin{minted}{jlcon}
julia> read(`echo hello`, String)
"hello\n"

julia> readchomp(`echo hello`)
"hello"
\end{minted}



更一般地，你可以使用 \hyperlink{300818094931158296}{\texttt{open}} 来读取或写入外部命令。




\begin{minted}{jlcon}
julia> open(`less`, "w", stdout) do io
           for i = 1:3
               println(io, i)
           end
       end
1
2
3
\end{minted}



命令中的程序名称和各个参数可以访问和迭代，这就好像命令也是一个字符串数组：




\begin{minted}{jlcon}
julia> collect(`echo "foo bar"`)
2-element Vector{String}:
 "echo"
 "foo bar"

julia> `echo "foo bar"`[2]
"foo bar"
\end{minted}



\hypertarget{6373319844820183024}{}


\section{插值}



假设你想要做的事情更复杂，并使用以变量 \texttt{file} 表示的文件名作为命令的参数。那你可以像在字符串字面量中那样使用 \texttt{\$} 进行插值：




\begin{minted}{jlcon}
julia> file = "/etc/passwd"
"/etc/passwd"

julia> `sort $file`
`sort /etc/passwd`
\end{minted}



通过 shell 运行外部程序的一个常见陷阱是，如果文件名中包含 shell 中的特殊字符，那么可能会导致不希望出现的行为。例如，假设我们想要对其内容进行排序的文件是 \texttt{/Volumes/External HD/data.csv}，而不是 \texttt{/etc/passwd}。让我们来试试：




\begin{minted}{jlcon}
julia> file = "/Volumes/External HD/data.csv"
"/Volumes/External HD/data.csv"

julia> `sort $file`
`sort '/Volumes/External HD/data.csv'`
\end{minted}



文件名是如何被引用的？Julia 知道 \texttt{file} 是作为单个参数插入的，因此它替你引用了此单词。事实上，这不太准确：\texttt{file} 的值始终不会被 shell 解释，因此并不需要实际引用；插入引号只是为了展现给用户。就算你把值作为 shell 单词的一部分插入，这也可以工作：




\begin{minted}{jlcon}
julia> path = "/Volumes/External HD"
"/Volumes/External HD"

julia> name = "data"
"data"

julia> ext = "csv"
"csv"

julia> `sort $path/$name.$ext`
`sort '/Volumes/External HD/data.csv'`
\end{minted}



如你所见，\texttt{path} 变量中的空格被恰当地转义了。但是，如果你\emph{想}插入多个单词怎么办？在此情况下，只需使用数组（或其它可迭代容器）：




\begin{minted}{jlcon}
julia> files = ["/etc/passwd","/Volumes/External HD/data.csv"]
2-element Vector{String}:
 "/etc/passwd"
 "/Volumes/External HD/data.csv"

julia> `grep foo $files`
`grep foo /etc/passwd '/Volumes/External HD/data.csv'`
\end{minted}



如果将数组作为 shell 单词的一部分插入，Julia 将模拟 shell 的 \texttt{\{a,b,c\}} 参数生成：




\begin{minted}{jlcon}
julia> names = ["foo","bar","baz"]
3-element Vector{String}:
 "foo"
 "bar"
 "baz"

julia> `grep xylophone $names.txt`
`grep xylophone foo.txt bar.txt baz.txt`
\end{minted}



此外，若在同一单词中插入多个数组，则将模拟 shell 的笛卡尔积生成行为：




\begin{minted}{jlcon}
julia> names = ["foo","bar","baz"]
3-element Vector{String}:
 "foo"
 "bar"
 "baz"

julia> exts = ["aux","log"]
2-element Vector{String}:
 "aux"
 "log"

julia> `rm -f $names.$exts`
`rm -f foo.aux foo.log bar.aux bar.log baz.aux baz.log`
\end{minted}



因为可以插入字面量数组，所以你可以使用此生成功能，而无需先创建临时数组对象：




\begin{minted}{jlcon}
julia> `rm -rf $["foo","bar","baz","qux"].$["aux","log","pdf"]`
`rm -rf foo.aux foo.log foo.pdf bar.aux bar.log bar.pdf baz.aux baz.log baz.pdf qux.aux qux.log qux.pdf`
\end{minted}



\hypertarget{12430289445905702597}{}


\section{引用}



不可避免地，我们会想要编写不那么简单的命令，且有必要使用引号。下面是 shell 提示符下单行 Perl 程序的简单示例：




\begin{lstlisting}
sh$ perl -le '$|=1; for (0..3) { print }'
0
1
2
3
\end{lstlisting}



该 Perl 表达式需要使用单引号有两个原因：一是为了避免空格将表达式分解为多个 shell 单词，二是为了在使用像 \texttt{\$|}（是的，这在 Perl 中是变量名）这样的 Perl 变量时避免发生插值。在其它情况下，你可能想要使用双引号来\emph{真的}进行插值：




\begin{lstlisting}
sh$ first="A"
sh$ second="B"
sh$ perl -le '$|=1; print for @ARGV' "1: $first" "2: $second"
1: A
2: B
\end{lstlisting}



总之，Julia 反引号语法是经过精心设计的，因此你可以只是将 shell 命令剪切并粘贴到反引号中，接着它们将会工作：转义、引用和插值行为与 shell 相同。唯一的不同是，插值是集成的并且知道在 Julia 的概念中什么是单个字符串值、什么是多个值的容器。让我们在 Julia 中尝试上面的两个例子：




\begin{minted}{jlcon}
julia> A = `perl -le '$|=1; for (0..3) { print }'`
`perl -le '$|=1; for (0..3) { print }'`

julia> run(A);
0
1
2
3

julia> first = "A"; second = "B";

julia> B = `perl -le 'print for @ARGV' "1: $first" "2: $second"`
`perl -le 'print for @ARGV' '1: A' '2: B'`

julia> run(B);
1: A
2: B
\end{minted}



结果是相同的，且 Julia 的插值行为模仿了 shell 的并对其做了一些改进，因为 Julia 支持头等的可迭代对象，但大多数 shell 通过使用空格分隔字符串来实现这一点，而这又引入了歧义。在尝试将 shell 命令移植到 Julia 中时，请先试着剪切并粘贴它。因为 Julia 会在运行命令前向你显示命令，所以你可以在不造成任何破坏的前提下轻松并安全地检查命令的解释。



\hypertarget{565642647898476823}{}


\section{管道}



Shell 元字符，如 \texttt{|}、\texttt{\&} 和 \texttt{>}，在 Julia 的反引号中需被引用（或转义）：




\begin{minted}{jlcon}
julia> run(`echo hello '|' sort`);
hello | sort

julia> run(`echo hello \| sort`);
hello | sort
\end{minted}



此表达式调用 \texttt{echo} 命令并以三个单词作为其参数：\texttt{hello}、\texttt{|} 和 \texttt{sort}。结果是只打印了一行：\texttt{hello | sort}。那么，如何构造管道呢？为此，请使用 \hyperlink{13500803391014570583}{\texttt{pipeline}}，而不是在反引号内使用 \texttt{{\textquotesingle}|{\textquotesingle}}：




\begin{minted}{jlcon}
julia> run(pipeline(`echo hello`, `sort`));
hello
\end{minted}



这将 \texttt{echo} 命令的输出传输到 \texttt{sort} 命令中。当然，这不是很有趣，因为只有一行要排序，但是我们的当然可以做更多、更有趣的事：




\begin{minted}{jlcon}
julia> run(pipeline(`cut -d: -f3 /etc/passwd`, `sort -n`, `tail -n5`))
210
211
212
213
214
\end{minted}



这将打印在 UNIX 系统上最高的五个用户 ID。\texttt{cut}、\texttt{sort} 和 \texttt{tail} 命令都是当前 \texttt{julia} 进程的直接子进程，这中间没有 shell 进程的干预。Julia 自己负责设置管道和连接文件描述符，而这通常由 shell 完成。因为 Julia 自己做了这些事，所以它能更好的控制并做 shell 做不到的一些事情。



Julia 可以并行地运行多个命令：




\begin{minted}{jlcon}
julia> run(`echo hello` & `echo world`);
world
hello
\end{minted}



这里的输出顺序是不确定的，因为两个 \texttt{echo} 进程几乎同时启动，并且争着先写入 \hyperlink{18181294266083891471}{\texttt{stdout}} 描述符和 \texttt{julia} 父进程。Julia 允许你将这两个进程的输出通过管道传输到另一个程序：




\begin{minted}{jlcon}
julia> run(pipeline(`echo world` & `echo hello`, `sort`));
hello
world
\end{minted}



在 UNIX 管道方面，这里发生的是，一个 UNIX 管道对象由两个 \texttt{echo} 进程创建和写入，管道的另一端由 \texttt{sort} 命令读取。



IO 重定向可以通过向 \texttt{pipeline} 函数传递关键字参数 \texttt{stdin}、\texttt{stdout} 和 \texttt{stderr} 来实现：




\begin{minted}{julia}
pipeline(`do_work`, stdout=pipeline(`sort`, "out.txt"), stderr="errs.txt")
\end{minted}



\hypertarget{10119727931012697003}{}


\subsection{避免管道中的死锁}



在单个进程中读取和写入管道的两端时，避免强制内核缓冲所有数据是很重要的。



例如，在读取命令的所有输出时，请调用 \texttt{read(out, String)}，而非 \texttt{wait(process)}，因为前者会积极地消耗由该进程写入的所有数据，而后者在等待读取者连接时会尝试将数据存储内核的缓冲区中。



另一个常见的解决方案是将读取者和写入者分离到单独的 \hyperlink{7131243650304654155}{\texttt{Task}} 中：




\begin{minted}{julia}
writer = @async write(process, "data")
reader = @async do_compute(read(process, String))
wait(writer)
fetch(reader)
\end{minted}



（通常，reader 不是一个单独的任务，因为无论如何我们都会立即\texttt{fetch}它）。



\hypertarget{14183945833806948978}{}


\subsection{复杂示例}



高级编程语言、头等的命令抽象以及进程间管道的自动设置，三者组合起来非常强大。为了更好地理解可被轻松创建的复杂管道，这里有一些更复杂的例子，以避免对单行 Perl 程序的滥用。




\begin{minted}{jlcon}
julia> prefixer(prefix, sleep) = `perl -nle '$|=1; print "'$prefix' ", $_; sleep '$sleep';'`;

julia> run(pipeline(`perl -le '$|=1; for(0..5){ print; sleep 1 }'`, prefixer("A",2) & prefixer("B",2)));
B 0
A 1
B 2
A 3
B 4
A 5
\end{minted}



这是一个经典的例子，一个生产者为两个并发的消费者提供内容：一个 \texttt{perl} 进程生成从数字 0 到 5 的行，而两个并行进程则使用该输出，一个行首加字母「A」，另一个行首加字母「B」。哪个进程使用第一行是不确定的，但是一旦赢得了竞争，这些行会先后被其中一个进程及另一个进程交替使用。（在 Perl 中设置 \texttt{\$|=1} 会导致每个 print 语句刷新 \hyperlink{18181294266083891471}{\texttt{stdout}} 句柄，这是本例工作所必需的。此外，所有输出将被缓存并一次性打印到管道中，以便只由一个消费者进程读取。）



这是一个更加复杂的多阶段生产者——消费者示例：




\begin{minted}{jlcon}
julia> run(pipeline(`perl -le '$|=1; for(0..5){ print; sleep 1 }'`,
           prefixer("X",3) & prefixer("Y",3) & prefixer("Z",3),
           prefixer("A",2) & prefixer("B",2)));
A X 0
B Y 1
A Z 2
B X 3
A Y 4
B Z 5
\end{minted}



此示例与前一个类似，不同之处在于本例中的消费者有两个阶段，并且阶段间有不同的延迟，因此它们使用不同数量的并行 worker 来维持饱和的吞吐量。



我们强烈建议你尝试所有这些例子，以便了解它们的工作原理。



\hypertarget{4648668513566277987}{}


\section{\texttt{Cmd}对象}



反引号语法创建一个 \hyperlink{10541952265148699805}{\texttt{Cmd}} 类型的对象。 此类对象也可以直接从现有的 \texttt{Cmd} 或参数列表构造：




\begin{minted}{julia}
run(Cmd(`pwd`, dir=".."))
run(Cmd(["pwd"], detach=true, ignorestatus=true))
\end{minted}



这允许你通过关键字参数指定 \texttt{Cmd} 的执行环境的几个方面。 例如，\texttt{dir} 关键字提供对 \texttt{Cmd} 工作目录的控制：




\begin{minted}{jlcon}
julia> run(Cmd(`pwd`, dir="/"));
/
\end{minted}



并且 \texttt{env} 关键字允许您设置执行环境变量：




\begin{minted}{jlcon}
julia> run(Cmd(`sh -c "echo foo \$HOWLONG"`, env=("HOWLONG" => "ever!",)));
foo ever!
\end{minted}



有关其它关键字参数，请参阅 \hyperlink{10541952265148699805}{\texttt{Cmd}}。 \hyperlink{14476048880059260855}{\texttt{setenv}} 和 \hyperlink{274817159920864187}{\texttt{addenv}} 命令分别提供了另一种替换或添加到 \texttt{Cmd} 执行环境变量的方法：




\begin{minted}{jlcon}
julia> run(setenv(`sh -c "echo foo \$HOWLONG"`, ("HOWLONG" => "ever!",)));
foo ever!

julia> run(addenv(`sh -c "echo foo \$HOWLONG"`, "HOWLONG" => "ever!"));
foo ever!
\end{minted}



\hypertarget{12701135342622507818}{}


\chapter{调用 C 和 Fortran 代码}



在数值计算领域，尽管有很多用 C 语言或 Fortran 写的高质量且成熟的库都可以用 Julia 重写，但为了便捷利用现有的 C 或 Fortran 代码，Julia 提供简洁且高效的调用方式。Julia 的哲学是 \texttt{no boilerplate}： Julia 可以直接调用 C/Fortran 的函数，不需要任何{\textquotedbl}胶水{\textquotedbl}代码，代码生成或其它编译过程 – 即使在交互式会话 (REPL/Jupyter notebook) 中使用也一样. 在 Julia 中，上述特性可以仅仅通过调用 \hyperlink{14245046751182637566}{\texttt{ccall}} 实现，它的语法看起来就像是普通的函数调用。



被调用的代码必须是一个共享库（.so, .dylib, .dll）。大多数 C 和 Fortran 库都已经是以共享库的形式发布的，但在用 GCC 或 Clang 编译自己的代码时，需要添加 \texttt{-shared} 和 \texttt{-fPIC} 编译器选项。由于 Julia 的 JIT 生成的机器码跟原生 C 代码的调用是一样，所以在 Julia 里调用 C/Fortran 库的额外开销与直接从 C 里调用是一样的。\footnotemark[1]



可以通过元组 \texttt{(:function, {\textquotedbl}library{\textquotedbl})} 或 \texttt{({\textquotedbl}function{\textquotedbl}, {\textquotedbl}library{\textquotedbl})} 这两种形式来索引库中的函数，其中 \texttt{function} 是函数名，\texttt{library} 是库名。（特定平台/操作系统的）加载路径中可用的共享库将按名称解析。 也可以指定库的完整路径。



可以单独使用函数名来代替元组（只用 \texttt{:function} 或 \texttt{{\textquotedbl}function{\textquotedbl}}）。在这种情况下，函数名在当前进程中进行解析。这一调用形式可用于调用 C 库函数、Julia 运行时中的函数或链接到 Julia 的应用程序中的函数。



默认情况下，Fortran 编译器会\href{https://en.wikipedia.org/wiki/Name\_mangling\#Fortran}{进行名称修饰}（例如，将函数名转换为小写或大写，通常会添加下划线），要通过 \hyperlink{14245046751182637566}{\texttt{ccall}} 调用 Fortran 函数，传递的标识符必须与 Fortran 编译器名称修饰之后的一致。此外，在调用 Fortran 函数时，\textbf{所有}输入必须以指针形式传递，并已在堆或栈上分配内存。这不仅适用于通常是堆分配的数组及可变对象，而且适用于整数和浮点数等标量值，尽管这些值通常是栈分配的，且在使用 C 或 Julia 调用约定时通常是通过寄存器传递的。



最终，你能使用 \hyperlink{14245046751182637566}{\texttt{ccall}} 来实际生成一个对库函数的调用。\hyperlink{14245046751182637566}{\texttt{ccall}} 的参数是：



\begin{itemize}
\item[1. ] 一个 \texttt{(:function, {\textquotedbl}library{\textquotedbl})} 对（最常见）

或

一个 \texttt{:function} 名称符号或 \texttt{{\textquotedbl}function{\textquotedbl}} 名称字符串（用于当前进程或 libc 中的符号），

或

一个函数指针（例如，从 \texttt{dlsym} 获得的指针）。


\item[2. ] 函数的返回值类型


\item[3. ] 输入类型的元组，对应于函数签名


\item[4. ] 要传递给函数的实际参数值，如果有的话； 每个都是一个单独的参数。

\end{itemize}


\begin{quote}
\textbf{Note}

\texttt{(:function, {\textquotedbl}library{\textquotedbl})} 对、返回类型和输入类型必须是字面量（即，它们不能是变量，但请参阅下面的 \hyperlink{415091760485310867}{非常量函数规范}）。

当定义包含方法时，将在编译时评估其余参数。

\end{quote}


\begin{quote}
\textbf{Note}

请参阅下文了解如何 \hyperlink{10872711251657367863}{将 C 类型映射到 Julia 类型}。

\end{quote}


作为一个完整但简单的例子，下面从大多数 Unix 派生系统上的标准 C 库中调用 \texttt{clock} 函数：




\begin{minted}{jlcon}
julia> t = ccall(:clock, Int32, ())
2292761

julia> t
2292761

julia> typeof(t)
Int32
\end{minted}



\texttt{clock} 不接受任何参数并返回一个 \hyperlink{10103694114785108551}{\texttt{Int32}}。 一个常见的错误是忘记了参数类型的单元组必须用逗号结尾。 例如，要调用 \texttt{getenv} 函数来获取指向环境变量值的指针，可以这样调用：




\begin{minted}{jlcon}
julia> path = ccall(:getenv, Cstring, (Cstring,), "SHELL")
Cstring(@0x00007fff5fbffc45)

julia> unsafe_string(path)
"/bin/bash"
\end{minted}



请注意，参数类型元组必须是 \texttt{(Cstring,)}，而不是 \texttt{(Cstring)} 。这是因为 \texttt{(Cstring)} 只是括号括起来的表达式 \texttt{Cstring}，而不是包含 \texttt{Cstring} 的单元组：




\begin{minted}{jlcon}
julia> (Cstring)
Cstring

julia> (Cstring,)
(Cstring,)
\end{minted}



在实践中，尤其是在提供可重用功能时，通常会在 Julia 函数中包装 \hyperlink{14245046751182637566}{\texttt{ccall}} 使用，这些函数设置参数，然后以 C 或 Fortran 函数指定的任何方式检查错误。 如果发生错误，它会作为普通的 Julia 异常抛出。 这一点尤其重要，因为 C 和 Fortran API 在它们指示错误条件的方式上是出了名的不一致。 例如，\texttt{getenv} C 库函数被包裹在下面的 Julia 函数中，它是 \href{https://github.com/JuliaLang/julia/blob/master/base/env.jl}{\texttt{env.jl}}：




\begin{minted}{julia}
function getenv(var::AbstractString)
    val = ccall(:getenv, Cstring, (Cstring,), var)
    if val == C_NULL
        error("getenv: undefined variable: ", var)
    end
    return unsafe_string(val)
end
\end{minted}



C 函数 \texttt{getenv} 通过返回 \texttt{NULL} 的方式进行报错，但是其他 C 标准库函数也会通过多种不同的方式来报错，这包括返回 -1，0，1 以及其它特殊值。此封装能够明确地抛出异常信息，即是否调用者在尝试获取一个不存在的环境变量：




\begin{minted}{jlcon}
julia> getenv("SHELL")
"/bin/bash"

julia> getenv("FOOBAR")
getenv: undefined variable: FOOBAR
\end{minted}



这是一个稍微复杂的示例，用于发现本地计算机的主机名。 在此示例中，假设网络库代码位于名为“libc”的共享库中。 在实践中，这个函数通常是 C 标准库的一部分，因此“libc”部分应该被省略，但我们希望在这里展示这个语法的用法。




\begin{minted}{julia}
function gethostname()
    hostname = Vector{UInt8}(undef, 256) # MAXHOSTNAMELEN
    err = ccall((:gethostname, "libc"), Int32,
                (Ptr{UInt8}, Csize_t),
                hostname, sizeof(hostname))
    Base.systemerror("gethostname", err != 0)
    hostname[end] = 0 # ensure null-termination
    return GC.@preserve hostname unsafe_string(pointer(hostname))
end
\end{minted}



此示例首先分配一个字节数组。 然后它调用 C 库函数 \texttt{gethostname} 以使用主机名填充数组。 最后，它接受一个指向主机名缓冲区的指针，并将该指针转换为一个 Julia 字符串，假设它是一个以 NUL 结尾的 C 字符串。



C 库通常使用这种模式，要求调用者分配要传递给被调用者并填充的内存。 像这样从 Julia 分配内存通常是通过创建一个未初始化的数组并将指向其数据的指针传递给 C 函数来完成的。 这就是我们在这里不使用 \texttt{Cstring} 类型的原因：由于数组未初始化，它可能包含 NUL 字节。 作为 \hyperlink{14245046751182637566}{\texttt{ccall}} 的一部分，转换为 \texttt{Cstring} 会检查包含的 NUL 字节，因此可能会引发类型转换错误。



用 \texttt{unsafe\_string} 取消引用 \texttt{pointer(hostname)} 是一种不安全的操作，因为它需要访问为 \texttt{hostname} 分配的内存，而这些内存可能在同时被垃圾收集。 宏 \hyperlink{6484353991353718972}{\texttt{GC.@preserve}} 防止这种情况发生，从而防止访问无效的内存位置。



\hypertarget{17519979972664810183}{}


\section{创建和C兼容的Julia函数指针}



可以将Julia函数传递给接受函数指针参数的原生C函数。例如，要匹配满足下面的C原型：




\begin{lstlisting}
typedef returntype (*functiontype)(argumenttype, ...)
\end{lstlisting}



宏 \hyperlink{11617107520401351255}{\texttt{@cfunction}} 为调用 Julia 函数生成 C 兼容函数指针。 \hyperlink{11617107520401351255}{\texttt{@cfunction}} 的参数是：



\begin{itemize}
\item[1. ] 一个Julia函数


\item[2. ] 函数的返回值类型


\item[3. ] 输入类型的元组，对应于函数签名

\end{itemize}


\begin{quote}
\textbf{Note}

与 \texttt{ccall} 一样，返回类型和输入类型的元组必须是字面量常量。

\end{quote}


\begin{quote}
\textbf{Note}

目前，仅支持平台默认的C调用约定。这意味着，\texttt{@cfunction}生成的指针不能用于WINAPI要求在32位Windows上使用\texttt{stdcall}函数的调用中，但可以在WIN64上使用（其中\texttt{stdcall}与C调用约定统一）。

\end{quote}


一个典型的例子就是标准C库函数\texttt{qsort}，定义为：




\begin{lstlisting}
void qsort(void *base, size_t nmemb, size_t size,
           int (*compare)(const void*, const void*));
\end{lstlisting}



\texttt{base} 参数是一个指向长度为 \texttt{nmemb} 的数组的指针，每个元素都有 \texttt{size} 字节。 \texttt{compare} 是一个回调函数，它采用指向两个元素 \texttt{a} 和 \texttt{b} 的指针，如果 \texttt{a} 出现在 \texttt{b} 之前/之后，则返回小于/大于零的整数（如果允许任何顺序，则返回零） 。



现在，假设我们在 Julia 中有一个 1 维数组 \texttt{A}，我们希望使用\texttt{qsort}函数（而不是 Julia 的内置\texttt{sort}函数）对其进行排序。 在我们考虑调用 \texttt{qsort} 并传递参数之前，我们需要编写一个比较函数：




\begin{minted}{jlcon}
julia> function mycompare(a, b)::Cint
           return (a < b) ? -1 : ((a > b) ? +1 : 0)
       end
mycompare (generic function with 1 method)
\end{minted}



\texttt{qsort} 需要一个返回 C \texttt{int} 的比较函数，因此我们将返回类型注释为 \texttt{Cint}。



为了将此函数传递给 C，我们使用宏\texttt{@cfunction} 获取它的地址：




\begin{minted}{jlcon}
julia> mycompare_c = @cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}));
\end{minted}



\hyperlink{11617107520401351255}{\texttt{@cfunction}} 需要三个参数: Julia函数 (\texttt{mycompare}), 返回值类型(\texttt{Cint}), 和一个输入参数类型的字面量元组, 此处是要排序的\texttt{Cdouble}(\hyperlink{5027751419500983000}{\texttt{Float64}}) 元素的数组.



\texttt{qsort}的最终调用看起来是这样的：




\begin{minted}{jlcon}
julia> A = [1.3, -2.7, 4.4, 3.1]
4-element Vector{Float64}:
  1.3
 -2.7
  4.4
  3.1

julia> ccall(:qsort, Cvoid, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{Cvoid}),
             A, length(A), sizeof(eltype(A)), mycompare_c)

julia> A
4-element Vector{Float64}:
 -2.7
  1.3
  3.1
  4.4
\end{minted}



如示例所示，原始 Julia 数组 \texttt{A} 现在已排序：\texttt{[-2.7, 1.3, 3.1, 4.4]}。 请注意，Julia \hyperlink{3709811402862932682}{负责将数组转换为\texttt{Ptr\{Cdouble\}}})，计算元素类型的大小（以字节为单位），等等。



为了好玩，尝试在 \texttt{mycompare} 中插入一行 \texttt{println({\textquotedbl}mycompare(\$a, \$b){\textquotedbl})}，这将允许你查看 \texttt{qsort} 正在执行的比较（并验证它是否真的在调用你传递给它的 Julia 函数）。



\hypertarget{10747596823753409973}{}


\section{将 C 类型映射到 Julia}



将声明的 C 类型与其在 Julia 中的声明完全匹配至关重要。 不一致会导致在一个系统上正常工作的代码在另一个系统上失败或产生不确定的结果。



请注意，在调用 C 函数的过程中没有任何地方使用 C 头文件：您有责任确保您的 Julia 类型和调用签名准确反映 C 头文件中的那些。\footnotemark[2]



\hypertarget{15689505875890763631}{}


\subsection{自动类型转换}



Julia 会自动插入对 \hyperlink{16487788729383051927}{\texttt{Base.cconvert}} 函数的调用，以将每个参数转换为指定的类型。 例如，以下调用：




\begin{minted}{julia}
ccall((:foo, "libfoo"), Cvoid, (Int32, Float64), x, y)
\end{minted}



将表现得好像它是这样写的：




\begin{minted}{julia}
ccall((:foo, "libfoo"), Cvoid, (Int32, Float64),
      Base.unsafe_convert(Int32, Base.cconvert(Int32, x)),
      Base.unsafe_convert(Float64, Base.cconvert(Float64, y)))
\end{minted}



\hyperlink{16487788729383051927}{\texttt{Base.cconvert}} 通常只调用 \hyperlink{1846942650946171605}{\texttt{convert}}，但可以定义为返回一个更适合传递给 C 的任意新对象。这应该用于执行 C 代码将访问的内存。 例如，这用于将对象（例如字符串）的 \texttt{Array} 转换为指针数组。



\hyperlink{6011318385865707029}{\texttt{Base.unsafe\_convert}} 处理到 \hyperlink{10630331440513004826}{\texttt{Ptr}} 类型转换。 它被认为是不安全的，因为将对象转换为本地指针会隐藏垃圾收集器中的对象，导致它过早地被释放。



\hypertarget{16132350195879344041}{}


\subsection{类型对应}



首先，让我们回顾一些相关的 Julia 类型术语：




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
语法 / 关键字 & 例子 & 描述 \\
\hline
\texttt{mutable struct} & \texttt{BitSet} & \texttt{Leaf Type}：包含 \texttt{type-tag} 的一组相关数据，由 Julia GC 管理，通过 \texttt{object-identity} 来定义。为了保证实例可以被构造，\texttt{Leaf Type} 必须是完整定义的，即不允许使用 \texttt{TypeVars}。 \\
\hline
\texttt{abstract type} & \texttt{Any}, \texttt{AbstractArray\{T, N\}}, \texttt{Complex\{T\}} & \texttt{Super Type}：用于描述一组类型，它不是 \texttt{Leaf-Type}，也无法被实例化。 \\
\hline
\texttt{T\{A\}} & \texttt{Vector\{Int\}} & \texttt{Type Parameter}：某种类型的一种具体化，通常用于分派或存储优化。 \\
\hline
 &  & \texttt{TypeVar}：\texttt{Type parameter} 声明中的 \texttt{T} 是一个 \texttt{TypeVar}，它是类型变量的简称。 \\
\hline
\texttt{primitive type} & \texttt{Int}, \texttt{Float64} & \texttt{Primitive Type}：一种没有成员变量的类型，但是它有大小。它是按值存储和定义的。 \\
\hline
\texttt{struct} & \texttt{Pair\{Int, Int\}} & {\textquotedbl}Struct{\textquotedbl} :: 所有字段都定义为常量的类型。 它是按值定义的，并且可以与类型标签一起存储。 \\
\hline
 & \texttt{ComplexF64} (\texttt{isbits}) & {\textquotedbl}Is-Bits{\textquotedbl} :: 一个 \texttt{primitive type}，或者一个 \texttt{struct} 类型，其中所有字段都是其他 \texttt{isbits} 类型。 它是按值定义的，并且在没有类型标签的情况下存储。 \\
\hline
\texttt{struct ...; end} & \texttt{nothing} & \texttt{Singleton}：没有成员变量的 \texttt{Leaf Type} 或 \texttt{Struct}。 \\
\hline
\texttt{(...)} or \texttt{tuple(...)} & \texttt{(1, 2, 3)} & “元组” :: 类似于匿名结构类型或常量数组的不可变数据结构。 表示为数组或结构。 \\
\hline
\end{tabulary}

\end{table}



\hypertarget{538651652486673311}{}


\subsection{Bits Types}



有几种特殊类型需要注意，因为没有其他类型可以定义为具有相同的行为：



\begin{itemize}
\item \texttt{Float32}

和C语言中的 \texttt{float} 类型完全对应（以及Fortran中的 \texttt{REAL*4} ）


\item \texttt{Float64}

和C语言中的 \texttt{double} 类型完全对应（以及Fortran中的 \texttt{REAL*8} ）


\item \texttt{ComplexF32}

和C语言中的 \texttt{complex float} 类型完全对应（以及Fortran中的 \texttt{COMPLEX*8} ）


\item \texttt{ComplexF64}

和C语言中的 \texttt{complex double} 类型完全对应（以及Fortran中的 \texttt{COMPLEX*16} ）


\item \texttt{Signed}

和C语言中的 \texttt{signed} 类型标识完全对应（以及Fortran中的任意 \texttt{INTEGER} 类型） Julia中任何不是\hyperlink{14154866400772377486}{\texttt{Signed}} 的子类型的类型，都会被认为是unsigned类型。

\end{itemize}


\begin{itemize}
\item \texttt{Ref\{T\}}

和 \texttt{Ptr\{T\}} 行为相同，能通过Julia的GC管理其内存。

\end{itemize}


\begin{itemize}
\item \texttt{Array\{T,N\}}

当数组作为 \texttt{Ptr\{T\}} 参数传递给 C 时，它不是重新解释转换：Julia 要求数组的元素类型与 \texttt{T} 匹配，并传递第一个元素的地址。

因此，如果一个 \texttt{Array} 中的数据格式不正确，它必须被显式地转换 ，通过类似 \texttt{trunc(Int32, a)} 的函数。

若要将一个数组 \texttt{A} 以不同类型的指针传递，而\emph{不提前转换数据}， （比如，将一个 \texttt{Float64} 数组传给一个处理原生字节的函数时），你 可以将这一参数声明为 \texttt{Ptr\{Cvoid\}} 。

如果一个元素类型为 \texttt{Ptr\{T\}} 的数组作为 \texttt{Ptr\{Ptr\{T\}\}} 类型的参数传递， \hyperlink{16487788729383051927}{\texttt{Base.cconvert}}  将会首先尝试进行 null-terminated copy（即直到下一个元素为null才停止复制），并将每一个元素使用其通过 \hyperlink{16487788729383051927}{\texttt{Base.cconvert}} 转换后的版本替换。 这允许，比如，将一个 \texttt{argv} 的指针数组，其类型为 \texttt{Vector\{String\}} ，传递给一个类型为 \texttt{Ptr\{Ptr\{Cchar\}\}} 的参数。

\end{itemize}


在我们目前支持的所有系统上，基本的 C/C++ 值类型可以转换为 Julia 类型，如下所示。 每个 C 类型还有一个对应的同名 Julia 类型，以 C 为前缀。这在编写可移植代码时很有帮助（记住 C 中的 \texttt{int} 与 Julia 中的 \texttt{Int} 不同）。



\textbf{独立于系统的类型}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
C 类型 & Fortran 类型 & 标准 Julia 别名 & Julia 基本类型 \\
\hline
\texttt{unsigned char} & \texttt{CHARACTER} & \texttt{Cuchar} & \texttt{UInt8} \\
\hline
\texttt{bool} (\_Bool in C99+) &  & \texttt{Cuchar} & \texttt{UInt8} \\
\hline
\texttt{short} & \texttt{INTEGER*2}, \texttt{LOGICAL*2} & \texttt{Cshort} & \texttt{Int16} \\
\hline
\texttt{unsigned short} &  & \texttt{Cushort} & \texttt{UInt16} \\
\hline
\texttt{int}, \texttt{BOOL} (C, typical) & \texttt{INTEGER*4}, \texttt{LOGICAL*4} & \texttt{Cint} & \texttt{Int32} \\
\hline
\texttt{unsigned int} &  & \texttt{Cuint} & \texttt{UInt32} \\
\hline
\texttt{long long} & \texttt{INTEGER*8}, \texttt{LOGICAL*8} & \texttt{Clonglong} & \texttt{Int64} \\
\hline
\texttt{unsigned long long} &  & \texttt{Culonglong} & \texttt{UInt64} \\
\hline
\texttt{intmax\_t} &  & \texttt{Cintmax\_t} & \texttt{Int64} \\
\hline
\texttt{uintmax\_t} &  & \texttt{Cuintmax\_t} & \texttt{UInt64} \\
\hline
\texttt{float} & \texttt{REAL*4i} & \texttt{Cfloat} & \texttt{Float32} \\
\hline
\texttt{double} & \texttt{REAL*8} & \texttt{Cdouble} & \texttt{Float64} \\
\hline
\texttt{complex float} & \texttt{COMPLEX*8} & \texttt{ComplexF32} & \texttt{Complex\{Float32\}} \\
\hline
\texttt{complex double} & \texttt{COMPLEX*16} & \texttt{ComplexF64} & \texttt{Complex\{Float64\}} \\
\hline
\texttt{ptrdiff\_t} &  & \texttt{Cptrdiff\_t} & \texttt{Int} \\
\hline
\texttt{ssize\_t} &  & \texttt{Cssize\_t} & \texttt{Int} \\
\hline
\texttt{size\_t} &  & \texttt{Csize\_t} & \texttt{UInt} \\
\hline
\texttt{void} &  &  & \texttt{Cvoid} \\
\hline
\texttt{void} and \texttt{[[noreturn]]} or \texttt{\_Noreturn} &  &  & \texttt{Union\{\}} \\
\hline
\texttt{void*} &  &  & \texttt{Ptr\{Cvoid\}} (或类似的 \texttt{Ref\{Cvoid\}}) \\
\hline
\texttt{T*} (where T represents an appropriately defined type) &  &  & \texttt{Ref\{T\}} （只有当 T 是 isbits 类型时，T 才可以安全地转变） \\
\hline
\texttt{char*} (or \texttt{char[]}, e.g. a string) & \texttt{CHARACTER*N} &  & \texttt{Cstring} if NUL-terminated, or \texttt{Ptr\{UInt8\}} if not \\
\hline
\texttt{char**} (or \texttt{*char[]}) &  &  & \texttt{Ptr\{Ptr\{UInt8\}\}} \\
\hline
\texttt{jl\_value\_t*} (any Julia Type) &  &  & \texttt{Any} \\
\hline
\texttt{jl\_value\_t* const*} (一个 Julia 值的引用） &  &  & \texttt{Ref\{Any\}}（常量，因为转变需要写屏障，不可能正确插入） \\
\hline
\texttt{va\_arg} &  &  & Not supported \\
\hline
\texttt{...} (variadic function specification) &  &  & \texttt{T...}（其中 \texttt{T} 是上述类型之一，当使用 \texttt{ccall} 函数时） \\
\hline
\texttt{...} (variadic function specification) &  &  & \texttt{; va\_arg1::T、va\_arg2::S 等}（仅支持\texttt{@ccall} 宏） \\
\hline
\end{tabulary}

\end{table}



\hyperlink{8632604011862685836}{\texttt{Cstring}} 类型本质上是\texttt{Ptr\{UInt8\}}的同义词，但如果Julia字符串包含任何嵌入的NUL字符，则类型转换为\texttt{Cstring}会引发错误（如果C例程将NUL视为终止符，则会导致字符串被静默截断）。如果要将\texttt{char*}传递给不采用NUL终止的C例程（例如，因为传递的是显式字符串长度），或者如果确定Julia字符串不包含NUL并希望跳过检查，则可以使用\texttt{Ptr\{UInt8\}}作为参数类型。\texttt{Cstring}也可以用作 \hyperlink{14245046751182637566}{\texttt{ccall}} 返回类型，但在这种情况下，它显然不会引入任何额外的检查，只是为了提高调用的可读性。



\textbf{系统独立类型}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
C 类型 & 标准 Julia 别名 & Julia 基本类型 \\
\hline
\texttt{char} & \texttt{Cchar} & \texttt{Int8} (x86, x86\_64), \texttt{UInt8} (powerpc, arm) \\
\hline
\texttt{long} & \texttt{Clong} & \texttt{Int} (UNIX), \texttt{Int32} (Windows) \\
\hline
\texttt{unsigned long} & \texttt{Culong} & \texttt{UInt} (UNIX), \texttt{UInt32} (Windows) \\
\hline
\texttt{wchar\_t} & \texttt{Cwchar\_t} & \texttt{Int32} (UNIX), \texttt{UInt16} (Windows) \\
\hline
\end{tabulary}

\end{table}



\begin{quote}
\textbf{Note}

调用 Fortran 时，所有输入都必须通过指向堆分配或堆栈分配值的指针传递，因此上述所有类型对应都应在其类型规范周围包含一个额外的 \texttt{Ptr\{..\}} 或 \texttt{Ref\{..\}} 包装器。

\end{quote}


\begin{quote}
\textbf{Warning}

对于字符串参数 (\texttt{char*})，Julia 类型应该是 \texttt{Cstring}（如果需要以 NUL 结尾的数据），否则为 \texttt{Ptr\{Cchar\}} 或 \texttt{Ptr\{UInt8\}}（这两种指针类型具有相同的效果），如上所述，而不是 \texttt{String}。 类似地，对于数组参数（\texttt{T[]} 或 \texttt{T*}），Julia 类型应该还是 \texttt{Ptr\{T\}}，而不是 \texttt{Vector\{T\}}。

\end{quote}


\begin{quote}
\textbf{Warning}

Julia 的 \texttt{Char} 类型是 32 位，这与所有平台上的宽字符类型（\texttt{wchar\_t} 或 \texttt{wint\_t}）不同。

\end{quote}


\begin{quote}
\textbf{Warning}

\texttt{Union\{\}} 的返回类型意味着函数不会返回，即 C++11 \texttt{[[noreturn]]} 或 C11 \texttt{\_Noreturn}（例如 \texttt{jl\_throw} 或 \texttt{longjmp}）。 不要将此用于不返回值（\texttt{void}）但返回的函数，而是使用\texttt{Cvoid}。

\end{quote}


\begin{quote}
\textbf{Note}

对于 \texttt{wchar\_t*} 参数，Julia 类型应为 \hyperlink{510630608879002831}{\texttt{Cwstring}}（如果 C 例程需要以 NUL 结尾的字符串），否则为 \texttt{Ptr\{Cwchar\_t\}}。 另请注意，Julia 中的 UTF-8 字符串数据在内部以 NUL 结尾，因此可以将其传递给需要以 NUL 结尾的数据的 C 函数，而无需进行复制（但使用 \texttt{Cwstring} 类型将导致抛出错误，如果字符串本身包含 NUL 字符）。

\end{quote}


\begin{quote}
\textbf{Note}

可以在 Julia 中使用 \texttt{Ptr\{Ptr\{UInt8\}\}} 类型调用采用 \texttt{char**} 类型参数的 C 函数。 例如，以下形式的 C 函数：


\begin{lstlisting}
int main(int argc, char **argv);
\end{lstlisting}

可以通过以下 Julia 代码调用：


\begin{minted}{julia}
argv = [ "a.out", "arg1", "arg2" ]
ccall(:main, Int32, (Int32, Ptr{Ptr{UInt8}}), length(argv), argv)
\end{minted}

\end{quote}


\begin{quote}
\textbf{Note}

对于采用 \texttt{character(len=*)} 类型的可变长度字符串的 Fortran 函数，字符串长度作为\emph{隐藏参数}提供。 这些参数在列表中的类型和位置是特定于编译器的，编译器供应商通常默认使用 \texttt{Csize\_t} 作为类型并将隐藏的参数附加到参数列表的末尾。 虽然此行为对于某些编译器 (GNU) 是固定的，但其他编译器\emph{可选} 允许将隐藏参数直接放置在字符参数（Intel、PGI）之后。 例如，如下的 Fortran 子程序


\begin{lstlisting}
subroutine test(str1, str2)
character(len=*) :: str1,str2
\end{lstlisting}

can be called via the following Julia code, where the lengths are appended


\begin{minted}{julia}
str1 = "foo"
str2 = "bar"
ccall(:test, Cvoid, (Ptr{UInt8}, Ptr{UInt8}, Csize_t, Csize_t),
                    str1, str2, sizeof(str1), sizeof(str2))
\end{minted}

\end{quote}


\begin{quote}
\textbf{Warning}

Fortran 编译器还\emph{可以}为指针、假定形状（\texttt{:}）和假定大小（\texttt{*}）数组添加其他隐藏参数。 这种行为可以通过使用\texttt{ISO\_C\_BINDING}并在子例程的定义中包含\texttt{bind(c)}来避免，强烈推荐用于可互操作的代码。 在这种情况下，将没有隐藏的参数，代价是一些语言特性（例如，只允许 \texttt{character(len=1)} 传递字符串）。

\end{quote}


\begin{quote}
\textbf{Note}

声明为返回 \texttt{Cvoid} 的 C 函数将在 Julia 中返回值 \texttt{nothing}。

\end{quote}


\hypertarget{15288158452444609990}{}


\subsection{结构类型对应}



复合类型，例如 C 中的\texttt{struct}或 Fortran90 中的\texttt{TYPE}（或 F77 的某些变体中的\texttt{STRUCTURE}/\texttt{RECORD}），可以通过创建具有相同字段布局的\texttt{struct}定义在 Julia 中进行镜像复制。



当递归使用时，\texttt{isbits} 类型被内联存储。 所有其他类型都存储为指向数据的指针。 在 C 中的另一个结构中镜像复制按值使用的结构时，不要尝试手动复制字段，因为这不会保留正确的字段对齐。 相反，建议声明一个 \texttt{isbits} 结构类型并使用它。 未命名的结构在翻译为 Julia 时是不可能的。



Julia不支持压缩结构和联合声明。



如果你事先地知道将具有最大大小（可能包括填充）的字段，则可以获得 \texttt{union} 的近似。 将你的字段转换为 Julia 时，将 Julia 字段声明为仅属于该类型。



参数数组可以用 \texttt{NTuple} 表示。例如，C 符号中的 struct 写成




\begin{lstlisting}
struct B {
    int A[3];
};

b_a_2 = B.A[2];
\end{lstlisting}



可以用 Julia 写成




\begin{minted}{julia}
struct B
    A::NTuple{3, Cint}
end

b_a_2 = B.A[3]  # note the difference in indexing (1-based in Julia, 0-based in C)
\end{minted}



不直接支持未知大小的数组（由\texttt{[]} 或\texttt{[0]} 指定的符合C99 的可变长度结构）。 通常处理这些的最好方法是直接处理字节偏移量。 例如，如果一个 C 库声明了一个正确的字符串类型并返回一个指向它的指针：




\begin{lstlisting}
struct String {
    int strlen;
    char data[];
};
\end{lstlisting}



在 Julia 中，我们可以独立访问这些部分以制作该字符串的副本：




\begin{minted}{julia}
str = from_c::Ptr{Cvoid}
len = unsafe_load(Ptr{Cint}(str))
unsafe_string(str + Core.sizeof(Cint), len)
\end{minted}



\hypertarget{12275815582345064545}{}


\subsection{类型参数}



当定义了方法时，\texttt{ccall} 和 \texttt{@cfunction} 的类型参数被静态地评估。 因此，它们必须采用字面量元组的形式，而不是变量，并且不能引用局部变量。



这听起来像是一个奇怪的限制，但请记住，由于 C 不是像 Julia 那样的动态语言，它的函数只能接受具有静态已知的固定签名的参数类型。



然而，虽然必须静态地知道类型布局才能计算预期的 C ABI，但函数的静态参数被视为此静态环境的一部分。函数的静态参数可以用作调用签名中的类型参数，只要它们不影响类型的布局即可。例如， \texttt{f(x::T) where \{T\} = ccall(:valid, Ptr\{T\}, (Ptr\{T\},), x)} 是有效的，因为 \texttt{Ptr} 始终是字大小的原始类型。但是， \texttt{g(x::T) where \{T\} = ccall(:notvalid, T, (T,), x)} 是无效的，因为 \texttt{T} 的类型布局不是静态已知的。



\hypertarget{12802490213714574525}{}


\subsection{SIMD 值}



注意：此功能目前仅在 64 位 x86 和 AArch64 平台上实现。



如果 C/C++ 例程具有本机 SIMD 类型的参数或返回值，则相应的 Julia 类型是自然映射到 SIMD 类型的\texttt{VecElement} 的同构元组。 具体来说：



\begin{quote}
\begin{itemize}
\item 元组的大小必须与 SIMD 类型相同。 例如，一个表示 \texttt{\_\_m128} 的元组

\end{itemize}
在 x86 上必须有 16 字节的大小。

\begin{itemize}
\item 元组的元素类型必须是 \texttt{VecElement\{T\}} 的一个实例，其中 \texttt{T} 是一个原始类型

\end{itemize}
是 1、2、4 或 8 个字节。

\end{quote}


例如，考虑这个使用 AVX 内在函数的 C 例程：




\begin{lstlisting}
#include <immintrin.h>

__m256 dist( __m256 a, __m256 b ) {
    return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),
                                        _mm256_mul_ps(b, b)));
}
\end{lstlisting}



以下 Julia 代码使用 \texttt{ccall} 调用 \texttt{dist}：




\begin{minted}{julia}
const m256 = NTuple{8, VecElement{Float32}}

a = m256(ntuple(i -> VecElement(sin(Float32(i))), 8))
b = m256(ntuple(i -> VecElement(cos(Float32(i))), 8))

function call_dist(a::m256, b::m256)
    ccall((:dist, "libdist"), m256, (m256, m256), a, b)
end

println(call_dist(a,b))
\end{minted}



主机必须具有必要的 SIMD 寄存器。 例如，上面的代码将无法在没有 AVX 支持的主机上运行。



\hypertarget{10794774929021837783}{}


\subsection{内存所有权}



\textbf{malloc/free}



此类对象的内存分配和释放必须通过调用正在使用的库中的适当清理例程来处理，就像在任何 C 程序中一样。 不要尝试在 Julia 中使用 \hyperlink{1633533624062187737}{\texttt{Libc.free}} 释放从 C 库接收的对象，因为这可能会导致通过错误的库调用 \texttt{free} 函数并导致进程中止。 反过来（传递在 Julia 中分配的对象以供外部库释放）同样无效。



\hypertarget{13734604265364549635}{}


\subsection{何时使用 T、Ptr\{T\} 以及 Ref\{T\}}



在对外部C例程的Julia代码包装调用中，普通（非指针）数据应该在\hyperlink{14245046751182637566}{\texttt{ccall}} 中声明为\texttt{T}类型，因为它们是通过值传递的。对于接受指针的C代码，\hyperlink{7936024700322877457}{\texttt{Ref\{T\}}} 通常应用于输入参数的类型，允许通过对\hyperlink{16487788729383051927}{\texttt{Base.cconvert}} 的隐式调用使用指向Julia或C管理的内存的指针。相反，被调用的C函数返回的指针应该声明为输出类型\hyperlink{10630331440513004826}{\texttt{Ptr\{T\}}}，这反映了指向的内存仅由C管理。C结构中包含的指针应在相应的Julia结构类型中表示为\texttt{Ptr\{T\}}类型的字段，这些结构类型旨在模拟相应C结构的内部结构。



在 Julia 代码包装对外部 Fortran 例程的调用中，所有输入参数都应声明为\texttt{Ref\{T\}}类型，因为 Fortran 通过指向内存位置的指针传递所有变量。 Fortran 子程序的返回类型应该是 \texttt{Cvoid}，或者 Fortran 函数的返回类型应该是 \texttt{T}，返回类型是 \texttt{T}。



\hypertarget{6114319820079574946}{}


\section{Mapping C Functions to Julia}



\hypertarget{14464013813592582244}{}


\subsection{\texttt{ccall} / \texttt{@cfunction} argument translation guide}



For translating a C argument list to Julia:



\begin{itemize}
\item \texttt{T}, where \texttt{T} is one of the primitive types: \texttt{char}, \texttt{int}, \texttt{long}, \texttt{short}, \texttt{float}, \texttt{double}, \texttt{complex}, \texttt{enum} or any of their \texttt{typedef} equivalents

\begin{itemize}
\item \texttt{T}, where \texttt{T} is an equivalent Julia Bits Type (per the table above)


\item if \texttt{T} is an \texttt{enum}, the argument type should be equivalent to \texttt{Cint} or \texttt{Cuint}


\item argument value will be copied (passed by value)

\end{itemize}

\item \texttt{struct T} (including typedef to a struct)

\begin{itemize}
\item \texttt{T}, where \texttt{T} is a Julia leaf type


\item argument value will be copied (passed by value)

\end{itemize}

\item \texttt{void*}

\begin{itemize}
\item depends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list


\item this argument may be declared as \texttt{Ptr\{Cvoid\}}, if it really is just an unknown pointer

\end{itemize}

\item \texttt{jl\_value\_t*}

\begin{itemize}
\item \texttt{Any}


\item argument value must be a valid Julia object

\end{itemize}

\item \texttt{jl\_value\_t* const*}

\begin{itemize}
\item \texttt{Ref\{Any\}}


\item 参数列表必须是有效的 Julia 对象（或 C\_NULL）


\item 不能用于输出参数，除非用户能够单独安排要GC保留的对象

\end{itemize}

\item \texttt{T*}

\begin{itemize}
\item \texttt{Ref\{T\}}, where \texttt{T} is the Julia type corresponding to \texttt{T}


\item 如果参数值是 \texttt{inlinealloc} 类型（否则包括 \texttt{isbits}，该值必须是有效的 Julia 对象）将被复制

\end{itemize}

\item \texttt{T (*)(...)} (e.g. a pointer to a function)

\begin{itemize}
\item \texttt{Ptr\{Cvoid\}}（你可能需要显式使用 \hyperlink{11617107520401351255}{\texttt{@cfunction}} 来创建这个指针）

\end{itemize}

\item \texttt{...} (e.g. a vararg)

\begin{itemize}
\item [[for \texttt{ccall}]: \texttt{T...}，其中 \texttt{T} 是所有剩余参数的单个 Julia 类型]: \texttt{T...}, where \texttt{T} is the single Julia type of all


\item [[for \texttt{@ccall}]：\texttt{; va\_arg1::T、va\_arg2::S} 等，其中 \texttt{T} 和 \texttt{S} 是 Julia 类型（即用 \texttt{;} 将常规参数与可变参数分开）]: \texttt{; va\_arg1::T, va\_arg2::S, etc}, where \texttt{T} and \texttt{S} are


\item \texttt{@cfunction} 目前不支持

\end{itemize}

\item \texttt{va\_arg}

\begin{itemize}
\item \texttt{ccall} 或 \texttt{@cfunction} 不支持

\end{itemize}
\end{itemize}


\hypertarget{13507762415394207754}{}


\subsection{\texttt{ccall} / \texttt{@cfunction} return type translation guide}



For translating a C return type to Julia:



\begin{itemize}
\item \texttt{void}

\begin{itemize}
\item \texttt{Cvoid} (this will return the singleton instance \texttt{nothing::Cvoid})

\end{itemize}

\item \texttt{T}, where \texttt{T} is one of the primitive types: \texttt{char}, \texttt{int}, \texttt{long}, \texttt{short}, \texttt{float}, \texttt{double}, \texttt{complex}, \texttt{enum} or any of their \texttt{typedef} equivalents

\begin{itemize}
\item \texttt{T}, where \texttt{T} is an equivalent Julia Bits Type (per the table above)


\item if \texttt{T} is an \texttt{enum}, the argument type should be equivalent to \texttt{Cint} or \texttt{Cuint}


\item argument value will be copied (returned by-value)

\end{itemize}

\item \texttt{struct T} (including typedef to a struct)

\begin{itemize}
\item \texttt{T}, where \texttt{T} is a Julia Leaf Type


\item argument value will be copied (returned by-value)

\end{itemize}

\item \texttt{void*}

\begin{itemize}
\item depends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list


\item this argument may be declared as \texttt{Ptr\{Cvoid\}}, if it really is just an unknown pointer

\end{itemize}

\item \texttt{jl\_value\_t*}

\begin{itemize}
\item \texttt{Any}


\item argument value must be a valid Julia object

\end{itemize}

\item \texttt{jl\_value\_t**}

\begin{itemize}
\item \texttt{Ptr\{Any\}} (\texttt{Ref\{Any\}} is invalid as a return type)

\end{itemize}

\item \texttt{T*}

\begin{itemize}
\item If the memory is already owned by Julia, or is an \texttt{isbits} type, and is known to be non-null:

\begin{itemize}
\item \texttt{Ref\{T\}}, where \texttt{T} is the Julia type corresponding to \texttt{T}


\item \texttt{Ref\{Any\}} 的返回类型无效，它应该是 \texttt{Any}（对应于 \texttt{jl\_value\_t*}）或 \texttt{Ptr\{Any\}}（对应于 \texttt{jl\_value\_t**}）


\item C \textbf{MUST NOT} modify the memory returned via \texttt{Ref\{T\}} if \texttt{T} is an \texttt{isbits} type

\end{itemize}

\item If the memory is owned by C:

\begin{itemize}
\item \texttt{Ptr\{T\}}, where \texttt{T} is the Julia type corresponding to \texttt{T}

\end{itemize}
\end{itemize}

\item \texttt{T (*)(...)} (e.g. a pointer to a function)

\begin{itemize}
\item \texttt{Ptr\{Cvoid\}} (you may need to use \hyperlink{11617107520401351255}{\texttt{@cfunction}} explicitly to create this pointer)

\end{itemize}
\end{itemize}


\hypertarget{11832262445711050581}{}


\subsection{传递修改输入的指针}



因为 C 不支持多个返回值，所以 C 函数通常会使用指向函数将修改的数据的指针。 要在 \hyperlink{14245046751182637566}{\texttt{ccall}} 中完成此操作，你需要首先将值封装在适当类型的 \hyperlink{7936024700322877457}{\texttt{Ref\{T\}}} 中。 当你将这个 \texttt{Ref} 对象作为参数传递时，Julia 会自动传递一个指向封装数据的 C 指针：




\begin{minted}{julia}
width = Ref{Cint}(0)
range = Ref{Cfloat}(0)
ccall(:foo, Cvoid, (Ref{Cint}, Ref{Cfloat}), width, range)
\end{minted}



返回时，可以通过\texttt{width[]}和\texttt{range[]}检索\texttt{width}和\texttt{range}的内容（如果它们被\texttt{foo}改变的话）； 也就是说，它们就像零维数组。



\hypertarget{11509619139541983993}{}


\section{C 包装器示例}



让我们从一个返回 \texttt{Ptr} 类型的 C 包装器的简单示例开始：




\begin{minted}{julia}
mutable struct gsl_permutation
end

# The corresponding C signature is
#     gsl_permutation * gsl_permutation_alloc (size_t n);
function permutation_alloc(n::Integer)
    output_ptr = ccall(
        (:gsl_permutation_alloc, :libgsl), # name of C function and library
        Ptr{gsl_permutation},              # output type
        (Csize_t,),                        # tuple of input types
        n                                  # name of Julia variable to pass in
    )
    if output_ptr == C_NULL # Could not allocate memory
        throw(OutOfMemoryError())
    end
    return output_ptr
end
\end{minted}



\href{https://www.gnu.org/software/gsl/}{GNU 科学图书馆}（这里假设可以通过\texttt{:libgsl} 访问）定义了一个不透明的指针，\texttt{gsl\_permutation *}，作为 C 函数\texttt{gsl\_permutation\_alloc} 的返回类型。 由于用户代码永远不必查看 \texttt{gsl\_permutation} 结构内部，相应的 Julia 包装器只需要一个新的类型声明 \texttt{gsl\_permutation}，它没有内部字段，其唯一目的是放置在 \texttt{Ptr}类型的类型参数中。 \hyperlink{14245046751182637566}{\texttt{ccall}} 的返回类型声明为 \texttt{Ptr\{gsl\_permutation\}}，因为 \texttt{output\_ptr} 分配和指向的内存由 C 控制。



输入 \texttt{n} 是按值传递的，因此函数的输入签名被简单地声明为 \texttt{(Csize\_t,)}，不需要任何 \texttt{Ref} 或 \texttt{Ptr}。 （如果包装器改为调用 Fortran 函数，则相应的函数输入签名将改为 \texttt{(Ref\{Csize\_t\},)}，因为 Fortran 变量是通过指针传递的。）此外，\texttt{n} 可以是任何可转换的类型 到一个 \texttt{Csize\_t} 整数； \hyperlink{14245046751182637566}{\texttt{ccall}} 隐式调用 \hyperlink{16487788729383051927}{\texttt{Base.cconvert(Csize\_t, n)}}。



这是包装相应析构函数的第二个示例：




\begin{minted}{julia}
# The corresponding C signature is
#     void gsl_permutation_free (gsl_permutation * p);
function permutation_free(p::Ref{gsl_permutation})
    ccall(
        (:gsl_permutation_free, :libgsl), # name of C function and library
        Cvoid,                             # output type
        (Ref{gsl_permutation},),          # tuple of input types
        p                                 # name of Julia variable to pass in
    )
end
\end{minted}



这里，输入\texttt{p}被声明为\texttt{Ref\{gsl\_permutation\}}类型，这意味着\texttt{p}指向的内存可以由Julia或C管理。由C分配的内存指针应该是类型 \texttt{Ptr\{gsl\_permutation\}}，但它可以使用 \href{@ref}{\texttt{Base.cconvert} } 进行转换，因此



现在，如果你仔细观察这个例子，你可能会注意到它是不正确的，因为我们上面对首选声明类型的解释。 你看到了吗？ 我们正在调用的函数将释放内存。 这种类型的操作不能被赋予 Julia 对象（它会崩溃或导致内存损坏）。因此，将 \texttt{p} 类型声明为 \texttt{Ptr\{gsl\_permutation \}} 可能更可取，这样用户就更难错误地传递另一种对象，而不是通过 \texttt{gsl\_permutation\_alloc} 获得的对象。



如果 C 包装器从不希望用户将指针传递给 Julia 管理的内存，那么使用 \texttt{p::Ptr\{gsl\_permutation\}} 作为包装器的方法签名，类似地在 \hyperlink{14245046751182637566}{\texttt{ccall}} 中也是可以接受。



这是传递 Julia 数组的第三个示例：




\begin{minted}{julia}
# The corresponding C signature is
#    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,
#                                double result_array[])
function sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)
    if nmax < nmin
        throw(DomainError())
    end
    result_array = Vector{Cdouble}(undef, nmax - nmin + 1)
    errorcode = ccall(
        (:gsl_sf_bessel_Jn_array, :libgsl), # name of C function and library
        Cint,                               # output type
        (Cint, Cint, Cdouble, Ref{Cdouble}),# tuple of input types
        nmin, nmax, x, result_array         # names of Julia variables to pass in
    )
    if errorcode != 0
        error("GSL error code $errorcode")
    end
    return result_array
end
\end{minted}



包装的 C 函数返回一个整数错误代码； Bessel J 函数的实际评估结果填充 Julia 数组 \texttt{result\_array}。 这个变量被声明为一个 \texttt{Ref\{Cdouble\}}，因为它的内存是由 Julia 分配和管理的。 对 \hyperlink{16487788729383051927}{\texttt{Base.cconvert(Ref\{Cdouble\}, result\_array)}} 的隐式调用将指向 Julia 数组数据结构的 Julia 指针解包为 C 可以理解的形式。



\hypertarget{6854516293199169395}{}


\section{Fortran 包装器示例}



以下示例利用 ccall 调用通用 Fortran 库 (libBLAS) 中的函数来计算点积。 请注意，这里的参数映射与上面的有点不同，因为我们需要从 Julia 映射到 Fortran。 在每个参数类型上，我们指定 \texttt{Ref} 或 \texttt{Ptr}。 此修改约定可能特定于你的 Fortran 编译器和操作系统，并且可能未记录在案。 但是，将每个包装在一个 \texttt{Ref}（或 \texttt{Ptr}，等效地）中是 Fortran 编译器实现的一个常见要求：




\begin{minted}{julia}
function compute_dot(DX::Vector{Float64}, DY::Vector{Float64})
    @assert length(DX) == length(DY)
    n = length(DX)
    incx = incy = 1
    product = ccall((:ddot_, "libLAPACK"),
                    Float64,
                    (Ref{Int32}, Ptr{Float64}, Ref{Int32}, Ptr{Float64}, Ref{Int32}),
                    n, DX, incx, DY, incy)
    return product
end
\end{minted}



\hypertarget{6047327473342163880}{}


\section{垃圾回收安全}



将数据传递给 \hyperlink{14245046751182637566}{\texttt{ccall}} 时，最好避免使用 \hyperlink{8901246211940014300}{\texttt{pointer}} 函数。 而是定义一个转换方法并将变量直接传递给 \hyperlink{14245046751182637566}{\texttt{ccall}}。 \hyperlink{14245046751182637566}{\texttt{ccall}} 自动安排它的所有参数都将从垃圾收集中保留，直到调用返回。 如果 C API 将存储对 Julia 分配的内存的引用，则在 \hyperlink{14245046751182637566}{\texttt{ccall}} 返回后，你必须确保该对象对垃圾收集器保持可见。 建议的方法是创建一个类型为 \texttt{Array\{Ref,1\}} 的全局变量来保存这些值，直到 C 库通知你它已完成使用它们。



每当你创建了一个指向 Julia 数据的指针时，你必须确保原始数据存在，直到你完成使用该指针。 Julia 中的许多方法，例如 \hyperlink{13744149973765810952}{\texttt{unsafe\_load}} 和 \hyperlink{2825695355940841177}{\texttt{String}} 复制数据而不是获取缓冲区的所有权，因此可以安全地释放（或更改）原始数而不影响 Julia。 一个值得注意的例外是 \hyperlink{2210267857349684744}{\texttt{unsafe\_wrap}}，出于性能原因，它共享（或可以被告知拥有）底层缓冲区。



垃圾收集器不保证任何终结顺序。 也就是说，如果 \texttt{a} 包含对 \texttt{b} 的引用，并且 \texttt{a} 和 \texttt{b} 都需要进行垃圾回收，则不能保证 \texttt{b} 会在 \texttt{a} 之后完成。 如果 \texttt{a} 的正确终结取决于 \texttt{b} 是否有效，则必须以其他方式处理。



\hypertarget{14397309909238125480}{}


\section{非常数函数规范}



在某些情况下，所需库的确切名称或路径是事先未知的，必须在运行时计算。 为了处理这种情况，\texttt{(name, library)} 规范的库组件可以是一个函数调用，例如 \texttt{(:dgemm\_, find\_blas())}。 调用表达式将在执行 \texttt{ccall} 本身时执行。 但是，假设库位置一旦确定就不会改变，因此调用的结果可以被缓存和重用。 因此，表达式执行的次数是未指定的，多次调用返回不同的值会导致未指定的行为。



如果需要更大的灵活性，可以通过 \hyperlink{7507639810592563424}{\texttt{eval}} 分段使用计算值作为函数名称，如下所示：




\begin{lstlisting}
@eval ccall(($(string("a", "b")), "lib"), ...
\end{lstlisting}



此表达式使用 \texttt{string} 构造一个名称，然后将此名称替换为一个新的 \hyperlink{14245046751182637566}{\texttt{ccall}} 表达式，然后对其进行评估。 请记住，\texttt{eval} 仅在顶层运行，因此在此表达式中局部变量将不可用（除非它们的值被替换为 \texttt{\$}）。 出于这个原因，\texttt{eval} 通常仅用于形成顶级定义，例如在包装包含许多类似函数的库时。 可以为 \hyperlink{11617107520401351255}{\texttt{@cfunction}} 构造一个类似的示例。



但是，这样做也会很慢并且会泄漏内存，因此你通常应该避免这种情况，而是继续阅读。 下一节讨论如何使用间接调用来有效地实现类似的效果。



\hypertarget{18148794268039727850}{}


\section{非直接调用}



\hyperlink{14245046751182637566}{\texttt{ccall}} 的第一个参数也可以是在运行时计算的表达式。 在这种情况下，表达式的计算结果必须为 \texttt{Ptr}，它将用作要调用的本地函数的地址。 当第一个 \hyperlink{14245046751182637566}{\texttt{ccall}} 参数包含对非常量（例如局部变量、函数参数或非常量全局变量）的引用时，会发生此行为。



例如，你可以通过 \texttt{dlsym} 查找函数，然后将其缓存在该会话的共享引用中。 例如：




\begin{minted}{julia}
macro dlsym(func, lib)
    z = Ref{Ptr{Cvoid}}(C_NULL)
    quote
        let zlocal = $z[]
            if zlocal == C_NULL
                zlocal = dlsym($(esc(lib))::Ptr{Cvoid}, $(esc(func)))::Ptr{Cvoid}
                $z[] = zlocal
            end
            zlocal
        end
    end
end

mylibvar = Libdl.dlopen("mylib")
ccall(@dlsym("myfunc", mylibvar), Cvoid, ())
\end{minted}



\hypertarget{1672217310774962173}{}


\section{cfunction 闭包}



\hyperlink{11617107520401351255}{\texttt{@cfunction}} 的第一个参数可以用 \texttt{\$} 标记，在这种情况下，返回值将改为结束参数的 \texttt{struct CFunction}。 你必须确保此返回对象保持活动状态，直到完成对它的所有使用。 当这个引用被删除和 atexit 时，cfunction 指针处的内容和代码将通过 \hyperlink{4805357059330171046}{\texttt{finalizer}} 删除。 这通常不是必需的，因为此功能在 C 中不存在，但对于处理不提供单独的闭包环境参数的设计不良的 API 很有用。




\begin{minted}{julia}
function qsort(a::Vector{T}, cmp) where T
    isbits(T) || throw(ArgumentError("this method can only qsort isbits arrays"))
    callback = @cfunction $cmp Cint (Ref{T}, Ref{T})
    # Here, `callback` isa Base.CFunction, which will be converted to Ptr{Cvoid}
    # (and protected against finalization) by the ccall
    ccall(:qsort, Cvoid, (Ptr{T}, Csize_t, Csize_t, Ptr{Cvoid}),
        a, length(a), Base.elsize(a), callback)
    # We could instead use:
    #    GC.@preserve callback begin
    #        use(Base.unsafe_convert(Ptr{Cvoid}, callback))
    #    end
    # if we needed to use it outside of a `ccall`
    return a
end
\end{minted}



\begin{quote}
\textbf{Note}

闭包 \hyperlink{11617107520401351255}{\texttt{@cfunction}} 依赖于 LLVM Trampolines，并非在所有平台（例如 ARM 和 PowerPC）上都可用。

\end{quote}


\hypertarget{10600174375111035081}{}


\section{关闭库}



关闭（卸载）库以便重新加载有时很有用。 例如，在开发与 Julia 一起使用的 C 代码时，可能需要编译、从 Julia 调用 C 代码，然后关闭库、进行编辑、重新编译并加载新的更改。 可以重新启动 Julia 或使用 \texttt{Libdl} 函数来显式管理库，例如：




\begin{minted}{julia}
lib = Libdl.dlopen("./my_lib.so") # 显式打开库
sym = Libdl.dlsym(lib, :my_fcn)   # 获得用于调用函数的符号
ccall(sym, ...) # 直接用指针 `sym` 而不是 (symbol, library) 元组，其余参数保持不变
Libdl.dlclose(lib) # 显式关闭库
\end{minted}



请注意，当将 \texttt{ccall} 与输入元组（例如，\texttt{ccall((:my\_fcn, {\textquotedbl}./my\_lib.so{\textquotedbl}), ...)}）一起使用时，库会隐式打开，并且可能不会显式关闭。



\hypertarget{14242265699396110950}{}


\section{调用规约}



\hyperlink{14245046751182637566}{\texttt{ccall}} 的第二个参数可以选择是调用约定说明符（直接在返回类型之前）。 没有任何说明符，使用平台默认的 C 调用约定。 其他支持的约定是：\texttt{stdcall}、\texttt{cdecl}、\texttt{fastcall} 和\texttt{thiscall}（64 位Windows 上无操作）。 例如（来自\texttt{base/libc.jl}）我们看到与上面相同的\texttt{gethostname}\hyperlink{14245046751182637566}{\texttt{ccall}}，但具有正确的Windows签名：




\begin{minted}{julia}
hn = Vector{UInt8}(undef, 256)
err = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))
\end{minted}



请参阅 \href{http://llvm.org/docs/LangRef.html\#calling-conventions}{LLVM Language Reference} 来获得更多信息。



还有一个额外的特殊调用约定 \hyperlink{12406828992589210838}{\texttt{llvmcall}}，它允许直接插入对 LLVM 内部函数的调用。 这在针对不常见的平台（例如 GPGPU）时特别有用。 例如，对于\href{http://llvm.org/docs/NVPTXUsage.html}{CUDA}，我们需要能够读取线程索引：




\begin{minted}{julia}
ccall("llvm.nvvm.read.ptx.sreg.tid.x", llvmcall, Int32, ())
\end{minted}



与任何 \texttt{ccall} 一样，参数签名必须完全正确。另外，请注意，与\texttt{Core.Intrinsics}开放的等效Julia函数不同，没有兼容层级可以确保内在函数有意义并在当前目标上工作。



\hypertarget{6755654760318927882}{}


\section{访问全局变量}



可以使用 \hyperlink{2746947069730856184}{\texttt{cglobal}} 函数按名称访问本地库导出的全局变量。 \hyperlink{2746947069730856184}{\texttt{cglobal}} 的参数与 \hyperlink{14245046751182637566}{\texttt{ccall}} 使用相同的符号规范，以及描述存储在变量中的值的类型：




\begin{minted}{jlcon}
julia> cglobal((:errno, :libc), Int32)
Ptr{Int32} @0x00007f418d0816b8
\end{minted}



结果是一个给出值地址的指针。 可以使用 \hyperlink{13744149973765810952}{\texttt{unsafe\_load}} 和 \hyperlink{4579672834750013041}{\texttt{unsafe\_store!}} 通过这个指针来操作该值。



\begin{quote}
\textbf{Note}

在名为“libc”的库中可能找不到此 \texttt{errno} 符号，因为这是系统编译器的实现细节。 通常标准库符号应该只通过名称访问，允许编译器填写正确的符号。 然而，这个例子中显示的 \texttt{errno} 符号在大多数编译器中都是特殊的，所以这里看到的值可能不是你所期望或想要的。 在任何支持多线程的系统上用 C 编译等效代码通常实际上会调用不同的函数（通过宏预处理器重载），并且可能给出与此处打印的遗留值不同的结果。

\end{quote}


\hypertarget{5779343654335654313}{}


\section{通过指针来访问数据}



以下方法被描述为“不安全”，因为错误的指针或类型声明会导致 Julia 突然终止。



给定一个 \texttt{Ptr\{T\}}，通常可以使用 \texttt{unsafe\_load(ptr, [index])} 将 \texttt{T} 类型的内容从引用的内存复制到 Julia 对象中。 index 参数是可选的（默认为 1），并遵循基于 1 的索引的 Julia 惯例。 此函数类似于 \hyperlink{13720608614876840481}{\texttt{getindex}} 和 \hyperlink{1309244355901386657}{\texttt{setindex!}} 的行为（例如\texttt{[]} 访问语法）。



返回值将是一个初始化为包含引用内存内容副本的新对象。 引用的内存可以安全地释放或释放。



如果 \texttt{T} 是 \texttt{Any}，则假定内存包含对 Julia 对象的引用（\texttt{jl\_value\_t*}），结果将是对该对象的引用，并且不会复制该对象。 在这种情况下，你必须小心确保对象始终对垃圾收集器可见（指针不计数，但新引用计数）以确保内存不会过早释放。 请注意，如果对象最初不是由 Julia 分配的，则新对象将永远不会被 Julia 的垃圾收集器终结。 如果 \texttt{Ptr} 本身实际上是一个 \texttt{jl\_value\_t*}，它可以通过 \hyperlink{10812596548944930674}{\texttt{unsafe\_pointer\_to\_objref(ptr)}} 转换回 Julia 对象引用。 （Julia 值 \texttt{v} 可以通过调用 \hyperlink{9366554937543398846}{\texttt{pointer\_from\_objref(v)}} 转换为 \texttt{jl\_value\_t*} 指针，如 \texttt{Ptr\{Cvoid\}}。）



可以使用 \hyperlink{4579672834750013041}{\texttt{unsafe\_store!(ptr, value, [index])}} 执行反向操作（将数据写入 \texttt{Ptr\{T\}}）。 目前，这仅支持原始类型或其他无指针（\texttt{isbits}）不可变结构类型。



任何引发错误的操作目前可能尚未实现，应作为错误发布，以便解决。



如果感兴趣的指针是纯数据数组（原始类型或不可变结构），则函数 \hyperlink{2210267857349684744}{\texttt{unsafe\_wrap(Array, ptr,dims, own = false)}} 可能更有用。 如果 Julia 应该“获得”底层缓冲区的所有权并在返回的 \texttt{Array} 对象最终确定时调用 \texttt{free(ptr)}，则最后一个参数应该为 true。 如果省略了 \texttt{own} 参数或为 false，则调用者必须确保缓冲区一直存在，直到所有访问完成。



Julia 中 \texttt{Ptr} 类型的算术（例如使用 \texttt{+}）与 C 的指针算术的行为不同。 将整数添加到 Julia 中的 \texttt{Ptr} 总是将指针移动一定数量的 \emph{bytes}，而不是元素。 这样，通过指针运算获得的地址值不依赖于指针的元素类型。



\hypertarget{11710684987427742051}{}


\section{线程安全}



一些 C 库从不同的线程执行它们的回调，并且由于 Julia 不是线程安全的，因此你需要采取一些额外的预防措施。 特别是，你需要设置一个两层系统：C 回调应该只 \emph{安排}（通过 Julia 的事件循环）执行“真实”回调。 为此，创建一个 \hyperlink{6110056827764884232}{\texttt{AsyncCondition}} 对象并在其上创建 \hyperlink{13761789780433862250}{\texttt{wait}}：




\begin{minted}{julia}
cond = Base.AsyncCondition()
wait(cond)
\end{minted}



传递给 C 的回调应该只通过 \hyperlink{14245046751182637566}{\texttt{ccall}} 将 \texttt{cond.handle} 作为参数传递给 \texttt{:uv\_async\_send} 并调用，注意避免任何内存分配操作或与 Julia 运行时的其他交互。



注意，事件可能会合并，因此对 \texttt{uv\_async\_send} 的多个调用可能会导致对该条件的单个唤醒通知。



\hypertarget{9551685449391366384}{}


\section{关于 Callbacks 的更多内容}



关于如何传递 callback 到 C 库的更多细节，请参考此\href{https://julialang.org/blog/2013/05/callback}{博客}。



\hypertarget{4039606750368114245}{}


\section{C++}



如需要直接易用的C++接口，即直接用Julia写封装代码，请参考 \href{https://github.com/Keno/Cxx.jl}{Cxx}。如需封装C++库的工具，即用C++写封装/胶水代码，请参考\href{https://github.com/JuliaInterop/CxxWrap.jl}{CxxWrap}。



\footnotetext[1]{Non-library function calls in both C and Julia can be inlined and thus may have even less overhead than calls to shared library functions. The point above is that the cost of actually doing foreign function call is about the same as doing a call in either native language.

}


\footnotetext[2]{The \href{https://github.com/ihnorton/Clang.jl}{Clang package} can be used to auto-generate Julia code from a C header file.

}


\hypertarget{4348488381006315694}{}


\chapter{处理操作系统差异}



当编写跨平台的应用或库时，通常需要考虑到操作系统之间的差异。变量 \texttt{Sys.KERNEL} 可以用于这些场合。在 \texttt{Sys} 模块中有一些函数将会使这些事情更加简单：\texttt{isunix}、 \texttt{islinux}、\texttt{isapple}、\texttt{isbsd}、\texttt{isfreebsd} 以及 \texttt{iswindows}。这些函数可以按如下方式使用：




\begin{minted}{julia}
if Sys.iswindows()
    windows_specific_thing(a)
end
\end{minted}



注意，\texttt{islinux}、\texttt{isapple} 和 \texttt{isfreebsd} 是 \texttt{isunix} 完全互斥的子集。另外，有一个宏 \texttt{@static} 可以使用这些函数有条件地隐藏无效代码，如以下示例所示。



简单例子：




\begin{lstlisting}
ccall((@static Sys.iswindows() ? :_fopen : :fopen), ...)
\end{lstlisting}



复杂例子：




\begin{minted}{julia}
@static if Sys.islinux()
    linux_specific_thing(a)
else
    generic_thing(a)
end
\end{minted}



在链式嵌套的条件表达式中（包括 \texttt{if}/\texttt{elseif}/\texttt{end}），\texttt{@static} 必须在每一层都调用（括号是可选的，但是为了可读性，建议添加）。




\begin{minted}{julia}
@static Sys.iswindows() ? :a : (@static Sys.isapple() ? :b : :c)
\end{minted}



\hypertarget{4919662572867023119}{}


\chapter{环境变量}



Julia 可以配置许多环境变量，一种常见的方式是直接配置操作系统环境变量，另一种更便携的方式是在 Julia 中配置。假设你要将环境变量 \texttt{JULIA\_EDITOR} 设置为 \texttt{vim}，可以直接在 REPL 中输入 \texttt{ENV[{\textquotedbl}JULIA\_EDITOR{\textquotedbl}] = {\textquotedbl}vim{\textquotedbl}}（请根据具体情况对此进行修改），也可以将其添加到用户主目录中的配置文件 \texttt{{\textasciitilde}/.julia/config/startup.jl}，这样做会使其永久生效。环境变量的当前值是通过执行 \texttt{ENV[{\textquotedbl}JULIA\_EDITOR{\textquotedbl}]} 来确定的。



Julia 使用的环境变量通常以 \texttt{JULIA} 开头。如果调用 \hyperlink{11698106121547091928}{\texttt{InteractiveUtils.versioninfo}} 时使用关键字参数 \texttt{verbose = true}，那么输出结果将列出与 Julia 相关的已定义环境变量，即包括那些名称中包含 \texttt{JULIA} 的环境变量。



\begin{quote}
\textbf{Note}

某些变量需要在 Julia 启动之前设置，比如 \texttt{JULIA\_NUM\_THREADS} 和 \texttt{JULIA\_PROJECT}，因为在启动过程中将这些变量添加到 \texttt{{\textasciitilde}/.julia/config/startup.jl} 中为时已晚。在 Bash 中，环境变量可以手动设置，这可通过在 Julia 启动前运行诸如 \texttt{export JULIA\_NUM\_THREADS=4} 的命令，亦可通过向 \texttt{{\textasciitilde}/.bashrc} 或 \texttt{{\textasciitilde}/.bash\_profile} 添加相同命令来在 Bash 每次启动时设置该变量。

\end{quote}


\hypertarget{10129404461588265763}{}


\section{文件位置}



\hypertarget{11878722049876551255}{}


\subsection{\texttt{JULIA\_BINDIR}}



包含 Julia 可执行文件的目录的绝对路径，它会设置全局变量 \hyperlink{11034333937761980027}{\texttt{Sys.BINDIR}}。\texttt{\$JULIA\_BINDIR} 如果没有设置，那么 Julia 会在运行时确定 \texttt{Sys.BINDIR} 的值。



在默认情况下，可执行文件是指：




\begin{lstlisting}
$JULIA_BINDIR/julia
$JULIA_BINDIR/julia-debug
\end{lstlisting}



全局变量 \texttt{Base.DATAROOTDIR} 是一个从 \texttt{Sys.BINDIR} 到 Julia 数据目录的相对路径。




\begin{lstlisting}
$JULIA_BINDIR/$DATAROOTDIR/julia/base
\end{lstlisting}



上述路径是 Julia 最初搜索源文件的路径（通过 \texttt{Base.find\_source\_file()}）。



同样，全局变量 \texttt{Base.SYSCONFDIR} 是一个到配置文件目录的相对路径。在默认情况下，Julia 会在下列文件中搜索 \texttt{startup.jl} 文件（通过 \texttt{Base.load\_julia\_startup()}）




\begin{lstlisting}
$JULIA_BINDIR/$SYSCONFDIR/julia/startup.jl
$JULIA_BINDIR/../etc/julia/startup.jl
\end{lstlisting}



例如，在 Linux 下安装的 Julia 可执行文件位于 \texttt{/bin/julia}，\texttt{DATAROOTDIR} 为 \texttt{../share}，\texttt{SYSCONFDIR} 为 \texttt{../etc}，\texttt{JULIA\_BINDIR} 会被设置为 \texttt{/bin}，会有一个源文件搜索路径：




\begin{lstlisting}
/share/julia/base
\end{lstlisting}



和一个全局配置文件搜索路径：




\begin{lstlisting}
/etc/julia/startup.jl
\end{lstlisting}



\hypertarget{4954349069727209817}{}


\subsection{\texttt{JULIA\_PROJECT}}



指示哪个项目应该是初始活动项目的目录路径。 设置这个环境变量和指定\texttt{--project}启动选项效果一样，但是\texttt{--project}优先级更高。 如果变量设置为 \texttt{@.}，那么 Julia 会尝试从当前目录及其父目录中查找包含 \texttt{Project.toml} 或 \texttt{JuliaProject.toml} 文件的项目目录。 另请参阅有关 \hyperlink{11949095373261797528}{代码加载} 的章节。



\begin{quote}
\textbf{Note}

\texttt{JULIA\_PROJECT} 必须在启动 julia 前定义；于 \texttt{startup.jl} 中定义它对于启动的过程为时已晚。

\end{quote}


\hypertarget{1363234541366705734}{}


\subsection{\texttt{JULIA\_LOAD\_PATH}}



\texttt{JULIA\_LOAD\_PATH} 环境变量用于补充全局的 Julia 变量 \hyperlink{17914149694871263675}{\texttt{LOAD\_PATH}} ，该变量可用于确定通过 \texttt{import} 和 \texttt{using} 可以加载哪些包（请参阅 \hyperlink{11949095373261797528}{Code Loading}）。



与 shell 使用的 \texttt{PATH} 变量不同， 在 \texttt{JULIA\_LOAD\_PATH} 中的空条目将会在填充 \texttt{LOAD\_PATH} 时被扩展为 \texttt{LOAD\_PATH} 的默认值 \texttt{[{\textquotedbl}@{\textquotedbl}, {\textquotedbl}@v\#.\#{\textquotedbl}, {\textquotedbl}@stdlib{\textquotedbl}]} 。这样，无论 \texttt{JULIA\_LOAD\_PATH} 是否已被设置，均可以使用 shell 脚本轻松地在加载路径前面或后面添加值。例如要将 \texttt{/foo/bar} 添加到 \texttt{LOAD\_PATH} 之前，只需要使用下列脚本：




\begin{lstlisting}
export JULIA_LOAD_PATH="/foo/bar:$JULIA_LOAD_PATH"
\end{lstlisting}



如果已经设置了 \texttt{JULIA\_LOAD\_PATH} 环境变量，那么 \texttt{/foo/bar} 将被添加在原有值之前。另一方面，如果 \texttt{JULIA\_LOAD\_PATH} 尚未设置，那么它会被设置为 \texttt{/foo/bar:} ，而这将使用 \texttt{LOAD\_PATH} 的值扩展为 \texttt{[{\textquotedbl}/foo/bar{\textquotedbl}, {\textquotedbl}@{\textquotedbl}, {\textquotedbl}@v\#.\#{\textquotedbl}, {\textquotedbl}@stdlib{\textquotedbl}]} 。如果 \texttt{JULIA\_LOAD\_PATH} 被设置为空字符串，那么它将被扩展为一个空的 \texttt{LOAD\_PATH} 数组。换句话说，这个空字符串数组将被认为是零元素的数组，而非是一个空字符串单元素的数组。使用这样的加载行为是为了可以通过环境变量设置空的加载路径。如果你需要使用默认的加载路径，请不要设置这一环境变量，如果它必须有值，那么可将其设置为字符串 \texttt{:} 。



\begin{quote}
\textbf{Note}

在 Windows 上，路径元素由 \texttt{;} 字符分隔，就像 Windows 上的大多数路径列表一样。 将上一段中的 \texttt{:} 替换为 \texttt{;}。

\end{quote}


\hypertarget{7415777056556214668}{}


\subsection{\texttt{JULIA\_DEPOT\_PATH}}



\texttt{JULIA\_DEPOT\_PATH} 环境变量用于填充全局的 Julia 变量 \hyperlink{15271486679944781836}{\texttt{DEPOT\_PATH}} ，该变量用于控制包管理器以及 Juila 代码加载机制在何处查找包注册表、已安装的包、命名环境、克隆的存储库、缓存的预编译包映像、配置文件和 REPL 历史记录文件的默认位置。



与 shell 使用的 \texttt{PATH} 变量不同，但与 \texttt{JULIA\_LOAD\_PATH} 类似， 在 \texttt{JULIA\_DEPOT\_PATH} 中的空条目将会被扩展为 \texttt{DEPOT\_PATH} 的默认值。这样，无论 \texttt{JULIA\_DEPOT\_PATH} 是否已被设置，均可以使用 shell 脚本轻松地在仓库路径前面或后面添加值。例如要将 \texttt{/foo/bar} 添加到 \texttt{DEPOT\_PATH} 之前，只需要使用下列脚本：




\begin{lstlisting}
export JULIA_DEPOT_PATH="/foo/bar:$JULIA_DEPOT_PATH"
\end{lstlisting}



如果已经设置了 \texttt{JULIA\_DEPOT\_PATH} 环境变量，那么 \texttt{/foo/bar} 将被添加在原有值之前。另一方面，如果 \texttt{JULIA\_DEPOT\_PATH} 尚未设置，那么它会被设置为 \texttt{/foo/bar:} ，而这将使 \texttt{/foo/bar} 被添加到默认仓库路径之前。如果 \texttt{JULIA\_DEPOT\_PATH} 被设置为空字符串，那么它将扩展为一个空的 \texttt{DEPOT\_PATH} 数组。换句话说，这个空字符串数组将被认为是零元素的数组，而非是一个空字符串单元素的数组。使用这样的加载行为是为了可以通过环境变量设置空的仓库路径。如果你需要使用默认的仓库路径，请不要设置这一环境变量，如果它必须有值，那么可将其设置为字符串 \texttt{:} 。



\begin{quote}
\textbf{Note}

在 Windows 上，路径元素由 \texttt{;} 字符分隔，就像 Windows 上的大多数路径列表一样。 将上一段中的 \texttt{:} 替换为 \texttt{;}。

\end{quote}


\hypertarget{7464422147684280847}{}


\subsection{\texttt{JULIA\_HISTORY}}



REPL 历史文件中 \texttt{REPL.find\_hist\_file()} 的绝对路径。如果没有设置 \texttt{\$JULIA\_HISTORY}，那么 \texttt{REPL.find\_hist\_file()} 默认为




\begin{lstlisting}
$(DEPOT_PATH[1])/logs/repl_history.jl
\end{lstlisting}



\hypertarget{8533599099446257685}{}


\subsection{\texttt{JULIA\_PKG\_SERVER}}



由\texttt{Pkg.jl} 使用，用于下载软件包和更新注册表。默认情况下，\texttt{Pkg} 使用 \texttt{https://pkg.julialang.org} 来获取 Julia 包。你可以使用此环境变量来选择不同的服务器。 此外，你可以禁用 PkgServer 协议的使用，并通过设置直接从它们的主机（GitHub、GitLab 等）访问包：




\begin{lstlisting}
export JULIA_PKG_SERVER=""
\end{lstlisting}



\hypertarget{3466341700032254278}{}


\section{外部应用}



\hypertarget{12177211249965413749}{}


\subsection{\texttt{JULIA\_SHELL}}



Julia 用来执行外部命令的 shell 的绝对路径（通过 \texttt{Base.repl\_cmd()}）。默认为环境变量 \texttt{\$SHELL}，如果 \texttt{\$SHELL} 未设置，则为 \texttt{/bin/sh}。



\begin{quote}
\textbf{Note}

在 Windows 上，此环境变量将被忽略，并且外部命令会直接被执行。

\end{quote}


\hypertarget{327473439132778011}{}


\subsection{\texttt{JULIA\_EDITOR}}



\texttt{InteractiveUtils.editor()} 的返回值–编辑器，例如，\hyperlink{7452583831414689960}{\texttt{InteractiveUtils.edit}}，会启动偏好编辑器，比如 \texttt{vim}。



\texttt{\$JULIA\_EDITOR} 优先于 \texttt{\$VISUAL}，而后者优先于 \texttt{\$EDITOR}。如果这些环境变量都没有设置，那么在 Windows 和 OS X 上会设置为 \texttt{open}，或者 \texttt{/etc/alternatives/editor}（如果存在的话），否则为 \texttt{emacs}。



\hypertarget{5963067566394654848}{}


\section{并行}



\hypertarget{9501730119086472793}{}


\subsection{\texttt{JULIA\_CPU\_THREADS}}



改写全局变量 \hyperlink{5072616208401232599}{\texttt{Base.Sys.CPU\_THREADS}}，逻辑 CPU 核心数。



\hypertarget{17625390316676574932}{}


\subsection{\texttt{JULIA\_WORKER\_TIMEOUT}}



一个 \hyperlink{5027751419500983000}{\texttt{Float64}} 值，用来确定 \texttt{Distributed.worker\_timeout()} 的值（默认：\texttt{60.0}）。此函数提供 worker 进程在死亡之前等待 master 进程建立连接的秒数。



\hypertarget{7328254851646027731}{}


\subsection{\texttt{JULIA\_NUM\_THREADS}}



一个无符号 64 位整数 (\texttt{uint64\_t})，用于设置 Julia 可用的最大线程数。 如果\texttt{\$JULIA\_NUM\_THREADS} 不为正数或未设置，或者无法通过系统调用确定CPU 线程数，则将线程数设置为\texttt{1}。



如果\texttt{\$JULIA\_NUM\_THREADS} 设置为\texttt{auto}，则线程数将设置为CPU线程数。



\begin{quote}
\textbf{Note}

\texttt{JULIA\_NUM\_THREADS} 必须在启动 julia 之前定义； 启动过程中在\texttt{startup.jl} 中定义它是不能奏效的。

\end{quote}


\begin{quote}
\textbf{Julia 1.5}

在 Julia 1.5 和更高版本中，也可在启动时使用 \texttt{-t}/\texttt{--threads} 命令行参数指定线程数。

\end{quote}


\begin{quote}
\textbf{Julia 1.7}

\texttt{\$JULIA\_NUM\_THREADS} 的 \texttt{auto} 值需要 Julia 1.7 或更高版本。

\end{quote}


\hypertarget{10532418503410947704}{}


\subsection{\texttt{JULIA\_THREAD\_SLEEP\_THRESHOLD}}



如果被设置为字符串，并且以大小写敏感的子字符串 \texttt{{\textquotedbl}infinite{\textquotedbl}} 开头，那么自旋线程从不睡眠。否则，\texttt{\$JULIA\_THREAD\_SLEEP\_THRESHOLD} 被解释为一个无符号 64 位整数（\texttt{uint64\_t}），并且提供以纳秒为单位的自旋线程睡眠的时间量。



\hypertarget{12794875033848178110}{}


\subsection{\texttt{JULIA\_EXCLUSIVE}}



如果设置为 \texttt{0} 以外的任何值，那么 Julia 的线程策略与在专用计算机上一致：主线程在 proc 0 上且线程间是关联的。否则，Julia 让操作系统处理线程策略。



\hypertarget{16378430867132816632}{}


\section{REPL 格式化输出}



决定 REPL 应当如何格式化输出的环境变量。通常，这些变量应当被设置为 \href{http://ascii-table.com/ansi-escape-sequences.php}{ANSI 终端转义序列}。Julia 提供了具有相同功能的高级接口；请参阅 \hyperlink{10670790884919535588}{Julia REPL} 章节。



\hypertarget{13891100922495428417}{}


\subsection{\texttt{JULIA\_ERROR\_COLOR}}



\texttt{Base.error\_color()}（默认值：亮红，\texttt{{\textquotedbl}{\textbackslash}033[91m{\textquotedbl}}），errors 在终端中的格式。



\hypertarget{17711733982596187514}{}


\subsection{\texttt{JULIA\_WARN\_COLOR}}



\texttt{Base.warn\_color()}（默认值：黄，\texttt{{\textquotedbl}{\textbackslash}033[93m{\textquotedbl}}），warnings 在终端中的格式。



\hypertarget{10994657891761481518}{}


\subsection{\texttt{JULIA\_INFO\_COLOR}}



\texttt{Base.info\_color()}（默认值：青，\texttt{{\textquotedbl}{\textbackslash}033[36m{\textquotedbl}}），info 在终端中的格式。



\hypertarget{7277467062996316804}{}


\subsection{\texttt{JULIA\_INPUT\_COLOR}}



\texttt{Base.input\_color()}（默认值：标准，\texttt{{\textquotedbl}{\textbackslash}033[0m{\textquotedbl}}），在终端中，输入应有的格式。



\hypertarget{11974933399373427924}{}


\subsection{\texttt{JULIA\_ANSWER\_COLOR}}



\texttt{Base.answer\_color()}（默认值：标准，\texttt{{\textquotedbl}{\textbackslash}033[0m{\textquotedbl}}），在终端中，输出应有的格式。



\hypertarget{14262570954781492291}{}


\section{调试和性能分析}



\hypertarget{8362221794188602098}{}


\subsection{\texttt{JULIA\_DEBUG}}



为文件或模块启动调试日志记录，请参阅 \href{@ref Logging}{日志} 了解更多信息。



\hypertarget{17935900017233878037}{}


\subsection{\texttt{JULIA\_GC\_ALLOC\_POOL}, \texttt{JULIA\_GC\_ALLOC\_OTHER}, \texttt{JULIA\_GC\_ALLOC\_PRINT}}



这些环境变量取值为字符串，可以以字符 \texttt{‘r’} 开头，后接一个由三个带符号 64 位整数（\texttt{int64\_t}）组成的、以冒号分割的列表的插值字符串。这个整数的三元组 \texttt{a:b:c} 代表算术序列 \texttt{a}, \texttt{a + b}, \texttt{a + 2*b}, ... \texttt{c}。



\begin{itemize}
\item 如果是第 \texttt{n} 次调用 \texttt{jl\_gc\_pool\_alloc()}，并且 \texttt{n}   属于 \texttt{\$JULIA\_GC\_ALLOC\_POOL} 代表的算术序列，   那么垃圾回收是强制的。


\item 如果是第 \texttt{n} 次调用 \texttt{maybe\_collect()}，并且 \texttt{n} 属于   \texttt{\$JULIA\_GC\_ALLOC\_OTHER} 代表的算术序列，那么垃圾   回收是强制的。


\item 如果是第 \texttt{n} 次调用 \texttt{jl\_gc\_alloc()}，并且 \texttt{n} 属于   \texttt{\$JULIA\_GC\_ALLOC\_PRINT} 代表的算术序列，那么   调用 \texttt{jl\_gc\_pool\_alloc()} 和 \texttt{maybe\_collect()} 的次数会   被打印。

\end{itemize}


如果这些环境变量的值以字符 \texttt{‘r{\textquotesingle}} 开头，那么垃圾回收事件间的间隔是随机的。



\begin{quote}
\textbf{Note}

这些环境变量生效要求 Julia 在编译时带有垃圾收集调试支持（也就是，在构建配置中将 \texttt{WITH\_GC\_DEBUG\_ENV} 设置为 \texttt{1}）。

\end{quote}


\hypertarget{15291982466110123243}{}


\subsection{\texttt{JULIA\_GC\_NO\_GENERATIONAL}}



如果设置为 \texttt{0} 以外的任何值，那么 Julia 的垃圾收集器将从不执行「快速扫描」内存。



\begin{quote}
\textbf{Note}

此环境变量生效要求 Julia 在编译时带有垃圾收集调试支持（也就是，在构建配置中将 \texttt{WITH\_GC\_DEBUG\_ENV} 设置为 \texttt{1}）。

\end{quote}


\hypertarget{4439082668862420182}{}


\subsection{\texttt{JULIA\_GC\_WAIT\_FOR\_DEBUGGER}}



如果设置为 \texttt{0} 以外的任何值，Julia 的垃圾收集器每当出现严重错误时将等待调试器连接而不是中止。



\begin{quote}
\textbf{Note}

此环境变量生效要求 Julia 在编译时带有垃圾收集调试支持（也就是，在构建配置中将 \texttt{WITH\_GC\_DEBUG\_ENV} 设置为 \texttt{1}）。

\end{quote}


\hypertarget{1100661411174026998}{}


\subsection{\texttt{ENABLE\_JITPROFILING}}



如果设置为 \texttt{0} 以外的任何值，那么编译器将为即时（JIT）性能分析创建并注册一个事件监听器。



\begin{quote}
\textbf{Note}

此环境变量仅在使用 JIT 性能分析支持编译 Julia 时有效，使用如下之一：

\begin{itemize}
\item Intel{\textquotesingle}s \href{https://software.intel.com/en-us/vtune}{VTune™ Amplifier}(\texttt{USE\_INTEL\_JITEVENTS} 在配置中设置为\texttt{1}), 或


\item \href{http://oprofile.sourceforge.net/news/}{OProfile}(\texttt{USE\_OPROFILE\_JITEVENTS} 在配置中设置为\texttt{1})。


\item \href{https://perf.wiki.kernel.org}{Perf} (\texttt{USE\_PERF\_JITEVENTS} 在构建配置中设置为 \texttt{1})。 默认情况下启用此集成。

\end{itemize}
\end{quote}


\hypertarget{1655388421400272774}{}


\subsection{\texttt{ENABLE\_GDBLISTENER}}



如果设置为除\texttt{0}之外的任何内容，则在发布版本上启用 Julia 代码的 GDB 注册。 在 Julia 的调试版本中，这始终处于启用状态。 推荐与 \texttt{-g 2} 一起使用。



\hypertarget{12744946110825549407}{}


\subsection{\texttt{JULIA\_LLVM\_ARGS}}



传递给 LLVM 后端的参数。



\hypertarget{12804520762715277004}{}


\chapter{嵌入 Julia}



正如我们在 \href{@ref}{调用 C 和 Fortran 代码} 中看到的, Julia 有着简单高效的方法来调用 C 编写的函数。但有时恰恰相反，我们需要在 C 中调用 Julia 的函数。这可以将 Julia 代码集成到一个更大的 C/C++ 项目而无需在 C/C++ 中重写所有内容。Julia 有一个 C API 来实现这一目标。几乎所有编程语言都能以某种方式来调用 C 语言的函数，因此 Julia 的 C API 也就能够进行更多语言的桥接。(例如在 Python 或是 C\# 中调用 Julia ).



\hypertarget{10185907435024062430}{}


\section{高级别嵌入}



\textbf{Note}: 本节包含可运行在类 Unix 系统上的、使用 C 编写的嵌入式 Julia 代码。Windows 平台请参阅下一节。



我们从一个简单的 C 程序开始初始化 Julia 并调用一些 Julia 代码：




\begin{lstlisting}
#include <julia.h>
JULIA_DEFINE_FAST_TLS // only define this once, in an executable (not in a shared library) if you want fast code.

int main(int argc, char *argv[])
{
    /* required: setup the Julia context */
    jl_init();

    /* run Julia commands */
    jl_eval_string("print(sqrt(2.0))");

    /* strongly recommended: notify Julia that the
         program is about to terminate. this allows
         Julia time to cleanup pending write requests
         and run all finalizers
    */
    jl_atexit_hook(0);
    return 0;
}
\end{lstlisting}



为构建这个程序，你必须将 Julia 头文件的路径放入 include 路径并链接 \texttt{libjulia} 。例如 Julia 被安装到 \texttt{\$JULIA\_DIR}，则可以用 \texttt{gcc} 来编译上面的测试程序 \texttt{test.c}：




\begin{lstlisting}
gcc -o test -fPIC -I$JULIA_DIR/include/julia -L$JULIA_DIR/lib -Wl,-rpath,$JULIA_DIR/lib test.c -ljulia
\end{lstlisting}



或者，查看 \texttt{test/embedding/} 文件夹中 Julia 源代码树中的 \texttt{embedding.c} 程序。 文件 \texttt{cli/loader\_exe.c} 程序是另一个简单的例子，说明如何在链接 \texttt{libjulia} 时设置 \texttt{jl\_options} 选项。



在调用任何其他 Julia C 函数之前第一件必须要做的事是初始化 Julia，通过调用 \texttt{jl\_init} 尝试自动确定 Julia 的安装位置来实现。如果需要自定义位置或指定要加载的系统映像，请改用 \texttt{jl\_init\_with\_image}。



测试程序中的第二个语句通过调用 \texttt{jl\_eval\_string} 来执行 Julia 语句。



在程序结束之前，强烈建议调用 \texttt{jl\_atexit\_hook}。上面的示例程序在 \texttt{main} 返回之前进行了调用。



\begin{quote}
\textbf{Note}

现在，动态链接 \texttt{libjulia} 的共享库需要传递选项 \texttt{RTLD\_GLOBAL} 。比如在 Python 中像这样调用：


\begin{lstlisting}
>>> julia=CDLL('./libjulia.dylib',RTLD_GLOBAL)
>>> julia.jl_init.argtypes = []
>>> julia.jl_init()
250593296
\end{lstlisting}

\end{quote}


\begin{quote}
\textbf{Note}

如果 Julia 程序需要访问 主可执行文件 中的符号，那么除了下面描述的由 \texttt{julia-config.jl} 生成的标记之外，可能还需要在 Linux 上的编译时添加 \texttt{-Wl,--export-dynamic} 链接器标志。编译共享库时则不必要。

\end{quote}


\hypertarget{122745226345289239}{}


\subsection{使用 julia-config 自动确定构建参数}



\texttt{julia-config.jl} 创建脚本是为了帮助确定使用嵌入的 Julia 程序所需的构建参数。此脚本使用由其调用的特定 Julia 分发的构建参数和系统配置来导出嵌入程序的必要编译器标志以与该分发交互。此脚本位于 Julia 的 share 目录中。



\hypertarget{18305016561534437319}{}


\subsubsection{例子}




\begin{lstlisting}
#include <julia.h>

int main(int argc, char *argv[])
{
    jl_init();
    (void)jl_eval_string("println(sqrt(2.0))");
    jl_atexit_hook(0);
    return 0;
}
\end{lstlisting}



\hypertarget{15399362667106734470}{}


\subsubsection{在命令行中}



命令行脚本简单用法：假设 \texttt{julia-config.jl} 位于 \texttt{/usr/local/julia/share/julia}，它可以直接在命令行上调用，并采用 3 个标志的任意组合：




\begin{lstlisting}
/usr/local/julia/share/julia/julia-config.jl
Usage: julia-config [--cflags|--ldflags|--ldlibs]
\end{lstlisting}



如果上面的示例源代码保存为文件 \texttt{embed\_example.c}，则以下命令将其编译为 Linux 和 Windows 上运行的程序（MSYS2 环境），或者如果在 OS/X 上，则用 \texttt{clang} 替换 \texttt{gcc}。：




\begin{lstlisting}
/usr/local/julia/share/julia/julia-config.jl --cflags --ldflags --ldlibs | xargs gcc embed_example.c
\end{lstlisting}



\hypertarget{9935040774481087943}{}


\subsubsection{在 Makefiles 中使用}



但通常来说，嵌入的项目会比上面更复杂，因此一般会提供 makefile 支持。由于使用了 \textbf{shell} 宏扩展，我们就假设用 GNU make 。 另外，尽管很多时候 \texttt{julia-config.jl} 会在目录 \texttt{/usr/local} 中出现多次，不过也未必如此，但 Julia 也定位 \texttt{julia-config.jl}，并且可以使用 makefile 来利用它。上面的示例程序使用 Makefile 来扩展。：




\begin{lstlisting}
JL_SHARE = $(shell julia -e 'print(joinpath(Sys.BINDIR, Base.DATAROOTDIR, "julia"))')
CFLAGS += $(shell $(JL_SHARE)/julia-config.jl --cflags)
CXXFLAGS += $(shell $(JL_SHARE)/julia-config.jl --cflags)
LDFLAGS += $(shell $(JL_SHARE)/julia-config.jl --ldflags)
LDLIBS += $(shell $(JL_SHARE)/julia-config.jl --ldlibs)

all: embed_example
\end{lstlisting}



现在构建的命令就只需要简简单单的\texttt{make}了。



\hypertarget{9091699375369199363}{}


\section{在 Windows 使用 Visual Studio 进行高级别嵌入}



如果尚未设置\texttt{JULIA\_DIR}环境变量，请在启动 Visual Studio 之前使用系统面板添加它。JULIA\_DIR 下的\texttt{bin} 文件夹应该在系统路径上。



我们首先打开 Visual Studio 并创建一个新的控制台应用程序项目。 在\texttt{stdafx.h}头文件的末尾添加以下几行：




\begin{lstlisting}
#include <julia.h>
\end{lstlisting}



然后，将项目中的 main() 函数替换为以下代码：




\begin{lstlisting}
int main(int argc, char *argv[])
{
    /* required: setup the Julia context */
    jl_init();

    /* run Julia commands */
    jl_eval_string("print(sqrt(2.0))");

    /* strongly recommended: notify Julia that the
         program is about to terminate. this allows
         Julia time to cleanup pending write requests
         and run all finalizers
    */
    jl_atexit_hook(0);
    return 0;
}
\end{lstlisting}



下一步是设置项目以查找 Julia 包含的文件和库。 了解 Julia 安装的是 32 位还是 64 位非常重要。 在继续之前删除与 Julia 安装不对应的任何平台配置。



使用项目属性对话框，转到\texttt{C/C++} | \texttt{General} 并将 \texttt{\$(JULIA\_DIR){\textbackslash}include{\textbackslash}julia{\textbackslash}} 添加到 Additional Include Directories 属性。 然后，转到\texttt{Linker} | \texttt{General} 部分并将 \texttt{\$(JULIA\_DIR){\textbackslash}lib} 添加到 Additional Library Directories 属性。最后，在\texttt{Linker}| \texttt{Input}下，将\texttt{libjulia.dll.a;libopenlibm.dll.a;}添加到库列表中。



到这里，该项目应该成功构建和运行。



\hypertarget{4573294506139022977}{}


\section{转换类型}



真正的应用程序不仅仅要执行表达式，还要返回表达式的值给宿主程序。\texttt{jl\_eval\_string} 返回 一个 \texttt{jl\_value\_t*}，它是指向堆分配的 Julia 对象的指针。存储像 \hyperlink{5027751419500983000}{\texttt{Float64}} 这些简单数据类型叫做 \texttt{装箱}，然后提取存储的基础类型数据叫 \texttt{拆箱}。我们改进的示例程序在 Julia 中计算 2 的平方根，并在 C 中读取回结果，如下所示：




\begin{lstlisting}
jl_value_t *ret = jl_eval_string("sqrt(2.0)");

if (jl_typeis(ret, jl_float64_type)) {
    double ret_unboxed = jl_unbox_float64(ret);
    printf("sqrt(2.0) in C: %e \n", ret_unboxed);
}
else {
    printf("ERROR: unexpected return type from sqrt(::Float64)\n");
}
\end{lstlisting}



为了检查 \texttt{ret} 是否为特定的 Julia 类型，我们可以使用 \texttt{jl\_isa}，\texttt{jl\_typeis} 或 \texttt{jl\_is\_...} 函数。通过输入 \texttt{typeof(sqrt(2.0))}到 Julia shell，我们可以看到返回类型是 \hyperlink{5027751419500983000}{\texttt{Float64}}（在C中是 \texttt{double} 类型）。要将装箱的 Julia 值转换为 C 的double，上面的代码片段使用了 \texttt{jl\_unbox\_float64}函数。



相应的, 用 \texttt{jl\_box\_...} 函数是另一种转换的方式。




\begin{lstlisting}
jl_value_t *a = jl_box_float64(3.0);
jl_value_t *b = jl_box_float32(3.0f);
jl_value_t *c = jl_box_int32(3);
\end{lstlisting}



正如我们将在下面看到的那样，装箱需要在调用 Julia 函数时使用特定参数。



\hypertarget{15001488547709567560}{}


\section{调用 Julia 函数}



虽然 \texttt{jl\_eval\_string} 允许 C 获取 Julia 表达式的结果，但它不允许将在 C 中计算的参数传递给 Julia。因此需要使用 \texttt{jl\_call} 来直接调用Julia函数：




\begin{lstlisting}
jl_function_t *func = jl_get_function(jl_base_module, "sqrt");
jl_value_t *argument = jl_box_float64(2.0);
jl_value_t *ret = jl_call1(func, argument);
\end{lstlisting}



在第一步中，通过调用 \texttt{jl\_get\_function} 检索出 Julia 函数 \texttt{sqrt} 的句柄(handle)。 传递给 \texttt{jl\_get\_function} 的第一个参数是 指向 定义\texttt{sqrt}所在的 \texttt{Base} 模块 的指针。 然后，double 值通过 \texttt{jl\_box\_float64} 被装箱。 最后，使用 \texttt{jl\_call1} 调用该函数。也有 \texttt{jl\_call0}，\texttt{jl\_call2}和\texttt{jl\_call3} 函数，方便地处理不同数量的参数。 要传递更多参数，使用 \texttt{jl\_call}：




\begin{lstlisting}
jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs)
\end{lstlisting}



它的第二个参数 \texttt{args} 是 \texttt{jl\_value\_t*} 类型的数组，\texttt{nargs} 是参数的个数



\hypertarget{3779983102705119396}{}


\section{内存管理}



正如我们所见，Julia 对象在 C 中表示为指针。这就出现了 谁来负责释放这些对象的问题。



通常，Julia 对象由垃圾收集器（GC）释放，但 GC 不会自动就懂我们正C中保留对Julia值的引用。这意味着 GC 会在你的掌控之外释放对象，从而使指针无效。



GC 只能在分配 Julia 对象时运行。 像 \texttt{jl\_box\_float64} 这样的调用执行分配，分配可能发生在运行 Julia 代码的任何时候。 然而，在 \texttt{jl\_...} 调用之间使用指针通常是安全的。 但是为了确保值可以在 \texttt{jl\_...} 调用后留存下来，我们必须告诉 Julia 我们仍然持有对 Julia \href{https://www.cs.purdue.edu/homes/hosking/690M/p611-fenichel.pdf}{root} 的引用，这个过程称为“GC rooting”。把一个值”扎根“将确保垃圾收集器不会意外地将此值识别为未使用并释放该值的内存。 这可以使用 \texttt{JL\_GC\_PUSH} 宏来完成：




\begin{lstlisting}
jl_value_t *ret = jl_eval_string("sqrt(2.0)");
JL_GC_PUSH1(&ret);
// Do something with ret
JL_GC_POP();
\end{lstlisting}



\texttt{JL\_GC\_POP} 调用会释放之前的 \texttt{JL\_GC\_PUSH} 建立的引用。 请注意，\texttt{JL\_GC\_PUSH} 将引用存储在 C 堆栈上，因此在退出作用域之前，它必须与一个 \texttt{JL\_GC\_POP} 精确配对。 也就是说，在函数返回之前，或者流程控制以其他方式离开调用了\texttt{JL\_GC\_PUSH} 的块。



可以使用 \texttt{JL\_GC\_PUSH2}、\texttt{JL\_GC\_PUSH3}、\texttt{JL\_GC\_PUSH4}、\texttt{JL\_GC\_PUSH5} 和 \texttt{JL\_GC\_PUSH6} 宏一次推送多个 Julia 值。 要推送一个 Julia 数组，可以使用 \texttt{JL\_GC\_PUSHARGS} 宏，其用法如下：




\begin{lstlisting}
jl_value_t **args;
JL_GC_PUSHARGS(args, 2); // args can now hold 2 `jl_value_t*` objects
args[0] = some_value;
args[1] = some_other_value;
// Do something with args (e.g. call jl_... functions)
JL_GC_POP();
\end{lstlisting}



每个作用域必须只有一次对 \texttt{JL\_GC\_PUSH*} 的调用。 因此，如果不能通过一次调用\texttt{JL\_GC\_PUSH*} 一次推送所有变量，或者如果要推送的变量超过 6 个并且使用参数数组不是一种选择，那么可以使用内部块：




\begin{lstlisting}
jl_value_t *ret1 = jl_eval_string("sqrt(2.0)");
JL_GC_PUSH1(&ret1);
jl_value_t *ret2 = 0;
{
    jl_function_t *func = jl_get_function(jl_base_module, "exp");
    ret2 = jl_call1(func, ret1);
    JL_GC_PUSH1(&ret2);
    // Do something with ret2.
    JL_GC_POP();    // This pops ret2.
}
JL_GC_POP();    // This pops ret1.
\end{lstlisting}



如果需要在函数（或块作用域）之间保存指向变量的指针，则不能使用 \texttt{JL\_GC\_PUSH*}。 在这种情况下，有必要在 Julia 全局作用域内创建并保留对变量的引用。 实现这一点的一种简单方法是使用一个全局的\texttt{IdDict}来保存引用，避免 GC 释放。 但是，此方法仅适用于可变类型。




\begin{lstlisting}
// This functions shall be executed only once, during the initialization.
jl_value_t* refs = jl_eval_string("refs = IdDict()");
jl_function_t* setindex = jl_get_function(jl_base_module, "setindex!");

...

// `var` is the variable we want to protect between function calls.
jl_value_t* var = 0;

...

// `var` is a `Vector{Float64}`, which is mutable.
var = jl_eval_string("[sqrt(2.0); sqrt(4.0); sqrt(6.0)]");

// To protect `var`, add its reference to `refs`.
jl_call3(setindex, refs, var, var);
\end{lstlisting}



如果变量是不可变的，则需要将其包装在等效的可变容器中，或者最好在将其推送到\texttt{IdDict}之前包装在\texttt{RefValue\{Any\}}中。 在这种方法中，容器必须通过 C 代码创建或填充，例如使用函数\texttt{jl\_new\_struct}。 如果容器是由\texttt{jl\_call*} 创建的，那么你将需要重新加载要在 C 代码中使用的指针。




\begin{lstlisting}
// This functions shall be executed only once, during the initialization.
jl_value_t* refs = jl_eval_string("refs = IdDict()");
jl_function_t* setindex = jl_get_function(jl_base_module, "setindex!");
jl_datatype_t* reft = (jl_datatype_t*)jl_eval_string("Base.RefValue{Any}");

...

// `var` is the variable we want to protect between function calls.
jl_value_t* var = 0;

...

// `var` is a `Float64`, which is immutable.
var = jl_eval_string("sqrt(2.0)");

// Protect `var` until we add its reference to `refs`.
JL_GC_PUSH1(&var);

// Wrap `var` in `RefValue{Any}` and push to `refs` to protect it.
jl_value_t* rvar = jl_new_struct(reft, var);
JL_GC_POP();

jl_call3(setindex, refs, rvar, rvar);
\end{lstlisting}



GC 可以通过使用函数\texttt{delete!} 从\texttt{refs} 中删除对变量的引用来释放变量，前提是没有其它对该变量的引用保留在任何地方：




\begin{lstlisting}
jl_function_t* delete = jl_get_function(jl_base_module, "delete!");
jl_call2(delete, refs, rvar);
\end{lstlisting}



作为非常简单情况的替代方案，可以只创建一个类型为\texttt{Vector\{Any\}}的全局容器，并在必要时从中获取元素，甚至可以使用以下方法为每个指针创建一个全局变量




\begin{lstlisting}
jl_set_global(jl_main_module, jl_symbol("var"), var);
\end{lstlisting}



\hypertarget{2772518371024501588}{}


\subsection{更新 GC 管理对象的字段}



垃圾回收器的运行假设它知道每个年老代对象都指向一个年轻代对象。 任何时候一个指针被更新打破了这个假设，它必须用\texttt{jl\_gc\_wb}（写屏障）函数向回收器发出信号，如下所示：




\begin{lstlisting}
jl_value_t *parent = some_old_value, *child = some_young_value;
((some_specific_type*)parent)->field = child;
jl_gc_wb(parent, child);
\end{lstlisting}



通常情况下不可能在运行时预测 值是否是旧的，因此 写屏障 必须被插入在所有显式存储之后。一个需要注意的例外是如果 \texttt{parent} 对象刚分配，垃圾收集之后并不执行。请记住大多数 \texttt{jl\_...} 函数有时候都会执行垃圾收集。



直接更新数据时，对于指针数组来说 写屏障 也是必需的 例如：




\begin{lstlisting}
jl_array_t *some_array = ...; // e.g. a Vector{Any}
void **data = (void**)jl_array_data(some_array);
jl_value_t *some_value = ...;
data[0] = some_value;
jl_gc_wb(some_array, some_value);
\end{lstlisting}



\hypertarget{13611710259554554355}{}


\subsection{控制垃圾收集器}



有一些函数能够控制GC。在正常使用情况下这些不是必要的。




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
函数 & 描述 \\
\hline
\texttt{jl\_gc\_collect()} & 强制执行 GC \\
\hline
\texttt{jl\_gc\_enable(0)} & 禁用 GC， 返回前一个状态作为 int 类型 \\
\hline
\texttt{jl\_gc\_enable(1)} & 启用 GC， 返回前一个状态作为 int 类型 \\
\hline
\texttt{jl\_gc\_is\_enabled()} & 返回当前状态作为 int 类型 \\
\hline
\end{tabulary}

\end{table}



\hypertarget{12793375650632651595}{}


\section{使用数组}



Julia 和 C 可以不通过复制而共享数组数据。下面一个例子将展示它是如何工作的。



Julia数组用数据类型 \texttt{jl\_array\_t *} 表示。基本上，\texttt{jl\_array\_t} 是一个包含以下内容的结构：



\begin{itemize}
\item 关于数据类型的信息


\item 指向数据块的指针


\item 关于数组长度的信息

\end{itemize}


为了让事情比较简单，我们从一维数组开始，创建一个存有 10 个 FLoat64 类型的数组如下所示：




\begin{lstlisting}
jl_value_t* array_type = jl_apply_array_type((jl_value_t*)jl_float64_type, 1);
jl_array_t* x          = jl_alloc_array_1d(array_type, 10);
\end{lstlisting}



或者，如果您已经分配了数组，则可以生成一个简易的包装器来包裹其数据：




\begin{lstlisting}
double *existingArray = (double*)malloc(sizeof(double)*10);
jl_array_t *x = jl_ptr_to_array_1d(array_type, existingArray, 10, 0);
\end{lstlisting}



最后一个参数是一个布尔值，表示 Julia 是否应该获取数据的所有权。 如果这个参数 不为零，当数组不再被引用时，GC 会在数据的指针上调用 \texttt{free} 。



为了访问 x 的数据，我们可以使用 \texttt{jl\_array\_data}：




\begin{lstlisting}
double *xData = (double*)jl_array_data(x);
\end{lstlisting}



现在我们可以填充这个数组：




\begin{lstlisting}
for(size_t i=0; i<jl_array_len(x); i++)
    xData[i] = i;
\end{lstlisting}



现在让我们调用一个对 \texttt{x} 就地操作的 Julia 函数：




\begin{lstlisting}
jl_function_t *func = jl_get_function(jl_base_module, "reverse!");
jl_call1(func, (jl_value_t*)x);
\end{lstlisting}



通过打印数组，可以验证 \texttt{x} 的元素现在是否已被逆置 (reversed)。



\hypertarget{10421624901695308393}{}


\subsection{获取返回的数组}



如果 Julia 函数返回一个数组，\texttt{jl\_eval\_string} 和 \texttt{jl\_call} 的返回值可以被强制转换为\texttt{jl\_array\_t *}：




\begin{lstlisting}
jl_function_t *func  = jl_get_function(jl_base_module, "reverse");
jl_array_t *y = (jl_array_t*)jl_call1(func, (jl_value_t*)x);
\end{lstlisting}



现在使用 \texttt{jl\_array\_data} 可以像前面一样访问 \texttt{y} 的内容。一如既往地，一定要在使用数组的时候确保 持有使用数组的引用。



\hypertarget{14703069974979105074}{}


\subsection{多维数组}



Julia的多维数组以 列序优先 存储在内存中。这是一些 创建一个2D数组并访问其属性 的代码：




\begin{lstlisting}
// Create 2D array of float64 type
jl_value_t *array_type = jl_apply_array_type(jl_float64_type, 2);
jl_array_t *x  = jl_alloc_array_2d(array_type, 10, 5);

// Get array pointer
double *p = (double*)jl_array_data(x);
// Get number of dimensions
int ndims = jl_array_ndims(x);
// Get the size of the i-th dim
size_t size0 = jl_array_dim(x,0);
size_t size1 = jl_array_dim(x,1);

// Fill array with data
for(size_t i=0; i<size1; i++)
    for(size_t j=0; j<size0; j++)
        p[j + size0*i] = i + j;
\end{lstlisting}



请注意，虽然 Julia 的数组使用基于 1 的索引，但C API 中使用基于 0 的索引（例如 在调用\texttt{jl\_array\_dim}）以便用C代码的习惯来阅读。



\hypertarget{4029112619480312893}{}


\section{异常}



Julia 代码可以抛出异常。比如：




\begin{lstlisting}
jl_eval_string("this_function_does_not_exist()");
\end{lstlisting}



这个调用似乎什么都没做。但可以检查异常是否抛出：




\begin{lstlisting}
if (jl_exception_occurred())
    printf("%s \n", jl_typeof_str(jl_exception_occurred()));
\end{lstlisting}



如果您使用 支持异常的语言的 Julia C API（例如Python，C＃，C ++），使用 检查是否有异常的函数 将每个调用 包装到 \texttt{libjulia} 中是有意义的，然后异常在宿主语言中重新抛出。



\hypertarget{3345506826925468977}{}


\subsection{抛出 Julia 异常}



在编写 Julia 可调用函数时，可能需要验证参数 并抛出异常表示错误。 典型的类型检查像这样：




\begin{lstlisting}
if (!jl_typeis(val, jl_float64_type)) {
    jl_type_error(function_name, (jl_value_t*)jl_float64_type, val);
}
\end{lstlisting}



可以使用以下函数 引发一般异常：




\begin{lstlisting}
void jl_error(const char *str);
void jl_errorf(const char *fmt, ...);
\end{lstlisting}



\texttt{jl\_error}采用 C 字符串，而 \texttt{jl\_errorf} 像 \texttt{printf} 一样调用:




\begin{lstlisting}
jl_errorf("argument x = %d is too large", x);
\end{lstlisting}



在这个例子中假定 \texttt{x} 是一个整数值。



\hypertarget{5835765330914877287}{}


\chapter{代码加载}



\begin{quote}
\textbf{Note}

这一章包含了加载包的技术细节。如果要安装包，使用 Julia 的内置包管理器\href{@ref Pkg}{\texttt{Pkg}}将包加入到你的活跃环境中。如果要使用已经在你的活跃环境中的包，使用 \texttt{import X} 或 \texttt{using X}，正如在\hyperlink{7031478671373133429}{模块}中所描述的那样。

\end{quote}


\hypertarget{5148923403283115982}{}


\section{定义}



Julia加载代码有两种机制：



\begin{itemize}
\item[1. ] \textbf{代码包含：}例如 \texttt{include({\textquotedbl}source.jl{\textquotedbl})}。包含允许你把一个程序拆分为多个源文件。表达式 \texttt{include({\textquotedbl}source.jl{\textquotedbl})} 使得文件 \texttt{source.jl} 的内容在出现 \texttt{include} 调用的模块的全局作用域中执行。如果多次调用 \texttt{include({\textquotedbl}source.jl{\textquotedbl})}，\texttt{source.jl} 就被执行多次。\texttt{source.jl} 的包含路径解释为相对于出现 \texttt{include} 调用的文件路径。重定位源文件子树因此变得简单。在 REPL 中，包含路径为当前工作目录，即 \hyperlink{16313884780490629439}{\texttt{pwd()}}。


\item[2. ] \textbf{加载包：}例如 \texttt{import X} 或 \texttt{using X}。\texttt{import} 通过加载包（一个独立的，可重用的 Julia 代码集合，包含在一个模块中），并导入模块内部的名称 \texttt{X}，使得模块 \texttt{X} 可用。 如果在同一个 Julia 会话中，多次导入包 \texttt{X}，那么后续导入模块为第一次导入模块的引用。但请注意，\texttt{import X} 可以在不同的上下文中加载不同的包：\texttt{X} 可以引用主工程中名为 \texttt{X} 的一个包，但它在各个依赖中可以引用不同的、名称同为 \texttt{X} 的包。更多机制说明如下。

\end{itemize}


代码包含是非常直接和简单的：其在调用者的上下文中解释运行给定的源文件。包加载是建立在代码包含之上的，它具有不同的\hyperlink{16725527896995457152}{用途}。本章的其余部分将重点介绍程序包加载的行为和机制。



一个 \emph{包（package）} 就是一个源码树，其标准布局中提供了其他 Julia 项目可以复用的功能。包可以使用 \texttt{import X} 或 \texttt{using X} 语句加载，名为 \texttt{X} 的模块在加载包代码时生成，并在包含该 import 语句的模块中可用。\texttt{import X} 中 \texttt{X} 的含义与上下文有关：程序加载哪个 \texttt{X} 包取决于 import 语句出现的位置。因此，处理 \texttt{import X} 分为两步：首先，确定在此上下文中是\textbf{哪个}包被定义为 \texttt{X}；其次，确定到\textbf{哪里}找特定的 \texttt{X} 包。



这些问题可通过查询各项目文件（\texttt{Project.toml} 或 \texttt{JuliaProject.toml}）、清单文件（\texttt{Manifest.toml} 或 \texttt{JuliaManifest.toml}），或是源文件的文件夹列在\hyperlink{17914149694871263675}{\texttt{LOAD\_PATH}} 中的项目环境解决。



\hypertarget{7954410959763991520}{}


\section{包的联合生态}



大多数时候，一个包可以通过它的名字唯一确定。但有时在一个项目中，可能需要使用两个有着相同名字的不同的包。尽管你可以通过重命名其中一个包来解决这个问题，但在一个大型的、共享的代码库中被迫做这件事可能是有高度破坏性的。相反，Julia的包加载机制允许相同的包名在一个应用的不同部分指向不同的包。



Julia 支持联合的包管理，这意味着多个独立的部分可以维护公有包、私有包以及包的注册表，并且项目可以依赖于一系列来自不同注册表的公有包和私有包。您也可以使用一组通用工具和工作流（workflow）来安装和管理来自各种注册表的包。Julia 附带的 \texttt{Pkg} 软件包管理器允许安装和管理项目的依赖项，它会帮助创建并操作项目文件（其描述了项目所依赖的其他项目）和清单文件（其为项目完整依赖库的确切版本的快照）。



联合管理的一个可能后果是没有包命名的中央权限。不同组织可以使用相同的名称来引用不相关的包。这并不是没有可能的，因为这些组织可能没有协作，甚至不知道彼此。由于缺乏中央命名权限，单个项目可能最终依赖着具有相同名称的不同包。Julia 的包加载机制不要求包名称是全局唯一的，即使在单个项目的依赖关系图中也是如此。相反，包由\href{https://en.wikipedia.org/wiki/Universally\_unique\_identifier}{通用唯一标识符} （UUID）进行标识，它在每个包创建时进行分配。通常，您不必直接使用这些有点麻烦的 128 位标识符，因为 \texttt{Pkg} 将负责生成和跟踪它们。但是，这些 UUID 为问题\emph{「\texttt{X} 所指的包是什么？」}提供了确定的答案



由于去中心化的命名问题有些抽象，因此可以通过具体情境来理解问题。假设你正在开发一个名为 \texttt{App} 的应用程序，它使用两个包：\texttt{Pub} 和 \texttt{Priv}。\texttt{Priv} 是你创建的私有包，而 \texttt{Pub} 是你使用但不控制的公共包。当你创建 \texttt{Priv} 时，没有名为 \texttt{Priv} 的公共包。然而，随后一个名为 \texttt{Priv} 的不相关软件包发布并变得流行起来，而且 \texttt{Pub} 包已经开始使用它了。因此，当你下次升级 \texttt{Pub} 以获取最新的错误修复和特性时，\texttt{App} 将依赖于两个名为 \texttt{Priv} 的不同包——尽管你除了升级之外什么都没做。\texttt{App} 直接依赖于你的私有 \texttt{Priv} 包，以及通过 \texttt{Pub} 在新的公共 \texttt{Priv} 包上的间接依赖。由于这两个 \texttt{Priv} 包是不同的，但是 \texttt{App} 继续正常工作依赖于他们两者，因此表达式 \texttt{import Priv} 必须引用不同的 \texttt{Priv} 包，具体取决于它是出现在 \texttt{App} 的代码中还是出现在 \texttt{Pub} 的代码中。为了处理这种情况，Julia 的包加载机制通过 UUID 区分两个 \texttt{Priv} 包并根据它（调用 \texttt{import} 的模块）的上下文选择正确的包。这种区分的工作原理取决于环境，如以下各节所述。



\hypertarget{3001628692617530434}{}


\section{环境（Environments）}



\textbf{环境}决定了 \texttt{import X} 和 \texttt{using X} 语句在不同的代码上下文中的含义以及什么文件会被加载。Julia 有两类环境（environment）：



\begin{itemize}
\item[1. ] \textbf{项目环境（project environment）}是包含项目文件和清单文件（可选）的目录，并形成一个\emph{显式环境}。项目文件确定项目的直接依赖项的名称和标识。清单文件（如果存在）提供完整的依赖关系图，包括所有直接和间接依赖关系，每个依赖的确切版本以及定位和加载正确版本的足够信息。


\item[2. ] \textbf{包目录（package directory）}是包含一组包的源码树子目录的目录，并形成一个\emph{隐式环境}。如果 \texttt{X} 是包目录的子目录并且存在 \texttt{X/src/X.jl}，那么程序包 \texttt{X} 在包目录环境中可用，而 \texttt{X/src/X.jl} 是加载它使用的源文件。

\end{itemize}


这些环境可以混合并用来创建\textbf{堆栈环境（stacked environment）}：是一组有序的项目环境和包目录，重叠为一个复合环境。然后，结合优先级规则和可见性规则，确定哪些包是可用的以及从哪里加载它们。例如，Julia 的负载路径是一个堆栈环境。



这些环境各有不同的用途：



\begin{itemize}
\item 项目环境提供\textbf{可迁移性}。通过将项目环境以及项目源代码的其余部分存放到版本控制（例如一个 git 存储库），您可以重现项目的确切状态和所有依赖项。特别是，清单文件会记录每个依赖项的确切版本，而依赖项由其源码树的加密哈希值标识；这使得 \texttt{Pkg} 可以检索出正确的版本，并确保你正在运行准确的已记录的所有依赖项的代码。


\item 当不需要完全仔细跟踪的项目环境时，包目录更\textbf{方便}。当你想要把一组包放在某处，并且希望能够直接使用它们而不必为之创建项目环境时，包目录是很实用的。


\item 堆栈环境允许向基本环境\textbf{添加}工具。您可以将包含开发工具在内的环境堆到堆栈环境的末尾，使它们在 REPL 和脚本中可用，但在包内部不可用。

\end{itemize}


从更高层次上，每个环境在概念上定义了三个映射：roots、graph 和 paths。当解析 \texttt{import X} 的含义时，roots 和 graph 映射用于确定 \texttt{X} 的身份，同时 paths 映射用于定位 \texttt{X} 的源代码。这三个映射的具体作用是：



\begin{itemize}
\item \textbf{roots:} \texttt{name::Symbol} ⟶ \texttt{uuid::UUID}

环境的 roots 映射将包名称分配给UUID，以获取环境可用于主项目的所有顶级依赖项（即可以在 \texttt{Main} 中加载的那些依赖项）。当 Julia 在主项目中遇到 \texttt{import X} 时，它会将 \texttt{X} 的标识作为 \texttt{roots[:X]}。


\item \textbf{graph:} \texttt{context::UUID} ⟶ \texttt{name::Symbol} ⟶ \texttt{uuid::UUID}

环境的 graph 是一个多级映射，它为每个 \texttt{context} UUID 分配一个从名称到 UUID 的映射——类似于 roots 映射，但专一于那个 \texttt{context}。当 Julia 在 UUID 为 \texttt{context} 的包代码中运行到 \texttt{import X} 时，它会将 \texttt{X} 的标识看作为 \texttt{graph[context][:X]}。正是因为如此，\texttt{import X} 可以根据 \texttt{context} 引用不同的包。


\item \textbf{paths:} \texttt{uuid::UUID} × \texttt{name::Symbol} ⟶ \texttt{path::String}

paths 映射会为每个包分配 UUID-name 对，即该包的入口点源文件的位置。在 \texttt{import X} 中，\texttt{X} 的标识已经通过 roots 或 graph 解析为 UUID（取决于它是从主项目还是从依赖项加载），Julia 确定要加载哪个文件来获取 \texttt{X} 是通过在环境中查找 \texttt{paths[uuid,:X]}。要包含此文件应该定义一个名为 \texttt{X} 的模块。一旦加载了此包，任何解析为相同的 \texttt{uuid} 的后续导入只会创建一个到同一个已加载的包模块的绑定。

\end{itemize}


每种环境都以不同的方式定义这三种映射，详见以下各节。



\begin{quote}
\textbf{Note}

为了清楚地说明，本章中的示例包括 roots、graph 和 paths 的完整数据结构。但是，为了提高效率，Julia 的包加载代码并没有显式地创建它们。相反，加载一个给定包只会简单地计算所需的结构。

\end{quote}


\hypertarget{2089876833496138047}{}


\subsection{项目环境（Project environments）}



项目环境由包含名为 \texttt{Project.toml} 的项目文件的目录以及名为 \texttt{Manifest.toml} 的清单文件（可选）确定。这些文件也可以命名为 \texttt{JuliaProject.toml} 和 \texttt{JuliaManifest.toml}，此时 \texttt{Project.toml} 和 \texttt{Manifest.toml} 被忽略——这允许项目与可能需要名为 \texttt{Project.toml} 和 \texttt{Manifest.toml} 文件的其他重要工具共存。但是对于纯 Julia 项目，名称 \texttt{Project.toml} 和 \texttt{Manifest.toml} 是首选。



项目环境的 roots、graph 和 paths 映射定义如下：



\textbf{roots 映射} 在环境中由其项目文件的内容决定，特别是它的顶级 \texttt{name} 和 \texttt{uuid} 条目及其 \texttt{[deps]} 部分（全部是可选的）。考虑以下一个假想的应用程序 \texttt{App} 的示例项目文件，如先前所述：




\begin{lstlisting}
name = "App"
uuid = "8f986787-14fe-4607-ba5d-fbff2944afa9"

[deps]
Priv = "ba13f791-ae1d-465a-978b-69c3ad90f72b"
Pub  = "c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"
\end{lstlisting}



如果将它表示为 Julia 字典，那么这个项目文件意味着以下 roots 映射：




\begin{minted}{julia}
roots = Dict(
    :App  => UUID("8f986787-14fe-4607-ba5d-fbff2944afa9"),
    :Priv => UUID("ba13f791-ae1d-465a-978b-69c3ad90f72b"),
    :Pub  => UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"),
)
\end{minted}



基于这个 root 映射，在 \texttt{App} 的代码中，语句 \texttt{import Priv} 将使 Julia 查找 \texttt{roots[:Priv]}，这将得到 \texttt{ba13f791-ae1d-465a-978b-69c3ad90f72b}，也就是要在这一部分加载的 \texttt{Priv} 包的 UUID。当主应用程序解释运行到 \texttt{import Priv} 时，此 UUID 标识了要加载和使用的 \texttt{Priv} 包。



\textbf{依赖图（dependency graph）} 在项目环境中其清单文件的内容决定，如果其存在。如果没有清单文件，则 graph 为空。清单文件包含项目的直接或间接依赖项的节（stanza）。对于每个依赖项，该文件列出该包的 UUID 以及源码树的哈希值或源代码的显式路径。考虑以下 \texttt{App} 的示例清单文件：




\begin{lstlisting}
[[Priv]] # 私有的那个
deps = ["Pub", "Zebra"]
uuid = "ba13f791-ae1d-465a-978b-69c3ad90f72b"
path = "deps/Priv"

[[Priv]] # 公共的那个
uuid = "2d15fe94-a1f7-436c-a4d8-07a9a496e01c"
git-tree-sha1 = "1bf63d3be994fe83456a03b874b409cfd59a6373"
version = "0.1.5"

[[Pub]]
uuid = "c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"
git-tree-sha1 = "9ebd50e2b0dd1e110e842df3b433cb5869b0dd38"
version = "2.1.4"

  [Pub.deps]
  Priv = "2d15fe94-a1f7-436c-a4d8-07a9a496e01c"
  Zebra = "f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"

[[Zebra]]
uuid = "f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"
git-tree-sha1 = "e808e36a5d7173974b90a15a353b564f3494092f"
version = "3.4.2"
\end{lstlisting}



这个清单文件描述了 \texttt{App} 项目可能的完整依赖关系图：



\begin{itemize}
\item 应用程序使用两个名为 \texttt{Priv} 的不同包，一个作为根依赖项的私有包，以及一个通过 \texttt{Pub} 作为间接依赖项的公共包。它们通过不同 UUID 来区分，并且有不同的依赖项：

\begin{itemize}
\item 私有的 \texttt{Priv} 依赖于 \texttt{Pub} 和 \texttt{Zebra} 包。


\item 公有的 \texttt{Priv} 没有依赖关系。

\end{itemize}

\item 该应用程序还依赖于 \texttt{Pub} 包，而后者依赖于公有的 \texttt{Priv} 以及私有的 \texttt{Priv} 包所依赖的那个 \texttt{Zebra} 包。

\end{itemize}


此依赖图以字典表示后如下所示：




\begin{minted}{julia}
graph = Dict(
    # Priv——私有的那个:
    UUID("ba13f791-ae1d-465a-978b-69c3ad90f72b") => Dict(
        :Pub   => UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"),
        :Zebra => UUID("f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"),
    ),
    # Priv——公共的那个:
    UUID("2d15fe94-a1f7-436c-a4d8-07a9a496e01c") => Dict(),
    # Pub:
    UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1") => Dict(
        :Priv  => UUID("2d15fe94-a1f7-436c-a4d8-07a9a496e01c"),
        :Zebra => UUID("f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"),
    ),
    # Zebra:
    UUID("f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62") => Dict(),
)
\end{minted}



给定这个依赖图，当 Julia 看到 \texttt{Pub} 包中的 \texttt{import Priv} ——它有 UUID\texttt{c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1} 时，它会查找：




\begin{minted}{julia}
graph[UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1")][:Priv]
\end{minted}



会得到 \texttt{2d15fe94-a1f7-436c-a4d8-07a9a496e01c}，这意味着 \texttt{Pub} 包中的内容，\texttt{import Priv} 指代的是公有的 \texttt{Priv} 内容，而非应用程序直接依赖的私有包。这也是为何 \texttt{Priv} 在主项目中可指代不同的包，而不像其在某个依赖包中另有含义。在包生态中，该特性允许重名的出现。



如果在 \texttt{App} 主代码库中 \texttt{import Zebra} 会如何？因为\texttt{Zebra} 不存在于项目文件，即使它 \emph{确实} 存在于清单文件中，其导入会是失败的。此外，\texttt{import Zebra} 这个行为若发生在公有的 \texttt{Priv} 包——UUID 为 \texttt{2d15fe94-a1f7-436c-a4d8-07a9a496e01c} 的包中，同样会失败。因为公有的 \texttt{Priv} 包未在清单文件中声明依赖，故而无法加载包。仅有在清单文件：\texttt{Pub} 包和一个 \texttt{Priv} 包中作为显式依赖的包可用于加载 \texttt{Zebra}。



项目环境的 \textbf{路径映射} 从 manifest 文件中提取得到。而包的路径 \texttt{uuid} 和名称 \texttt{X} 则 (循序) 依据这些规则确定。



\begin{itemize}
\item[1. ] 如果目录中的项目文件与要求的 \texttt{uuid} 以及名称 \texttt{X} 匹配，那么可能出现以下情况的一种：

\begin{itemize}
\item 若该文件具有顶层 \texttt{路径} 入口，则 \texttt{uuid} 会被映射到该路径，文件的执行与包含项目文件的目录相关。


\item 此外，\texttt{uuid} 依照包含项目文件的目录，映射至与\texttt{src/X.jl}。

\end{itemize}

\item[2. ] 若非上述情况，且项目文件具有对应的清单文件，且该清单文件包含匹配 \texttt{uuid} 的节（stanza），那么：

\begin{itemize}
\item 若其具有一个 \texttt{路径} 入口，则使用该路径（与包含清单文件的目录相关）。


\item 若其具有一个 \texttt{git-tree-sha1} 入口，计算一个确定的 \texttt{uuid} 与 \texttt{git-tree-sha1} 函数——我们把这个函数称为 \texttt{slug}——并在每个 Julia \texttt{DEPOT\_PATH} 的全局序列中的目录查询名为 \texttt{packages/X/\$slug} 的目录。使用存在的第一个此类目录。

\end{itemize}
\end{itemize}


若某些结果成功，源码入口点的路径会是这些结果中的某个，结果的相对路径+\texttt{src/X.jl}；否则，\texttt{uuid} 不存在路径映射。当加载 \texttt{X} 时，如果没找到源码路径，查找即告失败，用户可能会被提示安装适当的包版本或采取其他纠正措施（例如，将 \texttt{X} 声明为某种依赖性）。



在上述样例清单文件中，为找到首个 \texttt{Priv} 包的路径——该包 UUID 为 \texttt{ba13f791-ae1d-465a-978b-69c3ad90f72b}——Julia 寻找其在清单中的节（stanza）。发现其有 路径\texttt{入口，查看}App\texttt{项目目录中相关的}deps/Priv\texttt{——不妨设}App\texttt{代码在}/home/me/projects/App\texttt{中—则 Julia 发现}/home/me/projects/App/deps/Priv\texttt{存在，并因此从中加载}Priv`。



另一方面，如果Julia加载的是带有\emph{other} \texttt{Priv} 包——即UUID为\texttt{2d15fe94-a1f7-436c-a4d8-07a9a496e01c}——它在清单中找到了它的节，请注意它\emph{没有}\texttt{path}条目，但是它有一个\texttt{git-tree-sha1} 条目。然后计算这个\texttt{slug} 的UUID/SHA-1对，具体是\texttt{HDkrT}（这个计算的确切细节并不重要，但它是始终一致的和确定的）。这意味着这个\texttt{Priv}包的路径\texttt{packages/Priv/HDkrT/src/Priv.jl}将在其中一个包仓库中。假设\texttt{DEPOT\_PATH} 的内容是\texttt{[{\textquotedbl}/home/me/.julia{\textquotedbl}, {\textquotedbl}/usr/local/julia{\textquotedbl}]}，Julia将根据下面的路径来查看它们是否存在：



\begin{itemize}
\item[1. ] \texttt{/home/me/.julia/packages/Priv/HDkrT}


\item[2. ] \texttt{/usr/local/julia/packages/Priv/HDkrT}

\end{itemize}


Julia使用以上路径信息在仓库里依次查找 \texttt{packages/Priv/HDKrT/src/Priv.jl}文件，并从第一个查找到的文件中加载公共的 \texttt{Priv}包。



这是我们的示例App项目环境的可能路径映射的表示，  如上面Manifest 中所提供的依赖关系图， 在 搜索本地文件系统后：




\begin{minted}{julia}
paths = Dict(
    # Priv – the private one:
    (UUID("ba13f791-ae1d-465a-978b-69c3ad90f72b"), :Priv) =>
        # relative entry-point inside `App` repo:
        "/home/me/projects/App/deps/Priv/src/Priv.jl",
    # Priv – the public one:
    (UUID("2d15fe94-a1f7-436c-a4d8-07a9a496e01c"), :Priv) =>
        # package installed in the system depot:
        "/usr/local/julia/packages/Priv/HDkr/src/Priv.jl",
    # Pub:
    (UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"), :Pub) =>
        # package installed in the user depot:
        "/home/me/.julia/packages/Pub/oKpw/src/Pub.jl",
    # Zebra:
    (UUID("f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"), :Zebra) =>
        # package installed in the system depot:
        "/usr/local/julia/packages/Zebra/me9k/src/Zebra.jl",
)
\end{minted}



这个例子包含三种不同类型的包位置信息(第一个和第三个是默认加载路径的一部分)



\begin{itemize}
\item[1. ] 私有 \texttt{Priv} 包 {\textquotedbl}\href{https://stackoverflow.com/a/35109534}{vendored}{\textquotedbl}包括在\texttt{App}仓库中。


\item[2. ] 公共 \texttt{Priv} 与 \texttt{Zebra} 包位于系统仓库，系统管理员在此对相关包进行实时安装与管理。这些包允许系统上的所有用户使用。


\item[3. ] \texttt{Pub} 包位于用户仓库，用户实时安装的包都储存在此。 这些包仅限原安装用户使用。

\end{itemize}


\hypertarget{9048837682653155362}{}


\subsection{包目录}



包目录提供了一种更简单的环境，但不能处理名称冲突。在包目录中， 顶层包集合是“类似”包的子目录集合。\texttt{X}包存在于包目录中的条件，是目录包含下列“入口点”文件之一：



\begin{itemize}
\item \texttt{X.jl}


\item \texttt{X/src/X.jl}


\item \texttt{X.jl/src/X.jl}

\end{itemize}


包目录中的包可以导入哪些依赖项，取决于该包是否含有项目文件：



\begin{itemize}
\item 如果它有一个项目文件，那么它只能导入那些在项目文件的\texttt{[deps]} 部分中已标识的包。


\item 如果没有项目文件，它可以导入任何顶层包，即与在\texttt{Main} 或者 REPL中可加载的包相同。

\end{itemize}


\textbf{根图}是根据包目录的所有内容而形成的一个列表，包含所有已存在的包。 此外，一个UUID 将被赋予给每一个条目，例如对一个在文件夹\texttt{X}中找到的包



\begin{itemize}
\item[1. ] 如果\texttt{X/Project.toml}文件存在并且有一个\texttt{uuid} 条目，那么这个 \texttt{uuid}就是上述所要赋予的值。


\item[2. ] 如果\texttt{X/Project.toml}文件存在，但\emph{没有}包含一个顶层UUID条目, 该\texttt{uuid}将是一个虚构的UUID，是对\texttt{X/Project.toml}文件所在的规范（真实的）路径信息进行哈希处理而生成。


\item[3. ] 否则（如果\texttt{Project.toml}文件不存在）， \texttt{uuid}将是一个全零值 \href{https://en.wikipedia.org/wiki/Universally\_unique\_identifier\#Nil\_UUID}{nil UUID}。

\end{itemize}


项目目录的\textbf{依赖关系图}是根据每个包的子目录中其项目文件的存在与否以及内容而形成。规则是：



\begin{itemize}
\item 如果包子目录没有项目文件，则在该图中忽略它， 其代码中的import语句按顶层处理，与main项目和REPL相同。


\item 如果包子目录有一个项目文件，那么图条目的UUID是项目文件的\texttt{[deps]}映射， 如果该信息项不存在，则视为空。

\end{itemize}


作为一个例子，假设包目录具有以下结构和内容：




\begin{lstlisting}
Aardvark/
    src/Aardvark.jl:
        import Bobcat
        import Cobra

Bobcat/
    Project.toml:
        [deps]
        Cobra = "4725e24d-f727-424b-bca0-c4307a3456fa"
        Dingo = "7a7925be-828c-4418-bbeb-bac8dfc843bc"

    src/Bobcat.jl:
        import Cobra
        import Dingo

Cobra/
    Project.toml:
        uuid = "4725e24d-f727-424b-bca0-c4307a3456fa"
        [deps]
        Dingo = "7a7925be-828c-4418-bbeb-bac8dfc843bc"

    src/Cobra.jl:
        import Dingo

Dingo/
    Project.toml:
        uuid = "7a7925be-828c-4418-bbeb-bac8dfc843bc"

    src/Dingo.jl:
        # no imports
\end{lstlisting}



下面是相应的根结构，表示为字典：




\begin{minted}{julia}
roots = Dict(
    :Aardvark => UUID("00000000-0000-0000-0000-000000000000"), # no project file, nil UUID
    :Bobcat   => UUID("85ad11c7-31f6-5d08-84db-0a4914d4cadf"), # dummy UUID based on path
    :Cobra    => UUID("4725e24d-f727-424b-bca0-c4307a3456fa"), # UUID from project file
    :Dingo    => UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc"), # UUID from project file
)
\end{minted}



下面是对应的图结构，表示为字典：




\begin{minted}{julia}
graph = Dict(
    # Bobcat:
    UUID("85ad11c7-31f6-5d08-84db-0a4914d4cadf") => Dict(
        :Cobra => UUID("4725e24d-f727-424b-bca0-c4307a3456fa"),
        :Dingo => UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc"),
    ),
    # Cobra:
    UUID("4725e24d-f727-424b-bca0-c4307a3456fa") => Dict(
        :Dingo => UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc"),
    ),
    # Dingo:
    UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc") => Dict(),
)
\end{minted}



值得注意的一些通用规则：



\begin{itemize}
\item[1. ] 缺少项目文件的包能依赖于任何顶层依赖项， 并且由于包目录中的每个包在顶层依赖中可用，因此它可以导入在环境中的所有包。


\item[2. ] 含有项目文件的包不能依赖于缺少项目文件的包。 因为有项目文件的包只能加载那些在\texttt{graph}中的包，而没有项目文件的包不会出现在\texttt{graph}。


\item[3. ] 具有项目文件但没有明确UUID的包只能被由没有项目文件的包所依赖， since dummy UUIDs assigned to these packages are strictly internal.

\end{itemize}


，因为赋予给这些包的虚构UUID全是项目内部的。



Observe the following specific instances of these rules in our example: 请注意以下我们例子中的规则具体实例：



\begin{itemize}
\item \texttt{Aardvark} 包可以导入\texttt{Bobcat}、\texttt{Cobra} 或\texttt{Dingo}中的所有包；它确实导入\texttt{Bobcat} and \texttt{Cobra}包.


\item \texttt{Bobcat} 包能导入\texttt{Cobra}与\texttt{Dingo}包。因为它们都有带有UUID的项目文件，并在\texttt{Bobcat}包的\texttt{[deps]}信息项声明为依赖项。


\item \texttt{Bobcat}包不能依赖于\texttt{Aardvark}包，因为\texttt{Aardvark}包缺少项目文件。


\item \texttt{Cobra}包能导入\texttt{Dingo}包。因为\texttt{Dingo}包有项目文件和UUID，并在\texttt{Cobra}的\texttt{[deps]} 信息项中声明为依赖项。


\item \texttt{Cobra}包不能依赖\texttt{Aardvark}或\texttt{Bobcat}包， 因为两者都没有真实的UUID。


\item \texttt{Dingo}包不能导入任何包，因为它的项目文件中缺少\texttt{[deps]}信息项。

\end{itemize}


包目录中的\textbf{路径映射}很简单: 它将子目录名映射到相应的入口点路径。换句话说，如果指向我们示例项目目录的路径是\texttt{/home/me/animals}，那么\texttt{路径}映射可以用此字典表示：




\begin{minted}{julia}
paths = Dict(
    (UUID("00000000-0000-0000-0000-000000000000"), :Aardvark) =>
        "/home/me/AnimalPackages/Aardvark/src/Aardvark.jl",
    (UUID("85ad11c7-31f6-5d08-84db-0a4914d4cadf"), :Bobcat) =>
        "/home/me/AnimalPackages/Bobcat/src/Bobcat.jl",
    (UUID("4725e24d-f727-424b-bca0-c4307a3456fa"), :Cobra) =>
        "/home/me/AnimalPackages/Cobra/src/Cobra.jl",
    (UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc"), :Dingo) =>
        "/home/me/AnimalPackages/Dingo/src/Dingo.jl",
)
\end{minted}



根据定义，包目录环境中的所有包都是具有预期入口点文件的子目录，因此它们的\texttt{路径} 映射条目始终具有此格式。



\hypertarget{14356834175019870606}{}


\subsection{环境堆栈}



第三种也是最后一种环境是通过覆盖其中的几个环境来组合其他环境，使每个环境中的包在单个组合环境中可用。这些复合环境称为\emph{环境堆栈}。Julia的\texttt{LOAD\_PATH}全局定义一个环境堆栈——Julia进程在其中运行的环境。如果希望Julia进程只能访问一个项目或包目录中的包，请将其设置为\texttt{LOAD\_PATH}中的唯一条目。然而，访问一些您喜爱的工具（标准库、探查器、调试器、个人实用程序等）通常是非常有用的，即使它们不是您正在处理的项目的依赖项。通过将包含这些工具的环境添加到加载路径，您可以立即在顶层代码中访问它们，而无需将它们添加到项目中。



组合环境堆栈组件中根、图和路径的数据结构的机制很简单：它们被作为字典进行合并， 在发生键冲突时，优先使用前面的条目而不是后面的条目。换言之，如果我们有\texttt{stack = [env₁, env₂, …]}，那么我们有：




\begin{minted}{julia}
roots = reduce(merge, reverse([roots₁, roots₂, …]))
graph = reduce(merge, reverse([graph₁, graph₂, …]))
paths = reduce(merge, reverse([paths₁, paths₂, …]))
\end{minted}



带下标的 \texttt{rootsᵢ}, \texttt{graphᵢ} and \texttt{pathsᵢ}变量对应于在\texttt{stack}中包含的下标环境变量\texttt{envᵢ}。 使用\texttt{reverse} 是因为当参数字典中的键之间发生冲突时，使\texttt{merge} 倾向于使用最后一个参数，而不是第一个参数。这种设计有几个值得注意的特点：



\begin{itemize}
\item[1. ] \emph{主环境}——即堆栈中的第一个环境，被准确地嵌入到堆栈环境中。堆栈中第一个环境的完整依赖关系图是必然被完整包括在含有所有相同版本的依赖项的堆栈环境中。


\item[2. ] 非主环境中的包能最终使用与其依赖项不兼容的版本，即使它们自己的环境是完全兼容。这种情况可能发生，当它们的一个依赖项被堆栈（通过图或路径，或两者）中某个早期环境中的版本所覆盖。

\end{itemize}


由于主环境通常是您正在处理的项目所在的环境，而堆栈中稍后的环境包含其他工具， 因此这是正确的权衡：最好改进您的开发工具，但保持项目能工作。当这种不兼容发生时，你通常要将开发工具升级到与主项目兼容的版本。



\hypertarget{16711373200664757596}{}


\section{总结}



在软件包系统中，联邦软件包管理和精确的软件可复制性是困难但有价值的目标。结合起来，这些目标导致了一个比大多数动态语言更加复杂的包加载机制，但它也产生了通常与静态语言相关的可伸缩性和可复制性。通常，Julia用户应该能够使用内置的包管理器来管理他们的项目，而无需精确理解这些交互细节。通过调用\texttt{Pkg.add({\textquotedbl}X{\textquotedbl})}添加\texttt{X}包到对应的项目，并清晰显示相关文件，选择\texttt{Pkg.activate({\textquotedbl}Y{\textquotedbl})}后, 可调用\texttt{import X} 即可加载\texttt{X}包，而无需作过多考虑。



\hypertarget{13874102823603666739}{}


\chapter{性能分析}



\texttt{Profile} 模块提供了一些工具来帮助开发者提高其代码的性能。在使用时，它运行代码并进行测量，并生成输出，该输出帮助你了解在每行（或几行）上花费了多少时间。最常见的用法是识别性能「瓶颈」并将其作为优化目标。



\texttt{Profile} 实现了所谓的「抽样」或\href{https://en.wikipedia.org/wiki/Profiling\_(computer\_programming)}{统计分析器}。它通过在执行任何任务期间定期进行回溯来工作。每次回溯捕获当前运行的函数和行号，以及导致该行执行的完整函数调用链，因此是当前执行状态的「快照」。



如果大部分运行时间都花在执行特定代码行上，则此行会在所有回溯的集合中频繁出现。换句话说，执行给定行的「成本」——或实际上，调用及包含此行的函数序列的成本——与它在所有回溯的集合中的出现频率成正比。



抽样分析器不提供完整的逐行覆盖功能，因为回溯是间隔发生的（默认情况下，该时间间隔在 Unix 上是 1 ms，而在 Windows 上是 10 ms，但实际调度受操作系统负载的影响）。此外，正如下文中进一步讨论的，因为样本是在所有执行点的稀疏子集处收集的，所以抽样分析器收集的数据会受到统计噪声的影响。



尽管有这些限制，但抽样分析器仍然有很大的优势：



\begin{itemize}
\item 你无需对代码进行任何修改即可进行时间测量。


\item 它可以分析 Julia 的核心代码，甚至（可选）可以分析 C 和 Fortran 库。


\item 通过「偶尔」运行，它只有很少的性能开销；代码在性能分析时能以接近本机的速度运行。

\end{itemize}


出于这些原因，建议你在考虑任何替代方案前尝试使用内置的抽样分析器。



\hypertarget{17553054695497272357}{}


\section{基本用法}



让我们使用一个简单的测试用例：




\begin{minted}{jlcon}
julia> function myfunc()
           A = rand(200, 200, 400)
           maximum(A)
       end
\end{minted}



最好先至少运行一次你想要分析的代码（除非你想要分析 Julia 的 JIT 编译器）：




\begin{minted}{jlcon}
julia> myfunc() # run once to force compilation
\end{minted}



现在我们准备分析这个函数：




\begin{minted}{jlcon}
julia> using Profile

julia> @profile myfunc()
\end{minted}



有一些图形界面可以查看性能分析的结果。这其中有一类是基于 \href{https://github.com/timholy/FlameGraphs.jl}{FlameGraphs.jl}打造的，只不过提供了不同的用户接口：



\begin{itemize}
\item \href{https://junolab.org/}{Juno} 是一个完整的 IDE，内置对性能分析可视化的支持


\item \href{https://github.com/timholy/ProfileView.jl}{ProfileView.jl} 是一个基于 GTK 的独立可视化工具


\item \href{https://github.com/davidanthoff/ProfileVega.jl}{ProfileVega.jl} 使用 VegaLight 并与 Jupyter notebooks 很好地集成


\item \href{https://github.com/tkluck/StatProfilerHTML.jl}{StatProfilerHTML} 生成 HTML 并提供一些额外的摘要，并且还与 Jupyter 笔记本很好地集成


\item \href{https://github.com/timholy/ProfileSVG.jl}{ProfileSVG} 渲染 SVG

\end{itemize}


一种完全独立的性能分析可视化方法是 \href{https://github.com/vchuravy/PProf.jl}{PProf.jl}，它使用外部 \texttt{pprof} 工具。



不过，在这里，我们将使用标准库附带的基于文本的显示：




\begin{minted}{jlcon}
julia> Profile.print()
80 ./event.jl:73; (::Base.REPL.##1#2{Base.REPL.REPLBackend})()
 80 ./REPL.jl:97; macro expansion
  80 ./REPL.jl:66; eval_user_input(::Any, ::Base.REPL.REPLBackend)
   80 ./boot.jl:235; eval(::Module, ::Any)
    80 ./<missing>:?; anonymous
     80 ./profile.jl:23; macro expansion
      52 ./REPL[1]:2; myfunc()
       38 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type{B...
        38 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr{F...
       14 ./random.jl:278; rand
        14 ./random.jl:277; rand
         14 ./random.jl:366; rand
          14 ./random.jl:369; rand
      28 ./REPL[1]:3; myfunc()
       28 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinear,...
        3  ./reduce.jl:426; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...
        25 ./reduce.jl:428; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...
\end{minted}



显示结果中的每行表示代码中的特定点（行数）。缩进用来标明嵌套的函数调用序列，其中缩进更多的行在调用序列中更深。在每一行中，第一个「字段」是在\emph{这一行或由这一行执行的任何函数}中获取的回溯（样本）数量。第二个字段是文件名和行数，第三个字段是函数名。请注意，具体的行号可能会随着 Julia 代码的改变而改变；如果你想跟上，最好自己运行这个示例。



在此例中，我们可以看到顶层的调用函数位于文件 \texttt{event.jl} 中。这是启动 Julia 时运行 REPL 的函数。如果你查看 \texttt{REPL.jl} 的第 97 行，你会看到这是调用函数 \texttt{eval\_user\_input()} 的地方。这是对你在 REPL 上的输入进行求值的函数，因为我们正以交互方式运行，所以当我们输入 \texttt{@profile myfunc()} 时会调用这些函数。下一行反映了 \hyperlink{9691715859147716436}{\texttt{@profile}} 所采取的操作。



第一行显示在 \texttt{event.jl} 的第 73 行获取了 80 次回溯，但这并不是说此行本身「昂贵」：第三行表明所有这些 80 次回溯实际上它调用的 \texttt{eval\_user\_input} 中触发的，以此类推。为了找出实际占用时间的操作，我们需要深入了解调用链。



此输出中第一个「重要」的行是这行：




\begin{lstlisting}
52 ./REPL[1]:2; myfunc()
\end{lstlisting}



\texttt{REPL} 指的是我们在 REPL 中定义了 \texttt{myfunc}，而不是把它放在文件中；如果我们使用文件，这将显示文件名。\texttt{[1]} 表示函数 \texttt{myfunc} 是在当前 REPL 会话中第一个进行求值的表达式。\texttt{myfunc()} 的第 2 行包含对 \texttt{rand} 的调用，（80 次中）有 52 次回溯发生在该行。在此之下，你可以看到在 \texttt{dSFMT.jl} 中对 \texttt{dsfmt\_fill\_array\_close\_open!} 的调用。



更进一步，你会看到：




\begin{lstlisting}
28 ./REPL[1]:3; myfunc()
\end{lstlisting}



\texttt{myfunc} 的第 3 行包含对 \texttt{maximum} 的调用，（80 次中）有 28 次回溯发生在这里。在此之下，你可以看到对于这种类型的输入数据，\texttt{maximum} 函数中执行的耗时操作在 \texttt{base/reduce.jl} 中的具体位置。



总的来说，我们可以暂时得出结论，生成随机数的成本大概是找到最大元素的两倍。通过收集更多样本，我们可以增加对此结果的信心：




\begin{minted}{jlcon}
julia> @profile (for i = 1:100; myfunc(); end)

julia> Profile.print()
[....]
 3821 ./REPL[1]:2; myfunc()
  3511 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type...
   3511 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr...
  310  ./random.jl:278; rand
   [....]
 2893 ./REPL[1]:3; myfunc()
  2893 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinea...
   [....]
\end{minted}



一般来说，如果你在某行上收集到 \texttt{N} 个样本，那你可以预期其有 \texttt{sqrt(N)} 的不确定性（忽略其它噪音源，比如计算机在其它任务上的繁忙程度）。这个规则的主要例外是垃圾收集，它很少运行但往往成本高昂。（因为 Julia 的垃圾收集器是用 C 语言编写的，此类事件可使用下文描述的 \texttt{C=true} 输出模式来检测，或者使用 \href{https://github.com/timholy/ProfileView.jl}{ProfileView.jl} 来检测。）



这展示了默认的「树」形转储；另一种选择是「扁平」形转储，它会累积与其嵌套无关的计数：




\begin{minted}{jlcon}
julia> Profile.print(format=:flat)
 Count File          Line Function
  6714 ./<missing>     -1 anonymous
  6714 ./REPL.jl       66 eval_user_input(::Any, ::Base.REPL.REPLBackend)
  6714 ./REPL.jl       97 macro expansion
  3821 ./REPL[1]        2 myfunc()
  2893 ./REPL[1]        3 myfunc()
  6714 ./REPL[7]        1 macro expansion
  6714 ./boot.jl      235 eval(::Module, ::Any)
  3511 ./dSFMT.jl      84 dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_s...
  6714 ./event.jl      73 (::Base.REPL.##1#2{Base.REPL.REPLBackend})()
  6714 ./profile.jl    23 macro expansion
  3511 ./random.jl    431 rand!(::MersenneTwister, ::Array{Float64,3}, ::In...
   310 ./random.jl    277 rand
   310 ./random.jl    278 rand
   310 ./random.jl    366 rand
   310 ./random.jl    369 rand
  2893 ./reduce.jl    270 _mapreduce(::Base.#identity, ::Base.#scalarmax, :...
     5 ./reduce.jl    420 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
   253 ./reduce.jl    426 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
  2592 ./reduce.jl    428 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
    43 ./reduce.jl    429 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
\end{minted}



如果你的代码有递归，那么可能令人困惑的就是「子」函数中的行的累积计数可以多于总回溯次数。考虑以下函数定义：




\begin{minted}{julia}
dumbsum(n::Integer) = n == 1 ? 1 : 1 + dumbsum(n-1)
dumbsum3() = dumbsum(3)
\end{minted}



如果你要分析 \texttt{dumbsum3}，并在执行 \texttt{dumbsum(1)} 时执行了回溯，那么该回溯将如下所示：




\begin{minted}{julia}
dumbsum3
    dumbsum(3)
        dumbsum(2)
            dumbsum(1)
\end{minted}



因此，即使父函数只获得 1 个计数，这个子函数也会获得 3 个计数。「树」形表示使这更清晰，因此（以及其它原因）可能是查看结果的最实用方法。



\hypertarget{11920246320852784321}{}


\section{结果累积和清空}



\hyperlink{9691715859147716436}{\texttt{@profile}} 的结果会累积在一个缓冲区中；如果你在 \hyperlink{9691715859147716436}{\texttt{@profile}} 下运行多端代码，那么 \hyperlink{2955792207246042270}{\texttt{Profile.print()}} 会显示合并的结果。这可能非常有用，但有时你会想重新开始，这可通过 \hyperlink{15414823368700214048}{\texttt{Profile.clear()}}。



\hypertarget{3561003529463300631}{}


\section{用于控制性能分析结果显示的选项}



\hyperlink{2955792207246042270}{\texttt{Profile.print}} 还有一些未曾描述的选项。让我们看看完整的声明：




\begin{minted}{julia}
function print(io::IO = stdout, data = fetch(); kwargs...)
\end{minted}



我们先讨论两个位置参数，然后讨论关键字参数：



\begin{itemize}
\item \texttt{io}——允许你将结果保存到缓冲区，例如一个文件，但默认是打印到 \texttt{stdout}（控制台）。


\item \texttt{data}——包含你要分析的数据；默认情况下，它是从 \hyperlink{3578108280181558112}{\texttt{Profile.fetch()}} 中获取的，该函数从预先分配的缓冲区中拉出回溯。例如，如果你要分析性能分析器，可以说：


\begin{minted}{julia}
data = copy(Profile.fetch())
Profile.clear()
@profile Profile.print(stdout, data) # Prints the previous results
Profile.print()                      # Prints results from Profile.print()
\end{minted}

\end{itemize}


关键字参数可以是以下参数的任意组合：



\begin{itemize}
\item \texttt{format}——上文已经介绍，确定是使用（默认值，\texttt{:tree}）还是不使用（\texttt{:flat}）缩进来表示其树形结构。


\item \texttt{C}——如果为 \texttt{true}，则显示 C 和 Fortran 代码中的回溯（通常它们被排除在外）。请尝试用 \texttt{Profile.print(C = true)} 运行介绍性示例。这对于判断是 Julia 代码还是 C 代码导致了性能瓶颈非常有帮助；设置 \texttt{C = true} 也可提高嵌套的可解释性，代价是更长的性能分析转储。


\item \texttt{combine}——某些代码行包含多个操作；例如，\texttt{s += A[i]} 包含一个数组引用（\texttt{A[i]}）和一个求和操作。这些操作在所生成的机器代码中对应不同的行，因此回溯期间可能会在此行中捕获两个或以上地址。\texttt{combine = true} 把它们混合在一起，可能你通常想要这样，但使用 \texttt{combine = false}，你可为每个唯一的指令指针单独生成输出。


\item \texttt{maxdepth}——限制 \texttt{:tree} 格式中深度大于 \texttt{maxdepth} 的帧。


\item   * \texttt{sortedby}——控制 \texttt{:flat} 格式中的次序。为 \texttt{:filefuncline}（默认值）时按源代码行排序，而为 \texttt{:count} 时按收集的样本数排序。


\item \texttt{noisefloor}——限制低于样本的启发式噪音下限的帧（只适用于格式 \texttt{:tree}）。尝试此选项的建议值是 2.0（默认值是 0）。此参数会隐藏 \texttt{n <= noisefloor * √N} 的样本，其中 \texttt{n} 是该行上的样本数，\texttt{N} 是被调用者的样本数。


\item \texttt{mincount}——限制出现次数少于 \texttt{mincount} 的帧。

\end{itemize}


文件/函数名有时会被（用 \texttt{...}）截断，缩进也有可能在开头用 \texttt{+n} 截断，其中 \texttt{n} 是在空间充足的情况下应该插入的额外空格数。如果你想要深层嵌套代码的完整性能分析，保存到文件并在 \hyperlink{13454403377667762339}{\texttt{IOContext}} 中使用宽的 \texttt{displaysize} 通常是个好主意：




\begin{minted}{julia}
open("/tmp/prof.txt", "w") do s
    Profile.print(IOContext(s, :displaysize => (24, 500)))
end
\end{minted}



\hypertarget{5894887495287635363}{}


\section{配置}



\hyperlink{9691715859147716436}{\texttt{@profile}} 只是累积回溯，在你调用 \hyperlink{2955792207246042270}{\texttt{Profile.print()}} 时才会进行性能分析。对于长时间运行的计算，完全有可能把用于存储回溯的预分配缓冲区填满。如果发生这种情况，回溯会停止，但你的计算会继续。因此，你也许会丢失一些重要的性能分析数据（当发生这种情况时，你会受到警告）。



你可通过以下方式获取和配置相关参数：




\begin{minted}{julia}
Profile.init() # returns the current settings
Profile.init(n = 10^7, delay = 0.01)
\end{minted}



\texttt{n} 是能够存储的指令指针总数，默认值为 \texttt{10{\textasciicircum}6}。如果通常的回溯是 20 个指令指针，那么可以收集 50000 次回溯，这意味着统计不确定性少于 1\%。这对于大多数应用来说可能已经足够了。



因此，你更可能需要修改 \texttt{delay}，它以秒为单位，设置在快照之间 Julia 用于执行所请求计算的时长。长时间运行的工作可能不需要经常回溯。默认设置为 \texttt{delay = 0.001}。当然，你可以减少和增加 delay；但是，一旦 delay 接近执行一次回溯所需的时间（在作者的笔记本上约为 30 微妙），性能分析的开销就会增加。



\hypertarget{10992983602239333354}{}


\section{内存分配分析}



减少内存分配是提高性能的最常用技术之一。内存分配总量可以用 \hyperlink{8029752041511656628}{\texttt{@time}} 和 \hyperlink{5377755456008435782}{\texttt{@allocated}}，触发内存分配的特定行通常可以通过这些行产生的垃圾分配成本从性能分析中推断出来。但是，直接测量每行代码的内存分配总量有时会更高效。



为了逐行测量内存分配，启动 Julia 时请使用命令行选项 \texttt{--track-allocation=<setting>}，该选项的可选值有 \texttt{none}（默认值，不测量内存分配）、\texttt{user}（测量除 Julia core 代码之外的所有代码的内存分配）或 \texttt{all}（测量 Julia 代码中每一行的内存分配）。这会为每行已编译的代码测量内存。在退出 Julia 时，累积的结果将写入到文本文件中，此文本文件名称为该文件名称后加 \texttt{.mem}，并与源文件位于同一目录下。该文件的每行列出内存分配的总字节数。\href{https://github.com/JuliaCI/Coverage.jl}{\texttt{Coverage} 包}包括了一些基本分析工具，例如，按照内存分配的字节数对行进行排序的工具。



在解释结果时，有一些需要注意的细节。在 \texttt{user} 设定下，直接从 REPL 调用的任何函数的第一行都将会显示内存分配，这是由发生在 REPL 代码本身的事件造成的。更重要的是，JIT 编译也会添加内存分配计数，因为 Julia 的编译器大部分是用 Julia 编写的（并且编译通常需要内存分配）。建议的分析过程是先通过执行待分析的所有命令来强制编译，然后调用 \hyperlink{12697816172521511938}{\texttt{Profile.clear\_malloc\_data()}} 来重置所有内存计数器。最后，执行所需的命令并退出 Julia 以触发 \texttt{.mem} 文件的生成。



\hypertarget{7694373006850867155}{}


\section{外部性能分析}



Julia 目前支持的外部性能分析工具有 \texttt{Intel VTune}、\texttt{OProfile} 和 \texttt{perf}。



根据你所选择的工具，编译时请在 \texttt{Make.user} 中将 \texttt{USE\_INTEL\_JITEVENTS}、\texttt{USE\_OPROFILE\_JITEVENTS} 和 \texttt{USE\_PERF\_JITEVENTS} 设置为 1。多个上述编译标志是支持的。



在运行 Julia 前，请将环境变量 \texttt{ENABLE\_JITPROFILING} 设置为 1。



现在，你可以通过多种方式使用这些工具！例如，可以使用 \texttt{OProfile} 来尝试做个简单的记录：




\begin{lstlisting}
>ENABLE_JITPROFILING=1 sudo operf -Vdebug ./julia test/fastmath.jl
>opreport -l `which ./julia`
\end{lstlisting}



或与 \texttt{perf} 类似：




\begin{lstlisting}
$ ENABLE_JITPROFILING=1 perf record -o /tmp/perf.data --call-graph dwarf -k 1 ./julia /test/fastmath.jl
$ perf inject --jit --input /tmp/perf.data --output /tmp/perf-jit.data
$ perf report --call-graph -G -i /tmp/perf-jit.data
\end{lstlisting}



你可以测量关于程序的更多有趣数据，若要获得详尽的列表，请阅读 \href{http://www.brendangregg.com/perf.html}{Linux perf 示例页面}。



请记住，perf 会为每次执行保存一个 \texttt{perf.data} 文件，即使对于小程序，它也可能变得非常大。此外，perf LLVM 模块会将调试对象保存在 \texttt{{\textasciitilde}/.debug/jit} 中，记得经常清理该文件夹。



\hypertarget{5468549229850022418}{}


\chapter{栈跟踪}



\texttt{StackTraces} 模块提供了简单的栈跟踪功能，这些栈跟踪信息既可读又易于编程使用。



\hypertarget{18224694583461024319}{}


\section{查看栈跟踪}



获取栈跟踪信息的主要函数是 \hyperlink{11964270650763140298}{\texttt{stacktrace}}：




\begin{minted}{jlcon}
6-element Array{Base.StackTraces.StackFrame,1}:
 top-level scope
 eval at boot.jl:317 [inlined]
 eval(::Module, ::Expr) at REPL.jl:5
 eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85
 macro expansion at REPL.jl:116 [inlined]
 (::getfield(REPL, Symbol("##28#29")){REPL.REPLBackend})() at event.jl:92
\end{minted}



调用 \hyperlink{11964270650763140298}{\texttt{stacktrace()}} 会返回一个 \hyperlink{16824886840215699957}{\texttt{StackTraces.StackFrame}} 数组。为了使用方便，可以用 \hyperlink{12289172590874430030}{\texttt{StackTraces.StackTrace}} 来代替 \texttt{Vector\{StackFrame\}}。下面例子中 \texttt{[...]} 的意思是这部分输出的内容可能会根据代码的实际执行情况而定。




\begin{minted}{jlcon}
julia> example() = stacktrace()
example (generic function with 1 method)

julia> example()
7-element Array{Base.StackTraces.StackFrame,1}:
 example() at REPL[1]:1
 top-level scope
 eval at boot.jl:317 [inlined]
[...]

julia> @noinline child() = stacktrace()
child (generic function with 1 method)

julia> @noinline parent() = child()
parent (generic function with 1 method)

julia> grandparent() = parent()
grandparent (generic function with 1 method)

julia> grandparent()
9-element Array{Base.StackTraces.StackFrame,1}:
 child() at REPL[3]:1
 parent() at REPL[4]:1
 grandparent() at REPL[5]:1
[...]
\end{minted}



注意，在调用 \hyperlink{11964270650763140298}{\texttt{stacktrace()}} 的时，通常会出现 \texttt{eval at boot.jl} 这帧。 当从 REPL 里调用 \hyperlink{11964270650763140298}{\texttt{stacktrace()}} 的时候，还会显示 \texttt{REPL.jl} 里的一些额外帧，就像下面一样：




\begin{minted}{jlcon}
julia> example() = stacktrace()
example (generic function with 1 method)

julia> example()
7-element Array{Base.StackTraces.StackFrame,1}:
 example() at REPL[1]:1
 top-level scope
 eval at boot.jl:317 [inlined]
 eval(::Module, ::Expr) at REPL.jl:5
 eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85
 macro expansion at REPL.jl:116 [inlined]
 (::getfield(REPL, Symbol("##28#29")){REPL.REPLBackend})() at event.jl:92
\end{minted}



\hypertarget{17184729199221037868}{}


\section{抽取有用信息}



每个 \hyperlink{16824886840215699957}{\texttt{StackTraces.StackFrame}} 都会包含函数名，文件名，代码行数，lambda 信息，一个用于确认此帧是否被内联的标帜，一个用于确认函数是否为 C 函数的标帜（在默认的情况下 C 函数不会出现在栈跟踪信息中）以及一个用整数表示的指针，它是由 \hyperlink{6187626674327343338}{\texttt{backtrace}} 返回的：




\begin{minted}{jlcon}
julia> frame = stacktrace()[3]
eval(::Module, ::Expr) at REPL.jl:5

julia> frame.func
:eval

julia> frame.file
Symbol("~/julia/usr/share/julia/stdlib/v0.7/REPL/src/REPL.jl")

julia> frame.line
5

julia> frame.linfo
MethodInstance for eval(::Module, ::Expr)

julia> frame.inlined
false

julia> frame.from_c
false

julia> frame.pointer
0x00007f92d6293171
\end{minted}



这使得我们可以通过编程的方式将栈跟踪信息用于打印日志，处理错误以及其它更多用途。



\hypertarget{6556726272179975372}{}


\section{错误处理}



能够轻松地获取当前调用栈的状态信息在许多场景下都很有用，但最直接的应用是错误处理和调试。




\begin{minted}{jlcon}
julia> @noinline bad_function() = undeclared_variable
bad_function (generic function with 1 method)

julia> @noinline example() = try
           bad_function()
       catch
           stacktrace()
       end
example (generic function with 1 method)

julia> example()
7-element Array{Base.StackTraces.StackFrame,1}:
 example() at REPL[2]:4
 top-level scope
 eval at boot.jl:317 [inlined]
[...]
\end{minted}



你可能已经注意到了，上述例子中第一个栈帧指向了\hyperlink{11964270650763140298}{\texttt{stacktrace}}被调用的第 4 行，而不是 \emph{bad\_function} 被调用的第 2 行，且完全没有出现 \texttt{bad\_function} 的栈帧。这是也是可以理解的，因为 \hyperlink{11964270650763140298}{\texttt{stacktrace}} 是在 \emph{catch} 的上下文中被调用的。虽然在这个例子中很容易查找到错误的真正源头，但在复杂的情况下查找错误源并不是一件容易的事。



为了补救，我们可以将 \hyperlink{98342946516168163}{\texttt{catch\_backtrace}} 的输出传递给 \hyperlink{11964270650763140298}{\texttt{stacktrace}}。\hyperlink{98342946516168163}{\texttt{catch\_backtrace}} 会返回最近发生异常的上下文中的栈信息，而不是返回当前上下文中的调用栈信息。




\begin{minted}{jlcon}
julia> @noinline bad_function() = undeclared_variable
bad_function (generic function with 1 method)

julia> @noinline example() = try
           bad_function()
       catch
           stacktrace(catch_backtrace())
       end
example (generic function with 1 method)

julia> example()
8-element Array{Base.StackTraces.StackFrame,1}:
 bad_function() at REPL[1]:1
 example() at REPL[2]:2
[...]
\end{minted}



可以看到，现在栈跟踪会显示正确的行号以及之前缺失的栈帧。




\begin{minted}{jlcon}
julia> @noinline child() = error("Whoops!")
child (generic function with 1 method)

julia> @noinline parent() = child()
parent (generic function with 1 method)

julia> @noinline function grandparent()
           try
               parent()
           catch err
               println("ERROR: ", err.msg)
               stacktrace(catch_backtrace())
           end
       end
grandparent (generic function with 1 method)

julia> grandparent()
ERROR: Whoops!
10-element Array{Base.StackTraces.StackFrame,1}:
 error at error.jl:33 [inlined]
 child() at REPL[1]:1
 parent() at REPL[2]:1
 grandparent() at REPL[3]:3
[...]
\end{minted}



\hypertarget{11436331555895367891}{}


\section{异常栈与\texttt{current\_exceptions}}



\begin{quote}
\textbf{Julia 1.1}

异常栈需要 Julia 1.1 及以上版本。

\end{quote}


在处理一个异常时，后续的异常同样可能被抛出。观察这些异常对定位问题的源头极有帮助。Julia runtime 支持将每个异常发生后推入一个内部的\emph{异常栈}。当代码正常退出一个\texttt{catch}语句，可认为所有被推入栈中的异常在相应的\texttt{try}语句中被成功处理并已从栈中移除。



存放当前异常的栈可通过测试函数 \href{@ref}{\texttt{current\_exceptions}} 获取，例如




\begin{minted}{jlcon}
julia> try
           error("(A) The root cause")
       catch
           try
               error("(B) An exception while handling the exception")
           catch
               for (exc, bt) in current_exceptions()
                   showerror(stdout, exc, bt)
                   println(stdout)
               end
           end
       end
(A) The root cause
Stacktrace:
 [1] error(::String) at error.jl:33
 [2] top-level scope at REPL[7]:2
 [3] eval(::Module, ::Any) at boot.jl:319
 [4] eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85
 [5] macro expansion at REPL.jl:117 [inlined]
 [6] (::getfield(REPL, Symbol("##26#27")){REPL.REPLBackend})() at task.jl:259
(B) An exception while handling the exception
Stacktrace:
 [1] error(::String) at error.jl:33
 [2] top-level scope at REPL[7]:5
 [3] eval(::Module, ::Any) at boot.jl:319
 [4] eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85
 [5] macro expansion at REPL.jl:117 [inlined]
 [6] (::getfield(REPL, Symbol("##26#27")){REPL.REPLBackend})() at task.jl:259
\end{minted}



在本例中，根源异常（A）排在栈头，其后放置着延伸异常（B)。 在正常退出（例如，不抛出新异常）两个 catch 块后，所有异常都被移除出栈，无法访问。



异常栈被存放于发生异常的 \texttt{Task} 处。当某个任务失败，出现意料外的异常时，\texttt{current\_exceptions(task)} 可被用于观察该任务的异常栈。



\hypertarget{9581632785664784530}{}


\section{\texttt{stacktrace} 与 \texttt{backtrace} 的比较}



调用 \hyperlink{6187626674327343338}{\texttt{backtrace}} 会返回一个 \texttt{Union\{Ptr\{Nothing\}, Base.InterpreterIP\}} 的数组，可以将其传给 \hyperlink{11964270650763140298}{\texttt{stacktrace}} 函数进行转化：




\begin{minted}{jlcon}
julia> trace = backtrace()
18-element Array{Union{Ptr{Nothing}, Base.InterpreterIP},1}:
 Ptr{Nothing} @0x00007fd8734c6209
 Ptr{Nothing} @0x00007fd87362b342
 Ptr{Nothing} @0x00007fd87362c136
 Ptr{Nothing} @0x00007fd87362c986
 Ptr{Nothing} @0x00007fd87362d089
 Base.InterpreterIP(CodeInfo(:(begin
      Core.SSAValue(0) = backtrace()
      trace = Core.SSAValue(0)
      return Core.SSAValue(0)
  end)), 0x0000000000000000)
 Ptr{Nothing} @0x00007fd87362e4cf
[...]

julia> stacktrace(trace)
6-element Array{Base.StackTraces.StackFrame,1}:
 top-level scope
 eval at boot.jl:317 [inlined]
 eval(::Module, ::Expr) at REPL.jl:5
 eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85
 macro expansion at REPL.jl:116 [inlined]
 (::getfield(REPL, Symbol("##28#29")){REPL.REPLBackend})() at event.jl:92
\end{minted}



需要注意的是，\hyperlink{6187626674327343338}{\texttt{backtrace}} 返回的向量有 18 个元素，而 \hyperlink{11964270650763140298}{\texttt{stacktrace}} 返回的向量只包含6 个元素。这是因为 \hyperlink{11964270650763140298}{\texttt{stacktrace}} 在默认情况下会移除所有底层 C 函数的栈信息。如果你想显示 C 函数调用的栈帧，可以这样做：




\begin{minted}{jlcon}
julia> stacktrace(trace, true)
21-element Array{Base.StackTraces.StackFrame,1}:
 jl_apply_generic at gf.c:2167
 do_call at interpreter.c:324
 eval_value at interpreter.c:416
 eval_body at interpreter.c:559
 jl_interpret_toplevel_thunk_callback at interpreter.c:798
 top-level scope
 jl_interpret_toplevel_thunk at interpreter.c:807
 jl_toplevel_eval_flex at toplevel.c:856
 jl_toplevel_eval_in at builtins.c:624
 eval at boot.jl:317 [inlined]
 eval(::Module, ::Expr) at REPL.jl:5
 jl_apply_generic at gf.c:2167
 eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85
 jl_apply_generic at gf.c:2167
 macro expansion at REPL.jl:116 [inlined]
 (::getfield(REPL, Symbol("##28#29")){REPL.REPLBackend})() at event.jl:92
 jl_fptr_trampoline at gf.c:1838
 jl_apply_generic at gf.c:2167
 jl_apply at julia.h:1540 [inlined]
 start_task at task.c:268
 ip:0xffffffffffffffff
\end{minted}



\hyperlink{6187626674327343338}{\texttt{backtrace}} 返回的单个指针可以通过 \hyperlink{1451426077045795515}{\texttt{StackTraces.lookup}} 来转化成一组 \hyperlink{16824886840215699957}{\texttt{StackTraces.StackFrame}}：




\begin{minted}{jlcon}
julia> pointer = backtrace()[1];

julia> frame = StackTraces.lookup(pointer)
1-element Array{Base.StackTraces.StackFrame,1}:
 jl_apply_generic at gf.c:2167

julia> println("The top frame is from $(frame[1].func)!")
The top frame is from jl_apply_generic!
\end{minted}



\hypertarget{3908315974291496321}{}


\chapter{性能建议}



下面几节简要地介绍了一些使 Julia 代码运行得尽可能快的技巧。



\hypertarget{13114631835196295196}{}


\section{影响性能的关键代码应该在函数内部}



任何对性能至关重要的代码都应该在函数内部。 由于 Julia 编译器的工作方式，函数内部的代码往往比顶层代码运行得更快。



函数的使用不仅对性能很重要：函数更可重用和可测试，并阐明正在执行哪些步骤以及它们的输入和输出是什么，[编写函数，而不仅仅是脚本]（@ref）也是 Julia 的风格指南。



函数应该接收参数，而不是直接对全局变量进行操作，请参阅下一点。



\hypertarget{14492220707033250800}{}


\section{避免全局变量}



全局变量的值和类型随时都会发生变化， 这使编译器难以优化使用全局变量的代码。 变量应该是局部的，或者尽可能作为参数传递给函数。



我们发现全局变量经常是常量，将它们声明为常量可大幅提升性能。




\begin{minted}{julia}
const DEFAULT_VAL = 0
\end{minted}



对于非常量的全局变量可以通过在使用的时候标注它们的类型来优化。




\begin{minted}{julia}
global x = rand(1000)

function loop_over_global()
    s = 0.0
    for i in x::Vector{Float64}
        s += i
    end
    return s
end
\end{minted}



一个更好的编程风格是将变量作为参数传给函数。这样可以使得代码更易复用，以及清晰的展示函数的输入和输出。



\begin{quote}
\textbf{Note}

所有的REPL中的代码都是在全局作用域中求值的，因此在顶层的变量的定义与赋值都会成为一个\textbf{全局}变量。在模块的顶层作用域定义的变量也是全局变量。

\end{quote}


在下面的REPL会话中：




\begin{minted}{jlcon}
julia> x = 1.0
\end{minted}



等价于：




\begin{minted}{jlcon}
julia> global x = 1.0
\end{minted}



因此，所有上文关于性能问题的讨论都适用于它们。



\hypertarget{1547856480373223464}{}


\section{使用 \texttt{@time}评估性能以及注意内存分配}



\hyperlink{8029752041511656628}{\texttt{@time}} 宏是一个有用的性能评估工具。这里我们将重复上面全局变量的例子，但是这次移除类型声明：




\begin{minted}{jlcon}
julia> x = rand(1000);

julia> function sum_global()
           s = 0.0
           for i in x
               s += i
           end
           return s
       end;

julia> @time sum_global()
  0.010414 seconds (9.07 k allocations: 373.448 KiB, 98.40% compilation time)
493.6199223951192

julia> @time sum_global()
  0.000108 seconds (3.49 k allocations: 70.156 KiB)
493.6199223951192
\end{minted}



在第一次调用（\texttt{@time sum\_global()}）时，函数被编译。 （如果不在此会话中使用 \hyperlink{8029752041511656628}{\texttt{@time}}，它还会编译计时所需的函数。）你不用把此次运行的结果放在心上。对于第二次运行，请注意，除了报告时间外，它还表明分配了大量内存。 我们在这里只是计算 64 位浮点数向量中所有元素的总和，因此不需要分配内存（至少不是在堆上，这就是 \texttt{@time} 报告的内容）。



预料之外的内存分配几乎总是表示你的代码存在问题，通常是类型稳定性问题或创建了许多小的临时数组。 因此，除了分配本身之外，你的函数的代码很可能远非最优。请认真对待此类迹象并遵循以下建议。



如果我们改为将 \texttt{x} 作为参数传递给函数，它不再分配内存（下面报告的分配是由于在全局范围内运行 \texttt{@time} 宏）并且在第一次调用后明显更快：




\begin{minted}{jlcon}
julia> x = rand(1000);

julia> function sum_arg(x)
           s = 0.0
           for i in x
               s += i
           end
           return s
       end;

julia> @time sum_arg(x)
  0.007971 seconds (3.96 k allocations: 200.171 KiB, 99.83% compilation time)
493.6199223951192

julia> @time sum_arg(x)
  0.000003 seconds (1 allocation: 16 bytes)
493.6199223951192
\end{minted}



看到的 1 allocation 来自在全局范围内运行 \texttt{@time} 宏本身。 如果我们改为在函数中运行计时，我们可以看到确实没有执行任何分配：




\begin{minted}{jlcon}
julia> time_sum(x) = @time sum_arg(x);

julia> time_sum(x)
  0.000001 seconds
493.6199223951192
\end{minted}



在某些情况下，你的函数可能需要将分配内存作为其操作的一部分，这比上面的简单例子复杂的多。 在这种情况下，请考虑使用下面的 \hyperlink{11178925956438684264}{工具} 之一来诊断问题，或者编写一个将分配内存与算法方面分开的函数版本（请参阅 \href{@ref Pre-allocating outputs}{输出预分配}）。



\begin{quote}
\textbf{Note}

对于更严格的基准测试，请考虑 \href{https://github.com/JuliaCI/BenchmarkTools.jl}{BenchmarkTools.jl} 包，该包会多次评估函数以减少噪音。

\end{quote}


\hypertarget{14350444000650775715}{}


\section{工具}



Julia 及其包生态系统包括可以帮助您诊断问题和提高代码性能的工具：



\begin{itemize}
\item \hyperlink{4960174996145365052}{Profiling} 允许你测量正在运行的代码的性能并识别作为瓶颈的行。对于复杂的项目，\href{https://github.com/timholy/ProfileView.jl}{ProfileView} 包可以帮助你可视化分析结果。


\item \href{https://github.com/JunoLab/Traceur.jl}{Traceur} 包可以帮助你找到代码中常见的性能问题。


\item 预期之外的大内存分配——正如 \hyperlink{8029752041511656628}{\texttt{@time}}、\hyperlink{5377755456008435782}{\texttt{@allocated}} 或 Profiler（通过调用垃圾收集例程）所报告的那样——暗示你的代码可能有问题。 如果你没有看到分配的其他原因，请怀疑是类型问题。还可以使用 \texttt{--track allocation=user} 选项启动 Julia 并检查生成的 \texttt{*.mem} 文件以查看有关这些分配发生位置的信息。 参见\hyperlink{11696223907232256803}{内存分配分析}。


\item \texttt{@code\_warntype} 生成代码的表示形式，这有助于查找导致类型不确定性的表达式。 请参阅下面的 \hyperlink{8092893264277772840}{\texttt{@code\_warntype}}。

\end{itemize}


\hypertarget{12159424404022697469}{}


\section{避免使用抽象类型参数的容器}



使用参数化类型（包括数组）时，最好尽可能避免使用抽象类型进行参数化。



考虑如下：




\begin{minted}{jlcon}
julia> a = Real[]
Real[]

julia> push!(a, 1); push!(a, 2.0); push!(a, π)
3-element Vector{Real}:
 1
 2.0
 π = 3.1415926535897...
\end{minted}



因为 \texttt{a} 是一个抽象类型 \hyperlink{6175959395021454412}{\texttt{Real}} 的数组，所以它能够保存任何 \texttt{Real} 值。 由于\texttt{Real}对象允许具有任意大小和结构，因此\texttt{a}必须表示为指向单独分配的\texttt{Real}对象的指针数组。 但是，如果我们只允许相同类型的数字，例如 \hyperlink{5027751419500983000}{\texttt{Float64}},  \texttt{a} 可以更有效地存储：




\begin{minted}{jlcon}
julia> a = Float64[]
Float64[]

julia> push!(a, 1); push!(a, 2.0); push!(a,  π)
3-element Vector{Float64}:
 1.0
 2.0
 3.141592653589793
\end{minted}



把数字赋值给\texttt{a}会即时将数字转换成\texttt{Float64}并且\texttt{a}会按照64位浮点数值的连续的块来储存，这就能高效地处理。



如果无法避免使用抽象值类型的容器，有时最好使用\texttt{Any}参数化以避免运行时类型检查。 例如。 \texttt{IdDict\{Any, Any\}} 的性能优于 \texttt{IdDict\{Type, Vector\}}。



也请参见在\href{@ref}{参数类型}下的讨论。



\hypertarget{11271598028486730305}{}


\section{类型声明}



在有可选类型声明的语言中，添加声明是使代码运行更快的原则性方法。在Julia中\emph{并不是}这种情况。在Julia中，编译器都知道所有的函数参数，局部变量和表达式的类型。但是，有一些特殊的情况下声明是有帮助的。



\hypertarget{17004910976199348766}{}


\subsection{避免有抽象类型的字段}



类型能在不指定其字段的类型的情况下被声明：




\begin{minted}{jlcon}
julia> struct MyAmbiguousType
           a
       end
\end{minted}



这就允许\texttt{a}可以是任意类型。这经常很有用，但是有个缺点：对于类型\texttt{MyAmbiguousType}的对象，编译器不能够生成高性能的代码。原因是编译器使用对象的类型，而非值，来确定如何构建代码。不幸的是，几乎没有信息可以从类型\texttt{MyAmbiguousType}的对象中推导出来：




\begin{minted}{jlcon}
julia> b = MyAmbiguousType("Hello")
MyAmbiguousType("Hello")

julia> c = MyAmbiguousType(17)
MyAmbiguousType(17)

julia> typeof(b)
MyAmbiguousType

julia> typeof(c)
MyAmbiguousType
\end{minted}



\texttt{b} 和 \texttt{c} 的值具有相同类型，但它们在内存中的数据的底层表示十分不同。即使你只在字段 \texttt{a} 中存储数值，\hyperlink{6609065134969660118}{\texttt{UInt8}} 的内存表示与 \hyperlink{5027751419500983000}{\texttt{Float64}} 也是不同的，这也意味着 CPU 需要使用两种不同的指令来处理它们。因为该类型中不提供所需的信息，所以必须在运行时进行这些判断。而这会降低性能。



通过声明 \texttt{a} 的类型，你能够做得更好。这里我们关注 \texttt{a} 可能是几种类型中任意一种的情况，在这种情况下，自然的一个解决方法是使用参数。例如：




\begin{minted}{jlcon}
julia> mutable struct MyType{T<:AbstractFloat}
           a::T
       end
\end{minted}



比下面这种更好




\begin{minted}{jlcon}
julia> mutable struct MyStillAmbiguousType
           a::AbstractFloat
       end
\end{minted}



因为第一种通过包装对象的类型指定了 \texttt{a} 的类型。 例如：




\begin{minted}{jlcon}
julia> m = MyType(3.2)
MyType{Float64}(3.2)

julia> t = MyStillAmbiguousType(3.2)
MyStillAmbiguousType(3.2)

julia> typeof(m)
MyType{Float64}

julia> typeof(t)
MyStillAmbiguousType
\end{minted}



字段 \texttt{a} 的类型可以很容易地通过 \texttt{m} 的类型确定，而不是通过 \texttt{t} 的类型确定。事实上，在 \texttt{t} 中是可以改变字段 \texttt{a} 的类型的：




\begin{minted}{jlcon}
julia> typeof(t.a)
Float64

julia> t.a = 4.5f0
4.5f0

julia> typeof(t.a)
Float32
\end{minted}



反之，一旦 \texttt{m} 被构建出来，\texttt{m.a} 的类型就不能够更改了。




\begin{minted}{jlcon}
julia> m.a = 4.5f0
4.5f0

julia> typeof(m.a)
Float64
\end{minted}



\texttt{m.a} 的类型是通过 \texttt{m} 的类型得知这一事实加上它的类型不能改变在函数中改变这一事实，这两者使得对于像 \texttt{m} 这样的对象编译器可以生成高度优化后的代码，但是对 \texttt{t} 这样的对象却不可以。 当然，如果我们将 \texttt{m} 构造成一个具体类型，那么这两者都可以。我们可以通过明确地使用一个抽象类型去构建它来破坏这一点：




\begin{minted}{jlcon}
julia> m = MyType{AbstractFloat}(3.2)
MyType{AbstractFloat}(3.2)

julia> typeof(m.a)
Float64

julia> m.a = 4.5f0
4.5f0

julia> typeof(m.a)
Float32
\end{minted}



对于一个实际的目的来说，这样的对象表现起来和那些 \texttt{MyStillAmbiguousType} 的对象一模一样。



比较为一个简单函数生成的代码的绝对数量是十分有指导意义的，




\begin{minted}{julia}
func(m::MyType) = m.a+1
\end{minted}



使用




\begin{minted}{julia}
code_llvm(func, Tuple{MyType{Float64}})
code_llvm(func, Tuple{MyType{AbstractFloat}})
\end{minted}



由于长度的原因，代码的结果没有在这里显示出来，但是你可能会希望自己去验证这一点。因为在第一种情况中，类型被完全指定了，在运行时，编译器不需要生成任何代码来决定类型。这就带来了更短和更快的代码。



\hypertarget{1665323452340421493}{}


\subsection{避免使用带抽象容器的字段}



上面的做法同样也适用于容器的类型：




\begin{minted}{jlcon}
julia> struct MySimpleContainer{A<:AbstractVector}
           a::A
       end

julia> struct MyAmbiguousContainer{T}
           a::AbstractVector{T}
       end
\end{minted}



例如:




\begin{minted}{jlcon}
julia> c = MySimpleContainer(1:3);

julia> typeof(c)
MySimpleContainer{UnitRange{Int64}}

julia> c = MySimpleContainer([1:3;]);

julia> typeof(c)
MySimpleContainer{Vector{Int64}}

julia> b = MyAmbiguousContainer(1:3);

julia> typeof(b)
MyAmbiguousContainer{Int64}

julia> b = MyAmbiguousContainer([1:3;]);

julia> typeof(b)
MyAmbiguousContainer{Int64}
\end{minted}



对于 \texttt{MySimpleContainer} 来说，它被它的类型和参数完全确定了，因此编译器能够生成优化过的代码。在大多数实例中，这点能够实现。



尽管编译器现在可以将它的工作做得非常好，但是还是有\textbf{你}可能希望你的代码能够能够根据 \texttt{a} 的\textbf{元素类型}做不同的事情的时候。通常达成这个目的最好的方式是将你的具体操作 (here, \texttt{foo}) 打包到一个独立的函数中。




\begin{minted}{jlcon}
julia> function sumfoo(c::MySimpleContainer)
           s = 0
           for x in c.a
               s += foo(x)
           end
           s
       end
sumfoo (generic function with 1 method)

julia> foo(x::Integer) = x
foo (generic function with 1 method)

julia> foo(x::AbstractFloat) = round(x)
foo (generic function with 2 methods)
\end{minted}



这使事情变得简单，同时也允许编译器在所有情况下生成经过优化的代码。



但是，在某些情况下，你可能需要声明外部函数的不同版本，这可能是为了不同的元素类型，也可能是为了 \texttt{MySimpleContainer} 中的字段 \texttt{a} 所具有的不同 \texttt{AbstractVector} 类型。你可以这样做：




\begin{minted}{jlcon}
julia> function myfunc(c::MySimpleContainer{<:AbstractArray{<:Integer}})
           return c.a[1]+1
       end
myfunc (generic function with 1 method)

julia> function myfunc(c::MySimpleContainer{<:AbstractArray{<:AbstractFloat}})
           return c.a[1]+2
       end
myfunc (generic function with 2 methods)

julia> function myfunc(c::MySimpleContainer{Vector{T}}) where T <: Integer
           return c.a[1]+3
       end
myfunc (generic function with 3 methods)
\end{minted}




\begin{minted}{jlcon}
julia> myfunc(MySimpleContainer(1:3))
2

julia> myfunc(MySimpleContainer(1.0:3))
3.0

julia> myfunc(MySimpleContainer([1:3;]))
4
\end{minted}



\hypertarget{18349216047452588444}{}


\subsection{对从无类型位置获取的值进行类型注释}



使用可能包含任何类型的值的数据结构（如类型为 \texttt{Array\{Any\}} 的数组）经常是很方便的。但是，如果你正在使用这些数据结构之一，并且恰巧知道某个元素的类型，那么让编译器也知道这一点会有所帮助：




\begin{minted}{julia}
function foo(a::Array{Any,1})
    x = a[1]::Int32
    b = x+1
    ...
end
\end{minted}



在这里，我们恰巧知道 \texttt{a} 的第一个元素是个 \hyperlink{10103694114785108551}{\texttt{Int32}}。留下这样的注释还有另外的好处，它将在该值不是预期类型时引发运行时错误，而这可能会更早地捕获某些错误。



在没有确切知道 \texttt{a[1]} 的类型的情况下，\texttt{x} 可以通过 \texttt{x = convert(Int32, a[1])::Int32} 来声明。使用 \hyperlink{1846942650946171605}{\texttt{convert}} 函数则允许 \texttt{a[1]} 是可转换为 \texttt{Int32} 的任何对象（比如 \texttt{UInt8}），从而通过放松类型限制来提高代码的通用性。请注意，\texttt{convert} 本身在此上下文中需要类型注释才能实现类型稳定性。这是因为除非该函数所有参数的类型都已知，否则编译器无法推导出该函数返回值的类型，即使其为 \texttt{convert}。



如果类型是抽象的或在运行时构造的，则类型注释不会增强（实际上可能会阻碍）性能。 这是因为编译器无法使用注解来特例化后续代码，并且类型检查本身需要时间。 例如，在代码中：




\begin{minted}{julia}
function nr(a, prec)
    ctype = prec == 32 ? Float32 : Float64
    b = Complex{ctype}(a)
    c = (b + 1.0f0)::Complex{ctype}
    abs(c)
end
\end{minted}



\texttt{c} 的注释会损害性能。要编写涉及在运行时构造类型的高性能代码，请使用下面讨论的 \hyperlink{17509985600836810807}{函数障碍技巧}，并确保构造的类型出现在内核函数的参数类型中，以便内核操作由编译器合理地特例化。例如，在上面的代码片段中，一旦构建了 \texttt{b}，它就可以传递给另一个函数 \texttt{k}，即内核。 例如，如果函数 \texttt{k} 将 \texttt{b} 声明为类型为 \texttt{Complex\{T\}} 的参数，其中 \texttt{T} 是一个类型参数，那么出现在\texttt{k}的赋值语句中的类型注释的形式：




\begin{minted}{julia}
c = (b + 1.0f0)::Complex{T}
\end{minted}



不会降低性能（但也不会有帮助），因为编译器可以在编译 \texttt{k} 时确定 \texttt{c} 的类型。



\hypertarget{13987935381679254535}{}


\subsection{注意Julia何时避免特例化}



作为一种启发式方法，Julia 避免在三种特定情况下自动特例化参数类型参数：\texttt{Type}、\texttt{Function} 和 \texttt{Vararg}。 当在方法中使用参数时，Julia 将始终特例化，但如果参数只是传递给另一个函数，则不会。 这通常在运行时没有性能影响并且\hyperlink{14494557220692677892}{提高编译器性能}。 如果你发现它在你的案例中在运行时确实有性能影响，您可以通过向方法声明添加类型参数来触发特例化。这里有些例子：



这不会特例化：




\begin{minted}{julia}
function f_type(t)  # or t::Type
    x = ones(t, 10)
    return sum(map(sin, x))
end
\end{minted}



但是这会：




\begin{minted}{julia}
function g_type(t::Type{T}) where T
    x = ones(T, 10)
    return sum(map(sin, x))
end
\end{minted}



这些不会特例化：




\begin{minted}{julia}
f_func(f, num) = ntuple(f, div(num, 2))
g_func(g::Function, num) = ntuple(g, div(num, 2))
\end{minted}



但是这会：




\begin{minted}{julia}
h_func(h::H, num) where {H} = ntuple(h, div(num, 2))
\end{minted}



这不会特例化：




\begin{minted}{julia}
f_vararg(x::Int...) = tuple(x...)
\end{minted}



但是这会：




\begin{minted}{julia}
g_vararg(x::Vararg{Int, N}) where {N} = tuple(x...)
\end{minted}



只需要引入一个类型参数就可以强制特例化，即使其他类型不受约束。比如下面这个例子，它会特例化，并且在参数不是全部相同类型时很有用：




\begin{minted}{julia}
h_vararg(x::Vararg{Any, N}) where {N} = tuple(x...)
\end{minted}



请注意， \hyperlink{6823997547688846780}{\texttt{@code\_typed}} 和你的朋友给你的始终是特例化的代码，即使 Julia 通常不会特例化该方法调用。如果要查看更改参数类型时是否生成特例化，则需要检查 \hyperlink{5484310955311811443}{method internals}，即是否 \texttt{(@which f(...)).specializations} 包含相关参数的特例化。



\hypertarget{5154687489987486672}{}


\section{将函数拆分为多个定义}



将一个函数写成许多小的定义能让编译器直接调用最适合的代码，甚至能够直接将它内联。



这是一个真的该被写成许多小的定义的\textbf{复合函数}的例子：




\begin{minted}{julia}
using LinearAlgebra

function mynorm(A)
    if isa(A, Vector)
        return sqrt(real(dot(A,A)))
    elseif isa(A, Matrix)
        return maximum(svdvals(A))
    else
        error("mynorm: invalid argument")
    end
end
\end{minted}



这可以更简洁有效地写成：




\begin{minted}{julia}
norm(x::Vector) = sqrt(real(dot(x, x)))
norm(A::Matrix) = maximum(svdvals(A))
\end{minted}



然而，应该注意的是，编译器会十分高效地优化掉编写得如同 \texttt{mynorm} 例子的代码中的死分支。



\hypertarget{11831339210471490014}{}


\section{编写「类型稳定的」函数}



如果可能，确保函数总是返回相同类型的值是有好处的。考虑以下定义：




\begin{minted}{julia}
pos(x) = x < 0 ? 0 : x
\end{minted}



虽然这看起来挺合法的，但问题是 \texttt{0} 是一个（\texttt{Int} 类型的）整数而 \texttt{x} 可能是任何类型。于是，根据 \texttt{x} 的值，此函数可能返回两种类型中任何一种的值。这种行为是允许的，并且在某些情况下可能是合乎需要的。但它可以很容易地以如下方式修复：




\begin{minted}{julia}
pos(x) = x < 0 ? zero(x) : x
\end{minted}



还有 \hyperlink{2310843180104103470}{\texttt{oneunit}} 函数，以及更通用的 \hyperlink{374166931194490566}{\texttt{oftype(x, y)}} 函数，它返回被转换为 \texttt{x} 的类型的 \texttt{y}。



\hypertarget{6976604449962643011}{}


\section{避免更改变量类型}



类似的「类型稳定性」问题存在于在函数内重复使用的变量：




\begin{minted}{julia}
function foo()
    x = 1
    for i = 1:10
        x /= rand()
    end
    return x
end
\end{minted}



局部变量 \texttt{x} 一开始是整数，在一次循环迭代后变为浮点数（\hyperlink{4103478871488785445}{\texttt{/}} 运算符的结果）。这使得编译器更难优化循环体。有几种可能的解决方法：



\begin{itemize}
\item 使用 \texttt{x = 1.0} 初始化 \texttt{x}


\item 显式声明 \texttt{x} 的类型：\texttt{x::Float64 = 1}


\item 使用 \texttt{x = oneunit(Float64)} 进行显式的类型转换


\item 使用第一个循环迭代初始化，即 \texttt{x = 1 / rand()}，接着循环 \texttt{for i = 2:10}

\end{itemize}


\hypertarget{16258602729394793584}{}


\section{分离核心函数（又称为函数屏障）}



许多函数遵循这一模式：先执行一些设置工作，再通过多次迭代来执行核心计算。如果可行，将这些核心计算放在单独的函数中是个好主意。例如，以下做作的函数返回一个数组，其类型是随机选择的。




\begin{minted}{jlcon}
julia> function strange_twos(n)
           a = Vector{rand(Bool) ? Int64 : Float64}(undef, n)
           for i = 1:n
               a[i] = 2
           end
           return a
       end;

julia> strange_twos(3)
3-element Vector{Int64}:
 2
 2
 2
\end{minted}



它应该这么写：




\begin{minted}{jlcon}
julia> function fill_twos!(a)
           for i = eachindex(a)
               a[i] = 2
           end
       end;

julia> function strange_twos(n)
           a = Vector{rand(Bool) ? Int64 : Float64}(undef, n)
           fill_twos!(a)
           return a
       end;

julia> strange_twos(3)
3-element Vector{Int64}:
 2
 2
 2
\end{minted}



Julia 的编译器会在函数边界处针对参数类型特化代码，因此在原始的实现中循环期间无法得知 \texttt{a} 的类型（因为它是随即选择的）。于是，第二个版本通常更快，因为对于不同类型的 \texttt{a}，内层循环都可被重新编译为 \texttt{fill\_twos!} 的一部分。



第二种形式通常是更好的风格，并且可以带来更多的代码的重复利用。



这个模式在 Julia Base 的几个地方中有使用。相关的例子，请参阅 \href{https://github.com/JuliaLang/julia/blob/40fe264f4ffaa29b749bcf42239a89abdcbba846/base/abstractarray.jl\#L1205-L1206}{\texttt{abstractarray.jl}} 中的 \texttt{vcat} 和 \texttt{hcat}，或者 \hyperlink{5162290739791026948}{\texttt{fill!}} 函数，我们可使用该函数而不是编写自己的 \texttt{fill\_twos!}。



诸如 \texttt{strange\_twos} 的函数会在处理具有不确定类型的数据时出现，例如从可能包含整数、浮点数、字符串或其它内容的输入文件中加载的数据。



\hypertarget{13298146121388666827}{}


\section{具有值作为参数的类型}



比方说你想创建一个每个维度大小都是3的 \texttt{N} 维数组。这种数组可以这样创建：




\begin{minted}{jlcon}
julia> A = fill(5.0, (3, 3))
3×3 Matrix{Float64}:
 5.0  5.0  5.0
 5.0  5.0  5.0
 5.0  5.0  5.0
\end{minted}



这个方法工作得很好：编译器可以识别出来 \texttt{A} 是一个 \texttt{Array\{Float64,2\}} 因为它知道填充值 (\texttt{5.0::Float64}) 的类型和维度 (\texttt{(3, 3)::NTuple\{2,Int\}}).



但是现在打比方说你想写一个函数，在任何一个维度下，它都创建一个 3×3×... 的数组；你可能会心动地写下一个函数




\begin{minted}{jlcon}
julia> function array3(fillval, N)
           fill(fillval, ntuple(d->3, N))
       end
array3 (generic function with 1 method)

julia> array3(5.0, 2)
3×3 Matrix{Float64}:
 5.0  5.0  5.0
 5.0  5.0  5.0
 5.0  5.0  5.0
\end{minted}



这确实有用，但是（你可以自己使用 \texttt{@code\_warntype array3(5.0, 2)} 来验证）问题是输出地类型不能被推断出来：参数 \texttt{N} 是一个 \texttt{Int} 类型的\textbf{值}，而且类型推断不会（也不能）提前预测它的值。这意味着使用这个函数的结果的代码在每次获取 \texttt{A} 时都不得不保守地检查其类型；这样的代码将会是非常缓慢的。



现在，解决此类问题的一种很好的方法是使用 \hyperlink{17509985600836810807}{函数障碍技巧}。 但是，在某些情况下，你可能希望完全消除类型不稳定性。 在这种情况下，一种方法是将维度作为参数传递，例如通过 \texttt{Val\{T\}()}（参见 \href{@ref}{{\textquotedbl}Value types{\textquotedbl}}）：




\begin{minted}{jlcon}
julia> function array3(fillval, ::Val{N}) where N
           fill(fillval, ntuple(d->3, Val(N)))
       end
array3 (generic function with 1 method)

julia> array3(5.0, Val(2))
3×3 Matrix{Float64}:
 5.0  5.0  5.0
 5.0  5.0  5.0
 5.0  5.0  5.0
\end{minted}



Julia 有一个特别版本的 \texttt{ntuple}，它接受一个 \texttt{Val\{::Int\}} 实例作为第二个参数； 通过将 \texttt{N} 作为类型参数传递，你可以让编译器知道它的“值”。 因此，这个版本的 \texttt{array3} 允许编译器预测返回类型。



然而，使用这些技术可能非常微妙。 例如，如果你从这样的函数中调用 \texttt{array3} 将没有任何帮助：




\begin{minted}{julia}
function call_array3(fillval, n)
    A = array3(fillval, Val(n))
end
\end{minted}



在这里，你又一次创造了同样的问题：编译器无法猜测 \texttt{n} 是什么，所以它不知道 \texttt{Val(n)} 的 \emph{类型}。 在许多情况下，尝试使用 \texttt{Val} 但不正确地使用很容易使性能\emph{变差}。 （只有在有效地将 \texttt{Val} 与函数障碍技巧结合起来的情况下，为了使内核函数更有效，才应使用上述代码。）



一个正确使用 \texttt{Val} 的例子是这样的：




\begin{minted}{julia}
function filter3(A::AbstractArray{T,N}) where {T,N}
    kernel = array3(1, Val(N))
    filter(A, kernel)
end
\end{minted}



在此示例中，\texttt{N} 作为参数传递，因此编译器知道其“值”。 本质上，\texttt{Val(T)} 仅在 \texttt{T} 是硬编码/i字面量 (\texttt{Val(3)}) 或已在类型域中指定时才起作用。



\hypertarget{3314341132664326955}{}


\section{滥用多重派发的危险（也就是更多关于以值作为参数的类型）}



一旦一个人理解了多重派发，就会有一个倾向，即过度使用它并尝试将其用于所有事情。 例如，您可能会想象使用它来存储信息，例如




\begin{lstlisting}
struct Car{Make, Model}
    year::Int
    ...more fields...
end
\end{lstlisting}



然后派发到像 \texttt{Car\{:Honda,:Accord\}(year, args...)} 的对象上。



当存在以下任一情况，这可能是值得做的：



\begin{itemize}
\item 你需要对每个 \texttt{Car} 进行 CPU 密集型处理，如果你在编译时知道 \texttt{Make} 和 \texttt{Model}，并且将使用的不同\texttt{Make}或\texttt{Model}的总数不太大，则效率会大大提高。


\item 你需要处理相同类型的 \texttt{Car} 的同类列表，因此可以将它们全部存储在一个数组\texttt{\{Car\{:Honda,:Accord\},N\}} 中。

\end{itemize}


当后者成立时，处理此类同型数组的函数可以高效地特例化：Julia 预先知道每个元素的类型（容器中的所有对象都具有相同的具体类型），因此当函数被编译时， Julia 可以“查找”正确的方法调用（不需要在运行时检查），从而产生有效的代码来处理整个列表。



当这些都不成立时，你很可能不会获得任何好处；更糟糕的是，由此产生的“类型组合爆炸”将适得其反。 如果 \texttt{items[i+1]} 与 \texttt{item[i]} 的类型不同，Julia 必须在运行时查找类型，在方法表中搜索适当的方法，决定（通过类型交集）哪一个匹配，确定它是否已经被 JIT 编译（如果没有，则执行），然后进行调用。 本质上，你是在要求完整的类型系统和 JIT 编译机制在你自己的代码中基本上执行相当于 switch 语句或字典查找的操作。



\href{https://groups.google.com/forum/\#!msg/julia-users/jUMu9A3QKQQ/qjgVWr7vAwAJ}{在邮件列表中} 可以找到一些运行时基准比较 (1) 类型派发、(2) 字典查找和 (3) “switch”语句



也许比运行时影响更糟糕的是编译期影响：Julia 将为每个不同的 \texttt{Car\{Make, Model\}} 编译专门的函数； 如果你有成百上千个这样的类型，那么每个接受这样一个对象作为参数的函数（从你可能自己编写的自定义 \texttt{get\_year} 函数，到 Julia Base 中的通用 \texttt{push!} 函数）都将成百上千个为它编译了的变体。 这些都会增加编译代码缓存的大小、内部方法列表的长度等。对值作为参数的过度热情很容易浪费大量资源。



\hypertarget{16800011477786249644}{}


\section{沿列按内存顺序访问数组}



Julia 中的多维数组以列主序存储。这意味着数组一次堆叠一列。这可使用 \texttt{vec} 函数或语法 \texttt{[:]} 来验证，如下所示（请注意，数组的顺序是 \texttt{[1 3 2 4]}，而不是 \texttt{[1 2 3 4]}）：




\begin{minted}{jlcon}
julia> x = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia> x[:]
4-element Vector{Int64}:
 1
 3
 2
 4
\end{minted}



这种对数组进行排序的约定在许多语言中都很常见，例如 Fortran、Matlab 和 R（仅举几例）。 列优先排序的替代方法是行优先排序，在其它语言中，这是 C 和 Python (\texttt{numpy}) 采用的约定。 在遍历数组时，记住数组的顺序会对性能产生显着的影响。 要记住的一个经验法则是，对于列优先数组，第一个索引变化最快。 本质上，这意味着如果最内层的循环索引是第一个出现在切片表达式中的，则循环会更快。 请记住，使用 \texttt{:} 索引数组是一个隐式循环，它迭代访问特定维度内的所有元素； 例如，提取列比提取行更快。



考虑以下人为示例。假设我们想编写一个接收 \hyperlink{10571362059486397014}{\texttt{Vector}} 并返回方阵 \hyperlink{5448927444601277512}{\texttt{Matrix}} 的函数，所返回方阵的行或列都用输入向量的副本填充。并假设用这些副本填充的是行还是列并不重要（也许可以很容易地相应调整剩余代码）。我们至少可以想到四种方式（除了建议的调用内置函数 \hyperlink{15426606278434194584}{\texttt{repeat}}）：




\begin{minted}{julia}
function copy_cols(x::Vector{T}) where T
    inds = axes(x, 1)
    out = similar(Array{T}, inds, inds)
    for i = inds
        out[:, i] = x
    end
    return out
end

function copy_rows(x::Vector{T}) where T
    inds = axes(x, 1)
    out = similar(Array{T}, inds, inds)
    for i = inds
        out[i, :] = x
    end
    return out
end

function copy_col_row(x::Vector{T}) where T
    inds = axes(x, 1)
    out = similar(Array{T}, inds, inds)
    for col = inds, row = inds
        out[row, col] = x[row]
    end
    return out
end

function copy_row_col(x::Vector{T}) where T
    inds = axes(x, 1)
    out = similar(Array{T}, inds, inds)
    for row = inds, col = inds
        out[row, col] = x[col]
    end
    return out
end
\end{minted}



现在，我们使用相同的 \texttt{10000} 乘 \texttt{1} 的随机输入向量来对这些函数计时。




\begin{minted}{jlcon}
julia> x = randn(10000);

julia> fmt(f) = println(rpad(string(f)*": ", 14, ' '), @elapsed f(x))

julia> map(fmt, [copy_cols, copy_rows, copy_col_row, copy_row_col]);
copy_cols:    0.331706323
copy_rows:    1.799009911
copy_col_row: 0.415630047
copy_row_col: 1.721531501
\end{minted}



请注意，\texttt{copy\_cols} 比 \texttt{copy\_rows} 快得多。这与预料的一致，因为 \texttt{copy\_cols} 尊重 \texttt{Matrix} 基于列的内存布局。另外，\texttt{copy\_col\_row} 比 \texttt{copy\_row\_col} 快得多，因为它遵循我们的经验法则，即切片表达式中出现的第一个元素应该与最内层循环耦合。



\hypertarget{9465526813695170184}{}


\section{输出预分配}



如果函数返回 \texttt{Array} 或其它复杂类型，则可能需要分配内存。不幸的是，内存分配及其反面垃圾收集通常是很大的瓶颈。



有时，你可以通过预分配输出结果来避免在每个函数调用上分配内存的需要。作为一个简单的例子，比较




\begin{minted}{jlcon}
julia> function xinc(x)
           return [x, x+1, x+2]
       end;

julia> function loopinc()
           y = 0
           for i = 1:10^7
               ret = xinc(i)
               y += ret[2]
           end
           return y
       end;
\end{minted}



和




\begin{minted}{jlcon}
julia> function xinc!(ret::AbstractVector{T}, x::T) where T
           ret[1] = x
           ret[2] = x+1
           ret[3] = x+2
           nothing
       end;

julia> function loopinc_prealloc()
           ret = Vector{Int}(undef, 3)
           y = 0
           for i = 1:10^7
               xinc!(ret, i)
               y += ret[2]
           end
           return y
       end;
\end{minted}



计时结果：




\begin{minted}{jlcon}
julia> @time loopinc()
  0.529894 seconds (40.00 M allocations: 1.490 GiB, 12.14% gc time)
50000015000000

julia> @time loopinc_prealloc()
  0.030850 seconds (6 allocations: 288 bytes)
50000015000000
\end{minted}



预分配还有其它优点，例如允许调用者在算法中控制「输出」类型。在上述例子中，我们如果需要，可以传递 \texttt{SubArray} 而不是 \hyperlink{15492651498431872487}{\texttt{Array}}。



极端情况下，预分配可能会使你的代码更丑陋，所以可能需要做性能测试和一些判断。但是，对于「向量化」（逐元素）函数，方便的语法 \texttt{x .= f.(y)} 可用于具有融合循环的 in-place 操作且无需临时数组（请参阅\hyperlink{17801130558550430478}{向量化函数的点语法}）。



\hypertarget{12965993905966303435}{}


\section{点语法：融合向量化操作}



Julia 有特殊的\hyperlink{17801130558550430478}{点语法}，它可以将任何标量函数转换为「向量化」函数调用，将任何运算符转换为「向量化」运算符，其具有的特殊性质是嵌套「点调用」是\emph{融合的}：它们在语法层级被组合为单个循环，无需分配临时数组。如果你使用 \texttt{.=} 和类似的赋值运算符，则结果也可以 in-place 存储在预分配的数组（参见上文）。



在线性代数的上下文中，这意味着即使诸如 \texttt{vector + vector} 和 \texttt{vector * scalar} 之类的运算，使用 \texttt{vector .+ vector} 和 \texttt{vector .* scalar} 来替代也可能是有利的，因为生成的循环可与周围的计算融合。例如，考虑两个函数：




\begin{minted}{jlcon}
julia> f(x) = 3x.^2 + 4x + 7x.^3;

julia> fdot(x) = @. 3x^2 + 4x + 7x^3 # equivalent to 3 .* x.^2 .+ 4 .* x .+ 7 .* x.^3;
\end{minted}



\texttt{f} 和 \texttt{fdot} 都做相同的计算。但是，\texttt{fdot}（在 \hyperlink{16688502228717894452}{\texttt{@.}} 宏的帮助下定义）在作用于数组时明显更快：




\begin{minted}{jlcon}
julia> x = rand(10^6);

julia> @time f(x);
  0.019049 seconds (16 allocations: 45.777 MiB, 18.59% gc time)

julia> @time fdot(x);
  0.002790 seconds (6 allocations: 7.630 MiB)

julia> @time f.(x);
  0.002626 seconds (8 allocations: 7.630 MiB)
\end{minted}



也就是说，\texttt{fdot(x)} 的速度是 \texttt{f(x)} 的 10 倍，分配的内存是 \texttt{f(x)} 的 1/6，因为 f(x) 中的每个 \texttt{*} 和 \texttt{+} 操作都会分配一个新的临时数组并在单独的循环中执行。 （当然，如果你只做 \texttt{f.(x)} 那么在这个例子中它和 \texttt{fdot(x)} 一样快，但在许多情况下，只在表达式中写一些点比为每个向量化操作定义单独的函数更方便。）



\hypertarget{16479954806149442392}{}


\section{考虑对切片使用视图}



在 Julia 中，像 \texttt{array[1:5, :]} 这样的数组“切片”表达式会创建该数据的副本（赋值的左侧除外，其中 \texttt{array[1:5, :] = ...} 原地对 \texttt{array} 的那一部分进行赋值）。 如果你在切片上执行许多操作，这对性能有好处，因为使用较小的连续副本比索引原始数组更有效。 另一方面，如果你只是对切片进行一些简单的操作，那么分配和复制操作的成本可能会很高。



另一种方法是创建数组的“视图”，它是一个数组对象（一个\texttt{SubArray}），它实际上就地引用了原始数组的数据，而不进行复制。（如果你写入视图，它也会修改原始数组的数据。）这可以通过调用 \hyperlink{4861450464669906845}{\texttt{view}} 对单个切片完成，或者更简单地通过将整个表达式或代码块放入 \hyperlink{4544474300423667148}{\texttt{@views}} 在该表达式前面。 例如：




\begin{minted}{jlcon}
julia> fcopy(x) = sum(x[2:end-1]);

julia> @views fview(x) = sum(x[2:end-1]);

julia> x = rand(10^6);

julia> @time fcopy(x);
  0.003051 seconds (3 allocations: 7.629 MB)

julia> @time fview(x);
  0.001020 seconds (1 allocation: 16 bytes)
\end{minted}



请注意，该函数的 \texttt{fview} 版本提速了 3 倍且减少了内存分配。



\hypertarget{12328390677917528950}{}


\section{复制数据不总是坏的}



数组被连续地存储在内存中，这使其可被 CPU 向量化，并且会由于缓存减少内存访问。这与建议以列序优先方式访问数组的原因相同（请参见上文）。由于不按顺序访问内存，无规律的访问方式和不连续的视图可能会大大减慢数组上的计算速度。



在对无规律访问的数据进行操作前，将其复制到连续的数组中可能带来巨大的加速，正如下例所示。其中，矩阵和向量在相乘前会访问其 800,000 个已被随机混洗的索引处的值。将视图复制到普通数组会加速乘法，即使考虑了复制操作的成本。




\begin{minted}{jlcon}
julia> using Random

julia> x = randn(1_000_000);

julia> inds = shuffle(1:1_000_000)[1:800000];

julia> A = randn(50, 1_000_000);

julia> xtmp = zeros(800_000);

julia> Atmp = zeros(50, 800_000);

julia> @time sum(view(A, :, inds) * view(x, inds))
  0.412156 seconds (14 allocations: 960 bytes)
-4256.759568345458

julia> @time begin
           copyto!(xtmp, view(x, inds))
           copyto!(Atmp, view(A, :, inds))
           sum(Atmp * xtmp)
       end
  0.285923 seconds (14 allocations: 960 bytes)
-4256.759568345134
\end{minted}



倘若副本本身的内存足够大，那么将视图复制到数组的成本可能远远超过在连续数组上执行矩阵乘法所带来的加速。



\hypertarget{11940955685871814254}{}


\section{使用 StaticArrays.jl 进行小型固定大小的向量/矩阵运算}



如果您的应用程序涉及许多固定大小的小（\texttt{< 100} 个元素）数组（即在执行之前已知大小），那么你可能需要考虑使用 [StaticArrays.jl 包](https://github.com/JuliaArrays/StaticArrays.jl）。 这个包允许你以一种避免不必要的堆分配的方式来表示这样的数组，并允许编译器为数组的\emph{大小}特例化代码，例如，通过完全展开向量操作（消除循环）并将元素存储在 CPU 寄存器中。



例如，如果你正在使用 2d 几何图形进行计算，你可能会使用 2-分量向量进行许多计算。 通过使用 StaticArrays.jl 中的 \texttt{SVector} 类型，你可以在向量 \texttt{v} 和 \texttt{w} 上使用方便的向量符号和操作，例如 \texttt{norm(3v - w)}，同时允许编译器将代码展开到最小，计算等效于\texttt{@inbounds hypot(3v[1]-w[1], 3v[2]-w[2])}。



\hypertarget{5580481875828136728}{}


\section{避免 I/0 中的字符串插值}



将数据写入到文件（或其他 I/0 设备）中时，生成额外的中间字符串会带来开销。请不要写成这样：




\begin{minted}{julia}
println(file, "$a $b")
\end{minted}



请写成这样：




\begin{minted}{julia}
println(file, a, " ", b)
\end{minted}



第一个版本的代码生成一个字符串，然后将其写入到文件中，而第二个版本直接将值写入到文件中。另请注意，在某些情况下，字符串插值可能更难阅读。请考虑：




\begin{minted}{julia}
println(file, "$(f(a))$(f(b))")
\end{minted}



与：




\begin{minted}{julia}
println(file, f(a), f(b))
\end{minted}



\hypertarget{612858988935113727}{}


\section{并发执行时优化网络 I/O}



当并发地执行一个远程函数时：




\begin{minted}{julia}
using Distributed

responses = Vector{Any}(undef, nworkers())
@sync begin
    for (idx, pid) in enumerate(workers())
        @async responses[idx] = remotecall_fetch(foo, pid, args...)
    end
end
\end{minted}



会快于：




\begin{minted}{julia}
using Distributed

refs = Vector{Any}(undef, nworkers())
for (idx, pid) in enumerate(workers())
    refs[idx] = @spawnat pid foo(args...)
end
responses = [fetch(r) for r in refs]
\end{minted}



第一种方式导致每个worker一次网络往返，而第二种方式是两次网络调用：一次 \hyperlink{11231712027010946923}{\texttt{@spawnat}} 一次\hyperlink{11007884648860062495}{\texttt{fetch}} （甚至是 \hyperlink{13761789780433862250}{\texttt{wait}}）。 \hyperlink{11007884648860062495}{\texttt{fetch}} 和\hyperlink{13761789780433862250}{\texttt{wait}} 都是同步执行，会导致较差的性能。



\hypertarget{1574945516556538959}{}


\section{修复过期警告}



过期的函数在内部会执行查找，以便仅打印一次相关警告。 这种额外查找可能会显著影响性能，因此应根据警告建议修复掉过期函数的所有使用。



\hypertarget{3670078412083548982}{}


\section{小技巧}



有一些小的注意事项可能会帮助改善循环性能。



\begin{itemize}
\item 避免使用不必要的数组。比如，使用 \texttt{x+y+z} 而不是 \hyperlink{8666686648688281595}{\texttt{sum([x,y,z])}}。


\item 对于复数 \texttt{z}，使用 \hyperlink{15686257922156163743}{\texttt{abs2(z)}} 而不是 \hyperlink{3804132060389001711}{\texttt{abs(z){\textasciicircum}2}}。一般的， 对于复数参数，用 \hyperlink{15686257922156163743}{\texttt{abs2}} 代替\hyperlink{9614495866226399167}{\texttt{abs}}。


\item 对于直接截断的整除，使用 \hyperlink{8020976424566491334}{\texttt{div(x,y)}} 而不是 \hyperlink{1728363361565303194}{\texttt{trunc(x/y)}}，使用\hyperlink{15067916827074788527}{\texttt{fld(x,y)}} 而不是 \hyperlink{11115257331910840693}{\texttt{floor(x/y)}}，使用 \hyperlink{7922388465305816555}{\texttt{cld(x,y)}} 而不是 \hyperlink{10519509038312853061}{\texttt{ceil(x/y)}}。

\end{itemize}


\hypertarget{3688250407374776658}{}


\section{性能标注}



有时，你可以通过承诺某些程序性质来启用更好的优化。



\begin{itemize}
\item 使用 \hyperlink{9619263577270933060}{\texttt{@inbounds}} 来取消表达式中的数组边界检查。使用前请再三确定，如果下标越界，可能会发生崩溃或潜在的故障。


\item 使用 \hyperlink{8577961464469068114}{\texttt{@fastmath}} 来允许对于实数是正确的、但是对于 IEEE 数字会导致差异的浮点数优化。使用时请多多小心，因为这可能改变数值结果。这对应于 clang 的 \texttt{-ffast-math} 选项。


\item 在 \texttt{for} 循环前编写 \hyperlink{8155428559748374852}{\texttt{@simd}} 来承诺迭代是相互独立且可以重新排序的。请注意，在许多情况下，Julia 可以在没有 \texttt{@simd} 宏的情况下自动向量化代码；只有在这种转换原本是非法的情况下才有用，包括允许浮点数重新结合和忽略相互依赖的内存访问（\texttt{@simd ivdep}）等情况。此外，在断言 \texttt{@simd} 时要十分小心，因为错误地标注一个具有相互依赖的迭代的循环可能导致意外结果。尤其要注意的是，某些 \texttt{AbstractArray} 子类型的 \texttt{setindex!} 本质上依赖于迭代顺序。\textbf{此功能是实验性的}，在 Julia 未来的版本中可能会更改或消失。

\end{itemize}


如果 Array 使用非常规索引，那么使用 1:n 索引到 AbstractArray 的常见习惯用法是不安全的，如果关闭边界检查，可能会导致段错误。请改用\texttt{LinearIndices(x)} 或\texttt{eachindex(x)}（另请参阅\hyperlink{1238988360302116626}{具有自定义索引的数组}）。



\begin{quote}
\textbf{Note}

虽然 \texttt{@simd} 需要直接放在最内层 \texttt{for} 循环前面，但 \texttt{@inbounds} 和 \texttt{@fastmath} 都可作用于单个表达式或在嵌套代码块中出现的所有表达式，例如，可使用 \texttt{@inbounds begin} 或 \texttt{@inbounds for ...}。

\end{quote}


下面是一个具有 \texttt{@inbounds} 和 \texttt{@simd} 标记的例子（我们这里使用 \texttt{@noinline} 来防止因优化器过于智能而破坏我们的基准测试）：




\begin{minted}{julia}
@noinline function inner(x, y)
    s = zero(eltype(x))
    for i=eachindex(x)
        @inbounds s += x[i]*y[i]
    end
    return s
end

@noinline function innersimd(x, y)
    s = zero(eltype(x))
    @simd for i = eachindex(x)
        @inbounds s += x[i] * y[i]
    end
    return s
end

function timeit(n, reps)
    x = rand(Float32, n)
    y = rand(Float32, n)
    s = zero(Float64)
    time = @elapsed for j in 1:reps
        s += inner(x, y)
    end
    println("GFlop/sec        = ", 2n*reps / time*1E-9)
    time = @elapsed for j in 1:reps
        s += innersimd(x, y)
    end
    println("GFlop/sec (SIMD) = ", 2n*reps / time*1E-9)
end

timeit(1000, 1000)
\end{minted}



在配备 2.4GHz Intel Core i5 处理器的计算机上，其结果为：




\begin{lstlisting}
GFlop/sec        = 1.9467069505224963
GFlop/sec (SIMD) = 17.578554163920018
\end{lstlisting}



（\texttt{GFlop/sec} 用来测试性能，数值越大越好。）



下面是一个具有三种标记的例子。此程序首先计算一个一维数组的有限差分，然后计算结果的 L2 范数：




\begin{minted}{julia}
function init!(u::Vector)
    n = length(u)
    dx = 1.0 / (n-1)
    @fastmath @inbounds @simd for i in 1:n # 通过断言 `u` 是一个 `Vector`，我们可以假定它具有 1-based 索引
        u[i] = sin(2pi*dx*i)
    end
end

function deriv!(u::Vector, du)
    n = length(u)
    dx = 1.0 / (n-1)
    @fastmath @inbounds du[1] = (u[2] - u[1]) / dx
    @fastmath @inbounds @simd for i in 2:n-1
        du[i] = (u[i+1] - u[i-1]) / (2*dx)
    end
    @fastmath @inbounds du[n] = (u[n] - u[n-1]) / dx
end

function mynorm(u::Vector)
    n = length(u)
    T = eltype(u)
    s = zero(T)
    @fastmath @inbounds @simd for i in 1:n
        s += u[i]^2
    end
    @fastmath @inbounds return sqrt(s)
end

function main()
    n = 2000
    u = Vector{Float64}(undef, n)
    init!(u)
    du = similar(u)

    deriv!(u, du)
    nu = mynorm(du)

    @time for i in 1:10^6
        deriv!(u, du)
        nu = mynorm(du)
    end

    println(nu)
end

main()
\end{minted}



在配备 2.7 GHz Intel Core i7 处理器的计算机上，其结果为：




\begin{lstlisting}
$ julia wave.jl;
  1.207814709 seconds
4.443986180758249

$ julia --math-mode=ieee wave.jl;
  4.487083643 seconds
4.443986180758249
\end{lstlisting}



在这里，选项 \texttt{--math-mode=ieee} 禁用 \texttt{@fastmath} 宏，好让我们可以比较结果。



在这种情况下，\texttt{@fastmath} 加速了大约 3.7 倍。这非常大——通常来说，加速会更小。（在这个特定的例子中，基准测试的工作集足够小，可以放在该处理器的 L1 缓存中，因此内存访问延迟不起作用，计算时间主要由 CPU 使用率决定。在许多现实世界的程序中，情况并非如此。）此外，在这种情况下，此优化不会改变计算结果——通常来说，结果会略有不同。在某些情况下，尤其是数值不稳定的算法，计算结果可能会差很多。



标注 \texttt{@fastmath} 会重新排列浮点数表达式，例如更改求值顺序，或者假设某些特殊情况（如 inf、nan）不出现。在这种情况中（以及在这个特定的计算机上），主要区别是函数 \texttt{deriv} 中的表达式 \texttt{1 / (2*dx)} 会被提升出循环（即在循环外计算），就像编写了 \texttt{idx = 1 / (2*dx)}，然后，在循环中，表达式 \texttt{... / (2*dx)} 变为 \texttt{... * idx}，后者计算起来快得多。当然，编译器实际上采用的优化以及由此产生的加速都在很大程度上取决于硬件。你可以使用 Julia 的 \hyperlink{2534314152947301270}{\texttt{code\_native}} 函数来检查所生成代码的更改。



请注意，\texttt{@fastmath} 也假设了在计算中不会出现 \texttt{NaN}，这可能导致意想不到的行为：




\begin{minted}{jlcon}
julia> f(x) = isnan(x);

julia> f(NaN)
true

julia> f_fast(x) = @fastmath isnan(x);

julia> f_fast(NaN)
false
\end{minted}



\hypertarget{7419573372551608522}{}


\section{将次正规数视为零}



次正规数，以前称为 \href{https://en.wikipedia.org/wiki/Denormal\_number}{非正规数}，在许多情况下都很有用，但会在某些硬件上造成性能损失。 调用 \hyperlink{2845950135157372113}{\texttt{set\_zero\_subnormals(true)}} 授予浮点运算权限，将次正规输入或输出视为零，这可能会提高某些硬件的性能。 调用 \hyperlink{2845950135157372113}{\texttt{set\_zero\_subnormals(false)}} 对次正规数强制执行严格的 IEEE 行为。



下面是一个示例，其中次正规数显着影响某些硬件的性能：




\begin{minted}{julia}
function timestep(b::Vector{T}, a::Vector{T}, Δt::T) where T
    @assert length(a)==length(b)
    n = length(b)
    b[1] = 1                            # Boundary condition
    for i=2:n-1
        b[i] = a[i] + (a[i-1] - T(2)*a[i] + a[i+1]) * Δt
    end
    b[n] = 0                            # Boundary condition
end

function heatflow(a::Vector{T}, nstep::Integer) where T
    b = similar(a)
    for t=1:div(nstep,2)                # Assume nstep is even
        timestep(b,a,T(0.1))
        timestep(a,b,T(0.1))
    end
end

heatflow(zeros(Float32,10),2)           # Force compilation
for trial=1:6
    a = zeros(Float32,1000)
    set_zero_subnormals(iseven(trial))  # Odd trials use strict IEEE arithmetic
    @time heatflow(a,1000)
end
\end{minted}



它的输出类似于




\begin{lstlisting}
  0.002202 seconds (1 allocation: 4.063 KiB)
  0.001502 seconds (1 allocation: 4.063 KiB)
  0.002139 seconds (1 allocation: 4.063 KiB)
  0.001454 seconds (1 allocation: 4.063 KiB)
  0.002115 seconds (1 allocation: 4.063 KiB)
  0.001455 seconds (1 allocation: 4.063 KiB)
\end{lstlisting}



注意，每个偶数迭代的速度明显更快。



这个例子产生了许多次正规数，因为\texttt{a}中的值变成了一个指数递减的曲线，随着时间的推移慢慢渐进趋于0。



应谨慎使用将次正规数视为零，因为这样做会破坏某些等式，例如 \texttt{x-y == 0} 意味着 \texttt{x == y}：




\begin{minted}{jlcon}
julia> x = 3f-38; y = 2f-38;

julia> set_zero_subnormals(true); (x - y, x == y)
(0.0f0, false)

julia> set_zero_subnormals(false); (x - y, x == y)
(1.0000001f-38, false)
\end{minted}



在某些应用程序中，将次正规数归零的另一种方法是加入一点点噪音。 例如，不是用零初始化\texttt{a}，而是用以下方法初始化它：




\begin{minted}{julia}
a = rand(Float32,1000) * 1.f-9
\end{minted}



\hypertarget{7082991166860772411}{}


\section{\texttt{@code\_warntype}}



宏 \hyperlink{8092893264277772840}{\texttt{@code\_warntype}}（或其函数变体 \hyperlink{5565852192659724503}{\texttt{code\_warntype}}）有时可以帮助诊断类型相关的问题。这是一个例子：




\begin{minted}{jlcon}
julia> @noinline pos(x) = x < 0 ? 0 : x;

julia> function f(x)
           y = pos(x)
           return sin(y*x + 1)
       end;

julia> @code_warntype f(3.2)
Variables
  #self#::Core.Const(f)
  x::Float64
  y::UNION{FLOAT64, INT64}

Body::Float64
1 ─      (y = Main.pos(x))
│   %2 = (y * x)::Float64
│   %3 = (%2 + 1)::Float64
│   %4 = Main.sin(%3)::Float64
└──      return %4
\end{minted}



理解 \hyperlink{8092893264277772840}{\texttt{@code\_warntype}} 的输出，就像理解它的同类工具 \hyperlink{1376948972689074219}{\texttt{@code\_lowered}}, \hyperlink{6823997547688846780}{\texttt{@code\_typed}}, \href{@ ref}{\texttt{@code\_llvm}} 和 \hyperlink{2629340111434042067}{\texttt{@code\_native}} 一样需要一些练习。你的代码以在生成编译机器代码的过程中经过大量摘要的形式呈现。大多数表达式都由类型注释，由 \texttt{::T} 表示（例如，其中 \texttt{T} 可能是 \hyperlink{5027751419500983000}{\texttt{Float64}}）。 \hyperlink{8092893264277772840}{\texttt{@code\_warntype}} 最大的特点就是非具体类型用红色显示； 由于本文档是用Markdown 编写的，没有颜色，所以本文档中红色文字用大写表示。



在顶部，该函数类型推导后的返回类型显示为 \texttt{Body::Float64}。下一行以 Julia 的 SSA IR 形式表示了 \texttt{f} 的主体。被数字标记的方块表示代码中（通过 \texttt{goto}）跳转的目标。查看主体，你会看到首先调用了 \texttt{pos}，其返回值经类型推导为 \texttt{Union} 类型 \texttt{UNION\{FLOAT64, INT64\}} 并以大写字母显示，因为它是非具体类型。这意味着我们无法根据输入类型知道 \texttt{pos} 的确切返回类型。但是，无论 \texttt{y} 是 \texttt{Float64} 还是 \texttt{Int64}，\texttt{y*x} 的结果都是 \texttt{Float64}。最终的结果是 \texttt{f(x::Float64)} 在其输出中不会是类型不稳定的，即使有些中间计算是类型不稳定的。



如何使用这些信息取决于你。显然，最好将 \texttt{pos} 修改为类型稳定的：如果这样做，\texttt{f} 中的所有变量都是具体的，其性能将是最佳的。但是，在某些情况下，这种\emph{短暂的}类型不稳定性可能无关紧要：例如，如果 \texttt{pos} 从不单独使用，那么 \texttt{f} 的输出（对于 \hyperlink{5027751419500983000}{\texttt{Float64}} 输入）是类型稳定的这一事实将保护之后的代码免受类型不稳定性的传播影响。这与类型不稳定性难以或不可能修复的情况密切相关。在这些情况下，上面的建议（例如，添加类型注释并/或分解函数）是你控制类型不稳定性的「损害」的最佳工具。另请注意，即使是 Julia Base 也有类型不稳定的函数。例如，函数 \hyperlink{13752961745140943082}{\texttt{findfirst}} 如果找到键则返回数组索引，如果没有找到键则返回 \texttt{nothing}，这是明显的类型不稳定性。为了更易于找到可能很重要的类型不稳定性，包含 \texttt{missing} 或 \texttt{nothing} 的 \texttt{Union} 会用黄色着重显示，而不是用红色。



以下示例可以帮助你解释被标记为包含非叶类型的表达式：



\begin{itemize}
\item 函数体以 \texttt{Body::UNION\{T1,T2\})} 开头

\begin{itemize}
\item 解释：函数具有不稳定返回类型


\item 建议：使返回值类型稳定，即使你必须对其进行类型注释

\end{itemize}

\item \texttt{invoke Main.g(\%\%x::Int64)::UNION\{FLOAT64, INT64\}}

\begin{itemize}
\item 解释：调用类型不稳定的函数 \texttt{g}。


\item 建议：修改该函数，或在必要时对其返回值进行类型注释

\end{itemize}

\item \texttt{invoke Base.getindex(\%\%x::Array\{Any,1\}, 1::Int64)::ANY}

\begin{itemize}
\item 解释：访问缺乏类型信息的数组的元素


\item 建议：使用具有更佳定义的类型的数组，或在必要时对访问的单个元素进行类型注释

\end{itemize}

\item \texttt{Base.getfield(\%\%x, :(:data))::ARRAY\{FLOAT64,N\} WHERE N}

\begin{itemize}
\item 解释：获取一个非叶子类型的字段。 在这种情况下，\texttt{x} 的类型，比如说 \texttt{ArrayContainer}，有一个字段 \texttt{data::Array\{T\}}。 但是 \texttt{Array} 也需要维度 \texttt{N} 作为具体类型。


\item 建议：使用类似于 \texttt{Array\{T,3\}} 或 \texttt{Array\{T,N\}} 的具体类型，其中的 \texttt{N} 现在是 \texttt{ArrayContainer} 的参数

\end{itemize}
\end{itemize}


\hypertarget{16106323250273012356}{}


\section{被捕获变量的性能}



请考虑以下定义内部函数的示例：




\begin{minted}{julia}
function abmult(r::Int)
    if r < 0
        r = -r
    end
    f = x -> x * r
    return f
end
\end{minted}



函数 \texttt{abmult} 返回一个函数 \texttt{f}，它将其参数乘以 \texttt{r} 的绝对值。赋值给 \texttt{f} 的函数称为「闭包」。内部函数还被语言用于 \texttt{do} 代码块和生成器表达式。



这种代码风格为语言带来了性能挑战。解析器在将其转换为较低级别的指令时，基本上通过将内部函数提取到单独的代码块来重新组织上述代码。「被捕获的」变量，比如 \texttt{r}，被内部函数共享，且包含它们的作用域会被提取到内部函数和外部函数皆可访问的堆分配「box」中，这是因为语言指定内部作用域中的 \texttt{r} 必须与外部作用域中的 \texttt{r} 相同，就算在外部作用域（或另一个内部函数）修改 \texttt{r} 后也需如此。



前一段的讨论中提到了「解析器」，也就是，包含 \texttt{abmult} 的模块被首次加载时发生的编译前期，而不是首次调用它的编译后期。解析器不「知道」\texttt{Int} 是固定类型，也不知道语句 \texttt{r = -r} 将一个 \texttt{Int} 转换为另一个 \texttt{Int}。类型推断的魔力在编译后期生效。



因此，解析器不知道 \texttt{r} 具有固定类型（\texttt{Int}）。一旦内部函数被创建，\texttt{r} 的值也不会改变（因此也不需要 box）。因此，解析器向包含具有抽象类型（比如 \texttt{Any}）的对象的 box 发出代码，这对于每次出现的 \texttt{r} 都需要运行时类型分派。这可以通过在上述函数中使用 \texttt{@code\_warntype} 来验证。装箱和运行时的类型分派都有可能导致性能损失。



如果捕获的变量用于代码的性能关键部分，那么以下提示有助于确保它们的使用具有高效性。首先，如果已经知道被捕获的变量不会改变类型，则可以使用类型注释来显式声明类型（在变量上，而不是在右侧）：




\begin{minted}{julia}
function abmult2(r0::Int)
    r::Int = r0
    if r < 0
        r = -r
    end
    f = x -> x * r
    return f
end
\end{minted}



类型注释部分恢复由于捕获而导致的丢失性能，因为解析器可以将具体类型与 box 中的对象相关联。更进一步，如果被捕获的变量不再需要 box（因为它不会在闭包创建后被重新分配），就可以用 \texttt{let} 代码块表示，如下所示。




\begin{minted}{julia}
function abmult3(r::Int)
    if r < 0
        r = -r
    end
    f = let r = r
            x -> x * r
    end
    return f
end
\end{minted}



\texttt{let} 代码块创建了一个新的变量 \texttt{r}，它的作用域只是内部函数。第二种技术在捕获变量存在时完全恢复了语言性能。请注意，这是编译器的一个快速发展的方面，未来的版本可能不需要依靠这种程度的程序员注释来获得性能。与此同时，一些用户提供的包（如 \href{https://github.com/c42f/FastClosures.jl}{FastClosures}）会自动插入像在 \texttt{abmult3} 中那样的 \texttt{let} 语句。



\hypertarget{14117620934191882930}{}


\chapter{工作流程建议}



这里是高效使用 Julia 的一些建议。



\hypertarget{1742408234615272902}{}


\section{基于 REPL 的工作流程}



正如在 \hyperlink{10670790884919535588}{Julia REPL} 中演示的那样，Julia 的 REPL 为高效的交互式工作流程提供了丰富的功能。这里是一些可能进一步提升你在命令行下的体验的建议。



\hypertarget{11122328157249839079}{}


\subsection{一个基本的编辑器 / REPL 工作流程}



最基本的 Julia 工作流程是将一个文本编辑器配合 \texttt{julia} 的命令行使用。一般会包含下面一些步骤：



\begin{itemize}
\item \textbf{把还在开发中的代码放到一个临时的模块中。}新建一个文件，例如 \texttt{Tmp.jl}，并放到模块中。


\begin{minted}{julia}
module Tmp
export say_hello

say_hello() = println("Hello!")

# your other definitions here

end
\end{minted}


\item \textbf{把测试代码放到另一个文件中。}新建另一个文件，例如 \texttt{tst.jl}，开头为


\begin{minted}{julia}
include("Tmp.jl")
import .Tmp
# using .Tmp # we can use `using` to bring the exported symbols in `Tmp` into our namespace

Tmp.say_hello()
# say_hello()

# your other test code here
\end{minted}

并把测试作为 \texttt{Tmp} 的内容。或者，你可以把测试文件的内容打包到一个模块中，例如


\begin{minted}{julia}
module Tst
    include("Tmp.jl")
    import .Tmp
    #using .Tmp

    Tmp.say_hello()
    # say_hello()

    # your other test code here
end
\end{minted}

优点是你的测试代码现在包含在一个模块中，并且不会在 \texttt{Main} 的全局作用域中引入新定义，这样更加整洁。


\item 使用 \texttt{include({\textquotedbl}tst.jl{\textquotedbl})} 来在 Julia REPL 中 \texttt{include} \texttt{tst.jl} 文件。


\item \textbf{打肥皂，冲洗，重复。}（译者注：此为英语幽默，被称为\href{https://en.wikipedia.org/wiki/Lather,\_rinse,\_repeat）描述洗头发的过程}{“洗发算法”}在 \texttt{julia} REPL 中摸索不同的想法，把好的想法存入 \texttt{tst.jl}。要在 \texttt{tst.jl} 被更改后执行它，只需再次 \texttt{include} 它。

\end{itemize}


\hypertarget{173246562791795014}{}


\section{基于浏览器的工作流程}



也可以通过 \href{https://github.com/JuliaLang/IJulia.jl}{IJulia} 在浏览器中与 Julia REPL 进行交互，请到该库的主页查看详细用法。



\hypertarget{12794253722784581701}{}


\section{基于Revise的工作流程}



无论你是在REPL还是在IJulia，你通常可以通过 \href{https://github.com/timholy/Revise.jl}{Revise}优化 你的开发经历。 通常情况，无论何时启动Julia，就请按照\href{https://timholy.github.io/Revise.jl/stable/}{Revise文档}中的说明配置好Revise。 一旦配置好，Revise将跟踪任何加载模块中的文件变化。 和任何用\texttt{includet}加载到 REPL 的文件 (但不包括普通的\texttt{include}); 然后你就可以编辑这些文件，并且更改会在不重新启动julia会话的情况下生效。 标准工作流与上面基于 REPL 的工作流类似，区别如下：



\begin{itemize}
\item[1. ] 把你的代码放到一个在你的加载路径里的模块中。 要这样做有很多种方法，通常推荐以下两种选择：

\begin{itemize}
\item 对于长期的项目，使用\href{https://github.com/invenia/PkgTemplates.jl}{PkgTemplates}:


\begin{minted}{julia}
using PkgTemplates
t = Template()
t("MyPkg")
\end{minted}

这将在 \texttt{.julia/dev} 目录中创建一个空白包\texttt{{\textquotedbl}MyPkg{\textquotedbl}}。 请注意，通过它的 \texttt{Template} 构造器，PkgTemplates 允许控制许多不同的选项。

在下面的第 2 步中，编辑 \texttt{MyPkg/src/MyPkg.jl} 以更改源代码，并编辑 \texttt{MyPkg/test/runtests.jl} 以进行测试。


\item 对于“一次性”项目，您可以通过在临时目录（例如 \texttt{/tmp}）中进行工作来避免任何清理需求。

切换到临时目录并启动 Julia，然后执行以下操作：


\begin{minted}{julia}
pkg> generate MyPkg            # type ] to enter pkg mode
julia> push!(LOAD_PATH, pwd())   # hit backspace to exit pkg mode
\end{minted}

如果你重新启动 Julia 会话，则必须重新发出修改 \texttt{LOAD\_PATH} 的命令。

在下面的第 2 步中，编辑 \texttt{MyPkg/src/MyPkg.jl} 以更改源代码，并创建你选择的任何测试文件。

\end{itemize}

\item[2. ] 构建你自己的包

\textbf{在加载任何代码之前}， 确保 Revise 已经被启用： \texttt{using Revise} 或者按照教程设置自动加载。

然后切换到包含测试文件（假设文件为\texttt{{\textquotedbl}runtests.jl{\textquotedbl}}）的目录下，并：


\begin{minted}{julia}
julia> using MyPkg

julia> include("runtests.jl")
\end{minted}

你可以修改在 MyPkg 文件夹中的代码然后用\texttt{include({\textquotedbl}runtests.jl{\textquotedbl})}重新跑一遍测试。 通常，你可能需要重新启动Julia 会话来使得这些变化生效（受一些 \href{https://timholy.github.io/Revise.jl/stable/limitations/}{限制}）。

\end{itemize}


\hypertarget{8293020885235442145}{}


\chapter{代码风格指南}



接下来的部分将介绍如何写出具有 Julia 风格的代码。当然，这些规则并不是绝对的，它们只是一些建议，以便更好地帮助你熟悉这门语言，以及在不同的代码设计中做出选择。



\hypertarget{5688357021956898116}{}


\section{缩进}



每个缩进级别使用 4 个空格。



\hypertarget{14598192216141137141}{}


\section{写函数，而不是仅仅写脚本}



一开始解决问题的时候，直接从最外层一步步写代码的确很便捷，但你应该尽早地将代码组织成函数。函数有更强的复用性和可测试性，并且能更清楚地让人知道哪些步骤做完了，以及每一步骤的输入输出分别是什么。此外，由于 Julia 编译器特殊的工作方式，写在函数中的代码往往要比最外层的代码运行地快得多。



此外值得一提的是，函数应当接受参数，而不是直接使用全局变量进行操作（\hyperlink{4355513108985533054}{\texttt{pi}} 等常数除外）。



\hypertarget{14766885101141675893}{}


\section{类型不要写得过于具体}



代码应该写得尽可能通用。例如，下面这段代码:




\begin{minted}{julia}
Complex{Float64}(x)
\end{minted}



更好的写法是写成下面的通用函数：




\begin{minted}{julia}
complex(float(x))
\end{minted}



第二个版本会把 \texttt{x} 转换成合适的类型，而不是某个写死的类型。



这种代码风格与函数的参数尤其相关。例如，当一个参数可以是任何整型时，不要将它的类型声明为 \texttt{Int} 或 \hyperlink{10103694114785108551}{\texttt{Int32}}，而要使用抽象类型（abstract type）\hyperlink{8469131683393450448}{\texttt{Integer}} 来表示。事实上，除非确实需要将其与其它的方法定义区分开，很多情况下你可以干脆完全省略掉参数的类型，因为如果你的操作中有不支持某种参数类型的操作的话，反正都会抛出 \hyperlink{68769522931907606}{\texttt{MethodError}} 的。这也称作 \href{https://zh.wikipedia.org/wiki/\%E9\%B8\%AD\%E5\%AD\%90\%E7\%B1\%BB\%E5\%9E\%8B}{鸭子类型}）。



例如，考虑这样的一个叫做 \texttt{addone} 的函数，其返回值为它的参数加 1 ：




\begin{minted}{julia}
addone(x::Int) = x + 1                 # works only for Int
addone(x::Integer) = x + oneunit(x)    # any integer type
addone(x::Number) = x + oneunit(x)     # any numeric type
addone(x) = x + oneunit(x)             # any type supporting + and oneunit
\end{minted}



最后一种定义可以处理所有支持 \hyperlink{2310843180104103470}{\texttt{oneunit}} （返回和 \texttt{x} 相同类型的 1，以避免不需要的类型提升（type promotion））以及 \hyperlink{3677358729494553841}{\texttt{+}} 函数的类型。这里的关键点在于，\textbf{只}定义通用的 \texttt{addone(x) = x + oneunit(x)} 并\textbf{不会}带来性能上的损失，因为 Julia 会在需要的时候自动编译特定的版本。比如说，当第一次调用 \texttt{addone(12)} 时，Julia 会自动编译一个特定的 \texttt{addone} 函数，它接受一个 \texttt{x::Int} 的参数，并把调用的 \texttt{oneunit} 替换为内连的值 \texttt{1}。因此，上述的前三种 \texttt{addone} 的定义对于第四种来说是完全多余的。



\hypertarget{14005859971102001375}{}


\section{让调用者处理多余的参数多样性}



如下的代码：




\begin{minted}{julia}
function foo(x, y)
    x = Int(x); y = Int(y)
    ...
end
foo(x, y)
\end{minted}



请写成这样：




\begin{minted}{julia}
function foo(x::Int, y::Int)
    ...
end
foo(Int(x), Int(y))
\end{minted}



这种风格更好，因为 \texttt{foo} 函数其实不需要接受所有类型的数，而只需要接受 \texttt{Int}。



这里的关键在于，如果一个函数需要处理的是整数，强制让调用者来决定非整数如何被转换（比如说向下还是向上取整）会更好。同时，把类型声明得具体一些的话可以为以后的方法定义留有更多的空间。



\hypertarget{1684346418186777370}{}


\section{在修改其参数的函数名称后加 \texttt{!}}



如下的代码：




\begin{minted}{julia}
function double(a::AbstractArray{<:Number})
    for i = firstindex(a):lastindex(a)
        a[i] *= 2
    end
    return a
end
\end{minted}



请写成这样：




\begin{minted}{julia}
function double!(a::AbstractArray{<:Number})
    for i = firstindex(a):lastindex(a)
        a[i] *= 2
    end
    return a
end
\end{minted}



Julia 的 Base 模块中的函数都遵循了这种规范，且包含很多例子：有的函数同时有拷贝和修改的形式（比如 \hyperlink{8473525809131227606}{\texttt{sort}} 和 \hyperlink{12296873681374954808}{\texttt{sort!}}），还有一些只有修改（比如 \hyperlink{18026893834387542681}{\texttt{push!}}，\hyperlink{14467641005327674015}{\texttt{pop!}} 和 \hyperlink{13785507599688955371}{\texttt{splice!}}）。为了方便起见，这类函数通常也会把修改后的数组作为返回值。



\hypertarget{14194687290331521644}{}


\section{避免使用奇怪的 \texttt{Union} 类型}



使用 \texttt{Union\{Function,AbstractString\}} 这样的类型的时候通常意味着设计还不够清晰。



\hypertarget{6548025962580232135}{}


\section{避免复杂的容器类型}



像下面这样构造数组通常没有什么好处：




\begin{minted}{julia}
a = Vector{Union{Int,AbstractString,Tuple,Array}}(undef, n)
\end{minted}



这种情况下，\texttt{Vector\{Any\}(undef, n)}更合适些。此外，相比将所有可能的类型都打包在一起，直接在使用时标注具体的数据类型（比如：\texttt{a[i]::Int}）对编译器来说更有用。



\hypertarget{2535775561601867117}{}


\section{方法导出优先于直接字段访问}



惯例上，Julia 代码通常应将模块的导出方法视为其类型的接口。 一个对象的字段通常被认为是实现细节，如果这被声明为 API，用户代码应该只直接访问它们。 这有几个好处：



包开发人员可以更自由地更改实现而不会破坏用户代码。



\begin{itemize}
\item
\item 方法可以传递给高阶结构，如 \hyperlink{11483231213869150535}{\texttt{map}}（例如 \texttt{map(imag, zs)}）而不是 \texttt{[z.im for z in zs]}）。


\item 方法可以定义在抽象类型上。


\item 方法可以描述可以在不同类型之间共享的概念操作（例如 \texttt{real(z)} 适用于复数或四元数）。

\end{itemize}


Julia 的调度系统鼓励这种风格，因为 \texttt{play(x::MyType)} 只在该特定类型上定义了 \texttt{play} 方法，其它类型有自己的实现。



同样，除非文档另有说明，否则非导出函数通常是内部的并且可能会发生变化。 名称有时会被赋予一个 \texttt{\_} 前缀（或后缀）以进一步暗示某些是“内部”或实现细节，但这不是规则。



该规则的反例包括 \hyperlink{3845731488275720657}{\texttt{NamedTuple}}、\hyperlink{2695862412477105800}{\texttt{RegexMatch}}、\hyperlink{10861694406169986183}{\texttt{StatStruct}}。



\hypertarget{17294992054689205687}{}


\section{使用和 Julia \texttt{base/} 文件夹中的代码一致的命名习惯}



\begin{itemize}
\item module 和 type 的名字使用大写开头的驼峰命名法：\texttt{module SparseArrays}，\texttt{struct UnitRange}。


\item 函数名使用小写字母，且当可读时可以将多个单词拼在一起。必要的时候，可以使用下划线作为单词分隔符。下划线也被用于指明概念的组合（比如 \hyperlink{17262349333771600150}{\texttt{remotecall\_fetch}} 作为 \texttt{fetch(remotecall(...))} 的一个更高效的实现）或者变化。


\item 至少改变其中一个参数的函数名称以\texttt{!}结尾。


\item 虽然简洁性很重要，但避免使用缩写（用 \hyperlink{16333903346703258373}{\texttt{indexin}} 而不是 \texttt{indxin}），因为这会让记住单词有没有被缩写或如何被缩写变得十分困难。

\end{itemize}


如果一个函数名需要多个单词，请考虑这个函数是否代表了超过一个概念，是不是分成几个更小的部分更好。



\hypertarget{527161729759687978}{}


\section{使用与 Julia Base 中的函数类似的参数顺序}



一般来说，Base 库使用以下的函数参数顺序（如适用）：



\begin{itemize}
\item[1.  ] \textbf{函数参数}. 函数的第一个参数可以接受 \texttt{Function} 类型，以便使用 \hyperlink{16455129305818705265}{\texttt{do}} blocks 来传递多行匿名函数。


\item[2.  ] \textbf{I/O stream}. 函数的第一个参数可以接受 \texttt{IO} 对象，以便将函数传递给 \hyperlink{6652981552509545835}{\texttt{sprint}} 之类的函数，例如 \texttt{sprint(show, x)}。


\item[3.  ] \textbf{在输入参数的内容会被更改的情况下}. 比如，在 \hyperlink{5162290739791026948}{\texttt{fill!(x, v)}} 中，\texttt{x} 是要被修改的对象，所以放在要被插入 \texttt{x} 中的值前面。


\item[4.  ] \textbf{Type}. 把类型作为参数传入函数通常意味着返回值也会是同样的类型。 在 \hyperlink{14207407853646164654}{\texttt{parse(Int, {\textquotedbl}1{\textquotedbl})}} 中，类型在需要解析的字符串之前。 还有很多类似的将类型作为函数第一个参数的例子，但是同时也需要注意到例如 \hyperlink{8104134490906192097}{\texttt{read(io, String)}} 这样的函数中，会把 \texttt{IO} 参数放在类型的更前面，这样还是保持着这里描述的顺序。


\item[5.  ] \textbf{在输入参数的内容不会被更改的情况下}. 比如在 \texttt{fill!(x, v)} 中的\textbf{不}被修改的 \texttt{v}，会放在 \texttt{x} 之后传入。


\item[6.  ] \textbf{Key}. 对于关联集合来说，指的是键值对的键。 对于其它有索引的集合来说，指的是索引。


\item[7.  ] \textbf{Value}. 对于关联集合来说，指的是键值对的值。 像\hyperlink{5162290739791026948}{\texttt{fill!(x, v)}}这样的情况, 是\texttt{v}。


\item[8.  ] \textbf{Everything else}. 任何的其它参数。


\item[9.  ] \textbf{Varargs}. 指的是在函数调用时可以被无限列在后面的参数。 比如在 \texttt{Matrix\{T\}(uninitialized, dims)} 中，维数（dims）可以作为 \hyperlink{17462354060312563026}{\texttt{Tuple}} 被传入（如 \texttt{Matrix\{T\}(uninitialized, (1,2))}），也可以作为可变参数（\hyperlink{5941806424098279588}{\texttt{Vararg}}，如 \texttt{Matrix\{T\}(uninitialized, 1, 2)}。


\item[10. ] \textbf{Keyword arguments}. 在 Julia 中，关键字参数本来就不得不定义在函数定义的最后，列在这里仅仅是为了完整性。

\end{itemize}


大多数函数并不会接受上述所有种类的参数，这些数字仅仅是表示当适用时的优先权。



当然，在一些情况下有例外。例如，\hyperlink{1846942650946171605}{\texttt{convert}} 函数总是把类型作为第一个参数。\hyperlink{1309244355901386657}{\texttt{setindex!}} 函数的值参数在索引参数之前，这样可以让索引作为可变参数传入。



设计 API 时，尽可能秉承着这种一般顺序会让函数的使用者有一种更一致的体验。



\hypertarget{16340212137156679332}{}


\section{不要过度使用 try-catch}



比起依赖于捕获错误，更好的是避免错误。



\hypertarget{15308468417216899816}{}


\section{不要给条件语句加括号}



Julia 不要求在 \texttt{if} 和 \texttt{while} 后的条件两边加括号。使用如下写法：




\begin{minted}{julia}
if a == b
\end{minted}



而不是:




\begin{minted}{julia}
if (a == b)
\end{minted}



\hypertarget{13344988799401234550}{}


\section{不要过度使用 \texttt{...}}



拼接函数参数是会上瘾的。请用简单的 \texttt{[a; b]} 来代替 \texttt{[a..., b...]}，因为前者已经是被拼接的数组了。\hyperlink{6278865767444641812}{\texttt{collect(a)}} 也比 \texttt{[a...]} 更好，但因为 \texttt{a} 已经是一个可迭代的变量了，通常不把它转换成数组就直接使用甚至更好。



\hypertarget{13140702923511466392}{}


\section{不要使用不必要的静态参数}



如下的函数签名：




\begin{minted}{julia}
foo(x::T) where {T<:Real} = ...
\end{minted}



应当被写作：




\begin{minted}{julia}
foo(x::Real) = ...
\end{minted}



尤其是当 \texttt{T} 没有被用在函数体中时格外有意义。即使 \texttt{T} 被用到了，通常也可以被替换为 \hyperlink{13440452181855594120}{\texttt{typeof(x)}}，后者不会导致性能上的差别。注意这并不是针对静态参数的一般警告，而仅仅是针对那些不必要的情况。



同样需要注意的是，容器类型在函数调用中可能明确地需要类型参数。详情参见\hyperlink{11695962945306703148}{避免使用带抽象容器的字段}。



\hypertarget{14321901677948654689}{}


\section{避免判断变量是实例还是类型的混乱}



如下的一组定义容易令人困惑：




\begin{minted}{julia}
foo(::Type{MyType}) = ...
foo(::MyType) = foo(MyType)
\end{minted}



请决定问题里的概念应当是 \texttt{MyType} 还是 \texttt{MyType()}，然后坚持使用其一。



首选风格应是默认使用实例，只有在需要解决某些问题时才添加涉及\texttt{Type\{MyType\}}的方法。



如果一个类型实际上是个枚举，它应该被定义成一个单一的类型（理想的情况是不可变结构或原始类型），把枚举值作为它的实例。构造器和转换器可以检查那些值是否有效。这种设计比把枚举做成抽象类型，并把“值”做成子类型来得更受推崇。



\hypertarget{678667303123676019}{}


\section{不要过度使用宏}



请注意有的宏实际上可以被写成一个函数。



在宏内部调用 \hyperlink{7507639810592563424}{\texttt{eval}} 是一个特别危险的警告标志，它意味着这个宏仅在被最外层调用时起作用。如果这样的宏被写成函数，它会自然地访问得到它所需要的运行时值。



\hypertarget{9477312169098625763}{}


\section{不要把不安全的操作暴露在接口层}



如果你有一个使用本地指针的类型：




\begin{minted}{julia}
mutable struct NativeType
    p::Ptr{UInt8}
    ...
end
\end{minted}



不要定义类似如下的函数：




\begin{minted}{julia}
getindex(x::NativeType, i) = unsafe_load(x.p, i)
\end{minted}



这里的问题在于，这个类型的用户可能会在意识不到这个操作不安全的情况下写出 \texttt{x[i]}，然后容易遇到内存错误。



在这样的函数中，可以加上对操作的检查来确保安全，或者可以在名字的某处加上 \texttt{unsafe} 来警告调用者。



\hypertarget{11547972187147924005}{}


\section{不要重载基础容器类型的方法}



有时可能会想要写这样的定义：




\begin{minted}{julia}
show(io::IO, v::Vector{MyType}) = ...
\end{minted}



这样可以提供对特定的某种新元素类型的向量的自定义显示。这种做法虽然很诱人，但应当被避免。这里的问题在于用户会想着一个像 \texttt{Vector()} 这样熟知的类型以某种方式表现，但过度自定义的行为会让使用变得更难。



\hypertarget{16979726342714314714}{}


\section{避免类型盗版}



“类型盗版”（type piracy）指的是扩展或是重定义 Base 或其它包中的并不是你所定义的类型的方法。在某些情况下，你可以几乎毫无副作用地逃避类型盗版。但在极端情况下，你甚至会让 Julia 崩溃（比如说你的方法扩展或重定义造成了对 \texttt{ccall} 传入了无效的输入）。类型盗版也让代码推导变得更复杂，且可能会引入难以预料和诊断的不兼容性。



例如，你也许想在一个模块中定义符号上的乘法：




\begin{minted}{julia}
module A
import Base.*
*(x::Symbol, y::Symbol) = Symbol(x,y)
end
\end{minted}



这里的问题时现在其它用到 \texttt{Base.*} 的模块同样会看到这个定义。由于 \texttt{Symbol} 是定义在 Base 里再被其它模块所使用的，这可能不可预料地改变无关代码的行为。这里有几种替代的方式，包括使用一个不同的函数名称，或是把 \texttt{Symbol} 给包在另一个你自己定义的类型中。



有时候，耦合的包可能会使用类型盗版，以此来从定义分隔特性，尤其是当那些包是一些合作的作者设计的时候，且那些定义是可重用的时候。例如，一个包可能提供一些对处理色彩有用的类型，另一个包可能为那些类型定义色彩空间之间转换的方法。再举一个例子，一个包可能是一些 C 代码的简易包装，另一个包可能就“盗版”来实现一些更高级别的、对 Julia 友好的 API。



\hypertarget{11741910651274288820}{}


\section{注意类型相等}



通常会用 \hyperlink{7066325108767373297}{\texttt{isa}} 和 \hyperlink{6254591906563366276}{\texttt{<:}} 来对类型进行测试，而不会用到 \texttt{==}。检测类型的相等通常只对和一个已知的具体类型比较有意义（例如 \texttt{T == Float64}），或者你\textbf{真的真的}知道自己在做什么。



\hypertarget{20919813611265277}{}


\section{不要写 \texttt{x->f(x)}}



因为调用高阶函数时经常会用到匿名函数，很容易认为这是合理甚至必要的。但任何函数都可以被直接传递，并不需要被“包{\textquotedbl}在一个匿名函数中。比如 \texttt{map(x->f(x), a)} 应当被写成 \hyperlink{11483231213869150535}{\texttt{map(f, a)}}。



\hypertarget{12032676153757060243}{}


\section{尽可能避免使用浮点数作为通用代码的字面量}



当写处理数字，且可以处理多种不同数字类型的参数的通用代码时，请使用对参数影响（通过类型提升）尽可能少的类型的字面量。



例如，




\begin{minted}{jlcon}
julia> f(x) = 2.0 * x
f (generic function with 1 method)

julia> f(1//2)
1.0

julia> f(1/2)
1.0

julia> f(1)
2.0
\end{minted}



而应当被写作：




\begin{minted}{jlcon}
julia> g(x) = 2 * x
g (generic function with 1 method)

julia> g(1//2)
1//1

julia> g(1/2)
1.0

julia> g(1)
2
\end{minted}



如你所见，使用了 \texttt{Int} 字面量的第二个版本保留了输入参数的类型，而第一个版本没有。这是因为例如 \texttt{promote\_type(Int, Float64) == Float64}，且做乘法时会需要类型提升。类似地，\hyperlink{8304566144531167610}{\texttt{Rational}} 字面量比 \hyperlink{5027751419500983000}{\texttt{Float64}} 字面量对类型有着更小的破坏性，但比 \texttt{Int} 大。




\begin{minted}{jlcon}
julia> h(x) = 2//1 * x
h (generic function with 1 method)

julia> h(1//2)
1//1

julia> h(1/2)
1.0

julia> h(1)
2//1
\end{minted}



所以，可能时尽量使用 \texttt{Int} 字面量，对非整数字面量使用 \texttt{Rational\{Int\}}，这样可以让代码变得更容易使用。



\hypertarget{17031291324185486008}{}


\chapter{常见问题}



\hypertarget{2697217483973683039}{}


\section{概述}



\hypertarget{6343873710843101538}{}


\subsection{Julia 的名字来源于某人或某事物吗？}



不。



\hypertarget{13041261795977380154}{}


\subsection{为什么不把 Matlab/Python/R 或者其他语言的代码编译为 Julia 呢？}



由于大多数人对其他动态语言的语法很熟悉，而且已经在这些动态语言中编写了很多代码，人们也许会问：为什么我们不直接设计以Julia为后端的Matlab或是Python前端（也就是把其他代码“转译”到Julia）？这样既能获得Julia的高性能，也能避免程序员花费精力来学一门新的语言。这是一个简单的解决方案，不是吗？



总的来说，我们这样做是因为 \textbf{Julia 编译器没有什么特别之处}：我们使用的是普通的编译器（LLVM），这里面没有什么其他语言开发者所不知道的“独家秘方”。诚然，Julia编译器在许多地方比其他动态语言的编译器更简单（比如 PyPy 和 LuaJIT）。Julia 的性能优势几乎完全来自其前端：它的语义学使得 \hyperlink{818954303942149020}{高质量的 Julia 程序} 能够给予编译器更多的机会来产生高效的代码和内存结构。如果你尝试将 Matlab 或 Python 代码编译为 Julia，我们的编译器会被其语义学限制而不能产生相对现有编译器更好的代码（甚至更差）。语义学的关键角色也正是一些现存的 Python 编译器（像 Numba 和 Pythran）仅仅尝试优化语言的一小部分（比如 Numpy 的矢量与标量运算）的原因，而这些部分已经至少在相同的语义学上与我们做的一样好。致力于这些项目的人员难以置信得聪明并且已经取得了令人惊叹的成就，但为被解释而设计的语言加装编译器是十分困难的。



Julia 的优势在于好的性能不止被限制在一小部分的内置类型与操作，用户能够写出使用任意自定义类型的高级泛型代码，同时也能保证很高的运行与内存效率。在如 Python 一般的语言中，类型没有给编译器提供太多的信息来达成这样的目的，当你试图像使用 Julia 前端一样使用这些语言时，你会遇到困难。



出于类似的原因，自动翻译为 Julia 的代码一般来说会是可读性差、缓慢且违反习惯的代码。这些代码不是从其他语言迁移到 Julia 的好的起点。



另一方面，语言\textbf{可迁移性}是极其有用的：我们会在一些时候想要将其他语言的高质量代码迁移到 Julia 中（也可能相反）。这一工作的最佳实践不是翻译器，而是使用简单的跨语言调用。我们对此有许多工作，从内置的 \texttt{ccall} （来调用 C 和 Fortran 模块）到\href{https://github.com/JuliaInterop}{JuliaInterop} 包来链接 Julia 和 Python、Matlab、C++ 以及更多语言。



\hypertarget{13920778722662354139}{}


\section{公共 API}



\hypertarget{8601842790836713122}{}


\subsection{Julia 如何定义其公共 API？}



对于 \texttt{julia} 版本的 \href{https://semver.org/}{SemVer}，唯一稳定的接口是 Julia 的 \texttt{Base} 和 \href{https://docs.julialang.org/}{文档} 中的标准库接口中且未标记为不稳定（例如，实验性的和内部性的）的部分。 如果函数、类型和常量未包含在文档中，则它们不是公共 API 的一部分，\emph{即使它们具有文档}。



\hypertarget{9375534551924275108}{}


\subsection{有一个有用的非官方的函数/类型/常量。我可以使用它吗？}



如果您使用非公共 API，更新 Julia 可能会使你的代码失效。 如果代码是自洽的，最好将其复制到你的项目中。 如果你想依赖一个复杂的非公共 API，尤其是从稳定的包中使用它时，最好打开发起 \href{https://github.com/JuliaLang/julia/issues}{issue} 或 \href{https://github.com/JuliaLang/julia/pulls}{pull request} 开始讨论将其转换为公共 API。 尽管你可以在下游自己开发一个包来封装这个内部实现，并且屏蔽不同的 \texttt{Julia} 版本差异，但我们并不鼓励这样做。



\hypertarget{17418216214092674945}{}


\subsection{文档不够准确。 我可以依赖现有的行为吗？}



请发起一个 \href{https://github.com/JuliaLang/julia/issues}{issue} 或 \href{https://github.com/JuliaLang/julia/pulls}{pull request} 开始讨论将现有行为转换为公共 API。



\hypertarget{4239210502811614787}{}


\section{会话和 REPL}



\hypertarget{503979811911045199}{}


\subsection{如何从内存中删除某个对象？}



Julia 没有类似于 MATLAB 的 \texttt{clear} 函数，某个名称一旦定义在 Julia 的会话中（准确地说，在 \texttt{Main} 模块中），它就会一直存在下去。



如果关心内存使用情况，你可以用消耗较少内存的对象替换原对象。 例如，如果 \texttt{A} 是一个你不再需要的千兆字节大小的数组，你可以使用 \texttt{A = nothing} 来释放内存。 下次垃圾收集器运行时会释放内存； 您可以使用 \hyperlink{16287035550645122381}{\texttt{GC.gc()}} 强制执行此操作。 此外，尝试使用 \texttt{A} 可能会导致错误，因为大多数方法都没有在类型 \texttt{Nothing} 上定义。



\hypertarget{191104846954255908}{}


\subsection{如何在会话中修改某个类型的声明？}



也许你定义了某个类型，后来发现需要向其中增加一个新的域。如果在 REPL 中尝试这样做，会得到一个错误：




\begin{lstlisting}
ERROR: invalid redefinition of constant MyType
\end{lstlisting}



模块 \texttt{Main} 中的类型不能重新定义。



尽管这在开发新代码时会造成不便，但是这个问题仍然有一个不错的解决办法：可以用重新定义的模块替换原有的模块，把所有新代码封装在一个模块里，这样就能重新定义类型和常量了。虽说不能将类型名称导入到 \texttt{Main} 模块中再去重新定义，但是可以用模块名来改变作用范围。换言之，开发时的工作流可能类似这样：




\begin{minted}{julia}
include("mynewcode.jl") # this defines a module MyModule
obj1 = MyModule.ObjConstructor(a, b)
obj2 = MyModule.somefunction(obj1)
# Got an error. Change something in "mynewcode.jl"
include("mynewcode.jl") # reload the module
obj1 = MyModule.ObjConstructor(a, b) # old objects are no longer valid, must reconstruct
obj2 = MyModule.somefunction(obj1) # this time it worked!
obj3 = MyModule.someotherfunction(obj2, c)
...
\end{minted}



\hypertarget{11224408082580741592}{}


\section{脚本}



\hypertarget{14939284717840791757}{}


\subsection{该如何检查当前文件是否正在以主脚本运行？}



当一个文件通过使用 \texttt{julia file.jl} 来当做主脚本运行时，有人也希望激活另外的功能例如命令行参数操作。确定文件是以这个方式运行的一个方法是检查 \texttt{abspath(PROGRAM\_FILE) == @\_\_FILE\_\_} 是不是 \texttt{true}。



\hypertarget{5414221961728470242}{}


\subsection{怎样在脚本中捕获 CTRL-C ？}



通过 \texttt{julia file.jl} 方式运行的 Julia 脚本，在你尝试按 CTRL-C (SIGINT) 中止它时，并不会抛出 \hyperlink{11255134339055983338}{\texttt{InterruptException}}。如果希望在脚本终止之后运行一些代码，请使用 \hyperlink{17479944696971324992}{\texttt{atexit}}，注意：脚本的中止不一定是由 CTRL-C 导致的。 另外你也可以通过 \texttt{julia -e {\textquotesingle}include(popfirst!(ARGS)){\textquotesingle} file.jl} 命令运行脚本，然后可以通过 \hyperlink{16338536928035025961}{\texttt{try}} 捕获 \texttt{InterruptException}。



\hypertarget{15272704088350857853}{}


\subsection{怎样通过 \texttt{\#!/usr/bin/env} 传递参数给 \texttt{julia}？}



通过类似 \texttt{\#!/usr/bin/env julia --startup-file=no} 的方式，使用 shebang 传递选项给 Julia 的方法，可能在像 Linux 这样的平台上无法正常工作。这是因为各平台上 shebang 的参数解析是平台相关的，并且尚未标准化。 在类 Unix 的环境中，可以通过以 \texttt{bash} 脚本作为可执行脚本的开头，并使用 \texttt{exec} 代替给 \texttt{julia} 传递选项的过程，来可靠的为 \texttt{julia} 传递选项。




\begin{minted}{julia}
#!/bin/bash
#=
exec julia --color=yes --startup-file=no "${BASH_SOURCE[0]}" "$@"
=#

@show ARGS  # put any Julia code here
\end{minted}



在以上例子中，位于 \texttt{\#=} 和 \texttt{=\#} 之间的代码可以当作一个 \texttt{bash} 脚本。 因为这些代码放在 Julia 的多行注释中，所以 Julia 会忽略它们。 在 \texttt{=\#} 之后的 Julia 代码会被 \texttt{bash} 忽略，J因为当文件解析到 \texttt{exec} 语句时会停止解析，开始执行命令。



\begin{quote}
\textbf{Note}

为了在脚本中捕获 \hyperlink{15294909856889946817}{catch CTRL-C} ，我们可以使用


\begin{minted}{julia}
#!/bin/bash
#=
exec julia --color=yes --startup-file=no -e 'include(popfirst!(ARGS))' \
    "${BASH_SOURCE[0]}" "$@"
=#

@show ARGS  # put any Julia code here
\end{minted}

instead. Note that with this strategy \hyperlink{9054270179006636705}{\texttt{PROGRAM\_FILE}} will not be set.

\end{quote}


\hypertarget{5727276226756196747}{}


\section{函数}



\hypertarget{7382572299104431822}{}


\subsection{向函数传递了参数 \texttt{x}，在函数中做了修改，但是在函数外变量 \texttt{x} 的值还是没有变。为什么？}



假设函数被如此调用：




\begin{minted}{jlcon}
julia> x = 10
10

julia> function change_value!(y)
           y = 17
       end
change_value! (generic function with 1 method)

julia> change_value!(x)
17

julia> x # x is unchanged!
10
\end{minted}



在 Julia 中，通过将 \texttt{x} 作为参数传递给函数，不能改变变量 \texttt{x} 的绑定。在上例中，调用 \texttt{change\_value!(x)} 时，\texttt{y} 是一个新建变量，初始时与 \texttt{x} 的值绑定，即 \texttt{10}。然后 \texttt{y} 与常量 \texttt{17} 重新绑定，此时变量外作用域中的 \texttt{x} 并没有变动。



假设 \texttt{x} 被绑定至 \texttt{Array} 类型 (也有可能是其他 \emph{可变} 的类型)。在函数中，你无法将 \texttt{x} 与 Array \emph{解绑}，但是你可以改变其内容。




\begin{minted}{jlcon}
julia> x = [1,2,3]
3-element Vector{Int64}:
 1
 2
 3

julia> function change_array!(A)
           A[1] = 5
       end
change_array! (generic function with 1 method)

julia> change_array!(x)
5

julia> x
3-element Vector{Int64}:
 5
 2
 3
\end{minted}



这里我们新建了一个函数 \texttt{chang\_array!}，它把 \texttt{5} 赋值给传入的数组（在调用处与 \texttt{x} 绑定，在函数中与 \texttt{A} 绑定）的第一个元素。注意，在函数调用之后，\texttt{x} 依旧与同一个数组绑定，但是数组的内容变化了：变量 \texttt{A} 和 \texttt{x} 是不同的绑定，引用同一个可变的 \texttt{Array} 对象。



\hypertarget{10749355378766657270}{}


\subsection{函数内部能否使用 \texttt{using} 或 \texttt{import}？}



不可以，不能在函数内部使用 \texttt{using} 或 \texttt{import} 语句。如果你希望导入一个模块，但只在特定的一个或一组函数中使用它的符号，有以下两种方式：



\begin{itemize}
\item[1. ] 使用 \texttt{import}：


\begin{minted}{julia}
import Foo
function bar(...)
    # ... refer to Foo symbols via Foo.baz ...
end
\end{minted}

这会加载 \texttt{Foo} 模块，同时定义一个变量 \texttt{Foo} 引用该模块，但并不会 将其他任何符号从该模块中导入当前的命名空间。 \texttt{Foo} 等符号可以由限定的名称 \texttt{Foo.bar} 等引用。


\item[2. ] 将函数封装到模块中：


\begin{minted}{julia}
module Bar
export bar
using Foo
function bar(...)
    # ... refer to Foo.baz as simply baz ....
end
end
using Bar
\end{minted}

这会从 \texttt{Foo} 中导入所有符号，但仅限于 \texttt{Bar} 模块内。

\end{itemize}


\hypertarget{425348862563535930}{}


\subsection{运算符 \texttt{...} 有何作用？}



\hypertarget{6176809975782961444}{}


\subsubsection{\texttt{...} 运算符的两个用法：slurping 和 splatting}



很多 Julia 的新手会对运算符 \texttt{...} 的用法感到困惑。让 \texttt{...} 用法如此困惑的部分原因是根据上下文它有两种不同的含义。



\hypertarget{7095517523544633865}{}


\subsubsection{\texttt{...} 在函数定义中将多个参数组合成一个参数}



在函数定义的上下文中，\texttt{...}运算符用来将多个不同的参数组合成单个参数。\texttt{...}运算符的这种将多个不同参数组合成单个参数的用法称为slurping：




\begin{minted}{jlcon}
julia> function printargs(args...)
           println(typeof(args))
           for (i, arg) in enumerate(args)
               println("Arg #$i = $arg")
           end
       end
printargs (generic function with 1 method)

julia> printargs(1, 2, 3)
Tuple{Int64, Int64, Int64}
Arg #1 = 1
Arg #2 = 2
Arg #3 = 3
\end{minted}



如果Julia是一个使用ASCII字符更加自由的语言的话，slurping运算符可能会写作\texttt{<-...}而非\texttt{...}。



\hypertarget{4752115827323838494}{}


\subsubsection{\texttt{...}在函数调用中将一个参数分解成多个不同参数}



与在定义函数时表示将多个不同参数组合成一个参数的\texttt{...}运算符用法相对，当用在函数调用的上下文中\texttt{...}运算符也用来将单个的函数参数分成多个不同的参数。\texttt{...}函数的这个用法叫做splatting：




\begin{minted}{jlcon}
julia> function threeargs(a, b, c)
           println("a = $a::$(typeof(a))")
           println("b = $b::$(typeof(b))")
           println("c = $c::$(typeof(c))")
       end
threeargs (generic function with 1 method)

julia> x = [1, 2, 3]
3-element Vector{Int64}:
 1
 2
 3

julia> threeargs(x...)
a = 1::Int64
b = 2::Int64
c = 3::Int64
\end{minted}



如果Julia是一个使用ASCII字符更加自由的语言的话，splatting运算符可能会写作\texttt{...->}而非\texttt{...}。



\hypertarget{18313029058103158138}{}


\subsection{赋值语句的返回值是什么？}



\texttt{=}运算符始终返回右侧的值，所以：




\begin{minted}{jlcon}
julia> function threeint()
           x::Int = 3.0
           x # returns variable x
       end
threeint (generic function with 1 method)

julia> function threefloat()
           x::Int = 3.0 # returns 3.0
       end
threefloat (generic function with 1 method)

julia> threeint()
3

julia> threefloat()
3.0
\end{minted}



相似地：




\begin{minted}{jlcon}
julia> function twothreetup()
           x, y = [2, 3] # assigns 2 to x and 3 to y
           x, y # returns a tuple
       end
twothreetup (generic function with 1 method)

julia> function twothreearr()
           x, y = [2, 3] # returns an array
       end
twothreearr (generic function with 1 method)

julia> twothreetup()
(2, 3)

julia> twothreearr()
2-element Vector{Int64}:
 2
 3
\end{minted}



\hypertarget{5608144491570256308}{}


\section{类型，类型声明和构造函数}



\hypertarget{11170875837665758023}{}


\subsection{何谓“类型稳定”？}



这意味着输出的类型可以由输入的类型预测出来。特别地，这意味着输出的类型不会因输入的\emph{值}的不同而变化。以下代码\emph{不是}类型稳定的：




\begin{minted}{jlcon}
julia> function unstable(flag::Bool)
           if flag
               return 1
           else
               return 1.0
           end
       end
unstable (generic function with 1 method)
\end{minted}



根据参数值的不同，该函数可能返回 \texttt{Int} 或 \hyperlink{5027751419500983000}{\texttt{Float64}}。由于 Julia 无法在编译期预测该函数的返回值类型，任何使用该函数的计算都需要考虑这两种可能的返回类型，这样难以生成高效的机器码。



\hypertarget{6904365807459053438}{}


\subsection{为何 Julia 对某个看似合理的操作返回 \texttt{DomainError}？}



某些运算在数学上有意义，但会产生错误：




\begin{minted}{jlcon}
julia> sqrt(-2.0)
ERROR: DomainError with -2.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
[...]
\end{minted}



这一行为是为了保证类型稳定而带来的不便。对于 \hyperlink{4551113327515323898}{\texttt{sqrt}}，许多用户会希望 \texttt{sqrt(2.0)} 产生一个实数，如果得到了复数 \texttt{1.4142135623730951 + 0.0im} 则会不高兴。也可以编写 \hyperlink{4551113327515323898}{\texttt{sqrt}} 函数，只有当传递一个负数时才切换到复值输出，但结果将不是\hyperlink{5872221809740029239}{类型稳定}的，而且 \hyperlink{4551113327515323898}{\texttt{sqrt}} 函数的性能会很差。



在这样那样的情况下，若你想得到希望的结果，你可以选择一个\emph{输入类型}，它可以使根据你的想法接受一个\emph{输出类型}，从而结果可以这样表示：




\begin{minted}{jlcon}
julia> sqrt(-2.0+0im)
0.0 + 1.4142135623730951im
\end{minted}



\hypertarget{12834294993005118106}{}


\subsection{怎样限制或计算类型参数？}



\hyperlink{5611641345231583503}{参数类型} 的参数可以包含类型或比特值，并且类型本身选择如何使用这些参数。例如，\texttt{Array\{Float64, 2\}} 由类型 \texttt{Float64} 参数化以表示其元素类型，并通过整数值 \texttt{2} 来表示其维度数。在定义自己的参数类型时，可以使用子类型约束来声明某个参数必须是某个抽象类型的子类型 (\hyperlink{6254591906563366276}{\texttt{<:}}) 或以前的类型参数。但是，没有专用的语法来声明参数必须是给定类型的\emph{值} — 也就是说，例如，你不能在\texttt{struct}定义中直接声明一个维度参数 \hyperlink{7066325108767373297}{\texttt{isa}} \texttt{Int}。同样，你不能对类型参数进行计算（包括简单的加法或减法）。相反，这些类型的约束和关系可以通过在类型的 \hyperlink{1489967485005487723}{构造函数} 中计算和强制执行的附加类型参数来表达。



例如，考虑




\begin{minted}{julia}
struct ConstrainedType{T,N,N+1} # NOTE: INVALID SYNTAX
    A::Array{T,N}
    B::Array{T,N+1}
end
\end{minted}



其中，用户希望强制第三个类型参数始终是第二个参数加一。 这可以使用显式类型参数来实现，该参数由 \hyperlink{5052047505447273614}{内部构造函数方法}（可以与其他检查结合使用）进行检查：




\begin{minted}{julia}
struct ConstrainedType{T,N,M}
    A::Array{T,N}
    B::Array{T,M}
    function ConstrainedType(A::Array{T,N}, B::Array{T,M}) where {T,N,M}
        N + 1 == M || throw(ArgumentError("second argument should have one more axis" ))
        new{T,N,M}(A, B)
    end
end
\end{minted}



这种检查通常是\emph{无成本的}，因为编译器可以省略对有效具体类型的检查。 如果还计算了第二个参数，则提供执行此计算的 \hyperlink{1408947822788665444}{外部构造函数方法} 可能更好：




\begin{minted}{julia}
ConstrainedType(A) = ConstrainedType(A, compute_B(A))
\end{minted}



\hypertarget{3408319939041447292}{}


\subsection{为什么Julia使用机器算法进行整数运算？}



Julia使用机器算法进行整数计算。这意味着\texttt{Int}的范围是有界的，值在范围的两端循环，也就是说整数的加法，减法和乘法会出现上溢或者下溢，导致出现某些从开始就令人不安的结果：




\begin{minted}{jlcon}
julia> x = typemax(Int)
9223372036854775807

julia> y = x+1
-9223372036854775808

julia> z = -y
-9223372036854775808

julia> 2*z
0
\end{minted}



无疑，这与数学上的整数的行为很不一样，并且你会想对于高阶编程语言来说把这个暴露给用户难称完美。然而，对于效率优先和透明度优先的数值计算来说，其他的备选方案可谓更糟。



一个备选方案是去检查每个整数运算是否溢出，如果溢出则将结果提升到更大的整数类型比如\hyperlink{8012327724714767060}{\texttt{Int128}}或者\hyperlink{423405808990690832}{\texttt{BigInt}}。 不幸的是，这会给所有的整数操作（比如让循环计数器自增）带来巨大的额外开销 — 这需要生成代码去在算法指令后进行运行溢出检测，并生成分支去处理潜在的溢出。更糟糕的是，这会让涉及整数的所有运算变得类型不稳定。如同上面提到的，对于高效生成高效的代码\hyperlink{5872221809740029239}{类型稳定很重要}。如果不指望整数运算的结果是整数，就无法想C和Fortran编译器一样生成快速简单的代码。



这个方法有个变体可以避免类型不稳定的出现，这个变体是将类型\texttt{Int}和\hyperlink{423405808990690832}{\texttt{BigInt}}合并成单个混合整数类型，当结果不再满足机器整数的大小时会内部自动切换表示。虽然表面上在Julia代码层面解决了类型不稳定，但是这个只是通过将所有的困难硬塞给实现混合整数类型的C代码而掩盖了这个问题。这个方法\emph{可能}有用，甚至在很多情况下速度很快，但是它有很多缺点。一个缺点是整数和整数数组的内存上的表示不再与C、Fortran和其他使用原生机器整数的怨言所使用的自然表示一样。所以，为了与那些语言协作，我们无论如何最终都需要引入原生整数类型。任何整数的无界表示都不会占用固定的比特数，所以无法使用固定大小的槽来内联地存储在数组中 — 大的整数值通常需要单独的堆分配的存储。并且无论使用的混合整数实现多么智能，总会存在性能陷阱 — 无法预期的性能下降的情况。复杂的表示，与C和Fortran协作能力的缺乏，无法在不使用另外的堆存储的情况下表示整数数组，和无法预测的性能特性让即使是最智能化的混合整数实现对于高性能数值计算来说也是个很差的选择。



除了使用混合整数和提升到BigInt，另一个备选方案是使用饱和整数算法，此时最大整数值加一个数时值保持不变，最小整数值减一个数时也是同样的。这就是Matlab™的做法：




\begin{lstlisting}
>> int64(9223372036854775807)

ans =

  9223372036854775807

>> int64(9223372036854775807) + 1

ans =

  9223372036854775807

>> int64(-9223372036854775808)

ans =

 -9223372036854775808

>> int64(-9223372036854775808) - 1

ans =

 -9223372036854775808
\end{lstlisting}



乍一看，这个似乎足够合理，因为9223372036854775807比-9223372036854775808更接近于9223372036854775808并且整数还是以固定大小的自然方式表示的，这与C和Fortran相兼容。但是饱和整数算法是很有问题的。首先最明显的问题是这并不是机器整数算法的工作方式，所以实现饱和整数算法需要生成指令，在每个机器整数运算后检查上溢或者下溢并正确地讲这些结果用\hyperlink{3613894539247233488}{\texttt{typemin(Int)}}或者\hyperlink{17760305803764597758}{\texttt{typemax(Int)}}取代。单单这个就将整数运算从单语句的快速的指令扩展成六个指令，还可能包括分支。哎呦喂{\textasciitilde}{\textasciitilde}但是还有更糟的 — 饱和整数算法并不满足结合律。考虑下列的Matlab计算：




\begin{lstlisting}
>> n = int64(2)^62
4611686018427387904

>> n + (n - 1)
9223372036854775807

>> (n + n) - 1
9223372036854775806
\end{lstlisting}



这就让写很多基础整数算法变得困难因为很多常用技术都是基于有溢出的机器加法\emph{是}满足结合律这一事实的。考虑一下在Julia中求整数值\texttt{lo}和\texttt{hi}之间的中点值，使用表达式\texttt{(lo + hi) >>> 1}:




\begin{minted}{jlcon}
julia> n = 2^62
4611686018427387904

julia> (n + 2n) >>> 1
6917529027641081856
\end{minted}



看到了吗？没有任何问题。那就是2{\textasciicircum}62和2{\textasciicircum}63之间的正确地中点值，虽然\texttt{n + 2n}的值是 -4611686018427387904。现在使用Matlab试一下：




\begin{lstlisting}
>> (n + 2*n)/2

ans =

  4611686018427387904
\end{lstlisting}



哎呦喂。在Matlab中添加\texttt{>>>}运算符没有任何作用，因为在将\texttt{n}与\texttt{2n}相加时已经破坏了能计算出正确地中点值的必要信息，已经出现饱和。



没有结合性不但对于不能依靠像这样的技术的程序员是不幸的，并且让几乎所有的希望优化整数算法的编译器铩羽而归。例如，因为Julia中的整数使用平常的机器整数算法，LLVM就可以自由地激进地优化像\texttt{f(k) = 5k-1}这样的简单地小函数。这个函数的机器码如下所示：




\begin{minted}{jlcon}
julia> code_native(f, Tuple{Int})
  .text
Filename: none
  pushq %rbp
  movq  %rsp, %rbp
Source line: 1
  leaq  -1(%rdi,%rdi,4), %rax
  popq  %rbp
  retq
  nopl  (%rax,%rax)
\end{minted}



这个函数的实际函数体只是一个简单地\texttt{leap}指令，可以立马计算整数乘法与加法。当\texttt{f}内联在其他函数中的时候这个更加有益：




\begin{minted}{jlcon}
julia> function g(k, n)
           for i = 1:n
               k = f(k)
           end
           return k
       end
g (generic function with 1 methods)

julia> code_native(g, Tuple{Int,Int})
  .text
Filename: none
  pushq %rbp
  movq  %rsp, %rbp
Source line: 2
  testq %rsi, %rsi
  jle L26
  nopl  (%rax)
Source line: 3
L16:
  leaq  -1(%rdi,%rdi,4), %rdi
Source line: 2
  decq  %rsi
  jne L16
Source line: 5
L26:
  movq  %rdi, %rax
  popq  %rbp
  retq
  nop
\end{minted}



因为\texttt{f}的调用内联化，循环体就只是简单地\texttt{leap}指令。接着，考虑一下如果循环迭代的次数固定的时候会发生什么：




\begin{minted}{jlcon}
julia> function g(k)
           for i = 1:10
               k = f(k)
           end
           return k
       end
g (generic function with 2 methods)

julia> code_native(g,(Int,))
  .text
Filename: none
  pushq %rbp
  movq  %rsp, %rbp
Source line: 3
  imulq $9765625, %rdi, %rax    # imm = 0x9502F9
  addq  $-2441406, %rax         # imm = 0xFFDABF42
Source line: 5
  popq  %rbp
  retq
  nopw  %cs:(%rax,%rax)
\end{minted}



因为编译器知道整数加法和乘法是满足结合律的并且乘法可以在加法上使用分配律 — 两者在饱和算法中都不成立 — 所以编译器就可以把整个循环优化到只有一个乘法和一个加法。饱和算法完全无法使用这种优化，因为在每个循环迭代中结合律和分配律都会失效导致不同的失效位置会得到不同的结果。编译器可以展开循环，但是不能代数上将多个操作简化到更少的等效操作。



让整数算术沉默地溢出的最合理替代方法是在任何地方进行检查算术，在加法、减法和乘法溢出时引发错误，产生不正确的值。 在这篇\href{https://danluu.com/integer-overflow/}{博文}中，Dan Luu 对此进行了分析，并发现这种方法在理论上应该具有的微不足道的成本，但由于编译器（LLVM 和 GCC）没有优雅地围绕添加的溢出检查进行优化，它最终会产生大量成本。 如果这在未来有所改善，我们可以考虑在 Julia 中默认使用检查整数算法，但现在，我们必须忍受可能会溢出这一现状。



同时，可以通过使用\href{https://github.com/JeffreySarnoff/SaferIntegers.jl}{SaferIntegers.jl}等外部库来实现溢出安全的整数运算。 请注意，如前所述，使用这些库会显着增加使用已检查整数类型的代码的执行时间。 但是，对于有限的使用，这远比将其用于所有整数运算时的问题要小得多。你可以在 \href{https://github.com/JuliaLang/julia/issues/855}{此处} 中关注讨论的状态。



\hypertarget{15127813284498705272}{}


\subsection{在远程执行中\texttt{UndefVarError}的可能原因有哪些？}



如同这个错误表述的，远程结点上的\texttt{UndefVarError}的直接原因是变量名的绑定并不存在。让我们探索一下一些可能的原因。




\begin{minted}{jlcon}
julia> module Foo
           foo() = remotecall_fetch(x->x, 2, "Hello")
       end

julia> Foo.foo()
ERROR: On worker 2:
UndefVarError: Foo not defined
Stacktrace:
[...]
\end{minted}



闭包\texttt{x->x}中有\texttt{Foo}的引用，因为\texttt{Foo}在节点2上不存在，所以\texttt{UndefVarError}被扔出。



在模块中而非\texttt{Main}中的全局变量不会在远程节点上按值序列化。只传递了一个引用。新建全局绑定的函数（除了\texttt{Main}中）可能会导致之后扔出\texttt{UndefVarError}。




\begin{minted}{jlcon}
julia> @everywhere module Foo
           function foo()
               global gvar = "Hello"
               remotecall_fetch(()->gvar, 2)
           end
       end

julia> Foo.foo()
ERROR: On worker 2:
UndefVarError: gvar not defined
Stacktrace:
[...]
\end{minted}



在上面的例子中，\texttt{@everywhere module Foo}在所有节点上定义了\texttt{Foo}。但是调用\texttt{Foo.foo()}在本地节点上新建了新的全局绑定\texttt{gvar}，但是节点2中并没有找到这个绑定，这会导致\texttt{UndefVarError}错误。



注意着并不适用于在模块\texttt{Main}下新建的全局变量。模块\texttt{Main}下的全局变量会被序列化并且在远程节点的\texttt{Main}下新建新的绑定。




\begin{minted}{jlcon}
julia> gvar_self = "Node1"
"Node1"

julia> remotecall_fetch(()->gvar_self, 2)
"Node1"

julia> remotecall_fetch(varinfo, 2)
name          size summary
––––––––– –––––––– –––––––
Base               Module
Core               Module
Main               Module
gvar_self 13 bytes String
\end{minted}



这并不适用于\texttt{函数}或者\texttt{结构体}声明。但是绑定到全局变量的匿名函数被序列化，如下例所示。




\begin{minted}{jlcon}
julia> bar() = 1
bar (generic function with 1 method)

julia> remotecall_fetch(bar, 2)
ERROR: On worker 2:
UndefVarError: #bar not defined
[...]

julia> anon_bar  = ()->1
(::#21) (generic function with 1 method)

julia> remotecall_fetch(anon_bar, 2)
1
\end{minted}



\hypertarget{799645384386008726}{}


\section{“method not matched”故障排除：参数类型不变性和\texttt{MethodError}}



\hypertarget{6536932508769855811}{}


\subsection{为什么声明 \texttt{foo(bar::Vector\{Real\}) = 42} 然后调用 \texttt{foo([1])} 不起作用？}



如果你尝试了，结果就会看到\texttt{MethodError}:




\begin{minted}{jlcon}
julia> foo(x::Vector{Real}) = 42
foo (generic function with 1 method)

julia> foo([1])
ERROR: MethodError: no method matching foo(::Vector{Int64})
Closest candidates are:
  foo(!Matched::Vector{Real}) at none:1
\end{minted}



这是因为 \texttt{Vector\{Real\}} 不是 \texttt{Vector\{Int\}} 的超类型！ 您可以使用类似 \texttt{foo(bar::Vector\{T\}) where \{T<:Real\}}（或缩写 \texttt{foo(bar::Vector\{<:Real\})} 如果静态参数函数体中不需要\texttt{T}）。\texttt{T} 是一个通配符：首先指定它必须是 Real 的子类型，然后指定函数采用具有该类型元素的 Vector 。



同样的问题适用于任何复合类型\texttt{Comp}，而不仅仅是\texttt{Vector}。 如果\texttt{Comp} 有一个声明为\texttt{Y} 类型的参数，那么另一个带有\texttt{X<:Y} 类型参数的类型\texttt{Comp2} 不是\texttt{Comp} 的子类型。 这是类型不变性（相比之下，元组在其参数中是类型协变的）。 有关这些的更多解释，请参阅 \hyperlink{17413469367194810249}{参数复合类型}。



\hypertarget{6739766638073943445}{}


\subsection{为什么 Julia 使用 \texttt{*} 进行字符串拼接？而不是使用 \texttt{+} 或其他符号？}



使用 \texttt{+}  的\hyperlink{12933998460683957945}{主要依据}是：字符串拼接是不可交换的操作，而 \texttt{+} 通常是一个具有可交换性的操作符。Julia 社区也意识到其他语言使用了不同的操作符，一些用户也可能不熟悉 \texttt{*} 包含的特定代数性值。



注意：你也可以用 \texttt{string(...)} 来拼接字符串和其他能转换成字符串的值； 类似的 \texttt{repeat} 函数可以用于替代用于重复字符串的 \texttt{{\textasciicircum}} 操作符。 \hyperlink{4452850363638134205}{字符串插值语法}在构造字符串时也很常用。



\hypertarget{16669380183019264286}{}


\section{包和模块}



\hypertarget{18070754917834956483}{}


\subsection{{\textquotedbl}using{\textquotedbl}和{\textquotedbl}import{\textquotedbl}的区别是什么？}



只有一个区别，并且在表面上（语法层面）这个区别看来很小。\texttt{using}和\texttt{import}的区别是使用\texttt{using}时你需要写\texttt{function Foo.bar(..}来用一个新方法来扩展模块Foo的函数bar，但是使用\texttt{import Foo.bar}时，你只需要写\texttt{function bar(...}，会自动扩展模块Foo的函数bar。



这个区别足够重要以至于提供不同的语法的原因是你不希望意外地扩展一个你根本不知道其存在的函数，因为这很容易造成bug。对于使用像字符串后者整数这样的常用类型的方法最有可能出现这个问题，因为你和其他模块都可能定义了方法来处理这样的常用类型。如果你使用\texttt{import}，你会用你自己的新实现覆盖别的函数的\texttt{bar(s::AbstractString)}实现，这会导致做的事情天差地别（并且破坏模块Foo中其他的依赖于调用bar的函数的所有/大部分的将来的使用）。



\hypertarget{16234869582973036611}{}


\section{空值与缺失值}



\hypertarget{7783935872990633567}{}


\subsection{在Julia中{\textquotedbl}null{\textquotedbl}，{\textquotedbl}空{\textquotedbl}或者{\textquotedbl}缺失{\textquotedbl}是怎么工作的?}



不像其它很多语言（例如 C 和 Java），Julia 对象默认不能为{\textquotedbl}null{\textquotedbl}。当一个引用（变量，对象域，或者数组元素）没有被初始化，访问它会立即扔出一个错误。这种情况可以使用函数 \hyperlink{11212950246505288748}{\texttt{isdefined}} 或者 \hyperlink{976355747478401147}{\texttt{isassigned}} 检测到。



一些函数只为了其副作用使用，并不需要返回一个值。在这些情况下，约定的是返回 \texttt{nothing} 这个值，这只是 \texttt{Nothing} 类型的一个单例对象。这是一个没有域的一般类型；除了这个约定之外没有任何特殊点，REPL 不会为它打印任何东西。有些语言结构不会有值，也产生 \texttt{nothing}，例如 \texttt{if false; end}。



对于类型\texttt{T}的值\texttt{x}只会有时存在的情况，\texttt{Union\{T,Nothing\}}类型可以用作函数参数，对象域和数组元素的类型，与其他语言中的\href{https://en.wikipedia.org/wiki/Nullable\_type}{\texttt{Nullable}, \texttt{Option} or \texttt{Maybe}}相等。如果值本身可以是\texttt{nothing}(显然当\texttt{T}是\texttt{Any}时），\texttt{Union\{Some\{T\}, Nothing\}}类型更加准确因为\texttt{x == nothing}表示值的缺失，\texttt{x == Some(nothing)}表示与\texttt{nothing}相等的值的存在。\hyperlink{12366229165852827603}{\texttt{something}}函数允许使用默认值的展开的\texttt{Some}对象，而非\texttt{nothing}参数。注意在使用\texttt{Union\{T,Nothing\}}参数或者域时编译器能够生成高效的代码。



在统计环境下表示缺失的数据（R 中的 \texttt{NA} 或者 SQL 中的 \texttt{NULL}）请使用 \hyperlink{14596725676261444434}{\texttt{missing}} 对象。请参照\hyperlink{5842114294087241506}{\texttt{缺失值}}章节来获取详细信息。



在某些语言中，空元组 (\texttt{()}) 被认为是{\textquotedbl}没有“的规范形式。但是，在 julia 中，最好将其视为恰好包含零个值的常规元组。



空（或者{\textquotedbl}底层{\textquotedbl}）类型，写作\texttt{Union\{\}}（空的union类型）是没有值和子类型（除了自己）的类型。通常你没有必要用这个类型。



\hypertarget{12500994751877938228}{}


\section{内存}



\hypertarget{2527646600001256276}{}


\subsection{为什么当\texttt{x}和\texttt{y}都是数组时\texttt{x += y}还会申请内存？}



在 Julia 中，\texttt{x += y} 在语法分析中会用 \texttt{x = x + y} 代替。对于数组，结果就是它会申请一个新数组来存储结果，而非把结果存在 \texttt{x} 同一位置的内存上。



这个行为可能会让一些人吃惊，但是这个结果是经过深思熟虑的。主要原因是Julia中的不可变对象，这些对象一旦新建就不能改变他们的值。实际上，数字是不可变对象，语句\texttt{x = 5; x += 1}不会改变\texttt{5}的意义，改变的是与\texttt{x}绑定的值。对于不可变对象，改变其值的唯一方法是重新赋值。



为了稍微详细一点，考虑下列的函数：




\begin{minted}{julia}
function power_by_squaring(x, n::Int)
    ispow2(n) || error("此实现只适用于2的幂")
    while n >= 2
        x *= x
        n >>= 1
    end
    x
end
\end{minted}



在\texttt{x = 5; y = power\_by\_squaring(x, 4)}调用后，你可以得到期望的结果\texttt{x == 5 \&\& y == 625}。然而，现在假设当\texttt{*=}与矩阵一起使用时会改变左边的值，这会有两个问题：



\begin{itemize}
\item 对于普通的方阵，\texttt{A = A*B} 不能在没有临时存储的情况下实现：\texttt{A[1,1]} 会被计算并且在被右边使用完之前存储在左边。


\item 假设你愿意申请一个计算的临时存储（这会消除 \texttt{*=}就地计算的大部分要点）；如果你利用了\texttt{x}的可变性， 这个函数会对于可变和不可变的输入有不同的行为。特别地， 对于不可变的\texttt{x}，在调用后（通常）你会得到\texttt{y != x}，而对可变的\texttt{x}，你会有\texttt{y == x}。

\end{itemize}


因为支持范用计算被认为比能使用其他方法完成的潜在的性能优化（比如使用显式循环）更加重要，所以像\texttt{+=}和\texttt{*=}运算符以绑定新值的方式工作。



\hypertarget{11478691918903630142}{}


\section{异步 IO 与并发同步写入}



\hypertarget{6102848140854273508}{}


\subsection{为什么对于同一个流的并发写入会导致相互混合的输出？}



虽然流式 I/O 的 API 是同步的，底层的实现是完全异步的。



思考一下下面的输出：




\begin{minted}{jlcon}
julia> @sync for i in 1:3
           @async write(stdout, string(i), " Foo ", " Bar ")
       end
123 Foo  Foo  Foo  Bar  Bar  Bar
\end{minted}



这是因为，虽然\texttt{write}调用是同步的，每个参数的写入在等待那一部分I/O完成时会生成其他的Tasks。



\texttt{print}和\texttt{println}在调用中会{\textquotedbl}锁定{\textquotedbl}该流。因此把上例中的\texttt{write}改成\texttt{println}会导致：




\begin{minted}{jlcon}
julia> @sync for i in 1:3
           @async println(stdout, string(i), " Foo ", " Bar ")
       end
1 Foo  Bar
2 Foo  Bar
3 Foo  Bar
\end{minted}



你可以使用\texttt{ReentrantLock}来锁定你的写入，就像这样：




\begin{minted}{jlcon}
julia> l = ReentrantLock();

julia> @sync for i in 1:3
           @async begin
               lock(l)
               try
                   write(stdout, string(i), " Foo ", " Bar ")
               finally
                   unlock(l)
               end
           end
       end
1 Foo  Bar 2 Foo  Bar 3 Foo  Bar
\end{minted}



\hypertarget{11524621654961197830}{}


\section{数组}



\hypertarget{8539259979709593447}{}


\subsection{零维数组和标量之间的有什么差别？}



零维数组是\texttt{Array\{T,0\}}形式的数组，它与标量的行为相似，但是有很多重要的不同。这值得一提，因为这是使用数组的范用定义来解释也符合逻辑的特殊情况，虽然最开始看起来有些非直觉。下面一行定义了一个零维数组：




\begin{lstlisting}
julia> A = zeros()
0-dimensional Array{Float64,0}:
0.0
\end{lstlisting}



在这个例子中，\texttt{A}是一个含有一个元素的可变容器，这个元素可以通过\texttt{A[] = 1.0}来设置，通过\texttt{A[]}来读取。所有的零维数组都有同样的大小（\texttt{size(A) == ()}）和长度（\texttt{length(A) == 1}）。特别地，零维数组不是空数组。如果你觉得这个非直觉，这里有些想法可以帮助理解Julia的这个定义。



\begin{itemize}
\item 类比的话，零维数组是{\textquotedbl}点{\textquotedbl}，向量是{\textquotedbl}线{\textquotedbl}而矩阵 是{\textquotedbl}面{\textquotedbl}。就像线没有面积一样（但是也能代表事物的一个集合）, 点没有长度和任意一个维度（但是也能表示一个事物）。


\item 我们定义\texttt{prod(())}为1，一个数组中的所有的元素个数是 大小的乘积。零维数组的大小为\texttt{()}，所以 它的长度为\texttt{1}。


\item 零维数组没有任何你可以索引的维度——它们仅仅是\texttt{A[]}。我们可以给它们应用同样的{\textquotedbl}尾一{\textquotedbl}规则就像对其它维度数组那样，比如\texttt{A[1]}，\texttt{A[1,1]}，等；参见\hyperlink{16741454967402507490}{Omitted and extra indices}.

\end{itemize}


理解它与普通的标量之间的区别也很重要。标量不是一个可变的容器（尽管它们是可迭代的，可以定义像\texttt{length}，\texttt{getindex}这样的东西，\emph{例如}\texttt{1[] == 1}）。特别地，如果\texttt{x = 0.0}是以一个标量来定义，尝试通过\texttt{x[] = 1.0}来改变它的值会报错。标量\texttt{x}能够通过\texttt{fill(x)}转化成包含它的零维数组，并且相对地，一个零维数组\texttt{a}可以通过\texttt{a[]}转化成其包含的标量。另外一个区别是标量可以参与到线性代数运算中，比如\texttt{2 * rand(2,2)}，但是零维数组的相似操作\texttt{fill(2) * rand(2,2)}会报错。



\hypertarget{1475135678057097278}{}


\subsection{为什么我的Julia的线性代数操作测试与其他的语言不同。}



你可能找到一些简单的线性代数测试，比如，




\begin{minted}{julia}
using BenchmarkTools
A = randn(1000, 1000)
B = randn(1000, 1000)
@btime $A \ $B
@btime $A * $B
\end{minted}



也许和其他语言不同比如Matlab或R。



由于像这样的操作都非常直接地从相关的BLAS函数调用，这样做的原因是，



\begin{itemize}
\item[1. ] 在每种语言中使用的BLAS库


\item[2. ] 并发线程的数量

\end{itemize}


Julia 编译并使用自己的 OpenBLAS 副本，当前线程数上限为 8（或内核数）。



修改 OpenBLAS 设置或使用不同的 BLAS 库编译 Julia，例如 \href{https://software.intel.com/en-us/mkl}{Intel MKL}，可能会提高性能。 你可以使用 \href{https://github.com/JuliaComputing/MKL.jl}{MKL.jl}，这是一个使 Julia 的线性代数使用英特尔 MKL BLAS 和 LAPACK 而不是 OpenBLAS 的包，或搜索论坛以获取有关如何使用的建议。 请注意，英特尔 MKL 不能与 Julia 捆绑在一起，因为它不是开源的。



\hypertarget{1807339410285786625}{}


\section{计算集群}



\hypertarget{16944626185242570374}{}


\subsection{我该如何管理分布式文件系统的预编译缓存？}



在高性能计算 (HPC) 设施中使用 \texttt{julia} 时，同时调用 \emph{n} 个 \texttt{julia} 进程最多会创建 \emph{n} 个预编译缓存文件的临时副本。 如果这是一个问题（缓慢和/或小型分布式文件系统），你可以：



\begin{itemize}
\item[1. ] 使用 \texttt{julia}的 \texttt{--compiled-modules=no} 标志来关掉预编译。


\item[2. ] 使用 \texttt{pushfirst!(DEPOT\_PATH, private\_path)} 配置一个私有的可写仓库 在这里\texttt{private\_path}是一个路径单独地到这个\texttt{julia}进程 也可以通过设置环境变量 \texttt{JULIA\_DEPOT\_PATH} 到 \texttt{\$private\_path:\$HOME/.julia}.


\item[3. ] 在scratch里创建到 \texttt{{\textasciitilde}/.julia/compiled}的符号链接。

\end{itemize}


\hypertarget{13975497382718262394}{}


\section{Julia 版本发布}



\hypertarget{9334472587960710746}{}


\subsection{你希望使用稳定的、长期支持的或是每日构建版本的Julia？}



Julia 的稳定版是最新发布的 Julia 版本，这是大多数人想要运行的版本。 它具有最新的功能，包括改进的性能。 Julia 的稳定版本根据 \href{https://semver.org/}{SemVer} 版本化为 v1.x.y。 在作为候选版本进行几周的测试后，大约每 4-5 个月就会发布一个与新稳定版本相对应的新 Julia 次要版本。 与 LTS 版本不同，在 Julia 的另一个稳定版本发布后，稳定版本通常不会收到错误修正。 但是，始终可以升级到下一个稳定版本，因为 Julia v1.x 的每个版本都将继续运行为早期版本编写的代码。



如果正在寻找非常稳定的代码库，你可能更喜欢 Julia 的 LTS（长期支持）版本。 Julia 当前的 LTS 版本根据 SemVer 版本为 v1.0.x； 此分支将继续接收错误修复，直到选择新的 LTS 分支，此时 v1.0.x 系列将不再收到常规错误修复，建议除最保守的用户之外的所有用户升级到新的 LTS 版本系列。作为软件包开发人员，你可能更喜欢针对 LTS 版本进行开发，以最大限度地增加可以使用你的软件包的用户数量。 根据 SemVer，为 v1.0 编写的代码将继续适用于所有未来的 LTS 和稳定版本。 一般来说，即使针对 LTS，也可以在最新的 Stable 版本中开发和运行代码，以利用改进的性能； 只要避免使用新功能（例如添加的库函数或新方法）。



如果您想利用该语言的最新更新，您可能更喜欢 Julia 的每日构建版本，并且不介意今天可用的版本是否偶尔无法正常工作。 顾名思义，每日构建版本的发布大约每晚发布一次（取决于构建基础设施的稳定性）。 一般来说，每日构建的发布是相当安全的——你的代码不会着火。 然而，它们可能出现偶尔的版本倒退和问题，直到更彻底的预发布测试才会发现。 你可能希望针对每日构建版本进行测试，以确保在发布之前捕获影响你的用例的版本倒退。



最后，您也可以考虑为自己从源代码构建 Julia。 此选项主要适用于那些熟悉命令行或对学习感兴趣的人。 如果你是这样的人，你可能也有兴趣阅读我们的 \href{https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md}{贡献指南}。



可以在\href{https://julialang.org/downloads/}{https://julialang.org/downloads/}的下载页面上找到每种下载类型的链接。 请注意，并非所有版本的Julia都适用于所有平台。



\hypertarget{2370247892740743728}{}


\subsection{更新我的 Julia 版本后，如何转移已安装软件包的列表？}



julia 的每个次要版本都有自己的默认 \href{https://docs.julialang.org/en/v1/manual/code-loading/\#Environments-1}{环境}。 因此，在安装新的 Julia 次要版本时，默认情况下你使用先前次要版本添加的包将不可用。 给定 julia 版本的环境由文件\texttt{Project.toml}和\texttt{Manifest.toml}定义，文件夹中的文件与\texttt{.julia/environments/}中的版本号匹配，例如\texttt{.julia/environments/v1.3}。



如果你安装了一个新的 Julia 次要版本，比如 \texttt{1.4}，并且想要在它的默认环境中使用与以前版本（例如 \texttt{1.3}）相同的包，你可以从\texttt{1.3} 文件夹复制文件 \texttt{Project.toml} 的内容到\texttt{1.4}。然后，在新的 Julia 版本的会话中，输入\texttt{]} 键进入“包管理模式”，并运行命令 \href{https://julialang.github.io/Pkg.jl/v1/api/\#Pkg.instantiate}{\texttt{instantiate}}。



此操作将从复制的文件中解析一组与目标 Julia 版本兼容的可行包，并在合适时安装或更新它们。 如果你不仅要重现软件包，还要重现在以前的 Julia 版本中使用的版本，您还应该在运行 Pkg 命令 \texttt{instantiate} 之前复制 \texttt{Manifest.toml} 文件。 但是，请注意，包可能定义了兼容性约束，这些约束可能会受到更改 Julia 版本的影响，因此你在\texttt{1.3}中拥有的确切版本集可能不适用于\texttt{1.4}。



\hypertarget{8132004312407744699}{}


\chapter{与其他语言的显著差异}



\hypertarget{12239763473214700690}{}


\section{与 MATLAB 的显著差异}



虽然 MATLAB 用户可能会发现 Julia 的语法很熟悉，但 Julia 不是 MATLAB 的克隆。 它们之间存在重大的语法和功能差异。 以下是一些可能会使习惯于 MATLAB 的 Julia 用户感到困扰的显著差异：



\begin{itemize}
\item Julia 数组使用方括号 \texttt{A[i,j]} 进行索引。


\item Julia 数组在分配给另一个变量时不会被复制。 在\texttt{A = B}之后，改变\texttt{B}的元素也会改变\texttt{A}的元素。


\item Julia 的值在向函数传递时不发生复制。如果某个函数修改了数组，这一修改对调用者是可见的。


\item Julia 不会在赋值语句中自动增长数组。 而在 MATLAB 中 \texttt{a(4) = 3.2} 可以创建数组 \texttt{a = [0 0 0 3.2]}，而 \texttt{a(5) = 7} 可以将它增长为 \texttt{a = [0 0 0 3.2 7]}。如果 \texttt{a} 的长度小于 5 或者这个语句是第一次使用标识符 \texttt{a}，则相应的 Julia 语句 \texttt{a[5] = 7} 会抛出错误。Julia 使用 \hyperlink{18026893834387542681}{\texttt{push!}} 和 \hyperlink{2587432243763606566}{\texttt{append!}} 来增长 \texttt{Vector}，它们比 MATLAB 的 \texttt{a(end+1) = val} 更高效。


\item 虚数单位 \texttt{sqrt(-1)} 在 Julia 中表示为 \hyperlink{15097910740298861288}{\texttt{im}}，而不是在 MATLAB 中的 \texttt{i} 或 \texttt{j}。


\item 在 Julia 中，没有小数点的数字字面量（例如 \texttt{42}）会创建整数而不是浮点数。也支持任意大整数字面量。因此，某些操作（如 \texttt{2{\textasciicircum}-1}）将抛出 domain error，因为结果不是整数（有关的详细信息，请参阅\hyperlink{1677964623674152967}{常见问题中有关 domain errors 的条目}）。 在 Julia 中，没有小数点的数字字面量（例如 \texttt{42}）会创建整数而不是浮点数。因此，某些操作会因为需要浮点数而抛出 domain error；例如 \texttt{julia > a = -1; 2{\textasciicircum}a} ，因为结果不是整数了。请参阅\hyperlink{1677964623674152967}{常见问题中有关 domain errors 的条目}）。


\item 在 Julia 中，能返回多个值并将其赋值为元组，例如 \texttt{(a, b) = (1, 2)} 或 \texttt{a, b = 1, 2}。 在 Julia 中不存在 MATLAB 的 \texttt{nargout}，它通常在 MATLAB 中用于根据返回值的数量执行可选工作。取而代之的是，用户可以使用可选参数和关键字参数来实现类似的功能。


\item Julia 拥有真正的一维数组。列向量的大小为 \texttt{N}，而不是 \texttt{Nx1}。例如，\hyperlink{7668863842145012694}{\texttt{rand(N)}} 创建一个一维数组。


\item 在 Julia 中，\texttt{[x,y,z]} 将始终构造一个包含\texttt{x}、\texttt{y} 和 \texttt{z} 的 3 元数组。

\begin{itemize}
\item 要在第一个维度（「垂直列」）中连接元素，请使用 \hyperlink{14691815416955507876}{\texttt{vcat(x,y,z)}} 或用分号分隔（\texttt{[x; y; z]}）。


\item 要在第二个维度（「水平行」）中连接元素，请使用 \hyperlink{8862791894748483563}{\texttt{hcat(x,y,z)}} 或用空格分隔（\texttt{[x y z]}）。


\item 要构造分块矩阵（在前两个维度中连接元素），请使用 \hyperlink{16279083053557795116}{\texttt{hvcat}} 或组合空格和分号（\texttt{[a b; c d]}）。

\end{itemize}

\item 在 Julia 中，\texttt{a:b} 和 \texttt{a:b:c} 构造 \texttt{AbstractRange} 对象。使用 \hyperlink{6278865767444641812}{\texttt{collect(a:b)}} 构造一个类似 MATLAB 中完整的向量。通常，不需要调用 \texttt{collect}。在大多数情况下，\texttt{AbstractRange} 对象将像普通数组一样运行，但效率更高，因为它是懒惰求值。这种创建专用对象而不是完整数组的模式经常被使用，并且也可以在诸如 \hyperlink{737600656772861535}{\texttt{range}} 之类的函数中看到，或者在诸如 \texttt{enumerate} 和 \texttt{zip} 之类的迭代器中看到。特殊对象大多可以像正常数组一样使用。


\item Julia 中的函数返回其最后一个表达式或 \texttt{return} 关键字的值而无需在函数定义中列出要返回的变量的名称（有关详细信息，请参阅 \hyperlink{16317991580998959177}{return 关键字}）。


\item Julia 脚本可以包含任意数量的函数，并且在加载文件时，所有定义都将在外部可见。可以从当前工作目录之外的文件加载函数定义。


\item 在 Julia 中，例如 \hyperlink{8666686648688281595}{\texttt{sum}}、\hyperlink{13484084847910116333}{\texttt{prod}} 和 \hyperlink{7839419811914289844}{\texttt{max}} 的归约操作会作用到数组的每一个元素上，当调用时只有一个函数，例如 \texttt{sum(A)}，即使 \texttt{A} 并不只有一个维度。


\item 在 Julia 中，调用无参数的函数时必须使用小括号，例如 \hyperlink{7668863842145012694}{\texttt{rand()}}。


\item Julia 不鼓励使用分号来结束语句。语句的结果不会自动打印（除了在 REPL 中），并且代码的一行不必使用分号结尾。\hyperlink{783803254548423222}{\texttt{println}} 或者 \hyperlink{13954719910189591998}{\texttt{@printf}} 能用来打印特定输出。


\item 在 Julia 中，如果 \texttt{A} 和 \texttt{B} 是数组，像 \texttt{A == B} 这样的逻辑比较运算符不会返回布尔值数组。相反地，请使用 \texttt{A .== B}。对于其他的像是 \hyperlink{702782232449268329}{\texttt{<}}、\hyperlink{8677991761303191103}{\texttt{>}} 的布尔运算符同理。


\item 在 Julia 中，运算符\hyperlink{1494761116451616317}{\texttt{\&}}、\hyperlink{9633687763646488853}{\texttt{|}} 和 \hyperlink{7071880015536674935}{\texttt{\unicodeveebar{}}}（\hyperlink{7071880015536674935}{\texttt{xor}}）进行按位操作，分别与MATLAB中的\texttt{and}、\texttt{or} 和 \texttt{xor} 等价，并且优先级与 Python 的按位运算符相似（不像 C）。他们可以对标量运算或者数组中逐元素运算，可以用来合并逻辑数组，但是注意运算顺序的区别：括号可能是必要的（例如，选择 \texttt{A} 中等于 1 或 2 的元素可使用 \texttt{(A .== 1) .| (A .== 2)}）。


\item 在 Julia 中，集合的元素可以使用 splat 运算符 \texttt{...} 来作为参数传递给函数，如 \texttt{xs=[1,2]; f(xs...)}。


\item Julia 的 \hyperlink{6661056220970412040}{\texttt{svd}} 将奇异值作为向量而非密集对角矩阵返回。


\item 在 Julia 中，\texttt{...} 不用于延续代码行。不同的是，Julia 中不完整的表达式会自动延续到下一行。


\item 在 Julia 和 MATLAB 中，变量 \texttt{ans} 被设置为交互式会话中提交的最后一个表达式的值。在 Julia 中与 MATLAB 不同的是，当 Julia 代码以非交互式模式运行时并不会设置 \texttt{ans}。


\item Julia 的 \texttt{struct} 不支持在运行时动态地添加字段，这与 MATLAB 的 \texttt{class} 不同。 如需支持，请使用 \hyperlink{3089397136845322041}{\texttt{Dict}}。Julia 中的字典不是有序的。


\item 在 Julia 中，每个模块有自身的全局作用域/命名空间，而在 MATLAB 中只有一个全局作用域。


\item 在 MATLAB 中，删除不需要的值的惯用方法是使用逻辑索引，如表达式 \texttt{x(x>3)} 或语句 \texttt{x(x>3) = []} 来 in-place 修改 \texttt{x}。相比之下，Julia 提供了更高阶的函数 \hyperlink{11445961893478569145}{\texttt{filter}} 和 \hyperlink{3384092630307389071}{\texttt{filter!}}，允许用户编写 \texttt{filter(z->z>3, x)} 和 \texttt{filter!(z->z>3, x)} 来代替相应直译 \texttt{x[x.>3]} 和 \texttt{x = x[x.>3]}。使用 \hyperlink{3384092630307389071}{\texttt{filter!}} 可以减少临时数组的使用。


\item 类似于提取（或「解引用」）元胞数组的所有元素的操作，例如 MATLAB 中的 \texttt{vertcat(A\{:\})}，在 Julia 中是使用 splat 运算符编写的，例如 \texttt{vcat(A...)}。


\item 在 Julia 中，\texttt{adjoint} 函数执行共轭转置；在 MATLAB 中，\texttt{adjoint} 提供了经典伴随，它是余子式的转置。


\item 在 Julia 中，a{\textasciicircum}b{\textasciicircum}c 被认为是 a{\textasciicircum}(b{\textasciicircum}c) 而在 MATLAB 中它是 (a{\textasciicircum}b){\textasciicircum}c。

\end{itemize}


\hypertarget{2824295160422151139}{}


\section{与 R 的显著差异}



Julia 的目标之一是为数据分析和统计编程提供高效的语言。对于从 R 转到 Julia 的用户来说，这是一些显著差异：



\begin{itemize}
\item Julia 的单引号封闭字符，而不是字符串。


\item Julia 可以通过索引字符串来创建子字符串。在 R 中，在创建子字符串之前必须将字符串转换为字符向量。


\item 在 Julia 中，与 Python 相同但与 R 不同的是，字符串可由三重引号 \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl} ... {\textquotedbl}{\textquotedbl}{\textquotedbl}} 创建。此语法对于构造包含换行符的字符串很方便。


\item 在 Julia 中，可变参数使用 splat 运算符 \texttt{...} 指定，该运算符总是跟在具体变量的名称后面，与 R 的不同，R 的 \texttt{...} 可以单独出现。


\item 在 Julia 中，模数是 \texttt{mod(a, b)}，而不是 \texttt{a \%\% b}。Julia 中的 \texttt{\%} 是余数运算符。


\item 在 Julia 中，并非所有数据结构都支持逻辑索引。此外，Julia 中的逻辑索引只支持长度等于被索引对象的向量。例如：

\begin{itemize}
\item 在 R 中，\texttt{c(1, 2, 3, 4)[c(TRUE, FALSE)]} 等价于 \texttt{c(1, 3)}。


\item 在 R 中，\texttt{c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]} 等价于 \texttt{c(1, 3)}。


\item 在 Julia 中，\texttt{[1, 2, 3, 4][[true, false]]} 抛出 \hyperlink{9731558909100893938}{\texttt{BoundsError}}。


\item 在 Julia 中，\texttt{[1, 2, 3, 4][[true, false, true, false]]} 产生 \texttt{[1, 3]}。

\end{itemize}

\item 与许多语言一样，Julia 并不总是允许对不同长度的向量进行操作，与 R 不同，R 中的向量只需要共享一个公共的索引范围。例如，\texttt{c(1, 2, 3, 4) + c(1, 2)} 是有效的 R，但等价的 \texttt{[1, 2, 3, 4] + [1, 2]} 在 Julia 中会抛出一个错误。


\item 在逗号不改变代码含义时，Julia 允许使用可选的尾随括号。在索引数组时，这可能在 R 用户间造成混淆。例如，R 中的 \texttt{x[1,]} 将返回矩阵的第一行；但是，在 Julia 中，引号被忽略，于是 \texttt{x[1,] == x[1]}，并且将返回第一个元素。要提取一行，请务必使用 \texttt{:}，如 \texttt{x[1,:]}。


\item Julia 的 \hyperlink{11483231213869150535}{\texttt{map}} 首先接受函数，然后是该函数的参数，这与 R 中的 \texttt{lapply(<structure>, function, ...)} 不同。类似地，R 中的 \texttt{apply(X, MARGIN, FUN, ...)} 等价于 Julia 的 \hyperlink{8678396932318499078}{\texttt{mapslices}}，其中函数是第一个参数。


\item R 中的多变量 apply，如 \texttt{mapply(choose, 11:13, 1:3)}，在 Julia 中可以编写成 \texttt{broadcast(binomial, 11:13, 1:3)}。等价地，Julia 提供了更短的点语法来向量化函数 \texttt{binomial.(11:13, 1:3)}。


\item Julia 使用 \texttt{end} 来表示条件块（如 \texttt{if}）、循环块（如 \texttt{while}/\texttt{for}）和函数的结束。为了代替单行 \texttt{if ( cond ) statement}，Julia 允许形式为 \texttt{if cond; statement; end}、\texttt{cond \&\& statement} 和 \texttt{!cond || statement} 的语句。后两种语法中的赋值语句必须显式地包含在括号中，例如 \texttt{cond \&\& (x = value)}，这是因为运算符的优先级。


\item 在 Julia 中，\texttt{<-}, \texttt{<<-} 和 \texttt{->} 不是赋值运算符。


\item Julia 的 \texttt{->} 创建一个匿名函数。


\item Julia 使用括号构造向量。Julia 的 \texttt{[1, 2, 3]} 等价于 R 的 \texttt{c(1, 2, 3)}。


\item Julia 的 \hyperlink{5498506958944335098}{\texttt{*}} 运算符可以执行矩阵乘法，这与 R 不同。如果 \texttt{A} 和 \texttt{B} 都是矩阵，那么 \texttt{A * B} 在 Julia 中表示矩阵乘法，等价于 R 的 \texttt{A \%*\% B}。在 R 中，相同的符号将执行逐元素（Hadamard）乘积。要在 Julia 中使用逐元素乘法运算，你需要编写 \texttt{A .* B}。


\item Julia 使用 \texttt{transpose} 函数来执行矩阵转置，使用 \texttt{{\textquotesingle}} 运算符或 \texttt{adjoint} 函数来执行共轭转置。因此，Julia 的 \texttt{transpose(A)} 等价于 R 的 \texttt{t(A)}。另外，Julia 中的非递归转置由 \texttt{permutedims} 函数提供。


\item Julia 在编写 \texttt{if} 语句或 \texttt{for}/\texttt{while} 循环时不需要括号：请使用 \texttt{for i in [1, 2, 3]} 代替 \texttt{for (int i=1; i <= 3; i++)}，以及 \texttt{if i == 1} 代替 \texttt{if (i == 1)}


\item Julia 不把数字 \texttt{0} 和 \texttt{1} 视为布尔值。在 Julia 中不能编写 \texttt{if (1)}，因为 \texttt{if} 语句只接受布尔值。相反，可以编写 \texttt{if true}、\texttt{if Bool(1)} 或 \texttt{if 1==1}。


\item Julia 不提供 \texttt{nrow} 和 \texttt{ncol}。相反，请使用 \texttt{size(M, 1)} 代替 \texttt{nrow(M)} 以及 \texttt{size(M, 2)} 代替 \texttt{ncol(M)}


\item Julia 仔细区分了标量、向量和矩阵。在 R 中，\texttt{1} 和 \texttt{c(1)} 是相同的。在 Julia 中，它们不能互换地使用。


\item Julia 的 \hyperlink{17079356950356685026}{\texttt{diag}} 和 \hyperlink{18133091318829836689}{\texttt{diagm}} 与 R 的不同。


\item Julia 赋值操作的左侧不能为函数调用的结果：你不能编写 \texttt{diag(M) = fill(1, n)}。


\item Julia 不鼓励使用函数填充主命名空间。Julia 的大多数统计功能都可在 \href{https://github.com/JuliaStats}{JuliaStats 组织}的\href{https://pkg.julialang.org/}{包}中找到。例如：

\begin{itemize}
\item 与概率分布相关的函数由 \href{https://github.com/JuliaStats/Distributions.jl}{Distributions 包}提供。


\item \href{https://github.com/JuliaData/DataFrames.jl}{DataFrames 包}提供数据帧。


\item 广义线性模型由 \href{https://github.com/JuliaStats/GLM.jl}{GLM 包}提供。

\end{itemize}

\item Julia 提供了元组和真正的哈希表，但不提供 R 风格的列表。在返回多个项时，通常应使用元组或具名元组：请使用 \texttt{(1, 2)} 或 \texttt{(a=1, b=2)} 代替 \texttt{list(a = 1, b = 2)}。


\item Julia 鼓励用户编写自己的类型，它比 R 中的 S3 或 S4 对象更容易使用。Julia 的多重派发系统意味着 \texttt{table(x::TypeA)} 和 \texttt{table(x::TypeB)} 类似于 R 的 \texttt{table.TypeA(x)} 和 \texttt{table.TypeB(x)}。


\item Julia 的值在向函数传递时不发生复制。如果某个函数修改了数组，这一修改对调用者是可见的。这与 R 非常不同，允许新函数更高效地操作大型数据结构。


\item 在 Julia 中，向量和矩阵使用 \hyperlink{8862791894748483563}{\texttt{hcat}}、\hyperlink{14691815416955507876}{\texttt{vcat}} 和 \hyperlink{16279083053557795116}{\texttt{hvcat}} 拼接，而不是像在 R 中那样使用 \texttt{c}、\texttt{rbind} 和 \texttt{cbind}。


\item 在 Julia 中，像 \texttt{a:b} 这样的 range 不是 R 中的向量简写，而是一个专门的 \texttt{AbstractRange} 对象，该对象用于没有高内存开销地进行迭代。要将 range 转换为 vector，请使用 \hyperlink{6278865767444641812}{\texttt{collect(a:b)}}。


\item Julia 的 \hyperlink{7839419811914289844}{\texttt{max}} 和 \hyperlink{7458766354532817148}{\texttt{min}} 分别等价于 R 中的 \texttt{pmax} 和 \texttt{pmin}，但两者的参数都需要具有相同的维度。虽然 \hyperlink{14719513931696680717}{\texttt{maximum}} 和 \hyperlink{13126064576294034099}{\texttt{minimum}} 代替了 R 中的 \texttt{max} 和 \texttt{min}，但它们之间有重大区别。


\item Julia 的 \hyperlink{8666686648688281595}{\texttt{sum}}、\hyperlink{13484084847910116333}{\texttt{prod}}、\hyperlink{14719513931696680717}{\texttt{maximum}} 和 \hyperlink{13126064576294034099}{\texttt{minimum}} 与它们在 R 中的对应物不同。它们都接受一个可选的关键字参数 \texttt{dims}，它表示执行操作的维度。例如，在 Julia 中令 \texttt{A = [1 2; 3 4]}，在 R 中令 \texttt{B <- rbind(c(1,2),c(3,4))} 是与之相同的矩阵。然后 \texttt{sum(A)} 得到与 \texttt{sum(B)} 相同的结果，但 \texttt{sum(A, dims=1)} 是一个包含每一列总和的行向量，\texttt{sum(A, dims=2)} 是一个包含每一行总和的列向量。这与 R 的行为形成了对比，在 R 中，单独的 \texttt{colSums(B)} 和 \texttt{rowSums(B)} 提供了这些功能。如果 \texttt{dims} 关键字参数是向量，则它指定执行求和的所有维度，并同时保持待求和数组的维数，例如 \texttt{sum(A, dims=(1,2)) == hcat(10)}。应该注意的是，没有针对第二个参数的错误检查。


\item Julia 具有一些可以改变其参数的函数。例如，它具有 \hyperlink{8473525809131227606}{\texttt{sort}} 和 \hyperlink{12296873681374954808}{\texttt{sort!}}。


\item 在 R 中，高性能需要向量化。在 Julia 中，这几乎恰恰相反：性能最高的代码通常通过去向量化的循环来实现。


\item Julia 是立即求值的，不支持 R 风格的惰性求值。对于大多数用户来说，这意味着很少有未引用的表达式或列名。


\item Julia 不支持 \texttt{NULL} 类型。最接近的等价物是 \hyperlink{9331422207248206047}{\texttt{nothing}}，但它的行为类似于标量值而不是列表。请使用 \texttt{x === nothing} 代替 \texttt{is.null(x)}。


\item 在 Julia 中，缺失值由 \hyperlink{14596725676261444434}{\texttt{missing}} 表示，而不是由 \texttt{NA} 表示。请使用 \hyperlink{3452327148507948899}{\texttt{ismissing(x)}}（或者在向量上使用逐元素操作 \texttt{ismissing.(x)}）代替 \texttt{isna(x)}。通常使用 \hyperlink{2012470681884771400}{\texttt{skipmissing}} 代替 \texttt{na.rm=TRUE}（尽管在某些特定情况下函数接受 \texttt{skipmissing} 参数）。


\item Julia 缺少 R 中的 \texttt{assign} 或 \texttt{get} 的等价物。


\item 在 Julia 中，\texttt{return} 不需要括号。


\item 在 R 中，删除不需要的值的惯用方法是使用逻辑索引，如表达式 \texttt{x[x>3]} 或语句 \texttt{x = x[x>3]} 来 in-place 修改 \texttt{x}。相比之下，Julia 提供了更高阶的函数 \hyperlink{11445961893478569145}{\texttt{filter}} 和 \hyperlink{3384092630307389071}{\texttt{filter!}}，允许用户编写 \texttt{filter(z->z>3, x)} 和 \texttt{filter!(z->z>3, x)} 来代替相应直译 \texttt{x[x.>3]} 和 \texttt{x = x[x.>3]}。使用 \hyperlink{3384092630307389071}{\texttt{filter!}} 可以减少临时数组的使用。

\end{itemize}


\hypertarget{17575785050737161441}{}


\section{与 Python 的显著差异}



\begin{itemize}
\item Julia 的 \texttt{for}, \texttt{if}, \texttt{while} 等语句块都以 \texttt{end} 关键字结束。代码的缩进不像在 Python 中那样重要。Julia 也没有 \texttt{pass} 关键字。


\item Julia 中的字符串使用双引号构造，如 \texttt{{\textquotedbl}text{\textquotedbl}}，也可以使用三引号构造多行字符串。而在 Python 中可以使用单引号（\texttt{{\textquotesingle}text{\textquotesingle}}）或者双引号（\texttt{{\textquotedbl}text{\textquotedbl}}）。单引号在 Julia 中用来表示单个字符，例如 \texttt{{\textquotesingle}c{\textquotesingle}}。


\item 在 Julia 中字符串的拼接使用 \texttt{*}，而不是像 Python 一样使用 \texttt{+}。类似的，字符串重复多次 Julia 使用 \texttt{{\textasciicircum}} 而不是 \texttt{*}。Julia 也不支持隐式的字符串拼接，例如 Python 中的 \texttt{{\textquotesingle}ab{\textquotesingle} {\textquotesingle}cd{\textquotesingle} == {\textquotesingle}abcd{\textquotesingle}}。


\item Python 列表——灵活但缓慢——对应于 Julia 的 \texttt{Vector\{Any\}} 类型或更一般的 \texttt{Vector\{T\}}，其中 \texttt{T} 是一些非具体元素类型。 “快”的数组，如 NumPy 数组，它们就地存储元素（即，\texttt{dtype} 是 \texttt{np.float64}、\texttt{[({\textquotesingle}f1{\textquotesingle}, np.uint64), ({\textquotesingle}f2{\textquotesingle}, np.int32)]}， 等）可以用 \texttt{Array\{T\}} 表示，其中 \texttt{T} 是一个具体的、不可变的元素类型。 这包括内置类型，如 \texttt{Float64}、\texttt{Int32}、\texttt{Int64}，也包括更复杂的类型，如 \texttt{Tuple\{UInt64,Float64\}} 和许多用户定义的类型。


\item 在 Julia 中，数组、字符串等的索引从 1 开始，而不是从 0 开始。


\item Julia 里的切片包含最后一个元素。Julia 里的 \texttt{a[2:3]} 等同于 Python 中的 \texttt{a[1:3]}。


\item Julia 不支持负数索引。特别地，列表或数组的最后一个元素在 Julia 中使用 \texttt{end} 索引，而不像在 Python 中使用 \texttt{-1}。


\item Julia 的索引必须写全。Python 中的 \texttt{x[1:]} 等价于 Julia 中的 \texttt{x[2:end]}。


\item Julia 的范围语法为 \texttt{x[start:step:stop]}，而 Python 的格式为 \texttt{x[start:(stop+1):step]}。

\end{itemize}


因此 Python 中的 \texttt{x[0:10:2]} 等价于 Julia 里的 \texttt{x[1:2:10]}。类似的 Python 中的反转数组 \texttt{x[::-1]} 等价于 Julia 中的 \texttt{x[end:-1:1]}。



\begin{itemize}
\item 在 Julia 中队一个矩阵取索引 \texttt{X[[1,2], [1,3]]} 返回一个子矩阵，它包含了第一和第二行与第一和第三列的交集。

\end{itemize}


在 Python 中 \texttt{X[[1,2], [1,3]]} 返回一个向量，它包含索引 \texttt{[1,1]} 和 \texttt{[2,3]} 的值。Julia 中的 \texttt{X[[1,2], [1,3]]} 等价于 Python 中的 \texttt{X[np.ix\_([0,1],[0,2])]}。Python 中的 \texttt{X[[1,2], [1,3]]} 等价于 Julia 中的 \texttt{X[[CartesianIndex(1,1), CartesianIndex(2,3)]]}。



\begin{itemize}
\item Julia 没有用来续行的语法：如果在行的末尾，到目前为止的输入是一个完整的表达式，则认为其已经结束；否则，认为输入继续。强制表达式继续的一种方式是将其包含在括号中。


\item 默认情况下，Julia 数组是列优先（Fortran 排序），而 NumPy 数组是行优先（C 排序）。为了在循环数组时获得最佳性能，Julia 中的循环顺序应相对于 NumPy 颠倒（请参阅\hyperlink{11239800376478112527}{性能提示的相关部分}）。


\item Julia 的更新运算符（例如 \texttt{+=}，\texttt{-=}，···）是非原位操作（not in-place），而 Numpy 的是。这意味着 \texttt{A = [1, 1]; B = A; B += [3, 3]} 不会改变 \texttt{A} 中的值，而将名称 \texttt{B} 重新绑定到右侧表达式 \texttt{B = B + 3} 的结果，这是一个新的数组。对于 in-place 操作，使用 \texttt{B .+= 3}（另请参阅 \hyperlink{15967322336376951940}{dot operators}）、显式的循环或者 \texttt{InplaceOps.jl}。


\item Julia 的函数在调用时，每次都对默认参数重新求值，不像 Python 只在函数定义时对默认参数求一次值。

\end{itemize}


举例来说：Julia 的函数 \texttt{f(x=rand()) = x} 在无参数调用时（\texttt{f()}），每次都会返回不同的随机数。 另一方面，函数 \texttt{g(x=[1,2]) = push!(x,3)} 无参数调用时 \texttt{g()}，永远返回 \texttt{[1,2,3]}。



\begin{itemize}
\item 在 Julia 中，必须使用关键字来传递关键字参数，这与 Python 中通常可以按位置传递它们不同。尝试按位置传递关键字参数会改变方法签名，从而导致 \texttt{MethodError} 或调用错误的方法。


\item 在 Julia 中，\texttt{\%} 是余数运算符，而在 Python 中是模运算符。

\end{itemize}


（译注：二者在参数有负数时有区别）



\begin{itemize}
\item 在 Julia 中，常用的整数类型 Int 对应机器的整数类型，\texttt{Int32} 或 \texttt{Int64}。不像 Python 中的整数 int 是任意精度的。这意味着 Julia 中默认的整数类型会溢出，因此 \texttt{2{\textasciicircum}64 == 0}。如果你要表示一个大数，请选择一个合适的类型。如：\texttt{Int128}、任意精度的 \texttt{BigInt} 或者浮点类型 \texttt{Flost64}。


\item Julia 中虚数单位 \texttt{sqrt(-1)} 是 \texttt{im}，而不是 Python 中的 \texttt{j}。


\item Julia 中指数是 \texttt{{\textasciicircum}}，而不是 Python 中的 \texttt{**}。


\item Julia 使用 \texttt{Nothing} 类型的实例 \texttt{nothing} 代表空值（null），而不是 Python 中 \texttt{NoneType} 类的 \texttt{None}。


\item 在 Julia 中，标准的运算符作用在矩阵上就得到矩阵操作，不像 Python 标准运算符默认是逐元素操作。当 A 和 B 都是矩阵时，\texttt{A * B} 在 Julia 中代表着矩阵乘法，而不是 Python 中的逐元素相乘。即：Julia 中的 \texttt{A * B} 等同于 Python 的 \texttt{A @ B}；Python 中的 \texttt{A * B} 等同于 Julia 中的 \texttt{A .* B}。


\item Julia 中的伴随操作符 \texttt{{\textquotesingle}} 返回向量的转置（一种行向量的懒惰表示法）。Python 中对向量执行 \texttt{.T} 返回它本身（没有效果）。


\item 在Julia中，一个函数可能包含多个具体实现（称为\emph{方法}），与Python中的函数相比，这些实现是根据调用的所有参数的类型通过多重派发选择的，它只有一个实现，没有多态性（与Python方法调用相反，Python方法调用使用不同的语法，并允许在方法的接收者上进行派发）。


\item Julia 没有类（class），取而代替的是结构体（structures），可以是可变的或不可变的，它们只包含数据而不包含方法。

\end{itemize}


\begin{itemize}
\item 在 Python 中调用类实例的方法 (\texttt{x = MyClass(*args); x.f(y)}) 对应于 Julia 中的函数调用，例如 \texttt{x = MyType(args...); f(x, y)}。 总的来说，多重派发比 Python 类系统更灵活和强大。


\item Julia 的结构体有且只能有一个抽象超类型（abstract supertype），而 Python 的类可以纪成一个或多个、抽象或具体的超类（superclasses）。


\item 逻辑 Julia 程序结构（包和模块）独立于文件结构（\texttt{include} 用于附加文件），而 Python 代码结构由目录（包）和文件（模块）定义。


\item Julia 中的三元运算符 \texttt{x > 0 ? 1 :  -1} 对应于 Python 中的条件表达式 \texttt{1 if x > 0 else -1}。


\item Julia 中以 \texttt{@} 开头的符号是宏（macro），而 Python 中是装饰器（decorator）。


\item Julia 的异常处理使用 \texttt{try} — \texttt{catch} — \texttt{finally}，而不是 Python 的 \texttt{try} — \texttt{except} — \texttt{finally}。与 Python 不同的是，因为性能的原因，Julia 不推荐在正常流程中使用异常处理。


\item Julia 的循环很快，所以没必要手动向量化（vectorized）。


\item 小心 Julia 中的非常量全局变量，尤其它出现在循环中时。因为你在 Julia 中可以写出贴近硬件的代码，这时使用全局变量的影响非常大（参见\hyperlink{818954303942149020}{性能建议}）


\item Python 中大多数的值都能用在逻辑运算中。例如：\texttt{if {\textquotedbl}a{\textquotedbl}} 永真，\texttt{if {\textquotedbl}{\textquotedbl}} 恒假。在 Julia 中你只能使用布尔类型的值，或者显示的将其他值转为布尔类型，否则就会抛出异常。例如当你想测试字符串是否为空是，请使用 \texttt{if !isempty({\textquotedbl}{\textquotedbl})}。


\item 在 Julia 中大多数代码块都会引入新的本地作用域（local scope）。例如：循环和异常处理的 try — catch — finally。注意：列表推断（comprehensions）与生成器在 Julia 和 Python 中都会引入新的作用域；而 if 分支则都不会引入。

\end{itemize}


\hypertarget{30781051824837113}{}


\section{与 C/C++ 的显著差异}



\begin{itemize}
\item Julia 的数组由方括号索引，方括号中可以包含不止一个维度 \texttt{A[i,j]}。这样的语法不仅仅是像 C/C++ 中那样对指针或者地址引用的语法糖，参见\hyperlink{16720099245556932994}{关于数组构造的语法的 Julia 文档}。


\item 在 Julia 中，数组、字符串等的索引从 1 开始，而不是从 0 开始。


\item Julia 的数组在赋值给另一个变量时不发生复制。执行 \texttt{A = B} 后，改变 \texttt{B} 中元素也会修改 \texttt{A}。像 \texttt{+=} 这样的更新运算符不会以 in-place 的方式执行，而是相当于 \texttt{A = A + B}，将左侧绑定到右侧表达式的计算结果上。


\item Julia 的数组是列优先的（Fortran 顺序），而 C/C++ 的数组默认是行优先的。要使数组上的循环性能最优，在 Julia 中循环的顺序应该与 C/C++ 相反（参见 \hyperlink{818954303942149020}{性能建议}）。


\item Julia 的值在赋值或向函数传递时不发生复制。如果某个函数修改了数组，这一修改对调用者是可见的。


\item 在 Julia 中，空格是有意义的，这与 C/C++ 不同，所以向 Julia 程序中添加或删除空格时必须谨慎。


\item 在 Julia 中，没有小数点的数值字面量（如 \texttt{42}）生成有符号整数，类型为 \texttt{Int}，但如果字面量太长，超过了机器字长，则会被自动提升为容量更大的类型，例如 \texttt{Int64}（如果 \texttt{Int} 是 \texttt{Int32}）、\texttt{Int128}，或者任意精度的 \texttt{BigInt} 类型。不存在诸如 \texttt{L}, \texttt{LL}, \texttt{U}, \texttt{UL}, \texttt{ULL} 这样的数值字面量后缀指示无符号和/或有符号与无符号。十进制字面量始终是有符号的，十六进制字面量（像 C/C++ 一样由 \texttt{0x} 开头）是无符号的。另外，十六进制字面量与 C/C++/Java 不同，也与 Julia 中的十进制字面量不同，它们的类型取决于字面量的\textbf{长度}，包括开头的 0。例如，\texttt{0x0} 和 \texttt{0x00} 的类型是 \hyperlink{6609065134969660118}{\texttt{UInt8}}，\texttt{0x000} 和 \texttt{0x0000} 的类型是 \hyperlink{7018610346698168012}{\texttt{UInt16}}。同理，字面量的长度在 5-8 之间，类型为 \texttt{UInt32}；在 9-16 之间，类型为 \texttt{UInt64}；在 17-32 之间，类型为 \texttt{UInt128}。当定义十六进制掩码时，就需要将这一问题考虑在内，比如 \texttt{{\textasciitilde}0xf == 0xf0} 与 \texttt{{\textasciitilde}0x000f == 0xfff0} 完全不同。64 位 \texttt{Float64} 和 32 位 \hyperlink{8101639384272933082}{\texttt{Float32}} 的字面量分别表示为 \texttt{1.0} 和 \texttt{1.0f0}。浮点字面量在无法被精确表示时舍入（且不会提升为 \texttt{BigFloat} 类型）。浮点字面量在行为上与 C/C++ 更接近。八进制（前缀为 \texttt{0o}）和二进制（前缀为 \texttt{0b}）也被视为无符号的。


\item 在 Julia 中，当两个操作数都是整数类型时，除法运算符 \texttt{/} 返回一个浮点数。 要执行整数除法，请使用 \texttt{div} 或 \texttt{÷}。


\item 使用浮点类型索引数组在 Julia 中通常是错误的。 C 表达式 \texttt{a[i / 2]} 的 Julia 等价写法是 \texttt{a[i ÷ 2 + 1]}，其中 \texttt{i} 是整数类型。


\item 字符串字面量可用 \texttt{{\textquotedbl}} 或 \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}} 分隔，用 \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}} 分隔的字面量可以包含 \texttt{{\textquotedbl}} 字符而无需像 \texttt{{\textquotedbl}{\textbackslash}{\textquotedbl}{\textquotedbl}} 这样来引用它。字符串字面量可以包含插入其中的其他变量或表达式，由 \texttt{\$variablename} 或 \texttt{\$(expression)} 表示，它在该函数所处的上下文中计算变量名或表达式。


\item \texttt{//} 表示 \hyperlink{8304566144531167610}{\texttt{Rational}} 数，而非单行注释（其在 Julia 中是 \texttt{\#}）


\item \texttt{\#=} 表示多行注释的开头，\texttt{=\#} 结束之。


\item Julia 中的函数返回其最后一个表达式或 \texttt{return} 关键字的值。可以从函数中返回多个值并将其作为元组赋值，如 \texttt{(a, b) = myfunction()} 或 \texttt{a, b = myfunction()}，而不必像在 C/C++ 中那样必须传递指向值的指针（即 \texttt{a = myfunction(\&b)}）。


\item Julia 不要求使用分号来结束语句。表达式的结果不会自动打印（除了在交互式提示符中，即 REPL），且代码行不需要以分号结尾。\hyperlink{783803254548423222}{\texttt{println}} 或 \hyperlink{13954719910189591998}{\texttt{@printf}} 可用于打印特定输出。在 REPL 中，\texttt{;} 可用于抑制输出。\texttt{;} 在 \texttt{[ ]} 中也有不同的含义，需要注意。\texttt{;} 可用于在单行中分隔表达式，但在许多情况下不是绝对必要的，更经常是为了可读性。


\item 在 Julia 中，运算符 \hyperlink{7071880015536674935}{\texttt{\unicodeveebar{}}}（\hyperlink{7071880015536674935}{\texttt{xor}}）执行按位 XOR 操作，即 C/C++ 中的 \hyperlink{3804132060389001711}{\texttt{{\textasciicircum}}}。此外，按位运算符不具有与 C/C++ 相同的优先级，所以可能需要括号。


\item Julia 的 \hyperlink{3804132060389001711}{\texttt{{\textasciicircum}}} 是取幂（pow），而非 C/C++ 中的按位 XOR（在 Julia 中请使用 \hyperlink{7071880015536674935}{\texttt{\unicodeveebar{}}} 或 \texttt{xor}）


\item Julia 有两个右移运算符，\texttt{>>} 和 \texttt{>>>}。 \texttt{>>} 执行算术移位，\texttt{>>>} 始终执行逻辑移位，这与 C/C++ 不同，其中 \texttt{>>} 的含义取决于被移位的值的类型。


\item Julia 的 \texttt{->} 创建一个匿名函数，它并不通过指针访问成员。


\item Julia 在编写 \texttt{if} 语句或 \texttt{for}/\texttt{while} 循环时不需要括号：请使用 \texttt{for i in [1, 2, 3]} 代替 \texttt{for (int i=1; i <= 3; i++)}，以及 \texttt{if i == 1} 代替 \texttt{if (i == 1)}


\item Julia 不把数字 \texttt{0} 和 \texttt{1} 视为布尔值。在 Julia 中不能编写 \texttt{if (1)}，因为 \texttt{if} 语句只接受布尔值。相反，可以编写 \texttt{if true}、\texttt{if Bool(1)} 或 \texttt{if 1==1}。


\item Julia 使用 \texttt{end} 来表示条件块（如 \texttt{if}）、循环块（如 \texttt{while}/\texttt{for}）和函数的结束。为了代替单行 \texttt{if ( cond ) statement}，Julia 允许形式为 \texttt{if cond; statement; end}、\texttt{cond \&\& statement} 和 \texttt{!cond || statement} 的语句。后两种语法中的赋值语句必须显式地包含在括号中，例如 \texttt{cond \&\& (x = value)}，这是因为运算符的优先级。


\item Julia 没有用来续行的语法：如果在行的末尾，到目前为止的输入是一个完整的表达式，则认为其已经结束；否则，认为输入继续。强制表达式继续的一种方式是将其包含在括号中。


\item Julia 宏对已解析的表达式进行操作，而非程序的文本，这允许它们执行复杂的 Julia 代码转换。宏名称以 \texttt{@} 字符开头，具有类似函数的语法 \texttt{@mymacro(arg1, arg2, arg3)} 和类似语句的语法 \texttt{@mymacro arg1 arg2 arg3}。两种形式的语法可以相互转换；如果宏出现在另一个表达式中，则类似函数的形式尤其有用，并且它通常是最清晰的。类似语句的形式通常用于标注块，如在分布式 \texttt{for} 结构中：\texttt{@distributed for i in 1:n; \#= body =\#; end}。如果宏结构的结尾不那么清晰，请使用类似函数的形式。


\item Julia 有一个枚举类型，使用宏 \texttt{@enum(name, value1, value2, ...)} 来表示，例如：\texttt{@enum(Fruit, banana=1, apple, pear)}。


\item 按照惯例，修改其参数的函数在名称的末尾有个 \texttt{!}，例如 \texttt{push!}。


\item 在 C++ 中，默认情况下，你具有静态分派，即为了支持动态派发，你需要将函数标注为 virtual 函数。另一方面，Julia 中的每个方法都是「virtual」（尽管它更通用，因为方法是在每个参数类型上派发的，而不仅仅是 \texttt{this}，并且使用的是最具体的声明规则）。

\end{itemize}


\hypertarget{14324149948761873740}{}


\section{与 Common Lisp 的显著差异}



\begin{itemize}
\item Julia 默认使用 1 开始的数组索引，它也能处理任意的\hyperlink{1238988360302116626}{索引顺序}。


\item 函数和变量共用一个命名空间（{\textquotedbl}Lisp-1{\textquotedbl}）。


\item Julia 中有 \hyperlink{14946515604348703614}{\texttt{Pair}} 类型，但这并不意味着它能用作 \texttt{COMMON-LISP:CONS}。在 Julia 中绝大多数可迭代的集合都能互换使用，例如：集合解包（splatting）、元组等。\texttt{Tuple} 最接近 Common Lisp 中用于异构元素的\textbf{短}列表。使用 \texttt{NamedTuple} 来代替关联表（alists）。对于更大的、同类型元素的集合，应该使用 \texttt{Array} 和 \texttt{Dict}。


\item 典型的使用 Julia 进行原型开发时，也会对镜像进行连续的修改，\href{https://github.com/timholy/Revise.jl}{Revise.jl} 包提供了这个功能。


\item 对于性能，Julia 更喜欢操作具有 \hyperlink{5872221809740029239}{类型稳定性}。 Common Lisp 从底层机器操作中抽象出来，而 Julia 则更接近它们。 例如：

\begin{itemize}
\item 使用 \texttt{/} 的整数除法总是返回浮点结果，即使计算是精确的。

\begin{itemize}
\item \texttt{//} 总是返回一个有理数结果


\item \texttt{÷} 总是返回一个（被截断的）整数结果

\end{itemize}

\item Julia 支持大整数，但不会自动转换。默认的整数类型会\hyperlink{17610230595270045080}{溢出}。


\item 支持复数，但要获得复数结果，\hyperlink{1677964623674152967}{你需要复数输入}。


\item 有多种 Complex 和 Rational 类型，具有不同的组成类型。

\end{itemize}

\item 模块（名称空间）可以是分层的。\hyperlink{16252475688663093021}{\texttt{import}} 和 \hyperlink{169458112978175560}{\texttt{using}} 有着双重角色：他们加载代码并让代码在命名空间中可用。\texttt{import} 用于仅有模块名是可用的情况，大致等价于 \texttt{ASDF:LOAD-OP}。槽名（Slot name）不需要单独导出。全局变量不能从模块的外部赋值，除了 \texttt{eval(mod, :(var = val))} 这个例外情况。


\item 宏以 \texttt{@} 开头，并没有像 Common Lisp 那样无缝地集成到语言中；因此在 Julia 中，宏的使用不像在 Common Lisp 中那样广泛。Julia 支持\hyperlink{15430858583934124136}{宏}的一种卫生（hygiene）形式。因为不同的表层语法，Julia 中没有 \texttt{COMMON-LISP:\&BODY} 的等价形式。


\item \textbf{所有的}函数都是通用的并且使用多重分派。函数的参数列表也无需遵循一样的模板，这让我们有了一个强大的范式：\hyperlink{16455129305818705265}{\texttt{do}}。可选参数与关键字参数的处理方式不同。方法的歧义没有像在 Common Lisp 对象系统中那样得到解决，因此需要为交集定义更具体的方法。


\item 符号不属于任何包，它\textbf{本身}也不包含任何值。\texttt{M.var} 会对 \texttt{M} 模块里的  \texttt{var} 符号求值。


\item Julia 完全支持函数式编程风格，包括闭包等特性。但这并不是 Julia 的惯用风格。修改捕获变量时需要一些额外的\hyperlink{627547588659365489}{变通}以便提高性能。

\end{itemize}


\hypertarget{13492984054190257059}{}


\chapter{Unicode 输入表}



在 Julia REPL 或其它编辑器中，可以像输入 LaTeX 符号一样，用 tab 补全下表列出的 Unicode 字符。在 REPL 中，可以先按 \texttt{?} 进入帮助模式，然后将 Unicode 字符复制粘贴进去，一般在文档开头就会写输入方式。



\begin{quote}
\textbf{Warning}

此表第二列可能会缺失一些字符，对某些字符的显示效果也可能会与在 Julia REPL 中不一致。如果发生了这种状况，强烈建议用户检查一下浏览器或 REPL 的字体设置，目前已知很多字体都有显示问题。

\end{quote}


% Unicode 表
% \input{part/unicode-table.tex}



\hypertarget{7890528511117722792}{}


\chapter{命令行选项}



以下是启动 julia 时可用的命令行选项的完整列表：




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
选项 & 描述 \\
\hline
\texttt{-v}, \texttt{--version} & 显示版本信息 \\
\hline
\texttt{-h}, \texttt{--help} & 显示命令行参数 \\
\hline
\texttt{--project[=\{<dir>|@.\}]} & 将 <dir> 设置为主项目/环境。默认的 @. 选项将搜索父目录，直至找到 Project.toml 或 JuliaProject.toml 文件。 \\
\hline
\texttt{-J}, \texttt{--sysimage <file>} & 用指定的系统镜像文件（system image file）启动 \\
\hline
\texttt{-H}, \texttt{--home <dir>} & 设置 \texttt{julia} 可执行文件的路径 \\
\hline
\texttt{--startup-file=\{yes|no\}} & 是否载入 \texttt{{\textasciitilde}/.julia/config/startup.jl} \\
\hline
\texttt{--handle-signals=\{yes|no\}} & 开启或关闭 Julia 默认的 signal handlers \\
\hline
\texttt{--sysimage-native-code=\{yes|no\}} & 在可能的情况下，使用系统镜像里的原生代码 \\
\hline
\texttt{--compiled-modules=\{yes|no\}} & 开启或关闭 module 的增量预编译功能 \\
\hline
\texttt{-e}, \texttt{--eval <expr>} & 执行 \texttt{<expr>} \\
\hline
\texttt{-E}, \texttt{--print <expr>} & 执行 \texttt{<expr>} 并显示结果 \\
\hline
\texttt{-L}, \texttt{--load <file>} & 立即在所有进程中载入 \texttt{<file>} \\
\hline
\texttt{-t}, \texttt{--threads \{N|auto\}} & 开启 N 个线程：\texttt{auto} 将 N 设置为当前 CPU 线程数，但这个行为可能在以后版本有所变动。 \\
\hline
\texttt{-p}, \texttt{--procs \{N|auto\}} & 这里的整数 N 表示启动 N 个额外的工作进程；\texttt{auto} 表示启动与 CPU 线程数目（logical cores）一样多的进程 \\
\hline
\texttt{--machine-file <file>} & 在 \texttt{<file>} 中列出的主机上运行进程 \\
\hline
\texttt{-i} & 交互式模式；REPL 运行且 \texttt{isinteractive()} 为 true \\
\hline
\texttt{-q}, \texttt{--quiet} & 安静的启动；REPL 启动时无横幅，不显示警告 \\
\hline
\texttt{--banner=\{yes|no|auto\}} & 开启或关闭 REPL 横幅 \\
\hline
\texttt{--color=\{yes|no|auto\}} & 开启或关闭文字颜色 \\
\hline
\texttt{--history-file=\{yes|no\}} & 载入或导出历史记录 \\
\hline
\texttt{--depwarn=\{yes|no|error\}} & 开启或关闭语法弃用警告，\texttt{error} 表示将弃用警告转换为错误。 \\
\hline
\texttt{--warn-overwrite=\{yes|no\}} & 开启或关闭“method overwrite”警告 \\
\hline
\texttt{-C}, \texttt{--cpu-target <target>} & 设置 \texttt{<target>} 来限制使用 CPU 的某些特性；设置为 \texttt{help} 可以查看可用的选项 \\
\hline
\texttt{-O}, \texttt{--optimize=\{0,1,2,3\}} & 设置编译器优化级别(若未配置此选项，则默认等级为2；若配置了此选项却没指定具体级别，则默认级别为3)。 \\
\hline
\texttt{--min-optlevel=\{0,1,2,3\}} & 设置每个模块加载的优化下限（默认为 0） \\
\hline
\texttt{-g}, \texttt{-g <level>} & 开启或设置 debug 信息的生成等级。若未配置此选项，则默认 debug 信息的级别为 1；若配置了此选项却没指定具体级别，则默认级别为 2。 \\
\hline
\texttt{--inline=\{yes|no\}} & 控制是否允许函数内联，此选项会覆盖源文件中的 \texttt{@inline} 声明 \\
\hline
\texttt{--check-bounds=\{yes|no|auto\}} & 进行边界检查，总是、从不、或依照宏@inbounds声明 \\
\hline
\texttt{--math-mode=\{ieee,fast\}} & 开启或关闭非安全的浮点数代数计算优化，此选项会覆盖源文件中的 \texttt{@fastmath} 声明 \\
\hline
\texttt{--code-coverage=\{none|user|all\}} & 对源文件中每行代码执行的次数计数 \\
\hline
\texttt{--code-coverage} & 等价于 \texttt{--code-coverage=user} \\
\hline
\texttt{--track-allocation=\{none|user|all\}} & 对源文件中每行代码的内存分配计数，单位 byte \\
\hline
\texttt{--track-allocation} & 等价于 \texttt{--track-allocation=user} \\
\hline
\end{tabulary}

\end{table}



\begin{quote}
\textbf{Julia 1.1}

在 Julia 1.0 中，默认的 \texttt{--project=@.} 选项不会在 Git 仓库的根目录中寻找 \texttt{Project.toml} 文件。从 Julia 1.1 开始，此选项会在其中寻找该文件。

\end{quote}
