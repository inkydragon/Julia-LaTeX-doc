
\part{Standard Library}


\hypertarget{11756231791819393325}{}


\chapter{Base64}


\hypertarget{6529833673026929543}{} 
\hyperlink{6529833673026929543}{\texttt{Base64.Base64}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base64
\end{minted}

Functionality for base-64 encoded strings and IO.



\end{adjustwidth}
\hypertarget{3718432815614240925}{} 
\hyperlink{3718432815614240925}{\texttt{Base64.Base64EncodePipe}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base64EncodePipe(ostream)
\end{minted}

Return a new write-only I/O stream, which converts any bytes written to it into base64-encoded ASCII bytes written to \texttt{ostream}.  Calling \hyperlink{5331333469799487255}{\texttt{close}} on the \texttt{Base64EncodePipe} stream is necessary to complete the encoding (but does not close \texttt{ostream}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer();

julia> iob64_encode = Base64EncodePipe(io);

julia> write(iob64_encode, "Hello!")
6

julia> close(iob64_encode);

julia> str = String(take!(io))
"SGVsbG8h"

julia> String(base64decode(str))
"Hello!"
\end{minted}



\end{adjustwidth}
\hypertarget{1446212874874362397}{} 
\hyperlink{1446212874874362397}{\texttt{Base64.base64encode}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
base64encode(writefunc, args...; context=nothing)
base64encode(args...; context=nothing)
\end{minted}

Given a \hyperlink{16947913578760238729}{\texttt{write}}-like function \texttt{writefunc}, which takes an I/O stream as its first argument, \texttt{base64encode(writefunc, args...)} calls \texttt{writefunc} to write \texttt{args...} to a base64-encoded string, and returns the string. \texttt{base64encode(args...)} is equivalent to \texttt{base64encode(write, args...)}: it converts its arguments into bytes using the standard \hyperlink{16947913578760238729}{\texttt{write}} functions and returns the base64-encoded string.

The optional keyword argument \texttt{context} can be set to \texttt{:key=>value} pair or an \texttt{IO} or \hyperlink{13454403377667762339}{\texttt{IOContext}} object whose attributes are used for the I/O stream passed to \texttt{writefunc} or \texttt{write}.

See also \hyperlink{7809304046524048078}{\texttt{base64decode}}.



\end{adjustwidth}
\hypertarget{3379294475433655298}{} 
\hyperlink{3379294475433655298}{\texttt{Base64.Base64DecodePipe}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base64DecodePipe(istream)
\end{minted}

Return a new read-only I/O stream, which decodes base64-encoded data read from \texttt{istream}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = IOBuffer();

julia> iob64_decode = Base64DecodePipe(io);

julia> write(io, "SGVsbG8h")
8

julia> seekstart(io);

julia> String(read(iob64_decode))
"Hello!"
\end{minted}



\end{adjustwidth}
\hypertarget{7809304046524048078}{} 
\hyperlink{7809304046524048078}{\texttt{Base64.base64decode}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
base64decode(string)
\end{minted}

Decode the base64-encoded \texttt{string} and returns a \texttt{Vector\{UInt8\}} of the decoded bytes.

See also \hyperlink{1446212874874362397}{\texttt{base64encode}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> b = base64decode("SGVsbG8h")
6-element Array{UInt8,1}:
 0x48
 0x65
 0x6c
 0x6c
 0x6f
 0x21

julia> String(b)
"Hello!"
\end{minted}



\end{adjustwidth}
\hypertarget{17279723834582920486}{} 
\hyperlink{17279723834582920486}{\texttt{Base64.stringmime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stringmime(mime, x; context=nothing)
\end{minted}

Returns an \texttt{AbstractString} containing the representation of \texttt{x} in the requested \texttt{mime} type. This is similar to \hyperlink{13076889230390082034}{\texttt{repr(mime, x)}} except that binary data is base64-encoded as an ASCII string.

The optional keyword argument \texttt{context} can be set to \texttt{:key=>value} pair or an \texttt{IO} or \hyperlink{13454403377667762339}{\texttt{IOContext}} object whose attributes are used for the I/O stream passed to \hyperlink{14071376285304310153}{\texttt{show}}.



\end{adjustwidth}

\hypertarget{2465264826987872946}{}


\chapter{CRC32c}


\hypertarget{8058568265327059376}{} 
\hyperlink{8058568265327059376}{\texttt{CRC32c.crc32c}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
crc32c(data, crc::UInt32=0x00000000)
\end{minted}

Compute the CRC-32c checksum of the given \texttt{data}, which can be an \texttt{Array\{UInt8\}}, a contiguous subarray thereof, or a \texttt{String}.  Optionally, you can pass a starting \texttt{crc} integer to be mixed in with the checksum.  The \texttt{crc} parameter can be used to compute a checksum on data divided into chunks: performing \texttt{crc32c(data2, crc32c(data1))} is equivalent to the checksum of \texttt{[data1; data2]}. (Technically, a little-endian checksum is computed.)

There is also a method \texttt{crc32c(io, nb, crc)} to checksum \texttt{nb} bytes from a stream \texttt{io}, or \texttt{crc32c(io, crc)} to checksum all the remaining bytes. Hence you can do \hyperlink{300818094931158296}{\texttt{open(crc32c, filename)}} to checksum an entire file, or \texttt{crc32c(seekstart(buf))} to checksum an \hyperlink{15789326112236459498}{\texttt{IOBuffer}} without calling \hyperlink{4963355246106153560}{\texttt{take!}}.

For a \texttt{String}, note that the result is specific to the UTF-8 encoding (a different checksum would be obtained from a different Unicode encoding). To checksum an \texttt{a::Array} of some other bitstype, you can do \texttt{crc32c(reinterpret(UInt8,a))}, but note that the result may be endian-dependent.



\end{adjustwidth}
\hypertarget{2947862938473710782}{} 
\hyperlink{2947862938473710782}{\texttt{CRC32c.crc32c}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
crc32c(io::IO, [nb::Integer,] crc::UInt32=0x00000000)
\end{minted}

Read up to \texttt{nb} bytes from \texttt{io} and return the CRC-32c checksum, optionally mixed with a starting \texttt{crc} integer.  If \texttt{nb} is not supplied, then \texttt{io} will be read until the end of the stream.



\end{adjustwidth}

\hypertarget{12670537780554709073}{}


\chapter{日期}





\texttt{Dates} 模块提供了两种类型来处理日期：\hyperlink{4488183467971164548}{\texttt{Date}} 和 \hyperlink{17572689933274889838}{\texttt{DateTime}}，分别精确到日和毫秒；两者都是抽象类型 \hyperlink{4438614350756187528}{\texttt{TimeType}} 的子类型。区分类型的动机很简单：不必处理更高精度所带来的复杂性时，一些操作在代码和思维推理上都更加简单。例如，由于 \hyperlink{4488183467971164548}{\texttt{Date}} 类型仅精确到日（即没有时、分或秒），因此避免了时区、夏令时和闰秒等不必要的通常考虑。



Both \hyperlink{4488183467971164548}{\texttt{Date}} and \hyperlink{17572689933274889838}{\texttt{DateTime}} are basically immutable \hyperlink{7720564657383125058}{\texttt{Int64}} wrappers. The single \texttt{instant} field of either type is actually a \texttt{UTInstant\{P\}} type, which represents a continuously increasing machine timeline based on the UT second \footnotemark[1]. The \hyperlink{17572689933274889838}{\texttt{DateTime}} type is not aware of time zones (\emph{naive}, in Python parlance), analogous to a \emph{LocalDateTime} in Java 8. Additional time zone functionality can be added through the \href{https://github.com/JuliaTime/TimeZones.jl/}{TimeZones.jl package}, which compiles the \href{http://www.iana.org/time-zones}{IANA time zone database}. Both \hyperlink{4488183467971164548}{\texttt{Date}} and \hyperlink{17572689933274889838}{\texttt{DateTime}} are based on the \href{https://en.wikipedia.org/wiki/ISO\_8601}{ISO 8601} standard, which follows the proleptic Gregorian calendar. One note is that the ISO 8601 standard is particular about BC/BCE dates. In general, the last day of the BC/BCE era, 1-12-31 BC/BCE, was followed by 1-1-1 AD/CE, thus no year zero exists. The ISO standard, however, states that 1 BC/BCE is year zero, so \texttt{0000-12-31} is the day before \texttt{0001-01-01}, and year \texttt{-0001} (yes, negative one for the year) is 2 BC/BCE, year \texttt{-0002} is 3 BC/BCE, etc.



\footnotetext[1]{The notion of the UT second is actually quite fundamental. There are basically two different notions of time generally accepted, one based on the physical rotation of the earth (one full rotation = 1 day), the other based on the SI second (a fixed, constant value). These are radically different! Think about it, a {\textquotedbl}UT second{\textquotedbl}, as defined relative to the rotation of the earth, may have a different absolute length depending on the day! Anyway, the fact that \hyperlink{4488183467971164548}{\texttt{Date}} and \hyperlink{17572689933274889838}{\texttt{DateTime}} are based on UT seconds is a simplifying, yet honest assumption so that things like leap seconds and all their complexity can be avoided. This basis of time is formally called \href{https://en.wikipedia.org/wiki/Universal\_Time}{UT} or UT1. Basing types on the UT second basically means that every minute has 60 seconds and every day has 24 hours and leads to more natural calculations when working with calendar dates.

}


\hypertarget{5490460475085720426}{}


\section{构造函数}



\hyperlink{4488183467971164548}{\texttt{Date}} 和 \hyperlink{17572689933274889838}{\texttt{DateTime}} 类型可以通过整数或 \hyperlink{17624028548543163266}{\texttt{Period}} 类型，解析，或调整器来构造（稍后会详细介绍）：




\begin{minted}{jlcon}
julia> DateTime(2013)
2013-01-01T00:00:00

julia> DateTime(2013,7)
2013-07-01T00:00:00

julia> DateTime(2013,7,1)
2013-07-01T00:00:00

julia> DateTime(2013,7,1,12)
2013-07-01T12:00:00

julia> DateTime(2013,7,1,12,30)
2013-07-01T12:30:00

julia> DateTime(2013,7,1,12,30,59)
2013-07-01T12:30:59

julia> DateTime(2013,7,1,12,30,59,1)
2013-07-01T12:30:59.001

julia> Date(2013)
2013-01-01

julia> Date(2013,7)
2013-07-01

julia> Date(2013,7,1)
2013-07-01

julia> Date(Dates.Year(2013),Dates.Month(7),Dates.Day(1))
2013-07-01

julia> Date(Dates.Month(7),Dates.Year(2013))
2013-07-01
\end{minted}



\hyperlink{4488183467971164548}{\texttt{Date}} or \hyperlink{17572689933274889838}{\texttt{DateTime}} parsing is accomplished by the use of format strings. Format strings work by the notion of defining \emph{delimited} or \emph{fixed-width} {\textquotedbl}slots{\textquotedbl} that contain a period to parse and passing the text to parse and format string to a \hyperlink{4488183467971164548}{\texttt{Date}} or \hyperlink{17572689933274889838}{\texttt{DateTime}} constructor, of the form \texttt{Date({\textquotedbl}2015-01-01{\textquotedbl},{\textquotedbl}y-m-d{\textquotedbl})} or \texttt{DateTime({\textquotedbl}20150101{\textquotedbl},{\textquotedbl}yyyymmdd{\textquotedbl})}.



Delimited slots are marked by specifying the delimiter the parser should expect between two subsequent periods; so \texttt{{\textquotedbl}y-m-d{\textquotedbl}} lets the parser know that between the first and second slots in a date string like \texttt{{\textquotedbl}2014-07-16{\textquotedbl}}, it should find the \texttt{-} character. The \texttt{y}, \texttt{m}, and \texttt{d} characters let the parser know which periods to parse in each slot.



Fixed-width slots are specified by repeating the period character the number of times corresponding to the width with no delimiter between characters. So \texttt{{\textquotedbl}yyyymmdd{\textquotedbl}} would correspond to a date string like \texttt{{\textquotedbl}20140716{\textquotedbl}}. The parser distinguishes a fixed-width slot by the absence of a delimiter, noting the transition \texttt{{\textquotedbl}yyyymm{\textquotedbl}} from one period character to the next.



Support for text-form month parsing is also supported through the \texttt{u} and \texttt{U} characters, for abbreviated and full-length month names, respectively. By default, only English month names are supported, so \texttt{u} corresponds to {\textquotedbl}Jan{\textquotedbl}, {\textquotedbl}Feb{\textquotedbl}, {\textquotedbl}Mar{\textquotedbl}, etc. And \texttt{U} corresponds to {\textquotedbl}January{\textquotedbl}, {\textquotedbl}February{\textquotedbl}, {\textquotedbl}March{\textquotedbl}, etc. Similar to other name=>value mapping functions \hyperlink{2440842966718954493}{\texttt{dayname}} and \hyperlink{16585759639636493546}{\texttt{monthname}}, custom locales can be loaded by passing in the \texttt{locale=>Dict\{String,Int\}} mapping to the \texttt{MONTHTOVALUEABBR} and \texttt{MONTHTOVALUE} dicts for abbreviated and full-name month names, respectively.



One note on parsing performance: using the \texttt{Date(date\_string,format\_string)} function is fine if only called a few times. If there are many similarly formatted date strings to parse however, it is much more efficient to first create a \hyperlink{18093459443158853001}{\texttt{Dates.DateFormat}}, and pass it instead of a raw format string.




\begin{minted}{jlcon}
julia> df = DateFormat("y-m-d");

julia> dt = Date("2015-01-01",df)
2015-01-01

julia> dt2 = Date("2015-01-02",df)
2015-01-02
\end{minted}



You can also use the \texttt{dateformat{\textquotedbl}{\textquotedbl}} string macro. This macro creates the \texttt{DateFormat} object once when the macro is expanded and uses the same \texttt{DateFormat} object even if a code snippet is run multiple times.




\begin{minted}{jlcon}
julia> for i = 1:10^5
           Date("2015-01-01", dateformat"y-m-d")
       end
\end{minted}



A full suite of parsing and formatting tests and examples is available in \href{https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/io.jl}{\texttt{stdlib/Dates/test/io.jl}}.



\hypertarget{5885257312656473374}{}


\section{持续时间/比较}



Finding the length of time between two \hyperlink{4488183467971164548}{\texttt{Date}} or \hyperlink{17572689933274889838}{\texttt{DateTime}} is straightforward given their underlying representation as \texttt{UTInstant\{Day\}} and \texttt{UTInstant\{Millisecond\}}, respectively. The difference between \hyperlink{4488183467971164548}{\texttt{Date}} is returned in the number of \hyperlink{13217464551942182596}{\texttt{Day}}, and \hyperlink{17572689933274889838}{\texttt{DateTime}} in the number of \hyperlink{9366634148855607364}{\texttt{Millisecond}}. Similarly, comparing \hyperlink{4438614350756187528}{\texttt{TimeType}} is a simple matter of comparing the underlying machine instants (which in turn compares the internal \hyperlink{7720564657383125058}{\texttt{Int64}} values).




\begin{minted}{jlcon}
julia> dt = Date(2012,2,29)
2012-02-29

julia> dt2 = Date(2000,2,1)
2000-02-01

julia> dump(dt)
Date
  instant: Dates.UTInstant{Day}
    periods: Day
      value: Int64 734562

julia> dump(dt2)
Date
  instant: Dates.UTInstant{Day}
    periods: Day
      value: Int64 730151

julia> dt > dt2
true

julia> dt != dt2
true

julia> dt + dt2
ERROR: MethodError: no method matching +(::Date, ::Date)
[...]

julia> dt * dt2
ERROR: MethodError: no method matching *(::Date, ::Date)
[...]

julia> dt / dt2
ERROR: MethodError: no method matching /(::Date, ::Date)

julia> dt - dt2
4411 days

julia> dt2 - dt
-4411 days

julia> dt = DateTime(2012,2,29)
2012-02-29T00:00:00

julia> dt2 = DateTime(2000,2,1)
2000-02-01T00:00:00

julia> dt - dt2
381110400000 milliseconds
\end{minted}



\hypertarget{1797872614315202652}{}


\section{访问函数}



Because the \hyperlink{4488183467971164548}{\texttt{Date}} and \hyperlink{17572689933274889838}{\texttt{DateTime}} types are stored as single \hyperlink{7720564657383125058}{\texttt{Int64}} values, date parts or fields can be retrieved through accessor functions. The lowercase accessors return the field as an integer:




\begin{minted}{jlcon}
julia> t = Date(2014, 1, 31)
2014-01-31

julia> Dates.year(t)
2014

julia> Dates.month(t)
1

julia> Dates.week(t)
5

julia> Dates.day(t)
31
\end{minted}



当首字母大写时会返回对应 \hyperlink{17624028548543163266}{\texttt{Period}} 类型的相同值：




\begin{minted}{jlcon}
julia> Dates.Year(t)
2014 years

julia> Dates.Day(t)
31 days
\end{minted}



Compound methods are provided, as they provide a measure of efficiency if multiple fields are needed at the same time:




\begin{minted}{jlcon}
julia> Dates.yearmonth(t)
(2014, 1)

julia> Dates.monthday(t)
(1, 31)

julia> Dates.yearmonthday(t)
(2014, 1, 31)
\end{minted}



One may also access the underlying \texttt{UTInstant} or integer value:




\begin{minted}{jlcon}
julia> dump(t)
Date
  instant: Dates.UTInstant{Day}
    periods: Day
      value: Int64 735264

julia> t.instant
Dates.UTInstant{Day}(Day(735264))

julia> Dates.value(t)
735264
\end{minted}



\hypertarget{6547083286508545671}{}


\section{查询函数}



Query functions provide calendrical information about a \hyperlink{4438614350756187528}{\texttt{TimeType}}. They include information about the day of the week:




\begin{minted}{jlcon}
julia> t = Date(2014, 1, 31)
2014-01-31

julia> Dates.dayofweek(t)
5

julia> Dates.dayname(t)
"Friday"

julia> Dates.dayofweekofmonth(t) # 5th Friday of January
5
\end{minted}



一年中的月份：




\begin{minted}{jlcon}
julia> Dates.monthname(t)
"January"

julia> Dates.daysinmonth(t)
31
\end{minted}



As well as information about the \hyperlink{4438614350756187528}{\texttt{TimeType}}{\textquotesingle}s year and quarter:




\begin{minted}{jlcon}
julia> Dates.isleapyear(t)
false

julia> Dates.dayofyear(t)
31

julia> Dates.quarterofyear(t)
1

julia> Dates.dayofquarter(t)
31
\end{minted}



The \hyperlink{2440842966718954493}{\texttt{dayname}} and \hyperlink{16585759639636493546}{\texttt{monthname}} methods can also take an optional \texttt{locale} keyword that can be used to return the name of the day or month of the year for other languages/locales. There are also versions of these functions returning the abbreviated names, namely \hyperlink{18198970391837299875}{\texttt{dayabbr}} and \hyperlink{12804940912944832895}{\texttt{monthabbr}}. First the mapping is loaded into the \texttt{LOCALES} variable:




\begin{minted}{jlcon}
julia> french_months = ["janvier", "février", "mars", "avril", "mai", "juin",
                        "juillet", "août", "septembre", "octobre", "novembre", "décembre"];

julia> french_monts_abbrev = ["janv","févr","mars","avril","mai","juin",
                              "juil","août","sept","oct","nov","déc"];

julia> french_days = ["lundi","mardi","mercredi","jeudi","vendredi","samedi","dimanche"];

julia> Dates.LOCALES["french"] = Dates.DateLocale(french_months, french_monts_abbrev, french_days, [""]);
\end{minted}



The above mentioned functions can then be used to perform the queries:




\begin{minted}{jlcon}
julia> Dates.dayname(t;locale="french")
"vendredi"

julia> Dates.monthname(t;locale="french")
"janvier"

julia> Dates.monthabbr(t;locale="french")
"janv"
\end{minted}



自从缩写版本的 \texttt{days} 函数不加载之后，试图访问函数 \texttt{dayabbr} 将导致一个错误。




\begin{minted}{jlcon}
julia> Dates.dayabbr(t;locale="french")
ERROR: BoundsError: attempt to access 1-element Array{String,1} at index [5]
Stacktrace:
[...]
\end{minted}



\hypertarget{552552737851946510}{}


\section{TimeType 时间运算}



It{\textquotesingle}s good practice when using any language/date framework to be familiar with how date-period arithmetic is handled as there are some \href{https://codeblog.jonskeet.uk/2010/12/01/the-joys-of-date-time-arithmetic/}{tricky issues} to deal with (though much less so for day-precision types).



The \texttt{Dates} module approach tries to follow the simple principle of trying to change as little as possible when doing \hyperlink{17624028548543163266}{\texttt{Period}} arithmetic. This approach is also often known as \emph{calendrical} arithmetic or what you would probably guess if someone were to ask you the same calculation in a conversation. Why all the fuss about this? Let{\textquotesingle}s take a classic example: add 1 month to January 31st, 2014. What{\textquotesingle}s the answer? Javascript will say \href{https://markhneedham.com/blog/2009/01/07/javascript-add-a-month-to-a-date/}{March 3} (assumes 31 days). PHP says \href{https://stackoverflow.com/questions/5760262/php-adding-months-to-a-date-while-not-exceeding-the-last-day-of-the-month}{March 2} (assumes 30 days). The fact is, there is no right answer. In the \texttt{Dates} module, it gives the result of February 28th. How does it figure that out? I like to think of the classic 7-7-7 gambling game in casinos.



Now just imagine that instead of 7-7-7, the slots are Year-Month-Day, or in our example, 2014-01-31. When you ask to add 1 month to this date, the month slot is incremented, so now we have 2014-02-31. Then the day number is checked if it is greater than the last valid day of the new month; if it is (as in the case above), the day number is adjusted down to the last valid day (28). What are the ramifications with this approach? Go ahead and add another month to our date, \texttt{2014-02-28 + Month(1) == 2014-03-28}. What? Were you expecting the last day of March? Nope, sorry, remember the 7-7-7 slots. As few slots as possible are going to change, so we first increment the month slot by 1, 2014-03-28, and boom, we{\textquotesingle}re done because that{\textquotesingle}s a valid date. On the other hand, if we were to add 2 months to our original date, 2014-01-31, then we end up with 2014-03-31, as expected. The other ramification of this approach is a loss in associativity when a specific ordering is forced (i.e. adding things in different orders results in different outcomes). For example:




\begin{minted}{jlcon}
julia> (Date(2014,1,29)+Dates.Day(1)) + Dates.Month(1)
2014-02-28

julia> (Date(2014,1,29)+Dates.Month(1)) + Dates.Day(1)
2014-03-01
\end{minted}



What{\textquotesingle}s going on there? In the first line, we{\textquotesingle}re adding 1 day to January 29th, which results in 2014-01-30; then we add 1 month, so we get 2014-02-30, which then adjusts down to 2014-02-28. In the second example, we add 1 month \emph{first}, where we get 2014-02-29, which adjusts down to 2014-02-28, and \emph{then} add 1 day, which results in 2014-03-01. One design principle that helps in this case is that, in the presence of multiple Periods, the operations will be ordered by the Periods{\textquotesingle} \emph{types}, not their value or positional order; this means \texttt{Year} will always be added first, then \texttt{Month}, then \texttt{Week}, etc. Hence the following \emph{does} result in associativity and Just Works:




\begin{minted}{jlcon}
julia> Date(2014,1,29) + Dates.Day(1) + Dates.Month(1)
2014-03-01

julia> Date(2014,1,29) + Dates.Month(1) + Dates.Day(1)
2014-03-01
\end{minted}



Tricky? Perhaps. What is an innocent \texttt{Dates} user to do? The bottom line is to be aware that explicitly forcing a certain associativity, when dealing with months, may lead to some unexpected results, but otherwise, everything should work as expected. Thankfully, that{\textquotesingle}s pretty much the extent of the odd cases in date-period arithmetic when dealing with time in UT (avoiding the {\textquotedbl}joys{\textquotedbl} of dealing with daylight savings, leap seconds, etc.).



另外，所有时间运算都可以与范围一起使用：




\begin{minted}{jlcon}
julia> dr = Date(2014,1,29):Day(1):Date(2014,2,3)
Date("2014-01-29"):Day(1):Date("2014-02-03")

julia> collect(dr)
6-element Array{Date,1}:
 2014-01-29
 2014-01-30
 2014-01-31
 2014-02-01
 2014-02-02
 2014-02-03

julia> dr = Date(2014,1,29):Dates.Month(1):Date(2014,07,29)
Date("2014-01-29"):Month(1):Date("2014-07-29")

julia> collect(dr)
7-element Array{Date,1}:
 2014-01-29
 2014-02-28
 2014-03-29
 2014-04-29
 2014-05-29
 2014-06-29
 2014-07-29
\end{minted}



\hypertarget{16701273079523868506}{}


\section{调整器函数}



As convenient as date-period arithmetic is, often the kinds of calculations needed on dates take on a \emph{calendrical} or \emph{temporal} nature rather than a fixed number of periods. Holidays are a perfect example; most follow rules such as {\textquotedbl}Memorial Day = Last Monday of May{\textquotedbl}, or {\textquotedbl}Thanksgiving = 4th Thursday of November{\textquotedbl}. These kinds of temporal expressions deal with rules relative to the calendar, like first or last of the month, next Tuesday, or the first and third Wednesdays, etc.



The \texttt{Dates} module provides the \emph{adjuster} API through several convenient methods that aid in simply and succinctly expressing temporal rules. The first group of adjuster methods deal with the first and last of weeks, months, quarters, and years. They each take a single \hyperlink{4438614350756187528}{\texttt{TimeType}} as input and return or \emph{adjust to} the first or last of the desired period relative to the input.




\begin{minted}{jlcon}
julia> Dates.firstdayofweek(Date(2014,7,16)) # Adjusts the input to the Monday of the input's week
2014-07-14

julia> Dates.lastdayofmonth(Date(2014,7,16)) # Adjusts to the last day of the input's month
2014-07-31

julia> Dates.lastdayofquarter(Date(2014,7,16)) # Adjusts to the last day of the input's quarter
2014-09-30
\end{minted}



The next two higher-order methods, \hyperlink{9410879287453023176}{\texttt{tonext}}, and \hyperlink{5295237512711135506}{\texttt{toprev}}, generalize working with temporal expressions by taking a \texttt{DateFunction} as first argument, along with a starting \hyperlink{4438614350756187528}{\texttt{TimeType}}. A \texttt{DateFunction} is just a function, usually anonymous, that takes a single \hyperlink{4438614350756187528}{\texttt{TimeType}} as input and returns a \hyperlink{46725311238864537}{\texttt{Bool}}, \texttt{true} indicating a satisfied adjustment criterion. For example:




\begin{minted}{jlcon}
julia> istuesday = x->Dates.dayofweek(x) == Dates.Tuesday; # 当 x 是周二时返回 true

julia> Dates.tonext(istuesday, Date(2014,7,13)) # 2014-07-13 是周日
2014-07-15

julia> Dates.tonext(Date(2014,7,13), Dates.Tuesday) # 星期调整的便捷方法
2014-07-15
\end{minted}



This is useful with the do-block syntax for more complex temporal expressions:




\begin{minted}{jlcon}
julia> Dates.tonext(Date(2014,7,13)) do x
           # 在十一月的第四个星期四——感恩节那天返回 true
           Dates.dayofweek(x) == Dates.Thursday &&
           Dates.dayofweekofmonth(x) == 4 &&
           Dates.month(x) == Dates.November
       end
2014-11-27
\end{minted}



The \hyperlink{11445961893478569145}{\texttt{Base.filter}} method can be used to obtain all valid dates/moments in a specified range:




\begin{minted}{jlcon}
# Pittsburgh street cleaning; Every 2nd Tuesday from April to November
# Date range from January 1st, 2014 to January 1st, 2015
julia> dr = Dates.Date(2014):Day(1):Dates.Date(2015);

julia> filter(dr) do x
           Dates.dayofweek(x) == Dates.Tue &&
           Dates.April <= Dates.month(x) <= Dates.Nov &&
           Dates.dayofweekofmonth(x) == 2
       end
8-element Array{Date,1}:
 2014-04-08
 2014-05-13
 2014-06-10
 2014-07-08
 2014-08-12
 2014-09-09
 2014-10-14
 2014-11-11
\end{minted}



Additional examples and tests are available in \href{https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/adjusters.jl}{\texttt{stdlib/Dates/test/adjusters.jl}}.



\hypertarget{17903801457919484645}{}


\section{时间段类型}



Periods are a human view of discrete, sometimes irregular durations of time. Consider 1 month; it could represent, in days, a value of 28, 29, 30, or 31 depending on the year and month context. Or a year could represent 365 or 366 days in the case of a leap year. \hyperlink{17624028548543163266}{\texttt{Period}} types are simple \hyperlink{7720564657383125058}{\texttt{Int64}} wrappers and are constructed by wrapping any \texttt{Int64} convertible type, i.e. \texttt{Year(1)} or \texttt{Month(3.0)}. Arithmetic between \hyperlink{17624028548543163266}{\texttt{Period}} of the same type behave like integers, and limited \texttt{Period-Real} arithmetic is available.  You can extract the underlying integer with \hyperlink{6471383377711200525}{\texttt{Dates.value}}.




\begin{minted}{jlcon}
julia> y1 = Dates.Year(1)
1 year

julia> y2 = Dates.Year(2)
2 years

julia> y3 = Dates.Year(10)
10 years

julia> y1 + y2
3 years

julia> div(y3,y2)
5

julia> y3 - y2
8 years

julia> y3 % y2
0 years

julia> div(y3,3) # mirrors integer division
3 years

julia> Dates.value(Dates.Millisecond(10))
10
\end{minted}



\hypertarget{2131702258451006422}{}


\section{取整}



\hyperlink{4488183467971164548}{\texttt{Date}} and \hyperlink{17572689933274889838}{\texttt{DateTime}} values can be rounded to a specified resolution (e.g., 1 month or 15 minutes) with \hyperlink{11115257331910840693}{\texttt{floor}}, \hyperlink{10519509038312853061}{\texttt{ceil}}, or \hyperlink{12930779325193350739}{\texttt{round}}:




\begin{minted}{jlcon}
julia> floor(Date(1985, 8, 16), Dates.Month)
1985-08-01

julia> ceil(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))
2013-02-13T00:45:00

julia> round(DateTime(2016, 8, 6, 20, 15), Dates.Day)
2016-08-07T00:00:00
\end{minted}



Unlike the numeric \hyperlink{12930779325193350739}{\texttt{round}} method, which breaks ties toward the even number by default, the \hyperlink{4438614350756187528}{\texttt{TimeType}}\hyperlink{12930779325193350739}{\texttt{round}} method uses the \texttt{RoundNearestTiesUp} rounding mode. (It{\textquotesingle}s difficult to guess what breaking ties to nearest {\textquotedbl}even{\textquotedbl} \hyperlink{4438614350756187528}{\texttt{TimeType}} would entail.) Further details on the available \texttt{RoundingMode} s can be found in the \hyperlink{2504340439131318713}{API reference}.



Rounding should generally behave as expected, but there are a few cases in which the expected behaviour is not obvious.



\hypertarget{18235125897086797691}{}


\subsection{Rounding Epoch}



In many cases, the resolution specified for rounding (e.g., \texttt{Dates.Second(30)}) divides evenly into the next largest period (in this case, \texttt{Dates.Minute(1)}). But rounding behaviour in cases in which this is not true may lead to confusion. What is the expected result of rounding a \hyperlink{17572689933274889838}{\texttt{DateTime}} to the nearest 10 hours?




\begin{minted}{jlcon}
julia> round(DateTime(2016, 7, 17, 11, 55), Dates.Hour(10))
2016-07-17T12:00:00
\end{minted}



That may seem confusing, given that the hour (12) is not divisible by 10. The reason that \texttt{2016-07-17T12:00:00} was chosen is that it is 17,676,660 hours after \texttt{0000-01-01T00:00:00}, and 17,676,660 is divisible by 10.



As Julia \hyperlink{4488183467971164548}{\texttt{Date}} and \hyperlink{17572689933274889838}{\texttt{DateTime}} values are represented according to the ISO 8601 standard, \texttt{0000-01-01T00:00:00} was chosen as base (or {\textquotedbl}rounding epoch{\textquotedbl}) from which to begin the count of days (and milliseconds) used in rounding calculations. (Note that this differs slightly from Julia{\textquotesingle}s internal representation of \hyperlink{4488183467971164548}{\texttt{Date}} s using Rata Die notation; but since the ISO 8601 standard is most visible to the end user, \texttt{0000-01-01T00:00:00} was chosen as the rounding epoch instead of the \texttt{0000-12-31T00:00:00} used internally to minimize confusion.)



The only exception to the use of \texttt{0000-01-01T00:00:00} as the rounding epoch is when rounding to weeks. Rounding to the nearest week will always return a Monday (the first day of the week as specified by ISO 8601). For this reason, we use \texttt{0000-01-03T00:00:00} (the first day of the first week of year 0000, as defined by ISO 8601) as the base when rounding to a number of weeks.



Here is a related case in which the expected behaviour is not necessarily obvious: What happens when we round to the nearest \texttt{P(2)}, where \texttt{P} is a \hyperlink{17624028548543163266}{\texttt{Period}} type? In some cases (specifically, when \texttt{P <: Dates.TimePeriod}) the answer is clear:




\begin{minted}{jlcon}
julia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Hour(2))
2016-07-17T08:00:00

julia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Minute(2))
2016-07-17T08:56:00
\end{minted}



This seems obvious, because two of each of these periods still divides evenly into the next larger order period. But in the case of two months (which still divides evenly into one year), the answer may be surprising:




\begin{minted}{jlcon}
julia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Month(2))
2016-07-01T00:00:00
\end{minted}



Why round to the first day in July, even though it is month 7 (an odd number)? The key is that months are 1-indexed (the first month is assigned 1), unlike hours, minutes, seconds, and milliseconds (the first of which are assigned 0).



This means that rounding a \hyperlink{17572689933274889838}{\texttt{DateTime}} to an even multiple of seconds, minutes, hours, or years (because the ISO 8601 specification includes a year zero) will result in a \hyperlink{17572689933274889838}{\texttt{DateTime}} with an even value in that field, while rounding a \hyperlink{17572689933274889838}{\texttt{DateTime}} to an even multiple of months will result in the months field having an odd value. Because both months and years may contain an irregular number of days, whether rounding to an even number of days will result in an even value in the days field is uncertain.



See the \hyperlink{2504340439131318713}{API reference} for additional information on methods exported from the \texttt{Dates} module.



\hypertarget{14493106802066079367}{}


\chapter{API reference}



\hypertarget{16585603824908593588}{}


\section{日期和时间类型}


\hypertarget{17624028548543163266}{} 
\hyperlink{17624028548543163266}{\texttt{Dates.Period}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Period
Year
Month
Week
Day
Hour
Minute
Second
Millisecond
Microsecond
Nanosecond
\end{minted}

\texttt{Period} types represent discrete, human representations of time.



\end{adjustwidth}
\hypertarget{10034674628199158268}{} 
\hyperlink{10034674628199158268}{\texttt{Dates.CompoundPeriod}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
CompoundPeriod
\end{minted}

A \texttt{CompoundPeriod} is useful for expressing time periods that are not a fixed multiple of smaller periods. For example, {\textquotedbl}a year and a  day{\textquotedbl} is not a fixed number of days, but can be expressed using a \texttt{CompoundPeriod}. In fact, a \texttt{CompoundPeriod} is automatically generated by addition of different period types, e.g. \texttt{Year(1) + Day(1)} produces a \texttt{CompoundPeriod} result.



\end{adjustwidth}
\hypertarget{4529923194910083363}{} 
\hyperlink{4529923194910083363}{\texttt{Dates.Instant}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Instant
\end{minted}

\texttt{Instant} types represent integer-based, machine representations of time as continuous timelines starting from an epoch.



\end{adjustwidth}
\hypertarget{5087474460137130402}{} 
\hyperlink{5087474460137130402}{\texttt{Dates.UTInstant}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UTInstant{T}
\end{minted}

The \texttt{UTInstant} represents a machine timeline based on UT time (1 day = one revolution of the earth). The \texttt{T} is a \texttt{Period} parameter that indicates the resolution or precision of the instant.



\end{adjustwidth}
\hypertarget{4438614350756187528}{} 
\hyperlink{4438614350756187528}{\texttt{Dates.TimeType}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
TimeType
\end{minted}

\texttt{TimeType} types wrap \texttt{Instant} machine instances to provide human representations of the machine instant. \texttt{Time}, \texttt{DateTime} and \texttt{Date} are subtypes of \texttt{TimeType}.



\end{adjustwidth}
\hypertarget{17572689933274889838}{} 
\hyperlink{17572689933274889838}{\texttt{Dates.DateTime}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DateTime
\end{minted}

\texttt{DateTime} wraps a \texttt{UTInstant\{Millisecond\}} and interprets it according to the proleptic Gregorian calendar.



\end{adjustwidth}
\hypertarget{4488183467971164548}{} 
\hyperlink{4488183467971164548}{\texttt{Dates.Date}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Date
\end{minted}

\texttt{Date} wraps a \texttt{UTInstant\{Day\}} and interprets it according to the proleptic Gregorian calendar.



\end{adjustwidth}
\hypertarget{8861990744010508981}{} 
\hyperlink{8861990744010508981}{\texttt{Dates.Time}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Time
\end{minted}

\texttt{Time} wraps a \texttt{Nanosecond} and represents a specific moment in a 24-hour day.



\end{adjustwidth}

\hypertarget{9236894787070694841}{}


\section{日期函数}


\hypertarget{1328456258006961178}{} 
\hyperlink{1328456258006961178}{\texttt{Dates.DateTime}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DateTime(y, [m, d, h, mi, s, ms]) -> DateTime
\end{minted}

Construct a \texttt{DateTime} type by parts. Arguments must be convertible to \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{8234829693150521940}{} 
\hyperlink{8234829693150521940}{\texttt{Dates.DateTime}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DateTime(periods::Period...) -> DateTime
\end{minted}

Construct a \texttt{DateTime} type by \texttt{Period} type parts. Arguments may be in any order. DateTime parts not provided will default to the value of \texttt{Dates.default(period)}.



\end{adjustwidth}
\hypertarget{18390475731552157559}{} 
\hyperlink{18390475731552157559}{\texttt{Dates.DateTime}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DateTime(f::Function, y[, m, d, h, mi, s]; step=Day(1), limit=10000) -> DateTime
\end{minted}

Create a \texttt{DateTime} through the adjuster API. The starting point will be constructed from the provided \texttt{y, m, d...} arguments, and will be adjusted until \texttt{f::Function} returns \texttt{true}. The step size in adjusting can be provided manually through the \texttt{step} keyword. \texttt{limit} provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (in the case that \texttt{f::Function} is never satisfied).

\textbf{Examples}


\begin{minted}{jlcon}
julia> DateTime(dt -> Dates.second(dt) == 40, 2010, 10, 20, 10; step = Dates.Second(1))
2010-10-20T10:00:40

julia> DateTime(dt -> Dates.hour(dt) == 20, 2010, 10, 20, 10; step = Dates.Hour(1), limit = 5)
ERROR: ArgumentError: Adjustment limit reached: 5 iterations
Stacktrace:
[...]
\end{minted}



\end{adjustwidth}
\hypertarget{12066645755218970960}{} 
\hyperlink{12066645755218970960}{\texttt{Dates.DateTime}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DateTime(dt::Date) -> DateTime
\end{minted}

Convert a \texttt{Date} to a \texttt{DateTime}. The hour, minute, second, and millisecond parts of the new \texttt{DateTime} are assumed to be zero.



\end{adjustwidth}
\hypertarget{17944514963000811562}{} 
\hyperlink{17944514963000811562}{\texttt{Dates.DateTime}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DateTime(dt::AbstractString, format::AbstractString; locale="english") -> DateTime
\end{minted}

Construct a \texttt{DateTime} by parsing the \texttt{dt} date time string following the pattern given in the \texttt{format} string.

This method creates a \texttt{DateFormat} object each time it is called. If you are parsing many date time strings of the same format, consider creating a \hyperlink{18093459443158853001}{\texttt{DateFormat}} object once and using that as the second argument instead.



\end{adjustwidth}
\hypertarget{16940765638871841169}{} 
\hyperlink{16940765638871841169}{\texttt{Dates.format}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
format(dt::TimeType, format::AbstractString; locale="english") -> AbstractString
\end{minted}

Construct a string by using a \texttt{TimeType} object and applying the provided \texttt{format}. The following character codes can be used to construct the \texttt{format} string:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Code & Examples & Comment \\
\hline
\texttt{y} & 6 & Numeric year with a fixed width \\
\hline
\texttt{Y} & 1996 & Numeric year with a minimum width \\
\hline
\texttt{m} & 1, 12 & Numeric month with a minimum width \\
\hline
\texttt{u} & Jan & Month name shortened to 3-chars according to the \texttt{locale} \\
\hline
\texttt{U} & January & Full month name according to the \texttt{locale} keyword \\
\hline
\texttt{d} & 1, 31 & Day of the month with a minimum width \\
\hline
\texttt{H} & 0, 23 & Hour (24-hour clock) with a minimum width \\
\hline
\texttt{M} & 0, 59 & Minute with a minimum width \\
\hline
\texttt{S} & 0, 59 & Second with a minimum width \\
\hline
\texttt{s} & 000, 500 & Millisecond with a minimum width of 3 \\
\hline
\texttt{e} & Mon, Tue & Abbreviated days of the week \\
\hline
\texttt{E} & Monday & Full day of week name \\
\hline
\end{tabulary}

\end{table}

The number of sequential code characters indicate the width of the code. A format of \texttt{yyyy-mm} specifies that the code \texttt{y} should have a width of four while \texttt{m} a width of two. Codes that yield numeric digits have an associated mode: fixed-width or minimum-width. The fixed-width mode left-pads the value with zeros when it is shorter than the specified width and truncates the value when longer. Minimum-width mode works the same as fixed-width except that it does not truncate values longer than the width.

When creating a \texttt{format} you can use any non-code characters as a separator. For example to generate the string {\textquotedbl}1996-01-15T00:00:00{\textquotedbl} you could use \texttt{format}: {\textquotedbl}yyyy-mm-ddTHH:MM:SS{\textquotedbl}. Note that if you need to use a code character as a literal you can use the escape character backslash. The string {\textquotedbl}1996y01m{\textquotedbl} can be produced with the format {\textquotedbl}yyyy{\textbackslash}ymm{\textbackslash}m{\textquotedbl}.



\end{adjustwidth}
\hypertarget{18093459443158853001}{} 
\hyperlink{18093459443158853001}{\texttt{Dates.DateFormat}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DateFormat(format::AbstractString, locale="english") -> DateFormat
\end{minted}

Construct a date formatting object that can be used for parsing date strings or formatting a date object as a string. The following character codes can be used to construct the \texttt{format} string:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Code & Matches & Comment \\
\hline
\texttt{y} & 1996, 96 & Returns year of 1996, 0096 \\
\hline
\texttt{Y} & 1996, 96 & Returns year of 1996, 0096. Equivalent to \texttt{y} \\
\hline
\texttt{m} & 1, 01 & Matches 1 or 2-digit months \\
\hline
\texttt{u} & Jan & Matches abbreviated months according to the \texttt{locale} keyword \\
\hline
\texttt{U} & January & Matches full month names according to the \texttt{locale} keyword \\
\hline
\texttt{d} & 1, 01 & Matches 1 or 2-digit days \\
\hline
\texttt{H} & 00 & Matches hours (24-hour clock) \\
\hline
\texttt{I} & 00 & For outputting hours with 12-hour clock \\
\hline
\texttt{M} & 00 & Matches minutes \\
\hline
\texttt{S} & 00 & Matches seconds \\
\hline
\texttt{s} & .500 & Matches milliseconds \\
\hline
\texttt{e} & Mon, Tues & Matches abbreviated days of the week \\
\hline
\texttt{E} & Monday & Matches full name days of the week \\
\hline
\texttt{p} & AM & Matches AM/PM (case-insensitive) \\
\hline
\texttt{yyyymmdd} & 19960101 & Matches fixed-width year, month, and day \\
\hline
\end{tabulary}

\end{table}

Characters not listed above are normally treated as delimiters between date and time slots. For example a \texttt{dt} string of {\textquotedbl}1996-01-15T00:00:00.0{\textquotedbl} would have a \texttt{format} string like {\textquotedbl}y-m-dTH:M:S.s{\textquotedbl}. If you need to use a code character as a delimiter you can escape it using backslash. The date {\textquotedbl}1995y01m{\textquotedbl} would have the format {\textquotedbl}y{\textbackslash}ym{\textbackslash}m{\textquotedbl}.

Note that 12:00AM corresponds 00:00 (midnight), and 12:00PM corresponds to 12:00 (noon). When parsing a time with a \texttt{p} specifier, any hour (either \texttt{H} or \texttt{I}) is interpreted as as a 12-hour clock, so the \texttt{I} code is mainly useful for output.

Creating a DateFormat object is expensive. Whenever possible, create it once and use it many times or try the \texttt{dateformat{\textquotedbl}{\textquotedbl}} string macro. Using this macro creates the DateFormat object once at macro expansion time and reuses it later. see \hyperlink{10511139750795822255}{\texttt{@dateformat\_str}}.

See \hyperlink{17572689933274889838}{\texttt{DateTime}} and \hyperlink{16940765638871841169}{\texttt{format}} for how to use a DateFormat object to parse and write Date strings respectively.



\end{adjustwidth}
\hypertarget{10511139750795822255}{} 
\hyperlink{10511139750795822255}{\texttt{Dates.@dateformat\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dateformat"Y-m-d H:M:S"
\end{minted}

Create a \hyperlink{18093459443158853001}{\texttt{DateFormat}} object. Similar to \texttt{DateFormat({\textquotedbl}Y-m-d H:M:S{\textquotedbl})} but creates the DateFormat object once during macro expansion.

See \hyperlink{18093459443158853001}{\texttt{DateFormat}} for details about format specifiers.



\end{adjustwidth}
\hypertarget{3209456936474118206}{} 
\hyperlink{3209456936474118206}{\texttt{Dates.DateTime}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DateTime(dt::AbstractString, df::DateFormat) -> DateTime
\end{minted}

Construct a \texttt{DateTime} by parsing the \texttt{dt} date time string following the pattern given in the \hyperlink{18093459443158853001}{\texttt{DateFormat}} object. Similar to \texttt{DateTime(::AbstractString, ::AbstractString)} but more efficient when repeatedly parsing similarly formatted date time strings with a pre-created \texttt{DateFormat} object.



\end{adjustwidth}
\hypertarget{3763584541689775694}{} 
\hyperlink{3763584541689775694}{\texttt{Dates.Date}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Date(y, [m, d]) -> Date
\end{minted}

Construct a \texttt{Date} type by parts. Arguments must be convertible to \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{13807007941640052204}{} 
\hyperlink{13807007941640052204}{\texttt{Dates.Date}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Date(period::Period...) -> Date
\end{minted}

Construct a \texttt{Date} type by \texttt{Period} type parts. Arguments may be in any order. \texttt{Date} parts not provided will default to the value of \texttt{Dates.default(period)}.



\end{adjustwidth}
\hypertarget{14780297511642453784}{} 
\hyperlink{14780297511642453784}{\texttt{Dates.Date}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Date(f::Function, y[, m, d]; step=Day(1), limit=10000) -> Date
\end{minted}

Create a \texttt{Date} through the adjuster API. The starting point will be constructed from the provided \texttt{y, m, d} arguments, and will be adjusted until \texttt{f::Function} returns \texttt{true}. The step size in adjusting can be provided manually through the \texttt{step} keyword. \texttt{limit} provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (given that \texttt{f::Function} is never satisfied).

\textbf{Examples}


\begin{minted}{jlcon}
julia> Date(date -> Dates.week(date) == 20, 2010, 01, 01)
2010-05-17

julia> Date(date -> Dates.year(date) == 2010, 2000, 01, 01)
2010-01-01

julia> Date(date -> Dates.month(date) == 10, 2000, 01, 01; limit = 5)
ERROR: ArgumentError: Adjustment limit reached: 5 iterations
Stacktrace:
[...]
\end{minted}



\end{adjustwidth}
\hypertarget{2036888574814255715}{} 
\hyperlink{2036888574814255715}{\texttt{Dates.Date}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Date(dt::DateTime) -> Date
\end{minted}

Convert a \texttt{DateTime} to a \texttt{Date}. The hour, minute, second, and millisecond parts of the \texttt{DateTime} are truncated, so only the year, month and day parts are used in construction.



\end{adjustwidth}
\hypertarget{8343259543700535183}{} 
\hyperlink{8343259543700535183}{\texttt{Dates.Date}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Date(d::AbstractString, format::AbstractString; locale="english") -> Date
\end{minted}

Construct a \texttt{Date} by parsing the \texttt{d} date string following the pattern given in the \texttt{format} string.

This method creates a \texttt{DateFormat} object each time it is called. If you are parsing many date strings of the same format, consider creating a \hyperlink{18093459443158853001}{\texttt{DateFormat}} object once and using that as the second argument instead.



\end{adjustwidth}
\hypertarget{10945442581319807702}{} 
\hyperlink{10945442581319807702}{\texttt{Dates.Date}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Date(d::AbstractString, df::DateFormat) -> Date
\end{minted}

Parse a date from a date string \texttt{d} using a \texttt{DateFormat} object \texttt{df}.



\end{adjustwidth}
\hypertarget{12389382980626687194}{} 
\hyperlink{12389382980626687194}{\texttt{Dates.Time}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Time(h, [mi, s, ms, us, ns]) -> Time
\end{minted}

Construct a \texttt{Time} type by parts. Arguments must be convertible to \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{2540456868150513770}{} 
\hyperlink{2540456868150513770}{\texttt{Dates.Time}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Time(period::TimePeriod...) -> Time
\end{minted}

Construct a \texttt{Time} type by \texttt{Period} type parts. Arguments may be in any order. \texttt{Time} parts not provided will default to the value of \texttt{Dates.default(period)}.



\end{adjustwidth}
\hypertarget{10615626888769753904}{} 
\hyperlink{10615626888769753904}{\texttt{Dates.Time}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Time(f::Function, h, mi=0; step::Period=Second(1), limit::Int=10000)
Time(f::Function, h, mi, s; step::Period=Millisecond(1), limit::Int=10000)
Time(f::Function, h, mi, s, ms; step::Period=Microsecond(1), limit::Int=10000)
Time(f::Function, h, mi, s, ms, us; step::Period=Nanosecond(1), limit::Int=10000)
\end{minted}

Create a \texttt{Time} through the adjuster API. The starting point will be constructed from the provided \texttt{h, mi, s, ms, us} arguments, and will be adjusted until \texttt{f::Function} returns \texttt{true}. The step size in adjusting can be provided manually through the \texttt{step} keyword. \texttt{limit} provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (in the case that \texttt{f::Function} is never satisfied). Note that the default step will adjust to allow for greater precision for the given arguments; i.e. if hour, minute, and second arguments are provided, the default step will be \texttt{Millisecond(1)} instead of \texttt{Second(1)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.Time(t -> Dates.minute(t) == 30, 20)
20:30:00

julia> Dates.Time(t -> Dates.minute(t) == 0, 20)
20:00:00

julia> Dates.Time(t -> Dates.hour(t) == 10, 3; limit = 5)
ERROR: ArgumentError: Adjustment limit reached: 5 iterations
Stacktrace:
[...]
\end{minted}



\end{adjustwidth}
\hypertarget{12276226804029079320}{} 
\hyperlink{12276226804029079320}{\texttt{Dates.Time}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Time(dt::DateTime) -> Time
\end{minted}

Convert a \texttt{DateTime} to a \texttt{Time}. The hour, minute, second, and millisecond parts of the \texttt{DateTime} are used to create the new \texttt{Time}. Microsecond and nanoseconds are zero by default.



\end{adjustwidth}
\hypertarget{18169882256128304087}{} 
\hyperlink{18169882256128304087}{\texttt{Dates.now}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
now() -> DateTime
\end{minted}

Return a \texttt{DateTime} corresponding to the user{\textquotesingle}s system time including the system timezone locale.



\end{adjustwidth}
\hypertarget{14867142023322691223}{} 
\hyperlink{14867142023322691223}{\texttt{Dates.now}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
now(::Type{UTC}) -> DateTime
\end{minted}

Return a \texttt{DateTime} corresponding to the user{\textquotesingle}s system time as UTC/GMT.



\end{adjustwidth}
\hypertarget{4594213520310841636}{} 
\hyperlink{4594213520310841636}{\texttt{Base.eps}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eps(::DateTime) -> Millisecond
eps(::Date) -> Day
eps(::Time) -> Nanosecond
\end{minted}

Returns \texttt{Millisecond(1)} for \texttt{DateTime} values, \texttt{Day(1)} for \texttt{Date} values, and \texttt{Nanosecond(1)} for \texttt{Time} values.



\end{adjustwidth}

\hypertarget{15274886386548419130}{}


\subsection{Accessor Functions}


\hypertarget{9714527822092754339}{} 
\hyperlink{9714527822092754339}{\texttt{Dates.year}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
year(dt::TimeType) -> Int64
\end{minted}

The year of a \texttt{Date} or \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{3646624885120036576}{} 
\hyperlink{3646624885120036576}{\texttt{Dates.month}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
month(dt::TimeType) -> Int64
\end{minted}

The month of a \texttt{Date} or \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{15002548627104558576}{} 
\hyperlink{15002548627104558576}{\texttt{Dates.week}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
week(dt::TimeType) -> Int64
\end{minted}

Return the \href{https://en.wikipedia.org/wiki/ISO\_week\_date}{ISO week date} of a \texttt{Date} or \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}. Note that the first week of a year is the week that contains the first Thursday of the year, which can result in dates prior to January 4th being in the last week of the previous year. For example, \texttt{week(Date(2005, 1, 1))} is the 53rd week of 2004.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.week(Date(1989, 6, 22))
25

julia> Dates.week(Date(2005, 1, 1))
53

julia> Dates.week(Date(2004, 12, 31))
53
\end{minted}



\end{adjustwidth}
\hypertarget{15216601024330128019}{} 
\hyperlink{15216601024330128019}{\texttt{Dates.day}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
day(dt::TimeType) -> Int64
\end{minted}

The day of month of a \texttt{Date} or \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{14478105094783051644}{} 
\hyperlink{14478105094783051644}{\texttt{Dates.hour}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hour(dt::DateTime) -> Int64
\end{minted}

The hour of day of a \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.




\begin{lstlisting}
hour(t::Time) -> Int64
\end{lstlisting}

The hour of a \texttt{Time} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{1962337999361765726}{} 
\hyperlink{1962337999361765726}{\texttt{Dates.minute}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
minute(dt::DateTime) -> Int64
\end{minted}

The minute of a \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.




\begin{lstlisting}
minute(t::Time) -> Int64
\end{lstlisting}

The minute of a \texttt{Time} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{15148061267327101157}{} 
\hyperlink{15148061267327101157}{\texttt{Dates.second}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
second(dt::DateTime) -> Int64
\end{minted}

The second of a \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.




\begin{lstlisting}
second(t::Time) -> Int64
\end{lstlisting}

The second of a \texttt{Time} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{4812831413693375163}{} 
\hyperlink{4812831413693375163}{\texttt{Dates.millisecond}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
millisecond(dt::DateTime) -> Int64
\end{minted}

The millisecond of a \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.




\begin{lstlisting}
millisecond(t::Time) -> Int64
\end{lstlisting}

The millisecond of a \texttt{Time} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{13472031808151614256}{} 
\hyperlink{13472031808151614256}{\texttt{Dates.microsecond}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
microsecond(t::Time) -> Int64
\end{minted}

The microsecond of a \texttt{Time} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{5077020706593048697}{} 
\hyperlink{5077020706593048697}{\texttt{Dates.nanosecond}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nanosecond(t::Time) -> Int64
\end{minted}

The nanosecond of a \texttt{Time} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{16556427820393178039}{} 
\hyperlink{16556427820393178039}{\texttt{Dates.Year}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Year(v)
\end{minted}

Construct a \texttt{Year} object with the given \texttt{v} value. Input must be losslessly convertible to an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{2872605566119772618}{} 
\hyperlink{2872605566119772618}{\texttt{Dates.Month}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Month(v)
\end{minted}

Construct a \texttt{Month} object with the given \texttt{v} value. Input must be losslessly convertible to an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{9656974277347347506}{} 
\hyperlink{9656974277347347506}{\texttt{Dates.Week}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Week(v)
\end{minted}

Construct a \texttt{Week} object with the given \texttt{v} value. Input must be losslessly convertible to an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{13217464551942182596}{} 
\hyperlink{13217464551942182596}{\texttt{Dates.Day}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Day(v)
\end{minted}

Construct a \texttt{Day} object with the given \texttt{v} value. Input must be losslessly convertible to an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{11671105558328225558}{} 
\hyperlink{11671105558328225558}{\texttt{Dates.Hour}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Hour(dt::DateTime) -> Hour
\end{minted}

The hour part of a DateTime as a \texttt{Hour}.



\end{adjustwidth}
\hypertarget{15437593953944371601}{} 
\hyperlink{15437593953944371601}{\texttt{Dates.Minute}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Minute(dt::DateTime) -> Minute
\end{minted}

The minute part of a DateTime as a \texttt{Minute}.



\end{adjustwidth}
\hypertarget{544402402471521748}{} 
\hyperlink{544402402471521748}{\texttt{Dates.Second}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Second(dt::DateTime) -> Second
\end{minted}

The second part of a DateTime as a \texttt{Second}.



\end{adjustwidth}
\hypertarget{9366634148855607364}{} 
\hyperlink{9366634148855607364}{\texttt{Dates.Millisecond}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Millisecond(dt::DateTime) -> Millisecond
\end{minted}

The millisecond part of a DateTime as a \texttt{Millisecond}.



\end{adjustwidth}
\hypertarget{4155472013117853166}{} 
\hyperlink{4155472013117853166}{\texttt{Dates.Microsecond}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Microsecond(dt::Time) -> Microsecond
\end{minted}

The microsecond part of a Time as a \texttt{Microsecond}.



\end{adjustwidth}
\hypertarget{14345635682555926790}{} 
\hyperlink{14345635682555926790}{\texttt{Dates.Nanosecond}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Nanosecond(dt::Time) -> Nanosecond
\end{minted}

The nanosecond part of a Time as a \texttt{Nanosecond}.



\end{adjustwidth}
\hypertarget{1408650772715600889}{} 
\hyperlink{1408650772715600889}{\texttt{Dates.yearmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
yearmonth(dt::TimeType) -> (Int64, Int64)
\end{minted}

Simultaneously return the year and month parts of a \texttt{Date} or \texttt{DateTime}.



\end{adjustwidth}
\hypertarget{17847736901982891967}{} 
\hyperlink{17847736901982891967}{\texttt{Dates.monthday}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
monthday(dt::TimeType) -> (Int64, Int64)
\end{minted}

Simultaneously return the month and day parts of a \texttt{Date} or \texttt{DateTime}.



\end{adjustwidth}
\hypertarget{18225305010779633841}{} 
\hyperlink{18225305010779633841}{\texttt{Dates.yearmonthday}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
yearmonthday(dt::TimeType) -> (Int64, Int64, Int64)
\end{minted}

Simultaneously return the year, month and day parts of a \texttt{Date} or \texttt{DateTime}.



\end{adjustwidth}

\hypertarget{16158364891045757229}{}


\subsection{Query Functions}


\hypertarget{2440842966718954493}{} 
\hyperlink{2440842966718954493}{\texttt{Dates.dayname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dayname(dt::TimeType; locale="english") -> String
dayname(day::Integer; locale="english") -> String
\end{minted}

Return the full day name corresponding to the day of the week of the \texttt{Date} or \texttt{DateTime} in the given \texttt{locale}. Also accepts \texttt{Integer}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.dayname(Date("2000-01-01"))
"Saturday"

julia> Dates.dayname(4)
"Thursday"
\end{minted}



\end{adjustwidth}
\hypertarget{18198970391837299875}{} 
\hyperlink{18198970391837299875}{\texttt{Dates.dayabbr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dayabbr(dt::TimeType; locale="english") -> String
dayabbr(day::Integer; locale="english") -> String
\end{minted}

Return the abbreviated name corresponding to the day of the week of the \texttt{Date} or \texttt{DateTime} in the given \texttt{locale}. Also accepts \texttt{Integer}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.dayabbr(Date("2000-01-01"))
"Sat"

julia> Dates.dayabbr(3)
"Wed"
\end{minted}



\end{adjustwidth}
\hypertarget{12798531608759474645}{} 
\hyperlink{12798531608759474645}{\texttt{Dates.dayofweek}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dayofweek(dt::TimeType) -> Int64
\end{minted}

Return the day of the week as an \hyperlink{7720564657383125058}{\texttt{Int64}} with \texttt{1 = Monday, 2 = Tuesday, etc.}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.dayofweek(Date("2000-01-01"))
6
\end{minted}



\end{adjustwidth}
\hypertarget{11391658730748043877}{} 
\hyperlink{11391658730748043877}{\texttt{Dates.dayofmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dayofmonth(dt::TimeType) -> Int64
\end{minted}

The day of month of a \texttt{Date} or \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{3444497056704321071}{} 
\hyperlink{3444497056704321071}{\texttt{Dates.dayofweekofmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dayofweekofmonth(dt::TimeType) -> Int
\end{minted}

For the day of week of \texttt{dt}, return which number it is in \texttt{dt}{\textquotesingle}s month. So if the day of the week of \texttt{dt} is Monday, then \texttt{1 = First Monday of the month, 2 = Second Monday of the month, etc.} In the range 1:5.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.dayofweekofmonth(Date("2000-02-01"))
1

julia> Dates.dayofweekofmonth(Date("2000-02-08"))
2

julia> Dates.dayofweekofmonth(Date("2000-02-15"))
3
\end{minted}



\end{adjustwidth}
\hypertarget{3276636057341185884}{} 
\hyperlink{3276636057341185884}{\texttt{Dates.daysofweekinmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
daysofweekinmonth(dt::TimeType) -> Int
\end{minted}

For the day of week of \texttt{dt}, return the total number of that day of the week in \texttt{dt}{\textquotesingle}s month. Returns 4 or 5. Useful in temporal expressions for specifying the last day of a week in a month by including \texttt{dayofweekofmonth(dt) == daysofweekinmonth(dt)} in the adjuster function.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.daysofweekinmonth(Date("2005-01-01"))
5

julia> Dates.daysofweekinmonth(Date("2005-01-04"))
4
\end{minted}



\end{adjustwidth}
\hypertarget{16585759639636493546}{} 
\hyperlink{16585759639636493546}{\texttt{Dates.monthname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
monthname(dt::TimeType; locale="english") -> String
monthname(month::Integer, locale="english") -> String
\end{minted}

Return the full name of the month of the \texttt{Date} or \texttt{DateTime} or \texttt{Integer} in the given \texttt{locale}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.monthname(Date("2005-01-04"))
"January"

julia> Dates.monthname(2)
"February"
\end{minted}



\end{adjustwidth}
\hypertarget{12804940912944832895}{} 
\hyperlink{12804940912944832895}{\texttt{Dates.monthabbr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
monthabbr(dt::TimeType; locale="english") -> String
monthabbr(month::Integer, locale="english") -> String
\end{minted}

Return the abbreviated month name of the \texttt{Date} or \texttt{DateTime} or \texttt{Integer} in the given \texttt{locale}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.monthabbr(Date("2005-01-04"))
"Jan"

julia> monthabbr(2)
"Feb"
\end{minted}



\end{adjustwidth}
\hypertarget{7867088328366678414}{} 
\hyperlink{7867088328366678414}{\texttt{Dates.daysinmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
daysinmonth(dt::TimeType) -> Int
\end{minted}

Return the number of days in the month of \texttt{dt}. Value will be 28, 29, 30, or 31.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.daysinmonth(Date("2000-01"))
31

julia> Dates.daysinmonth(Date("2001-02"))
28

julia> Dates.daysinmonth(Date("2000-02"))
29
\end{minted}



\end{adjustwidth}
\hypertarget{8386083064240039655}{} 
\hyperlink{8386083064240039655}{\texttt{Dates.isleapyear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isleapyear(dt::TimeType) -> Bool
\end{minted}

Return \texttt{true} if the year of \texttt{dt} is a leap year.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.isleapyear(Date("2004"))
true

julia> Dates.isleapyear(Date("2005"))
false
\end{minted}



\end{adjustwidth}
\hypertarget{4496651838489546625}{} 
\hyperlink{4496651838489546625}{\texttt{Dates.dayofyear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dayofyear(dt::TimeType) -> Int
\end{minted}

Return the day of the year for \texttt{dt} with January 1st being day 1.



\end{adjustwidth}
\hypertarget{11086128603918251845}{} 
\hyperlink{11086128603918251845}{\texttt{Dates.daysinyear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
daysinyear(dt::TimeType) -> Int
\end{minted}

Return 366 if the year of \texttt{dt} is a leap year, otherwise return 365.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.daysinyear(1999)
365

julia> Dates.daysinyear(2000)
366
\end{minted}



\end{adjustwidth}
\hypertarget{6690591772267933900}{} 
\hyperlink{6690591772267933900}{\texttt{Dates.quarterofyear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
quarterofyear(dt::TimeType) -> Int
\end{minted}

Return the quarter that \texttt{dt} resides in. Range of value is 1:4.



\end{adjustwidth}
\hypertarget{10496844318360486693}{} 
\hyperlink{10496844318360486693}{\texttt{Dates.dayofquarter}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dayofquarter(dt::TimeType) -> Int
\end{minted}

Return the day of the current quarter of \texttt{dt}. Range of value is 1:92.



\end{adjustwidth}

\hypertarget{13551592780469201884}{}


\subsection{Adjuster Functions}


\hypertarget{173413331178974124}{} 
\hyperlink{173413331178974124}{\texttt{Base.trunc}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trunc(dt::TimeType, ::Type{Period}) -> TimeType
\end{minted}

Truncates the value of \texttt{dt} according to the provided \texttt{Period} type.

\textbf{Examples}


\begin{minted}{jlcon}
julia> trunc(Dates.DateTime("1996-01-01T12:30:00"), Dates.Day)
1996-01-01T00:00:00
\end{minted}



\end{adjustwidth}
\hypertarget{725369720992290901}{} 
\hyperlink{725369720992290901}{\texttt{Dates.firstdayofweek}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
firstdayofweek(dt::TimeType) -> TimeType
\end{minted}

Adjusts \texttt{dt} to the Monday of its week.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.firstdayofweek(DateTime("1996-01-05T12:30:00"))
1996-01-01T00:00:00
\end{minted}



\end{adjustwidth}
\hypertarget{15555713849502356755}{} 
\hyperlink{15555713849502356755}{\texttt{Dates.lastdayofweek}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lastdayofweek(dt::TimeType) -> TimeType
\end{minted}

Adjusts \texttt{dt} to the Sunday of its week.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.lastdayofweek(DateTime("1996-01-05T12:30:00"))
1996-01-07T00:00:00
\end{minted}



\end{adjustwidth}
\hypertarget{944292496394173921}{} 
\hyperlink{944292496394173921}{\texttt{Dates.firstdayofmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
firstdayofmonth(dt::TimeType) -> TimeType
\end{minted}

Adjusts \texttt{dt} to the first day of its month.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.firstdayofmonth(DateTime("1996-05-20"))
1996-05-01T00:00:00
\end{minted}



\end{adjustwidth}
\hypertarget{14220689943148611628}{} 
\hyperlink{14220689943148611628}{\texttt{Dates.lastdayofmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lastdayofmonth(dt::TimeType) -> TimeType
\end{minted}

Adjusts \texttt{dt} to the last day of its month.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.lastdayofmonth(DateTime("1996-05-20"))
1996-05-31T00:00:00
\end{minted}



\end{adjustwidth}
\hypertarget{16489505143268736660}{} 
\hyperlink{16489505143268736660}{\texttt{Dates.firstdayofyear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
firstdayofyear(dt::TimeType) -> TimeType
\end{minted}

Adjusts \texttt{dt} to the first day of its year.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.firstdayofyear(DateTime("1996-05-20"))
1996-01-01T00:00:00
\end{minted}



\end{adjustwidth}
\hypertarget{10580858002556506121}{} 
\hyperlink{10580858002556506121}{\texttt{Dates.lastdayofyear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lastdayofyear(dt::TimeType) -> TimeType
\end{minted}

Adjusts \texttt{dt} to the last day of its year.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.lastdayofyear(DateTime("1996-05-20"))
1996-12-31T00:00:00
\end{minted}



\end{adjustwidth}
\hypertarget{16102783699720368943}{} 
\hyperlink{16102783699720368943}{\texttt{Dates.firstdayofquarter}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
firstdayofquarter(dt::TimeType) -> TimeType
\end{minted}

Adjusts \texttt{dt} to the first day of its quarter.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.firstdayofquarter(DateTime("1996-05-20"))
1996-04-01T00:00:00

julia> Dates.firstdayofquarter(DateTime("1996-08-20"))
1996-07-01T00:00:00
\end{minted}



\end{adjustwidth}
\hypertarget{90261086996796964}{} 
\hyperlink{90261086996796964}{\texttt{Dates.lastdayofquarter}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lastdayofquarter(dt::TimeType) -> TimeType
\end{minted}

Adjusts \texttt{dt} to the last day of its quarter.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.lastdayofquarter(DateTime("1996-05-20"))
1996-06-30T00:00:00

julia> Dates.lastdayofquarter(DateTime("1996-08-20"))
1996-09-30T00:00:00
\end{minted}



\end{adjustwidth}
\hypertarget{9410879287453023176}{} 
\hyperlink{9410879287453023176}{\texttt{Dates.tonext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tonext(dt::TimeType, dow::Int; same::Bool=false) -> TimeType
\end{minted}

Adjusts \texttt{dt} to the next day of week corresponding to \texttt{dow} with \texttt{1 = Monday, 2 = Tuesday, etc}. Setting \texttt{same=true} allows the current \texttt{dt} to be considered as the next \texttt{dow}, allowing for no adjustment to occur.



\end{adjustwidth}
\hypertarget{5295237512711135506}{} 
\hyperlink{5295237512711135506}{\texttt{Dates.toprev}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
toprev(dt::TimeType, dow::Int; same::Bool=false) -> TimeType
\end{minted}

Adjusts \texttt{dt} to the previous day of week corresponding to \texttt{dow} with \texttt{1 = Monday, 2 = Tuesday, etc}. Setting \texttt{same=true} allows the current \texttt{dt} to be considered as the previous \texttt{dow}, allowing for no adjustment to occur.



\end{adjustwidth}
\hypertarget{14392816409484181570}{} 
\hyperlink{14392816409484181570}{\texttt{Dates.tofirst}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tofirst(dt::TimeType, dow::Int; of=Month) -> TimeType
\end{minted}

Adjusts \texttt{dt} to the first \texttt{dow} of its month. Alternatively, \texttt{of=Year} will adjust to the first \texttt{dow} of the year.



\end{adjustwidth}
\hypertarget{18080067486232724602}{} 
\hyperlink{18080067486232724602}{\texttt{Dates.tolast}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tolast(dt::TimeType, dow::Int; of=Month) -> TimeType
\end{minted}

Adjusts \texttt{dt} to the last \texttt{dow} of its month. Alternatively, \texttt{of=Year} will adjust to the last \texttt{dow} of the year.



\end{adjustwidth}
\hypertarget{4241078503475048595}{} 
\hyperlink{4241078503475048595}{\texttt{Dates.tonext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tonext(func::Function, dt::TimeType; step=Day(1), limit=10000, same=false) -> TimeType
\end{minted}

Adjusts \texttt{dt} by iterating at most \texttt{limit} iterations by \texttt{step} increments until \texttt{func} returns \texttt{true}. \texttt{func} must take a single \texttt{TimeType} argument and return a \hyperlink{46725311238864537}{\texttt{Bool}}. \texttt{same} allows \texttt{dt} to be considered in satisfying \texttt{func}.



\end{adjustwidth}
\hypertarget{7889720794479911439}{} 
\hyperlink{7889720794479911439}{\texttt{Dates.toprev}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
toprev(func::Function, dt::TimeType; step=Day(-1), limit=10000, same=false) -> TimeType
\end{minted}

Adjusts \texttt{dt} by iterating at most \texttt{limit} iterations by \texttt{step} increments until \texttt{func} returns \texttt{true}. \texttt{func} must take a single \texttt{TimeType} argument and return a \hyperlink{46725311238864537}{\texttt{Bool}}. \texttt{same} allows \texttt{dt} to be considered in satisfying \texttt{func}.



\end{adjustwidth}

\hypertarget{5161625535326415321}{}


\subsection{Periods}


\hypertarget{5339072836021258931}{} 
\hyperlink{5339072836021258931}{\texttt{Dates.Period}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Year(v)
Month(v)
Week(v)
Day(v)
Hour(v)
Minute(v)
Second(v)
Millisecond(v)
Microsecond(v)
Nanosecond(v)
\end{minted}

Construct a \texttt{Period} type with the given \texttt{v} value. Input must be losslessly convertible to an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{11754777390580731638}{} 
\hyperlink{11754777390580731638}{\texttt{Dates.CompoundPeriod}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
CompoundPeriod(periods) -> CompoundPeriod
\end{minted}

Construct a \texttt{CompoundPeriod} from a \texttt{Vector} of \texttt{Period}s. All \texttt{Period}s of the same type will be added together.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.CompoundPeriod(Dates.Hour(12), Dates.Hour(13))
25 hours

julia> Dates.CompoundPeriod(Dates.Hour(-1), Dates.Minute(1))
-1 hour, 1 minute

julia> Dates.CompoundPeriod(Dates.Month(1), Dates.Week(-2))
1 month, -2 weeks

julia> Dates.CompoundPeriod(Dates.Minute(50000))
50000 minutes
\end{minted}



\end{adjustwidth}
\hypertarget{6471383377711200525}{} 
\hyperlink{6471383377711200525}{\texttt{Dates.value}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Dates.value(x::Period) -> Int64
\end{minted}

For a given period, return the value associated with that period.  For example, \texttt{value(Millisecond(10))} returns 10 as an integer.



\end{adjustwidth}
\hypertarget{9890661094020401012}{} 
\hyperlink{9890661094020401012}{\texttt{Dates.default}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
default(p::Period) -> Period
\end{minted}

Returns a sensible {\textquotedbl}default{\textquotedbl} value for the input Period by returning \texttt{T(1)} for Year, Month, and Day, and \texttt{T(0)} for Hour, Minute, Second, and Millisecond.



\end{adjustwidth}

\hypertarget{13058474467070921522}{}


\subsection{取整函数}



\texttt{Date} and \texttt{DateTime} values can be rounded to a specified resolution (e.g., 1 month or 15 minutes) with \texttt{floor}, \texttt{ceil}, or \texttt{round}.


\hypertarget{6962549236860281908}{} 
\hyperlink{6962549236860281908}{\texttt{Base.floor}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
floor(dt::TimeType, p::Period) -> TimeType
\end{minted}

Return the nearest \texttt{Date} or \texttt{DateTime} less than or equal to \texttt{dt} at resolution \texttt{p}.

For convenience, \texttt{p} may be a type instead of a value: \texttt{floor(dt, Dates.Hour)} is a shortcut for \texttt{floor(dt, Dates.Hour(1))}.


\begin{minted}{jlcon}
julia> floor(Date(1985, 8, 16), Dates.Month)
1985-08-01

julia> floor(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))
2013-02-13T00:30:00

julia> floor(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)
2016-08-06T00:00:00
\end{minted}



\end{adjustwidth}
\hypertarget{13217485408632363978}{} 
\hyperlink{13217485408632363978}{\texttt{Base.ceil}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ceil(dt::TimeType, p::Period) -> TimeType
\end{minted}

Return the nearest \texttt{Date} or \texttt{DateTime} greater than or equal to \texttt{dt} at resolution \texttt{p}.

For convenience, \texttt{p} may be a type instead of a value: \texttt{ceil(dt, Dates.Hour)} is a shortcut for \texttt{ceil(dt, Dates.Hour(1))}.


\begin{minted}{jlcon}
julia> ceil(Date(1985, 8, 16), Dates.Month)
1985-09-01

julia> ceil(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))
2013-02-13T00:45:00

julia> ceil(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)
2016-08-07T00:00:00
\end{minted}



\end{adjustwidth}
\hypertarget{11570783396170921526}{} 
\hyperlink{11570783396170921526}{\texttt{Base.round}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
round(dt::TimeType, p::Period, [r::RoundingMode]) -> TimeType
\end{minted}

Return the \texttt{Date} or \texttt{DateTime} nearest to \texttt{dt} at resolution \texttt{p}. By default (\texttt{RoundNearestTiesUp}), ties (e.g., rounding 9:30 to the nearest hour) will be rounded up.

For convenience, \texttt{p} may be a type instead of a value: \texttt{round(dt, Dates.Hour)} is a shortcut for \texttt{round(dt, Dates.Hour(1))}.


\begin{minted}{jlcon}
julia> round(Date(1985, 8, 16), Dates.Month)
1985-08-01

julia> round(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))
2013-02-13T00:30:00

julia> round(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)
2016-08-07T00:00:00
\end{minted}

Valid rounding modes for \texttt{round(::TimeType, ::Period, ::RoundingMode)} are \texttt{RoundNearestTiesUp} (default), \texttt{RoundDown} (\texttt{floor}), and \texttt{RoundUp} (\texttt{ceil}).



\end{adjustwidth}

Most \texttt{Period} values can also be rounded to a specified resolution:


\hypertarget{3559289051512772121}{} 
\hyperlink{3559289051512772121}{\texttt{Base.floor}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
floor(x::Period, precision::T) where T <: Union{TimePeriod, Week, Day} -> T
\end{minted}

Round \texttt{x} down to the nearest multiple of \texttt{precision}. If \texttt{x} and \texttt{precision} are different subtypes of \texttt{Period}, the return value will have the same type as \texttt{precision}.

For convenience, \texttt{precision} may be a type instead of a value: \texttt{floor(x, Dates.Hour)} is a shortcut for \texttt{floor(x, Dates.Hour(1))}.


\begin{minted}{jlcon}
julia> floor(Dates.Day(16), Dates.Week)
2 weeks

julia> floor(Dates.Minute(44), Dates.Minute(15))
30 minutes

julia> floor(Dates.Hour(36), Dates.Day)
1 day
\end{minted}

Rounding to a \texttt{precision} of \texttt{Month}s or \texttt{Year}s is not supported, as these \texttt{Period}s are of inconsistent length.



\end{adjustwidth}
\hypertarget{6035166226319109738}{} 
\hyperlink{6035166226319109738}{\texttt{Base.ceil}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ceil(x::Period, precision::T) where T <: Union{TimePeriod, Week, Day} -> T
\end{minted}

Round \texttt{x} up to the nearest multiple of \texttt{precision}. If \texttt{x} and \texttt{precision} are different subtypes of \texttt{Period}, the return value will have the same type as \texttt{precision}.

For convenience, \texttt{precision} may be a type instead of a value: \texttt{ceil(x, Dates.Hour)} is a shortcut for \texttt{ceil(x, Dates.Hour(1))}.


\begin{minted}{jlcon}
julia> ceil(Dates.Day(16), Dates.Week)
3 weeks

julia> ceil(Dates.Minute(44), Dates.Minute(15))
45 minutes

julia> ceil(Dates.Hour(36), Dates.Day)
2 days
\end{minted}

Rounding to a \texttt{precision} of \texttt{Month}s or \texttt{Year}s is not supported, as these \texttt{Period}s are of inconsistent length.



\end{adjustwidth}
\hypertarget{15529975760511008617}{} 
\hyperlink{15529975760511008617}{\texttt{Base.round}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
round(x::Period, precision::T, [r::RoundingMode]) where T <: Union{TimePeriod, Week, Day} -> T
\end{minted}

Round \texttt{x} to the nearest multiple of \texttt{precision}. If \texttt{x} and \texttt{precision} are different subtypes of \texttt{Period}, the return value will have the same type as \texttt{precision}. By default (\texttt{RoundNearestTiesUp}), ties (e.g., rounding 90 minutes to the nearest hour) will be rounded up.

For convenience, \texttt{precision} may be a type instead of a value: \texttt{round(x, Dates.Hour)} is a shortcut for \texttt{round(x, Dates.Hour(1))}.


\begin{minted}{jlcon}
julia> round(Dates.Day(16), Dates.Week)
2 weeks

julia> round(Dates.Minute(44), Dates.Minute(15))
45 minutes

julia> round(Dates.Hour(36), Dates.Day)
2 days
\end{minted}

Valid rounding modes for \texttt{round(::Period, ::T, ::RoundingMode)} are \texttt{RoundNearestTiesUp} (default), \texttt{RoundDown} (\texttt{floor}), and \texttt{RoundUp} (\texttt{ceil}).

Rounding to a \texttt{precision} of \texttt{Month}s or \texttt{Year}s is not supported, as these \texttt{Period}s are of inconsistent length.



\end{adjustwidth}

The following functions are not exported:


\hypertarget{12245544538142909757}{} 
\hyperlink{12245544538142909757}{\texttt{Dates.floorceil}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
floorceil(dt::TimeType, p::Period) -> (TimeType, TimeType)
\end{minted}

Simultaneously return the \texttt{floor} and \texttt{ceil} of a \texttt{Date} or \texttt{DateTime} at resolution \texttt{p}. More efficient than calling both \texttt{floor} and \texttt{ceil} individually.




\begin{lstlisting}
floorceil(x::Period, precision::T) where T <: Union{TimePeriod, Week, Day} -> (T, T)
\end{lstlisting}

Simultaneously return the \texttt{floor} and \texttt{ceil} of \texttt{Period} at resolution \texttt{p}.  More efficient than calling both \texttt{floor} and \texttt{ceil} individually.



\end{adjustwidth}
\hypertarget{6172851707225539496}{} 
\hyperlink{6172851707225539496}{\texttt{Dates.epochdays2date}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
epochdays2date(days) -> Date
\end{minted}

Take the number of days since the rounding epoch (\texttt{0000-01-01T00:00:00}) and return the corresponding \texttt{Date}.



\end{adjustwidth}
\hypertarget{228819666916608027}{} 
\hyperlink{228819666916608027}{\texttt{Dates.epochms2datetime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
epochms2datetime(milliseconds) -> DateTime
\end{minted}

Take the number of milliseconds since the rounding epoch (\texttt{0000-01-01T00:00:00}) and return the corresponding \texttt{DateTime}.



\end{adjustwidth}
\hypertarget{4031977144092247953}{} 
\hyperlink{4031977144092247953}{\texttt{Dates.date2epochdays}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
date2epochdays(dt::Date) -> Int64
\end{minted}

Take the given \texttt{Date} and return the number of days since the rounding epoch (\texttt{0000-01-01T00:00:00}) as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}
\hypertarget{12248243003394996071}{} 
\hyperlink{12248243003394996071}{\texttt{Dates.datetime2epochms}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
datetime2epochms(dt::DateTime) -> Int64
\end{minted}

Take the given \texttt{DateTime} and return the number of milliseconds since the rounding epoch (\texttt{0000-01-01T00:00:00}) as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\end{adjustwidth}

\hypertarget{7595184717708184953}{}


\subsection{转换函数}


\hypertarget{14772120662961874184}{} 
\hyperlink{14772120662961874184}{\texttt{Dates.today}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
today() -> Date
\end{minted}

Return the date portion of \texttt{now()}.



\end{adjustwidth}
\hypertarget{1873675393210620747}{} 
\hyperlink{1873675393210620747}{\texttt{Dates.unix2datetime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unix2datetime(x) -> DateTime
\end{minted}

Take the number of seconds since unix epoch \texttt{1970-01-01T00:00:00} and convert to the corresponding \texttt{DateTime}.



\end{adjustwidth}
\hypertarget{4964397354460606136}{} 
\hyperlink{4964397354460606136}{\texttt{Dates.datetime2unix}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
datetime2unix(dt::DateTime) -> Float64
\end{minted}

Take the given \texttt{DateTime} and return the number of seconds since the unix epoch \texttt{1970-01-01T00:00:00} as a \hyperlink{5027751419500983000}{\texttt{Float64}}.



\end{adjustwidth}
\hypertarget{2031899596964007680}{} 
\hyperlink{2031899596964007680}{\texttt{Dates.julian2datetime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
julian2datetime(julian_days) -> DateTime
\end{minted}

Take the number of Julian calendar days since epoch \texttt{-4713-11-24T12:00:00} and return the corresponding \texttt{DateTime}.



\end{adjustwidth}
\hypertarget{11675145653043813028}{} 
\hyperlink{11675145653043813028}{\texttt{Dates.datetime2julian}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
datetime2julian(dt::DateTime) -> Float64
\end{minted}

Take the given \texttt{DateTime} and return the number of Julian calendar days since the julian epoch \texttt{-4713-11-24T12:00:00} as a \hyperlink{5027751419500983000}{\texttt{Float64}}.



\end{adjustwidth}
\hypertarget{13618878841813439465}{} 
\hyperlink{13618878841813439465}{\texttt{Dates.rata2datetime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rata2datetime(days) -> DateTime
\end{minted}

Take the number of Rata Die days since epoch \texttt{0000-12-31T00:00:00} and return the corresponding \texttt{DateTime}.



\end{adjustwidth}
\hypertarget{4095235562821247460}{} 
\hyperlink{4095235562821247460}{\texttt{Dates.datetime2rata}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
datetime2rata(dt::TimeType) -> Int64
\end{minted}

Return the number of Rata Die days since epoch from the given \texttt{Date} or \texttt{DateTime}.



\end{adjustwidth}

\hypertarget{5407065244463689569}{}


\subsection{常量}



Days of the Week:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Variable & Abbr. & Value (Int) \\
\hline
\texttt{Monday} & \texttt{Mon} & 1 \\
\hline
\texttt{Tuesday} & \texttt{Tue} & 2 \\
\hline
\texttt{Wednesday} & \texttt{Wed} & 3 \\
\hline
\texttt{Thursday} & \texttt{Thu} & 4 \\
\hline
\texttt{Friday} & \texttt{Fri} & 5 \\
\hline
\texttt{Saturday} & \texttt{Sat} & 6 \\
\hline
\texttt{Sunday} & \texttt{Sun} & 7 \\
\hline
\end{tabulary}

\end{table}



Months of the Year:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Variable & Abbr. & Value (Int) \\
\hline
\texttt{January} & \texttt{Jan} & 1 \\
\hline
\texttt{February} & \texttt{Feb} & 2 \\
\hline
\texttt{March} & \texttt{Mar} & 3 \\
\hline
\texttt{April} & \texttt{Apr} & 4 \\
\hline
\texttt{May} & \texttt{May} & 5 \\
\hline
\texttt{June} & \texttt{Jun} & 6 \\
\hline
\texttt{July} & \texttt{Jul} & 7 \\
\hline
\texttt{August} & \texttt{Aug} & 8 \\
\hline
\texttt{September} & \texttt{Sep} & 9 \\
\hline
\texttt{October} & \texttt{Oct} & 10 \\
\hline
\texttt{November} & \texttt{Nov} & 11 \\
\hline
\texttt{December} & \texttt{Dec} & 12 \\
\hline
\end{tabulary}

\end{table}





\hypertarget{8991044554794555328}{}


\chapter{分隔符文件}


\hypertarget{16037077475059757878}{} 
\hyperlink{16037077475059757878}{\texttt{DelimitedFiles.readdlm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readdlm(source, delim::AbstractChar, T::Type, eol::AbstractChar; header=false, skipstart=0, skipblanks=true, use_mmap, quotes=true, dims, comments=false, comment_char='#')
\end{minted}

Read a matrix from the source where each line (separated by \texttt{eol}) gives one row, with elements separated by the given delimiter. The source can be a text file, stream or byte array. Memory mapped files can be used by passing the byte array representation of the mapped segment as source.

If \texttt{T} is a numeric type, the result is an array of that type, with any non-numeric elements as \texttt{NaN} for floating-point types, or zero. Other useful values of \texttt{T} include \texttt{String}, \texttt{AbstractString}, and \texttt{Any}.

If \texttt{header} is \texttt{true}, the first row of data will be read as header and the tuple \texttt{(data\_cells, header\_cells)} is returned instead of only \texttt{data\_cells}.

Specifying \texttt{skipstart} will ignore the corresponding number of initial lines from the input.

If \texttt{skipblanks} is \texttt{true}, blank lines in the input will be ignored.

If \texttt{use\_mmap} is \texttt{true}, the file specified by \texttt{source} is memory mapped for potential speedups. Default is \texttt{true} except on Windows. On Windows, you may want to specify \texttt{true} if the file is large, and is only read once and not written to.

If \texttt{quotes} is \texttt{true}, columns enclosed within double-quote ({\textquotedbl}) characters are allowed to contain new lines and column delimiters. Double-quote characters within a quoted field must be escaped with another double-quote.  Specifying \texttt{dims} as a tuple of the expected rows and columns (including header, if any) may speed up reading of large files.  If \texttt{comments} is \texttt{true}, lines beginning with \texttt{comment\_char} and text following \texttt{comment\_char} in any line are ignored.

\textbf{Examples}


\begin{minted}{jlcon}
julia> using DelimitedFiles

julia> x = [1; 2; 3; 4];

julia> y = [5; 6; 7; 8];

julia> open("delim_file.txt", "w") do io
           writedlm(io, [x y])
       end

julia> readdlm("delim_file.txt", '\t', Int, '\n')
4×2 Array{Int64,2}:
 1  5
 2  6
 3  7
 4  8

julia> rm("delim_file.txt")
\end{minted}



\end{adjustwidth}
\hypertarget{1307762155632158750}{} 
\hyperlink{1307762155632158750}{\texttt{DelimitedFiles.readdlm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readdlm(source, delim::AbstractChar, eol::AbstractChar; options...)
\end{minted}

If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.



\end{adjustwidth}
\hypertarget{11851910953015558329}{} 
\hyperlink{11851910953015558329}{\texttt{DelimitedFiles.readdlm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readdlm(source, delim::AbstractChar, T::Type; options...)
\end{minted}

The end of line delimiter is taken as \texttt{{\textbackslash}n}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> using DelimitedFiles

julia> x = [1; 2; 3; 4];

julia> y = [1.1; 2.2; 3.3; 4.4];

julia> open("delim_file.txt", "w") do io
           writedlm(io, [x y], ',')
       end;

julia> readdlm("delim_file.txt", ',', Float64)
4×2 Array{Float64,2}:
 1.0  1.1
 2.0  2.2
 3.0  3.3
 4.0  4.4

julia> rm("delim_file.txt")
\end{minted}



\end{adjustwidth}
\hypertarget{14088726821151253916}{} 
\hyperlink{14088726821151253916}{\texttt{DelimitedFiles.readdlm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readdlm(source, delim::AbstractChar; options...)
\end{minted}

The end of line delimiter is taken as \texttt{{\textbackslash}n}. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.

\textbf{Examples}


\begin{minted}{jlcon}
julia> using DelimitedFiles

julia> x = [1; 2; 3; 4];

julia> y = [1.1; 2.2; 3.3; 4.4];

julia> open("delim_file.txt", "w") do io
           writedlm(io, [x y], ',')
       end;

julia> readdlm("delim_file.txt", ',')
4×2 Array{Float64,2}:
 1.0  1.1
 2.0  2.2
 3.0  3.3
 4.0  4.4

julia> z = ["a"; "b"; "c"; "d"];

julia> open("delim_file.txt", "w") do io
           writedlm(io, [x z], ',')
       end;

julia> readdlm("delim_file.txt", ',')
4×2 Array{Any,2}:
 1  "a"
 2  "b"
 3  "c"
 4  "d"

julia> rm("delim_file.txt")
\end{minted}



\end{adjustwidth}
\hypertarget{2674796801770597595}{} 
\hyperlink{2674796801770597595}{\texttt{DelimitedFiles.readdlm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readdlm(source, T::Type; options...)
\end{minted}

The columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as \texttt{{\textbackslash}n}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> using DelimitedFiles

julia> x = [1; 2; 3; 4];

julia> y = [5; 6; 7; 8];

julia> open("delim_file.txt", "w") do io
           writedlm(io, [x y])
       end;

julia> readdlm("delim_file.txt", Int64)
4×2 Array{Int64,2}:
 1  5
 2  6
 3  7
 4  8

julia> readdlm("delim_file.txt", Float64)
4×2 Array{Float64,2}:
 1.0  5.0
 2.0  6.0
 3.0  7.0
 4.0  8.0

julia> rm("delim_file.txt")
\end{minted}



\end{adjustwidth}
\hypertarget{12553768345033130217}{} 
\hyperlink{12553768345033130217}{\texttt{DelimitedFiles.readdlm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
readdlm(source; options...)
\end{minted}

The columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as \texttt{{\textbackslash}n}. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.

\textbf{Examples}


\begin{minted}{jlcon}
julia> using DelimitedFiles

julia> x = [1; 2; 3; 4];

julia> y = ["a"; "b"; "c"; "d"];

julia> open("delim_file.txt", "w") do io
           writedlm(io, [x y])
       end;

julia> readdlm("delim_file.txt")
4×2 Array{Any,2}:
 1  "a"
 2  "b"
 3  "c"
 4  "d"

julia> rm("delim_file.txt")
\end{minted}



\end{adjustwidth}
\hypertarget{18287165101716314167}{} 
\hyperlink{18287165101716314167}{\texttt{DelimitedFiles.writedlm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
writedlm(f, A, delim='\t'; opts)
\end{minted}

Write \texttt{A} (a vector, matrix, or an iterable collection of iterable rows) as text to \texttt{f} (either a filename string or an \texttt{IO} stream) using the given delimiter \texttt{delim} (which defaults to tab, but can be any printable Julia object, typically a \texttt{Char} or \texttt{AbstractString}).

For example, two vectors \texttt{x} and \texttt{y} of the same length can be written as two columns of tab-delimited text to \texttt{f} by either \texttt{writedlm(f, [x y])} or by \texttt{writedlm(f, zip(x, y))}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> using DelimitedFiles

julia> x = [1; 2; 3; 4];

julia> y = [5; 6; 7; 8];

julia> open("delim_file.txt", "w") do io
           writedlm(io, [x y])
       end

julia> readdlm("delim_file.txt", '\t', Int, '\n')
4×2 Array{Int64,2}:
 1  5
 2  6
 3  7
 4  8

julia> rm("delim_file.txt")
\end{minted}



\end{adjustwidth}

\hypertarget{18417912811524942081}{}


\chapter{分布式计算}


\hypertarget{2657399037748470653}{} 
\hyperlink{2657399037748470653}{\texttt{Distributed.addprocs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
addprocs(manager::ClusterManager; kwargs...) -> List of process identifiers
\end{minted}

Launches worker processes via the specified cluster manager.

For example, Beowulf clusters are supported via a custom cluster manager implemented in the package \texttt{ClusterManagers.jl}.

The number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable \texttt{JULIA\_WORKER\_TIMEOUT} in the worker process{\textquotesingle}s environment. Relevant only when using TCP/IP as transport.

To launch workers without blocking the REPL, or the containing function if launching workers programmatically, execute \texttt{addprocs} in its own task.

\textbf{Examples}


\begin{lstlisting}
# On busy clusters, call `addprocs` asynchronously
t = @async addprocs(...)
\end{lstlisting}


\begin{lstlisting}
# Utilize workers as and when they come online
if nprocs() > 1   # Ensure at least one new worker is available
   ....   # perform distributed execution
end
\end{lstlisting}


\begin{lstlisting}
# Retrieve newly launched worker IDs, or any error messages
if istaskdone(t)   # Check if `addprocs` has completed to ensure `fetch` doesn't block
    if nworkers() == N
        new_pids = fetch(t)
    else
        fetch(t)
    end
  end
\end{lstlisting}




\begin{lstlisting}
addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers
\end{lstlisting}

Add processes on remote machines via SSH. Requires \texttt{julia} to be installed in the same location on each node, or to be available via a shared file system.

\texttt{machines} is a vector of machine specifications. Workers are started for each specification.

A machine specification is either a string \texttt{machine\_spec} or a tuple - \texttt{(machine\_spec, count)}.

\texttt{machine\_spec} is a string of the form \texttt{[user@]host[:port] [bind\_addr[:port]]}. \texttt{user} defaults to current user, \texttt{port} to the standard ssh port. If \texttt{[bind\_addr[:port]]} is specified, other workers will connect to this worker at the specified \texttt{bind\_addr} and \texttt{port}.

\texttt{count} is the number of workers to be launched on the specified host. If specified as \texttt{:auto} it will launch as many workers as the number of CPU threads on the specific host.

Keyword arguments:

\begin{itemize}
\item \texttt{tunnel}: if \texttt{true} then SSH tunneling will be used to connect to the worker from the master process. Default is \texttt{false}.


\item \texttt{sshflags}: specifies additional ssh options, e.g. \texttt{sshflags=`-i /home/foo/bar.pem}`


\item \texttt{max\_parallel}: specifies the maximum number of workers connected to in parallel at a host. Defaults to 10.


\item \texttt{dir}: specifies the working directory on the workers. Defaults to the host{\textquotesingle}s current directory (as found by \texttt{pwd()})


\item \texttt{enable\_threaded\_blas}: if \texttt{true} then  BLAS will run on multiple threads in added processes. Default is \texttt{false}.


\item \texttt{exename}: name of the \texttt{julia} executable. Defaults to \texttt{{\textquotedbl}\$(Sys.BINDIR)/julia{\textquotedbl}} or \texttt{{\textquotedbl}\$(Sys.BINDIR)/julia-debug{\textquotedbl}} as the case may be.


\item \texttt{exeflags}: additional flags passed to the worker processes.


\item \texttt{topology}: Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.

\begin{itemize}
\item \texttt{topology=:all\_to\_all}: All processes are connected to each other. The default.


\item \texttt{topology=:master\_worker}: Only the driver process, i.e. \texttt{pid} 1 connects to the workers. The workers do not connect to each other.


\item \texttt{topology=:custom}: The \texttt{launch} method of the cluster manager specifies the connection topology via fields \texttt{ident} and \texttt{connect\_idents} in \texttt{WorkerConfig}. A worker with a cluster manager identity \texttt{ident} will connect to all workers specified in \texttt{connect\_idents}.

\end{itemize}

\item \texttt{lazy}: Applicable only with \texttt{topology=:all\_to\_all}. If \texttt{true}, worker-worker connections are setup lazily, i.e. they are setup at the first instance of a remote call between workers. Default is true.

\end{itemize}
Environment variables :

If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal situation and terminates. This timeout can be controlled via environment variable \texttt{JULIA\_WORKER\_TIMEOUT}. The value of \texttt{JULIA\_WORKER\_TIMEOUT} on the master process specifies the number of seconds a newly launched worker waits for connection establishment.




\begin{lstlisting}
addprocs(; kwargs...) -> List of process identifiers
\end{lstlisting}

Equivalent to \texttt{addprocs(Sys.CPU\_THREADS; kwargs...)}

Note that workers do not run a \texttt{.julia/config/startup.jl} startup script, nor do they synchronize their global state (such as global variables, new method definitions, and loaded modules) with any of the other running processes.




\begin{lstlisting}
addprocs(np::Integer; restrict=true, kwargs...) -> List of process identifiers
\end{lstlisting}

Launches workers using the in-built \texttt{LocalManager} which only launches workers on the local host. This can be used to take advantage of multiple cores. \texttt{addprocs(4)} will add 4 processes on the local machine. If \texttt{restrict} is \texttt{true}, binding is restricted to \texttt{127.0.0.1}. Keyword args \texttt{dir}, \texttt{exename}, \texttt{exeflags}, \texttt{topology}, \texttt{lazy} and \texttt{enable\_threaded\_blas} have the same effect as documented for \texttt{addprocs(machines)}.



\end{adjustwidth}
\hypertarget{12624410612036310990}{} 
\hyperlink{12624410612036310990}{\texttt{Distributed.nprocs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nprocs()
\end{minted}

Get the number of available processes.

\textbf{Examples}


\begin{minted}{jlcon}
julia> nprocs()
3

julia> workers()
5-element Array{Int64,1}:
 2
 3
\end{minted}



\end{adjustwidth}
\hypertarget{7237632848154090273}{} 
\hyperlink{7237632848154090273}{\texttt{Distributed.nworkers}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nworkers()
\end{minted}

Get the number of available worker processes. This is one less than \hyperlink{12624410612036310990}{\texttt{nprocs()}}. Equal to \texttt{nprocs()} if \texttt{nprocs() == 1}.

\textbf{Examples}


\begin{minted}{jlcon}
$ julia -p 5

julia> nprocs()
6

julia> nworkers()
5
\end{minted}



\end{adjustwidth}
\hypertarget{10683956780105113822}{} 
\hyperlink{10683956780105113822}{\texttt{Distributed.procs}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
procs()
\end{minted}

Return a list of all process identifiers, including pid 1 (which is not included by \hyperlink{7474509137601932173}{\texttt{workers()}}).

\textbf{Examples}


\begin{minted}{jlcon}
$ julia -p 5

julia> procs()
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



\end{adjustwidth}
\hypertarget{12431527815799129129}{} 
\hyperlink{12431527815799129129}{\texttt{Distributed.procs}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
procs(pid::Integer)
\end{minted}

Return a list of all process identifiers on the same physical node. Specifically all workers bound to the same ip-address as \texttt{pid} are returned.



\end{adjustwidth}
\hypertarget{7474509137601932173}{} 
\hyperlink{7474509137601932173}{\texttt{Distributed.workers}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
workers()
\end{minted}

Return a list of all worker process identifiers.

\textbf{Examples}


\begin{minted}{jlcon}
$ julia -p 5

julia> workers()
2-element Array{Int64,1}:
 2
 3
\end{minted}



\end{adjustwidth}
\hypertarget{16165500032398890398}{} 
\hyperlink{16165500032398890398}{\texttt{Distributed.rmprocs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rmprocs(pids...; waitfor=typemax(Int))
\end{minted}

Remove the specified workers. Note that only process 1 can add or remove workers.

Argument \texttt{waitfor} specifies how long to wait for the workers to shut down:

\begin{itemize}
\item If unspecified, \texttt{rmprocs} will wait until all requested \texttt{pids} are removed.


\item An \hyperlink{12102596058483452470}{\texttt{ErrorException}} is raised if all workers cannot be terminated before the requested \texttt{waitfor} seconds.


\item With a \texttt{waitfor} value of 0, the call returns immediately with the workers scheduled for removal in a different task. The scheduled \hyperlink{7131243650304654155}{\texttt{Task}} object is returned. The user should call \hyperlink{13761789780433862250}{\texttt{wait}} on the task before invoking any other parallel calls.

\end{itemize}
\textbf{Examples}


\begin{minted}{jlcon}
$ julia -p 5

julia> t = rmprocs(2, 3, waitfor=0)
Task (runnable) @0x0000000107c718d0

julia> wait(t)

julia> workers()
3-element Array{Int64,1}:
 4
 5
 6
\end{minted}



\end{adjustwidth}
\hypertarget{15554950403613599151}{} 
\hyperlink{15554950403613599151}{\texttt{Distributed.interrupt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
interrupt(pids::Integer...)
\end{minted}

Interrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.




\begin{lstlisting}
interrupt(pids::AbstractVector=workers())
\end{lstlisting}

Interrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.



\end{adjustwidth}
\hypertarget{15079655651797922234}{} 
\hyperlink{15079655651797922234}{\texttt{Distributed.myid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
myid()
\end{minted}

Get the id of the current process.

\textbf{Examples}


\begin{minted}{jlcon}
julia> myid()
1

julia> remotecall_fetch(() -> myid(), 4)
4
\end{minted}



\end{adjustwidth}
\hypertarget{9432281416771383761}{} 
\hyperlink{9432281416771383761}{\texttt{Distributed.pmap}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pmap(f, [::AbstractWorkerPool], c...; distributed=true, batch_size=1, on_error=nothing, retry_delays=[], retry_check=nothing) -> collection
\end{minted}

Transform collection \texttt{c} by applying \texttt{f} to each element using available workers and tasks.

For multiple collection arguments, apply \texttt{f} elementwise.

Note that \texttt{f} must be made available to all worker processes; see \href{@ref code-availability}{Code Availability and Loading Packages} for details.

If a worker pool is not specified, all available workers, i.e., the default worker pool is used.

By default, \texttt{pmap} distributes the computation over all specified workers. To use only the local process and distribute over tasks, specify \texttt{distributed=false}. This is equivalent to using \hyperlink{14148755671315265621}{\texttt{asyncmap}}. For example, \texttt{pmap(f, c; distributed=false)} is equivalent to \texttt{asyncmap(f,c; ntasks=()->nworkers())}

\texttt{pmap} can also use a mix of processes and tasks via the \texttt{batch\_size} argument. For batch sizes greater than 1, the collection is processed in multiple batches, each of length \texttt{batch\_size} or less. A batch is sent as a single request to a free worker, where a local \hyperlink{14148755671315265621}{\texttt{asyncmap}} processes elements from the batch using multiple concurrent tasks.

Any error stops \texttt{pmap} from processing the remainder of the collection. To override this behavior you can specify an error handling function via argument \texttt{on\_error} which takes in a single argument, i.e., the exception. The function can stop the processing by rethrowing the error, or, to continue, return any value which is then returned inline with the results to the caller.

Consider the following two examples. The first one returns the exception object inline, the second a 0 in place of any exception:


\begin{minted}{jlcon}
julia> pmap(x->iseven(x) ? error("foo") : x, 1:4; on_error=identity)
4-element Array{Any,1}:
 1
  ErrorException("foo")
 3
  ErrorException("foo")

julia> pmap(x->iseven(x) ? error("foo") : x, 1:4; on_error=ex->0)
4-element Array{Int64,1}:
 1
 0
 3
 0
\end{minted}

Errors can also be handled by retrying failed computations. Keyword arguments \texttt{retry\_delays} and \texttt{retry\_check} are passed through to \hyperlink{13615447016541985376}{\texttt{retry}} as keyword arguments \texttt{delays} and \texttt{check} respectively. If batching is specified, and an entire batch fails, all items in the batch are retried.

Note that if both \texttt{on\_error} and \texttt{retry\_delays} are specified, the \texttt{on\_error} hook is called before retrying. If \texttt{on\_error} does not throw (or rethrow) an exception, the element will not be retried.

Example: On errors, retry \texttt{f} on an element a maximum of 3 times without any delay between retries.


\begin{minted}{julia}
pmap(f, c; retry_delays = zeros(3))
\end{minted}

Example: Retry \texttt{f} only if the exception is not of type \hyperlink{5399118524830636312}{\texttt{InexactError}}, with exponentially increasing delays up to 3 times. Return a \texttt{NaN} in place for all \texttt{InexactError} occurrences.


\begin{minted}{julia}
pmap(f, c; on_error = e->(isa(e, InexactError) ? NaN : rethrow()), retry_delays = ExponentialBackOff(n = 3))
\end{minted}



\end{adjustwidth}
\hypertarget{10250718604436154991}{} 
\hyperlink{10250718604436154991}{\texttt{Distributed.RemoteException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RemoteException(captured)
\end{minted}

Exceptions on remote computations are captured and rethrown locally.  A \texttt{RemoteException} wraps the \texttt{pid} of the worker and a captured exception. A \texttt{CapturedException} captures the remote exception and a serializable form of the call stack when the exception was raised.



\end{adjustwidth}
\hypertarget{4170271048165085864}{} 
\hyperlink{4170271048165085864}{\texttt{Distributed.Future}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Future(w::Int, rrid::RRID, v::Union{Some, Nothing}=nothing)
\end{minted}

A \texttt{Future} is a placeholder for a single computation of unknown termination status and time. For multiple potential computations, see \texttt{RemoteChannel}. See \texttt{remoteref\_id} for identifying an \texttt{AbstractRemoteRef}.



\end{adjustwidth}
\hypertarget{16773267780467157552}{} 
\hyperlink{16773267780467157552}{\texttt{Distributed.RemoteChannel}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RemoteChannel(pid::Integer=myid())
\end{minted}

Make a reference to a \texttt{Channel\{Any\}(1)} on process \texttt{pid}. The default \texttt{pid} is the current process.


\begin{lstlisting}
RemoteChannel(f::Function, pid::Integer=myid())
\end{lstlisting}

Create references to remote channels of a specific size and type. \texttt{f} is a function that when executed on \texttt{pid} must return an implementation of an \texttt{AbstractChannel}.

For example, \texttt{RemoteChannel(()->Channel\{Int\}(10), pid)}, will return a reference to a channel of type \texttt{Int} and size 10 on \texttt{pid}.

The default \texttt{pid} is the current process.



\end{adjustwidth}
\hypertarget{16587595157480609141}{} 
\hyperlink{16587595157480609141}{\texttt{Base.fetch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fetch(x::Future)
\end{minted}

Wait for and get the value of a \hyperlink{4170271048165085864}{\texttt{Future}}. The fetched value is cached locally. Further calls to \texttt{fetch} on the same reference return the cached value. If the remote value is an exception, throws a \hyperlink{10250718604436154991}{\texttt{RemoteException}} which captures the remote exception and backtrace.



\end{adjustwidth}
\hypertarget{12485990804056740391}{} 
\hyperlink{12485990804056740391}{\texttt{Base.fetch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fetch(c::RemoteChannel)
\end{minted}

Wait for and get a value from a \hyperlink{16773267780467157552}{\texttt{RemoteChannel}}. Exceptions raised are the same as for a \hyperlink{4170271048165085864}{\texttt{Future}}. Does not remove the item fetched.



\end{adjustwidth}
\hypertarget{16286103980815121272}{} 
\hyperlink{16286103980815121272}{\texttt{Distributed.remotecall}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
remotecall(f, id::Integer, args...; kwargs...) -> Future
\end{minted}

Call a function \texttt{f} asynchronously on the given arguments on the specified process. Return a \hyperlink{4170271048165085864}{\texttt{Future}}. Keyword arguments, if any, are passed through to \texttt{f}.



\end{adjustwidth}
\hypertarget{14331709651005681807}{} 
\hyperlink{14331709651005681807}{\texttt{Distributed.remotecall\_wait}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
remotecall_wait(f, id::Integer, args...; kwargs...)
\end{minted}

Perform a faster \texttt{wait(remotecall(...))} in one message on the \texttt{Worker} specified by worker id \texttt{id}. Keyword arguments, if any, are passed through to \texttt{f}.

See also \hyperlink{13761789780433862250}{\texttt{wait}} and \hyperlink{16286103980815121272}{\texttt{remotecall}}.



\end{adjustwidth}
\hypertarget{14909184572421937971}{} 
\hyperlink{14909184572421937971}{\texttt{Distributed.remotecall\_fetch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
remotecall_fetch(f, id::Integer, args...; kwargs...)
\end{minted}

Perform \texttt{fetch(remotecall(...))} in one message. Keyword arguments, if any, are passed through to \texttt{f}. Any remote exceptions are captured in a \hyperlink{10250718604436154991}{\texttt{RemoteException}} and thrown.

See also \hyperlink{11007884648860062495}{\texttt{fetch}} and \hyperlink{16286103980815121272}{\texttt{remotecall}}.

\textbf{Examples}


\begin{minted}{jlcon}
$ julia -p 2

julia> remotecall_fetch(sqrt, 2, 4)
2.0

julia> remotecall_fetch(sqrt, 2, -4)
ERROR: On worker 2:
DomainError with -4.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
...
\end{minted}



\end{adjustwidth}
\hypertarget{10768474699483765487}{} 
\hyperlink{10768474699483765487}{\texttt{Distributed.remote\_do}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
remote_do(f, id::Integer, args...; kwargs...) -> nothing
\end{minted}

Executes \texttt{f} on worker \texttt{id} asynchronously. Unlike \hyperlink{16286103980815121272}{\texttt{remotecall}}, it does not store the result of computation, nor is there a way to wait for its completion.

A successful invocation indicates that the request has been accepted for execution on the remote node.

While consecutive \texttt{remotecall}s to the same worker are serialized in the order they are invoked, the order of executions on the remote worker is undetermined. For example, \texttt{remote\_do(f1, 2); remotecall(f2, 2); remote\_do(f3, 2)} will serialize the call to \texttt{f1}, followed by \texttt{f2} and \texttt{f3} in that order. However, it is not guaranteed that \texttt{f1} is executed before \texttt{f3} on worker 2.

Any exceptions thrown by \texttt{f} are printed to \hyperlink{6150355911915549172}{\texttt{stderr}} on the remote worker.

Keyword arguments, if any, are passed through to \texttt{f}.



\end{adjustwidth}
\hypertarget{2834687666116026096}{} 
\hyperlink{2834687666116026096}{\texttt{Base.put!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
put!(rr::RemoteChannel, args...)
\end{minted}

Store a set of values to the \hyperlink{16773267780467157552}{\texttt{RemoteChannel}}. If the channel is full, blocks until space is available. Return the first argument.



\end{adjustwidth}
\hypertarget{4609812859110888236}{} 
\hyperlink{4609812859110888236}{\texttt{Base.put!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
put!(rr::Future, v)
\end{minted}

Store a value to a \hyperlink{4170271048165085864}{\texttt{Future}} \texttt{rr}. \texttt{Future}s are write-once remote references. A \texttt{put!} on an already set \texttt{Future} throws an \texttt{Exception}. All asynchronous remote calls return \texttt{Future}s and set the value to the return value of the call upon completion.



\end{adjustwidth}
\hypertarget{1891403764656916697}{} 
\hyperlink{1891403764656916697}{\texttt{Base.take!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
take!(rr::RemoteChannel, args...)
\end{minted}

Fetch value(s) from a \hyperlink{16773267780467157552}{\texttt{RemoteChannel}} \texttt{rr}, removing the value(s) in the process.



\end{adjustwidth}
\hypertarget{6980559591888438300}{} 
\hyperlink{6980559591888438300}{\texttt{Base.isready}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isready(rr::RemoteChannel, args...)
\end{minted}

Determine whether a \hyperlink{16773267780467157552}{\texttt{RemoteChannel}} has a value stored to it. Note that this function can cause race conditions, since by the time you receive its result it may no longer be true. However, it can be safely used on a \hyperlink{4170271048165085864}{\texttt{Future}} since they are assigned only once.



\end{adjustwidth}
\hypertarget{10100315526321712686}{} 
\hyperlink{10100315526321712686}{\texttt{Base.isready}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isready(rr::Future)
\end{minted}

Determine whether a \hyperlink{4170271048165085864}{\texttt{Future}} has a value stored to it.

If the argument \texttt{Future} is owned by a different node, this call will block to wait for the answer. It is recommended to wait for \texttt{rr} in a separate task instead or to use a local \hyperlink{12548845729684045604}{\texttt{Channel}} as a proxy:


\begin{minted}{julia}
p = 1
f = Future(p)
@async put!(f, remotecall_fetch(long_computation, p))
isready(f)  # will not block
\end{minted}



\end{adjustwidth}
\hypertarget{3164386881139700111}{} 
\hyperlink{3164386881139700111}{\texttt{Distributed.AbstractWorkerPool}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractWorkerPool
\end{minted}

Supertype for worker pools such as \hyperlink{17976394752057970100}{\texttt{WorkerPool}} and \hyperlink{8617353702639655725}{\texttt{CachingPool}}. An \texttt{AbstractWorkerPool} should implement:

\begin{itemize}
\item \hyperlink{18026893834387542681}{\texttt{push!}} - add a new worker to the overall pool (available + busy)


\item \hyperlink{12719543094136814100}{\texttt{put!}} - put back a worker to the available pool


\item \hyperlink{4963355246106153560}{\texttt{take!}} - take a worker from the available pool (to be used for remote function execution)


\item \hyperlink{9362803119463040896}{\texttt{length}} - number of workers available in the overall pool


\item \hyperlink{15888554370655089980}{\texttt{isready}} - return false if a \texttt{take!} on the pool would block, else true

\end{itemize}
The default implementations of the above (on a \texttt{AbstractWorkerPool}) require fields

\begin{itemize}
\item \texttt{channel::Channel\{Int\}}


\item \texttt{workers::Set\{Int\}}

\end{itemize}
where \texttt{channel} contains free worker pids and \texttt{workers} is the set of all workers associated with this pool.



\end{adjustwidth}
\hypertarget{17976394752057970100}{} 
\hyperlink{17976394752057970100}{\texttt{Distributed.WorkerPool}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
WorkerPool(workers::Vector{Int})
\end{minted}

Create a \texttt{WorkerPool} from a vector of worker ids.

\textbf{Examples}


\begin{minted}{jlcon}
$ julia -p 3

julia> WorkerPool([2, 3])
WorkerPool(Channel{Int64}(sz_max:9223372036854775807,sz_curr:2), Set([2, 3]), RemoteChannel{Channel{Any}}(1, 1, 6))
\end{minted}



\end{adjustwidth}
\hypertarget{8617353702639655725}{} 
\hyperlink{8617353702639655725}{\texttt{Distributed.CachingPool}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
CachingPool(workers::Vector{Int})
\end{minted}

An implementation of an \texttt{AbstractWorkerPool}. \hyperlink{11837735656545549689}{\texttt{remote}}, \hyperlink{14909184572421937971}{\texttt{remotecall\_fetch}}, \hyperlink{9432281416771383761}{\texttt{pmap}} (and other remote calls which execute functions remotely) benefit from caching the serialized/deserialized functions on the worker nodes, especially closures (which may capture large amounts of data).

The remote cache is maintained for the lifetime of the returned \texttt{CachingPool} object. To clear the cache earlier, use \texttt{clear!(pool)}.

For global variables, only the bindings are captured in a closure, not the data. \texttt{let} blocks can be used to capture global data.

\textbf{Examples}


\begin{minted}{julia}
const foo = rand(10^8);
wp = CachingPool(workers())
let foo = foo
    pmap(wp, i -> sum(foo) + i, 1:100);
end
\end{minted}

The above would transfer \texttt{foo} only once to each worker.



\end{adjustwidth}
\hypertarget{994186287326037532}{} 
\hyperlink{994186287326037532}{\texttt{Distributed.default\_worker\_pool}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
default_worker_pool()
\end{minted}

\hyperlink{17976394752057970100}{\texttt{WorkerPool}} containing idle \hyperlink{7474509137601932173}{\texttt{workers}} - used by \texttt{remote(f)} and \hyperlink{9432281416771383761}{\texttt{pmap}} (by default).

\textbf{Examples}


\begin{minted}{jlcon}
$ julia -p 3

julia> default_worker_pool()
WorkerPool(Channel{Int64}(sz_max:9223372036854775807,sz_curr:3), Set([4, 2, 3]), RemoteChannel{Channel{Any}}(1, 1, 4))
\end{minted}



\end{adjustwidth}
\hypertarget{16881245113854963094}{} 
\hyperlink{16881245113854963094}{\texttt{Distributed.clear!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
clear!(pool::CachingPool) -> pool
\end{minted}

Removes all cached functions from all participating workers.



\end{adjustwidth}
\hypertarget{11837735656545549689}{} 
\hyperlink{11837735656545549689}{\texttt{Distributed.remote}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
remote([p::AbstractWorkerPool], f) -> Function
\end{minted}

Return an anonymous function that executes function \texttt{f} on an available worker (drawn from \hyperlink{17976394752057970100}{\texttt{WorkerPool}} \texttt{p} if provided) using \hyperlink{14909184572421937971}{\texttt{remotecall\_fetch}}.



\end{adjustwidth}
\hypertarget{13826444473261744969}{} 
\hyperlink{13826444473261744969}{\texttt{Distributed.remotecall}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
remotecall(f, pool::AbstractWorkerPool, args...; kwargs...) -> Future
\end{minted}

\hyperlink{17976394752057970100}{\texttt{WorkerPool}} variant of \texttt{remotecall(f, pid, ....)}. Wait for and take a free worker from \texttt{pool} and perform a \texttt{remotecall} on it.

\textbf{Examples}


\begin{minted}{jlcon}
$ julia -p 3

julia> wp = WorkerPool([2, 3]);

julia> A = rand(3000);

julia> f = remotecall(maximum, wp, A)
Future(2, 1, 6, nothing)
\end{minted}

In this example, the task ran on pid 2, called from pid 1.



\end{adjustwidth}
\hypertarget{1493466248843041179}{} 
\hyperlink{1493466248843041179}{\texttt{Distributed.remotecall\_wait}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
remotecall_wait(f, pool::AbstractWorkerPool, args...; kwargs...) -> Future
\end{minted}

\hyperlink{17976394752057970100}{\texttt{WorkerPool}} variant of \texttt{remotecall\_wait(f, pid, ....)}. Wait for and take a free worker from \texttt{pool} and perform a \texttt{remotecall\_wait} on it.

\textbf{Examples}


\begin{minted}{jlcon}
$ julia -p 3

julia> wp = WorkerPool([2, 3]);

julia> A = rand(3000);

julia> f = remotecall_wait(maximum, wp, A)
Future(3, 1, 9, nothing)

julia> fetch(f)
0.9995177101692958
\end{minted}



\end{adjustwidth}
\hypertarget{6431566786299199412}{} 
\hyperlink{6431566786299199412}{\texttt{Distributed.remotecall\_fetch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
remotecall_fetch(f, pool::AbstractWorkerPool, args...; kwargs...) -> result
\end{minted}

\hyperlink{17976394752057970100}{\texttt{WorkerPool}} variant of \texttt{remotecall\_fetch(f, pid, ....)}. Waits for and takes a free worker from \texttt{pool} and performs a \texttt{remotecall\_fetch} on it.

\textbf{Examples}


\begin{minted}{jlcon}
$ julia -p 3

julia> wp = WorkerPool([2, 3]);

julia> A = rand(3000);

julia> remotecall_fetch(maximum, wp, A)
0.9995177101692958
\end{minted}



\end{adjustwidth}
\hypertarget{9355776911888896083}{} 
\hyperlink{9355776911888896083}{\texttt{Distributed.remote\_do}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
remote_do(f, pool::AbstractWorkerPool, args...; kwargs...) -> nothing
\end{minted}

\hyperlink{17976394752057970100}{\texttt{WorkerPool}} variant of \texttt{remote\_do(f, pid, ....)}. Wait for and take a free worker from \texttt{pool} and perform a \texttt{remote\_do} on it.



\end{adjustwidth}
\hypertarget{11231712027010946923}{} 
\hyperlink{11231712027010946923}{\texttt{Distributed.@spawnat}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@spawnat p expr
\end{minted}

Create a closure around an expression and run the closure asynchronously on process \texttt{p}. Return a \hyperlink{4170271048165085864}{\texttt{Future}} to the result. If \texttt{p} is the quoted literal symbol \texttt{:any}, then the system will pick a processor to use automatically.

\textbf{Examples}


\begin{minted}{jlcon}
julia> addprocs(3);

julia> f = @spawnat 2 myid()
Future(2, 1, 3, nothing)

julia> fetch(f)
2

julia> f = @spawnat :any myid()
Future(3, 1, 7, nothing)

julia> fetch(f)
3
\end{minted}

\begin{quote}
\textbf{Julia 1.3}

The \texttt{:any} argument is available as of Julia 1.3.

\end{quote}


\end{adjustwidth}
\hypertarget{12924100318586144753}{} 
\hyperlink{12924100318586144753}{\texttt{Distributed.@fetch}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@fetch expr
\end{minted}

Equivalent to \texttt{fetch(@spawnat :any expr)}. See \hyperlink{11007884648860062495}{\texttt{fetch}} and \hyperlink{11231712027010946923}{\texttt{@spawnat}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> addprocs(3);

julia> @fetch myid()
2

julia> @fetch myid()
3

julia> @fetch myid()
4

julia> @fetch myid()
2
\end{minted}



\end{adjustwidth}
\hypertarget{4668231420319368373}{} 
\hyperlink{4668231420319368373}{\texttt{Distributed.@fetchfrom}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@fetchfrom
\end{minted}

Equivalent to \texttt{fetch(@spawnat p expr)}. See \hyperlink{11007884648860062495}{\texttt{fetch}} and \hyperlink{11231712027010946923}{\texttt{@spawnat}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> addprocs(3);

julia> @fetchfrom 2 myid()
2

julia> @fetchfrom 4 myid()
4
\end{minted}



\end{adjustwidth}
\hypertarget{4581929266257108937}{} 
\hyperlink{4581929266257108937}{\texttt{Distributed.@distributed}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@distributed
\end{minted}

A distributed memory, parallel for loop of the form :


\begin{lstlisting}
@distributed [reducer] for var = range
    body
end
\end{lstlisting}

The specified range is partitioned and locally executed across all workers. In case an optional reducer function is specified, \texttt{@distributed} performs local reductions on each worker with a final reduction on the calling process.

Note that without a reducer function, \texttt{@distributed} executes asynchronously, i.e. it spawns independent tasks on all available workers and returns immediately without waiting for completion. To wait for completion, prefix the call with \hyperlink{7188613740509403855}{\texttt{@sync}}, like :


\begin{lstlisting}
@sync @distributed for var = range
    body
end
\end{lstlisting}



\end{adjustwidth}
\hypertarget{4972064255482407966}{} 
\hyperlink{4972064255482407966}{\texttt{Distributed.@everywhere}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@everywhere [procs()] expr
\end{minted}

Execute an expression under \texttt{Main} on all \texttt{procs}. Errors on any of the processes are collected into a \hyperlink{15047752250898038281}{\texttt{CompositeException}} and thrown. For example:


\begin{lstlisting}
@everywhere bar = 1
\end{lstlisting}

will define \texttt{Main.bar} on all processes.

Unlike \hyperlink{11231712027010946923}{\texttt{@spawnat}}, \texttt{@everywhere} does not capture any local variables. Instead, local variables can be broadcast using interpolation:


\begin{lstlisting}
foo = 1
@everywhere bar = $foo
\end{lstlisting}

The optional argument \texttt{procs} allows specifying a subset of all processes to have execute the expression.

Equivalent to calling \texttt{remotecall\_eval(Main, procs, expr)}.



\end{adjustwidth}
\hypertarget{13290730966976452315}{} 
\hyperlink{13290730966976452315}{\texttt{Distributed.clear!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
clear!(syms, pids=workers(); mod=Main)
\end{minted}

Clears global bindings in modules by initializing them to \texttt{nothing}. \texttt{syms} should be of type \hyperlink{18332791376992528422}{\texttt{Symbol}} or a collection of \texttt{Symbol}s . \texttt{pids} and \texttt{mod} identify the processes and the module in which global variables are to be reinitialized. Only those names found to be defined under \texttt{mod} are cleared.

An exception is raised if a global constant is requested to be cleared.



\end{adjustwidth}
\hypertarget{10046899291571146856}{} 
\hyperlink{10046899291571146856}{\texttt{Distributed.remoteref\_id}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
remoteref_id(r::AbstractRemoteRef) -> RRID
\end{minted}

\texttt{Future}s and \texttt{RemoteChannel}s are identified by fields:

\begin{itemize}
\item \texttt{where} - refers to the node where the underlying object/storage referred to by the reference actually exists.


\item \texttt{whence} - refers to the node the remote reference was created from. Note that this is different from the node where the underlying object referred to actually exists. For example calling \texttt{RemoteChannel(2)} from the master process would result in a \texttt{where} value of 2 and a \texttt{whence} value of 1.


\item \texttt{id} is unique across all references created from the worker specified by \texttt{whence}.

\end{itemize}
Taken together,  \texttt{whence} and \texttt{id} uniquely identify a reference across all workers.

\texttt{remoteref\_id} is a low-level API which returns a \texttt{RRID} object that wraps \texttt{whence} and \texttt{id} values of a remote reference.



\end{adjustwidth}
\hypertarget{5007915834563819885}{} 
\hyperlink{5007915834563819885}{\texttt{Distributed.channel\_from\_id}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
channel_from_id(id) -> c
\end{minted}

A low-level API which returns the backing \texttt{AbstractChannel} for an \texttt{id} returned by \hyperlink{10046899291571146856}{\texttt{remoteref\_id}}. The call is valid only on the node where the backing channel exists.



\end{adjustwidth}
\hypertarget{806684110794204081}{} 
\hyperlink{806684110794204081}{\texttt{Distributed.worker\_id\_from\_socket}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
worker_id_from_socket(s) -> pid
\end{minted}

A low-level API which, given a \texttt{IO} connection or a \texttt{Worker}, returns the \texttt{pid} of the worker it is connected to. This is useful when writing custom \hyperlink{17931089632175850899}{\texttt{serialize}} methods for a type, which optimizes the data written out depending on the receiving process id.



\end{adjustwidth}
\hypertarget{914110747490695974}{} 
\hyperlink{914110747490695974}{\texttt{Distributed.cluster\_cookie}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cluster_cookie() -> cookie
\end{minted}

Return the cluster cookie.



\end{adjustwidth}
\hypertarget{7078615008605512632}{} 
\hyperlink{7078615008605512632}{\texttt{Distributed.cluster\_cookie}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cluster_cookie(cookie) -> cookie
\end{minted}

Set the passed cookie as the cluster cookie, then returns it.



\end{adjustwidth}

\hypertarget{6819108494041220011}{}


\section{Cluster Manager Interface}



This interface provides a mechanism to launch and manage Julia workers on different cluster environments. There are two types of managers present in Base: \texttt{LocalManager}, for launching additional workers on the same host, and \texttt{SSHManager}, for launching on remote hosts via \texttt{ssh}. TCP/IP sockets are used to connect and transport messages between processes. It is possible for Cluster Managers to provide a different transport.


\hypertarget{1673650075671996993}{} 
\hyperlink{1673650075671996993}{\texttt{Distributed.ClusterManager}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ClusterManager
\end{minted}

Supertype for cluster managers, which control workers processes as a cluster. Cluster managers implement how workers can be added, removed and communicated with. \texttt{SSHManager} and \texttt{LocalManager} are subtypes of this.



\end{adjustwidth}
\hypertarget{3351347791553517124}{} 
\hyperlink{3351347791553517124}{\texttt{Distributed.WorkerConfig}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
WorkerConfig
\end{minted}

Type used by \hyperlink{1673650075671996993}{\texttt{ClusterManager}}s to control workers added to their clusters. Some fields are used by all cluster managers to access a host:

\begin{itemize}
\item \texttt{io} – the connection used to access the worker (a subtype of \texttt{IO} or \texttt{Nothing})


\item \texttt{host} – the host address (either an \texttt{AbstractString} or \texttt{Nothing})


\item \texttt{port} – the port on the host used to connect to the worker (either an \texttt{Int} or \texttt{Nothing})

\end{itemize}
Some are used by the cluster manager to add workers to an already-initialized host:

\begin{itemize}
\item \texttt{count} – the number of workers to be launched on the host


\item \texttt{exename} – the path to the Julia executable on the host, defaults to \texttt{{\textquotedbl}\$(Sys.BINDIR)/julia{\textquotedbl}} or \texttt{{\textquotedbl}\$(Sys.BINDIR)/julia-debug{\textquotedbl}}


\item \texttt{exeflags} – flags to use when lauching Julia remotely

\end{itemize}
The \texttt{userdata} field is used to store information for each worker by external managers.

Some fields are used by \texttt{SSHManager} and similar managers:

\begin{itemize}
\item \texttt{tunnel} – \texttt{true} (use tunneling), \texttt{false} (do not use tunneling), or \hyperlink{9331422207248206047}{\texttt{nothing}} (use default for the manager)


\item \texttt{bind\_addr} – the address on the remote host to bind to


\item \texttt{sshflags} – flags to use in establishing the SSH connection


\item \texttt{max\_parallel} – the maximum number of workers to connect to in parallel on the host

\end{itemize}
Some fields are used by both \texttt{LocalManager}s and \texttt{SSHManager}s:

\begin{itemize}
\item \texttt{connect\_at} – determines whether this is a worker-to-worker or driver-to-worker setup call


\item \texttt{process} – the process which will be connected (usually the manager will assign this during \hyperlink{2657399037748470653}{\texttt{addprocs}})


\item \texttt{ospid} – the process ID according to the host OS, used to interrupt worker processes


\item \texttt{environ} – private dictionary used to store temporary information by Local/SSH managers


\item \texttt{ident} – worker as identified by the \hyperlink{1673650075671996993}{\texttt{ClusterManager}}


\item \texttt{connect\_idents} – list of worker ids the worker must connect to if using a custom topology


\item \texttt{enable\_threaded\_blas} – \texttt{true}, \texttt{false}, or \texttt{nothing}, whether to use threaded BLAS or not on the workers

\end{itemize}


\end{adjustwidth}
\hypertarget{7346188534454273843}{} 
\hyperlink{7346188534454273843}{\texttt{Distributed.launch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
launch(manager::ClusterManager, params::Dict, launched::Array, launch_ntfy::Condition)
\end{minted}

Implemented by cluster managers. For every Julia worker launched by this function, it should append a \texttt{WorkerConfig} entry to \texttt{launched} and notify \texttt{launch\_ntfy}. The function MUST exit once all workers, requested by \texttt{manager} have been launched. \texttt{params} is a dictionary of all keyword arguments \hyperlink{2657399037748470653}{\texttt{addprocs}} was called with.



\end{adjustwidth}
\hypertarget{8462349151012734144}{} 
\hyperlink{8462349151012734144}{\texttt{Distributed.manage}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
manage(manager::ClusterManager, id::Integer, config::WorkerConfig. op::Symbol)
\end{minted}

Implemented by cluster managers. It is called on the master process, during a worker{\textquotesingle}s lifetime, with appropriate \texttt{op} values:

\begin{itemize}
\item with \texttt{:register}/\texttt{:deregister} when a worker is added / removed from the Julia worker pool.


\item with \texttt{:interrupt} when \texttt{interrupt(workers)} is called. The \texttt{ClusterManager} should signal the appropriate worker with an interrupt signal.


\item with \texttt{:finalize} for cleanup purposes.

\end{itemize}


\end{adjustwidth}
\hypertarget{17836284879339877528}{} 
\hyperlink{17836284879339877528}{\texttt{Base.kill}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
kill(manager::ClusterManager, pid::Int, config::WorkerConfig)
\end{minted}

Implemented by cluster managers. It is called on the master process, by \hyperlink{16165500032398890398}{\texttt{rmprocs}}. It should cause the remote worker specified by \texttt{pid} to exit. \texttt{kill(manager::ClusterManager.....)} executes a remote \texttt{exit()} on \texttt{pid}.



\end{adjustwidth}
\hypertarget{9743233285520657275}{} 
\hyperlink{9743233285520657275}{\texttt{Sockets.connect}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
connect(manager::ClusterManager, pid::Int, config::WorkerConfig) -> (instrm::IO, outstrm::IO)
\end{minted}

Implemented by cluster managers using custom transports. It should establish a logical connection to worker with id \texttt{pid}, specified by \texttt{config} and return a pair of \texttt{IO} objects. Messages from \texttt{pid} to current process will be read off \texttt{instrm}, while messages to be sent to \texttt{pid} will be written to \texttt{outstrm}. The custom transport implementation must ensure that messages are delivered and received completely and in order. \texttt{connect(manager::ClusterManager.....)} sets up TCP/IP socket connections in-between workers.



\end{adjustwidth}
\hypertarget{12889811459778306363}{} 
\hyperlink{12889811459778306363}{\texttt{Distributed.init\_worker}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
init_worker(cookie::AbstractString, manager::ClusterManager=DefaultClusterManager())
\end{minted}

Called by cluster managers implementing custom transports. It initializes a newly launched process as a worker. Command line argument \texttt{--worker[=<cookie>]} has the effect of initializing a process as a worker using TCP/IP sockets for transport. \texttt{cookie} is a \hyperlink{914110747490695974}{\texttt{cluster\_cookie}}.



\end{adjustwidth}
\hypertarget{3765538736204641537}{} 
\hyperlink{3765538736204641537}{\texttt{Distributed.start\_worker}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
start_worker([out::IO=stdout], cookie::AbstractString=readline(stdin); close_stdin::Bool=true, stderr_to_stdout::Bool=true)
\end{minted}

\texttt{start\_worker} is an internal function which is the default entry point for worker processes connecting via TCP/IP. It sets up the process as a Julia cluster worker.

host:port information is written to stream \texttt{out} (defaults to stdout).

The function reads the cookie from stdin if required, and  listens on a free port (or if specified, the port in the \texttt{--bind-to} command line option) and schedules tasks to process incoming TCP connections and requests. It also (optionally) closes stdin and redirects stderr to stdout.

It does not return.



\end{adjustwidth}
\hypertarget{3971171154765725829}{} 
\hyperlink{3971171154765725829}{\texttt{Distributed.process\_messages}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
process_messages(r_stream::IO, w_stream::IO, incoming::Bool=true)
\end{minted}

Called by cluster managers using custom transports. It should be called when the custom transport implementation receives the first message from a remote worker. The custom transport must manage a logical connection to the remote worker and provide two \texttt{IO} objects, one for incoming messages and the other for messages addressed to the remote worker. If \texttt{incoming} is \texttt{true}, the remote peer initiated the connection. Whichever of the pair initiates the connection sends the cluster cookie and its Julia version number to perform the authentication handshake.

See also \hyperlink{914110747490695974}{\texttt{cluster\_cookie}}.



\end{adjustwidth}

\hypertarget{4477435705340973602}{}


\chapter{文件相关事件}


\hypertarget{4018465060202185434}{} 
\hyperlink{4018465060202185434}{\texttt{FileWatching.poll\_fd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
poll_fd(fd, timeout_s::Real=-1; readable=false, writable=false)
\end{minted}

Monitor a file descriptor \texttt{fd} for changes in the read or write availability, and with a timeout given by \texttt{timeout\_s} seconds.

The keyword arguments determine which of read and/or write status should be monitored; at least one of them must be set to \texttt{true}.

The returned value is an object with boolean fields \texttt{readable}, \texttt{writable}, and \texttt{timedout}, giving the result of the polling.



\end{adjustwidth}
\hypertarget{16623395181067730756}{} 
\hyperlink{16623395181067730756}{\texttt{FileWatching.poll\_file}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
poll_file(path::AbstractString, interval_s::Real=5.007, timeout_s::Real=-1) -> (previous::StatStruct, current)
\end{minted}

Monitor a file for changes by polling every \texttt{interval\_s} seconds until a change occurs or \texttt{timeout\_s} seconds have elapsed. The \texttt{interval\_s} should be a long period; the default is 5.007 seconds.

Returns a pair of status objects \texttt{(previous, current)} when a change is detected. The \texttt{previous} status is always a \texttt{StatStruct}, but it may have all of the fields zeroed (indicating the file didn{\textquotesingle}t previously exist, or wasn{\textquotesingle}t previously accessible).

The \texttt{current} status object may be a \texttt{StatStruct}, an \texttt{EOFError} (indicating the timeout elapsed), or some other \texttt{Exception} subtype (if the \texttt{stat} operation failed - for example, if the path does not exist).

To determine when a file was modified, compare \texttt{current isa StatStruct \&\& mtime(prev) != mtime(current)} to detect notification of changes. However, using \hyperlink{9407226289289061636}{\texttt{watch\_file}} for this operation is preferred, since it is more reliable and efficient, although in some situations it may not be available.



\end{adjustwidth}
\hypertarget{9407226289289061636}{} 
\hyperlink{9407226289289061636}{\texttt{FileWatching.watch\_file}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
watch_file(path::AbstractString, timeout_s::Real=-1)
\end{minted}

Watch file or directory \texttt{path} for changes until a change occurs or \texttt{timeout\_s} seconds have elapsed.

The returned value is an object with boolean fields \texttt{changed}, \texttt{renamed}, and \texttt{timedout}, giving the result of watching the file.

This behavior of this function varies slightly across platforms. See \href{https://nodejs.org/api/fs.html\#fs\_caveats}{https://nodejs.org/api/fs.html\#fs\_caveats} for more detailed information.



\end{adjustwidth}
\hypertarget{3977882412787158374}{} 
\hyperlink{3977882412787158374}{\texttt{FileWatching.watch\_folder}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
watch_folder(path::AbstractString, timeout_s::Real=-1)
\end{minted}

Watches a file or directory \texttt{path} for changes until a change has occurred or \texttt{timeout\_s} seconds have elapsed.

This will continuing tracking changes for \texttt{path} in the background until \texttt{unwatch\_folder} is called on the same \texttt{path}.

The returned value is an pair where the first field is the name of the changed file (if available) and the second field is an object with boolean fields \texttt{changed}, \texttt{renamed}, and \texttt{timedout}, giving the event.

This behavior of this function varies slightly across platforms. See \href{https://nodejs.org/api/fs.html\#fs\_caveats}{https://nodejs.org/api/fs.html\#fs\_caveats} for more detailed information.



\end{adjustwidth}
\hypertarget{18277052083824325968}{} 
\hyperlink{18277052083824325968}{\texttt{FileWatching.unwatch\_folder}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
unwatch_folder(path::AbstractString)
\end{minted}

Stop background tracking of changes for \texttt{path}. It is not recommended to do this while another task is waiting for \texttt{watch\_folder} to return on the same path, as the result may be unpredictable.



\end{adjustwidth}

\hypertarget{5035560459599416721}{}


\chapter{交互式组件}


\hypertarget{6069714544176255543}{} 
\hyperlink{6069714544176255543}{\texttt{Base.Docs.apropos}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
apropos(string)
\end{minted}

Search through all documentation for a string, ignoring case.



\end{adjustwidth}
\hypertarget{18269429703422902914}{} 
\hyperlink{18269429703422902914}{\texttt{InteractiveUtils.varinfo}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
varinfo(m::Module=Main, pattern::Regex=r"")
\end{minted}

Return a markdown table giving information about exported global variables in a module, optionally restricted to those matching \texttt{pattern}.

The memory consumption estimate is an approximate lower bound on the size of the internal structure of the object.



\end{adjustwidth}
\hypertarget{11698106121547091928}{} 
\hyperlink{11698106121547091928}{\texttt{InteractiveUtils.versioninfo}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
versioninfo(io::IO=stdout; verbose::Bool=false)
\end{minted}

Print information about the version of Julia in use. The output is controlled with boolean keyword arguments:

\begin{itemize}
\item \texttt{verbose}: print all additional information

\end{itemize}


\end{adjustwidth}
\hypertarget{1845157398882896709}{} 
\hyperlink{1845157398882896709}{\texttt{InteractiveUtils.methodswith}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
methodswith(typ[, module or function]; supertypes::Bool=false])
\end{minted}

Return an array of methods with an argument of type \texttt{typ}.

The optional second argument restricts the search to a particular module or function (the default is all top-level modules).

If keyword \texttt{supertypes} is \texttt{true}, also return arguments with a parent type of \texttt{typ}, excluding type \texttt{Any}.



\end{adjustwidth}
\hypertarget{13112219412833772146}{} 
\hyperlink{13112219412833772146}{\texttt{InteractiveUtils.subtypes}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
subtypes(T::DataType)
\end{minted}

Return a list of immediate subtypes of DataType \texttt{T}. Note that all currently loaded subtypes are included, including those not visible in the current module.

\textbf{Examples}


\begin{minted}{jlcon}
julia> subtypes(Integer)
3-element Array{Any,1}:
 Bool
 Signed
 Unsigned
\end{minted}



\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{InteractiveUtils.supertypes}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{10268751953828531961}{} 
\hyperlink{10268751953828531961}{\texttt{InteractiveUtils.edit}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
edit(path::AbstractString, line::Integer=0)
\end{minted}

Edit a file or directory optionally providing a line number to edit the file at. Return to the \texttt{julia} prompt when you quit the editor. The editor can be changed by setting \texttt{JULIA\_EDITOR}, \texttt{VISUAL} or \texttt{EDITOR} as an environment variable.

See also: (\texttt{define\_editor})[@ref]



\end{adjustwidth}
\hypertarget{5817135015306723574}{} 
\hyperlink{5817135015306723574}{\texttt{InteractiveUtils.edit}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
edit(function, [types])
edit(module)
\end{minted}

Edit the definition of a function, optionally specifying a tuple of types to indicate which method to edit. For modules, open the main source file. The module needs to be loaded with \texttt{using} or \texttt{import} first.

\begin{quote}
\textbf{Julia 1.1}

\texttt{edit} on modules requires at least Julia 1.1.

\end{quote}
To ensure that the file can be opened at the given line, you may need to call \texttt{define\_editor} first.



\end{adjustwidth}
\hypertarget{15808508619915684107}{} 
\hyperlink{15808508619915684107}{\texttt{InteractiveUtils.@edit}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@edit
\end{minted}

Evaluates the arguments to the function or macro call, determines their types, and calls the \texttt{edit} function on the resulting expression.



\end{adjustwidth}
\hypertarget{7329923191421757530}{} 
\hyperlink{7329923191421757530}{\texttt{InteractiveUtils.define\_editor}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
define_editor(fn, pattern; wait=false)
\end{minted}

Define a new editor matching \texttt{pattern} that can be used to open a file (possibly at a given line number) using \texttt{fn}.

The \texttt{fn} argument is a function that determines how to open a file with the given editor. It should take three arguments, as follows:

\begin{itemize}
\item \texttt{cmd} - a base command object for the editor


\item \texttt{path} - the path to the source file to open


\item \texttt{line} - the line number to open the editor at

\end{itemize}
Editors which cannot open to a specific line with a command may ignore the \texttt{line} argument. The \texttt{fn} callback must return either an appropriate \texttt{Cmd} object to open a file or \texttt{nothing} to indicate that they cannot edit this file. Use \texttt{nothing} to indicate that this editor is not appropriate for the current environment and another editor should be attempted. It is possible to add more general editing hooks that need not spawn external commands by pushing a callback directly to the vector \texttt{EDITOR\_CALLBACKS}.

The \texttt{pattern} argument is a string, regular expression, or an array of strings and regular expressions. For the \texttt{fn} to be called, one of the patterns must match the value of \texttt{EDITOR}, \texttt{VISUAL} or \texttt{JULIA\_EDITOR}. For strings, the string must equal the \hyperlink{16452154606861459390}{\texttt{basename}} of the first word of the editor command, with its extension, if any, removed. E.g. {\textquotedbl}vi{\textquotedbl} doesn{\textquotesingle}t match {\textquotedbl}vim -g{\textquotedbl} but matches {\textquotedbl}/usr/bin/vi -m{\textquotedbl}; it also matches \texttt{vi.exe}. If \texttt{pattern} is a regex it is matched against all of the editor command as a shell-escaped string. An array pattern matches if any of its items match. If multiple editors match, the one added most recently is used.

By default julia does not wait for the editor to close, running it in the background. However, if the editor is terminal based, you will probably want to set \texttt{wait=true} and julia will wait for the editor to close before resuming.

If one of the editor environment variables is set, but no editor entry matches it, the default editor entry is invoked:


\begin{lstlisting}
(cmd, path, line) -> `$cmd $path`
\end{lstlisting}

Note that many editors are already defined. All of the following commands should already work:

\begin{itemize}
\item emacs


\item vim


\item nvim


\item nano


\item textmate


\item mate


\item kate


\item subl


\item atom


\item notepad++


\item Visual Studio Code


\item open


\item pycharm

\end{itemize}
\textbf{Example:}

The following defines the usage of terminal-based \texttt{emacs}:


\begin{lstlisting}
define_editor(
    r"\bemacs\b.*\s(-nw|--no-window-system)\b", wait=true) do cmd, path, line
    `$cmd +$line $path`
end
\end{lstlisting}

\begin{quote}
\textbf{Julia 1.4}

\texttt{define\_editor} was introduced in Julia 1.4.

\end{quote}


\end{adjustwidth}
\hypertarget{449855233258666437}{} 
\hyperlink{449855233258666437}{\texttt{InteractiveUtils.less}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
less(file::AbstractString, [line::Integer])
\end{minted}

Show a file using the default pager, optionally providing a starting line number. Returns to the \texttt{julia} prompt when you quit the pager.



\end{adjustwidth}
\hypertarget{16005681522948418287}{} 
\hyperlink{16005681522948418287}{\texttt{InteractiveUtils.less}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
less(function, [types])
\end{minted}

Show the definition of a function using the default pager, optionally specifying a tuple of types to indicate which method to see.



\end{adjustwidth}
\hypertarget{8935326068247481160}{} 
\hyperlink{8935326068247481160}{\texttt{InteractiveUtils.@less}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@less
\end{minted}

Evaluates the arguments to the function or macro call, determines their types, and calls the \texttt{less} function on the resulting expression.



\end{adjustwidth}
\hypertarget{5196080466457876497}{} 
\hyperlink{5196080466457876497}{\texttt{InteractiveUtils.@which}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@which
\end{minted}

Applied to a function or macro call, it evaluates the arguments to the specified call, and returns the \texttt{Method} object for the method that would be called for those arguments. Applied to a variable, it returns the module in which the variable was bound. It calls out to the \texttt{which} function.



\end{adjustwidth}
\hypertarget{12812718888833665191}{} 
\hyperlink{12812718888833665191}{\texttt{InteractiveUtils.@functionloc}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@functionloc
\end{minted}

Applied to a function or macro call, it evaluates the arguments to the specified call, and returns a tuple \texttt{(filename,line)} giving the location for the method that would be called for those arguments. It calls out to the \texttt{functionloc} function.



\end{adjustwidth}
\hypertarget{1376948972689074219}{} 
\hyperlink{1376948972689074219}{\texttt{InteractiveUtils.@code\_lowered}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@code_lowered
\end{minted}

Evaluates the arguments to the function or macro call, determines their types, and calls \hyperlink{18235967286596219009}{\texttt{code\_lowered}} on the resulting expression.



\end{adjustwidth}
\hypertarget{6823997547688846780}{} 
\hyperlink{6823997547688846780}{\texttt{InteractiveUtils.@code\_typed}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@code_typed
\end{minted}

Evaluates the arguments to the function or macro call, determines their types, and calls \hyperlink{14801595959157535515}{\texttt{code\_typed}} on the resulting expression. Use the optional argument \texttt{optimize} with


\begin{lstlisting}
@code_typed optimize=true foo(x)
\end{lstlisting}

to control whether additional optimizations, such as inlining, are also applied.



\end{adjustwidth}
\hypertarget{5565852192659724503}{} 
\hyperlink{5565852192659724503}{\texttt{InteractiveUtils.code\_warntype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
code_warntype([io::IO], f, types; debuginfo=:default)
\end{minted}

Prints lowered and type-inferred ASTs for the methods matching the given generic function and type signature to \texttt{io} which defaults to \texttt{stdout}. The ASTs are annotated in such a way as to cause {\textquotedbl}non-leaf{\textquotedbl} types to be emphasized (if color is available, displayed in red). This serves as a warning of potential type instability. Not all non-leaf types are particularly problematic for performance, so the results need to be used judiciously. In particular, unions containing either \hyperlink{14596725676261444434}{\texttt{missing}} or \hyperlink{9331422207248206047}{\texttt{nothing}} are displayed in yellow, since these are often intentional.

Keyword argument \texttt{debuginfo} may be one of \texttt{:source} or \texttt{:none} (default), to specify the verbosity of code comments.

See \hyperlink{7310642359836438564}{\texttt{@code\_warntype}} for more information.



\end{adjustwidth}
\hypertarget{8092893264277772840}{} 
\hyperlink{8092893264277772840}{\texttt{InteractiveUtils.@code\_warntype}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@code_warntype
\end{minted}

Evaluates the arguments to the function or macro call, determines their types, and calls \hyperlink{5565852192659724503}{\texttt{code\_warntype}} on the resulting expression.



\end{adjustwidth}
\hypertarget{1749471484368489435}{} 
\hyperlink{1749471484368489435}{\texttt{InteractiveUtils.code\_llvm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
code_llvm([io=stdout,], f, types; raw=false, dump_module=false, optimize=true, debuginfo=:default)
\end{minted}

Prints the LLVM bitcodes generated for running the method matching the given generic function and type signature to \texttt{io}.

If the \texttt{optimize} keyword is unset, the code will be shown before LLVM optimizations. All metadata and dbg.* calls are removed from the printed bitcode. For the full IR, set the \texttt{raw} keyword to true. To dump the entire module that encapsulates the function (with declarations), set the \texttt{dump\_module} keyword to true. Keyword argument \texttt{debuginfo} may be one of source (default) or none, to specify the verbosity of code comments.



\end{adjustwidth}
\hypertarget{18039596607712979441}{} 
\hyperlink{18039596607712979441}{\texttt{InteractiveUtils.@code\_llvm}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@code_llvm
\end{minted}

Evaluates the arguments to the function or macro call, determines their types, and calls \hyperlink{1749471484368489435}{\texttt{code\_llvm}} on the resulting expression. Set the optional keyword arguments \texttt{raw}, \texttt{dump\_module}, \texttt{debuginfo}, \texttt{optimize} by putting them and their value before the function call, like this:


\begin{lstlisting}
@code_llvm raw=true dump_module=true debuginfo=:default f(x)
@code_llvm optimize=false f(x)
\end{lstlisting}

\texttt{optimize} controls whether additional optimizations, such as inlining, are also applied. \texttt{raw} makes all metadata and dbg.* calls visible. \texttt{debuginfo} may be one of \texttt{:source} (default) or \texttt{:none},  to specify the verbosity of code comments. \texttt{dump\_module} prints the entire module that encapsulates the function.



\end{adjustwidth}
\hypertarget{2534314152947301270}{} 
\hyperlink{2534314152947301270}{\texttt{InteractiveUtils.code\_native}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
code_native([io=stdout,], f, types; syntax=:att, debuginfo=:default)
\end{minted}

Prints the native assembly instructions generated for running the method matching the given generic function and type signature to \texttt{io}. Switch assembly syntax using \texttt{syntax} symbol parameter set to \texttt{:att} for AT\&T syntax or \texttt{:intel} for Intel syntax. Keyword argument \texttt{debuginfo} may be one of source (default) or none, to specify the verbosity of code comments.



\end{adjustwidth}
\hypertarget{2629340111434042067}{} 
\hyperlink{2629340111434042067}{\texttt{InteractiveUtils.@code\_native}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@code_native
\end{minted}

Evaluates the arguments to the function or macro call, determines their types, and calls \hyperlink{2534314152947301270}{\texttt{code\_native}} on the resulting expression.

Set the optional keyword argument \texttt{debuginfo} by putting it before the function call, like this:


\begin{lstlisting}
@code_native debuginfo=:default f(x)
\end{lstlisting}

\texttt{debuginfo} may be one of \texttt{:source} (default) or \texttt{:none}, to specify the verbosity of code comments.



\end{adjustwidth}
\hypertarget{17688389159658604177}{} 
\hyperlink{17688389159658604177}{\texttt{InteractiveUtils.clipboard}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
clipboard(x)
\end{minted}

Send a printed form of \texttt{x} to the operating system clipboard ({\textquotedbl}copy{\textquotedbl}).




\begin{lstlisting}
clipboard() -> AbstractString
\end{lstlisting}

Return a string with the contents of the operating system clipboard ({\textquotedbl}paste{\textquotedbl}).



\end{adjustwidth}

\hypertarget{14272245692301851811}{}


\chapter{LibGit2}



The LibGit2 module provides bindings to \href{https://libgit2.org/}{libgit2}, a portable C library that implements core functionality for the \href{https://git-scm.com/}{Git} version control system. These bindings are currently used to power Julia{\textquotesingle}s package manager. It is expected that this module will eventually be moved into a separate package.



\hypertarget{13716495418266911399}{}


\subsection{Functionality}



Some of this documentation assumes some prior knowledge of the libgit2 API. For more information on some of the objects and methods referenced here, consult the upstream \href{https://libgit2.org/libgit2/\#v0.25.1}{libgit2 API reference}.


\hypertarget{6862256905288214016}{} 
\hyperlink{6862256905288214016}{\texttt{LibGit2.Buffer}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.Buffer
\end{minted}

A data buffer for exporting data from libgit2. Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_buf}{\texttt{git\_buf}} struct.

When fetching data from LibGit2, a typical usage would look like:


\begin{minted}{julia}
buf_ref = Ref(Buffer())
@check ccall(..., (Ptr{Buffer},), buf_ref)
# operation on buf_ref
free(buf_ref)
\end{minted}

In particular, note that \texttt{LibGit2.free} should be called afterward on the \texttt{Ref} object.



\end{adjustwidth}
\hypertarget{16441061243067746546}{} 
\hyperlink{16441061243067746546}{\texttt{LibGit2.CheckoutOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.CheckoutOptions
\end{minted}

Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_checkout\_options}{\texttt{git\_checkout\_options}} struct.

The fields represent:

\begin{itemize}
\item \texttt{version}: version of the struct in use, in case this changes later. For now, always \texttt{1}.


\item \texttt{checkout\_strategy}: determine how to handle conflicts and whether to force the  checkout/recreate missing files.


\item \texttt{disable\_filters}: if nonzero, do not apply filters like CLRF (to convert file newlines between UNIX and DOS).


\item \texttt{dir\_mode}: read/write/access mode for any directories involved in the checkout. Default is \texttt{0755}.


\item \texttt{file\_mode}: read/write/access mode for any files involved in the checkout.  Default is \texttt{0755} or \texttt{0644}, depending on the blob.


\item \texttt{file\_open\_flags}: bitflags used to open any files during the checkout.


\item \texttt{notify\_flags}: Flags for what sort of conflicts the user should be notified about.


\item \texttt{notify\_cb}: An optional callback function to notify the user if a checkout conflict occurs.  If this function returns a non-zero value, the checkout will be cancelled.


\item \texttt{notify\_payload}: Payload for the notify callback function.


\item \texttt{progress\_cb}: An optional callback function to display checkout progress.


\item \texttt{progress\_payload}: Payload for the progress callback.


\item \texttt{paths}: If not empty, describes which paths to search during the checkout.  If empty, the checkout will occur over all files in the repository.


\item \texttt{baseline}: Expected content of the \hyperlink{6689577338311178757}{\texttt{workdir}}, captured in a (pointer to a)  \hyperlink{6242150303858692069}{\texttt{GitTree}}. Defaults to the state of the tree at HEAD.


\item \texttt{baseline\_index}: Expected content of the \hyperlink{6689577338311178757}{\texttt{workdir}}, captured in a (pointer to a)  \texttt{GitIndex}. Defaults to the state of the index at HEAD.


\item \texttt{target\_directory}: If not empty, checkout to this directory instead of the \texttt{workdir}.


\item \texttt{ancestor\_label}: In case of conflicts, the name of the common ancestor side.


\item \texttt{our\_label}: In case of conflicts, the name of {\textquotedbl}our{\textquotedbl} side.


\item \texttt{their\_label}: In case of conflicts, the name of {\textquotedbl}their{\textquotedbl} side.


\item \texttt{perfdata\_cb}: An optional callback function to display performance data.


\item \texttt{perfdata\_payload}: Payload for the performance callback.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L32}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15963609167797539123}{} 
\hyperlink{15963609167797539123}{\texttt{LibGit2.CloneOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.CloneOptions
\end{minted}

Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_clone\_options}{\texttt{git\_clone\_options}} struct.

The fields represent:

\begin{itemize}
\item \texttt{version}: version of the struct in use, in case this changes later. For now, always \texttt{1}.


\item \texttt{checkout\_opts}: The options for performing the checkout of the remote as part of the clone.


\item \texttt{fetch\_opts}: The options for performing the pre-checkout fetch of the remote as part of the clone.


\item \texttt{bare}: If \texttt{0}, clone the full remote repository. If non-zero, perform a bare clone, in which  there is no local copy of the source files in the repository and the \hyperlink{12125979754140967861}{\texttt{gitdir}} and \hyperlink{6689577338311178757}{\texttt{workdir}}  are the same.


\item \texttt{localclone}: Flag whether to clone a local object database or do a fetch. The default is to let git decide.  It will not use the git-aware transport for a local clone, but will use it for URLs which begin with \texttt{file://}.


\item \texttt{checkout\_branch}: The name of the branch to checkout. If an empty string, the default branch of the  remote will be checked out.


\item \texttt{repository\_cb}: An optional callback which will be used to create the \emph{new} repository into which  the clone is made.


\item \texttt{repository\_cb\_payload}: The payload for the repository callback.


\item \texttt{remote\_cb}: An optional callback used to create the \hyperlink{9925970107179782013}{\texttt{GitRemote}} before making the clone from it.


\item \texttt{remote\_cb\_payload}: The payload for the remote callback.

\end{itemize}


\end{adjustwidth}
\hypertarget{7523488922232000806}{} 
\hyperlink{7523488922232000806}{\texttt{LibGit2.DescribeOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.DescribeOptions
\end{minted}

Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_describe\_options}{\texttt{git\_describe\_options}} struct.

The fields represent:

\begin{itemize}
\item \texttt{version}: version of the struct in use, in case this changes later. For now, always \texttt{1}.


\item \texttt{max\_candidates\_tags}: consider this many most recent tags in \texttt{refs/tags} to describe a commit.  Defaults to 10 (so that the 10 most recent tags would be examined to see if they describe a commit).


\item \texttt{describe\_strategy}: whether to consider all entries in \texttt{refs/tags} (equivalent to \texttt{git-describe --tags})  or all entries in \texttt{refs/} (equivalent to \texttt{git-describe --all}). The default is to only show annotated tags.  If \texttt{Consts.DESCRIBE\_TAGS} is passed, all tags, annotated or not, will be considered.  If \texttt{Consts.DESCRIBE\_ALL} is passed, any ref in \texttt{refs/} will be considered.


\item \texttt{pattern}: only consider tags which match \texttt{pattern}. Supports glob expansion.


\item \texttt{only\_follow\_first\_parent}: when finding the distance from a matching reference to the described  object, only consider the distance from the first parent.


\item \texttt{show\_commit\_oid\_as\_fallback}: if no matching reference can be found which describes a commit, show the  commit{\textquotesingle}s \hyperlink{202290709580230708}{\texttt{GitHash}} instead of throwing an error (the default behavior).

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L18}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6319202671460827960}{} 
\hyperlink{6319202671460827960}{\texttt{LibGit2.DescribeFormatOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.DescribeFormatOptions
\end{minted}

Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_describe\_format\_options}{\texttt{git\_describe\_format\_options}} struct.

The fields represent:

\begin{itemize}
\item \texttt{version}: version of the struct in use, in case this changes later. For now, always \texttt{1}.


\item \texttt{abbreviated\_size}: lower bound on the size of the abbreviated \texttt{GitHash} to use, defaulting to \texttt{7}.


\item \texttt{always\_use\_long\_format}: set to \texttt{1} to use the long format for strings even if a short format can be used.


\item \texttt{dirty\_suffix}: if set, this will be appended to the end of the description string if the \hyperlink{6689577338311178757}{\texttt{workdir}} is dirty.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L10}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9789233943804285928}{} 
\hyperlink{9789233943804285928}{\texttt{LibGit2.DiffDelta}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.DiffDelta
\end{minted}

Description of changes to one entry. Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_diff\_delta}{\texttt{git\_diff\_delta}} struct.

The fields represent:

\begin{itemize}
\item \texttt{status}: One of \texttt{Consts.DELTA\_STATUS}, indicating whether the file has been added/modified/deleted.


\item \texttt{flags}: Flags for the delta and the objects on each side. Determines whether to treat the file(s)  as binary/text, whether they exist on each side of the diff, and whether the object ids are known  to be correct.


\item \texttt{similarity}: Used to indicate if a file has been renamed or copied.


\item \texttt{nfiles}: The number of files in the delta (for instance, if the delta  was run on a submodule commit id, it may contain more than one file).


\item \texttt{old\_file}: A \hyperlink{18417152281461649554}{\texttt{DiffFile}} containing information about the file(s) before the changes.


\item \texttt{new\_file}: A \hyperlink{18417152281461649554}{\texttt{DiffFile}} containing information about the file(s) after the changes.

\end{itemize}


\end{adjustwidth}
\hypertarget{18417152281461649554}{} 
\hyperlink{18417152281461649554}{\texttt{LibGit2.DiffFile}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.DiffFile
\end{minted}

Description of one side of a delta. Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_diff\_file}{\texttt{git\_diff\_file}} struct.

The fields represent:

\begin{itemize}
\item \texttt{id}: the \hyperlink{202290709580230708}{\texttt{GitHash}} of the item in the diff. If the item is empty on this  side of the diff (for instance, if the diff is of the removal of a file), this will  be \texttt{GitHash(0)}.


\item \texttt{path}: a \texttt{NULL} terminated path to the item relative to the working directory of the repository.


\item \texttt{size}: the size of the item in bytes.


\item \texttt{flags}: a combination of the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_diff\_flag\_t}{\texttt{git\_diff\_flag\_t}}  flags. The \texttt{i}th bit of this integer sets the \texttt{i}th flag.


\item \texttt{mode}: the \hyperlink{10861694406169986183}{\texttt{stat}} mode for the item.


\item \texttt{id\_abbrev}: only present in LibGit2 versions newer than or equal to \texttt{0.25.0}.  The length of the \texttt{id} field when converted using \hyperlink{7919678712989769360}{\texttt{string}}. Usually equal to \texttt{OID\_HEXSZ} (40).

\end{itemize}


\end{adjustwidth}
\hypertarget{12061588653487632733}{} 
\hyperlink{12061588653487632733}{\texttt{LibGit2.DiffOptionsStruct}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.DiffOptionsStruct
\end{minted}

Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_diff\_options}{\texttt{git\_diff\_options}} struct.

The fields represent:

\begin{itemize}
\item \texttt{version}: version of the struct in use, in case this changes later. For now, always \texttt{1}.


\item \texttt{flags}: flags controlling which files will appear in the diff. Defaults to \texttt{DIFF\_NORMAL}.


\item \texttt{ignore\_submodules}: whether to look at files in submodules or not. Defaults to \texttt{SUBMODULE\_IGNORE\_UNSPECIFIED}, which means the submodule{\textquotesingle}s configuration will control  whether it appears in the diff or not.


\item \texttt{pathspec}: path to files to include in the diff. Default is to use all files in the repository.


\item \texttt{notify\_cb}: optional callback which will notify the user of changes to the diff as file deltas are  added to it.


\item \texttt{progress\_cb}: optional callback which will display diff progress. Only relevant on libgit2 versions  at least as new as 0.24.0.


\item \texttt{payload}: the payload to pass to \texttt{notify\_cb} and \texttt{progress\_cb}.


\item \texttt{context\_lines}: the number of \emph{unchanged} lines used to define the edges of a hunk.  This is also the number of lines which will be shown before/after a hunk to provide  context. Default is 3.


\item \texttt{interhunk\_lines}: the maximum number of \emph{unchanged} lines \emph{between} two separate  hunks allowed before the hunks will be combined. Default is 0.


\item \texttt{id\_abbrev}: sets the length of the abbreviated \hyperlink{202290709580230708}{\texttt{GitHash}} to print.  Default is \texttt{7}.


\item \texttt{max\_size}: the maximum file size of a blob. Above this size, it will be treated  as a binary blob. The default is 512 MB.


\item \texttt{old\_prefix}: the virtual file directory in which to place old files on one side  of the diff. Default is \texttt{{\textquotedbl}a{\textquotedbl}}.


\item \texttt{new\_prefix}: the virtual file directory in which to place new files on one side  of the diff. Default is \texttt{{\textquotedbl}b{\textquotedbl}}.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L30}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17806809481919147110}{} 
\hyperlink{17806809481919147110}{\texttt{LibGit2.FetchHead}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.FetchHead
\end{minted}

Contains the information about HEAD during a fetch, including the name and URL of the branch fetched from, the oid of the HEAD, and whether the fetched HEAD has been merged locally.

The fields represent:

\begin{itemize}
\item \texttt{name}: The name in the local reference database of the fetch head, for example,  \texttt{{\textquotedbl}refs/heads/master{\textquotedbl}}.


\item \texttt{url}: The URL of the fetch head.


\item \texttt{oid}: The \hyperlink{202290709580230708}{\texttt{GitHash}} of the tip of the fetch head.


\item \texttt{ismerge}: Boolean flag indicating whether the changes at the  remote have been merged into the local copy yet or not. If \texttt{true}, the local  copy is up to date with the remote fetch head.

\end{itemize}


\end{adjustwidth}
\hypertarget{7474664468985945267}{} 
\hyperlink{7474664468985945267}{\texttt{LibGit2.FetchOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.FetchOptions
\end{minted}

Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_fetch\_options}{\texttt{git\_fetch\_options}} struct.

The fields represent:

\begin{itemize}
\item \texttt{version}: version of the struct in use, in case this changes later. For now, always \texttt{1}.


\item \texttt{callbacks}: remote callbacks to use during the fetch.


\item \texttt{prune}: whether to perform a prune after the fetch or not. The default is to  use the setting from the \texttt{GitConfig}.


\item \texttt{update\_fetchhead}: whether to update the \hyperlink{17806809481919147110}{\texttt{FetchHead}} after the fetch.  The default is to perform the update, which is the normal git behavior.


\item \texttt{download\_tags}: whether to download tags present at the remote or not. The default  is to request the tags for objects which are being downloaded anyway from the server.


\item \texttt{proxy\_opts}: options for connecting to the remote through a proxy. See \hyperlink{1179613637206861638}{\texttt{ProxyOptions}}.  Only present on libgit2 versions newer than or equal to 0.25.0.


\item \texttt{custom\_headers}: any extra headers needed for the fetch. Only present on libgit2 versions  newer than or equal to 0.24.0.

\end{itemize}


\end{adjustwidth}
\hypertarget{9263689983564368210}{} 
\hyperlink{9263689983564368210}{\texttt{LibGit2.GitAnnotated}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GitAnnotated(repo::GitRepo, commit_id::GitHash)
GitAnnotated(repo::GitRepo, ref::GitReference)
GitAnnotated(repo::GitRepo, fh::FetchHead)
GitAnnotated(repo::GitRepo, comittish::AbstractString)
\end{minted}

An annotated git commit carries with it information about how it was looked up and why, so that rebase or merge operations have more information about the context of the commit. Conflict files contain information about the source/target branches in the merge which are conflicting, for instance. An annotated commit can refer to the tip of a remote branch, for instance when a \hyperlink{17806809481919147110}{\texttt{FetchHead}} is passed, or to a branch head described using \texttt{GitReference}.



\end{adjustwidth}
\hypertarget{11166114255561117709}{} 
\hyperlink{11166114255561117709}{\texttt{LibGit2.GitBlame}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GitBlame(repo::GitRepo, path::AbstractString; options::BlameOptions=BlameOptions())
\end{minted}

Construct a \texttt{GitBlame} object for the file at \texttt{path}, using change information gleaned from the history of \texttt{repo}. The \texttt{GitBlame} object records who changed which chunks of the file when, and how. \texttt{options} controls how to separate the contents of the file and which commits to probe - see \hyperlink{13109557230915215869}{\texttt{BlameOptions}} for more information.



\end{adjustwidth}
\hypertarget{13272891135715880949}{} 
\hyperlink{13272891135715880949}{\texttt{LibGit2.GitBlob}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GitBlob(repo::GitRepo, hash::AbstractGitHash)
GitBlob(repo::GitRepo, spec::AbstractString)
\end{minted}

Return a \texttt{GitBlob} object from \texttt{repo} specified by \texttt{hash}/\texttt{spec}.

\begin{itemize}
\item \texttt{hash} is a full (\texttt{GitHash}) or partial (\texttt{GitShortHash}) hash.


\item \texttt{spec} is a textual specification: see \href{https://git-scm.com/docs/git-rev-parse.html\#\_specifying\_revisions}{the git docs} for a full list.

\end{itemize}


\end{adjustwidth}
\hypertarget{5346527129202716606}{} 
\hyperlink{5346527129202716606}{\texttt{LibGit2.GitCommit}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GitCommit(repo::GitRepo, hash::AbstractGitHash)
GitCommit(repo::GitRepo, spec::AbstractString)
\end{minted}

Return a \texttt{GitCommit} object from \texttt{repo} specified by \texttt{hash}/\texttt{spec}.

\begin{itemize}
\item \texttt{hash} is a full (\texttt{GitHash}) or partial (\texttt{GitShortHash}) hash.


\item \texttt{spec} is a textual specification: see \href{https://git-scm.com/docs/git-rev-parse.html\#\_specifying\_revisions}{the git docs} for a full list.

\end{itemize}


\end{adjustwidth}
\hypertarget{202290709580230708}{} 
\hyperlink{202290709580230708}{\texttt{LibGit2.GitHash}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GitHash
\end{minted}

A git object identifier, based on the sha-1 hash. It is a 20 byte string (40 hex digits) used to identify a \texttt{GitObject} in a repository.



\end{adjustwidth}
\hypertarget{4668198389828625678}{} 
\hyperlink{4668198389828625678}{\texttt{LibGit2.GitObject}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GitObject(repo::GitRepo, hash::AbstractGitHash)
GitObject(repo::GitRepo, spec::AbstractString)
\end{minted}

Return the specified object (\hyperlink{5346527129202716606}{\texttt{GitCommit}}, \hyperlink{13272891135715880949}{\texttt{GitBlob}}, \hyperlink{6242150303858692069}{\texttt{GitTree}} or \hyperlink{10467695058580020738}{\texttt{GitTag}}) from \texttt{repo} specified by \texttt{hash}/\texttt{spec}.

\begin{itemize}
\item \texttt{hash} is a full (\texttt{GitHash}) or partial (\texttt{GitShortHash}) hash.


\item \texttt{spec} is a textual specification: see \href{https://git-scm.com/docs/git-rev-parse.html\#\_specifying\_revisions}{the git docs} for a full list.

\end{itemize}


\end{adjustwidth}
\hypertarget{9925970107179782013}{} 
\hyperlink{9925970107179782013}{\texttt{LibGit2.GitRemote}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GitRemote(repo::GitRepo, rmt_name::AbstractString, rmt_url::AbstractString) -> GitRemote
\end{minted}

Look up a remote git repository using its name and URL. Uses the default fetch refspec.

\textbf{Examples}


\begin{minted}{julia}
repo = LibGit2.init(repo_path)
remote = LibGit2.GitRemote(repo, "upstream", repo_url)
\end{minted}




\begin{lstlisting}
GitRemote(repo::GitRepo, rmt_name::AbstractString, rmt_url::AbstractString, fetch_spec::AbstractString) -> GitRemote
\end{lstlisting}

Look up a remote git repository using the repository{\textquotesingle}s name and URL, as well as specifications for how to fetch from the remote (e.g. which remote branch to fetch from).

\textbf{Examples}


\begin{minted}{julia}
repo = LibGit2.init(repo_path)
refspec = "+refs/heads/mybranch:refs/remotes/origin/mybranch"
remote = LibGit2.GitRemote(repo, "upstream", repo_url, refspec)
\end{minted}



\end{adjustwidth}
\hypertarget{13915605113589562056}{} 
\hyperlink{13915605113589562056}{\texttt{LibGit2.GitRemoteAnon}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GitRemoteAnon(repo::GitRepo, url::AbstractString) -> GitRemote
\end{minted}

Look up a remote git repository using only its URL, not its name.

\textbf{Examples}


\begin{minted}{julia}
repo = LibGit2.init(repo_path)
remote = LibGit2.GitRemoteAnon(repo, repo_url)
\end{minted}



\end{adjustwidth}
\hypertarget{3263346103236484748}{} 
\hyperlink{3263346103236484748}{\texttt{LibGit2.GitRepo}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.GitRepo(path::AbstractString)
\end{minted}

Open a git repository at \texttt{path}.



\end{adjustwidth}
\hypertarget{11364757486103041711}{} 
\hyperlink{11364757486103041711}{\texttt{LibGit2.GitRepoExt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.GitRepoExt(path::AbstractString, flags::Cuint = Cuint(Consts.REPOSITORY_OPEN_DEFAULT))
\end{minted}

Open a git repository at \texttt{path} with extended controls (for instance, if the current user must be a member of a special access group to read \texttt{path}).



\end{adjustwidth}
\hypertarget{7800294839307043628}{} 
\hyperlink{7800294839307043628}{\texttt{LibGit2.GitRevWalker}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GitRevWalker(repo::GitRepo)
\end{minted}

A \texttt{GitRevWalker} \emph{walks} through the \emph{revisions} (i.e. commits) of a git repository \texttt{repo}. It is a collection of the commits in the repository, and supports iteration and calls to \hyperlink{546421066875217314}{\texttt{map}} and \hyperlink{3202007276139600178}{\texttt{count}} (for instance, \texttt{count} could be used to determine what percentage of commits in a repository were made by a certain author).


\begin{minted}{julia}
cnt = LibGit2.with(LibGit2.GitRevWalker(repo)) do walker
    count((oid,repo)->(oid == commit_oid1), walker, oid=commit_oid1, by=LibGit2.Consts.SORT_TIME)
end
\end{minted}

Here, \texttt{count} finds the number of commits along the walk with a certain \texttt{GitHash}. Since the \texttt{GitHash} is unique to a commit, \texttt{cnt} will be \texttt{1}.



\end{adjustwidth}
\hypertarget{3676458372916825224}{} 
\hyperlink{3676458372916825224}{\texttt{LibGit2.GitShortHash}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GitShortHash(hash::GitHash, len::Integer)
\end{minted}

A shortened git object identifier, which can be used to identify a git object when it is unique, consisting of the initial \texttt{len} hexadecimal digits of \texttt{hash} (the remaining digits are ignored).



\end{adjustwidth}
\hypertarget{16780673881553092129}{} 
\hyperlink{16780673881553092129}{\texttt{LibGit2.GitSignature}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.GitSignature
\end{minted}

This is a Julia wrapper around a pointer to a \href{https://libgit2.org/libgit2/\#HEAD/type/git\_signature}{\texttt{git\_signature}} object.



\end{adjustwidth}
\hypertarget{5023272497907128319}{} 
\hyperlink{5023272497907128319}{\texttt{LibGit2.GitStatus}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.GitStatus(repo::GitRepo; status_opts=StatusOptions())
\end{minted}

Collect information about the status of each file in the git repository \texttt{repo} (e.g. is the file modified, staged, etc.). \texttt{status\_opts} can be used to set various options, for instance whether or not to look at untracked files or whether to include submodules or not. See \hyperlink{15761804013497693135}{\texttt{StatusOptions}} for more information.



\end{adjustwidth}
\hypertarget{10467695058580020738}{} 
\hyperlink{10467695058580020738}{\texttt{LibGit2.GitTag}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GitTag(repo::GitRepo, hash::AbstractGitHash)
GitTag(repo::GitRepo, spec::AbstractString)
\end{minted}

Return a \texttt{GitTag} object from \texttt{repo} specified by \texttt{hash}/\texttt{spec}.

\begin{itemize}
\item \texttt{hash} is a full (\texttt{GitHash}) or partial (\texttt{GitShortHash}) hash.


\item \texttt{spec} is a textual specification: see \href{https://git-scm.com/docs/git-rev-parse.html\#\_specifying\_revisions}{the git docs} for a full list.

\end{itemize}


\end{adjustwidth}
\hypertarget{6242150303858692069}{} 
\hyperlink{6242150303858692069}{\texttt{LibGit2.GitTree}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GitTree(repo::GitRepo, hash::AbstractGitHash)
GitTree(repo::GitRepo, spec::AbstractString)
\end{minted}

Return a \texttt{GitTree} object from \texttt{repo} specified by \texttt{hash}/\texttt{spec}.

\begin{itemize}
\item \texttt{hash} is a full (\texttt{GitHash}) or partial (\texttt{GitShortHash}) hash.


\item \texttt{spec} is a textual specification: see \href{https://git-scm.com/docs/git-rev-parse.html\#\_specifying\_revisions}{the git docs} for a full list.

\end{itemize}


\end{adjustwidth}
\hypertarget{2169451189682045075}{} 
\hyperlink{2169451189682045075}{\texttt{LibGit2.IndexEntry}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.IndexEntry
\end{minted}

In-memory representation of a file entry in the index. Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_index\_entry}{\texttt{git\_index\_entry}} struct.



\end{adjustwidth}
\hypertarget{13894240843968539685}{} 
\hyperlink{13894240843968539685}{\texttt{LibGit2.IndexTime}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.IndexTime
\end{minted}

Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_index\_time}{\texttt{git\_index\_time}} struct.



\end{adjustwidth}
\hypertarget{13109557230915215869}{} 
\hyperlink{13109557230915215869}{\texttt{LibGit2.BlameOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.BlameOptions
\end{minted}

Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_blame\_options}{\texttt{git\_blame\_options}} struct.

The fields represent:

\begin{itemize}
\item \texttt{version}: version of the struct in use, in case this changes later. For now, always \texttt{1}.


\item \texttt{flags}: one of \texttt{Consts.BLAME\_NORMAL} or \texttt{Consts.BLAME\_FIRST\_PARENT} (the other blame flags  are not yet implemented by libgit2).


\item \texttt{min\_match\_characters}: the minimum number of \emph{alphanumeric} characters which much change in a commit in order for the change to be associated with that commit. The default is 20. Only takes effect if one of the \texttt{Consts.BLAME\_*\_COPIES} flags are used, which libgit2 does not implement yet.


\item \texttt{newest\_commit}: the \hyperlink{202290709580230708}{\texttt{GitHash}} of the newest commit from which to look at changes.


\item \texttt{oldest\_commit}: the \hyperlink{202290709580230708}{\texttt{GitHash}} of the oldest commit from which to look at changes.


\item \texttt{min\_line}: the first line of the file from which to starting blaming. The default is \texttt{1}.


\item \texttt{max\_line}: the last line of the file to which to blame. The default is \texttt{0}, meaning the last line of the file.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L18}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7663922722360889557}{} 
\hyperlink{7663922722360889557}{\texttt{LibGit2.MergeOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.MergeOptions
\end{minted}

Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_merge\_options}{\texttt{git\_merge\_options}} struct.

The fields represent:

\begin{itemize}
\item \texttt{version}: version of the struct in use, in case this changes later. For now, always \texttt{1}.


\item \texttt{flags}: an \texttt{enum} for flags describing merge behavior.  Defined in \href{https://github.com/libgit2/libgit2/blob/HEAD/include/git2/merge.h\#L95}{\texttt{git\_merge\_flag\_t}}.  The corresponding Julia enum is \texttt{GIT\_MERGE} and has values:

\begin{itemize}
\item \texttt{MERGE\_FIND\_RENAMES}: detect if a file has been renamed between the common ancestor and the {\textquotedbl}ours{\textquotedbl} or {\textquotedbl}theirs{\textquotedbl} side of the merge. Allows merges where a file has been renamed.


\item \texttt{MERGE\_FAIL\_ON\_CONFLICT}: exit immediately if a conflict is found rather than trying to resolve it.


\item \texttt{MERGE\_SKIP\_REUC}: do not write the REUC extension on the index resulting from the merge.


\item \texttt{MERGE\_NO\_RECURSIVE}: if the commits being merged have multiple merge bases, use the first one, rather than trying to recursively merge the bases.

\end{itemize}

\item \texttt{rename\_threshold}: how similar two files must to consider one a rename of the other. This is an integer that sets the percentage similarity. The default is 50.


\item \texttt{target\_limit}: the maximum number of files to compare with to look for renames. The default is 200.


\item \texttt{metric}: optional custom function to use to determine the similarity between two files for rename detection.


\item \texttt{recursion\_limit}: the upper limit on the number of merges of common ancestors to perform to try to build a new virtual merge base for the merge. The default is no limit. This field is only present on libgit2 versions newer than 0.24.0.


\item \texttt{default\_driver}: the merge driver to use if both sides have changed. This field is only present on libgit2 versions newer than 0.25.0.


\item \texttt{file\_favor}: how to handle conflicting file contents for the \texttt{text} driver.

\begin{itemize}
\item \texttt{MERGE\_FILE\_FAVOR\_NORMAL}: if both sides of the merge have changes to a section,  make a note of the conflict in the index which \texttt{git checkout} will use to create  a merge file, which the user can then reference to resolve the conflicts. This is  the default.


\item \texttt{MERGE\_FILE\_FAVOR\_OURS}: if both sides of the merge have changes to a section,  use the version in the {\textquotedbl}ours{\textquotedbl} side of the merge in the index.


\item \texttt{MERGE\_FILE\_FAVOR\_THEIRS}: if both sides of the merge have changes to a section,  use the version in the {\textquotedbl}theirs{\textquotedbl} side of the merge in the index.


\item \texttt{MERGE\_FILE\_FAVOR\_UNION}: if both sides of the merge have changes to a section,  include each unique line from both sides in the file which is put into the index.

\end{itemize}

\item \texttt{file\_flags}: guidelines for merging files.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L42}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1179613637206861638}{} 
\hyperlink{1179613637206861638}{\texttt{LibGit2.ProxyOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.ProxyOptions
\end{minted}

Options for connecting through a proxy.

Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_proxy\_options}{\texttt{git\_proxy\_options}} struct.

The fields represent:

\begin{itemize}
\item \texttt{version}: version of the struct in use, in case this changes later. For now, always \texttt{1}.


\item \texttt{proxytype}: an \texttt{enum} for the type of proxy to use.  Defined in \href{https://libgit2.org/libgit2/\#HEAD/type/git\_proxy\_t}{\texttt{git\_proxy\_t}}.  The corresponding Julia enum is \texttt{GIT\_PROXY} and has values:

\begin{itemize}
\item \texttt{PROXY\_NONE}: do not attempt the connection through a proxy.


\item \texttt{PROXY\_AUTO}: attempt to figure out the proxy configuration from the git configuration.


\item \texttt{PROXY\_SPECIFIED}: connect using the URL given in the \texttt{url} field of this struct.

\end{itemize}
Default is to auto-detect the proxy type.


\item \texttt{url}: the URL of the proxy.


\item \texttt{credential\_cb}: a pointer to a callback function which will be called if the remote requires authentication to connect.


\item \texttt{certificate\_cb}: a pointer to a callback function which will be called if certificate verification fails. This lets the user decide whether or not to keep connecting. If the function returns \texttt{1}, connecting will be allowed. If it returns \texttt{0}, the connection will not be allowed. A negative value can be used to return errors.


\item \texttt{payload}: the payload to be provided to the two callback functions.

\end{itemize}
\textbf{Examples}


\begin{minted}{jlcon}
julia> fo = LibGit2.FetchOptions(
           proxy_opts = LibGit2.ProxyOptions(url = Cstring("https://my_proxy_url.com")))

julia> fetch(remote, "master", options=fo)
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L32}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13899785564428555533}{} 
\hyperlink{13899785564428555533}{\texttt{LibGit2.PushOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.PushOptions
\end{minted}

Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_push\_options}{\texttt{git\_push\_options}} struct.

The fields represent:

\begin{itemize}
\item \texttt{version}: version of the struct in use, in case this changes later. For now, always \texttt{1}.


\item \texttt{parallelism}: if a pack file must be created, this variable sets the number of worker  threads which will be spawned by the packbuilder. If \texttt{0}, the packbuilder will auto-set  the number of threads to use. The default is \texttt{1}.


\item \texttt{callbacks}: the callbacks (e.g. for authentication with the remote) to use for the push.


\item \texttt{proxy\_opts}: only relevant if the LibGit2 version is greater than or equal to \texttt{0.25.0}.  Sets options for using a proxy to communicate with a remote. See \hyperlink{1179613637206861638}{\texttt{ProxyOptions}}  for more information.


\item \texttt{custom\_headers}: only relevant if the LibGit2 version is greater than or equal to \texttt{0.24.0}.  Extra headers needed for the push operation.

\end{itemize}


\end{adjustwidth}
\hypertarget{4600807719307889860}{} 
\hyperlink{4600807719307889860}{\texttt{LibGit2.RebaseOperation}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.RebaseOperation
\end{minted}

Describes a single instruction/operation to be performed during the rebase. Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_rebase\_operation\_t}{\texttt{git\_rebase\_operation}} struct.

The fields represent:

\begin{itemize}
\item \texttt{optype}: the type of rebase operation currently being performed. The options are:

\begin{itemize}
\item \texttt{REBASE\_OPERATION\_PICK}: cherry-pick the commit in question.


\item \texttt{REBASE\_OPERATION\_REWORD}: cherry-pick the commit in question, but rewrite its message using the prompt.


\item \texttt{REBASE\_OPERATION\_EDIT}: cherry-pick the commit in question, but allow the user to edit the commit{\textquotesingle}s contents and its message.


\item \texttt{REBASE\_OPERATION\_SQUASH}: squash the commit in question into the previous commit. The commit messages of the two commits will be merged.


\item \texttt{REBASE\_OPERATION\_FIXUP}: squash the commit in question into the previous commit. Only the commit message of the previous commit will be used.


\item \texttt{REBASE\_OPERATION\_EXEC}: do not cherry-pick a commit. Run a command and continue if the command exits successfully.

\end{itemize}

\item \texttt{id}: the \hyperlink{202290709580230708}{\texttt{GitHash}} of the commit being worked on during this rebase step.


\item \texttt{exec}: in case \texttt{REBASE\_OPERATION\_EXEC} is used, the command to run during this step (for instance, running the test suite after each commit).

\end{itemize}


\end{adjustwidth}
\hypertarget{9347726754162781322}{} 
\hyperlink{9347726754162781322}{\texttt{LibGit2.RebaseOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.RebaseOptions
\end{minted}

Matches the \texttt{git\_rebase\_options} struct.

The fields represent:

\begin{itemize}
\item \texttt{version}: version of the struct in use, in case this changes later. For now, always \texttt{1}.


\item \texttt{quiet}: inform other git clients helping with/working on the rebase that the rebase should be done {\textquotedbl}quietly{\textquotedbl}. Used for interoperability. The default is \texttt{1}.


\item \texttt{inmemory}: start an in-memory rebase. Callers working on the rebase can go through its steps and commit any changes, but cannot rewind HEAD or update the repository. The \hyperlink{6689577338311178757}{\texttt{workdir}} will not be modified. Only present on libgit2 versions newer than or equal to 0.24.0.


\item \texttt{rewrite\_notes\_ref}: name of the reference to notes to use to rewrite the commit notes as the rebase is finished.


\item \texttt{merge\_opts}: merge options controlling how the trees will be merged at each rebase step.  Only present on libgit2 versions newer than or equal to 0.24.0.


\item \texttt{checkout\_opts}: checkout options for writing files when initializing the rebase, stepping through it, and aborting it. See \hyperlink{16441061243067746546}{\texttt{CheckoutOptions}} for more information.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L18}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5220283667301575523}{} 
\hyperlink{5220283667301575523}{\texttt{LibGit2.RemoteCallbacks}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.RemoteCallbacks
\end{minted}

Callback settings. Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_remote\_callbacks}{\texttt{git\_remote\_callbacks}} struct.



\end{adjustwidth}
\hypertarget{8598007626850742967}{} 
\hyperlink{8598007626850742967}{\texttt{LibGit2.SignatureStruct}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.SignatureStruct
\end{minted}

An action signature (e.g. for committers, taggers, etc). Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_signature}{\texttt{git\_signature}} struct.

The fields represent:

\begin{itemize}
\item \texttt{name}: The full name of the committer or author of the commit.


\item \texttt{email}: The email at which the committer/author can be contacted.


\item \texttt{when}: a \hyperlink{11932909532186040994}{\texttt{TimeStruct}} indicating when the commit was  authored/committed into the repository.

\end{itemize}


\end{adjustwidth}
\hypertarget{16035791715224568905}{} 
\hyperlink{16035791715224568905}{\texttt{LibGit2.StatusEntry}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.StatusEntry
\end{minted}

Providing the differences between the file as it exists in HEAD and the index, and providing the differences between the index and the working directory. Matches the \texttt{git\_status\_entry} struct.

The fields represent:

\begin{itemize}
\item \texttt{status}: contains the status flags for the file, indicating if it is current, or has been changed in some way in the index or work tree.


\item \texttt{head\_to\_index}: a pointer to a \hyperlink{9789233943804285928}{\texttt{DiffDelta}} which encapsulates the difference(s) between the file as it exists in HEAD and in the index.


\item \texttt{index\_to\_workdir}: a pointer to a \texttt{DiffDelta} which encapsulates the difference(s) between the file as it exists in the index and in the \hyperlink{6689577338311178757}{\texttt{workdir}}.

\end{itemize}


\end{adjustwidth}
\hypertarget{15761804013497693135}{} 
\hyperlink{15761804013497693135}{\texttt{LibGit2.StatusOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.StatusOptions
\end{minted}

Options to control how \texttt{git\_status\_foreach\_ext()} will issue callbacks. Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_status\_opt\_t}{\texttt{git\_status\_opt\_t}} struct.

The fields represent:

\begin{itemize}
\item \texttt{version}: version of the struct in use, in case this changes later. For now, always \texttt{1}.


\item \texttt{show}: a flag for which files to examine and in which order. The default is \texttt{Consts.STATUS\_SHOW\_INDEX\_AND\_WORKDIR}.


\item \texttt{flags}: flags for controlling any callbacks used in a status call.


\item \texttt{pathspec}: an array of paths to use for path-matching. The behavior of the path-matching will vary depending on the values of \texttt{show} and \texttt{flags}.


\item The \texttt{baseline} is the tree to be used for comparison to the working directory and index; defaults to HEAD.

\end{itemize}


\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L15}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10686064701005230750}{} 
\hyperlink{10686064701005230750}{\texttt{LibGit2.StrArrayStruct}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.StrArrayStruct
\end{minted}

A LibGit2 representation of an array of strings. Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_strarray}{\texttt{git\_strarray}} struct.

When fetching data from LibGit2, a typical usage would look like:


\begin{minted}{julia}
sa_ref = Ref(StrArrayStruct())
@check ccall(..., (Ptr{StrArrayStruct},), sa_ref)
res = convert(Vector{String}, sa_ref[])
free(sa_ref)
\end{minted}

In particular, note that \texttt{LibGit2.free} should be called afterward on the \texttt{Ref} object.

Conversely, when passing a vector of strings to LibGit2, it is generally simplest to rely on implicit conversion:


\begin{minted}{julia}
strs = String[...]
@check ccall(..., (Ptr{StrArrayStruct},), strs)
\end{minted}

Note that no call to \texttt{free} is required as the data is allocated by Julia.



\end{adjustwidth}
\hypertarget{11932909532186040994}{} 
\hyperlink{11932909532186040994}{\texttt{LibGit2.TimeStruct}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.TimeStruct
\end{minted}

Time in a signature. Matches the \href{https://libgit2.org/libgit2/\#HEAD/type/git\_time}{\texttt{git\_time}} struct.



\end{adjustwidth}
\hypertarget{16270901697937111000}{} 
\hyperlink{16270901697937111000}{\texttt{LibGit2.add!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
add!(repo::GitRepo, files::AbstractString...; flags::Cuint = Consts.INDEX_ADD_DEFAULT)
add!(idx::GitIndex, files::AbstractString...; flags::Cuint = Consts.INDEX_ADD_DEFAULT)
\end{minted}

Add all the files with paths specified by \texttt{files} to the index \texttt{idx} (or the index of the \texttt{repo}). If the file already exists, the index entry will be updated. If the file does not exist already, it will be newly added into the index. \texttt{files} may contain glob patterns which will be expanded and any matching files will be added (unless \texttt{INDEX\_ADD\_DISABLE\_PATHSPEC\_MATCH} is set, see below). If a file has been ignored (in \texttt{.gitignore} or in the config), it \emph{will not} be added, \emph{unless} it is already being tracked in the index, in which case it \emph{will} be updated. The keyword argument \texttt{flags} is a set of bit-flags which control the behavior with respect to ignored files:

\begin{itemize}
\item \texttt{Consts.INDEX\_ADD\_DEFAULT} - default, described above.


\item \texttt{Consts.INDEX\_ADD\_FORCE} - disregard the existing ignore rules and force addition of the file to the index even if it is already ignored.


\item \texttt{Consts.INDEX\_ADD\_CHECK\_PATHSPEC} - cannot be used at the same time as \texttt{INDEX\_ADD\_FORCE}. Check that each file in \texttt{files} which exists on disk is not in the ignore list. If one of the files \emph{is} ignored, the function will return \texttt{EINVALIDSPEC}.


\item \texttt{Consts.INDEX\_ADD\_DISABLE\_PATHSPEC\_MATCH} - turn off glob matching, and only add files to the index which exactly match the paths specified in \texttt{files}.

\end{itemize}


\end{adjustwidth}
\hypertarget{6981412809211295791}{} 
\hyperlink{6981412809211295791}{\texttt{LibGit2.add\_fetch!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
add_fetch!(repo::GitRepo, rmt::GitRemote, fetch_spec::String)
\end{minted}

Add a \emph{fetch} refspec for the specified \texttt{rmt}. This refspec will contain information about which branch(es) to fetch from.

\textbf{Examples}


\begin{minted}{jlcon}
julia> LibGit2.add_fetch!(repo, remote, "upstream");

julia> LibGit2.fetch_refspecs(remote)
String["+refs/heads/*:refs/remotes/upstream/*"]
\end{minted}



\end{adjustwidth}
\hypertarget{2424007891894294055}{} 
\hyperlink{2424007891894294055}{\texttt{LibGit2.add\_push!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
add_push!(repo::GitRepo, rmt::GitRemote, push_spec::String)
\end{minted}

Add a \emph{push} refspec for the specified \texttt{rmt}. This refspec will contain information about which branch(es) to push to.

\textbf{Examples}


\begin{minted}{jlcon}
julia> LibGit2.add_push!(repo, remote, "refs/heads/master");

julia> remote = LibGit2.get(LibGit2.GitRemote, repo, branch);

julia> LibGit2.push_refspecs(remote)
String["refs/heads/master"]
\end{minted}

\begin{quote}
\textbf{Note}

You may need to \hyperlink{5331333469799487255}{\texttt{close}} and reopen the \texttt{GitRemote} in question after updating its push refspecs in order for the change to take effect and for calls to \hyperlink{9401118176170322302}{\texttt{push}} to work.

\end{quote}


\end{adjustwidth}
\hypertarget{12021530861844417654}{} 
\hyperlink{12021530861844417654}{\texttt{LibGit2.addblob!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.addblob!(repo::GitRepo, path::AbstractString)
\end{minted}

Read the file at \texttt{path} and adds it to the object database of \texttt{repo} as a loose blob. Return the \hyperlink{202290709580230708}{\texttt{GitHash}} of the resulting blob.

\textbf{Examples}


\begin{minted}{julia}
hash_str = string(commit_oid)
blob_file = joinpath(repo_path, ".git", "objects", hash_str[1:2], hash_str[3:end])
id = LibGit2.addblob!(repo, blob_file)
\end{minted}



\end{adjustwidth}
\hypertarget{7024880280540966409}{} 
\hyperlink{7024880280540966409}{\texttt{LibGit2.author}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
author(c::GitCommit)
\end{minted}

Return the \texttt{Signature} of the author of the commit \texttt{c}. The author is the person who made changes to the relevant file(s). See also \hyperlink{4819166445750615913}{\texttt{committer}}.



\end{adjustwidth}
\hypertarget{13671452176500407122}{} 
\hyperlink{13671452176500407122}{\texttt{LibGit2.authors}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
authors(repo::GitRepo) -> Vector{Signature}
\end{minted}

Return all authors of commits to the \texttt{repo} repository.

\textbf{Examples}


\begin{minted}{julia}
repo = LibGit2.GitRepo(repo_path)
repo_file = open(joinpath(repo_path, test_file), "a")

println(repo_file, commit_msg)
flush(repo_file)
LibGit2.add!(repo, test_file)
sig = LibGit2.Signature("TEST", "TEST@TEST.COM", round(time(), 0), 0)
commit_oid1 = LibGit2.commit(repo, "commit1"; author=sig, committer=sig)
println(repo_file, randstring(10))
flush(repo_file)
LibGit2.add!(repo, test_file)
commit_oid2 = LibGit2.commit(repo, "commit2"; author=sig, committer=sig)

# will be a Vector of [sig, sig]
auths = LibGit2.authors(repo)
\end{minted}



\end{adjustwidth}
\hypertarget{17976386758924249721}{} 
\hyperlink{17976386758924249721}{\texttt{LibGit2.branch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
branch(repo::GitRepo)
\end{minted}

Equivalent to \texttt{git branch}. Create a new branch from the current HEAD.



\end{adjustwidth}
\hypertarget{10282470573382896007}{} 
\hyperlink{10282470573382896007}{\texttt{LibGit2.branch!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
branch!(repo::GitRepo, branch_name::AbstractString, commit::AbstractString=""; kwargs...)
\end{minted}

Checkout a new git branch in the \texttt{repo} repository. \texttt{commit} is the \hyperlink{202290709580230708}{\texttt{GitHash}}, in string form, which will be the start of the new branch. If \texttt{commit} is an empty string, the current HEAD will be used.

The keyword arguments are:

\begin{itemize}
\item \texttt{track::AbstractString={\textquotedbl}{\textquotedbl}}: the name of the remote branch this new branch should track, if any. If empty (the default), no remote branch will be tracked.


\item \texttt{force::Bool=false}: if \texttt{true}, branch creation will be forced.


\item \texttt{set\_head::Bool=true}: if \texttt{true}, after the branch creation finishes the branch head will be set as the HEAD of \texttt{repo}.

\end{itemize}
Equivalent to \texttt{git checkout [-b|-B] <branch\_name> [<commit>] [--track <track>]}.

\textbf{Examples}


\begin{minted}{julia}
repo = LibGit2.GitRepo(repo_path)
LibGit2.branch!(repo, "new_branch", set_head=false)
\end{minted}



\end{adjustwidth}
\hypertarget{17667204238793225311}{} 
\hyperlink{17667204238793225311}{\texttt{LibGit2.checkout!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
checkout!(repo::GitRepo, commit::AbstractString=""; force::Bool=true)
\end{minted}

Equivalent to \texttt{git checkout [-f] --detach <commit>}. Checkout the git commit \texttt{commit} (a \hyperlink{202290709580230708}{\texttt{GitHash}} in string form) in \texttt{repo}. If \texttt{force} is \texttt{true}, force the checkout and discard any current changes. Note that this detaches the current HEAD.

\textbf{Examples}


\begin{minted}{julia}
repo = LibGit2.init(repo_path)
open(joinpath(LibGit2.path(repo), "file1"), "w") do f
    write(f, "111
")
end
LibGit2.add!(repo, "file1")
commit_oid = LibGit2.commit(repo, "add file1")
open(joinpath(LibGit2.path(repo), "file1"), "w") do f
    write(f, "112
")
end
# would fail without the force=true
# since there are modifications to the file
LibGit2.checkout!(repo, string(commit_oid), force=true)
\end{minted}



\end{adjustwidth}
\hypertarget{7099795087604363090}{} 
\hyperlink{7099795087604363090}{\texttt{LibGit2.clone}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
clone(repo_url::AbstractString, repo_path::AbstractString, clone_opts::CloneOptions)
\end{minted}

Clone the remote repository at \texttt{repo\_url} (which can be a remote URL or a path on the local filesystem) to \texttt{repo\_path} (which must be a path on the local filesystem). Options for the clone, such as whether to perform a bare clone or not, are set by \hyperlink{15963609167797539123}{\texttt{CloneOptions}}.

\textbf{Examples}


\begin{minted}{julia}
repo_url = "https://github.com/JuliaLang/Example.jl"
repo = LibGit2.clone(repo_url, "/home/me/projects/Example")
\end{minted}




\begin{lstlisting}
clone(repo_url::AbstractString, repo_path::AbstractString; kwargs...)
\end{lstlisting}

Clone a remote repository located at \texttt{repo\_url} to the local filesystem location \texttt{repo\_path}.

The keyword arguments are:

\begin{itemize}
\item \texttt{branch::AbstractString={\textquotedbl}{\textquotedbl}}: which branch of the remote to clone, if not the default repository branch (usually \texttt{master}).


\item \texttt{isbare::Bool=false}: if \texttt{true}, clone the remote as a bare repository, which will make \texttt{repo\_path} itself the git directory instead of \texttt{repo\_path/.git}. This means that a working tree cannot be checked out. Plays the role of the git CLI argument \texttt{--bare}.


\item \texttt{remote\_cb::Ptr\{Cvoid\}=C\_NULL}: a callback which will be used to create the remote before it is cloned. If \texttt{C\_NULL} (the default), no attempt will be made to create the remote - it will be assumed to already exist.


\item \texttt{credentials::Creds=nothing}: provides credentials and/or settings when authenticating against a private repository.


\item \texttt{callbacks::Callbacks=Callbacks()}: user provided callbacks and payloads.

\end{itemize}
Equivalent to \texttt{git clone [-b <branch>] [--bare] <repo\_url> <repo\_path>}.

\textbf{Examples}


\begin{minted}{julia}
repo_url = "https://github.com/JuliaLang/Example.jl"
repo1 = LibGit2.clone(repo_url, "test_path")
repo2 = LibGit2.clone(repo_url, "test_path", isbare=true)
julia_url = "https://github.com/JuliaLang/julia"
julia_repo = LibGit2.clone(julia_url, "julia_path", branch="release-0.6")
\end{minted}



\end{adjustwidth}
\hypertarget{9554164652611238018}{} 
\hyperlink{9554164652611238018}{\texttt{LibGit2.commit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
commit(repo::GitRepo, msg::AbstractString; kwargs...) -> GitHash
\end{minted}

Wrapper around \href{https://libgit2.org/libgit2/\#HEAD/group/commit/git\_commit\_create}{\texttt{git\_commit\_create}}. Create a commit in the repository \texttt{repo}. \texttt{msg} is the commit message. Return the OID of the new commit.

The keyword arguments are:

\begin{itemize}
\item \texttt{refname::AbstractString=Consts.HEAD\_FILE}: if not NULL, the name of the reference to update to point to the new commit. For example, \texttt{{\textquotedbl}HEAD{\textquotedbl}} will update the HEAD of the current branch. If the reference does not yet exist, it will be created.


\item \texttt{author::Signature = Signature(repo)} is a \texttt{Signature} containing information about the person who authored the commit.


\item \texttt{committer::Signature = Signature(repo)} is a \texttt{Signature} containing information about the person who committed the commit to the repository. Not necessarily the same as \texttt{author}, for instance if \texttt{author} emailed a patch to \texttt{committer} who committed it.


\item \texttt{tree\_id::GitHash = GitHash()} is a git tree to use to create the commit, showing its ancestry and relationship with any other history. \texttt{tree} must belong to \texttt{repo}.


\item \texttt{parent\_ids::Vector\{GitHash\}=GitHash[]} is a list of commits by \hyperlink{202290709580230708}{\texttt{GitHash}} to use as parent commits for the new one, and may be empty. A commit might have multiple parents if it is a merge commit, for example.

\end{itemize}



\begin{lstlisting}
LibGit2.commit(rb::GitRebase, sig::GitSignature)
\end{lstlisting}

Commit the current patch to the rebase \texttt{rb}, using \texttt{sig} as the committer. Is silent if the commit has already been applied.



\end{adjustwidth}
\hypertarget{4819166445750615913}{} 
\hyperlink{4819166445750615913}{\texttt{LibGit2.committer}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
committer(c::GitCommit)
\end{minted}

Return the \texttt{Signature} of the committer of the commit \texttt{c}. The committer is the person who committed the changes originally authored by the \hyperlink{7024880280540966409}{\texttt{author}}, but need not be the same as the \texttt{author}, for example, if the \texttt{author} emailed a patch to a \texttt{committer} who committed it.



\end{adjustwidth}
\hypertarget{3202007276139600178}{} 
\hyperlink{3202007276139600178}{\texttt{LibGit2.count}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.count(f::Function, walker::GitRevWalker; oid::GitHash=GitHash(), by::Cint=Consts.SORT_NONE, rev::Bool=false)
\end{minted}

Using the \hyperlink{7800294839307043628}{\texttt{GitRevWalker}} \texttt{walker} to {\textquotedbl}walk{\textquotedbl} over every commit in the repository{\textquotesingle}s history, find the number of commits which return \texttt{true} when \texttt{f} is applied to them. The keyword arguments are:     * \texttt{oid}: The \hyperlink{202290709580230708}{\texttt{GitHash}} of the commit to begin the walk from. The default is to use       \hyperlink{9792433728015067335}{\texttt{push\_head!}} and therefore the HEAD commit and all its ancestors.     * \texttt{by}: The sorting method. The default is not to sort. Other options are to sort by       topology (\texttt{LibGit2.Consts.SORT\_TOPOLOGICAL}), to sort forwards in time       (\texttt{LibGit2.Consts.SORT\_TIME}, most ancient first) or to sort backwards in time       (\texttt{LibGit2.Consts.SORT\_REVERSE}, most recent first).     * \texttt{rev}: Whether to reverse the sorted order (for instance, if topological sorting is used).

\textbf{Examples}


\begin{minted}{julia}
cnt = LibGit2.with(LibGit2.GitRevWalker(repo)) do walker
    count((oid, repo)->(oid == commit_oid1), walker, oid=commit_oid1, by=LibGit2.Consts.SORT_TIME)
end
\end{minted}

\texttt{count} finds the number of commits along the walk with a certain \texttt{GitHash} \texttt{commit\_oid1}, starting the walk from that commit and moving forwards in time from it. Since the \texttt{GitHash} is unique to a commit, \texttt{cnt} will be \texttt{1}.



\end{adjustwidth}
\hypertarget{14766056021243867485}{} 
\hyperlink{14766056021243867485}{\texttt{LibGit2.counthunks}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
counthunks(blame::GitBlame)
\end{minted}

Return the number of distinct {\textquotedbl}hunks{\textquotedbl} with a file. A hunk may contain multiple lines. A hunk is usually a piece of a file that was added/changed/removed together, for example, a function added to a source file or an inner loop that was optimized out of that function later.



\end{adjustwidth}
\hypertarget{3632112326305021926}{} 
\hyperlink{3632112326305021926}{\texttt{LibGit2.create\_branch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.create_branch(repo::GitRepo, bname::AbstractString, commit_obj::GitCommit; force::Bool=false)
\end{minted}

Create a new branch in the repository \texttt{repo} with name \texttt{bname}, which points to commit \texttt{commit\_obj} (which has to be part of \texttt{repo}). If \texttt{force} is \texttt{true}, overwrite an existing branch named \texttt{bname} if it exists. If \texttt{force} is \texttt{false} and a branch already exists named \texttt{bname}, this function will throw an error.



\end{adjustwidth}
\hypertarget{14873190507178513691}{} 
\hyperlink{14873190507178513691}{\texttt{LibGit2.credentials\_callback}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
credential_callback(...) -> Cint
\end{minted}

A LibGit2 credential callback function which provides different credential acquisition functionality w.r.t. a connection protocol. The \texttt{payload\_ptr} is required to contain a \texttt{LibGit2.CredentialPayload} object which will keep track of state and settings.

The \texttt{allowed\_types} contains a bitmask of \texttt{LibGit2.Consts.GIT\_CREDTYPE} values specifying which authentication methods should be attempted.

Credential authentication is done in the following order (if supported):

\begin{itemize}
\item SSH agent


\item SSH private/public key pair


\item Username/password plain text

\end{itemize}
If a user is presented with a credential prompt they can abort the prompt by typing \texttt{{\textasciicircum}D} (pressing the control key together with the \texttt{d} key).

\textbf{Note}: Due to the specifics of the \texttt{libgit2} authentication procedure, when authentication fails, this function is called again without any indication whether authentication was successful or not. To avoid an infinite loop from repeatedly using the same faulty credentials, we will keep track of state using the payload.

For addition details see the LibGit2 guide on \href{https://libgit2.org/docs/guides/authentication/}{authenticating against a server}.



\end{adjustwidth}
\hypertarget{9226239310211022593}{} 
\hyperlink{9226239310211022593}{\texttt{LibGit2.credentials\_cb}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

C function pointer for \texttt{credentials\_callback}



\end{adjustwidth}
\hypertarget{4585945206005903475}{} 
\hyperlink{4585945206005903475}{\texttt{LibGit2.default\_signature}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Return signature object. Free it after use.



\end{adjustwidth}
\hypertarget{3338994964608738996}{} 
\hyperlink{3338994964608738996}{\texttt{LibGit2.delete\_branch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.delete_branch(branch::GitReference)
\end{minted}

Delete the branch pointed to by \texttt{branch}.



\end{adjustwidth}
\hypertarget{15514326201827332376}{} 
\hyperlink{15514326201827332376}{\texttt{LibGit2.diff\_files}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
diff_files(repo::GitRepo, branch1::AbstractString, branch2::AbstractString; kwarg...) -> Vector{AbstractString}
\end{minted}

Show which files have changed in the git repository \texttt{repo} between branches \texttt{branch1} and \texttt{branch2}.

The keyword argument is:

\begin{itemize}
\item \texttt{filter::Set\{Consts.DELTA\_STATUS\}=Set([Consts.DELTA\_ADDED, Consts.DELTA\_MODIFIED, Consts.DELTA\_DELETED]))}, and it sets options for the diff. The default is to show files added, modified, or deleted.

\end{itemize}
Return only the \emph{names} of the files which have changed, \emph{not} their contents.

\textbf{Examples}


\begin{minted}{julia}
LibGit2.branch!(repo, "branch/a")
LibGit2.branch!(repo, "branch/b")
# add a file to repo
open(joinpath(LibGit2.path(repo),"file"),"w") do f
    write(f, "hello repo
")
end
LibGit2.add!(repo, "file")
LibGit2.commit(repo, "add file")
# returns ["file"]
filt = Set([LibGit2.Consts.DELTA_ADDED])
files = LibGit2.diff_files(repo, "branch/a", "branch/b", filter=filt)
# returns [] because existing files weren't modified
filt = Set([LibGit2.Consts.DELTA_MODIFIED])
files = LibGit2.diff_files(repo, "branch/a", "branch/b", filter=filt)
\end{minted}

Equivalent to \texttt{git diff --name-only --diff-filter=<filter> <branch1> <branch2>}.



\end{adjustwidth}
\hypertarget{13732663441533972746}{} 
\hyperlink{13732663441533972746}{\texttt{LibGit2.entryid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
entryid(te::GitTreeEntry)
\end{minted}

Return the \hyperlink{202290709580230708}{\texttt{GitHash}} of the object to which \texttt{te} refers.



\end{adjustwidth}
\hypertarget{5430515144387502914}{} 
\hyperlink{5430515144387502914}{\texttt{LibGit2.entrytype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
entrytype(te::GitTreeEntry)
\end{minted}

Return the type of the object to which \texttt{te} refers. The result will be one of the types which \hyperlink{5024227788763319693}{\texttt{objtype}} returns, e.g. a \texttt{GitTree} or \texttt{GitBlob}.



\end{adjustwidth}
\hypertarget{538444501253561978}{} 
\hyperlink{538444501253561978}{\texttt{LibGit2.fetch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fetch(rmt::GitRemote, refspecs; options::FetchOptions=FetchOptions(), msg="")
\end{minted}

Fetch from the specified \texttt{rmt} remote git repository, using \texttt{refspecs} to determine which remote branch(es) to fetch. The keyword arguments are:

\begin{itemize}
\item \texttt{options}: determines the options for the fetch, e.g. whether to prune afterwards. See \hyperlink{7474664468985945267}{\texttt{FetchOptions}} for more information.


\item \texttt{msg}: a message to insert into the reflogs.

\end{itemize}



\begin{lstlisting}
fetch(repo::GitRepo; kwargs...)
\end{lstlisting}

Fetches updates from an upstream of the repository \texttt{repo}.

The keyword arguments are:

\begin{itemize}
\item \texttt{remote::AbstractString={\textquotedbl}origin{\textquotedbl}}: which remote, specified by name, of \texttt{repo} to fetch from. If this is empty, the URL will be used to construct an anonymous remote.


\item \texttt{remoteurl::AbstractString={\textquotedbl}{\textquotedbl}}: the URL of \texttt{remote}. If not specified, will be assumed based on the given name of \texttt{remote}.


\item \texttt{refspecs=AbstractString[]}: determines properties of the fetch.


\item \texttt{credentials=nothing}: provides credentials and/or settings when authenticating against a private \texttt{remote}.


\item \texttt{callbacks=Callbacks()}: user provided callbacks and payloads.

\end{itemize}
Equivalent to \texttt{git fetch [<remoteurl>|<repo>] [<refspecs>]}.



\end{adjustwidth}
\hypertarget{17606053504537858539}{} 
\hyperlink{17606053504537858539}{\texttt{LibGit2.fetchheads}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fetchheads(repo::GitRepo) -> Vector{FetchHead}
\end{minted}

Return the list of all the fetch heads for \texttt{repo}, each represented as a \hyperlink{17806809481919147110}{\texttt{FetchHead}}, including their names, URLs, and merge statuses.

\textbf{Examples}


\begin{minted}{jlcon}
julia> fetch_heads = LibGit2.fetchheads(repo);

julia> fetch_heads[1].name
"refs/heads/master"

julia> fetch_heads[1].ismerge
true

julia> fetch_heads[2].name
"refs/heads/test_branch"

julia> fetch_heads[2].ismerge
false
\end{minted}



\end{adjustwidth}
\hypertarget{2305079754843803490}{} 
\hyperlink{2305079754843803490}{\texttt{LibGit2.fetch\_refspecs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fetch_refspecs(rmt::GitRemote) -> Vector{String}
\end{minted}

Get the \emph{fetch} refspecs for the specified \texttt{rmt}. These refspecs contain information about which branch(es) to fetch from.

\textbf{Examples}


\begin{minted}{jlcon}
julia> remote = LibGit2.get(LibGit2.GitRemote, repo, "upstream");

julia> LibGit2.add_fetch!(repo, remote, "upstream");

julia> LibGit2.fetch_refspecs(remote)
String["+refs/heads/*:refs/remotes/upstream/*"]
\end{minted}



\end{adjustwidth}
\hypertarget{14433606895966923953}{} 
\hyperlink{14433606895966923953}{\texttt{LibGit2.fetchhead\_foreach\_cb}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

C function pointer for \texttt{fetchhead\_foreach\_callback}



\end{adjustwidth}
\hypertarget{2535753121792845073}{} 
\hyperlink{2535753121792845073}{\texttt{LibGit2.merge\_base}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
merge_base(repo::GitRepo, one::AbstractString, two::AbstractString) -> GitHash
\end{minted}

Find a merge base (a common ancestor) between the commits \texttt{one} and \texttt{two}. \texttt{one} and \texttt{two} may both be in string form. Return the \texttt{GitHash} of the merge base.



\end{adjustwidth}
\hypertarget{1187901033925205953}{} 
\hyperlink{1187901033925205953}{\texttt{LibGit2.merge!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
merge!(repo::GitRepo; kwargs...) -> Bool
\end{minted}

Perform a git merge on the repository \texttt{repo}, merging commits with diverging history into the current branch. Return \texttt{true} if the merge succeeded, \texttt{false} if not.

The keyword arguments are:

\begin{itemize}
\item \texttt{committish::AbstractString={\textquotedbl}{\textquotedbl}}: Merge the named commit(s) in \texttt{committish}.


\item \texttt{branch::AbstractString={\textquotedbl}{\textquotedbl}}: Merge the branch \texttt{branch} and all its commits since it diverged from the current branch.


\item \texttt{fastforward::Bool=false}: If \texttt{fastforward} is \texttt{true}, only merge if the merge is a fast-forward (the current branch head is an ancestor of the commits to be merged), otherwise refuse to merge and return \texttt{false}. This is equivalent to the git CLI option \texttt{--ff-only}.


\item \texttt{merge\_opts::MergeOptions=MergeOptions()}: \texttt{merge\_opts} specifies options for the merge, such as merge strategy in case of conflicts.


\item \texttt{checkout\_opts::CheckoutOptions=CheckoutOptions()}: \texttt{checkout\_opts} specifies options for the checkout step.

\end{itemize}
Equivalent to \texttt{git merge [--ff-only] [<committish> | <branch>]}.

\begin{quote}
\textbf{Note}

If you specify a \texttt{branch}, this must be done in reference format, since the string will be turned into a \texttt{GitReference}. For example, if you wanted to merge branch \texttt{branch\_a}, you would call \texttt{merge!(repo, branch={\textquotedbl}refs/heads/branch\_a{\textquotedbl})}.

\end{quote}


\end{adjustwidth}
\hypertarget{6081828016566889200}{} 
\hyperlink{6081828016566889200}{\texttt{LibGit2.merge!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
merge!(repo::GitRepo, anns::Vector{GitAnnotated}; kwargs...) -> Bool
\end{minted}

Merge changes from the annotated commits (captured as \hyperlink{9263689983564368210}{\texttt{GitAnnotated}} objects) \texttt{anns} into the HEAD of the repository \texttt{repo}. The keyword arguments are:

\begin{itemize}
\item \texttt{merge\_opts::MergeOptions = MergeOptions()}: options for how to perform the merge, including whether fastforwarding is allowed. See \hyperlink{7663922722360889557}{\texttt{MergeOptions}} for more information.


\item \texttt{checkout\_opts::CheckoutOptions = CheckoutOptions()}: options for how to perform the checkout. See \hyperlink{16441061243067746546}{\texttt{CheckoutOptions}} for more information.

\end{itemize}
\texttt{anns} may refer to remote or local branch heads. Return \texttt{true} if the merge is successful, otherwise return \texttt{false} (for instance, if no merge is possible because the branches have no common ancestor).

\textbf{Examples}


\begin{minted}{julia}
upst_ann = LibGit2.GitAnnotated(repo, "branch/a")

# merge the branch in
LibGit2.merge!(repo, [upst_ann])
\end{minted}



\end{adjustwidth}
\hypertarget{4685130166334465369}{} 
\hyperlink{4685130166334465369}{\texttt{LibGit2.merge!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
merge!(repo::GitRepo, anns::Vector{GitAnnotated}, fastforward::Bool; kwargs...) -> Bool
\end{minted}

Merge changes from the annotated commits (captured as \hyperlink{9263689983564368210}{\texttt{GitAnnotated}} objects) \texttt{anns} into the HEAD of the repository \texttt{repo}. If \texttt{fastforward} is \texttt{true}, \emph{only} a fastforward merge is allowed. In this case, if conflicts occur, the merge will fail. Otherwise, if \texttt{fastforward} is \texttt{false}, the merge may produce a conflict file which the user will need to resolve.

The keyword arguments are:

\begin{itemize}
\item \texttt{merge\_opts::MergeOptions = MergeOptions()}: options for how to perform the merge, including whether fastforwarding is allowed. See \hyperlink{7663922722360889557}{\texttt{MergeOptions}} for more information.


\item \texttt{checkout\_opts::CheckoutOptions = CheckoutOptions()}: options for how to perform the checkout. See \hyperlink{16441061243067746546}{\texttt{CheckoutOptions}} for more information.

\end{itemize}
\texttt{anns} may refer to remote or local branch heads. Return \texttt{true} if the merge is successful, otherwise return \texttt{false} (for instance, if no merge is possible because the branches have no common ancestor).

\textbf{Examples}


\begin{minted}{julia}
upst_ann_1 = LibGit2.GitAnnotated(repo, "branch/a")

# merge the branch in, fastforward
LibGit2.merge!(repo, [upst_ann_1], true)

# merge conflicts!
upst_ann_2 = LibGit2.GitAnnotated(repo, "branch/b")
# merge the branch in, try to fastforward
LibGit2.merge!(repo, [upst_ann_2], true) # will return false
LibGit2.merge!(repo, [upst_ann_2], false) # will return true
\end{minted}



\end{adjustwidth}
\hypertarget{12324560892659859842}{} 
\hyperlink{12324560892659859842}{\texttt{LibGit2.ffmerge!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ffmerge!(repo::GitRepo, ann::GitAnnotated)
\end{minted}

Fastforward merge changes into current HEAD. This is only possible if the commit referred to by \texttt{ann} is descended from the current HEAD (e.g. if pulling changes from a remote branch which is simply ahead of the local branch tip).



\end{adjustwidth}
\hypertarget{2268784022172298907}{} 
\hyperlink{2268784022172298907}{\texttt{LibGit2.fullname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.fullname(ref::GitReference)
\end{minted}

Return the name of the reference pointed to by the symbolic reference \texttt{ref}. If \texttt{ref} is not a symbolic reference, return an empty string.



\end{adjustwidth}
\hypertarget{15490475873131507647}{} 
\hyperlink{15490475873131507647}{\texttt{LibGit2.features}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
features()
\end{minted}

Return a list of git features the current version of libgit2 supports, such as threading or using HTTPS or SSH.



\end{adjustwidth}
\hypertarget{4260849105857148209}{} 
\hyperlink{4260849105857148209}{\texttt{LibGit2.filename}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
filename(te::GitTreeEntry)
\end{minted}

Return the filename of the object on disk to which \texttt{te} refers.



\end{adjustwidth}
\hypertarget{10756827966829509667}{} 
\hyperlink{10756827966829509667}{\texttt{LibGit2.filemode}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
filemode(te::GitTreeEntry) -> Cint
\end{minted}

Return the UNIX filemode of the object on disk to which \texttt{te} refers as an integer.



\end{adjustwidth}
\hypertarget{12125979754140967861}{} 
\hyperlink{12125979754140967861}{\texttt{LibGit2.gitdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.gitdir(repo::GitRepo)
\end{minted}

Return the location of the {\textquotedbl}git{\textquotedbl} files of \texttt{repo}:

\begin{itemize}
\item for normal repositories, this is the location of the \texttt{.git} folder.


\item for bare repositories, this is the location of the repository itself.

\end{itemize}
See also \hyperlink{6689577338311178757}{\texttt{workdir}}, \hyperlink{7655803558162329563}{\texttt{path}}.



\end{adjustwidth}
\hypertarget{12071312184635750746}{} 
\hyperlink{12071312184635750746}{\texttt{LibGit2.git\_url}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.git_url(; kwargs...) -> String
\end{minted}

Create a string based upon the URL components provided. When the \texttt{scheme} keyword is not provided the URL produced will use the alternative \href{https://git-scm.com/docs/git-clone\#\_git\_urls\_a\_id\_urls\_a}{scp-like syntax}.

\textbf{Keywords}

\begin{itemize}
\item \texttt{scheme::AbstractString={\textquotedbl}{\textquotedbl}}: the URL scheme which identifies the protocol to be used. For HTTP use {\textquotedbl}http{\textquotedbl}, SSH use {\textquotedbl}ssh{\textquotedbl}, etc. When \texttt{scheme} is not provided the output format will be {\textquotedbl}ssh{\textquotedbl} but using the scp-like syntax.


\item \texttt{username::AbstractString={\textquotedbl}{\textquotedbl}}: the username to use in the output if provided.


\item \texttt{password::AbstractString={\textquotedbl}{\textquotedbl}}: the password to use in the output if provided.


\item \texttt{host::AbstractString={\textquotedbl}{\textquotedbl}}: the hostname to use in the output. A hostname is required to be specified.


\item \texttt{port::Union\{AbstractString,Integer\}={\textquotedbl}{\textquotedbl}}: the port number to use in the output if provided. Cannot be specified when using the scp-like syntax.


\item \texttt{path::AbstractString={\textquotedbl}{\textquotedbl}}: the path to use in the output if provided.

\end{itemize}
\begin{quote}
\textbf{Warning}

Avoid using passwords in URLs. Unlike the credential objects, Julia is not able to securely zero or destroy the sensitive data after use and the password may remain in memory; possibly to be exposed by an uninitialized memory.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> LibGit2.git_url(username="git", host="github.com", path="JuliaLang/julia.git")
"git@github.com:JuliaLang/julia.git"

julia> LibGit2.git_url(scheme="https", host="github.com", path="/JuliaLang/julia.git")
"https://github.com/JuliaLang/julia.git"

julia> LibGit2.git_url(scheme="ssh", username="git", host="github.com", port=2222, path="JuliaLang/julia.git")
"ssh://git@github.com:2222/JuliaLang/julia.git"
\end{minted}



\end{adjustwidth}
\hypertarget{6260170502036665222}{} 
\hyperlink{6260170502036665222}{\texttt{LibGit2.@githash\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@githash_str -> AbstractGitHash
\end{minted}

Construct a git hash object from the given string, returning a \texttt{GitShortHash} if the string is shorter than 40 hexadecimal digits, otherwise a \texttt{GitHash}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> LibGit2.githash"d114feb74ce633"
GitShortHash("d114feb74ce633")

julia> LibGit2.githash"d114feb74ce63307afe878a5228ad014e0289a85"
GitHash("d114feb74ce63307afe878a5228ad014e0289a85")
\end{minted}



\end{adjustwidth}
\hypertarget{14955163669937294027}{} 
\hyperlink{14955163669937294027}{\texttt{LibGit2.head}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.head(repo::GitRepo) -> GitReference
\end{minted}

Return a \texttt{GitReference} to the current HEAD of \texttt{repo}.




\begin{lstlisting}
head(pkg::AbstractString) -> String
\end{lstlisting}

Return current HEAD \hyperlink{202290709580230708}{\texttt{GitHash}} of the \texttt{pkg} repo as a string.



\end{adjustwidth}
\hypertarget{16482865322979618348}{} 
\hyperlink{16482865322979618348}{\texttt{LibGit2.head!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.head!(repo::GitRepo, ref::GitReference) -> GitReference
\end{minted}

Set the HEAD of \texttt{repo} to the object pointed to by \texttt{ref}.



\end{adjustwidth}
\hypertarget{15860910592870539871}{} 
\hyperlink{15860910592870539871}{\texttt{LibGit2.head\_oid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.head_oid(repo::GitRepo) -> GitHash
\end{minted}

Lookup the object id of the current HEAD of git repository \texttt{repo}.



\end{adjustwidth}
\hypertarget{9819416665219430137}{} 
\hyperlink{9819416665219430137}{\texttt{LibGit2.headname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.headname(repo::GitRepo)
\end{minted}

Lookup the name of the current HEAD of git repository \texttt{repo}. If \texttt{repo} is currently detached, return the name of the HEAD it{\textquotesingle}s detached from.



\end{adjustwidth}
\hypertarget{234151039133609684}{} 
\hyperlink{234151039133609684}{\texttt{LibGit2.init}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.init(path::AbstractString, bare::Bool=false) -> GitRepo
\end{minted}

Open a new git repository at \texttt{path}. If \texttt{bare} is \texttt{false}, the working tree will be created in \texttt{path/.git}. If \texttt{bare} is \texttt{true}, no working directory will be created.



\end{adjustwidth}
\hypertarget{330281650028652704}{} 
\hyperlink{330281650028652704}{\texttt{LibGit2.is\_ancestor\_of}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
is_ancestor_of(a::AbstractString, b::AbstractString, repo::GitRepo) -> Bool
\end{minted}

Return \texttt{true} if \texttt{a}, a \hyperlink{202290709580230708}{\texttt{GitHash}} in string form, is an ancestor of \texttt{b}, a \hyperlink{202290709580230708}{\texttt{GitHash}} in string form.

\textbf{Examples}


\begin{minted}{jlcon}
julia> repo = LibGit2.GitRepo(repo_path);

julia> LibGit2.add!(repo, test_file1);

julia> commit_oid1 = LibGit2.commit(repo, "commit1");

julia> LibGit2.add!(repo, test_file2);

julia> commit_oid2 = LibGit2.commit(repo, "commit2");

julia> LibGit2.is_ancestor_of(string(commit_oid1), string(commit_oid2), repo)
true
\end{minted}



\end{adjustwidth}
\hypertarget{404822283933661526}{} 
\hyperlink{404822283933661526}{\texttt{LibGit2.isbinary}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isbinary(blob::GitBlob) -> Bool
\end{minted}

Use a heuristic to guess if a file is binary: searching for NULL bytes and looking for a reasonable ratio of printable to non-printable characters among the first 8000 bytes.



\end{adjustwidth}
\hypertarget{12031902939660672720}{} 
\hyperlink{12031902939660672720}{\texttt{LibGit2.iscommit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
iscommit(id::AbstractString, repo::GitRepo) -> Bool
\end{minted}

Check if commit \texttt{id} (which is a \hyperlink{202290709580230708}{\texttt{GitHash}} in string form) is in the repository.

\textbf{Examples}


\begin{minted}{jlcon}
julia> repo = LibGit2.GitRepo(repo_path);

julia> LibGit2.add!(repo, test_file);

julia> commit_oid = LibGit2.commit(repo, "add test_file");

julia> LibGit2.iscommit(string(commit_oid), repo)
true
\end{minted}



\end{adjustwidth}
\hypertarget{3509758867865957563}{} 
\hyperlink{3509758867865957563}{\texttt{LibGit2.isdiff}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.isdiff(repo::GitRepo, treeish::AbstractString, pathspecs::AbstractString=""; cached::Bool=false)
\end{minted}

Checks if there are any differences between the tree specified by \texttt{treeish} and the tracked files in the working tree (if \texttt{cached=false}) or the index (if \texttt{cached=true}). \texttt{pathspecs} are the specifications for options for the diff.

\textbf{Examples}


\begin{minted}{julia}
repo = LibGit2.GitRepo(repo_path)
LibGit2.isdiff(repo, "HEAD") # should be false
open(joinpath(repo_path, new_file), "a") do f
    println(f, "here's my cool new file")
end
LibGit2.isdiff(repo, "HEAD") # now true
\end{minted}

Equivalent to \texttt{git diff-index <treeish> [-- <pathspecs>]}.



\end{adjustwidth}
\hypertarget{7941935372196782184}{} 
\hyperlink{7941935372196782184}{\texttt{LibGit2.isdirty}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.isdirty(repo::GitRepo, pathspecs::AbstractString=""; cached::Bool=false) -> Bool
\end{minted}

Check if there have been any changes to tracked files in the working tree (if \texttt{cached=false}) or the index (if \texttt{cached=true}). \texttt{pathspecs} are the specifications for options for the diff.

\textbf{Examples}


\begin{minted}{julia}
repo = LibGit2.GitRepo(repo_path)
LibGit2.isdirty(repo) # should be false
open(joinpath(repo_path, new_file), "a") do f
    println(f, "here's my cool new file")
end
LibGit2.isdirty(repo) # now true
LibGit2.isdirty(repo, new_file) # now true
\end{minted}

Equivalent to \texttt{git diff-index HEAD [-- <pathspecs>]}.



\end{adjustwidth}
\hypertarget{2361675915882834215}{} 
\hyperlink{2361675915882834215}{\texttt{LibGit2.isorphan}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.isorphan(repo::GitRepo)
\end{minted}

Check if the current branch is an {\textquotedbl}orphan{\textquotedbl} branch, i.e. has no commits. The first commit to this branch will have no parents.



\end{adjustwidth}
\hypertarget{2310531182237663864}{} 
\hyperlink{2310531182237663864}{\texttt{LibGit2.isset}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isset(val::Integer, flag::Integer)
\end{minted}

Test whether the bits of \texttt{val} indexed by \texttt{flag} are set (\texttt{1}) or unset (\texttt{0}).



\end{adjustwidth}
\hypertarget{12794222535204600786}{} 
\hyperlink{12794222535204600786}{\texttt{LibGit2.iszero}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
iszero(id::GitHash) -> Bool
\end{minted}

Determine whether all hexadecimal digits of the given \hyperlink{202290709580230708}{\texttt{GitHash}} are zero.



\end{adjustwidth}
\hypertarget{8872141007246166845}{} 
\hyperlink{8872141007246166845}{\texttt{LibGit2.lookup\_branch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lookup_branch(repo::GitRepo, branch_name::AbstractString, remote::Bool=false) -> Union{GitReference, Nothing}
\end{minted}

Determine if the branch specified by \texttt{branch\_name} exists in the repository \texttt{repo}. If \texttt{remote} is \texttt{true}, \texttt{repo} is assumed to be a remote git repository. Otherwise, it is part of the local filesystem.

Return either a \texttt{GitReference} to the requested branch if it exists, or \hyperlink{9331422207248206047}{\texttt{nothing}} if not.



\end{adjustwidth}
\hypertarget{546421066875217314}{} 
\hyperlink{546421066875217314}{\texttt{LibGit2.map}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.map(f::Function, walker::GitRevWalker; oid::GitHash=GitHash(), range::AbstractString="", by::Cint=Consts.SORT_NONE, rev::Bool=false)
\end{minted}

Using the \hyperlink{7800294839307043628}{\texttt{GitRevWalker}} \texttt{walker} to {\textquotedbl}walk{\textquotedbl} over every commit in the repository{\textquotesingle}s history, apply \texttt{f} to each commit in the walk. The keyword arguments are:     * \texttt{oid}: The \hyperlink{202290709580230708}{\texttt{GitHash}} of the commit to begin the walk from. The default is to use       \hyperlink{9792433728015067335}{\texttt{push\_head!}} and therefore the HEAD commit and all its ancestors.     * \texttt{range}: A range of \texttt{GitHash}s in the format \texttt{oid1..oid2}. \texttt{f} will be       applied to all commits between the two.     * \texttt{by}: The sorting method. The default is not to sort. Other options are to sort by       topology (\texttt{LibGit2.Consts.SORT\_TOPOLOGICAL}), to sort forwards in time       (\texttt{LibGit2.Consts.SORT\_TIME}, most ancient first) or to sort backwards in time       (\texttt{LibGit2.Consts.SORT\_REVERSE}, most recent first).     * \texttt{rev}: Whether to reverse the sorted order (for instance, if topological sorting is used).

\textbf{Examples}


\begin{minted}{julia}
oids = LibGit2.with(LibGit2.GitRevWalker(repo)) do walker
    LibGit2.map((oid, repo)->string(oid), walker, by=LibGit2.Consts.SORT_TIME)
end
\end{minted}

Here, \texttt{map} visits each commit using the \texttt{GitRevWalker} and finds its \texttt{GitHash}.



\end{adjustwidth}
\hypertarget{3649636619945218341}{} 
\hyperlink{3649636619945218341}{\texttt{LibGit2.mirror\_callback}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Mirror callback function

Function sets \texttt{+refs/*:refs/*} refspecs and \texttt{mirror} flag for remote reference.



\end{adjustwidth}
\hypertarget{381062800465562522}{} 
\hyperlink{381062800465562522}{\texttt{LibGit2.mirror\_cb}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

C function pointer for \texttt{mirror\_callback}



\end{adjustwidth}
\hypertarget{8348936587496719270}{} 
\hyperlink{8348936587496719270}{\texttt{LibGit2.message}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
message(c::GitCommit, raw::Bool=false)
\end{minted}

Return the commit message describing the changes made in commit \texttt{c}. If \texttt{raw} is \texttt{false}, return a slightly {\textquotedbl}cleaned up{\textquotedbl} message (which has any leading newlines removed). If \texttt{raw} is \texttt{true}, the message is not stripped of any such newlines.



\end{adjustwidth}
\hypertarget{8167742111561542209}{} 
\hyperlink{8167742111561542209}{\texttt{LibGit2.merge\_analysis}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
merge_analysis(repo::GitRepo, anns::Vector{GitAnnotated}) -> analysis, preference
\end{minted}

Run analysis on the branches pointed to by the annotated branch tips \texttt{anns} and determine under what circumstances they can be merged. For instance, if \texttt{anns[1]} is simply an ancestor of \texttt{ann[2]}, then \texttt{merge\_analysis} will report that a fast-forward merge is possible.

Return two outputs, \texttt{analysis} and \texttt{preference}. \texttt{analysis} has several possible values:     * \texttt{MERGE\_ANALYSIS\_NONE}: it is not possible to merge the elements of \texttt{anns}.     * \texttt{MERGE\_ANALYSIS\_NORMAL}: a regular merge, when HEAD and the commits that the       user wishes to merge have all diverged from a common ancestor. In this case the       changes have to be resolved and conflicts may occur.     * \texttt{MERGE\_ANALYSIS\_UP\_TO\_DATE}: all the input commits the user wishes to merge can       be reached from HEAD, so no merge needs to be performed.     * \texttt{MERGE\_ANALYSIS\_FASTFORWARD}: the input commit is a descendant of HEAD and so no       merge needs to be performed - instead, the user can simply checkout the       input commit(s).     * \texttt{MERGE\_ANALYSIS\_UNBORN}: the HEAD of the repository refers to a commit which does not       exist. It is not possible to merge, but it may be possible to checkout the input       commits. \texttt{preference} also has several possible values:     * \texttt{MERGE\_PREFERENCE\_NONE}: the user has no preference.     * \texttt{MERGE\_PREFERENCE\_NO\_FASTFORWARD}: do not allow any fast-forward merges.     * \texttt{MERGE\_PREFERENCE\_FASTFORWARD\_ONLY}: allow only fast-forward merges and no       other type (which may introduce conflicts). \texttt{preference} can be controlled through the repository or global git configuration.



\end{adjustwidth}
\hypertarget{2421524004789353091}{} 
\hyperlink{2421524004789353091}{\texttt{LibGit2.name}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.name(ref::GitReference)
\end{minted}

Return the full name of \texttt{ref}.




\begin{lstlisting}
name(rmt::GitRemote)
\end{lstlisting}

Get the name of a remote repository, for instance \texttt{{\textquotedbl}origin{\textquotedbl}}. If the remote is anonymous (see \hyperlink{13915605113589562056}{\texttt{GitRemoteAnon}}) the name will be an empty string \texttt{{\textquotedbl}{\textquotedbl}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> repo_url = "https://github.com/JuliaLang/Example.jl";

julia> repo = LibGit2.clone(cache_repo, "test_directory");

julia> remote = LibGit2.GitRemote(repo, "origin", repo_url);

julia> name(remote)
"origin"
\end{minted}




\begin{lstlisting}
LibGit2.name(tag::GitTag)
\end{lstlisting}

The name of \texttt{tag} (e.g. \texttt{{\textquotedbl}v0.5{\textquotedbl}}).



\end{adjustwidth}
\hypertarget{7748563965577890862}{} 
\hyperlink{7748563965577890862}{\texttt{LibGit2.need\_update}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
need_update(repo::GitRepo)
\end{minted}

Equivalent to \texttt{git update-index}. Return \texttt{true} if \texttt{repo} needs updating.



\end{adjustwidth}
\hypertarget{5024227788763319693}{} 
\hyperlink{5024227788763319693}{\texttt{LibGit2.objtype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
objtype(obj_type::Consts.OBJECT)
\end{minted}

Return the type corresponding to the enum value.



\end{adjustwidth}
\hypertarget{7655803558162329563}{} 
\hyperlink{7655803558162329563}{\texttt{LibGit2.path}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.path(repo::GitRepo)
\end{minted}

Return the base file path of the repository \texttt{repo}.

\begin{itemize}
\item for normal repositories, this will typically be the parent directory of the {\textquotedbl}.git{\textquotedbl} directory (note: this may be different than the working directory, see \texttt{workdir} for more details).


\item for bare repositories, this is the location of the {\textquotedbl}git{\textquotedbl} files.

\end{itemize}
See also \hyperlink{12125979754140967861}{\texttt{gitdir}}, \hyperlink{6689577338311178757}{\texttt{workdir}}.



\end{adjustwidth}
\hypertarget{16139465008527879046}{} 
\hyperlink{16139465008527879046}{\texttt{LibGit2.peel}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
peel([T,] ref::GitReference)
\end{minted}

Recursively peel \texttt{ref} until an object of type \texttt{T} is obtained. If no \texttt{T} is provided, then \texttt{ref} will be peeled until an object other than a \hyperlink{10467695058580020738}{\texttt{GitTag}} is obtained.

\begin{itemize}
\item A \texttt{GitTag} will be peeled to the object it references.


\item A \hyperlink{5346527129202716606}{\texttt{GitCommit}} will be peeled to a \hyperlink{6242150303858692069}{\texttt{GitTree}}.

\end{itemize}
\begin{quote}
\textbf{Note}

Only annotated tags can be peeled to \texttt{GitTag} objects. Lightweight tags (the default) are references under \texttt{refs/tags/} which point directly to \texttt{GitCommit} objects.

\end{quote}



\begin{lstlisting}
peel([T,] obj::GitObject)
\end{lstlisting}

Recursively peel \texttt{obj} until an object of type \texttt{T} is obtained. If no \texttt{T} is provided, then \texttt{obj} will be peeled until the type changes.

\begin{itemize}
\item A \texttt{GitTag} will be peeled to the object it references.


\item A \texttt{GitCommit} will be peeled to a \texttt{GitTree}.

\end{itemize}


\end{adjustwidth}
\hypertarget{8201535180875495206}{} 
\hyperlink{8201535180875495206}{\texttt{LibGit2.posixpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.posixpath(path)
\end{minted}

Standardise the path string \texttt{path} to use POSIX separators.



\end{adjustwidth}
\hypertarget{9401118176170322302}{} 
\hyperlink{9401118176170322302}{\texttt{LibGit2.push}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
push(rmt::GitRemote, refspecs; force::Bool=false, options::PushOptions=PushOptions())
\end{minted}

Push to the specified \texttt{rmt} remote git repository, using \texttt{refspecs} to determine which remote branch(es) to push to. The keyword arguments are:

\begin{itemize}
\item \texttt{force}: if \texttt{true}, a force-push will occur, disregarding conflicts.


\item \texttt{options}: determines the options for the push, e.g. which proxy headers to use. See \hyperlink{13899785564428555533}{\texttt{PushOptions}} for more information.

\end{itemize}
\begin{quote}
\textbf{Note}

You can add information about the push refspecs in two other ways: by setting an option in the repository{\textquotesingle}s \texttt{GitConfig} (with \texttt{push.default} as the key) or by calling \hyperlink{2424007891894294055}{\texttt{add\_push!}}. Otherwise you will need to explicitly specify a push refspec in the call to \texttt{push} for it to have any effect, like so: \texttt{LibGit2.push(repo, refspecs=[{\textquotedbl}refs/heads/master{\textquotedbl}])}.

\end{quote}



\begin{lstlisting}
push(repo::GitRepo; kwargs...)
\end{lstlisting}

Pushes updates to an upstream of \texttt{repo}.

The keyword arguments are:

\begin{itemize}
\item \texttt{remote::AbstractString={\textquotedbl}origin{\textquotedbl}}: the name of the upstream remote to push to.


\item \texttt{remoteurl::AbstractString={\textquotedbl}{\textquotedbl}}: the URL of \texttt{remote}.


\item \texttt{refspecs=AbstractString[]}: determines properties of the push.


\item \texttt{force::Bool=false}: determines if the push will be a force push,  overwriting the remote branch.


\item \texttt{credentials=nothing}: provides credentials and/or settings when authenticating against  a private \texttt{remote}.


\item \texttt{callbacks=Callbacks()}: user provided callbacks and payloads.

\end{itemize}
Equivalent to \texttt{git push [<remoteurl>|<repo>] [<refspecs>]}.



\end{adjustwidth}
\hypertarget{1094911863830060497}{} 
\hyperlink{1094911863830060497}{\texttt{LibGit2.push!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.push!(w::GitRevWalker, cid::GitHash)
\end{minted}

Start the \hyperlink{7800294839307043628}{\texttt{GitRevWalker}} \texttt{walker} at commit \texttt{cid}. This function can be used to apply a function to all commits since a certain year, by passing the first commit of that year as \texttt{cid} and then passing the resulting \texttt{w} to \hyperlink{546421066875217314}{\texttt{map}}.



\end{adjustwidth}
\hypertarget{9792433728015067335}{} 
\hyperlink{9792433728015067335}{\texttt{LibGit2.push\_head!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.push_head!(w::GitRevWalker)
\end{minted}

Push the HEAD commit and its ancestors onto the \hyperlink{7800294839307043628}{\texttt{GitRevWalker}} \texttt{w}. This ensures that HEAD and all its ancestor commits will be encountered during the walk.



\end{adjustwidth}
\hypertarget{13692255696673908343}{} 
\hyperlink{13692255696673908343}{\texttt{LibGit2.push\_refspecs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
push_refspecs(rmt::GitRemote) -> Vector{String}
\end{minted}

Get the \emph{push} refspecs for the specified \texttt{rmt}. These refspecs contain information about which branch(es) to push to.

\textbf{Examples}


\begin{minted}{jlcon}
julia> remote = LibGit2.get(LibGit2.GitRemote, repo, "upstream");

julia> LibGit2.add_push!(repo, remote, "refs/heads/master");

julia> close(remote);

julia> remote = LibGit2.get(LibGit2.GitRemote, repo, "upstream");

julia> LibGit2.push_refspecs(remote)
String["refs/heads/master"]
\end{minted}



\end{adjustwidth}
\hypertarget{17280494735661401954}{} 
\hyperlink{17280494735661401954}{\texttt{LibGit2.raw}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
raw(id::GitHash) -> Vector{UInt8}
\end{minted}

Obtain the raw bytes of the \hyperlink{202290709580230708}{\texttt{GitHash}} as a vector of length 20.



\end{adjustwidth}
\hypertarget{8133295290894494359}{} 
\hyperlink{8133295290894494359}{\texttt{LibGit2.read\_tree!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.read_tree!(idx::GitIndex, tree::GitTree)
LibGit2.read_tree!(idx::GitIndex, treehash::AbstractGitHash)
\end{minted}

Read the tree \texttt{tree} (or the tree pointed to by \texttt{treehash} in the repository owned by \texttt{idx}) into the index \texttt{idx}. The current index contents will be replaced.



\end{adjustwidth}
\hypertarget{14810332437858061232}{} 
\hyperlink{14810332437858061232}{\texttt{LibGit2.rebase!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.rebase!(repo::GitRepo, upstream::AbstractString="", newbase::AbstractString="")
\end{minted}

Attempt an automatic merge rebase of the current branch, from \texttt{upstream} if provided, or otherwise from the upstream tracking branch. \texttt{newbase} is the branch to rebase onto. By default this is \texttt{upstream}.

If any conflicts arise which cannot be automatically resolved, the rebase will abort, leaving the repository and working tree in its original state, and the function will throw a \texttt{GitError}. This is roughly equivalent to the following command line statement:


\begin{lstlisting}
git rebase --merge [<upstream>]
if [ -d ".git/rebase-merge" ]; then
    git rebase --abort
fi
\end{lstlisting}



\end{adjustwidth}
\hypertarget{12847926185465464483}{} 
\hyperlink{12847926185465464483}{\texttt{LibGit2.ref\_list}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.ref_list(repo::GitRepo) -> Vector{String}
\end{minted}

Get a list of all reference names in the \texttt{repo} repository.



\end{adjustwidth}
\hypertarget{5156390520855755168}{} 
\hyperlink{5156390520855755168}{\texttt{LibGit2.reftype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.reftype(ref::GitReference) -> Cint
\end{minted}

Return a \texttt{Cint} corresponding to the type of \texttt{ref}:

\begin{itemize}
\item \texttt{0} if the reference is invalid


\item \texttt{1} if the reference is an object id


\item \texttt{2} if the reference is symbolic

\end{itemize}


\end{adjustwidth}
\hypertarget{5507389887346241045}{} 
\hyperlink{5507389887346241045}{\texttt{LibGit2.remotes}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.remotes(repo::GitRepo)
\end{minted}

Return a vector of the names of the remotes of \texttt{repo}.



\end{adjustwidth}
\hypertarget{12673554228490546577}{} 
\hyperlink{12673554228490546577}{\texttt{LibGit2.remove!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
remove!(repo::GitRepo, files::AbstractString...)
remove!(idx::GitIndex, files::AbstractString...)
\end{minted}

Remove all the files with paths specified by \texttt{files} in the index \texttt{idx} (or the index of the \texttt{repo}).



\end{adjustwidth}
\hypertarget{6133575189326240402}{} 
\hyperlink{6133575189326240402}{\texttt{LibGit2.reset}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reset(val::Integer, flag::Integer)
\end{minted}

Unset the bits of \texttt{val} indexed by \texttt{flag}, returning them to \texttt{0}.



\end{adjustwidth}
\hypertarget{6684497681285141047}{} 
\hyperlink{6684497681285141047}{\texttt{LibGit2.reset!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reset!(payload, [config]) -> CredentialPayload
\end{minted}

Reset the \texttt{payload} state back to the initial values so that it can be used again within the credential callback. If a \texttt{config} is provided the configuration will also be updated.



Updates some entries, determined by the \texttt{pathspecs}, in the index from the target commit tree.



Sets the current head to the specified commit oid and optionally resets the index and working tree to match.



git reset [<committish>] [–] <pathspecs>... 




\begin{lstlisting}
reset!(repo::GitRepo, id::GitHash, mode::Cint=Consts.RESET_MIXED)
\end{lstlisting}

Reset the repository \texttt{repo} to its state at \texttt{id}, using one of three modes set by \texttt{mode}:

\begin{itemize}
\item[1. ] \texttt{Consts.RESET\_SOFT} - move HEAD to \texttt{id}.


\item[2. ] \texttt{Consts.RESET\_MIXED} - default, move HEAD to \texttt{id} and reset the index to \texttt{id}.


\item[3. ] \texttt{Consts.RESET\_HARD} - move HEAD to \texttt{id}, reset the index to \texttt{id}, and discard all working changes.

\end{itemize}
\textbf{Examples}


\begin{minted}{julia}
# fetch changes
LibGit2.fetch(repo)
isfile(joinpath(repo_path, our_file)) # will be false

# fastforward merge the changes
LibGit2.merge!(repo, fastforward=true)

# because there was not any file locally, but there is
# a file remotely, we need to reset the branch
head_oid = LibGit2.head_oid(repo)
new_head = LibGit2.reset!(repo, head_oid, LibGit2.Consts.RESET_HARD)
\end{minted}

In this example, the remote which is being fetched from \emph{does} have a file called \texttt{our\_file} in its index, which is why we must reset.

Equivalent to \texttt{git reset [--soft | --mixed | --hard] <id>}.

\textbf{Examples}


\begin{minted}{julia}
repo = LibGit2.GitRepo(repo_path)
head_oid = LibGit2.head_oid(repo)
open(joinpath(repo_path, "file1"), "w") do f
    write(f, "111
")
end
LibGit2.add!(repo, "file1")
mode = LibGit2.Consts.RESET_HARD
# will discard the changes to file1
# and unstage it
new_head = LibGit2.reset!(repo, head_oid, mode)
\end{minted}



\end{adjustwidth}
\hypertarget{1068934750891016732}{} 
\hyperlink{1068934750891016732}{\texttt{LibGit2.restore}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
restore(s::State, repo::GitRepo)
\end{minted}

Return a repository \texttt{repo} to a previous \texttt{State} \texttt{s}, for example the HEAD of a branch before a merge attempt. \texttt{s} can be generated using the \hyperlink{5664620894068288269}{\texttt{snapshot}} function.



\end{adjustwidth}
\hypertarget{3220704891875596639}{} 
\hyperlink{3220704891875596639}{\texttt{LibGit2.revcount}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.revcount(repo::GitRepo, commit1::AbstractString, commit2::AbstractString)
\end{minted}

List the number of revisions between \texttt{commit1} and \texttt{commit2} (committish OIDs in string form). Since \texttt{commit1} and \texttt{commit2} may be on different branches, \texttt{revcount} performs a {\textquotedbl}left-right{\textquotedbl} revision list (and count), returning a tuple of \texttt{Int}s - the number of left and right commits, respectively. A left (or right) commit refers to which side of a symmetric difference in a tree the commit is reachable from.

Equivalent to \texttt{git rev-list --left-right --count <commit1> <commit2>}.

\textbf{Examples}


\begin{minted}{julia}
repo = LibGit2.GitRepo(repo_path)
repo_file = open(joinpath(repo_path, test_file), "a")
println(repo_file, "hello world")
flush(repo_file)
LibGit2.add!(repo, test_file)
commit_oid1 = LibGit2.commit(repo, "commit 1")
println(repo_file, "hello world again")
flush(repo_file)
LibGit2.add!(repo, test_file)
commit_oid2 = LibGit2.commit(repo, "commit 2")
LibGit2.revcount(repo, string(commit_oid1), string(commit_oid2))
\end{minted}

This will return \texttt{(-1, 0)}.



\end{adjustwidth}
\hypertarget{17796350858376315108}{} 
\hyperlink{17796350858376315108}{\texttt{LibGit2.set\_remote\_url}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
set_remote_url(repo::GitRepo, remote_name, url)
set_remote_url(repo::String, remote_name, url)
\end{minted}

Set both the fetch and push \texttt{url} for \texttt{remote\_name} for the \hyperlink{3263346103236484748}{\texttt{GitRepo}} or the git repository located at \texttt{path}. Typically git repos use \texttt{{\textquotedbl}origin{\textquotedbl}} as the remote name.

\textbf{Examples}


\begin{minted}{julia}
repo_path = joinpath(tempdir(), "Example")
repo = LibGit2.init(repo_path)
LibGit2.set_remote_url(repo, "upstream", "https://github.com/JuliaLang/Example.jl")
LibGit2.set_remote_url(repo_path, "upstream2", "https://github.com/JuliaLang/Example2.jl")
\end{minted}



\end{adjustwidth}
\hypertarget{16470264269906288721}{} 
\hyperlink{16470264269906288721}{\texttt{LibGit2.shortname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.shortname(ref::GitReference)
\end{minted}

Return a shortened version of the name of \texttt{ref} that{\textquotesingle}s {\textquotedbl}human-readable{\textquotedbl}.


\begin{minted}{jlcon}
julia> repo = LibGit2.GitRepo(path_to_repo);

julia> branch_ref = LibGit2.head(repo);

julia> LibGit2.name(branch_ref)
"refs/heads/master"

julia> LibGit2.shortname(branch_ref)
"master"
\end{minted}



\end{adjustwidth}
\hypertarget{5664620894068288269}{} 
\hyperlink{5664620894068288269}{\texttt{LibGit2.snapshot}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
snapshot(repo::GitRepo) -> State
\end{minted}

Take a snapshot of the current state of the repository \texttt{repo}, storing the current HEAD, index, and any uncommitted work. The output \texttt{State} can be used later during a call to \hyperlink{1068934750891016732}{\texttt{restore}} to return the repository to the snapshotted state.



\end{adjustwidth}
\hypertarget{709196314204873648}{} 
\hyperlink{709196314204873648}{\texttt{LibGit2.split\_cfg\_entry}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.split_cfg_entry(ce::LibGit2.ConfigEntry) -> Tuple{String,String,String,String}
\end{minted}

Break the \texttt{ConfigEntry} up to the following pieces: section, subsection, name, and value.

\textbf{Examples}

Given the git configuration file containing:


\begin{lstlisting}
[credential "https://example.com"]
    username = me
\end{lstlisting}

The \texttt{ConfigEntry} would look like the following:


\begin{minted}{jlcon}
julia> entry
ConfigEntry("credential.https://example.com.username", "me")

julia> LibGit2.split_cfg_entry(entry)
("credential", "https://example.com", "username", "me")
\end{minted}

Refer to the \href{https://git-scm.com/docs/git-config\#\_syntax}{git config syntax documentation} for more details.



\end{adjustwidth}
\hypertarget{8948863044724673987}{} 
\hyperlink{8948863044724673987}{\texttt{LibGit2.status}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.status(repo::GitRepo, path::String) -> Union{Cuint, Cvoid}
\end{minted}

Lookup the status of the file at \texttt{path} in the git repository \texttt{repo}. For instance, this can be used to check if the file at \texttt{path} has been modified and needs to be staged and committed.



\end{adjustwidth}
\hypertarget{3859390867093299114}{} 
\hyperlink{3859390867093299114}{\texttt{LibGit2.stage}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stage(ie::IndexEntry) -> Cint
\end{minted}

Get the stage number of \texttt{ie}. The stage number \texttt{0} represents the current state of the working tree, but other numbers can be used in the case of a merge conflict. In such a case, the various stage numbers on an \texttt{IndexEntry} describe which side(s) of the conflict the current state of the file belongs to. Stage \texttt{0} is the state before the attempted merge, stage \texttt{1} is the changes which have been made locally, stages \texttt{2} and larger are for changes from other branches (for instance, in the case of a multi-branch {\textquotedbl}octopus{\textquotedbl} merge, stages \texttt{2}, \texttt{3}, and \texttt{4} might be used).



\end{adjustwidth}
\hypertarget{4898692620083276733}{} 
\hyperlink{4898692620083276733}{\texttt{LibGit2.tag\_create}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.tag_create(repo::GitRepo, tag::AbstractString, commit; kwargs...)
\end{minted}

Create a new git tag \texttt{tag} (e.g. \texttt{{\textquotedbl}v0.5{\textquotedbl}}) in the repository \texttt{repo}, at the commit \texttt{commit}.

The keyword arguments are:

\begin{itemize}
\item \texttt{msg::AbstractString={\textquotedbl}{\textquotedbl}}: the message for the tag.


\item \texttt{force::Bool=false}: if \texttt{true}, existing references will be overwritten.


\item \texttt{sig::Signature=Signature(repo)}: the tagger{\textquotesingle}s signature.

\end{itemize}


\end{adjustwidth}
\hypertarget{7680948887680773639}{} 
\hyperlink{7680948887680773639}{\texttt{LibGit2.tag\_delete}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.tag_delete(repo::GitRepo, tag::AbstractString)
\end{minted}

Remove the git tag \texttt{tag} from the repository \texttt{repo}.



\end{adjustwidth}
\hypertarget{7061472492129884254}{} 
\hyperlink{7061472492129884254}{\texttt{LibGit2.tag\_list}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.tag_list(repo::GitRepo) -> Vector{String}
\end{minted}

Get a list of all tags in the git repository \texttt{repo}.



\end{adjustwidth}
\hypertarget{14775566063016633781}{} 
\hyperlink{14775566063016633781}{\texttt{LibGit2.target}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.target(tag::GitTag)
\end{minted}

The \texttt{GitHash} of the target object of \texttt{tag}.



\end{adjustwidth}
\hypertarget{6271025014547744112}{} 
\hyperlink{6271025014547744112}{\texttt{LibGit2.toggle}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
toggle(val::Integer, flag::Integer)
\end{minted}

Flip the bits of \texttt{val} indexed by \texttt{flag}, so that if a bit is \texttt{0} it will be \texttt{1} after the toggle, and vice-versa.



\end{adjustwidth}
\hypertarget{11557958455666787225}{} 
\hyperlink{11557958455666787225}{\texttt{LibGit2.transact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
transact(f::Function, repo::GitRepo)
\end{minted}

Apply function \texttt{f} to the git repository \texttt{repo}, taking a \hyperlink{5664620894068288269}{\texttt{snapshot}} before applying \texttt{f}. If an error occurs within \texttt{f}, \texttt{repo} will be returned to its snapshot state using \hyperlink{1068934750891016732}{\texttt{restore}}. The error which occurred will be rethrown, but the state of \texttt{repo} will not be corrupted.



\end{adjustwidth}
\hypertarget{11991883748960508451}{} 
\hyperlink{11991883748960508451}{\texttt{LibGit2.treewalk}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
treewalk(f, tree::GitTree, post::Bool=false)
\end{minted}

Traverse the entries in \texttt{tree} and its subtrees in post or pre order. Preorder means beginning at the root and then traversing the leftmost subtree (and recursively on down through that subtree{\textquotesingle}s leftmost subtrees) and moving right through the subtrees. Postorder means beginning at the bottom of the leftmost subtree, traversing upwards through it, then traversing the next right subtree (again beginning at the bottom) and finally visiting the tree root last of all.

The function parameter \texttt{f} should have following signature:


\begin{lstlisting}
(String, GitTreeEntry) -> Cint
\end{lstlisting}

A negative value returned from \texttt{f} stops the tree walk. A positive value means that the entry will be skipped if \texttt{post} is \texttt{false}.



\end{adjustwidth}
\hypertarget{14916286790794253178}{} 
\hyperlink{14916286790794253178}{\texttt{LibGit2.upstream}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
upstream(ref::GitReference) -> Union{GitReference, Nothing}
\end{minted}

Determine if the branch containing \texttt{ref} has a specified upstream branch.

Return either a \texttt{GitReference} to the upstream branch if it exists, or \hyperlink{9331422207248206047}{\texttt{nothing}} if the requested branch does not have an upstream counterpart.



\end{adjustwidth}
\hypertarget{3010892674015914384}{} 
\hyperlink{3010892674015914384}{\texttt{LibGit2.update!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
update!(repo::GitRepo, files::AbstractString...)
update!(idx::GitIndex, files::AbstractString...)
\end{minted}

Update all the files with paths specified by \texttt{files} in the index \texttt{idx} (or the index of the \texttt{repo}). Match the state of each file in the index with the current state on disk, removing it if it has been removed on disk, or updating its entry in the object database.



\end{adjustwidth}
\hypertarget{2040666647044196560}{} 
\hyperlink{2040666647044196560}{\texttt{LibGit2.url}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
url(rmt::GitRemote)
\end{minted}

Get the fetch URL of a remote git repository.

\textbf{Examples}


\begin{minted}{jlcon}
julia> repo_url = "https://github.com/JuliaLang/Example.jl";

julia> repo = LibGit2.init(mktempdir());

julia> remote = LibGit2.GitRemote(repo, "origin", repo_url);

julia> LibGit2.url(remote)
"https://github.com/JuliaLang/Example.jl"
\end{minted}



\end{adjustwidth}
\hypertarget{18107764583308594889}{} 
\hyperlink{18107764583308594889}{\texttt{LibGit2.version}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
version() -> VersionNumber
\end{minted}

Return the version of libgit2 in use, as a \hyperlink{12935585355849408291}{\texttt{VersionNumber}}.



\end{adjustwidth}
\hypertarget{11949205828120857817}{} 
\hyperlink{11949205828120857817}{\texttt{LibGit2.with}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
with(f::Function, obj)
\end{minted}

Resource management helper function. Applies \texttt{f} to \texttt{obj}, making sure to call \texttt{close} on \texttt{obj} after \texttt{f} successfully returns or throws an error. Ensures that allocated git resources are finalized as soon as they are no longer needed.



\end{adjustwidth}
\hypertarget{17446520273049220374}{} 
\hyperlink{17446520273049220374}{\texttt{LibGit2.with\_warn}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
with_warn(f::Function, ::Type{T}, args...)
\end{minted}

Resource management helper function. Apply \texttt{f} to \texttt{args}, first constructing an instance of type \texttt{T} from \texttt{args}. Makes sure to call \texttt{close} on the resulting object after \texttt{f} successfully returns or throws an error. Ensures that allocated git resources are finalized as soon as they are no longer needed. If an error is thrown by \texttt{f}, a warning is shown containing the error.



\end{adjustwidth}
\hypertarget{6689577338311178757}{} 
\hyperlink{6689577338311178757}{\texttt{LibGit2.workdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.workdir(repo::GitRepo)
\end{minted}

Return the location of the working directory of \texttt{repo}. This will throw an error for bare repositories.

\begin{quote}
\textbf{Note}

This will typically be the parent directory of \texttt{gitdir(repo)}, but can be different in some cases: e.g. if either the \texttt{core.worktree} configuration variable or the \texttt{GIT\_WORK\_TREE} environment variable is set.

\end{quote}
See also \hyperlink{12125979754140967861}{\texttt{gitdir}}, \hyperlink{7655803558162329563}{\texttt{path}}.



\end{adjustwidth}
\hypertarget{12199863114467893789}{} 
\hyperlink{12199863114467893789}{\texttt{LibGit2.GitObject}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
(::Type{T})(te::GitTreeEntry) where T<:GitObject
\end{minted}

Get the git object to which \texttt{te} refers and return it as its actual type (the type \hyperlink{5430515144387502914}{\texttt{entrytype}} would show), for instance a \texttt{GitBlob} or \texttt{GitTag}.

\textbf{Examples}


\begin{minted}{julia}
tree = LibGit2.GitTree(repo, "HEAD^{tree}")
tree_entry = tree[1]
blob = LibGit2.GitBlob(tree_entry)
\end{minted}



\end{adjustwidth}
\hypertarget{14233399752683117201}{} 
\hyperlink{14233399752683117201}{\texttt{LibGit2.UserPasswordCredential}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

Credential that support only \texttt{user} and \texttt{password} parameters



\end{adjustwidth}
\hypertarget{10065416427289604487}{} 
\hyperlink{10065416427289604487}{\texttt{LibGit2.SSHCredential}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

SSH credential type



\end{adjustwidth}
\hypertarget{10844720204154576193}{} 
\hyperlink{10844720204154576193}{\texttt{LibGit2.isfilled}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isfilled(cred::AbstractCredential) -> Bool
\end{minted}

Verifies that a credential is ready for use in authentication.



\end{adjustwidth}
\hypertarget{8879321221473200614}{} 
\hyperlink{8879321221473200614}{\texttt{LibGit2.CachedCredentials}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

Caches credential information for re-use



\end{adjustwidth}
\hypertarget{10030132349633212983}{} 
\hyperlink{10030132349633212983}{\texttt{LibGit2.CredentialPayload}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LibGit2.CredentialPayload
\end{minted}

Retains the state between multiple calls to the credential callback for the same URL. A \texttt{CredentialPayload} instance is expected to be \texttt{reset!} whenever it will be used with a different URL.



\end{adjustwidth}
\hypertarget{15851737231324263444}{} 
\hyperlink{15851737231324263444}{\texttt{LibGit2.approve}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
approve(payload::CredentialPayload; shred::Bool=true) -> Nothing
\end{minted}

Store the \texttt{payload} credential for re-use in a future authentication. Should only be called when authentication was successful.

The \texttt{shred} keyword controls whether sensitive information in the payload credential field should be destroyed. Should only be set to \texttt{false} during testing.



\end{adjustwidth}
\hypertarget{17184615468062555134}{} 
\hyperlink{17184615468062555134}{\texttt{LibGit2.reject}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
reject(payload::CredentialPayload; shred::Bool=true) -> Nothing
\end{minted}

Discard the \texttt{payload} credential from begin re-used in future authentication. Should only be called when authentication was unsuccessful.

The \texttt{shred} keyword controls whether sensitive information in the payload credential field should be destroyed. Should only be set to \texttt{false} during testing.



\end{adjustwidth}

\hypertarget{13528239852401045842}{}


\chapter{动态链接器}


\hypertarget{8171750449393676854}{} 
\hyperlink{8171750449393676854}{\texttt{Libdl.dlopen}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dlopen(libfile::AbstractString [, flags::Integer]; throw_error:Bool = true)
\end{minted}

Load a shared library, returning an opaque handle.

The extension given by the constant \texttt{dlext} (\texttt{.so}, \texttt{.dll}, or \texttt{.dylib}) can be omitted from the \texttt{libfile} string, as it is automatically appended if needed.   If \texttt{libfile} is not an absolute path name, then the paths in the array \texttt{DL\_LOAD\_PATH} are searched for \texttt{libfile}, followed by the system load path.

The optional flags argument is a bitwise-or of zero or more of \texttt{RTLD\_LOCAL}, \texttt{RTLD\_GLOBAL}, \texttt{RTLD\_LAZY}, \texttt{RTLD\_NOW}, \texttt{RTLD\_NODELETE}, \texttt{RTLD\_NOLOAD}, \texttt{RTLD\_DEEPBIND}, and \texttt{RTLD\_FIRST}. These are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS) dlopen command, if possible, or are ignored if the specified functionality is not available on the current platform. The default flags are platform specific. On MacOS the default \texttt{dlopen} flags are \texttt{RTLD\_LAZY|RTLD\_DEEPBIND|RTLD\_GLOBAL} while on other platforms the defaults are \texttt{RTLD\_LAZY|RTLD\_DEEPBIND|RTLD\_LOCAL}. An important usage of these flags is to specify non default behavior for when the dynamic library loader binds library references to exported symbols and if the bound references are put into process local or global scope. For instance \texttt{RTLD\_LAZY|RTLD\_DEEPBIND|RTLD\_GLOBAL} allows the library{\textquotesingle}s symbols to be available for usage in other shared libraries, addressing situations where there are dependencies between shared libraries.

If the library cannot be found, this method throws an error, unless the keyword argument \texttt{throw\_error} is set to \texttt{false}, in which case this method returns \texttt{nothing}.



\end{adjustwidth}
\hypertarget{10728988161738445989}{} 
\hyperlink{10728988161738445989}{\texttt{Libdl.dlopen\_e}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dlopen_e(libfile::AbstractString [, flags::Integer])
\end{minted}

Similar to \hyperlink{8171750449393676854}{\texttt{dlopen}}, except returns \texttt{C\_NULL} instead of raising errors. This method is now deprecated in favor of \texttt{dlopen(libfile::AbstractString [, flags::Integer]; throw\_error=false)}.



\end{adjustwidth}
\hypertarget{8137158678557353815}{} 
\hyperlink{8137158678557353815}{\texttt{Libdl.RTLD\_NOW}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RTLD_DEEPBIND
RTLD_FIRST
RTLD_GLOBAL
RTLD_LAZY
RTLD_LOCAL
RTLD_NODELETE
RTLD_NOLOAD
RTLD_NOW
\end{minted}

Enum constant for \hyperlink{8171750449393676854}{\texttt{dlopen}}. See your platform man page for details, if applicable.



\end{adjustwidth}
\hypertarget{13057188112538777408}{} 
\hyperlink{13057188112538777408}{\texttt{Libdl.dlsym}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dlsym(handle, sym)
\end{minted}

Look up a symbol from a shared library handle, return callable function pointer on success.



\end{adjustwidth}
\hypertarget{10957545335350379951}{} 
\hyperlink{10957545335350379951}{\texttt{Libdl.dlsym\_e}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dlsym_e(handle, sym)
\end{minted}

Look up a symbol from a shared library handle, silently return \texttt{C\_NULL} on lookup failure. This method is now deprecated in favor of \texttt{dlsym(handle, sym; throw\_error=false)}.



\end{adjustwidth}
\hypertarget{6068064281708498692}{} 
\hyperlink{6068064281708498692}{\texttt{Libdl.dlclose}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dlclose(handle)
\end{minted}

Close shared library referenced by handle.




\begin{lstlisting}
dlclose(::Nothing)
\end{lstlisting}

For the very common pattern usage pattern of


\begin{lstlisting}
try
    hdl = dlopen(library_name)
    ... do something
finally
    dlclose(hdl)
end
\end{lstlisting}

We define a \texttt{dlclose()} method that accepts a parameter of type \texttt{Nothing}, so that user code does not have to change its behavior for the case that \texttt{library\_name} was not found.



\end{adjustwidth}
\hypertarget{8833400024976878033}{} 
\hyperlink{8833400024976878033}{\texttt{Libdl.dlext}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dlext
\end{minted}

File extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.



\end{adjustwidth}
\hypertarget{106077495372504799}{} 
\hyperlink{106077495372504799}{\texttt{Libdl.dllist}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dllist()
\end{minted}

Return the paths of dynamic libraries currently loaded in a \texttt{Vector\{String\}}.



\end{adjustwidth}
\hypertarget{6289250176059967308}{} 
\hyperlink{6289250176059967308}{\texttt{Libdl.dlpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dlpath(handle::Ptr{Cvoid})
\end{minted}

Given a library \texttt{handle} from \texttt{dlopen}, return the full path.




\begin{lstlisting}
dlpath(libname::Union{AbstractString, Symbol})
\end{lstlisting}

Get the full path of the library \texttt{libname}.

\textbf{Example}


\begin{minted}{jlcon}
julia> dlpath("libjulia")
\end{minted}



\end{adjustwidth}
\hypertarget{12933484848758864058}{} 
\hyperlink{12933484848758864058}{\texttt{Libdl.find\_library}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
find_library(names, locations)
\end{minted}

Searches for the first library in \texttt{names} in the paths in the \texttt{locations} list, \texttt{DL\_LOAD\_PATH}, or system library paths (in that order) which can successfully be dlopen{\textquotesingle}d. On success, the return value will be one of the names (potentially prefixed by one of the paths in locations). This string can be assigned to a \texttt{global const} and used as the library name in future \texttt{ccall}{\textquotesingle}s. On failure, it returns the empty string.



\end{adjustwidth}
\hypertarget{617000259211246203}{} 
\hyperlink{617000259211246203}{\texttt{Base.DL\_LOAD\_PATH}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
DL_LOAD_PATH
\end{minted}

When calling \hyperlink{8171750449393676854}{\texttt{dlopen}}, the paths in this list will be searched first, in order, before searching the system locations for a valid library handle.



\end{adjustwidth}

\hypertarget{12233296614674559904}{}


\chapter{线性代数}





In addition to (and as part of) its support for multi-dimensional arrays, Julia provides native implementations of many common and useful linear algebra operations which can be loaded with \texttt{using LinearAlgebra}. Basic operations, such as \hyperlink{3355659645971312171}{\texttt{tr}}, \hyperlink{16543378577000914469}{\texttt{det}}, and \hyperlink{13336866048543706848}{\texttt{inv}} are all supported:




\begin{minted}{jlcon}
julia> A = [1 2 3; 4 1 6; 7 8 1]
3×3 Array{Int64,2}:
 1  2  3
 4  1  6
 7  8  1

julia> tr(A)
3

julia> det(A)
104.0

julia> inv(A)
3×3 Array{Float64,2}:
 -0.451923   0.211538    0.0865385
  0.365385  -0.192308    0.0576923
  0.240385   0.0576923  -0.0673077
\end{minted}



还有其它实用的运算，比如寻找特征值或特征向量：




\begin{minted}{jlcon}
julia> A = [-4. -17.; 2. 2.]
2×2 Array{Float64,2}:
 -4.0  -17.0
  2.0    2.0

julia> eigvals(A)
2-element Array{Complex{Float64},1}:
 -1.0 - 5.0im
 -1.0 + 5.0im

julia> eigvecs(A)
2×2 Array{Complex{Float64},2}:
  0.945905-0.0im        0.945905+0.0im
 -0.166924+0.278207im  -0.166924-0.278207im
\end{minted}



此外，Julia 提供了多种\hyperlink{14017178414387426770}{矩阵分解}，它们可用于加快问题的求解，比如线性求解或矩阵或矩阵求幂，这通过将矩阵预先分解成更适合问题的形式（出于性能或内存上的原因）。有关的更多信息，请参阅文档 \hyperlink{7042962205548658937}{\texttt{factorize}}。举个例子：




\begin{minted}{jlcon}
julia> A = [1.5 2 -4; 3 -1 -6; -10 2.3 4]
3×3 Array{Float64,2}:
   1.5   2.0  -4.0
   3.0  -1.0  -6.0
 -10.0   2.3   4.0

julia> factorize(A)
LU{Float64,Array{Float64,2}}
L factor:
3×3 Array{Float64,2}:
  1.0    0.0       0.0
 -0.15   1.0       0.0
 -0.3   -0.132196  1.0
U factor:
3×3 Array{Float64,2}:
 -10.0  2.3     4.0
   0.0  2.345  -3.4
   0.0  0.0    -5.24947
\end{minted}



因为 \texttt{A} 不是埃尔米特、对称、三角、三对角或双对角矩阵，LU 分解也许是我们能做的最好分解。与之相比：




\begin{minted}{jlcon}
julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3×3 Array{Float64,2}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia> factorize(B)
BunchKaufman{Float64,Array{Float64,2}}
D factor:
3×3 Tridiagonal{Float64,Array{Float64,1}}:
 -1.64286   0.0   ⋅
  0.0      -2.8  0.0
   ⋅        0.0  5.0
U factor:
3×3 UnitUpperTriangular{Float64,Array{Float64,2}}:
 1.0  0.142857  -0.8
  ⋅   1.0       -0.6
  ⋅    ⋅         1.0
permutation:
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



在这里，Julia 能够发现 \texttt{B} 确实是对称矩阵，并且使用一种更适当的分解。针对一个具有某些属性的矩阵，比如一个对称或三对角矩阵，往往有可能写出更高效的代码。Julia 提供了一些特殊的类型好让你可以根据矩阵所具有的属性「标记」它们。例如：




\begin{minted}{jlcon}
julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3×3 Array{Float64,2}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia> sB = Symmetric(B)
3×3 Symmetric{Float64,Array{Float64,2}}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0
\end{minted}



\texttt{sB} 已经被标记成（实）对称矩阵，所以对于之后可能在它上面执行的操作，例如特征因子化或矩阵-向量乘积，只引用矩阵的一半可以提高效率。举个例子：




\begin{minted}{jlcon}
julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3×3 Array{Float64,2}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia> sB = Symmetric(B)
3×3 Symmetric{Float64,Array{Float64,2}}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia> x = [1; 2; 3]
3-element Array{Int64,1}:
 1
 2
 3

julia> sB\x
3-element Array{Float64,1}:
 -1.7391304347826084
 -1.1086956521739126
 -1.4565217391304346
\end{minted}



\texttt{{\textbackslash}} 运算在这里执行线性求解。左除运算符相当强大，很容易写出紧凑、可读的代码，它足够灵活，可以求解各种线性方程组。



\hypertarget{16591042520207219529}{}


\section{特殊矩阵}



\href{http://www2.imm.dtu.dk/pubdb/views/publication\_details.php?id=3274}{具有特殊对称性和结构的矩阵}经常在线性代数中出现并且与各种矩阵分解相关。Julia 具有丰富的特殊矩阵类型，可以快速计算专门为特定矩阵类型开发的专用例程。



下表总结了在 Julia 中已经实现的特殊矩阵类型，以及为它们提供各种优化方法的钩子在 LAPACK 中是否可用。




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
类型 & 描述 \\
\hline
\hyperlink{17683454167504168761}{\texttt{Symmetric}} & \href{https://en.wikipedia.org/wiki/Symmetric\_matrix}{对称矩阵} \\
\hline
\hyperlink{938713992181310063}{\texttt{Hermitian}} & \href{https://en.wikipedia.org/wiki/Hermitian\_matrix}{埃尔米特矩阵} \\
\hline
\hyperlink{6344726545165008167}{\texttt{UpperTriangular}} & 上\href{https://en.wikipedia.org/wiki/Triangular\_matrix}{三角矩阵} \\
\hline
\hyperlink{17221720404477798393}{\texttt{UnitUpperTriangular}} & Upper \href{https://en.wikipedia.org/wiki/Triangular\_matrix}{triangular matrix} with unit diagonal \\
\hline
\hyperlink{15116078732779234709}{\texttt{LowerTriangular}} & Lower \href{https://en.wikipedia.org/wiki/Triangular\_matrix}{triangular matrix} \\
\hline
\hyperlink{2163321084999097240}{\texttt{UnitLowerTriangular}} & Lower \href{https://en.wikipedia.org/wiki/Triangular\_matrix}{triangular matrix} with unit diagonal \\
\hline
\hyperlink{6167777885202579792}{\texttt{UpperHessenberg}} & Upper \href{https://en.wikipedia.org/wiki/Hessenberg\_matrix}{Hessenberg matrix} \\
\hline
\hyperlink{17820886359515748171}{\texttt{Tridiagonal}} & \href{https://en.wikipedia.org/wiki/Tridiagonal\_matrix}{Tridiagonal matrix} \\
\hline
\hyperlink{6062797780727203318}{\texttt{SymTridiagonal}} & Symmetric tridiagonal matrix \\
\hline
\hyperlink{6156150905679680892}{\texttt{Bidiagonal}} & Upper/lower \href{https://en.wikipedia.org/wiki/Bidiagonal\_matrix}{bidiagonal matrix} \\
\hline
\hyperlink{3300114559258360989}{\texttt{Diagonal}} & \href{https://en.wikipedia.org/wiki/Diagonal\_matrix}{Diagonal matrix} \\
\hline
\hyperlink{723087258311673942}{\texttt{UniformScaling}} & \href{https://en.wikipedia.org/wiki/Uniform\_scaling}{Uniform scaling operator} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{17944625623829928397}{}


\subsection{Elementary operations}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|}
\hline
Matrix type & \texttt{+} & \texttt{-} & \texttt{*} & \texttt{{\textbackslash}} & Other functions with optimized methods \\
\hline
\hyperlink{17683454167504168761}{\texttt{Symmetric}} &  &  &  & MV & \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{4551113327515323898}{\texttt{sqrt}}, \hyperlink{5801729597955756107}{\texttt{exp}} \\
\hline
\hyperlink{938713992181310063}{\texttt{Hermitian}} &  &  &  & MV & \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{4551113327515323898}{\texttt{sqrt}}, \hyperlink{5801729597955756107}{\texttt{exp}} \\
\hline
\hyperlink{6344726545165008167}{\texttt{UpperTriangular}} &  &  & MV & MV & \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{16543378577000914469}{\texttt{det}} \\
\hline
\hyperlink{17221720404477798393}{\texttt{UnitUpperTriangular}} &  &  & MV & MV & \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{16543378577000914469}{\texttt{det}} \\
\hline
\hyperlink{15116078732779234709}{\texttt{LowerTriangular}} &  &  & MV & MV & \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{16543378577000914469}{\texttt{det}} \\
\hline
\hyperlink{2163321084999097240}{\texttt{UnitLowerTriangular}} &  &  & MV & MV & \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{16543378577000914469}{\texttt{det}} \\
\hline
\hyperlink{6167777885202579792}{\texttt{UpperHessenberg}} &  &  &  & MM & \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{16543378577000914469}{\texttt{det}} \\
\hline
\hyperlink{6062797780727203318}{\texttt{SymTridiagonal}} & M & M & MS & MV & \hyperlink{1568196261511691624}{\texttt{eigmax}}, \hyperlink{658135215942727363}{\texttt{eigmin}} \\
\hline
\hyperlink{17820886359515748171}{\texttt{Tridiagonal}} & M & M & MS & MV &  \\
\hline
\hyperlink{6156150905679680892}{\texttt{Bidiagonal}} & M & M & MS & MV &  \\
\hline
\hyperlink{3300114559258360989}{\texttt{Diagonal}} & M & M & MV & MV & \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{16543378577000914469}{\texttt{det}}, \hyperlink{12765142073947245963}{\texttt{logdet}}, \hyperlink{4103478871488785445}{\texttt{/}} \\
\hline
\hyperlink{723087258311673942}{\texttt{UniformScaling}} & M & M & MVS & MVS & \hyperlink{4103478871488785445}{\texttt{/}} \\
\hline
\end{tabulary}

\end{table}



Legend:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Key & Description \\
\hline
M (matrix) & An optimized method for matrix-matrix operations is available \\
\hline
V (vector) & An optimized method for matrix-vector operations is available \\
\hline
S (scalar) & An optimized method for matrix-scalar operations is available \\
\hline
\end{tabulary}

\end{table}



\hypertarget{9743537278285582026}{}


\subsection{Matrix factorizations}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|L|}
\hline
Matrix type & LAPACK & \hyperlink{11056016707394839114}{\texttt{eigen}} & \hyperlink{12334018763942871611}{\texttt{eigvals}} & \hyperlink{8591842276375230542}{\texttt{eigvecs}} & \hyperlink{6661056220970412040}{\texttt{svd}} & \hyperlink{12905968661134086149}{\texttt{svdvals}} \\
\hline
\hyperlink{17683454167504168761}{\texttt{Symmetric}} & SY &  & ARI &  &  &  \\
\hline
\hyperlink{938713992181310063}{\texttt{Hermitian}} & HE &  & ARI &  &  &  \\
\hline
\hyperlink{6344726545165008167}{\texttt{UpperTriangular}} & TR & A & A & A &  &  \\
\hline
\hyperlink{17221720404477798393}{\texttt{UnitUpperTriangular}} & TR & A & A & A &  &  \\
\hline
\hyperlink{15116078732779234709}{\texttt{LowerTriangular}} & TR & A & A & A &  &  \\
\hline
\hyperlink{2163321084999097240}{\texttt{UnitLowerTriangular}} & TR & A & A & A &  &  \\
\hline
\hyperlink{6062797780727203318}{\texttt{SymTridiagonal}} & ST & A & ARI & AV &  &  \\
\hline
\hyperlink{17820886359515748171}{\texttt{Tridiagonal}} & GT &  &  &  &  &  \\
\hline
\hyperlink{6156150905679680892}{\texttt{Bidiagonal}} & BD &  &  &  & A & A \\
\hline
\hyperlink{3300114559258360989}{\texttt{Diagonal}} & DI &  & A &  &  &  \\
\hline
\end{tabulary}

\end{table}



Legend:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Key & Description & Example \\
\hline
A (all) & An optimized method to find all the characteristic values and/or vectors is available & e.g. \texttt{eigvals(M)} \\
\hline
R (range) & An optimized method to find the \texttt{il}th through the \texttt{ih}th characteristic values are available & \texttt{eigvals(M, il, ih)} \\
\hline
I (interval) & An optimized method to find the characteristic values in the interval [\texttt{vl}, \texttt{vh}] is available & \texttt{eigvals(M, vl, vh)} \\
\hline
V (vectors) & An optimized method to find the characteristic vectors corresponding to the characteristic values \texttt{x=[x1, x2,...]} is available & \texttt{eigvecs(M, x)} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{8735142158345502219}{}


\subsection{The uniform scaling operator}



A \hyperlink{723087258311673942}{\texttt{UniformScaling}} operator represents a scalar times the identity operator, \texttt{λ*I}. The identity operator \texttt{I} is defined as a constant and is an instance of \texttt{UniformScaling}. The size of these operators are generic and match the other matrix in the binary operations \hyperlink{3677358729494553841}{\texttt{+}}, \hyperlink{8228207173393714756}{\texttt{-}}, \hyperlink{7592762607639177347}{\texttt{*}} and \hyperlink{4639577998029770435}{\texttt{{\textbackslash}}}. For \texttt{A+I} and \texttt{A-I} this means that \texttt{A} must be square. Multiplication with the identity operator \texttt{I} is a noop (except for checking that the scaling factor is one) and therefore almost without overhead.



To see the \texttt{UniformScaling} operator in action:




\begin{minted}{jlcon}
julia> U = UniformScaling(2);

julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> a + U
2×2 Array{Int64,2}:
 3  2
 3  6

julia> a * U
2×2 Array{Int64,2}:
 2  4
 6  8

julia> [a U]
2×4 Array{Int64,2}:
 1  2  2  0
 3  4  0  2

julia> b = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia> b - U
ERROR: DimensionMismatch("matrix is not square: dimensions are (2, 3)")
Stacktrace:
[...]
\end{minted}



If you need to solve many systems of the form \texttt{(A+μI)x = b} for the same \texttt{A} and different \texttt{μ}, it might be beneficial to first compute the Hessenberg factorization \texttt{F} of \texttt{A} via the \hyperlink{14451165250498024497}{\texttt{hessenberg}} function. Given \texttt{F}, Julia employs an efficient algorithm for \texttt{(F+μ*I) {\textbackslash} b} (equivalent to \texttt{(A+μ*I)x {\textbackslash} b}) and related operations like determinants.



\hypertarget{12615392115882150758}{}


\section{Matrix factorizations}



\href{https://en.wikipedia.org/wiki/Matrix\_decomposition}{Matrix factorizations (a.k.a. matrix decompositions)} compute the factorization of a matrix into a product of matrices, and are one of the central concepts in linear algebra.



The following table summarizes the types of matrix factorizations that have been implemented in Julia. Details of their associated methods can be found in the \hyperlink{14873423929127000343}{Standard functions} section of the Linear Algebra documentation.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Type & Description \\
\hline
\texttt{BunchKaufman} & Bunch-Kaufman factorization \\
\hline
\texttt{Cholesky} & \href{https://en.wikipedia.org/wiki/Cholesky\_decomposition}{Cholesky factorization} \\
\hline
\texttt{CholeskyPivoted} & \href{https://en.wikipedia.org/wiki/Pivot\_element}{Pivoted} Cholesky factorization \\
\hline
\texttt{LDLt} & \href{https://en.wikipedia.org/wiki/Cholesky\_decomposition\#LDL\_decomposition}{LDL(T) factorization} \\
\hline
\texttt{LU} & \href{https://en.wikipedia.org/wiki/LU\_decomposition}{LU factorization} \\
\hline
\texttt{QR} & \href{https://en.wikipedia.org/wiki/QR\_decomposition}{QR factorization} \\
\hline
\texttt{QRCompactWY} & Compact WY form of the QR factorization \\
\hline
\texttt{QRPivoted} & Pivoted \href{https://en.wikipedia.org/wiki/QR\_decomposition}{QR factorization} \\
\hline
\texttt{LQ} & \href{https://en.wikipedia.org/wiki/QR\_decomposition}{QR factorization} of \texttt{transpose(A)} \\
\hline
\texttt{Hessenberg} & \href{http://mathworld.wolfram.com/HessenbergDecomposition.html}{Hessenberg decomposition} \\
\hline
\texttt{Eigen} & \href{https://en.wikipedia.org/wiki/Eigendecomposition\_of\_a\_matrix}{Spectral decomposition} \\
\hline
\texttt{GeneralizedEigen} & \href{https://en.wikipedia.org/wiki/Eigendecomposition\_of\_a\_matrix\#Generalized\_eigenvalue\_problem}{Generalized spectral decomposition} \\
\hline
\texttt{SVD} & \href{https://en.wikipedia.org/wiki/Singular\_value\_decomposition}{Singular value decomposition} \\
\hline
\texttt{GeneralizedSVD} & \href{https://en.wikipedia.org/wiki/Generalized\_singular\_value\_decomposition\#Higher\_order\_version}{Generalized SVD} \\
\hline
\texttt{Schur} & \href{https://en.wikipedia.org/wiki/Schur\_decomposition}{Schur decomposition} \\
\hline
\texttt{GeneralizedSchur} & \href{https://en.wikipedia.org/wiki/Schur\_decomposition\#Generalized\_Schur\_decomposition}{Generalized Schur decomposition} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{10454442684761744234}{}


\section{Standard functions}



Linear algebra functions in Julia are largely implemented by calling functions from \href{http://www.netlib.org/lapack/}{LAPACK}.  Sparse factorizations call functions from \href{http://faculty.cse.tamu.edu/davis/suitesparse.html}{SuiteSparse}.


\hypertarget{9051502204834048921}{} 
\hyperlink{9051502204834048921}{\texttt{Base.:*}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
*(A::AbstractMatrix, B::AbstractMatrix)
\end{minted}

Matrix multiplication.

\textbf{Examples}


\begin{minted}{jlcon}
julia> [1 1; 0 1] * [1 0; 1 1]
2×2 Array{Int64,2}:
 2  1
 1  1
\end{minted}



\end{adjustwidth}
\hypertarget{9779560736429840808}{} 
\hyperlink{9779560736429840808}{\texttt{Base.:{\textbackslash}}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
\(A, B)
\end{minted}

Matrix division using a polyalgorithm. For input matrices \texttt{A} and \texttt{B}, the result \texttt{X} is such that \texttt{A*X == B} when \texttt{A} is square. The solver that is used depends upon the structure of \texttt{A}.  If \texttt{A} is upper or lower triangular (or diagonal), no factorization of \texttt{A} is required and the system is solved with either forward or backward substitution. For non-triangular square matrices, an LU factorization is used.

For rectangular \texttt{A} the result is the minimum-norm least squares solution computed by a pivoted QR factorization of \texttt{A} and a rank estimate of \texttt{A} based on the R factor.

When \texttt{A} is sparse, a similar polyalgorithm is used. For indefinite matrices, the \texttt{LDLt} factorization does not use pivoting during the numerical factorization and therefore the procedure can fail even for invertible matrices.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 0; 1 -2]; B = [32; -4];

julia> X = A \ B
2-element Array{Float64,1}:
 32.0
 18.0

julia> A * X == B
true
\end{minted}



\end{adjustwidth}
\hypertarget{3093579424646561023}{} 
\hyperlink{3093579424646561023}{\texttt{LinearAlgebra.SingularException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SingularException
\end{minted}

Exception thrown when the input matrix has one or more zero-valued eigenvalues, and is not invertible. A linear solve involving such a matrix cannot be computed. The \texttt{info} field indicates the location of (one of) the singular value(s).



\end{adjustwidth}
\hypertarget{12039872206324733514}{} 
\hyperlink{12039872206324733514}{\texttt{LinearAlgebra.PosDefException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
PosDefException
\end{minted}

Exception thrown when the input matrix was not \href{https://en.wikipedia.org/wiki/Definiteness\_of\_a\_matrix}{positive definite}. Some linear algebra functions and factorizations are only applicable to positive definite matrices. The \texttt{info} field indicates the location of (one of) the eigenvalue(s) which is (are) less than/equal to 0.



\end{adjustwidth}
\hypertarget{5527602249593606173}{} 
\hyperlink{5527602249593606173}{\texttt{LinearAlgebra.ZeroPivotException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ZeroPivotException <: Exception
\end{minted}

Exception thrown when a matrix factorization/solve encounters a zero in a pivot (diagonal) position and cannot proceed.  This may \emph{not} mean that the matrix is singular: it may be fruitful to switch to a diffent factorization such as pivoted LU that can re-order variables to eliminate spurious zero pivots. The \texttt{info} field indicates the location of (one of) the zero pivot(s).



\end{adjustwidth}
\hypertarget{15449777733236645501}{} 
\hyperlink{15449777733236645501}{\texttt{LinearAlgebra.dot}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dot(x, y)
x ⋅ y
\end{minted}

Compute the dot product between two vectors. For complex vectors, the first vector is conjugated.

\texttt{dot} also works on arbitrary iterable objects, including arrays of any dimension, as long as \texttt{dot} is defined on the elements.

\texttt{dot} is semantically equivalent to \texttt{sum(dot(vx,vy) for (vx,vy) in zip(x, y))}, with the added restriction that the arguments must have equal lengths.

\texttt{x ⋅ y} (where \texttt{⋅} can be typed by tab-completing \texttt{{\textbackslash}cdot} in the REPL) is a synonym for \texttt{dot(x, y)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> dot([1; 1], [2; 3])
5

julia> dot([im; im], [1; 1])
0 - 2im

julia> dot(1:5, 2:6)
70

julia> x = fill(2., (5,5));

julia> y = fill(3., (5,5));

julia> dot(x, y)
150.0
\end{minted}



\end{adjustwidth}
\hypertarget{7470245664307242183}{} 
\hyperlink{7470245664307242183}{\texttt{LinearAlgebra.cross}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cross(x, y)
×(x,y)
\end{minted}

Compute the cross product of two 3-vectors.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [0;1;0]
3-element Array{Int64,1}:
 0
 1
 0

julia> b = [0;0;1]
3-element Array{Int64,1}:
 0
 0
 1

julia> cross(a,b)
3-element Array{Int64,1}:
 1
 0
 0
\end{minted}



\end{adjustwidth}
\hypertarget{7042962205548658937}{} 
\hyperlink{7042962205548658937}{\texttt{LinearAlgebra.factorize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
factorize(A)
\end{minted}

Compute a convenient factorization of \texttt{A}, based upon the type of the input matrix. \texttt{factorize} checks \texttt{A} to see if it is symmetric/triangular/etc. if \texttt{A} is passed as a generic matrix. \texttt{factorize} checks every element of \texttt{A} to verify/rule out each property. It will short-circuit as soon as it can rule out symmetry/triangular structure. The return value can be reused for efficient solving of multiple systems. For example: \texttt{A=factorize(A); x=A{\textbackslash}b; y=A{\textbackslash}C}.


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Properties of \texttt{A} & type of factorization \\
\hline
Positive-definite & Cholesky (see \hyperlink{7653413936706994771}{\texttt{cholesky}}) \\
\hline
Dense Symmetric/Hermitian & Bunch-Kaufman (see \hyperlink{17253210517333433448}{\texttt{bunchkaufman}}) \\
\hline
Sparse Symmetric/Hermitian & LDLt (see \hyperlink{8934377864822491393}{\texttt{ldlt}}) \\
\hline
Triangular & Triangular \\
\hline
Diagonal & Diagonal \\
\hline
Bidiagonal & Bidiagonal \\
\hline
Tridiagonal & LU (see \hyperlink{5672569096214810830}{\texttt{lu}}) \\
\hline
Symmetric real tridiagonal & LDLt (see \hyperlink{8934377864822491393}{\texttt{ldlt}}) \\
\hline
General square & LU (see \hyperlink{5672569096214810830}{\texttt{lu}}) \\
\hline
General non-square & QR (see \hyperlink{4122539696772350360}{\texttt{qr}}) \\
\hline
\end{tabulary}

\end{table}

If \texttt{factorize} is called on a Hermitian positive-definite matrix, for instance, then \texttt{factorize} will return a Cholesky factorization.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = Array(Bidiagonal(fill(1.0, (5, 5)), :U))
5×5 Array{Float64,2}:
 1.0  1.0  0.0  0.0  0.0
 0.0  1.0  1.0  0.0  0.0
 0.0  0.0  1.0  1.0  0.0
 0.0  0.0  0.0  1.0  1.0
 0.0  0.0  0.0  0.0  1.0

julia> factorize(A) # factorize will check to see that A is already factorized
5×5 Bidiagonal{Float64,Array{Float64,1}}:
 1.0  1.0   ⋅    ⋅    ⋅
  ⋅   1.0  1.0   ⋅    ⋅
  ⋅    ⋅   1.0  1.0   ⋅
  ⋅    ⋅    ⋅   1.0  1.0
  ⋅    ⋅    ⋅    ⋅   1.0
\end{minted}

This returns a \texttt{5×5 Bidiagonal\{Float64\}}, which can now be passed to other linear algebra functions (e.g. eigensolvers) which will use specialized methods for \texttt{Bidiagonal} types.



\end{adjustwidth}
\hypertarget{3300114559258360989}{} 
\hyperlink{3300114559258360989}{\texttt{LinearAlgebra.Diagonal}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Diagonal(A::AbstractMatrix)
\end{minted}

Construct a matrix from the diagonal of \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia> Diagonal(A)
3×3 Diagonal{Int64,Array{Int64,1}}:
 1  ⋅  ⋅
 ⋅  5  ⋅
 ⋅  ⋅  9
\end{minted}




\begin{lstlisting}
Diagonal(V::AbstractVector)
\end{lstlisting}

Construct a matrix with \texttt{V} as its diagonal.

\textbf{Examples}


\begin{minted}{jlcon}
julia> V = [1, 2]
2-element Array{Int64,1}:
 1
 2

julia> Diagonal(V)
2×2 Diagonal{Int64,Array{Int64,1}}:
 1  ⋅
 ⋅  2
\end{minted}



\end{adjustwidth}
\hypertarget{6156150905679680892}{} 
\hyperlink{6156150905679680892}{\texttt{LinearAlgebra.Bidiagonal}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Bidiagonal(dv::V, ev::V, uplo::Symbol) where V <: AbstractVector
\end{minted}

Constructs an upper (\texttt{uplo=:U}) or lower (\texttt{uplo=:L}) bidiagonal matrix using the given diagonal (\texttt{dv}) and off-diagonal (\texttt{ev}) vectors. The result is of type \texttt{Bidiagonal} and provides efficient specialized linear solvers, but may be converted into a regular matrix with \hyperlink{1846942650946171605}{\texttt{convert(Array, \_)}} (or \texttt{Array(\_)} for short). The length of \texttt{ev} must be one less than the length of \texttt{dv}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> dv = [1, 2, 3, 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> ev = [7, 8, 9]
3-element Array{Int64,1}:
 7
 8
 9

julia> Bu = Bidiagonal(dv, ev, :U) # ev is on the first superdiagonal
4×4 Bidiagonal{Int64,Array{Int64,1}}:
 1  7  ⋅  ⋅
 ⋅  2  8  ⋅
 ⋅  ⋅  3  9
 ⋅  ⋅  ⋅  4

julia> Bl = Bidiagonal(dv, ev, :L) # ev is on the first subdiagonal
4×4 Bidiagonal{Int64,Array{Int64,1}}:
 1  ⋅  ⋅  ⋅
 7  2  ⋅  ⋅
 ⋅  8  3  ⋅
 ⋅  ⋅  9  4
\end{minted}




\begin{lstlisting}
Bidiagonal(A, uplo::Symbol)
\end{lstlisting}

Construct a \texttt{Bidiagonal} matrix from the main diagonal of \texttt{A} and its first super- (if \texttt{uplo=:U}) or sub-diagonal (if \texttt{uplo=:L}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 1 1 1; 2 2 2 2; 3 3 3 3; 4 4 4 4]
4×4 Array{Int64,2}:
 1  1  1  1
 2  2  2  2
 3  3  3  3
 4  4  4  4

julia> Bidiagonal(A, :U) # contains the main diagonal and first superdiagonal of A
4×4 Bidiagonal{Int64,Array{Int64,1}}:
 1  1  ⋅  ⋅
 ⋅  2  2  ⋅
 ⋅  ⋅  3  3
 ⋅  ⋅  ⋅  4

julia> Bidiagonal(A, :L) # contains the main diagonal and first subdiagonal of A
4×4 Bidiagonal{Int64,Array{Int64,1}}:
 1  ⋅  ⋅  ⋅
 2  2  ⋅  ⋅
 ⋅  3  3  ⋅
 ⋅  ⋅  4  4
\end{minted}



\end{adjustwidth}
\hypertarget{6062797780727203318}{} 
\hyperlink{6062797780727203318}{\texttt{LinearAlgebra.SymTridiagonal}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SymTridiagonal(dv::V, ev::V) where V <: AbstractVector
\end{minted}

Construct a symmetric tridiagonal matrix from the diagonal (\texttt{dv}) and first sub/super-diagonal (\texttt{ev}), respectively. The result is of type \texttt{SymTridiagonal} and provides efficient specialized eigensolvers, but may be converted into a regular matrix with \hyperlink{1846942650946171605}{\texttt{convert(Array, \_)}} (or \texttt{Array(\_)} for short).

\textbf{Examples}


\begin{minted}{jlcon}
julia> dv = [1, 2, 3, 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> ev = [7, 8, 9]
3-element Array{Int64,1}:
 7
 8
 9

julia> SymTridiagonal(dv, ev)
4×4 SymTridiagonal{Int64,Array{Int64,1}}:
 1  7  ⋅  ⋅
 7  2  8  ⋅
 ⋅  8  3  9
 ⋅  ⋅  9  4
\end{minted}




\begin{lstlisting}
SymTridiagonal(A::AbstractMatrix)
\end{lstlisting}

Construct a symmetric tridiagonal matrix from the diagonal and first sub/super-diagonal, of the symmetric matrix \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2 3; 2 4 5; 3 5 6]
3×3 Array{Int64,2}:
 1  2  3
 2  4  5
 3  5  6

julia> SymTridiagonal(A)
3×3 SymTridiagonal{Int64,Array{Int64,1}}:
 1  2  ⋅
 2  4  5
 ⋅  5  6
\end{minted}



\end{adjustwidth}
\hypertarget{17820886359515748171}{} 
\hyperlink{17820886359515748171}{\texttt{LinearAlgebra.Tridiagonal}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Tridiagonal(dl::V, d::V, du::V) where V <: AbstractVector
\end{minted}

Construct a tridiagonal matrix from the first subdiagonal, diagonal, and first superdiagonal, respectively. The result is of type \texttt{Tridiagonal} and provides efficient specialized linear solvers, but may be converted into a regular matrix with \hyperlink{1846942650946171605}{\texttt{convert(Array, \_)}} (or \texttt{Array(\_)} for short). The lengths of \texttt{dl} and \texttt{du} must be one less than the length of \texttt{d}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> dl = [1, 2, 3];

julia> du = [4, 5, 6];

julia> d = [7, 8, 9, 0];

julia> Tridiagonal(dl, d, du)
4×4 Tridiagonal{Int64,Array{Int64,1}}:
 7  4  ⋅  ⋅
 1  8  5  ⋅
 ⋅  2  9  6
 ⋅  ⋅  3  0
\end{minted}




\begin{lstlisting}
Tridiagonal(A)
\end{lstlisting}

Construct a tridiagonal matrix from the first sub-diagonal, diagonal and first super-diagonal of the matrix \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2 3 4; 1 2 3 4; 1 2 3 4; 1 2 3 4]
4×4 Array{Int64,2}:
 1  2  3  4
 1  2  3  4
 1  2  3  4
 1  2  3  4

julia> Tridiagonal(A)
4×4 Tridiagonal{Int64,Array{Int64,1}}:
 1  2  ⋅  ⋅
 1  2  3  ⋅
 ⋅  2  3  4
 ⋅  ⋅  3  4
\end{minted}



\end{adjustwidth}
\hypertarget{17683454167504168761}{} 
\hyperlink{17683454167504168761}{\texttt{LinearAlgebra.Symmetric}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Symmetric(A, uplo=:U)
\end{minted}

Construct a \texttt{Symmetric} view of the upper (if \texttt{uplo = :U}) or lower (if \texttt{uplo = :L}) triangle of the matrix \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 0 2 0 3; 0 4 0 5 0; 6 0 7 0 8; 0 9 0 1 0; 2 0 3 0 4]
5×5 Array{Int64,2}:
 1  0  2  0  3
 0  4  0  5  0
 6  0  7  0  8
 0  9  0  1  0
 2  0  3  0  4

julia> Supper = Symmetric(A)
5×5 Symmetric{Int64,Array{Int64,2}}:
 1  0  2  0  3
 0  4  0  5  0
 2  0  7  0  8
 0  5  0  1  0
 3  0  8  0  4

julia> Slower = Symmetric(A, :L)
5×5 Symmetric{Int64,Array{Int64,2}}:
 1  0  6  0  2
 0  4  0  9  0
 6  0  7  0  3
 0  9  0  1  0
 2  0  3  0  4
\end{minted}

Note that \texttt{Supper} will not be equal to \texttt{Slower} unless \texttt{A} is itself symmetric (e.g. if \texttt{A == transpose(A)}).



\end{adjustwidth}
\hypertarget{938713992181310063}{} 
\hyperlink{938713992181310063}{\texttt{LinearAlgebra.Hermitian}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Hermitian(A, uplo=:U)
\end{minted}

Construct a \texttt{Hermitian} view of the upper (if \texttt{uplo = :U}) or lower (if \texttt{uplo = :L}) triangle of the matrix \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 0 2+2im 0 3-3im; 0 4 0 5 0; 6-6im 0 7 0 8+8im; 0 9 0 1 0; 2+2im 0 3-3im 0 4];

julia> Hupper = Hermitian(A)
5×5 Hermitian{Complex{Int64},Array{Complex{Int64},2}}:
 1+0im  0+0im  2+2im  0+0im  3-3im
 0+0im  4+0im  0+0im  5+0im  0+0im
 2-2im  0+0im  7+0im  0+0im  8+8im
 0+0im  5+0im  0+0im  1+0im  0+0im
 3+3im  0+0im  8-8im  0+0im  4+0im

julia> Hlower = Hermitian(A, :L)
5×5 Hermitian{Complex{Int64},Array{Complex{Int64},2}}:
 1+0im  0+0im  6+6im  0+0im  2-2im
 0+0im  4+0im  0+0im  9+0im  0+0im
 6-6im  0+0im  7+0im  0+0im  3+3im
 0+0im  9+0im  0+0im  1+0im  0+0im
 2+2im  0+0im  3-3im  0+0im  4+0im
\end{minted}

Note that \texttt{Hupper} will not be equal to \texttt{Hlower} unless \texttt{A} is itself Hermitian (e.g. if \texttt{A == adjoint(A)}).

All non-real parts of the diagonal will be ignored.


\begin{minted}{julia}
Hermitian(fill(complex(1,1), 1, 1)) == fill(1, 1, 1)
\end{minted}



\end{adjustwidth}
\hypertarget{15116078732779234709}{} 
\hyperlink{15116078732779234709}{\texttt{LinearAlgebra.LowerTriangular}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LowerTriangular(A::AbstractMatrix)
\end{minted}

Construct a \texttt{LowerTriangular} view of the matrix \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia> LowerTriangular(A)
3×3 LowerTriangular{Float64,Array{Float64,2}}:
 1.0   ⋅    ⋅
 4.0  5.0   ⋅
 7.0  8.0  9.0
\end{minted}



\end{adjustwidth}
\hypertarget{6344726545165008167}{} 
\hyperlink{6344726545165008167}{\texttt{LinearAlgebra.UpperTriangular}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UpperTriangular(A::AbstractMatrix)
\end{minted}

Construct an \texttt{UpperTriangular} view of the matrix \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia> UpperTriangular(A)
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 1.0  2.0  3.0
  ⋅   5.0  6.0
  ⋅    ⋅   9.0
\end{minted}



\end{adjustwidth}
\hypertarget{2163321084999097240}{} 
\hyperlink{2163321084999097240}{\texttt{LinearAlgebra.UnitLowerTriangular}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UnitLowerTriangular(A::AbstractMatrix)
\end{minted}

Construct a \texttt{UnitLowerTriangular} view of the matrix \texttt{A}. Such a view has the \hyperlink{2310843180104103470}{\texttt{oneunit}} of the \hyperlink{6396209842929672718}{\texttt{eltype}} of \texttt{A} on its diagonal.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia> UnitLowerTriangular(A)
3×3 UnitLowerTriangular{Float64,Array{Float64,2}}:
 1.0   ⋅    ⋅
 4.0  1.0   ⋅
 7.0  8.0  1.0
\end{minted}



\end{adjustwidth}
\hypertarget{17221720404477798393}{} 
\hyperlink{17221720404477798393}{\texttt{LinearAlgebra.UnitUpperTriangular}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UnitUpperTriangular(A::AbstractMatrix)
\end{minted}

Construct an \texttt{UnitUpperTriangular} view of the matrix \texttt{A}. Such a view has the \hyperlink{2310843180104103470}{\texttt{oneunit}} of the \hyperlink{6396209842929672718}{\texttt{eltype}} of \texttt{A} on its diagonal.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia> UnitUpperTriangular(A)
3×3 UnitUpperTriangular{Float64,Array{Float64,2}}:
 1.0  2.0  3.0
  ⋅   1.0  6.0
  ⋅    ⋅   1.0
\end{minted}



\end{adjustwidth}
\hypertarget{6167777885202579792}{} 
\hyperlink{6167777885202579792}{\texttt{LinearAlgebra.UpperHessenberg}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UpperHessenberg(A::AbstractMatrix)
\end{minted}

Construct an \texttt{UpperHessenberg} view of the matrix \texttt{A}. Entries of \texttt{A} below the first subdiagonal are ignored.

Efficient algorithms are implemented for \texttt{H {\textbackslash} b}, \texttt{det(H)}, and similar.

See also the \hyperlink{14451165250498024497}{\texttt{hessenberg}} function to factor any matrix into a similar upper-Hessenberg matrix.

If \texttt{F::Hessenberg} is the factorization object, the unitary matrix can be accessed with \texttt{F.Q} and the Hessenberg matrix with \texttt{F.H}. When \texttt{Q} is extracted, the resulting type is the \texttt{HessenbergQ} object, and may be converted to a regular matrix with \hyperlink{1846942650946171605}{\texttt{convert(Array, \_)}} (or \texttt{Array(\_)} for short).

Iterating the decomposition produces the factors \texttt{F.Q} and \texttt{F.H}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2 3 4; 5 6 7 8; 9 10 11 12; 13 14 15 16]
4×4 Array{Int64,2}:
  1   2   3   4
  5   6   7   8
  9  10  11  12
 13  14  15  16

julia> UpperHessenberg(A)
4×4 UpperHessenberg{Int64,Array{Int64,2}}:
 1   2   3   4
 5   6   7   8
 ⋅  10  11  12
 ⋅   ⋅  15  16
\end{minted}



\end{adjustwidth}
\hypertarget{723087258311673942}{} 
\hyperlink{723087258311673942}{\texttt{LinearAlgebra.UniformScaling}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UniformScaling{T<:Number}
\end{minted}

Generically sized uniform scaling operator defined as a scalar times the identity operator, \texttt{λ*I}. See also \hyperlink{15346645596018210602}{\texttt{I}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> J = UniformScaling(2.)
UniformScaling{Float64}
2.0*I

julia> A = [1. 2.; 3. 4.]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia> J*A
2×2 Array{Float64,2}:
 2.0  4.0
 6.0  8.0
\end{minted}



\end{adjustwidth}
\hypertarget{15346645596018210602}{} 
\hyperlink{15346645596018210602}{\texttt{LinearAlgebra.I}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
I
\end{minted}

An object of type \hyperlink{723087258311673942}{\texttt{UniformScaling}}, representing an identity matrix of any size.

\textbf{Examples}


\begin{minted}{jlcon}
julia> fill(1, (5,6)) * I == fill(1, (5,6))
true

julia> [1 2im 3; 1im 2 3] * I
2×3 Array{Complex{Int64},2}:
 1+0im  0+2im  3+0im
 0+1im  2+0im  3+0im
\end{minted}



\end{adjustwidth}
\hypertarget{3230130194560201438}{} 
\hyperlink{3230130194560201438}{\texttt{LinearAlgebra.Factorization}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LinearAlgebra.Factorization
\end{minted}

Abstract type for \href{https://en.wikipedia.org/wiki/Matrix\_decomposition}{matrix factorizations} a.k.a. matrix decompositions. See \hyperlink{14017178414387426770}{online documentation} for a list of available matrix factorizations.



\end{adjustwidth}
\hypertarget{9094854913402033490}{} 
\hyperlink{9094854913402033490}{\texttt{LinearAlgebra.LU}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LU <: Factorization
\end{minted}

Matrix factorization type of the \texttt{LU} factorization of a square matrix \texttt{A}. This is the return type of \hyperlink{5672569096214810830}{\texttt{lu}}, the corresponding matrix factorization function.

The individual components of the factorization \texttt{F::LU} can be accessed via \texttt{getproperty}:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Component & Description \\
\hline
\texttt{F.L} & \texttt{L} (unit lower triangular) part of \texttt{LU} \\
\hline
\texttt{F.U} & \texttt{U} (upper triangular) part of \texttt{LU} \\
\hline
\texttt{F.p} & (right) permutation \texttt{Vector} \\
\hline
\texttt{F.P} & (right) permutation \texttt{Matrix} \\
\hline
\end{tabulary}

\end{table}

Iterating the factorization produces the components \texttt{F.L}, \texttt{F.U}, and \texttt{F.p}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4 3; 6 3]
2×2 Array{Int64,2}:
 4  3
 6  3

julia> F = lu(A)
LU{Float64,Array{Float64,2}}
L factor:
2×2 Array{Float64,2}:
 1.0       0.0
 0.666667  1.0
U factor:
2×2 Array{Float64,2}:
 6.0  3.0
 0.0  1.0

julia> F.L * F.U == A[F.p, :]
true

julia> l, u, p = lu(A); # destructuring via iteration

julia> l == F.L && u == F.U && p == F.p
true
\end{minted}



\end{adjustwidth}
\hypertarget{5672569096214810830}{} 
\hyperlink{5672569096214810830}{\texttt{LinearAlgebra.lu}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lu(A, pivot=Val(true); check = true) -> F::LU
\end{minted}

Compute the LU factorization of \texttt{A}.

When \texttt{check = true}, an error is thrown if the decomposition fails. When \texttt{check = false}, responsibility for checking the decomposition{\textquotesingle}s validity (via \hyperlink{10694198281534172656}{\texttt{issuccess}}) lies with the user.

In most cases, if \texttt{A} is a subtype \texttt{S} of \texttt{AbstractMatrix\{T\}} with an element type \texttt{T} supporting \texttt{+}, \texttt{-}, \texttt{*} and \texttt{/}, the return type is \texttt{LU\{T,S\{T\}\}}. If pivoting is chosen (default) the element type should also support \texttt{abs} and \texttt{<}.

The individual components of the factorization \texttt{F} can be accessed via \texttt{getproperty}:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Component & Description \\
\hline
\texttt{F.L} & \texttt{L} (lower triangular) part of \texttt{LU} \\
\hline
\texttt{F.U} & \texttt{U} (upper triangular) part of \texttt{LU} \\
\hline
\texttt{F.p} & (right) permutation \texttt{Vector} \\
\hline
\texttt{F.P} & (right) permutation \texttt{Matrix} \\
\hline
\end{tabulary}

\end{table}

Iterating the factorization produces the components \texttt{F.L}, \texttt{F.U}, and \texttt{F.p}.

The relationship between \texttt{F} and \texttt{A} is

\texttt{F.L*F.U == A[F.p, :]}

\texttt{F} further supports the following functions:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Supported function & \texttt{LU} & \texttt{LU\{T,Tridiagonal\{T\}\}} \\
\hline
\hyperlink{4103478871488785445}{\texttt{/}} & ✓ &  \\
\hline
\hyperlink{4639577998029770435}{\texttt{{\textbackslash}}} & ✓ & ✓ \\
\hline
\hyperlink{13336866048543706848}{\texttt{inv}} & ✓ & ✓ \\
\hline
\hyperlink{16543378577000914469}{\texttt{det}} & ✓ & ✓ \\
\hline
\hyperlink{12765142073947245963}{\texttt{logdet}} & ✓ & ✓ \\
\hline
\hyperlink{11067048979448481853}{\texttt{logabsdet}} & ✓ & ✓ \\
\hline
\hyperlink{17888996102305087038}{\texttt{size}} & ✓ & ✓ \\
\hline
\end{tabulary}

\end{table}

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4 3; 6 3]
2×2 Array{Int64,2}:
 4  3
 6  3

julia> F = lu(A)
LU{Float64,Array{Float64,2}}
L factor:
2×2 Array{Float64,2}:
 1.0       0.0
 0.666667  1.0
U factor:
2×2 Array{Float64,2}:
 6.0  3.0
 0.0  1.0

julia> F.L * F.U == A[F.p, :]
true

julia> l, u, p = lu(A); # destructuring via iteration

julia> l == F.L && u == F.U && p == F.p
true
\end{minted}



\end{adjustwidth}
\hypertarget{3268903080173564842}{} 
\hyperlink{3268903080173564842}{\texttt{LinearAlgebra.lu!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lu!(A, pivot=Val(true); check = true) -> LU
\end{minted}

\texttt{lu!} is the same as \hyperlink{5672569096214810830}{\texttt{lu}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. An \hyperlink{5399118524830636312}{\texttt{InexactError}} exception is thrown if the factorization produces a number not representable by the element type of \texttt{A}, e.g. for integer types.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4. 3.; 6. 3.]
2×2 Array{Float64,2}:
 4.0  3.0
 6.0  3.0

julia> F = lu!(A)
LU{Float64,Array{Float64,2}}
L factor:
2×2 Array{Float64,2}:
 1.0       0.0
 0.666667  1.0
U factor:
2×2 Array{Float64,2}:
 6.0  3.0
 0.0  1.0

julia> iA = [4 3; 6 3]
2×2 Array{Int64,2}:
 4  3
 6  3

julia> lu!(iA)
ERROR: InexactError: Int64(0.6666666666666666)
Stacktrace:
[...]
\end{minted}



\end{adjustwidth}
\hypertarget{17457903574632305101}{} 
\hyperlink{17457903574632305101}{\texttt{LinearAlgebra.Cholesky}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Cholesky <: Factorization
\end{minted}

Matrix factorization type of the Cholesky factorization of a dense symmetric/Hermitian positive definite matrix \texttt{A}. This is the return type of \hyperlink{7653413936706994771}{\texttt{cholesky}}, the corresponding matrix factorization function.

The triangular Cholesky factor can be obtained from the factorization \texttt{F::Cholesky} via \texttt{F.L} and \texttt{F.U}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]
3×3 Array{Float64,2}:
   4.0   12.0  -16.0
  12.0   37.0  -43.0
 -16.0  -43.0   98.0

julia> C = cholesky(A)
Cholesky{Float64,Array{Float64,2}}
U factor:
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia> C.U
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia> C.L
3×3 LowerTriangular{Float64,Array{Float64,2}}:
  2.0   ⋅    ⋅
  6.0  1.0   ⋅
 -8.0  5.0  3.0

julia> C.L * C.U == A
true
\end{minted}



\end{adjustwidth}
\hypertarget{9530655262094960367}{} 
\hyperlink{9530655262094960367}{\texttt{LinearAlgebra.CholeskyPivoted}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
CholeskyPivoted
\end{minted}

Matrix factorization type of the pivoted Cholesky factorization of a dense symmetric/Hermitian positive semi-definite matrix \texttt{A}. This is the return type of \hyperlink{7653413936706994771}{\texttt{cholesky(\_, Val(true))}}, the corresponding matrix factorization function.

The triangular Cholesky factor can be obtained from the factorization \texttt{F::CholeskyPivoted} via \texttt{F.L} and \texttt{F.U}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]
3×3 Array{Float64,2}:
   4.0   12.0  -16.0
  12.0   37.0  -43.0
 -16.0  -43.0   98.0

julia> C = cholesky(A, Val(true))
CholeskyPivoted{Float64,Array{Float64,2}}
U factor with rank 3:
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 9.89949  -4.34366  -1.61624
  ⋅        4.25825   1.1694
  ⋅         ⋅        0.142334
permutation:
3-element Array{Int64,1}:
 3
 2
 1
\end{minted}



\end{adjustwidth}
\hypertarget{7653413936706994771}{} 
\hyperlink{7653413936706994771}{\texttt{LinearAlgebra.cholesky}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cholesky(A, Val(false); check = true) -> Cholesky
\end{minted}

Compute the Cholesky factorization of a dense symmetric positive definite matrix \texttt{A} and return a \texttt{Cholesky} factorization. The matrix \texttt{A} can either be a \hyperlink{17683454167504168761}{\texttt{Symmetric}} or \hyperlink{938713992181310063}{\texttt{Hermitian}} \texttt{StridedMatrix} or a \emph{perfectly} symmetric or Hermitian \texttt{StridedMatrix}. The triangular Cholesky factor can be obtained from the factorization \texttt{F} with: \texttt{F.L} and \texttt{F.U}. The following functions are available for \texttt{Cholesky} objects: \hyperlink{17888996102305087038}{\texttt{size}}, \hyperlink{4639577998029770435}{\texttt{{\textbackslash}}}, \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{16543378577000914469}{\texttt{det}}, \hyperlink{12765142073947245963}{\texttt{logdet}} and \hyperlink{13841568437070319804}{\texttt{isposdef}}.

When \texttt{check = true}, an error is thrown if the decomposition fails. When \texttt{check = false}, responsibility for checking the decomposition{\textquotesingle}s validity (via \hyperlink{10694198281534172656}{\texttt{issuccess}}) lies with the user.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]
3×3 Array{Float64,2}:
   4.0   12.0  -16.0
  12.0   37.0  -43.0
 -16.0  -43.0   98.0

julia> C = cholesky(A)
Cholesky{Float64,Array{Float64,2}}
U factor:
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia> C.U
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia> C.L
3×3 LowerTriangular{Float64,Array{Float64,2}}:
  2.0   ⋅    ⋅
  6.0  1.0   ⋅
 -8.0  5.0  3.0

julia> C.L * C.U == A
true
\end{minted}




\begin{lstlisting}
cholesky(A, Val(true); tol = 0.0, check = true) -> CholeskyPivoted
\end{lstlisting}

Compute the pivoted Cholesky factorization of a dense symmetric positive semi-definite matrix \texttt{A} and return a \texttt{CholeskyPivoted} factorization. The matrix \texttt{A} can either be a \hyperlink{17683454167504168761}{\texttt{Symmetric}} or \hyperlink{938713992181310063}{\texttt{Hermitian}} \texttt{StridedMatrix} or a \emph{perfectly} symmetric or Hermitian \texttt{StridedMatrix}. The triangular Cholesky factor can be obtained from the factorization \texttt{F} with: \texttt{F.L} and \texttt{F.U}. The following functions are available for \texttt{CholeskyPivoted} objects: \hyperlink{17888996102305087038}{\texttt{size}}, \hyperlink{4639577998029770435}{\texttt{{\textbackslash}}}, \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{16543378577000914469}{\texttt{det}}, and \hyperlink{439390458422397873}{\texttt{rank}}. The argument \texttt{tol} determines the tolerance for determining the rank. For negative values, the tolerance is the machine precision.

When \texttt{check = true}, an error is thrown if the decomposition fails. When \texttt{check = false}, responsibility for checking the decomposition{\textquotesingle}s validity (via \hyperlink{10694198281534172656}{\texttt{issuccess}}) lies with the user.



\end{adjustwidth}
\hypertarget{3967830962731048730}{} 
\hyperlink{3967830962731048730}{\texttt{LinearAlgebra.cholesky!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cholesky!(A, Val(false); check = true) -> Cholesky
\end{minted}

The same as \hyperlink{7653413936706994771}{\texttt{cholesky}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. An \hyperlink{5399118524830636312}{\texttt{InexactError}} exception is thrown if the factorization produces a number not representable by the element type of \texttt{A}, e.g. for integer types.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 2 50]
2×2 Array{Int64,2}:
 1   2
 2  50

julia> cholesky!(A)
ERROR: InexactError: Int64(6.782329983125268)
Stacktrace:
[...]
\end{minted}




\begin{lstlisting}
cholesky!(A, Val(true); tol = 0.0, check = true) -> CholeskyPivoted
\end{lstlisting}

The same as \hyperlink{7653413936706994771}{\texttt{cholesky}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. An \hyperlink{5399118524830636312}{\texttt{InexactError}} exception is thrown if the factorization produces a number not representable by the element type of \texttt{A}, e.g. for integer types.



\end{adjustwidth}
\hypertarget{11384711924205954768}{} 
\hyperlink{11384711924205954768}{\texttt{LinearAlgebra.lowrankupdate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lowrankupdate(C::Cholesky, v::StridedVector) -> CC::Cholesky
\end{minted}

Update a Cholesky factorization \texttt{C} with the vector \texttt{v}. If \texttt{A = C.U{\textquotesingle}C.U} then \texttt{CC = cholesky(C.U{\textquotesingle}C.U + v*v{\textquotesingle})} but the computation of \texttt{CC} only uses \texttt{O(n{\textasciicircum}2)} operations.



\end{adjustwidth}
\hypertarget{17556419310056499978}{} 
\hyperlink{17556419310056499978}{\texttt{LinearAlgebra.lowrankdowndate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lowrankdowndate(C::Cholesky, v::StridedVector) -> CC::Cholesky
\end{minted}

Downdate a Cholesky factorization \texttt{C} with the vector \texttt{v}. If \texttt{A = C.U{\textquotesingle}C.U} then \texttt{CC = cholesky(C.U{\textquotesingle}C.U - v*v{\textquotesingle})} but the computation of \texttt{CC} only uses \texttt{O(n{\textasciicircum}2)} operations.



\end{adjustwidth}
\hypertarget{2909160594931213214}{} 
\hyperlink{2909160594931213214}{\texttt{LinearAlgebra.lowrankupdate!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lowrankupdate!(C::Cholesky, v::StridedVector) -> CC::Cholesky
\end{minted}

Update a Cholesky factorization \texttt{C} with the vector \texttt{v}. If \texttt{A = C.U{\textquotesingle}C.U} then \texttt{CC = cholesky(C.U{\textquotesingle}C.U + v*v{\textquotesingle})} but the computation of \texttt{CC} only uses \texttt{O(n{\textasciicircum}2)} operations. The input factorization \texttt{C} is updated in place such that on exit \texttt{C == CC}. The vector \texttt{v} is destroyed during the computation.



\end{adjustwidth}
\hypertarget{15152518260640180506}{} 
\hyperlink{15152518260640180506}{\texttt{LinearAlgebra.lowrankdowndate!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lowrankdowndate!(C::Cholesky, v::StridedVector) -> CC::Cholesky
\end{minted}

Downdate a Cholesky factorization \texttt{C} with the vector \texttt{v}. If \texttt{A = C.U{\textquotesingle}C.U} then \texttt{CC = cholesky(C.U{\textquotesingle}C.U - v*v{\textquotesingle})} but the computation of \texttt{CC} only uses \texttt{O(n{\textasciicircum}2)} operations. The input factorization \texttt{C} is updated in place such that on exit \texttt{C == CC}. The vector \texttt{v} is destroyed during the computation.



\end{adjustwidth}
\hypertarget{5189218595453722756}{} 
\hyperlink{5189218595453722756}{\texttt{LinearAlgebra.LDLt}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LDLt <: Factorization
\end{minted}

Matrix factorization type of the \texttt{LDLt} factorization of a real \hyperlink{6062797780727203318}{\texttt{SymTridiagonal}} matrix \texttt{S} such that \texttt{S = L*Diagonal(d)*L{\textquotesingle}}, where \texttt{L} is a \hyperlink{2163321084999097240}{\texttt{UnitLowerTriangular}} matrix and \texttt{d} is a vector. The main use of an \texttt{LDLt} factorization \texttt{F = ldlt(S)} is to solve the linear system of equations \texttt{Sx = b} with \texttt{F{\textbackslash}b}. This is the return type of \hyperlink{8934377864822491393}{\texttt{ldlt}}, the corresponding matrix factorization function.

The individual components of the factorization \texttt{F::LDLt} can be accessed via \texttt{getproperty}:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|C|L|}
\hline
Component & Description \\
\hline
\texttt{F.L} & \texttt{L} (unit lower triangular) part of \texttt{LDLt} \\
\hline
\texttt{F.D} & \texttt{D} (diagonal) part of \texttt{LDLt} \\
\hline
\texttt{F.Lt} & \texttt{Lt} (unit upper triangular) part of \texttt{LDLt} \\
\hline
\texttt{F.d} & diagonal values of \texttt{D} as a \texttt{Vector} \\
\hline
\end{tabulary}

\end{table}

\textbf{Examples}


\begin{minted}{jlcon}
julia> S = SymTridiagonal([3., 4., 5.], [1., 2.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 3.0  1.0   ⋅
 1.0  4.0  2.0
  ⋅   2.0  5.0

julia> F = ldlt(S)
LDLt{Float64,SymTridiagonal{Float64,Array{Float64,1}}}
L factor:
3×3 UnitLowerTriangular{Float64,SymTridiagonal{Float64,Array{Float64,1}}}:
 1.0        ⋅         ⋅
 0.333333  1.0        ⋅
 0.0       0.545455  1.0
D factor:
3×3 Diagonal{Float64,Array{Float64,1}}:
 3.0   ⋅        ⋅
  ⋅   3.66667   ⋅
  ⋅    ⋅       3.90909
\end{minted}



\end{adjustwidth}
\hypertarget{8934377864822491393}{} 
\hyperlink{8934377864822491393}{\texttt{LinearAlgebra.ldlt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ldlt(S::SymTridiagonal) -> LDLt
\end{minted}

Compute an \texttt{LDLt} factorization of the real symmetric tridiagonal matrix \texttt{S} such that \texttt{S = L*Diagonal(d)*L{\textquotesingle}} where \texttt{L} is a unit lower triangular matrix and \texttt{d} is a vector. The main use of an \texttt{LDLt} factorization \texttt{F = ldlt(S)} is to solve the linear system of equations \texttt{Sx = b} with \texttt{F{\textbackslash}b}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> S = SymTridiagonal([3., 4., 5.], [1., 2.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 3.0  1.0   ⋅
 1.0  4.0  2.0
  ⋅   2.0  5.0

julia> ldltS = ldlt(S);

julia> b = [6., 7., 8.];

julia> ldltS \ b
3-element Array{Float64,1}:
 1.7906976744186047
 0.627906976744186
 1.3488372093023255

julia> S \ b
3-element Array{Float64,1}:
 1.7906976744186047
 0.627906976744186
 1.3488372093023255
\end{minted}



\end{adjustwidth}
\hypertarget{9183185033445403339}{} 
\hyperlink{9183185033445403339}{\texttt{LinearAlgebra.ldlt!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ldlt!(S::SymTridiagonal) -> LDLt
\end{minted}

Same as \hyperlink{8934377864822491393}{\texttt{ldlt}}, but saves space by overwriting the input \texttt{S}, instead of creating a copy.

\textbf{Examples}


\begin{minted}{jlcon}
julia> S = SymTridiagonal([3., 4., 5.], [1., 2.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 3.0  1.0   ⋅
 1.0  4.0  2.0
  ⋅   2.0  5.0

julia> ldltS = ldlt!(S);

julia> ldltS === S
false

julia> S
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 3.0       0.333333   ⋅
 0.333333  3.66667   0.545455
  ⋅        0.545455  3.90909
\end{minted}



\end{adjustwidth}
\hypertarget{16913872014958777367}{} 
\hyperlink{16913872014958777367}{\texttt{LinearAlgebra.QR}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
QR <: Factorization
\end{minted}

A QR matrix factorization stored in a packed format, typically obtained from \hyperlink{4122539696772350360}{\texttt{qr}}. If  \(A\)  is an \texttt{m}×\texttt{n} matrix, then

\begin{equation*}
\begin{split}A = Q R\end{split}\end{equation*}
where  \(Q\)  is an orthogonal/unitary matrix and  \(R\)  is upper triangular. The matrix  \(Q\)  is stored as a sequence of Householder reflectors  \(v_i\)  and coefficients  \(\tau_i\)  where:

\begin{equation*}
\begin{split}Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T).\end{split}\end{equation*}
Iterating the decomposition produces the components \texttt{Q} and \texttt{R}.

The object has two fields:

\begin{itemize}
\item \texttt{factors} is an \texttt{m}×\texttt{n} matrix.

\begin{itemize}
\item The upper triangular part contains the elements of  \(R\) , that is \texttt{R = triu(F.factors)} for a \texttt{QR} object \texttt{F}.


\item The subdiagonal part contains the reflectors  \(v_i\)  stored in a packed format where  \(v_i\)  is the  \(i\) th column of the matrix \texttt{V = I + tril(F.factors, -1)}.

\end{itemize}

\item \texttt{τ} is a vector  of length \texttt{min(m,n)} containing the coefficients  \(au_i\) .

\end{itemize}


\end{adjustwidth}
\hypertarget{15814215390089782499}{} 
\hyperlink{15814215390089782499}{\texttt{LinearAlgebra.QRCompactWY}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
QRCompactWY <: Factorization
\end{minted}

A QR matrix factorization stored in a compact blocked format, typically obtained from \hyperlink{4122539696772350360}{\texttt{qr}}. If  \(A\)  is an \texttt{m}×\texttt{n} matrix, then

\begin{equation*}
\begin{split}A = Q R\end{split}\end{equation*}
where  \(Q\)  is an orthogonal/unitary matrix and  \(R\)  is upper triangular. It is similar to the \hyperlink{16913872014958777367}{\texttt{QR}} format except that the orthogonal/unitary matrix  \(Q\)  is stored in \emph{Compact WY} format \footnotemark[1].  For the block size  \(n_b\) , it is stored as a \texttt{m}×\texttt{n} lower trapezoidal matrix  \(V\)  and a matrix  \(T = (T_1 \; T_2 \; ... \; T_{b-1} \; T_b')\)  composed of  \(b = \lceil \min(m,n) / n_b \rceil\)  upper triangular matrices  \(T_j\)  of size  \(n_b\) × \(n_b\)  ( \(j = 1, ..., b-1\) ) and an upper trapezoidal  \(n_b\) × \(\min(m,n) - (b-1) n_b\)  matrix  \(T_b'\)  ( \(j=b\) ) whose upper square part denoted with  \(T_b\)  satisfying

\begin{equation*}
\begin{split}Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T)
= \prod_{j=1}^{b} (I - V_j T_j V_j^T)\end{split}\end{equation*}
such that  \(v_i\)  is the  \(i\) th column of  \(V\) ,  \(\tau_i\)  is the  \(i\) th element of \texttt{[diag(T\_1); diag(T\_2); …; diag(T\_b)]}, and  \((V_1 \; V_2 \; ... \; V_b)\)  is the left \texttt{m}×\texttt{min(m, n)} block of  \(V\) .  When constructed using \hyperlink{4122539696772350360}{\texttt{qr}}, the block size is given by  \(n_b = \min(m, n, 36)\) .

Iterating the decomposition produces the components \texttt{Q} and \texttt{R}.

The object has two fields:

\begin{itemize}
\item \texttt{factors}, as in the \hyperlink{16913872014958777367}{\texttt{QR}} type, is an \texttt{m}×\texttt{n} matrix.

\begin{itemize}
\item The upper triangular part contains the elements of  \(R\) , that is \texttt{R = triu(F.factors)} for a \texttt{QR} object \texttt{F}.


\item The subdiagonal part contains the reflectors  \(v_i\)  stored in a packed format such that \texttt{V = I + tril(F.factors, -1)}.

\end{itemize}

\item \texttt{T} is a  \(n_b\) -by- \(\min(m,n)\)  matrix as described above. The subdiagonal elements for each triangular matrix  \(T_j\)  are ignored.

\end{itemize}
\begin{quote}
\textbf{Note}

This format should not to be confused with the older \emph{WY} representation \footnotemark[2].

\end{quote}
\footnotetext[2]{C Bischof and C Van Loan, {\textquotedbl}The WY representation for products of Householder matrices{\textquotedbl}, SIAM J Sci Stat Comput 8 (1987), s2-s13. \href{https://doi.org/10.1137/0908009}{doi:10.1137/0908009}

}
\footnotetext[1]{R Schreiber and C Van Loan, {\textquotedbl}A storage-efficient WY representation for products of Householder transformations{\textquotedbl}, SIAM J Sci Stat Comput 10 (1989), 53-57. \href{https://doi.org/10.1137/0910005}{doi:10.1137/0910005}

}


\end{adjustwidth}
\hypertarget{1950169381798525185}{} 
\hyperlink{1950169381798525185}{\texttt{LinearAlgebra.QRPivoted}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
QRPivoted <: Factorization
\end{minted}

A QR matrix factorization with column pivoting in a packed format, typically obtained from \hyperlink{4122539696772350360}{\texttt{qr}}. If  \(A\)  is an \texttt{m}×\texttt{n} matrix, then

\begin{equation*}
\begin{split}A P = Q R\end{split}\end{equation*}
where  \(P\)  is a permutation matrix,  \(Q\)  is an orthogonal/unitary matrix and  \(R\)  is upper triangular. The matrix  \(Q\)  is stored as a sequence of Householder reflectors:

\begin{equation*}
\begin{split}Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T).\end{split}\end{equation*}
Iterating the decomposition produces the components \texttt{Q}, \texttt{R}, and \texttt{p}.

The object has three fields:

\begin{itemize}
\item \texttt{factors} is an \texttt{m}×\texttt{n} matrix.

\begin{itemize}
\item The upper triangular part contains the elements of  \(R\) , that is \texttt{R = triu(F.factors)} for a \texttt{QR} object \texttt{F}.


\item The subdiagonal part contains the reflectors  \(v_i\)  stored in a packed format where  \(v_i\)  is the  \(i\) th column of the matrix \texttt{V = I + tril(F.factors, -1)}.

\end{itemize}

\item \texttt{τ} is a vector of length \texttt{min(m,n)} containing the coefficients  \(au_i\) .


\item \texttt{jpvt} is an integer vector of length \texttt{n} corresponding to the permutation  \(P\) .

\end{itemize}


\end{adjustwidth}
\hypertarget{4122539696772350360}{} 
\hyperlink{4122539696772350360}{\texttt{LinearAlgebra.qr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
qr(A, pivot=Val(false); blocksize) -> F
\end{minted}

Compute the QR factorization of the matrix \texttt{A}: an orthogonal (or unitary if \texttt{A} is complex-valued) matrix \texttt{Q}, and an upper triangular matrix \texttt{R} such that

\begin{equation*}
\begin{split}A = Q R\end{split}\end{equation*}
The returned object \texttt{F} stores the factorization in a packed format:

\begin{itemize}
\item if \texttt{pivot == Val(true)} then \texttt{F} is a \hyperlink{1950169381798525185}{\texttt{QRPivoted}} object,


\item otherwise if the element type of \texttt{A} is a BLAS type (\hyperlink{8101639384272933082}{\texttt{Float32}}, \hyperlink{5027751419500983000}{\texttt{Float64}}, \texttt{ComplexF32} or \texttt{ComplexF64}), then \texttt{F} is a \hyperlink{15814215390089782499}{\texttt{QRCompactWY}} object,


\item otherwise \texttt{F} is a \hyperlink{16913872014958777367}{\texttt{QR}} object.

\end{itemize}
The individual components of the decomposition \texttt{F} can be retrieved via property accessors:

\begin{itemize}
\item \texttt{F.Q}: the orthogonal/unitary matrix \texttt{Q}


\item \texttt{F.R}: the upper triangular matrix \texttt{R}


\item \texttt{F.p}: the permutation vector of the pivot (\hyperlink{1950169381798525185}{\texttt{QRPivoted}} only)


\item \texttt{F.P}: the permutation matrix of the pivot (\hyperlink{1950169381798525185}{\texttt{QRPivoted}} only)

\end{itemize}
Iterating the decomposition produces the components \texttt{Q}, \texttt{R}, and if extant \texttt{p}.

The following functions are available for the \texttt{QR} objects: \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{17888996102305087038}{\texttt{size}}, and \hyperlink{4639577998029770435}{\texttt{{\textbackslash}}}. When \texttt{A} is rectangular, \texttt{{\textbackslash}} will return a least squares solution and if the solution is not unique, the one with smallest norm is returned. When \texttt{A} is not full rank, factorization with (column) pivoting is required to obtain a minimum norm solution.

Multiplication with respect to either full/square or non-full/square \texttt{Q} is allowed, i.e. both \texttt{F.Q*F.R} and \texttt{F.Q*A} are supported. A \texttt{Q} matrix can be converted into a regular matrix with \hyperlink{5448927444601277512}{\texttt{Matrix}}.  This operation returns the {\textquotedbl}thin{\textquotedbl} Q factor, i.e., if \texttt{A} is \texttt{m}×\texttt{n} with \texttt{m>=n}, then \texttt{Matrix(F.Q)} yields an \texttt{m}×\texttt{n} matrix with orthonormal columns.  To retrieve the {\textquotedbl}full{\textquotedbl} Q factor, an \texttt{m}×\texttt{m} orthogonal matrix, use \texttt{F.Q*Matrix(I,m,m)}.  If \texttt{m<=n}, then \texttt{Matrix(F.Q)} yields an \texttt{m}×\texttt{m} orthogonal matrix.

The block size for QR decomposition can be specified by keyword argument \texttt{blocksize :: Integer} when \texttt{pivot == Val(false)} and \texttt{A isa StridedMatrix\{<:BlasFloat\}}. It is ignored when \texttt{blocksize > minimum(size(A))}.  See \hyperlink{15814215390089782499}{\texttt{QRCompactWY}}.

\begin{quote}
\textbf{Julia 1.4}

The \texttt{blocksize} keyword argument requires Julia 1.4 or later.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [3.0 -6.0; 4.0 -8.0; 0.0 1.0]
3×2 Array{Float64,2}:
 3.0  -6.0
 4.0  -8.0
 0.0   1.0

julia> F = qr(A)
LinearAlgebra.QRCompactWY{Float64,Array{Float64,2}}
Q factor:
3×3 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}:
 -0.6   0.0   0.8
 -0.8   0.0  -0.6
  0.0  -1.0   0.0
R factor:
2×2 Array{Float64,2}:
 -5.0  10.0
  0.0  -1.0

julia> F.Q * F.R == A
true
\end{minted}

\begin{quote}
\textbf{Note}

\texttt{qr} returns multiple types because LAPACK uses several representations that minimize the memory storage requirements of products of Householder elementary reflectors, so that the \texttt{Q} and \texttt{R} matrices can be stored compactly rather as two separate dense matrices.

\end{quote}


\end{adjustwidth}
\hypertarget{9968830575998743150}{} 
\hyperlink{9968830575998743150}{\texttt{LinearAlgebra.qr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
qr!(A, pivot=Val(false); blocksize)
\end{minted}

\texttt{qr!} is the same as \hyperlink{4122539696772350360}{\texttt{qr}} when \texttt{A} is a subtype of \texttt{StridedMatrix}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. An \hyperlink{5399118524830636312}{\texttt{InexactError}} exception is thrown if the factorization produces a number not representable by the element type of \texttt{A}, e.g. for integer types.

\begin{quote}
\textbf{Julia 1.4}

The \texttt{blocksize} keyword argument requires Julia 1.4 or later.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1. 2.; 3. 4.]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia> qr!(a)
LinearAlgebra.QRCompactWY{Float64,Array{Float64,2}}
Q factor:
2×2 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}:
 -0.316228  -0.948683
 -0.948683   0.316228
R factor:
2×2 Array{Float64,2}:
 -3.16228  -4.42719
  0.0      -0.632456

julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> qr!(a)
ERROR: InexactError: Int64(-3.1622776601683795)
Stacktrace:
[...]
\end{minted}



\end{adjustwidth}
\hypertarget{15372856222060015568}{} 
\hyperlink{15372856222060015568}{\texttt{LinearAlgebra.LQ}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LQ <: Factorization
\end{minted}

Matrix factorization type of the \texttt{LQ} factorization of a matrix \texttt{A}. The \texttt{LQ} decomposition is the \texttt{QR} decomposition of \texttt{transpose(A)}. This is the return type of \hyperlink{1096124289761034610}{\texttt{lq}}, the corresponding matrix factorization function.

If \texttt{S::LQ} is the factorization object, the lower triangular component can be obtained via \texttt{S.L}, and the orthogonal/unitary component via \texttt{S.Q}, such that \texttt{A ≈ S.L*S.Q}.

Iterating the decomposition produces the components \texttt{S.L} and \texttt{S.Q}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [5. 7.; -2. -4.]
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia> S = lq(A)
LQ{Float64,Array{Float64,2}} with factors L and Q:
[-8.60233 0.0; 4.41741 -0.697486]
[-0.581238 -0.813733; -0.813733 0.581238]

julia> S.L * S.Q
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia> l, q = S; # destructuring via iteration

julia> l == S.L &&  q == S.Q
true
\end{minted}



\end{adjustwidth}
\hypertarget{1096124289761034610}{} 
\hyperlink{1096124289761034610}{\texttt{LinearAlgebra.lq}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lq(A) -> S::LQ
\end{minted}

Compute the LQ decomposition of \texttt{A}. The decomposition{\textquotesingle}s lower triangular component can be obtained from the \texttt{LQ} object \texttt{S} via \texttt{S.L}, and the orthogonal/unitary component via \texttt{S.Q}, such that \texttt{A ≈ S.L*S.Q}.

Iterating the decomposition produces the components \texttt{S.L} and \texttt{S.Q}.

The LQ decomposition is the QR decomposition of \texttt{transpose(A)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [5. 7.; -2. -4.]
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia> S = lq(A)
LQ{Float64,Array{Float64,2}} with factors L and Q:
[-8.60233 0.0; 4.41741 -0.697486]
[-0.581238 -0.813733; -0.813733 0.581238]

julia> S.L * S.Q
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia> l, q = S; # destructuring via iteration

julia> l == S.L &&  q == S.Q
true
\end{minted}



\end{adjustwidth}
\hypertarget{11794326565026371502}{} 
\hyperlink{11794326565026371502}{\texttt{LinearAlgebra.lq!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lq!(A) -> LQ
\end{minted}

Compute the LQ factorization of \texttt{A}, using the input matrix as a workspace. See also \hyperlink{1096124289761034610}{\texttt{lq}}.



\end{adjustwidth}
\hypertarget{10272627787201613275}{} 
\hyperlink{10272627787201613275}{\texttt{LinearAlgebra.BunchKaufman}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
BunchKaufman <: Factorization
\end{minted}

Matrix factorization type of the Bunch-Kaufman factorization of a symmetric or Hermitian matrix \texttt{A} as \texttt{P{\textquotesingle}UDU{\textquotesingle}P} or \texttt{P{\textquotesingle}LDL{\textquotesingle}P}, depending on whether the upper (the default) or the lower triangle is stored in \texttt{A}. If \texttt{A} is complex symmetric then \texttt{U{\textquotesingle}} and \texttt{L{\textquotesingle}} denote the unconjugated transposes, i.e. \texttt{transpose(U)} and \texttt{transpose(L)}, respectively. This is the return type of \hyperlink{17253210517333433448}{\texttt{bunchkaufman}}, the corresponding matrix factorization function.

If \texttt{S::BunchKaufman} is the factorization object, the components can be obtained via \texttt{S.D}, \texttt{S.U} or \texttt{S.L} as appropriate given \texttt{S.uplo}, and \texttt{S.p}.

Iterating the decomposition produces the components \texttt{S.D}, \texttt{S.U} or \texttt{S.L} as appropriate given \texttt{S.uplo}, and \texttt{S.p}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 2 3]
2×2 Array{Int64,2}:
 1  2
 2  3

julia> S = bunchkaufman(A) # A gets wrapped internally by Symmetric(A)
BunchKaufman{Float64,Array{Float64,2}}
D factor:
2×2 Tridiagonal{Float64,Array{Float64,1}}:
 -0.333333  0.0
  0.0       3.0
U factor:
2×2 UnitUpperTriangular{Float64,Array{Float64,2}}:
 1.0  0.666667
  ⋅   1.0
permutation:
2-element Array{Int64,1}:
 1
 2

julia> d, u, p = S; # destructuring via iteration

julia> d == S.D && u == S.U && p == S.p
true

julia> S = bunchkaufman(Symmetric(A, :L))
BunchKaufman{Float64,Array{Float64,2}}
D factor:
2×2 Tridiagonal{Float64,Array{Float64,1}}:
 3.0   0.0
 0.0  -0.333333
L factor:
2×2 UnitLowerTriangular{Float64,Array{Float64,2}}:
 1.0        ⋅
 0.666667  1.0
permutation:
2-element Array{Int64,1}:
 2
 1
\end{minted}



\end{adjustwidth}
\hypertarget{17253210517333433448}{} 
\hyperlink{17253210517333433448}{\texttt{LinearAlgebra.bunchkaufman}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
bunchkaufman(A, rook::Bool=false; check = true) -> S::BunchKaufman
\end{minted}

Compute the Bunch-Kaufman \footnotemark[3] factorization of a symmetric or Hermitian matrix \texttt{A} as \texttt{P{\textquotesingle}*U*D*U{\textquotesingle}*P} or \texttt{P{\textquotesingle}*L*D*L{\textquotesingle}*P}, depending on which triangle is stored in \texttt{A}, and return a \texttt{BunchKaufman} object. Note that if \texttt{A} is complex symmetric then \texttt{U{\textquotesingle}} and \texttt{L{\textquotesingle}} denote the unconjugated transposes, i.e. \texttt{transpose(U)} and \texttt{transpose(L)}.

Iterating the decomposition produces the components \texttt{S.D}, \texttt{S.U} or \texttt{S.L} as appropriate given \texttt{S.uplo}, and \texttt{S.p}.

If \texttt{rook} is \texttt{true}, rook pivoting is used. If \texttt{rook} is false, rook pivoting is not used.

When \texttt{check = true}, an error is thrown if the decomposition fails. When \texttt{check = false}, responsibility for checking the decomposition{\textquotesingle}s validity (via \hyperlink{10694198281534172656}{\texttt{issuccess}}) lies with the user.

The following functions are available for \texttt{BunchKaufman} objects: \hyperlink{17888996102305087038}{\texttt{size}}, \texttt{{\textbackslash}}, \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{2326080217547608316}{\texttt{issymmetric}}, \hyperlink{2319981190929881860}{\texttt{ishermitian}}, \hyperlink{13720608614876840481}{\texttt{getindex}}.

\footnotetext[3]{J R Bunch and L Kaufman, Some stable methods for calculating inertia and solving symmetric linear systems, Mathematics of Computation 31:137 (1977), 163-179. \href{http://www.ams.org/journals/mcom/1977-31-137/S0025-5718-1977-0428694-0/}{url}.

}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 2 3]
2×2 Array{Int64,2}:
 1  2
 2  3

julia> S = bunchkaufman(A) # A gets wrapped internally by Symmetric(A)
BunchKaufman{Float64,Array{Float64,2}}
D factor:
2×2 Tridiagonal{Float64,Array{Float64,1}}:
 -0.333333  0.0
  0.0       3.0
U factor:
2×2 UnitUpperTriangular{Float64,Array{Float64,2}}:
 1.0  0.666667
  ⋅   1.0
permutation:
2-element Array{Int64,1}:
 1
 2

julia> d, u, p = S; # destructuring via iteration

julia> d == S.D && u == S.U && p == S.p
true

julia> S = bunchkaufman(Symmetric(A, :L))
BunchKaufman{Float64,Array{Float64,2}}
D factor:
2×2 Tridiagonal{Float64,Array{Float64,1}}:
 3.0   0.0
 0.0  -0.333333
L factor:
2×2 UnitLowerTriangular{Float64,Array{Float64,2}}:
 1.0        ⋅
 0.666667  1.0
permutation:
2-element Array{Int64,1}:
 2
 1
\end{minted}



\end{adjustwidth}
\hypertarget{12377977453211508613}{} 
\hyperlink{12377977453211508613}{\texttt{LinearAlgebra.bunchkaufman!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
bunchkaufman!(A, rook::Bool=false; check = true) -> BunchKaufman
\end{minted}

\texttt{bunchkaufman!} is the same as \hyperlink{17253210517333433448}{\texttt{bunchkaufman}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy.



\end{adjustwidth}
\hypertarget{2476442734611677039}{} 
\hyperlink{2476442734611677039}{\texttt{LinearAlgebra.Eigen}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Eigen <: Factorization
\end{minted}

Matrix factorization type of the eigenvalue/spectral decomposition of a square matrix \texttt{A}. This is the return type of \hyperlink{11056016707394839114}{\texttt{eigen}}, the corresponding matrix factorization function.

If \texttt{F::Eigen} is the factorization object, the eigenvalues can be obtained via \texttt{F.values} and the eigenvectors as the columns of the matrix \texttt{F.vectors}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{F.vectors[:, k]}.)

Iterating the decomposition produces the components \texttt{F.values} and \texttt{F.vectors}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> F = eigen([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
Eigen{Float64,Float64,Array{Float64,2},Array{Float64,1}}
values:
3-element Array{Float64,1}:
  1.0
  3.0
 18.0
vectors:
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia> F.values
3-element Array{Float64,1}:
  1.0
  3.0
 18.0

julia> F.vectors
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia> vals, vecs = F; # destructuring via iteration

julia> vals == F.values && vecs == F.vectors
true
\end{minted}



\end{adjustwidth}
\hypertarget{6969744257762628976}{} 
\hyperlink{6969744257762628976}{\texttt{LinearAlgebra.GeneralizedEigen}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GeneralizedEigen <: Factorization
\end{minted}

Matrix factorization type of the generalized eigenvalue/spectral decomposition of \texttt{A} and \texttt{B}. This is the return type of \hyperlink{11056016707394839114}{\texttt{eigen}}, the corresponding matrix factorization function, when called with two matrix arguments.

If \texttt{F::GeneralizedEigen} is the factorization object, the eigenvalues can be obtained via \texttt{F.values} and the eigenvectors as the columns of the matrix \texttt{F.vectors}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{F.vectors[:, k]}.)

Iterating the decomposition produces the components \texttt{F.values} and \texttt{F.vectors}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia> B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia> F = eigen(A, B)
GeneralizedEigen{Complex{Float64},Complex{Float64},Array{Complex{Float64},2},Array{Complex{Float64},1}}
values:
2-element Array{Complex{Float64},1}:
 0.0 - 1.0im
 0.0 + 1.0im
vectors:
2×2 Array{Complex{Float64},2}:
  0.0+1.0im   0.0-1.0im
 -1.0+0.0im  -1.0-0.0im

julia> F.values
2-element Array{Complex{Float64},1}:
 0.0 - 1.0im
 0.0 + 1.0im

julia> F.vectors
2×2 Array{Complex{Float64},2}:
  0.0+1.0im   0.0-1.0im
 -1.0+0.0im  -1.0-0.0im

julia> vals, vecs = F; # destructuring via iteration

julia> vals == F.values && vecs == F.vectors
true
\end{minted}



\end{adjustwidth}
\hypertarget{12334018763942871611}{} 
\hyperlink{12334018763942871611}{\texttt{LinearAlgebra.eigvals}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eigvals(A; permute::Bool=true, scale::Bool=true, sortby) -> values
\end{minted}

Return the eigenvalues of \texttt{A}.

For general non-symmetric matrices it is possible to specify how the matrix is balanced before the eigenvalue calculation. The \texttt{permute}, \texttt{scale}, and \texttt{sortby} keywords are the same as for \hyperlink{11207008815152064958}{\texttt{eigen!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> diag_matrix = [1 0; 0 4]
2×2 Array{Int64,2}:
 1  0
 0  4

julia> eigvals(diag_matrix)
2-element Array{Float64,1}:
 1.0
 4.0
\end{minted}



For a scalar input, \texttt{eigvals} will return a scalar.

\textbf{Example}


\begin{minted}{jlcon}
julia> eigvals(-2)
-2
\end{minted}




\begin{lstlisting}
eigvals(A, B) -> values
\end{lstlisting}

Computes the generalized eigenvalues of \texttt{A} and \texttt{B}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia> B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia> eigvals(A,B)
2-element Array{Complex{Float64},1}:
 0.0 - 1.0im
 0.0 + 1.0im
\end{minted}




\begin{lstlisting}
eigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> values
\end{lstlisting}

Returns the eigenvalues of \texttt{A}. It is possible to calculate only a subset of the eigenvalues by specifying a \texttt{UnitRange} \texttt{irange} covering indices of the sorted eigenvalues, e.g. the 2nd to 8th eigenvalues.


\begin{minted}{jlcon}
julia> A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia> eigvals(A, 2:2)
1-element Array{Float64,1}:
 0.9999999999999996

julia> eigvals(A)
3-element Array{Float64,1}:
 -2.1400549446402604
  1.0000000000000002
  5.140054944640259
\end{minted}




\begin{lstlisting}
eigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> values
\end{lstlisting}

Returns the eigenvalues of \texttt{A}. It is possible to calculate only a subset of the eigenvalues by specifying a pair \texttt{vl} and \texttt{vu} for the lower and upper boundaries of the eigenvalues.


\begin{minted}{jlcon}
julia> A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia> eigvals(A, -1, 2)
1-element Array{Float64,1}:
 1.0000000000000009

julia> eigvals(A)
3-element Array{Float64,1}:
 -2.1400549446402604
  1.0000000000000002
  5.140054944640259
\end{minted}



\end{adjustwidth}
\hypertarget{10264430947938868113}{} 
\hyperlink{10264430947938868113}{\texttt{LinearAlgebra.eigvals!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eigvals!(A; permute::Bool=true, scale::Bool=true, sortby) -> values
\end{minted}

Same as \hyperlink{12334018763942871611}{\texttt{eigvals}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. The \texttt{permute}, \texttt{scale}, and \texttt{sortby} keywords are the same as for \hyperlink{11056016707394839114}{\texttt{eigen}}.

\begin{quote}
\textbf{Note}

The input matrix \texttt{A} will not contain its eigenvalues after \texttt{eigvals!} is called on it - \texttt{A} is used as a workspace.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1. 2.; 3. 4.]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia> eigvals!(A)
2-element Array{Float64,1}:
 -0.3722813232690143
  5.372281323269014

julia> A
2×2 Array{Float64,2}:
 -0.372281  -1.0
  0.0        5.37228
\end{minted}




\begin{lstlisting}
eigvals!(A, B; sortby) -> values
\end{lstlisting}

Same as \hyperlink{12334018763942871611}{\texttt{eigvals}}, but saves space by overwriting the input \texttt{A} (and \texttt{B}), instead of creating copies.

\begin{quote}
\textbf{Note}

The input matrices \texttt{A} and \texttt{B} will not contain their eigenvalues after \texttt{eigvals!} is called. They are used as workspaces.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1. 0.; 0. -1.]
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia> B = [0. 1.; 1. 0.]
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia> eigvals!(A, B)
2-element Array{Complex{Float64},1}:
 0.0 - 1.0im
 0.0 + 1.0im

julia> A
2×2 Array{Float64,2}:
 -0.0  -1.0
  1.0  -0.0

julia> B
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0
\end{minted}




\begin{lstlisting}
eigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> values
\end{lstlisting}

Same as \hyperlink{12334018763942871611}{\texttt{eigvals}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. \texttt{irange} is a range of eigenvalue \emph{indices} to search for - for instance, the 2nd to 8th eigenvalues.




\begin{lstlisting}
eigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> values
\end{lstlisting}

Same as \hyperlink{12334018763942871611}{\texttt{eigvals}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. \texttt{vl} is the lower bound of the interval to search for eigenvalues, and \texttt{vu} is the upper bound.



\end{adjustwidth}
\hypertarget{1568196261511691624}{} 
\hyperlink{1568196261511691624}{\texttt{LinearAlgebra.eigmax}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eigmax(A; permute::Bool=true, scale::Bool=true)
\end{minted}

Return the largest eigenvalue of \texttt{A}. The option \texttt{permute=true} permutes the matrix to become closer to upper triangular, and \texttt{scale=true} scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of \texttt{A} are complex, this method will fail, since complex numbers cannot be sorted.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [0 im; -im 0]
2×2 Array{Complex{Int64},2}:
 0+0im  0+1im
 0-1im  0+0im

julia> eigmax(A)
1.0

julia> A = [0 im; -1 0]
2×2 Array{Complex{Int64},2}:
  0+0im  0+1im
 -1+0im  0+0im

julia> eigmax(A)
ERROR: DomainError with Complex{Int64}[0+0im 0+1im; -1+0im 0+0im]:
`A` cannot have complex eigenvalues.
Stacktrace:
[...]
\end{minted}



\end{adjustwidth}
\hypertarget{658135215942727363}{} 
\hyperlink{658135215942727363}{\texttt{LinearAlgebra.eigmin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eigmin(A; permute::Bool=true, scale::Bool=true)
\end{minted}

Return the smallest eigenvalue of \texttt{A}. The option \texttt{permute=true} permutes the matrix to become closer to upper triangular, and \texttt{scale=true} scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of \texttt{A} are complex, this method will fail, since complex numbers cannot be sorted.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [0 im; -im 0]
2×2 Array{Complex{Int64},2}:
 0+0im  0+1im
 0-1im  0+0im

julia> eigmin(A)
-1.0

julia> A = [0 im; -1 0]
2×2 Array{Complex{Int64},2}:
  0+0im  0+1im
 -1+0im  0+0im

julia> eigmin(A)
ERROR: DomainError with Complex{Int64}[0+0im 0+1im; -1+0im 0+0im]:
`A` cannot have complex eigenvalues.
Stacktrace:
[...]
\end{minted}



\end{adjustwidth}
\hypertarget{8591842276375230542}{} 
\hyperlink{8591842276375230542}{\texttt{LinearAlgebra.eigvecs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eigvecs(A::SymTridiagonal[, eigvals]) -> Matrix
\end{minted}

Return a matrix \texttt{M} whose columns are the eigenvectors of \texttt{A}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{M[:, k]}.)

If the optional vector of eigenvalues \texttt{eigvals} is specified, \texttt{eigvecs} returns the specific corresponding eigenvectors.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia> eigvals(A)
3-element Array{Float64,1}:
 -2.1400549446402604
  1.0000000000000002
  5.140054944640259

julia> eigvecs(A)
3×3 Array{Float64,2}:
  0.418304  -0.83205      0.364299
 -0.656749  -7.39009e-16  0.754109
  0.627457   0.5547       0.546448

julia> eigvecs(A, [1.])
3×1 Array{Float64,2}:
  0.8320502943378438
  4.263514128092366e-17
 -0.5547001962252291
\end{minted}




\begin{lstlisting}
eigvecs(A; permute::Bool=true, scale::Bool=true, `sortby`) -> Matrix
\end{lstlisting}

Return a matrix \texttt{M} whose columns are the eigenvectors of \texttt{A}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{M[:, k]}.) The \texttt{permute}, \texttt{scale}, and \texttt{sortby} keywords are the same as for \hyperlink{11056016707394839114}{\texttt{eigen}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> eigvecs([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0
\end{minted}




\begin{lstlisting}
eigvecs(A, B) -> Matrix
\end{lstlisting}

Return a matrix \texttt{M} whose columns are the generalized eigenvectors of \texttt{A} and \texttt{B}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{M[:, k]}.)

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia> B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia> eigvecs(A, B)
2×2 Array{Complex{Float64},2}:
  0.0+1.0im   0.0-1.0im
 -1.0+0.0im  -1.0-0.0im
\end{minted}



\end{adjustwidth}
\hypertarget{11056016707394839114}{} 
\hyperlink{11056016707394839114}{\texttt{LinearAlgebra.eigen}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eigen(A; permute::Bool=true, scale::Bool=true, sortby) -> Eigen
\end{minted}

Computes the eigenvalue decomposition of \texttt{A}, returning an \texttt{Eigen} factorization object \texttt{F} which contains the eigenvalues in \texttt{F.values} and the eigenvectors in the columns of the matrix \texttt{F.vectors}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{F.vectors[:, k]}.)

Iterating the decomposition produces the components \texttt{F.values} and \texttt{F.vectors}.

The following functions are available for \texttt{Eigen} objects: \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{16543378577000914469}{\texttt{det}}, and \hyperlink{13841568437070319804}{\texttt{isposdef}}.

For general nonsymmetric matrices it is possible to specify how the matrix is balanced before the eigenvector calculation. The option \texttt{permute=true} permutes the matrix to become closer to upper triangular, and \texttt{scale=true} scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is \texttt{true} for both options.

By default, the eigenvalues and vectors are sorted lexicographically by \texttt{(real(λ),imag(λ))}. A different comparison function \texttt{by(λ)} can be passed to \texttt{sortby}, or you can pass \texttt{sortby=nothing} to leave the eigenvalues in an arbitrary order.   Some special matrix types (e.g. \texttt{Diagonal} or \texttt{SymTridiagonal}) may implement their own sorting convention and not accept a \texttt{sortby} keyword.

\textbf{Examples}


\begin{minted}{jlcon}
julia> F = eigen([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
Eigen{Float64,Float64,Array{Float64,2},Array{Float64,1}}
values:
3-element Array{Float64,1}:
  1.0
  3.0
 18.0
vectors:
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia> F.values
3-element Array{Float64,1}:
  1.0
  3.0
 18.0

julia> F.vectors
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia> vals, vecs = F; # destructuring via iteration

julia> vals == F.values && vecs == F.vectors
true
\end{minted}




\begin{lstlisting}
eigen(A, B) -> GeneralizedEigen
\end{lstlisting}

Computes the generalized eigenvalue decomposition of \texttt{A} and \texttt{B}, returning a \texttt{GeneralizedEigen} factorization object \texttt{F} which contains the generalized eigenvalues in \texttt{F.values} and the generalized eigenvectors in the columns of the matrix \texttt{F.vectors}. (The \texttt{k}th generalized eigenvector can be obtained from the slice \texttt{F.vectors[:, k]}.)

Iterating the decomposition produces the components \texttt{F.values} and \texttt{F.vectors}.

Any keyword arguments passed to \texttt{eigen} are passed through to the lower-level \hyperlink{11207008815152064958}{\texttt{eigen!}} function.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia> B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia> F = eigen(A, B);

julia> F.values
2-element Array{Complex{Float64},1}:
 0.0 - 1.0im
 0.0 + 1.0im

julia> F.vectors
2×2 Array{Complex{Float64},2}:
  0.0+1.0im   0.0-1.0im
 -1.0+0.0im  -1.0-0.0im

julia> vals, vecs = F; # destructuring via iteration

julia> vals == F.values && vecs == F.vectors
true
\end{minted}




\begin{lstlisting}
eigen(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> Eigen
\end{lstlisting}

Computes the eigenvalue decomposition of \texttt{A}, returning an \texttt{Eigen} factorization object \texttt{F} which contains the eigenvalues in \texttt{F.values} and the eigenvectors in the columns of the matrix \texttt{F.vectors}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{F.vectors[:, k]}.)

Iterating the decomposition produces the components \texttt{F.values} and \texttt{F.vectors}.

The following functions are available for \texttt{Eigen} objects: \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{16543378577000914469}{\texttt{det}}, and \hyperlink{13841568437070319804}{\texttt{isposdef}}.

The \texttt{UnitRange} \texttt{irange} specifies indices of the sorted eigenvalues to search for.

\begin{quote}
\textbf{Note}

If \texttt{irange} is not \texttt{1:n}, where \texttt{n} is the dimension of \texttt{A}, then the returned factorization will be a \emph{truncated} factorization.

\end{quote}



\begin{lstlisting}
eigen(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> Eigen
\end{lstlisting}

Computes the eigenvalue decomposition of \texttt{A}, returning an \texttt{Eigen} factorization object \texttt{F} which contains the eigenvalues in \texttt{F.values} and the eigenvectors in the columns of the matrix \texttt{F.vectors}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{F.vectors[:, k]}.)

Iterating the decomposition produces the components \texttt{F.values} and \texttt{F.vectors}.

The following functions are available for \texttt{Eigen} objects: \hyperlink{13336866048543706848}{\texttt{inv}}, \hyperlink{16543378577000914469}{\texttt{det}}, and \hyperlink{13841568437070319804}{\texttt{isposdef}}.

\texttt{vl} is the lower bound of the window of eigenvalues to search for, and \texttt{vu} is the upper bound.

\begin{quote}
\textbf{Note}

If [\texttt{vl}, \texttt{vu}] does not contain all eigenvalues of \texttt{A}, then the returned factorization will be a \emph{truncated} factorization.

\end{quote}


\end{adjustwidth}
\hypertarget{11207008815152064958}{} 
\hyperlink{11207008815152064958}{\texttt{LinearAlgebra.eigen!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
eigen!(A, [B]; permute, scale, sortby)
\end{minted}

Same as \hyperlink{11056016707394839114}{\texttt{eigen}}, but saves space by overwriting the input \texttt{A} (and \texttt{B}), instead of creating a copy.



\end{adjustwidth}
\hypertarget{17562496283230520715}{} 
\hyperlink{17562496283230520715}{\texttt{LinearAlgebra.Hessenberg}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Hessenberg <: Factorization
\end{minted}

A \texttt{Hessenberg} object represents the Hessenberg factorization \texttt{QHQ{\textquotesingle}} of a square matrix, or a shift \texttt{Q(H+μI)Q{\textquotesingle}} thereof, which is produced by the \hyperlink{14451165250498024497}{\texttt{hessenberg}} function.



\end{adjustwidth}
\hypertarget{14451165250498024497}{} 
\hyperlink{14451165250498024497}{\texttt{LinearAlgebra.hessenberg}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hessenberg(A) -> Hessenberg
\end{minted}

Compute the Hessenberg decomposition of \texttt{A} and return a \texttt{Hessenberg} object. If \texttt{F} is the factorization object, the unitary matrix can be accessed with \texttt{F.Q} (of type \texttt{LinearAlgebra.HessenbergQ}) and the Hessenberg matrix with \texttt{F.H} (of type \hyperlink{6167777885202579792}{\texttt{UpperHessenberg}}), either of which may be converted to a regular matrix with \texttt{Matrix(F.H)} or \texttt{Matrix(F.Q)}.

If \texttt{A} is \hyperlink{938713992181310063}{\texttt{Hermitian}} or real-\hyperlink{17683454167504168761}{\texttt{Symmetric}}, then the Hessenberg decomposition produces a real-symmetric tridiagonal matrix and \texttt{F.H} is of type \hyperlink{6062797780727203318}{\texttt{SymTridiagonal}}.

Note that the shifted factorization \texttt{A+μI = Q (H+μI) Q{\textquotesingle}} can be constructed efficiently by \texttt{F + μ*I} using the \hyperlink{723087258311673942}{\texttt{UniformScaling}} object \hyperlink{15346645596018210602}{\texttt{I}}, which creates a new \texttt{Hessenberg} object with shared storage and a modified shift.   The shift of a given \texttt{F} is obtained by \texttt{F.μ}. This is useful because multiple shifted solves \texttt{(F + μ*I) {\textbackslash} b} (for different \texttt{μ} and/or \texttt{b}) can be performed efficiently once \texttt{F} is created.

Iterating the decomposition produces the factors \texttt{F.Q, F.H, F.μ}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4. 9. 7.; 4. 4. 1.; 4. 3. 2.]
3×3 Array{Float64,2}:
 4.0  9.0  7.0
 4.0  4.0  1.0
 4.0  3.0  2.0

julia> F = hessenberg(A)
Hessenberg{Float64,UpperHessenberg{Float64,Array{Float64,2}},Array{Float64,2},Array{Float64,1},Bool}
Q factor:
3×3 LinearAlgebra.HessenbergQ{Float64,Array{Float64,2},Array{Float64,1},false}:
 1.0   0.0        0.0
 0.0  -0.707107  -0.707107
 0.0  -0.707107   0.707107
H factor:
3×3 UpperHessenberg{Float64,Array{Float64,2}}:
  4.0      -11.3137       -1.41421
 -5.65685    5.0           2.0
   ⋅        -8.88178e-16   1.0

julia> F.Q * F.H * F.Q'
3×3 Array{Float64,2}:
 4.0  9.0  7.0
 4.0  4.0  1.0
 4.0  3.0  2.0

julia> q, h = F; # destructuring via iteration

julia> q == F.Q && h == F.H
true
\end{minted}



\end{adjustwidth}
\hypertarget{6911141030439555603}{} 
\hyperlink{6911141030439555603}{\texttt{LinearAlgebra.hessenberg!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hessenberg!(A) -> Hessenberg
\end{minted}

\texttt{hessenberg!} is the same as \hyperlink{14451165250498024497}{\texttt{hessenberg}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy.



\end{adjustwidth}
\hypertarget{9412476259327688170}{} 
\hyperlink{9412476259327688170}{\texttt{LinearAlgebra.Schur}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Schur <: Factorization
\end{minted}

Matrix factorization type of the Schur factorization of a matrix \texttt{A}. This is the return type of \hyperlink{17132870828407138368}{\texttt{schur(\_)}}, the corresponding matrix factorization function.

If \texttt{F::Schur} is the factorization object, the (quasi) triangular Schur factor can be obtained via either \texttt{F.Schur} or \texttt{F.T} and the orthogonal/unitary Schur vectors via \texttt{F.vectors} or \texttt{F.Z} such that \texttt{A = F.vectors * F.Schur * F.vectors{\textquotesingle}}. The eigenvalues of \texttt{A} can be obtained with \texttt{F.values}.

Iterating the decomposition produces the components \texttt{F.T}, \texttt{F.Z}, and \texttt{F.values}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [5. 7.; -2. -4.]
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia> F = schur(A)
Schur{Float64,Array{Float64,2}}
T factor:
2×2 Array{Float64,2}:
 3.0   9.0
 0.0  -2.0
Z factor:
2×2 Array{Float64,2}:
  0.961524  0.274721
 -0.274721  0.961524
eigenvalues:
2-element Array{Float64,1}:
  3.0
 -2.0

julia> F.vectors * F.Schur * F.vectors'
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia> t, z, vals = F; # destructuring via iteration

julia> t == F.T && z == F.Z && vals == F.values
true
\end{minted}



\end{adjustwidth}
\hypertarget{6518772096850576950}{} 
\hyperlink{6518772096850576950}{\texttt{LinearAlgebra.GeneralizedSchur}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GeneralizedSchur <: Factorization
\end{minted}

Matrix factorization type of the generalized Schur factorization of two matrices \texttt{A} and \texttt{B}. This is the return type of \hyperlink{17132870828407138368}{\texttt{schur(\_, \_)}}, the corresponding matrix factorization function.

If \texttt{F::GeneralizedSchur} is the factorization object, the (quasi) triangular Schur factors can be obtained via \texttt{F.S} and \texttt{F.T}, the left unitary/orthogonal Schur vectors via \texttt{F.left} or \texttt{F.Q}, and the right unitary/orthogonal Schur vectors can be obtained with \texttt{F.right} or \texttt{F.Z} such that \texttt{A=F.left*F.S*F.right{\textquotesingle}} and \texttt{B=F.left*F.T*F.right{\textquotesingle}}. The generalized eigenvalues of \texttt{A} and \texttt{B} can be obtained with \texttt{F.α./F.β}.

Iterating the decomposition produces the components \texttt{F.S}, \texttt{F.T}, \texttt{F.Q}, \texttt{F.Z}, \texttt{F.α}, and \texttt{F.β}.



\end{adjustwidth}
\hypertarget{17132870828407138368}{} 
\hyperlink{17132870828407138368}{\texttt{LinearAlgebra.schur}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
schur(A::StridedMatrix) -> F::Schur
\end{minted}

Computes the Schur factorization of the matrix \texttt{A}. The (quasi) triangular Schur factor can be obtained from the \texttt{Schur} object \texttt{F} with either \texttt{F.Schur} or \texttt{F.T} and the orthogonal/unitary Schur vectors can be obtained with \texttt{F.vectors} or \texttt{F.Z} such that \texttt{A = F.vectors * F.Schur * F.vectors{\textquotesingle}}. The eigenvalues of \texttt{A} can be obtained with \texttt{F.values}.

Iterating the decomposition produces the components \texttt{F.T}, \texttt{F.Z}, and \texttt{F.values}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [5. 7.; -2. -4.]
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia> F = schur(A)
Schur{Float64,Array{Float64,2}}
T factor:
2×2 Array{Float64,2}:
 3.0   9.0
 0.0  -2.0
Z factor:
2×2 Array{Float64,2}:
  0.961524  0.274721
 -0.274721  0.961524
eigenvalues:
2-element Array{Float64,1}:
  3.0
 -2.0

julia> F.vectors * F.Schur * F.vectors'
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia> t, z, vals = F; # destructuring via iteration

julia> t == F.T && z == F.Z && vals == F.values
true
\end{minted}




\begin{lstlisting}
schur(A::StridedMatrix, B::StridedMatrix) -> F::GeneralizedSchur
\end{lstlisting}

Computes the Generalized Schur (or QZ) factorization of the matrices \texttt{A} and \texttt{B}. The (quasi) triangular Schur factors can be obtained from the \texttt{Schur} object \texttt{F} with \texttt{F.S} and \texttt{F.T}, the left unitary/orthogonal Schur vectors can be obtained with \texttt{F.left} or \texttt{F.Q} and the right unitary/orthogonal Schur vectors can be obtained with \texttt{F.right} or \texttt{F.Z} such that \texttt{A=F.left*F.S*F.right{\textquotesingle}} and \texttt{B=F.left*F.T*F.right{\textquotesingle}}. The generalized eigenvalues of \texttt{A} and \texttt{B} can be obtained with \texttt{F.α./F.β}.

Iterating the decomposition produces the components \texttt{F.S}, \texttt{F.T}, \texttt{F.Q}, \texttt{F.Z}, \texttt{F.α}, and \texttt{F.β}.



\end{adjustwidth}
\hypertarget{17231330544698367907}{} 
\hyperlink{17231330544698367907}{\texttt{LinearAlgebra.schur!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
schur!(A::StridedMatrix) -> F::Schur
\end{minted}

Same as \hyperlink{17132870828407138368}{\texttt{schur}} but uses the input argument \texttt{A} as workspace.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [5. 7.; -2. -4.]
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia> F = schur!(A)
Schur{Float64,Array{Float64,2}}
T factor:
2×2 Array{Float64,2}:
 3.0   9.0
 0.0  -2.0
Z factor:
2×2 Array{Float64,2}:
  0.961524  0.274721
 -0.274721  0.961524
eigenvalues:
2-element Array{Float64,1}:
  3.0
 -2.0

julia> A
2×2 Array{Float64,2}:
 3.0   9.0
 0.0  -2.0
\end{minted}




\begin{lstlisting}
schur!(A::StridedMatrix, B::StridedMatrix) -> F::GeneralizedSchur
\end{lstlisting}

Same as \hyperlink{17132870828407138368}{\texttt{schur}} but uses the input matrices \texttt{A} and \texttt{B} as workspace.



\end{adjustwidth}
\hypertarget{4329711108255537481}{} 
\hyperlink{4329711108255537481}{\texttt{LinearAlgebra.ordschur}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ordschur(F::Schur, select::Union{Vector{Bool},BitVector}) -> F::Schur
\end{minted}

Reorders the Schur factorization \texttt{F} of a matrix \texttt{A = Z*T*Z{\textquotesingle}} according to the logical array \texttt{select} returning the reordered factorization \texttt{F} object. The selected eigenvalues appear in the leading diagonal of \texttt{F.Schur} and the corresponding leading columns of \texttt{F.vectors} form an orthogonal/unitary basis of the corresponding right invariant subspace. In the real case, a complex conjugate pair of eigenvalues must be either both included or both excluded via \texttt{select}.




\begin{lstlisting}
ordschur(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -> F::GeneralizedSchur
\end{lstlisting}

Reorders the Generalized Schur factorization \texttt{F} of a matrix pair \texttt{(A, B) = (Q*S*Z{\textquotesingle}, Q*T*Z{\textquotesingle})} according to the logical array \texttt{select} and returns a GeneralizedSchur object \texttt{F}. The selected eigenvalues appear in the leading diagonal of both \texttt{F.S} and \texttt{F.T}, and the left and right orthogonal/unitary Schur vectors are also reordered such that \texttt{(A, B) = F.Q*(F.S, F.T)*F.Z{\textquotesingle}} still holds and the generalized eigenvalues of \texttt{A} and \texttt{B} can still be obtained with \texttt{F.α./F.β}.



\end{adjustwidth}
\hypertarget{871218922691469554}{} 
\hyperlink{871218922691469554}{\texttt{LinearAlgebra.ordschur!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ordschur!(F::Schur, select::Union{Vector{Bool},BitVector}) -> F::Schur
\end{minted}

Same as \hyperlink{4329711108255537481}{\texttt{ordschur}} but overwrites the factorization \texttt{F}.




\begin{lstlisting}
ordschur!(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -> F::GeneralizedSchur
\end{lstlisting}

Same as \texttt{ordschur} but overwrites the factorization \texttt{F}.



\end{adjustwidth}
\hypertarget{10448068302163375703}{} 
\hyperlink{10448068302163375703}{\texttt{LinearAlgebra.SVD}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SVD <: Factorization
\end{minted}

Matrix factorization type of the singular value decomposition (SVD) of a matrix \texttt{A}. This is the return type of \hyperlink{6661056220970412040}{\texttt{svd(\_)}}, the corresponding matrix factorization function.

If \texttt{F::SVD} is the factorization object, \texttt{U}, \texttt{S}, \texttt{V} and \texttt{Vt} can be obtained via \texttt{F.U}, \texttt{F.S}, \texttt{F.V} and \texttt{F.Vt}, such that \texttt{A = U * Diagonal(S) * Vt}. The singular values in \texttt{S} are sorted in descending order.

Iterating the decomposition produces the components \texttt{U}, \texttt{S}, and \texttt{V}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia> F = svd(A)
SVD{Float64,Float64,Array{Float64,2}}
U factor:
4×4 Array{Float64,2}:
 0.0  1.0  0.0   0.0
 1.0  0.0  0.0   0.0
 0.0  0.0  0.0  -1.0
 0.0  0.0  1.0   0.0
singular values:
4-element Array{Float64,1}:
 3.0
 2.23606797749979
 2.0
 0.0
Vt factor:
4×5 Array{Float64,2}:
 -0.0       0.0  1.0  -0.0  0.0
  0.447214  0.0  0.0   0.0  0.894427
 -0.0       1.0  0.0  -0.0  0.0
  0.0       0.0  0.0   1.0  0.0

julia> F.U * Diagonal(F.S) * F.Vt
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia> u, s, v = F; # destructuring via iteration

julia> u == F.U && s == F.S && v == F.V
true
\end{minted}



\end{adjustwidth}
\hypertarget{16156328526785145806}{} 
\hyperlink{16156328526785145806}{\texttt{LinearAlgebra.GeneralizedSVD}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
GeneralizedSVD <: Factorization
\end{minted}

Matrix factorization type of the generalized singular value decomposition (SVD) of two matrices \texttt{A} and \texttt{B}, such that \texttt{A = F.U*F.D1*F.R0*F.Q{\textquotesingle}} and \texttt{B = F.V*F.D2*F.R0*F.Q{\textquotesingle}}. This is the return type of \hyperlink{6661056220970412040}{\texttt{svd(\_, \_)}}, the corresponding matrix factorization function.

For an M-by-N matrix \texttt{A} and P-by-N matrix \texttt{B},

\begin{itemize}
\item \texttt{U} is a M-by-M orthogonal matrix,


\item \texttt{V} is a P-by-P orthogonal matrix,


\item \texttt{Q} is a N-by-N orthogonal matrix,


\item \texttt{D1} is a M-by-(K+L) diagonal matrix with 1s in the first K entries,


\item \texttt{D2} is a P-by-(K+L) matrix whose top right L-by-L block is diagonal,


\item \texttt{R0} is a (K+L)-by-N matrix whose rightmost (K+L)-by-(K+L) block is          nonsingular upper block triangular,

\end{itemize}
\texttt{K+L} is the effective numerical rank of the matrix \texttt{[A; B]}.

Iterating the decomposition produces the components \texttt{U}, \texttt{V}, \texttt{Q}, \texttt{D1}, \texttt{D2}, and \texttt{R0}.

The entries of \texttt{F.D1} and \texttt{F.D2} are related, as explained in the LAPACK documentation for the \href{http://www.netlib.org/lapack/lug/node36.html}{generalized SVD} and the \href{http://www.netlib.org/lapack/explore-html/d6/db3/dggsvd3\_8f.html}{xGGSVD3} routine which is called underneath (in LAPACK 3.6.0 and newer).

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1. 0.; 0. -1.]
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia> B = [0. 1.; 1. 0.]
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia> F = svd(A, B)
GeneralizedSVD{Float64,Array{Float64,2}}
U factor:
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0
V factor:
2×2 Array{Float64,2}:
 -0.0  -1.0
  1.0   0.0
Q factor:
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0
D1 factor:
2×2 SparseArrays.SparseMatrixCSC{Float64,Int64} with 2 stored entries:
  [1, 1]  =  0.707107
  [2, 2]  =  0.707107
D2 factor:
2×2 SparseArrays.SparseMatrixCSC{Float64,Int64} with 2 stored entries:
  [1, 1]  =  0.707107
  [2, 2]  =  0.707107
R0 factor:
2×2 Array{Float64,2}:
 1.41421   0.0
 0.0      -1.41421

julia> F.U*F.D1*F.R0*F.Q'
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia> F.V*F.D2*F.R0*F.Q'
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0
\end{minted}



\end{adjustwidth}
\hypertarget{6661056220970412040}{} 
\hyperlink{6661056220970412040}{\texttt{LinearAlgebra.svd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
svd(A; full::Bool = false, alg::Algorithm = default_svd_alg(A)) -> SVD
\end{minted}

Compute the singular value decomposition (SVD) of \texttt{A} and return an \texttt{SVD} object.

\texttt{U}, \texttt{S}, \texttt{V} and \texttt{Vt} can be obtained from the factorization \texttt{F} with \texttt{F.U}, \texttt{F.S}, \texttt{F.V} and \texttt{F.Vt}, such that \texttt{A = U * Diagonal(S) * Vt}. The algorithm produces \texttt{Vt} and hence \texttt{Vt} is more efficient to extract than \texttt{V}. The singular values in \texttt{S} are sorted in descending order.

Iterating the decomposition produces the components \texttt{U}, \texttt{S}, and \texttt{V}.

If \texttt{full = false} (default), a {\textquotedbl}thin{\textquotedbl} SVD is returned. For a  \(M \times N\)  matrix \texttt{A}, in the full factorization \texttt{U} is \texttt{M {\textbackslash}times M} and \texttt{V} is \texttt{N {\textbackslash}times N}, while in the thin factorization \texttt{U} is \texttt{M {\textbackslash}times K} and \texttt{V} is \texttt{N {\textbackslash}times K}, where \texttt{K = {\textbackslash}min(M,N)} is the number of singular values.

If \texttt{alg = DivideAndConquer()} a divide-and-conquer algorithm is used to calculate the SVD. Another (typically slower but more accurate) option is \texttt{alg = QRIteration()}.

\begin{quote}
\textbf{Julia 1.3}

The \texttt{alg} keyword argument requires Julia 1.3 or later.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = rand(4,3);

julia> F = svd(A); # Store the Factorization Object

julia> A ≈ F.U * Diagonal(F.S) * F.Vt
true

julia> U, S, V = F; # destructuring via iteration

julia> A ≈ U * Diagonal(S) * V'
true

julia> Uonly, = svd(A); # Store U only

julia> Uonly == U
true
\end{minted}




\begin{lstlisting}
svd(A, B) -> GeneralizedSVD
\end{lstlisting}

Compute the generalized SVD of \texttt{A} and \texttt{B}, returning a \texttt{GeneralizedSVD} factorization object \texttt{F} such that \texttt{[A;B] = [F.U * F.D1; F.V * F.D2] * F.R0 * F.Q{\textquotesingle}}

\begin{itemize}
\item \texttt{U} is a M-by-M orthogonal matrix,


\item \texttt{V} is a P-by-P orthogonal matrix,


\item \texttt{Q} is a N-by-N orthogonal matrix,


\item \texttt{D1} is a M-by-(K+L) diagonal matrix with 1s in the first K entries,


\item \texttt{D2} is a P-by-(K+L) matrix whose top right L-by-L block is diagonal,


\item \texttt{R0} is a (K+L)-by-N matrix whose rightmost (K+L)-by-(K+L) block is          nonsingular upper block triangular,

\end{itemize}
\texttt{K+L} is the effective numerical rank of the matrix \texttt{[A; B]}.

Iterating the decomposition produces the components \texttt{U}, \texttt{V}, \texttt{Q}, \texttt{D1}, \texttt{D2}, and \texttt{R0}.

The generalized SVD is used in applications such as when one wants to compare how much belongs to \texttt{A} vs. how much belongs to \texttt{B}, as in human vs yeast genome, or signal vs noise, or between clusters vs within clusters. (See Edelman and Wang for discussion: https://arxiv.org/abs/1901.00485)

It decomposes \texttt{[A; B]} into \texttt{[UC; VS]H}, where \texttt{[UC; VS]} is a natural orthogonal basis for the column space of \texttt{[A; B]}, and \texttt{H = RQ{\textquotesingle}} is a natural non-orthogonal basis for the rowspace of \texttt{[A;B]}, where the top rows are most closely attributed to the \texttt{A} matrix, and the bottom to the \texttt{B} matrix. The multi-cosine/sine matrices \texttt{C} and \texttt{S} provide a multi-measure of how much \texttt{A} vs how much \texttt{B}, and \texttt{U} and \texttt{V} provide directions in which these are measured.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = randn(3,2); B=randn(4,2);

julia> F = svd(A, B);

julia> U,V,Q,C,S,R = F;

julia> H = R*Q';

julia> [A; B] ≈ [U*C; V*S]*H
true

julia> [A; B] ≈ [F.U*F.D1; F.V*F.D2]*F.R0*F.Q'
true

julia> Uonly, = svd(A,B);

julia> U == Uonly
true
\end{minted}



\end{adjustwidth}
\hypertarget{7585497127906495351}{} 
\hyperlink{7585497127906495351}{\texttt{LinearAlgebra.svd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
svd!(A; full::Bool = false, alg::Algorithm = default_svd_alg(A)) -> SVD
\end{minted}

\texttt{svd!} is the same as \hyperlink{6661056220970412040}{\texttt{svd}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. See documentation of \hyperlink{6661056220970412040}{\texttt{svd}} for details. ```




\begin{lstlisting}
svd!(A, B) -> GeneralizedSVD
\end{lstlisting}

\texttt{svd!} is the same as \hyperlink{6661056220970412040}{\texttt{svd}}, but modifies the arguments \texttt{A} and \texttt{B} in-place, instead of making copies. See documentation of \hyperlink{6661056220970412040}{\texttt{svd}} for details. ```



\end{adjustwidth}
\hypertarget{12905968661134086149}{} 
\hyperlink{12905968661134086149}{\texttt{LinearAlgebra.svdvals}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
svdvals(A)
\end{minted}

Return the singular values of \texttt{A} in descending order.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia> svdvals(A)
4-element Array{Float64,1}:
 3.0
 2.23606797749979
 2.0
 0.0
\end{minted}




\begin{lstlisting}
svdvals(A, B)
\end{lstlisting}

Return the generalized singular values from the generalized singular value decomposition of \texttt{A} and \texttt{B}. See also \hyperlink{6661056220970412040}{\texttt{svd}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1. 0.; 0. -1.]
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia> B = [0. 1.; 1. 0.]
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia> svdvals(A, B)
2-element Array{Float64,1}:
 1.0
 1.0
\end{minted}



\end{adjustwidth}
\hypertarget{590278903094160607}{} 
\hyperlink{590278903094160607}{\texttt{LinearAlgebra.svdvals!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
svdvals!(A)
\end{minted}

Return the singular values of \texttt{A}, saving space by overwriting the input. See also \hyperlink{12905968661134086149}{\texttt{svdvals}} and \hyperlink{6661056220970412040}{\texttt{svd}}. ```




\begin{lstlisting}
svdvals!(A, B)
\end{lstlisting}

Return the generalized singular values from the generalized singular value decomposition of \texttt{A} and \texttt{B}, saving space by overwriting \texttt{A} and \texttt{B}. See also \hyperlink{6661056220970412040}{\texttt{svd}} and \hyperlink{12905968661134086149}{\texttt{svdvals}}. ```



\end{adjustwidth}
\hypertarget{7608839947605749416}{} 
\hyperlink{7608839947605749416}{\texttt{LinearAlgebra.Givens}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LinearAlgebra.Givens(i1,i2,c,s) -> G
\end{minted}

A Givens rotation linear operator. The fields \texttt{c} and \texttt{s} represent the cosine and sine of the rotation angle, respectively. The \texttt{Givens} type supports left multiplication \texttt{G*A} and conjugated transpose right multiplication \texttt{A*G{\textquotesingle}}. The type doesn{\textquotesingle}t have a \texttt{size} and can therefore be multiplied with matrices of arbitrary size as long as \texttt{i2<=size(A,2)} for \texttt{G*A} or \texttt{i2<=size(A,1)} for \texttt{A*G{\textquotesingle}}.

See also: \hyperlink{16453376059429157444}{\texttt{givens}}



\end{adjustwidth}
\hypertarget{16453376059429157444}{} 
\hyperlink{16453376059429157444}{\texttt{LinearAlgebra.givens}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
givens(f::T, g::T, i1::Integer, i2::Integer) where {T} -> (G::Givens, r::T)
\end{minted}

Computes the Givens rotation \texttt{G} and scalar \texttt{r} such that for any vector \texttt{x} where


\begin{lstlisting}
x[i1] = f
x[i2] = g
\end{lstlisting}

the result of the multiplication


\begin{lstlisting}
y = G*x
\end{lstlisting}

has the property that


\begin{lstlisting}
y[i1] = r
y[i2] = 0
\end{lstlisting}

See also: \hyperlink{7608839947605749416}{\texttt{LinearAlgebra.Givens}}




\begin{lstlisting}
givens(A::AbstractArray, i1::Integer, i2::Integer, j::Integer) -> (G::Givens, r)
\end{lstlisting}

Computes the Givens rotation \texttt{G} and scalar \texttt{r} such that the result of the multiplication


\begin{lstlisting}
B = G*A
\end{lstlisting}

has the property that


\begin{lstlisting}
B[i1,j] = r
B[i2,j] = 0
\end{lstlisting}

See also: \hyperlink{7608839947605749416}{\texttt{LinearAlgebra.Givens}}




\begin{lstlisting}
givens(x::AbstractVector, i1::Integer, i2::Integer) -> (G::Givens, r)
\end{lstlisting}

Computes the Givens rotation \texttt{G} and scalar \texttt{r} such that the result of the multiplication


\begin{lstlisting}
B = G*x
\end{lstlisting}

has the property that


\begin{lstlisting}
B[i1] = r
B[i2] = 0
\end{lstlisting}

See also: \hyperlink{7608839947605749416}{\texttt{LinearAlgebra.Givens}}



\end{adjustwidth}
\hypertarget{13861148483706203681}{} 
\hyperlink{13861148483706203681}{\texttt{LinearAlgebra.triu}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
triu(M)
\end{minted}

Upper triangle of a matrix.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = fill(1.0, (4,4))
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia> triu(a)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 0.0  1.0  1.0  1.0
 0.0  0.0  1.0  1.0
 0.0  0.0  0.0  1.0
\end{minted}




\begin{lstlisting}
triu(M, k::Integer)
\end{lstlisting}

Returns the upper triangle of \texttt{M} starting from the \texttt{k}th superdiagonal.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = fill(1.0, (4,4))
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia> triu(a,3)
4×4 Array{Float64,2}:
 0.0  0.0  0.0  1.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0

julia> triu(a,-3)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
\end{minted}



\end{adjustwidth}
\hypertarget{17824694935904725032}{} 
\hyperlink{17824694935904725032}{\texttt{LinearAlgebra.triu!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
triu!(M)
\end{minted}

Upper triangle of a matrix, overwriting \texttt{M} in the process. See also \hyperlink{13861148483706203681}{\texttt{triu}}.




\begin{lstlisting}
triu!(M, k::Integer)
\end{lstlisting}

Return the upper triangle of \texttt{M} starting from the \texttt{k}th superdiagonal, overwriting \texttt{M} in the process.

\textbf{Examples}


\begin{minted}{jlcon}
julia> M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]
5×5 Array{Int64,2}:
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5

julia> triu!(M, 1)
5×5 Array{Int64,2}:
 0  2  3  4  5
 0  0  3  4  5
 0  0  0  4  5
 0  0  0  0  5
 0  0  0  0  0
\end{minted}



\end{adjustwidth}
\hypertarget{6919124555890239966}{} 
\hyperlink{6919124555890239966}{\texttt{LinearAlgebra.tril}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tril(M)
\end{minted}

Lower triangle of a matrix.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = fill(1.0, (4,4))
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia> tril(a)
4×4 Array{Float64,2}:
 1.0  0.0  0.0  0.0
 1.0  1.0  0.0  0.0
 1.0  1.0  1.0  0.0
 1.0  1.0  1.0  1.0
\end{minted}




\begin{lstlisting}
tril(M, k::Integer)
\end{lstlisting}

Returns the lower triangle of \texttt{M} starting from the \texttt{k}th superdiagonal.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = fill(1.0, (4,4))
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia> tril(a,3)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia> tril(a,-3)
4×4 Array{Float64,2}:
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 1.0  0.0  0.0  0.0
\end{minted}



\end{adjustwidth}
\hypertarget{579033117422555588}{} 
\hyperlink{579033117422555588}{\texttt{LinearAlgebra.tril!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tril!(M)
\end{minted}

Lower triangle of a matrix, overwriting \texttt{M} in the process. See also \hyperlink{6919124555890239966}{\texttt{tril}}.




\begin{lstlisting}
tril!(M, k::Integer)
\end{lstlisting}

Return the lower triangle of \texttt{M} starting from the \texttt{k}th superdiagonal, overwriting \texttt{M} in the process.

\textbf{Examples}


\begin{minted}{jlcon}
julia> M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]
5×5 Array{Int64,2}:
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5

julia> tril!(M, 2)
5×5 Array{Int64,2}:
 1  2  3  0  0
 1  2  3  4  0
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
\end{minted}



\end{adjustwidth}
\hypertarget{16168870718733561340}{} 
\hyperlink{16168870718733561340}{\texttt{LinearAlgebra.diagind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
diagind(M, k::Integer=0)
\end{minted}

An \texttt{AbstractRange} giving the indices of the \texttt{k}th diagonal of the matrix \texttt{M}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia> diagind(A,-1)
2:4:6
\end{minted}



\end{adjustwidth}
\hypertarget{17079356950356685026}{} 
\hyperlink{17079356950356685026}{\texttt{LinearAlgebra.diag}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
diag(M, k::Integer=0)
\end{minted}

The \texttt{k}th diagonal of a matrix, as a vector.

See also: \hyperlink{18133091318829836689}{\texttt{diagm}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia> diag(A,1)
2-element Array{Int64,1}:
 2
 6
\end{minted}



\end{adjustwidth}
\hypertarget{18133091318829836689}{} 
\hyperlink{18133091318829836689}{\texttt{LinearAlgebra.diagm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
diagm(kv::Pair{<:Integer,<:AbstractVector}...)
diagm(m::Integer, n::Integer, kv::Pair{<:Integer,<:AbstractVector}...)
\end{minted}

Construct a matrix from \texttt{Pair}s of diagonals and vectors. Vector \texttt{kv.second} will be placed on the \texttt{kv.first} diagonal. By default the matrix is square and its size is inferred from \texttt{kv}, but a non-square size \texttt{m}×\texttt{n} (padded with zeros as needed) can be specified by passing \texttt{m,n} as the first arguments.

\texttt{diagm} constructs a full matrix; if you want storage-efficient versions with fast arithmetic, see \hyperlink{3300114559258360989}{\texttt{Diagonal}}, \hyperlink{6156150905679680892}{\texttt{Bidiagonal}} \hyperlink{17820886359515748171}{\texttt{Tridiagonal}} and \hyperlink{6062797780727203318}{\texttt{SymTridiagonal}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> diagm(1 => [1,2,3])
4×4 Array{Int64,2}:
 0  1  0  0
 0  0  2  0
 0  0  0  3
 0  0  0  0

julia> diagm(1 => [1,2,3], -1 => [4,5])
4×4 Array{Int64,2}:
 0  1  0  0
 4  0  2  0
 0  5  0  3
 0  0  0  0
\end{minted}




\begin{lstlisting}
diagm(v::AbstractVector)
diagm(m::Integer, n::Integer, v::AbstractVector)
\end{lstlisting}

Construct a matrix with elements of the vector as diagonal elements. By default (if \texttt{size=nothing}), the matrix is square and its size is given by \texttt{length(v)}, but a non-square size \texttt{m}×\texttt{n} can be specified by passing \texttt{m,n} as the first arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> diagm([1,2,3])
3×3 Array{Int64,2}:
 1  0  0
 0  2  0
 0  0  3
\end{minted}



\end{adjustwidth}
\hypertarget{439390458422397873}{} 
\hyperlink{439390458422397873}{\texttt{LinearAlgebra.rank}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rank(A::AbstractMatrix; atol::Real=0, rtol::Real=atol>0 ? 0 : n*ϵ)
rank(A::AbstractMatrix, rtol::Real)
\end{minted}

Compute the rank of a matrix by counting how many singular values of \texttt{A} have magnitude greater than \texttt{max(atol, rtol*σ₁)} where \texttt{σ₁} is \texttt{A}{\textquotesingle}s largest singular value. \texttt{atol} and \texttt{rtol} are the absolute and relative tolerances, respectively. The default relative tolerance is \texttt{n*ϵ}, where \texttt{n} is the size of the smallest dimension of \texttt{A}, and \texttt{ϵ} is the \hyperlink{4594213520310841636}{\texttt{eps}} of the element type of \texttt{A}.

\begin{quote}
\textbf{Julia 1.1}

The \texttt{atol} and \texttt{rtol} keyword arguments requires at least Julia 1.1. In Julia 1.0 \texttt{rtol} is available as a positional argument, but this will be deprecated in Julia 2.0.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> rank(Matrix(I, 3, 3))
3

julia> rank(diagm(0 => [1, 0, 2]))
2

julia> rank(diagm(0 => [1, 0.001, 2]), rtol=0.1)
2

julia> rank(diagm(0 => [1, 0.001, 2]), rtol=0.00001)
3

julia> rank(diagm(0 => [1, 0.001, 2]), atol=1.5)
1
\end{minted}



\end{adjustwidth}
\hypertarget{898926013064269707}{} 
\hyperlink{898926013064269707}{\texttt{LinearAlgebra.norm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
norm(A, p::Real=2)
\end{minted}

For any iterable container \texttt{A} (including arrays of any dimension) of numbers (or any element type for which \texttt{norm} is defined), compute the \texttt{p}-norm (defaulting to \texttt{p=2}) as if \texttt{A} were a vector of the corresponding length.

The \texttt{p}-norm is defined as

\begin{equation*}
\begin{split}\|A\|_p = \left( \sum_{i=1}^n | a_i | ^p \right)^{1/p}\end{split}\end{equation*}
with  \(a_i\)  the entries of  \(A\) ,  \(| a_i |\)  the \hyperlink{898926013064269707}{\texttt{norm}} of  \(a_i\) , and  \(n\)  the length of  \(A\) . Since the \texttt{p}-norm is computed using the \hyperlink{898926013064269707}{\texttt{norm}}s of the entries of \texttt{A}, the \texttt{p}-norm of a vector of vectors is not compatible with the interpretation of it as a block vector in general if \texttt{p != 2}.

\texttt{p} can assume any numeric value (even though not all values produce a mathematically valid vector norm). In particular, \texttt{norm(A, Inf)} returns the largest value in \texttt{abs.(A)}, whereas \texttt{norm(A, -Inf)} returns the smallest. If \texttt{A} is a matrix and \texttt{p=2}, then this is equivalent to the Frobenius norm.

The second argument \texttt{p} is not necessarily a part of the interface for \texttt{norm}, i.e. a custom type may only implement \texttt{norm(A)} without second argument.

Use \hyperlink{4740175223212326101}{\texttt{opnorm}} to compute the operator norm of a matrix.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [3, -2, 6]
3-element Array{Int64,1}:
  3
 -2
  6

julia> norm(v)
7.0

julia> norm(v, 1)
11.0

julia> norm(v, Inf)
6.0

julia> norm([1 2 3; 4 5 6; 7 8 9])
16.881943016134134

julia> norm([1 2 3 4 5 6 7 8 9])
16.881943016134134

julia> norm(1:9)
16.881943016134134

julia> norm(hcat(v,v), 1) == norm(vcat(v,v), 1) != norm([v,v], 1)
true

julia> norm(hcat(v,v), 2) == norm(vcat(v,v), 2) == norm([v,v], 2)
true

julia> norm(hcat(v,v), Inf) == norm(vcat(v,v), Inf) != norm([v,v], Inf)
true
\end{minted}




\begin{lstlisting}
norm(x::Number, p::Real=2)
\end{lstlisting}

For numbers, return  \(\left( |x|^p \right)^{1/p}\) .

\textbf{Examples}


\begin{minted}{jlcon}
julia> norm(2, 1)
2.0

julia> norm(-2, 1)
2.0

julia> norm(2, 2)
2.0

julia> norm(-2, 2)
2.0

julia> norm(2, Inf)
2.0

julia> norm(-2, Inf)
2.0
\end{minted}



\end{adjustwidth}
\hypertarget{4740175223212326101}{} 
\hyperlink{4740175223212326101}{\texttt{LinearAlgebra.opnorm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
opnorm(A::AbstractMatrix, p::Real=2)
\end{minted}

Compute the operator norm (or matrix norm) induced by the vector \texttt{p}-norm, where valid values of \texttt{p} are \texttt{1}, \texttt{2}, or \texttt{Inf}. (Note that for sparse matrices, \texttt{p=2} is currently not implemented.) Use \hyperlink{898926013064269707}{\texttt{norm}} to compute the Frobenius norm.

When \texttt{p=1}, the operator norm is the maximum absolute column sum of \texttt{A}:

\begin{equation*}
\begin{split}\|A\|_1 = \max_{1 ≤ j ≤ n} \sum_{i=1}^m | a_{ij} |\end{split}\end{equation*}
with  \(a_{ij}\)  the entries of  \(A\) , and  \(m\)  and  \(n\)  its dimensions.

When \texttt{p=2}, the operator norm is the spectral norm, equal to the largest singular value of \texttt{A}.

When \texttt{p=Inf}, the operator norm is the maximum absolute row sum of \texttt{A}:

\begin{equation*}
\begin{split}\|A\|_\infty = \max_{1 ≤ i ≤ m} \sum _{j=1}^n | a_{ij} |\end{split}\end{equation*}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 -2 -3; 2 3 -1]
2×3 Array{Int64,2}:
 1  -2  -3
 2   3  -1

julia> opnorm(A, Inf)
6.0

julia> opnorm(A, 1)
5.0
\end{minted}




\begin{lstlisting}
opnorm(x::Number, p::Real=2)
\end{lstlisting}

For numbers, return  \(\left( |x|^p \right)^{1/p}\) . This is equivalent to \hyperlink{898926013064269707}{\texttt{norm}}.




\begin{lstlisting}
opnorm(A::Adjoint{<:Any,<:AbstracVector}, q::Real=2)
opnorm(A::Transpose{<:Any,<:AbstracVector}, q::Real=2)
\end{lstlisting}

For Adjoint/Transpose-wrapped vectors, return the operator  \(q\) -norm of \texttt{A}, which is equivalent to the \texttt{p}-norm with value \texttt{p = q/(q-1)}. They coincide at \texttt{p = q = 2}. Use \hyperlink{898926013064269707}{\texttt{norm}} to compute the \texttt{p} norm of \texttt{A} as a vector.

The difference in norm between a vector space and its dual arises to preserve the relationship between duality and the dot product, and the result is consistent with the operator \texttt{p}-norm of a \texttt{1 × n} matrix.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [1; im];

julia> vc = v';

julia> opnorm(vc, 1)
1.0

julia> norm(vc, 1)
2.0

julia> norm(v, 1)
2.0

julia> opnorm(vc, 2)
1.4142135623730951

julia> norm(vc, 2)
1.4142135623730951

julia> norm(v, 2)
1.4142135623730951

julia> opnorm(vc, Inf)
2.0

julia> norm(vc, Inf)
1.0

julia> norm(v, Inf)
1.0
\end{minted}



\end{adjustwidth}
\hypertarget{7806117778219468080}{} 
\hyperlink{7806117778219468080}{\texttt{LinearAlgebra.normalize!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
normalize!(v::AbstractVector, p::Real=2)
\end{minted}

Normalize the vector \texttt{v} in-place so that its \texttt{p}-norm equals unity, i.e. \texttt{norm(v, p) == 1}. See also \hyperlink{10731692832589480792}{\texttt{normalize}} and \hyperlink{898926013064269707}{\texttt{norm}}.



\end{adjustwidth}
\hypertarget{10731692832589480792}{} 
\hyperlink{10731692832589480792}{\texttt{LinearAlgebra.normalize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
normalize(v::AbstractVector, p::Real=2)
\end{minted}

Normalize the vector \texttt{v} so that its \texttt{p}-norm equals unity, i.e. \texttt{norm(v, p) == 1}. See also \hyperlink{7806117778219468080}{\texttt{normalize!}} and \hyperlink{898926013064269707}{\texttt{norm}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1,2,4];

julia> b = normalize(a)
3-element Array{Float64,1}:
 0.2182178902359924
 0.4364357804719848
 0.8728715609439696

julia> norm(b)
1.0

julia> c = normalize(a, 1)
3-element Array{Float64,1}:
 0.14285714285714285
 0.2857142857142857
 0.5714285714285714

julia> norm(c, 1)
1.0
\end{minted}



\end{adjustwidth}
\hypertarget{875685967830602736}{} 
\hyperlink{875685967830602736}{\texttt{LinearAlgebra.cond}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cond(M, p::Real=2)
\end{minted}

Condition number of the matrix \texttt{M}, computed using the operator \texttt{p}-norm. Valid values for \texttt{p} are \texttt{1}, \texttt{2} (default), or \texttt{Inf}.



\end{adjustwidth}
\hypertarget{11563712892597655531}{} 
\hyperlink{11563712892597655531}{\texttt{LinearAlgebra.condskeel}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
condskeel(M, [x, p::Real=Inf])
\end{minted}

\begin{equation*}
\begin{split}\kappa_S(M, p) = \left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert \right\Vert_p \\
\kappa_S(M, x, p) = \left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert \left\vert x \right\vert \right\Vert_p\end{split}\end{equation*}
Skeel condition number  \(\kappa_S\)  of the matrix \texttt{M}, optionally with respect to the vector \texttt{x}, as computed using the operator \texttt{p}-norm.  \(\left\vert M \right\vert\)  denotes the matrix of (entry wise) absolute values of  \(M\) ;  \(\left\vert M \right\vert_{ij} = \left\vert M_{ij} \right\vert\) . Valid values for \texttt{p} are \texttt{1}, \texttt{2} and \texttt{Inf} (default).

This quantity is also known in the literature as the Bauer condition number, relative condition number, or componentwise relative condition number.



\end{adjustwidth}
\hypertarget{3355659645971312171}{} 
\hyperlink{3355659645971312171}{\texttt{LinearAlgebra.tr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tr(M)
\end{minted}

Matrix trace. Sums the diagonal elements of \texttt{M}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> tr(A)
5
\end{minted}



\end{adjustwidth}
\hypertarget{16543378577000914469}{} 
\hyperlink{16543378577000914469}{\texttt{LinearAlgebra.det}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
det(M)
\end{minted}

Matrix determinant.

\textbf{Examples}


\begin{minted}{jlcon}
julia> M = [1 0; 2 2]
2×2 Array{Int64,2}:
 1  0
 2  2

julia> det(M)
2.0
\end{minted}



\end{adjustwidth}
\hypertarget{12765142073947245963}{} 
\hyperlink{12765142073947245963}{\texttt{LinearAlgebra.logdet}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
logdet(M)
\end{minted}

Log of matrix determinant. Equivalent to \texttt{log(det(M))}, but may provide increased accuracy and/or speed.

\textbf{Examples}


\begin{minted}{jlcon}
julia> M = [1 0; 2 2]
2×2 Array{Int64,2}:
 1  0
 2  2

julia> logdet(M)
0.6931471805599453

julia> logdet(Matrix(I, 3, 3))
0.0
\end{minted}



\end{adjustwidth}
\hypertarget{11067048979448481853}{} 
\hyperlink{11067048979448481853}{\texttt{LinearAlgebra.logabsdet}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
logabsdet(M)
\end{minted}

Log of absolute value of matrix determinant. Equivalent to \texttt{(log(abs(det(M))), sign(det(M)))}, but may provide increased accuracy and/or speed.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [-1. 0.; 0. 1.]
2×2 Array{Float64,2}:
 -1.0  0.0
  0.0  1.0

julia> det(A)
-1.0

julia> logabsdet(A)
(0.0, -1.0)

julia> B = [2. 0.; 0. 1.]
2×2 Array{Float64,2}:
 2.0  0.0
 0.0  1.0

julia> det(B)
2.0

julia> logabsdet(B)
(0.6931471805599453, 1.0)
\end{minted}



\end{adjustwidth}
\hypertarget{3073938155232622368}{} 
\hyperlink{3073938155232622368}{\texttt{Base.inv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
inv(M)
\end{minted}

Matrix inverse. Computes matrix \texttt{N} such that \texttt{M * N = I}, where \texttt{I} is the identity matrix. Computed by solving the left-division \texttt{N = M {\textbackslash} I}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> M = [2 5; 1 3]
2×2 Array{Int64,2}:
 2  5
 1  3

julia> N = inv(M)
2×2 Array{Float64,2}:
  3.0  -5.0
 -1.0   2.0

julia> M*N == N*M == Matrix(I, 2, 2)
true
\end{minted}



\end{adjustwidth}
\hypertarget{15549768004641518126}{} 
\hyperlink{15549768004641518126}{\texttt{LinearAlgebra.pinv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pinv(M; atol::Real=0, rtol::Real=atol>0 ? 0 : n*ϵ)
pinv(M, rtol::Real) = pinv(M; rtol=rtol) # to be deprecated in Julia 2.0
\end{minted}

Computes the Moore-Penrose pseudoinverse.

For matrices \texttt{M} with floating point elements, it is convenient to compute the pseudoinverse by inverting only singular values greater than \texttt{max(atol, rtol*σ₁)} where \texttt{σ₁} is the largest singular value of \texttt{M}.

The optimal choice of absolute (\texttt{atol}) and relative tolerance (\texttt{rtol}) varies both with the value of \texttt{M} and the intended application of the pseudoinverse. The default relative tolerance is \texttt{n*ϵ}, where \texttt{n} is the size of the smallest dimension of \texttt{M}, and \texttt{ϵ} is the \hyperlink{4594213520310841636}{\texttt{eps}} of the element type of \texttt{M}.

For inverting dense ill-conditioned matrices in a least-squares sense, \texttt{rtol = sqrt(eps(real(float(one(eltype(M))))))} is recommended.

For more information, see \footnotemark[4], \footnotemark[5], \footnotemark[6], \footnotemark[7].

\textbf{Examples}


\begin{minted}{jlcon}
julia> M = [1.5 1.3; 1.2 1.9]
2×2 Array{Float64,2}:
 1.5  1.3
 1.2  1.9

julia> N = pinv(M)
2×2 Array{Float64,2}:
  1.47287   -1.00775
 -0.930233   1.16279

julia> M * N
2×2 Array{Float64,2}:
 1.0          -2.22045e-16
 4.44089e-16   1.0
\end{minted}

\footnotetext[4]{Issue 8859, {\textquotedbl}Fix least squares{\textquotedbl}, \href{https://github.com/JuliaLang/julia/pull/8859}{https://github.com/JuliaLang/julia/pull/8859}

}
\footnotetext[5]{Åke Björck, {\textquotedbl}Numerical Methods for Least Squares Problems{\textquotedbl},  SIAM Press, Philadelphia, 1996, {\textquotedbl}Other Titles in Applied Mathematics{\textquotedbl}, Vol. 51. \href{http://epubs.siam.org/doi/book/10.1137/1.9781611971484}{doi:10.1137/1.9781611971484}

}
\footnotetext[6]{G. W. Stewart, {\textquotedbl}Rank Degeneracy{\textquotedbl}, SIAM Journal on Scientific and Statistical Computing, 5(2), 1984, 403-413. \href{http://epubs.siam.org/doi/abs/10.1137/0905030}{doi:10.1137/0905030}

}
\footnotetext[7]{Konstantinos Konstantinides and Kung Yao, {\textquotedbl}Statistical analysis of effective singular values in matrix rank determination{\textquotedbl}, IEEE Transactions on Acoustics, Speech and Signal Processing, 36(5), 1988, 757-763. \href{https://doi.org/10.1109/29.1585}{doi:10.1109/29.1585}

}


\end{adjustwidth}
\hypertarget{13997374044866220350}{} 
\hyperlink{13997374044866220350}{\texttt{LinearAlgebra.nullspace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nullspace(M; atol::Real=0, rtol::Real=atol>0 ? 0 : n*ϵ)
nullspace(M, rtol::Real) = nullspace(M; rtol=rtol) # to be deprecated in Julia 2.0
\end{minted}

Computes a basis for the nullspace of \texttt{M} by including the singular vectors of \texttt{M} whose singular values have magnitudes greater than \texttt{max(atol, rtol*σ₁)}, where \texttt{σ₁} is \texttt{M}{\textquotesingle}s largest singular value.

By default, the relative tolerance \texttt{rtol} is \texttt{n*ϵ}, where \texttt{n} is the size of the smallest dimension of \texttt{M}, and \texttt{ϵ} is the \hyperlink{4594213520310841636}{\texttt{eps}} of the element type of \texttt{M}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> M = [1 0 0; 0 1 0; 0 0 0]
3×3 Array{Int64,2}:
 1  0  0
 0  1  0
 0  0  0

julia> nullspace(M)
3×1 Array{Float64,2}:
 0.0
 0.0
 1.0

julia> nullspace(M, rtol=3)
3×3 Array{Float64,2}:
 0.0  1.0  0.0
 1.0  0.0  0.0
 0.0  0.0  1.0

julia> nullspace(M, atol=0.95)
3×1 Array{Float64,2}:
 0.0
 0.0
 1.0
\end{minted}



\end{adjustwidth}
\hypertarget{14153417388267953812}{} 
\hyperlink{14153417388267953812}{\texttt{Base.kron}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
kron(A, B)
\end{minted}

Kronecker tensor product of two vectors or two matrices.

For vectors v and w, the Kronecker product is related to the outer product by \texttt{kron(v,w) == vec(w*transpose(v))} or \texttt{w*transpose(v) == reshape(kron(v,w), (length(w), length(v)))}. Note how the ordering of \texttt{v} and \texttt{w} differs on the left and right of these expressions (due to column-major storage).

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> B = [im 1; 1 -im]
2×2 Array{Complex{Int64},2}:
 0+1im  1+0im
 1+0im  0-1im

julia> kron(A, B)
4×4 Array{Complex{Int64},2}:
 0+1im  1+0im  0+2im  2+0im
 1+0im  0-1im  2+0im  0-2im
 0+3im  3+0im  0+4im  4+0im
 3+0im  0-3im  4+0im  0-4im

julia> v = [1, 2]; w = [3, 4, 5];

julia> w*transpose(v)
3×2 Array{Int64,2}:
 3   6
 4   8
 5  10

julia> reshape(kron(v,w), (length(w), length(v)))
3×2 Array{Int64,2}:
 3   6
 4   8
 5  10
\end{minted}



\end{adjustwidth}
\hypertarget{18285859961980795328}{} 
\hyperlink{18285859961980795328}{\texttt{Base.exp}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
exp(A::AbstractMatrix)
\end{minted}

Compute the matrix exponential of \texttt{A}, defined by

\begin{equation*}
\begin{split}e^A = \sum_{n=0}^{\infty} \frac{A^n}{n!}.\end{split}\end{equation*}
For symmetric or Hermitian \texttt{A}, an eigendecomposition (\hyperlink{11056016707394839114}{\texttt{eigen}}) is used, otherwise the scaling and squaring algorithm (see \footnotemark[8]) is chosen.

\footnotetext[8]{Nicholas J. Higham, {\textquotedbl}The squaring and scaling method for the matrix exponential revisited{\textquotedbl}, SIAM Journal on Matrix Analysis and Applications, 26(4), 2005, 1179-1193. \href{https://doi.org/10.1137/090768539}{doi:10.1137/090768539}

}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = Matrix(1.0I, 2, 2)
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0

julia> exp(A)
2×2 Array{Float64,2}:
 2.71828  0.0
 0.0      2.71828
\end{minted}



\end{adjustwidth}
\hypertarget{13815303599818670515}{} 
\hyperlink{13815303599818670515}{\texttt{Base.:{\textasciicircum}}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
^(A::AbstractMatrix, p::Number)
\end{minted}

Matrix power, equivalent to  \(\exp(p\log(A))\) 

\textbf{Examples}


\begin{minted}{jlcon}
julia> [1 2; 0 3]^3
2×2 Array{Int64,2}:
 1  26
 0  27
\end{minted}



\end{adjustwidth}
\hypertarget{7435396726429142215}{} 
\hyperlink{7435396726429142215}{\texttt{Base.:{\textasciicircum}}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
^(b::Number, A::AbstractMatrix)
\end{minted}

Matrix exponential, equivalent to  \(\exp(\log(b)A)\) .

\begin{quote}
\textbf{Julia 1.1}

Support for raising \texttt{Irrational} numbers (like \texttt{ℯ}) to a matrix was added in Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> 2^[1 2; 0 3]
2×2 Array{Float64,2}:
 2.0  6.0
 0.0  8.0

julia> ℯ^[1 2; 0 3]
2×2 Array{Float64,2}:
 2.71828  17.3673
 0.0      20.0855
\end{minted}



\end{adjustwidth}
\hypertarget{3808986897558314383}{} 
\hyperlink{3808986897558314383}{\texttt{Base.log}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
log(A{T}::StridedMatrix{T})
\end{minted}

If \texttt{A} has no negative real eigenvalue, compute the principal matrix logarithm of \texttt{A}, i.e. the unique matrix  \(X\)  such that  \(e^X = A\)  and  \(-\pi < Im(\lambda) < \pi\)  for all the eigenvalues  \(\lambda\)  of  \(X\) . If \texttt{A} has nonpositive eigenvalues, a nonprincipal matrix function is returned whenever possible.

If \texttt{A} is symmetric or Hermitian, its eigendecomposition (\hyperlink{11056016707394839114}{\texttt{eigen}}) is used, if \texttt{A} is triangular an improved version of the inverse scaling and squaring method is employed (see \footnotemark[9] and \footnotemark[10]). For general matrices, the complex Schur form (\hyperlink{17132870828407138368}{\texttt{schur}}) is computed and the triangular algorithm is used on the triangular factor.

\footnotetext[9]{Awad H. Al-Mohy and Nicholas J. Higham, {\textquotedbl}Improved inverse  scaling and squaring algorithms for the matrix logarithm{\textquotedbl}, SIAM Journal on Scientific Computing, 34(4), 2012, C153-C169. \href{https://doi.org/10.1137/110852553}{doi:10.1137/110852553}

}
\footnotetext[10]{Awad H. Al-Mohy, Nicholas J. Higham and Samuel D. Relton, {\textquotedbl}Computing the Fréchet derivative of the matrix logarithm and estimating the condition number{\textquotedbl}, SIAM Journal on Scientific Computing, 35(4), 2013, C394-C410. \href{https://doi.org/10.1137/120885991}{doi:10.1137/120885991}

}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = Matrix(2.7182818*I, 2, 2)
2×2 Array{Float64,2}:
 2.71828  0.0
 0.0      2.71828

julia> log(A)
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0
\end{minted}



\end{adjustwidth}
\hypertarget{2764611134083270926}{} 
\hyperlink{2764611134083270926}{\texttt{Base.sqrt}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sqrt(A::AbstractMatrix)
\end{minted}

If \texttt{A} has no negative real eigenvalues, compute the principal matrix square root of \texttt{A}, that is the unique matrix  \(X\)  with eigenvalues having positive real part such that  \(X^2 = A\) . Otherwise, a nonprincipal square root is returned.

If \texttt{A} is symmetric or Hermitian, its eigendecomposition (\hyperlink{11056016707394839114}{\texttt{eigen}}) is used to compute the square root. Otherwise, the square root is determined by means of the Björck-Hammarling method \footnotemark[11], which computes the complex Schur form (\hyperlink{17132870828407138368}{\texttt{schur}}) and then the complex square root of the triangular factor.

\footnotetext[11]{Åke Björck and Sven Hammarling, {\textquotedbl}A Schur method for the square root of a matrix{\textquotedbl}, Linear Algebra and its Applications, 52-53, 1983, 127-140. \href{https://doi.org/10.1016/0024-3795(83)80010-X}{doi:10.1016/0024-3795(83)80010-X}

}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4 0; 0 4]
2×2 Array{Int64,2}:
 4  0
 0  4

julia> sqrt(A)
2×2 Array{Float64,2}:
 2.0  0.0
 0.0  2.0
\end{minted}



\end{adjustwidth}
\hypertarget{11601410820050169124}{} 
\hyperlink{11601410820050169124}{\texttt{Base.cos}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cos(A::AbstractMatrix)
\end{minted}

Compute the matrix cosine of a square matrix \texttt{A}.

If \texttt{A} is symmetric or Hermitian, its eigendecomposition (\hyperlink{11056016707394839114}{\texttt{eigen}}) is used to compute the cosine. Otherwise, the cosine is determined by calling \hyperlink{5801729597955756107}{\texttt{exp}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> cos(fill(1.0, (2,2)))
2×2 Array{Float64,2}:
  0.291927  -0.708073
 -0.708073   0.291927
\end{minted}



\end{adjustwidth}
\hypertarget{14039855138661767630}{} 
\hyperlink{14039855138661767630}{\texttt{Base.sin}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sin(A::AbstractMatrix)
\end{minted}

Compute the matrix sine of a square matrix \texttt{A}.

If \texttt{A} is symmetric or Hermitian, its eigendecomposition (\hyperlink{11056016707394839114}{\texttt{eigen}}) is used to compute the sine. Otherwise, the sine is determined by calling \hyperlink{5801729597955756107}{\texttt{exp}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sin(fill(1.0, (2,2)))
2×2 Array{Float64,2}:
 0.454649  0.454649
 0.454649  0.454649
\end{minted}



\end{adjustwidth}
\hypertarget{10476266945170887002}{} 
\hyperlink{10476266945170887002}{\texttt{Base.Math.sincos}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sincos(A::AbstractMatrix)
\end{minted}

Compute the matrix sine and cosine of a square matrix \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> S, C = sincos(fill(1.0, (2,2)));

julia> S
2×2 Array{Float64,2}:
 0.454649  0.454649
 0.454649  0.454649

julia> C
2×2 Array{Float64,2}:
  0.291927  -0.708073
 -0.708073   0.291927
\end{minted}



\end{adjustwidth}
\hypertarget{16475848931771819970}{} 
\hyperlink{16475848931771819970}{\texttt{Base.tan}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tan(A::AbstractMatrix)
\end{minted}

Compute the matrix tangent of a square matrix \texttt{A}.

If \texttt{A} is symmetric or Hermitian, its eigendecomposition (\hyperlink{11056016707394839114}{\texttt{eigen}}) is used to compute the tangent. Otherwise, the tangent is determined by calling \hyperlink{5801729597955756107}{\texttt{exp}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> tan(fill(1.0, (2,2)))
2×2 Array{Float64,2}:
 -1.09252  -1.09252
 -1.09252  -1.09252
\end{minted}



\end{adjustwidth}
\hypertarget{2627941190173499283}{} 
\hyperlink{2627941190173499283}{\texttt{Base.Math.sec}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sec(A::AbstractMatrix)
\end{minted}

Compute the matrix secant of a square matrix \texttt{A}.



\end{adjustwidth}
\hypertarget{14836994396551644362}{} 
\hyperlink{14836994396551644362}{\texttt{Base.Math.csc}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
csc(A::AbstractMatrix)
\end{minted}

Compute the matrix cosecant of a square matrix \texttt{A}.



\end{adjustwidth}
\hypertarget{3756551817451989074}{} 
\hyperlink{3756551817451989074}{\texttt{Base.Math.cot}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cot(A::AbstractMatrix)
\end{minted}

Compute the matrix cotangent of a square matrix \texttt{A}.



\end{adjustwidth}
\hypertarget{3831542837693533832}{} 
\hyperlink{3831542837693533832}{\texttt{Base.cosh}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cosh(A::AbstractMatrix)
\end{minted}

Compute the matrix hyperbolic cosine of a square matrix \texttt{A}.



\end{adjustwidth}
\hypertarget{10621922578961083459}{} 
\hyperlink{10621922578961083459}{\texttt{Base.sinh}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sinh(A::AbstractMatrix)
\end{minted}

Compute the matrix hyperbolic sine of a square matrix \texttt{A}.



\end{adjustwidth}
\hypertarget{1859383072068909395}{} 
\hyperlink{1859383072068909395}{\texttt{Base.tanh}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tanh(A::AbstractMatrix)
\end{minted}

Compute the matrix hyperbolic tangent of a square matrix \texttt{A}.



\end{adjustwidth}
\hypertarget{12898765534995911506}{} 
\hyperlink{12898765534995911506}{\texttt{Base.Math.sech}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sech(A::AbstractMatrix)
\end{minted}

Compute the matrix hyperbolic secant of square matrix \texttt{A}.



\end{adjustwidth}
\hypertarget{14098493345003221932}{} 
\hyperlink{14098493345003221932}{\texttt{Base.Math.csch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
csch(A::AbstractMatrix)
\end{minted}

Compute the matrix hyperbolic cosecant of square matrix \texttt{A}.



\end{adjustwidth}
\hypertarget{2675030789857212222}{} 
\hyperlink{2675030789857212222}{\texttt{Base.Math.coth}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
coth(A::AbstractMatrix)
\end{minted}

Compute the matrix hyperbolic cotangent of square matrix \texttt{A}.



\end{adjustwidth}
\hypertarget{13124751178617899053}{} 
\hyperlink{13124751178617899053}{\texttt{Base.acos}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acos(A::AbstractMatrix)
\end{minted}

Compute the inverse matrix cosine of a square matrix \texttt{A}.

If \texttt{A} is symmetric or Hermitian, its eigendecomposition (\hyperlink{11056016707394839114}{\texttt{eigen}}) is used to compute the inverse cosine. Otherwise, the inverse cosine is determined by using \hyperlink{17317607370922767936}{\texttt{log}} and \hyperlink{4551113327515323898}{\texttt{sqrt}}.  For the theory and logarithmic formulas used to compute this function, see \footnotemark[12].

\footnotetext[12]{Mary Aprahamian and Nicholas J. Higham, {\textquotedbl}Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms{\textquotedbl}, MIMS EPrint: 2016.4. \href{https://doi.org/10.1137/16M1057577}{https://doi.org/10.1137/16M1057577}

}
\textbf{Examples}


\begin{minted}{jlcon}
julia> acos(cos([0.5 0.1; -0.2 0.3]))
2×2 Array{Complex{Float64},2}:
  0.5-8.32667e-17im  0.1+0.0im
 -0.2+2.63678e-16im  0.3-3.46945e-16im
\end{minted}



\end{adjustwidth}
\hypertarget{13323825159284566975}{} 
\hyperlink{13323825159284566975}{\texttt{Base.asin}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asin(A::AbstractMatrix)
\end{minted}

Compute the inverse matrix sine of a square matrix \texttt{A}.

If \texttt{A} is symmetric or Hermitian, its eigendecomposition (\hyperlink{11056016707394839114}{\texttt{eigen}}) is used to compute the inverse sine. Otherwise, the inverse sine is determined by using \hyperlink{17317607370922767936}{\texttt{log}} and \hyperlink{4551113327515323898}{\texttt{sqrt}}.  For the theory and logarithmic formulas used to compute this function, see \footnotemark[13].

\footnotetext[13]{Mary Aprahamian and Nicholas J. Higham, {\textquotedbl}Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms{\textquotedbl}, MIMS EPrint: 2016.4. \href{https://doi.org/10.1137/16M1057577}{https://doi.org/10.1137/16M1057577}

}
\textbf{Examples}


\begin{minted}{jlcon}
julia> asin(sin([0.5 0.1; -0.2 0.3]))
2×2 Array{Complex{Float64},2}:
  0.5-4.16334e-17im  0.1-5.55112e-17im
 -0.2+9.71445e-17im  0.3-1.249e-16im
\end{minted}



\end{adjustwidth}
\hypertarget{16602871865924174581}{} 
\hyperlink{16602871865924174581}{\texttt{Base.atan}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
atan(A::AbstractMatrix)
\end{minted}

Compute the inverse matrix tangent of a square matrix \texttt{A}.

If \texttt{A} is symmetric or Hermitian, its eigendecomposition (\hyperlink{11056016707394839114}{\texttt{eigen}}) is used to compute the inverse tangent. Otherwise, the inverse tangent is determined by using \hyperlink{17317607370922767936}{\texttt{log}}.  For the theory and logarithmic formulas used to compute this function, see \footnotemark[14].

\footnotetext[14]{Mary Aprahamian and Nicholas J. Higham, {\textquotedbl}Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms{\textquotedbl}, MIMS EPrint: 2016.4. \href{https://doi.org/10.1137/16M1057577}{https://doi.org/10.1137/16M1057577}

}
\textbf{Examples}


\begin{minted}{jlcon}
julia> atan(tan([0.5 0.1; -0.2 0.3]))
2×2 Array{Complex{Float64},2}:
  0.5+1.38778e-17im  0.1-2.77556e-17im
 -0.2+6.93889e-17im  0.3-4.16334e-17im
\end{minted}



\end{adjustwidth}
\hypertarget{18059102985382682628}{} 
\hyperlink{18059102985382682628}{\texttt{Base.Math.asec}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asec(A::AbstractMatrix)
\end{minted}

Compute the inverse matrix secant of \texttt{A}. 



\end{adjustwidth}
\hypertarget{1996732052493549393}{} 
\hyperlink{1996732052493549393}{\texttt{Base.Math.acsc}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acsc(A::AbstractMatrix)
\end{minted}

Compute the inverse matrix cosecant of \texttt{A}. 



\end{adjustwidth}
\hypertarget{10418731786659005321}{} 
\hyperlink{10418731786659005321}{\texttt{Base.Math.acot}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acot(A::AbstractMatrix)
\end{minted}

Compute the inverse matrix cotangent of \texttt{A}. 



\end{adjustwidth}
\hypertarget{8148684206205068128}{} 
\hyperlink{8148684206205068128}{\texttt{Base.acosh}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acosh(A::AbstractMatrix)
\end{minted}

Compute the inverse hyperbolic matrix cosine of a square matrix \texttt{A}.  For the theory and logarithmic formulas used to compute this function, see \footnotemark[15].

\footnotetext[15]{Mary Aprahamian and Nicholas J. Higham, {\textquotedbl}Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms{\textquotedbl}, MIMS EPrint: 2016.4. \href{https://doi.org/10.1137/16M1057577}{https://doi.org/10.1137/16M1057577}

}


\end{adjustwidth}
\hypertarget{7556135416358066324}{} 
\hyperlink{7556135416358066324}{\texttt{Base.asinh}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asinh(A::AbstractMatrix)
\end{minted}

Compute the inverse hyperbolic matrix sine of a square matrix \texttt{A}.  For the theory and logarithmic formulas used to compute this function, see \footnotemark[16].

\footnotetext[16]{Mary Aprahamian and Nicholas J. Higham, {\textquotedbl}Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms{\textquotedbl}, MIMS EPrint: 2016.4. \href{https://doi.org/10.1137/16M1057577}{https://doi.org/10.1137/16M1057577}

}


\end{adjustwidth}
\hypertarget{631136805929918109}{} 
\hyperlink{631136805929918109}{\texttt{Base.atanh}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
atanh(A::AbstractMatrix)
\end{minted}

Compute the inverse hyperbolic matrix tangent of a square matrix \texttt{A}.  For the theory and logarithmic formulas used to compute this function, see \footnotemark[17].

\footnotetext[17]{Mary Aprahamian and Nicholas J. Higham, {\textquotedbl}Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms{\textquotedbl}, MIMS EPrint: 2016.4. \href{https://doi.org/10.1137/16M1057577}{https://doi.org/10.1137/16M1057577}

}


\end{adjustwidth}
\hypertarget{2354446395483966696}{} 
\hyperlink{2354446395483966696}{\texttt{Base.Math.asech}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asech(A::AbstractMatrix)
\end{minted}

Compute the inverse matrix hyperbolic secant of \texttt{A}. 



\end{adjustwidth}
\hypertarget{1360680038198884316}{} 
\hyperlink{1360680038198884316}{\texttt{Base.Math.acsch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acsch(A::AbstractMatrix)
\end{minted}

Compute the inverse matrix hyperbolic cosecant of \texttt{A}. 



\end{adjustwidth}
\hypertarget{12006952808365013482}{} 
\hyperlink{12006952808365013482}{\texttt{Base.Math.acoth}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
acoth(A::AbstractMatrix)
\end{minted}

Compute the inverse matrix hyperbolic cotangent of \texttt{A}. 



\end{adjustwidth}
\hypertarget{13191775510498989455}{} 
\hyperlink{13191775510498989455}{\texttt{LinearAlgebra.lyap}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lyap(A, C)
\end{minted}

Computes the solution \texttt{X} to the continuous Lyapunov equation \texttt{AX + XA{\textquotesingle} + C = 0}, where no eigenvalue of \texttt{A} has a zero real part and no two eigenvalues are negative complex conjugates of each other.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [3. 4.; 5. 6]
2×2 Array{Float64,2}:
 3.0  4.0
 5.0  6.0

julia> B = [1. 1.; 1. 2.]
2×2 Array{Float64,2}:
 1.0  1.0
 1.0  2.0

julia> X = lyap(A, B)
2×2 Array{Float64,2}:
  0.5  -0.5
 -0.5   0.25

julia> A*X + X*A' + B
2×2 Array{Float64,2}:
 0.0          6.66134e-16
 6.66134e-16  8.88178e-16
\end{minted}



\end{adjustwidth}
\hypertarget{1947738214979807634}{} 
\hyperlink{1947738214979807634}{\texttt{LinearAlgebra.sylvester}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sylvester(A, B, C)
\end{minted}

Computes the solution \texttt{X} to the Sylvester equation \texttt{AX + XB + C = 0}, where \texttt{A}, \texttt{B} and \texttt{C} have compatible dimensions and \texttt{A} and \texttt{-B} have no eigenvalues with equal real part.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [3. 4.; 5. 6]
2×2 Array{Float64,2}:
 3.0  4.0
 5.0  6.0

julia> B = [1. 1.; 1. 2.]
2×2 Array{Float64,2}:
 1.0  1.0
 1.0  2.0

julia> C = [1. 2.; -2. 1]
2×2 Array{Float64,2}:
  1.0  2.0
 -2.0  1.0

julia> X = sylvester(A, B, C)
2×2 Array{Float64,2}:
 -4.46667   1.93333
  3.73333  -1.8

julia> A*X + X*B + C
2×2 Array{Float64,2}:
  2.66454e-15  1.77636e-15
 -3.77476e-15  4.44089e-16
\end{minted}



\end{adjustwidth}
\hypertarget{10694198281534172656}{} 
\hyperlink{10694198281534172656}{\texttt{LinearAlgebra.issuccess}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issuccess(F::Factorization)
\end{minted}

Test that a factorization of a matrix succeeded.


\begin{minted}{jlcon}
julia> F = cholesky([1 0; 0 1]);

julia> LinearAlgebra.issuccess(F)
true

julia> F = lu([1 0; 0 0]; check = false);

julia> LinearAlgebra.issuccess(F)
false
\end{minted}



\end{adjustwidth}
\hypertarget{2326080217547608316}{} 
\hyperlink{2326080217547608316}{\texttt{LinearAlgebra.issymmetric}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issymmetric(A) -> Bool
\end{minted}

Test whether a matrix is symmetric.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia> issymmetric(a)
true

julia> b = [1 im; -im 1]
2×2 Array{Complex{Int64},2}:
 1+0im  0+1im
 0-1im  1+0im

julia> issymmetric(b)
false
\end{minted}



\end{adjustwidth}
\hypertarget{13841568437070319804}{} 
\hyperlink{13841568437070319804}{\texttt{LinearAlgebra.isposdef}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isposdef(A) -> Bool
\end{minted}

Test whether a matrix is positive definite (and Hermitian) by trying to perform a Cholesky factorization of \texttt{A}. See also \hyperlink{15124613555733932079}{\texttt{isposdef!}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 2 50]
2×2 Array{Int64,2}:
 1   2
 2  50

julia> isposdef(A)
true
\end{minted}



\end{adjustwidth}
\hypertarget{15124613555733932079}{} 
\hyperlink{15124613555733932079}{\texttt{LinearAlgebra.isposdef!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isposdef!(A) -> Bool
\end{minted}

Test whether a matrix is positive definite (and Hermitian) by trying to perform a Cholesky factorization of \texttt{A}, overwriting \texttt{A} in the process. See also \hyperlink{13841568437070319804}{\texttt{isposdef}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1. 2.; 2. 50.];

julia> isposdef!(A)
true

julia> A
2×2 Array{Float64,2}:
 1.0  2.0
 2.0  6.78233
\end{minted}



\end{adjustwidth}
\hypertarget{14402064054856945387}{} 
\hyperlink{14402064054856945387}{\texttt{LinearAlgebra.istril}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
istril(A::AbstractMatrix, k::Integer = 0) -> Bool
\end{minted}

Test whether \texttt{A} is lower triangular starting from the \texttt{k}th superdiagonal.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia> istril(a)
false

julia> istril(a, 1)
true

julia> b = [1 0; -im -1]
2×2 Array{Complex{Int64},2}:
 1+0im   0+0im
 0-1im  -1+0im

julia> istril(b)
true

julia> istril(b, -1)
false
\end{minted}



\end{adjustwidth}
\hypertarget{15000310211103088559}{} 
\hyperlink{15000310211103088559}{\texttt{LinearAlgebra.istriu}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
istriu(A::AbstractMatrix, k::Integer = 0) -> Bool
\end{minted}

Test whether \texttt{A} is upper triangular starting from the \texttt{k}th superdiagonal.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia> istriu(a)
false

julia> istriu(a, -1)
true

julia> b = [1 im; 0 -1]
2×2 Array{Complex{Int64},2}:
 1+0im   0+1im
 0+0im  -1+0im

julia> istriu(b)
true

julia> istriu(b, 1)
false
\end{minted}



\end{adjustwidth}
\hypertarget{13562995326026471446}{} 
\hyperlink{13562995326026471446}{\texttt{LinearAlgebra.isdiag}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isdiag(A) -> Bool
\end{minted}

Test whether a matrix is diagonal.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia> isdiag(a)
false

julia> b = [im 0; 0 -im]
2×2 Array{Complex{Int64},2}:
 0+1im  0+0im
 0+0im  0-1im

julia> isdiag(b)
true
\end{minted}



\end{adjustwidth}
\hypertarget{2319981190929881860}{} 
\hyperlink{2319981190929881860}{\texttt{LinearAlgebra.ishermitian}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ishermitian(A) -> Bool
\end{minted}

Test whether a matrix is Hermitian.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia> ishermitian(a)
true

julia> b = [1 im; -im 1]
2×2 Array{Complex{Int64},2}:
 1+0im  0+1im
 0-1im  1+0im

julia> ishermitian(b)
true
\end{minted}



\end{adjustwidth}
\hypertarget{12700837529519091997}{} 
\hyperlink{12700837529519091997}{\texttt{Base.transpose}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
transpose(A)
\end{minted}

Lazy transpose. Mutating the returned object should appropriately mutate \texttt{A}. Often, but not always, yields \texttt{Transpose(A)}, where \texttt{Transpose} is a lazy transpose wrapper. Note that this operation is recursive.

This operation is intended for linear algebra usage - for general data manipulation see \hyperlink{10913801624539723467}{\texttt{permutedims}}, which is non-recursive.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia> transpose(A)
2×2 Transpose{Complex{Int64},Array{Complex{Int64},2}}:
 3+2im  8+7im
 9+2im  4+6im
\end{minted}



\end{adjustwidth}
\hypertarget{11048480146030319791}{} 
\hyperlink{11048480146030319791}{\texttt{LinearAlgebra.transpose!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
transpose!(dest,src)
\end{minted}

Transpose array \texttt{src} and store the result in the preallocated array \texttt{dest}, which should have a size corresponding to \texttt{(size(src,2),size(src,1))}. No in-place transposition is supported and unexpected results will happen if \texttt{src} and \texttt{dest} have overlapping memory regions.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia> B = zeros(Complex{Int64}, 2, 2)
2×2 Array{Complex{Int64},2}:
 0+0im  0+0im
 0+0im  0+0im

julia> transpose!(B, A);

julia> B
2×2 Array{Complex{Int64},2}:
 3+2im  8+7im
 9+2im  4+6im

julia> A
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im
\end{minted}



\end{adjustwidth}
\hypertarget{14692313863932962816}{} 
\hyperlink{14692313863932962816}{\texttt{LinearAlgebra.Transpose}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Transpose
\end{minted}

Lazy wrapper type for a transpose view of the underlying linear algebra object, usually an \texttt{AbstractVector}/\texttt{AbstractMatrix}, but also some \texttt{Factorization}, for instance. Usually, the \texttt{Transpose} constructor should not be called directly, use \hyperlink{12700837529519091997}{\texttt{transpose}} instead. To materialize the view use \hyperlink{15665284441316555522}{\texttt{copy}}.

This type is intended for linear algebra usage - for general data manipulation see \hyperlink{10913801624539723467}{\texttt{permutedims}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia> transpose(A)
2×2 Transpose{Complex{Int64},Array{Complex{Int64},2}}:
 3+2im  8+7im
 9+2im  4+6im
\end{minted}



\end{adjustwidth}
\hypertarget{10565518144285607255}{} 
\hyperlink{10565518144285607255}{\texttt{Base.adjoint}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
adjoint(A)
\end{minted}

Lazy adjoint (conjugate transposition) (also postfix \texttt{{\textquotesingle}}). Note that \texttt{adjoint} is applied recursively to elements.

This operation is intended for linear algebra usage - for general data manipulation see \hyperlink{10913801624539723467}{\texttt{permutedims}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia> adjoint(A)
2×2 Adjoint{Complex{Int64},Array{Complex{Int64},2}}:
 3-2im  8-7im
 9-2im  4-6im
\end{minted}



\end{adjustwidth}
\hypertarget{9871500626629337445}{} 
\hyperlink{9871500626629337445}{\texttt{LinearAlgebra.adjoint!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
adjoint!(dest,src)
\end{minted}

Conjugate transpose array \texttt{src} and store the result in the preallocated array \texttt{dest}, which should have a size corresponding to \texttt{(size(src,2),size(src,1))}. No in-place transposition is supported and unexpected results will happen if \texttt{src} and \texttt{dest} have overlapping memory regions.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia> B = zeros(Complex{Int64}, 2, 2)
2×2 Array{Complex{Int64},2}:
 0+0im  0+0im
 0+0im  0+0im

julia> adjoint!(B, A);

julia> B
2×2 Array{Complex{Int64},2}:
 3-2im  8-7im
 9-2im  4-6im

julia> A
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im
\end{minted}



\end{adjustwidth}
\hypertarget{10784859587547982593}{} 
\hyperlink{10784859587547982593}{\texttt{LinearAlgebra.Adjoint}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Adjoint
\end{minted}

Lazy wrapper type for an adjoint view of the underlying linear algebra object, usually an \texttt{AbstractVector}/\texttt{AbstractMatrix}, but also some \texttt{Factorization}, for instance. Usually, the \texttt{Adjoint} constructor should not be called directly, use \hyperlink{10565518144285607255}{\texttt{adjoint}} instead. To materialize the view use \hyperlink{15665284441316555522}{\texttt{copy}}.

This type is intended for linear algebra usage - for general data manipulation see \hyperlink{10913801624539723467}{\texttt{permutedims}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia> adjoint(A)
2×2 Adjoint{Complex{Int64},Array{Complex{Int64},2}}:
 3-2im  8-7im
 9-2im  4-6im
\end{minted}



\end{adjustwidth}
\hypertarget{16739145811029380235}{} 
\hyperlink{16739145811029380235}{\texttt{Base.copy}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
copy(A::Transpose)
copy(A::Adjoint)
\end{minted}

Eagerly evaluate the lazy matrix transpose/adjoint. Note that the transposition is applied recursively to elements.

This operation is intended for linear algebra usage - for general data manipulation see \hyperlink{10913801624539723467}{\texttt{permutedims}}, which is non-recursive.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2im; -3im 4]
2×2 Array{Complex{Int64},2}:
 1+0im  0+2im
 0-3im  4+0im

julia> T = transpose(A)
2×2 Transpose{Complex{Int64},Array{Complex{Int64},2}}:
 1+0im  0-3im
 0+2im  4+0im

julia> copy(T)
2×2 Array{Complex{Int64},2}:
 1+0im  0-3im
 0+2im  4+0im
\end{minted}



\end{adjustwidth}
\hypertarget{17430342268269872501}{} 
\hyperlink{17430342268269872501}{\texttt{LinearAlgebra.stride1}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stride1(A) -> Int
\end{minted}

Return the distance between successive array elements in dimension 1 in units of element size.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1,2,3,4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> LinearAlgebra.stride1(A)
1

julia> B = view(A, 2:2:4)
2-element view(::Array{Int64,1}, 2:2:4) with eltype Int64:
 2
 4

julia> LinearAlgebra.stride1(B)
2
\end{minted}



\end{adjustwidth}
\hypertarget{3700476694218805076}{} 
\hyperlink{3700476694218805076}{\texttt{LinearAlgebra.checksquare}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LinearAlgebra.checksquare(A)
\end{minted}

Check that a matrix is square, then return its common dimension. For multiple arguments, return a vector.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = fill(1, (4,4)); B = fill(1, (5,5));

julia> LinearAlgebra.checksquare(A, B)
2-element Array{Int64,1}:
 4
 5
\end{minted}



\end{adjustwidth}
\hypertarget{2023980161110391079}{} 
\hyperlink{2023980161110391079}{\texttt{LinearAlgebra.peakflops}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LinearAlgebra.peakflops(n::Integer=2000; parallel::Bool=false)
\end{minted}

\texttt{peakflops} computes the peak flop rate of the computer by using double precision \hyperlink{8173170876588438683}{\texttt{gemm!}}. By default, if no arguments are specified, it multiplies a matrix of size \texttt{n x n}, where \texttt{n = 2000}. If the underlying BLAS is using multiple threads, higher flop rates are realized. The number of BLAS threads can be set with \hyperlink{2145233402822007277}{\texttt{BLAS.set\_num\_threads(n)}}.

If the keyword argument \texttt{parallel} is set to \texttt{true}, \texttt{peakflops} is run in parallel on all the worker processors. The flop rate of the entire parallel computer is returned. When running in parallel, only 1 BLAS thread is used. The argument \texttt{n} still refers to the size of the problem that is solved on each processor.

\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1. In Julia 1.0 it is available from the standard library \texttt{InteractiveUtils}.

\end{quote}


\end{adjustwidth}

\hypertarget{4687212954685590607}{}


\section{Low-level matrix operations}



In many cases there are in-place versions of matrix operations that allow you to supply a pre-allocated output vector or matrix.  This is useful when optimizing critical code in order to avoid the overhead of repeated allocations. These in-place operations are suffixed with \texttt{!} below (e.g. \texttt{mul!}) according to the usual Julia convention.


\hypertarget{364008531309780709}{} 
\hyperlink{364008531309780709}{\texttt{LinearAlgebra.mul!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mul!(Y, A, B) -> Y
\end{minted}

Calculates the matrix-matrix or matrix-vector product  \(AB\)  and stores the result in \texttt{Y}, overwriting the existing value of \texttt{Y}. Note that \texttt{Y} must not be aliased with either \texttt{A} or \texttt{B}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A=[1.0 2.0; 3.0 4.0]; B=[1.0 1.0; 1.0 1.0]; Y = similar(B); mul!(Y, A, B);

julia> Y
2×2 Array{Float64,2}:
 3.0  3.0
 7.0  7.0
\end{minted}

\textbf{Implementation}

For custom matrix and vector types, it is recommended to implement 5-argument \texttt{mul!} rather than implementing 3-argument \texttt{mul!} directly if possible.




\begin{lstlisting}
mul!(C, A, B, α, β) -> C
\end{lstlisting}

Combined inplace matrix-matrix or matrix-vector multiply-add  \(A B α + C β\) . The result is stored in \texttt{C} by overwriting it.  Note that \texttt{C} must not be aliased with either \texttt{A} or \texttt{B}.

\begin{quote}
\textbf{Julia 1.3}

Five-argument \texttt{mul!} requires at least Julia 1.3.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A=[1.0 2.0; 3.0 4.0]; B=[1.0 1.0; 1.0 1.0]; C=[1.0 2.0; 3.0 4.0];

julia> mul!(C, A, B, 100.0, 10.0) === C
true

julia> C
2×2 Array{Float64,2}:
 310.0  320.0
 730.0  740.0
\end{minted}



\end{adjustwidth}
\hypertarget{12404459690324241452}{} 
\hyperlink{12404459690324241452}{\texttt{LinearAlgebra.lmul!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
lmul!(a::Number, B::AbstractArray)
\end{minted}

Scale an array \texttt{B} by a scalar \texttt{a} overwriting \texttt{B} in-place.  Use \hyperlink{11562785155463579477}{\texttt{rmul!}} to multiply scalar from right.  The scaling operation respects the semantics of the multiplication \hyperlink{7592762607639177347}{\texttt{*}} between \texttt{a} and an element of \texttt{B}.  In particular, this also applies to multiplication involving non-finite numbers such as \texttt{NaN} and \texttt{±Inf}.

\begin{quote}
\textbf{Julia 1.1}

Prior to Julia 1.1, \texttt{NaN} and \texttt{±Inf} entries in \texttt{B} were treated inconsistently.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> B = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> lmul!(2, B)
2×2 Array{Int64,2}:
 2  4
 6  8

julia> lmul!(0.0, [Inf])
1-element Array{Float64,1}:
 NaN
\end{minted}




\begin{lstlisting}
lmul!(A, B)
\end{lstlisting}

Calculate the matrix-matrix product  \(AB\) , overwriting \texttt{B}, and return the result. Here, \texttt{A} must be of special matrix type, like, e.g., \hyperlink{3300114559258360989}{\texttt{Diagonal}}, \hyperlink{6344726545165008167}{\texttt{UpperTriangular}} or \hyperlink{15116078732779234709}{\texttt{LowerTriangular}}, or of some orthogonal type, see \hyperlink{16913872014958777367}{\texttt{QR}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> B = [0 1; 1 0];

julia> A = LinearAlgebra.UpperTriangular([1 2; 0 3]);

julia> LinearAlgebra.lmul!(A, B);

julia> B
2×2 Array{Int64,2}:
 2  1
 3  0

julia> B = [1.0 2.0; 3.0 4.0];

julia> F = qr([0 1; -1 0]);

julia> lmul!(F.Q, B)
2×2 Array{Float64,2}:
 3.0  4.0
 1.0  2.0
\end{minted}



\end{adjustwidth}
\hypertarget{11562785155463579477}{} 
\hyperlink{11562785155463579477}{\texttt{LinearAlgebra.rmul!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rmul!(A::AbstractArray, b::Number)
\end{minted}

Scale an array \texttt{A} by a scalar \texttt{b} overwriting \texttt{A} in-place.  Use \hyperlink{12404459690324241452}{\texttt{lmul!}} to multiply scalar from left.  The scaling operation respects the semantics of the multiplication \hyperlink{7592762607639177347}{\texttt{*}} between an element of \texttt{A} and \texttt{b}.  In particular, this also applies to multiplication involving non-finite numbers such as \texttt{NaN} and \texttt{±Inf}.

\begin{quote}
\textbf{Julia 1.1}

Prior to Julia 1.1, \texttt{NaN} and \texttt{±Inf} entries in \texttt{A} were treated inconsistently.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rmul!(A, 2)
2×2 Array{Int64,2}:
 2  4
 6  8

julia> rmul!([NaN], 0.0)
1-element Array{Float64,1}:
 NaN
\end{minted}




\begin{lstlisting}
rmul!(A, B)
\end{lstlisting}

Calculate the matrix-matrix product  \(AB\) , overwriting \texttt{A}, and return the result. Here, \texttt{B} must be of special matrix type, like, e.g., \hyperlink{3300114559258360989}{\texttt{Diagonal}}, \hyperlink{6344726545165008167}{\texttt{UpperTriangular}} or \hyperlink{15116078732779234709}{\texttt{LowerTriangular}}, or of some orthogonal type, see \hyperlink{16913872014958777367}{\texttt{QR}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [0 1; 1 0];

julia> B = LinearAlgebra.UpperTriangular([1 2; 0 3]);

julia> LinearAlgebra.rmul!(A, B);

julia> A
2×2 Array{Int64,2}:
 0  3
 1  2

julia> A = [1.0 2.0; 3.0 4.0];

julia> F = qr([0 1; -1 0]);

julia> rmul!(A, F.Q)
2×2 Array{Float64,2}:
 2.0  1.0
 4.0  3.0
\end{minted}



\end{adjustwidth}
\hypertarget{11817740014578453690}{} 
\hyperlink{11817740014578453690}{\texttt{LinearAlgebra.ldiv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ldiv!(Y, A, B) -> Y
\end{minted}

Compute \texttt{A {\textbackslash} B} in-place and store the result in \texttt{Y}, returning the result.

The argument \texttt{A} should \emph{not} be a matrix.  Rather, instead of matrices it should be a factorization object (e.g. produced by \hyperlink{7042962205548658937}{\texttt{factorize}} or \hyperlink{7653413936706994771}{\texttt{cholesky}}). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., \hyperlink{3268903080173564842}{\texttt{lu!}}), and performance-critical situations requiring \texttt{ldiv!} usually also require fine-grained control over the factorization of \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2.2 4; 3.1 0.2 3; 4 1 2];

julia> X = [1; 2.5; 3];

julia> Y = zero(X);

julia> ldiv!(Y, qr(A), X);

julia> Y
3-element Array{Float64,1}:
  0.7128099173553719
 -0.051652892561983674
  0.10020661157024757

julia> A\X
3-element Array{Float64,1}:
  0.7128099173553719
 -0.05165289256198333
  0.10020661157024785
\end{minted}




\begin{lstlisting}
ldiv!(A, B)
\end{lstlisting}

Compute \texttt{A {\textbackslash} B} in-place and overwriting \texttt{B} to store the result.

The argument \texttt{A} should \emph{not} be a matrix.  Rather, instead of matrices it should be a factorization object (e.g. produced by \hyperlink{7042962205548658937}{\texttt{factorize}} or \hyperlink{7653413936706994771}{\texttt{cholesky}}). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., \hyperlink{3268903080173564842}{\texttt{lu!}}), and performance-critical situations requiring \texttt{ldiv!} usually also require fine-grained control over the factorization of \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2.2 4; 3.1 0.2 3; 4 1 2];

julia> X = [1; 2.5; 3];

julia> Y = copy(X);

julia> ldiv!(qr(A), X);

julia> X
3-element Array{Float64,1}:
  0.7128099173553719
 -0.051652892561983674
  0.10020661157024757

julia> A\Y
3-element Array{Float64,1}:
  0.7128099173553719
 -0.05165289256198333
  0.10020661157024785
\end{minted}




\begin{lstlisting}
ldiv!(a::Number, B::AbstractArray)
\end{lstlisting}

Divide each entry in an array \texttt{B} by a scalar \texttt{a} overwriting \texttt{B} in-place.  Use \hyperlink{14949618513077509248}{\texttt{rdiv!}} to divide scalar from right.

\textbf{Examples}


\begin{minted}{jlcon}
julia> B = [1.0 2.0; 3.0 4.0]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia> ldiv!(2.0, B)
2×2 Array{Float64,2}:
 0.5  1.0
 1.5  2.0
\end{minted}



\end{adjustwidth}
\hypertarget{14949618513077509248}{} 
\hyperlink{14949618513077509248}{\texttt{LinearAlgebra.rdiv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rdiv!(A, B)
\end{minted}

Compute \texttt{A / B} in-place and overwriting \texttt{A} to store the result.

The argument \texttt{B} should \emph{not} be a matrix.  Rather, instead of matrices it should be a factorization object (e.g. produced by \hyperlink{7042962205548658937}{\texttt{factorize}} or \hyperlink{7653413936706994771}{\texttt{cholesky}}). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., \hyperlink{3268903080173564842}{\texttt{lu!}}), and performance-critical situations requiring \texttt{rdiv!} usually also require fine-grained control over the factorization of \texttt{B}.




\begin{lstlisting}
rdiv!(A::AbstractArray, b::Number)
\end{lstlisting}

Divide each entry in an array \texttt{A} by a scalar \texttt{b} overwriting \texttt{A} in-place.  Use \hyperlink{11817740014578453690}{\texttt{ldiv!}} to divide scalar from left.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1.0 2.0; 3.0 4.0]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia> rdiv!(A, 2.0)
2×2 Array{Float64,2}:
 0.5  1.0
 1.5  2.0
\end{minted}



\end{adjustwidth}

\hypertarget{11716155958635895745}{}


\section{BLAS functions}



In Julia (as in much of scientific computation), dense linear-algebra operations are based on the \href{http://www.netlib.org/lapack/}{LAPACK library}, which in turn is built on top of basic linear-algebra building-blocks known as the \href{http://www.netlib.org/blas/}{BLAS}. There are highly optimized implementations of BLAS available for every computer architecture, and sometimes in high-performance linear algebra routines it is useful to call the BLAS functions directly.



\texttt{LinearAlgebra.BLAS} provides wrappers for some of the BLAS functions. Those BLAS functions that overwrite one of the input arrays have names ending in \texttt{{\textquotesingle}!{\textquotesingle}}.  Usually, a BLAS function has four methods defined, for \hyperlink{5027751419500983000}{\texttt{Float64}}, \hyperlink{8101639384272933082}{\texttt{Float32}}, \texttt{ComplexF64}, and \texttt{ComplexF32} arrays.



\hypertarget{11073177327200670825}{}


\subsection{BLAS character arguments}



Many BLAS functions accept arguments that determine whether to transpose an argument (\texttt{trans}), which triangle of a matrix to reference (\texttt{uplo} or \texttt{ul}), whether the diagonal of a triangular matrix can be assumed to be all ones (\texttt{dA}) or which side of a matrix multiplication the input argument belongs on (\texttt{side}). The possibilities are:



\hypertarget{1714685266370616361}{}


\subsubsection{Multiplication order}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\texttt{side} & Meaning \\
\hline
\texttt{{\textquotesingle}L{\textquotesingle}} & The argument goes on the \emph{left} side of a matrix-matrix operation. \\
\hline
\texttt{{\textquotesingle}R{\textquotesingle}} & The argument goes on the \emph{right} side of a matrix-matrix operation. \\
\hline
\end{tabulary}

\end{table}



\hypertarget{5558887752259302145}{}


\subsubsection{Triangle referencing}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\texttt{uplo}/\texttt{ul} & Meaning \\
\hline
\texttt{{\textquotesingle}U{\textquotesingle}} & Only the \emph{upper} triangle of the matrix will be used. \\
\hline
\texttt{{\textquotesingle}L{\textquotesingle}} & Only the \emph{lower} triangle of the matrix will be used. \\
\hline
\end{tabulary}

\end{table}



\hypertarget{13285421231458545876}{}


\subsubsection{Transposition operation}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\texttt{trans}/\texttt{tX} & Meaning \\
\hline
\texttt{{\textquotesingle}N{\textquotesingle}} & The input matrix \texttt{X} is not transposed or conjugated. \\
\hline
\texttt{{\textquotesingle}T{\textquotesingle}} & The input matrix \texttt{X} will be transposed. \\
\hline
\texttt{{\textquotesingle}C{\textquotesingle}} & The input matrix \texttt{X} will be conjugated and transposed. \\
\hline
\end{tabulary}

\end{table}



\hypertarget{11643333471578083521}{}


\subsubsection{Unit diagonal}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\texttt{diag}/\texttt{dX} & Meaning \\
\hline
\texttt{{\textquotesingle}N{\textquotesingle}} & The diagonal values of the matrix \texttt{X} will be read. \\
\hline
\texttt{{\textquotesingle}U{\textquotesingle}} & The diagonal of the matrix \texttt{X} is assumed to be all ones. \\
\hline
\end{tabulary}

\end{table}


\hypertarget{16764328874035557229}{} 
\hyperlink{16764328874035557229}{\texttt{LinearAlgebra.BLAS}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}

Interface to BLAS subroutines.



\end{adjustwidth}
\hypertarget{18272264626945379268}{} 
\hyperlink{18272264626945379268}{\texttt{LinearAlgebra.BLAS.dot}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dot(n, X, incx, Y, incy)
\end{minted}

Dot product of two vectors consisting of \texttt{n} elements of array \texttt{X} with stride \texttt{incx} and \texttt{n} elements of array \texttt{Y} with stride \texttt{incy}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> BLAS.dot(10, fill(1.0, 10), 1, fill(1.0, 20), 2)
10.0
\end{minted}



\end{adjustwidth}
\hypertarget{17189447686500977816}{} 
\hyperlink{17189447686500977816}{\texttt{LinearAlgebra.BLAS.dotu}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dotu(n, X, incx, Y, incy)
\end{minted}

Dot function for two complex vectors consisting of \texttt{n} elements of array \texttt{X} with stride \texttt{incx} and \texttt{n} elements of array \texttt{Y} with stride \texttt{incy}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> BLAS.dotu(10, fill(1.0im, 10), 1, fill(1.0+im, 20), 2)
-10.0 + 10.0im
\end{minted}



\end{adjustwidth}
\hypertarget{14215820815183043302}{} 
\hyperlink{14215820815183043302}{\texttt{LinearAlgebra.BLAS.dotc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dotc(n, X, incx, U, incy)
\end{minted}

Dot function for two complex vectors, consisting of \texttt{n} elements of array \texttt{X} with stride \texttt{incx} and \texttt{n} elements of array \texttt{U} with stride \texttt{incy}, conjugating the first vector.

\textbf{Examples}


\begin{minted}{jlcon}
julia> BLAS.dotc(10, fill(1.0im, 10), 1, fill(1.0+im, 20), 2)
10.0 - 10.0im
\end{minted}



\end{adjustwidth}
\hypertarget{18067085143510999712}{} 
\hyperlink{18067085143510999712}{\texttt{LinearAlgebra.BLAS.blascopy!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
blascopy!(n, X, incx, Y, incy)
\end{minted}

Copy \texttt{n} elements of array \texttt{X} with stride \texttt{incx} to array \texttt{Y} with stride \texttt{incy}. Returns \texttt{Y}.



\end{adjustwidth}
\hypertarget{16054338457942758080}{} 
\hyperlink{16054338457942758080}{\texttt{LinearAlgebra.BLAS.nrm2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nrm2(n, X, incx)
\end{minted}

2-norm of a vector consisting of \texttt{n} elements of array \texttt{X} with stride \texttt{incx}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> BLAS.nrm2(4, fill(1.0, 8), 2)
2.0

julia> BLAS.nrm2(1, fill(1.0, 8), 2)
1.0
\end{minted}



\end{adjustwidth}
\hypertarget{17921796148467908168}{} 
\hyperlink{17921796148467908168}{\texttt{LinearAlgebra.BLAS.asum}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
asum(n, X, incx)
\end{minted}

Sum of the absolute values of the first \texttt{n} elements of array \texttt{X} with stride \texttt{incx}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> BLAS.asum(5, fill(1.0im, 10), 2)
5.0

julia> BLAS.asum(2, fill(1.0im, 10), 5)
2.0
\end{minted}



\end{adjustwidth}
\hypertarget{1249554703870980233}{} 
\hyperlink{1249554703870980233}{\texttt{LinearAlgebra.axpy!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
axpy!(a, X, Y)
\end{minted}

Overwrite \texttt{Y} with \texttt{X*a + Y}, where \texttt{a} is a scalar. Return \texttt{Y}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = [1; 2; 3];

julia> y = [4; 5; 6];

julia> BLAS.axpy!(2, x, y)
3-element Array{Int64,1}:
  6
  9
 12
\end{minted}



\end{adjustwidth}
\hypertarget{15769382652026820442}{} 
\hyperlink{15769382652026820442}{\texttt{LinearAlgebra.axpby!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
axpby!(a, X, b, Y)
\end{minted}

Overwrite \texttt{Y} with \texttt{X*a + Y*b}, where \texttt{a} and \texttt{b} are scalars. Return \texttt{Y}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = [1., 2, 3];

julia> y = [4., 5, 6];

julia> BLAS.axpby!(2., x, 3., y)
3-element Array{Float64,1}:
 14.0
 19.0
 24.0
\end{minted}



\end{adjustwidth}
\hypertarget{1309689219983162396}{} 
\hyperlink{1309689219983162396}{\texttt{LinearAlgebra.BLAS.scal!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
scal!(n, a, X, incx)
\end{minted}

Overwrite \texttt{X} with \texttt{a*X} for the first \texttt{n} elements of array \texttt{X} with stride \texttt{incx}. Returns \texttt{X}.



\end{adjustwidth}
\hypertarget{12895642275868597015}{} 
\hyperlink{12895642275868597015}{\texttt{LinearAlgebra.BLAS.scal}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
scal(n, a, X, incx)
\end{minted}

Return \texttt{X} scaled by \texttt{a} for the first \texttt{n} elements of array \texttt{X} with stride \texttt{incx}.



\end{adjustwidth}
\hypertarget{7368077295193322508}{} 
\hyperlink{7368077295193322508}{\texttt{LinearAlgebra.BLAS.iamax}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
iamax(n, dx, incx)
iamax(dx)
\end{minted}

Find the index of the element of \texttt{dx} with the maximum absolute value. \texttt{n} is the length of \texttt{dx}, and \texttt{incx} is the stride. If \texttt{n} and \texttt{incx} are not provided, they assume default values of \texttt{n=length(dx)} and \texttt{incx=stride1(dx)}.



\end{adjustwidth}
\hypertarget{15218685048281144798}{} 
\hyperlink{15218685048281144798}{\texttt{LinearAlgebra.BLAS.ger!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ger!(alpha, x, y, A)
\end{minted}

Rank-1 update of the matrix \texttt{A} with vectors \texttt{x} and \texttt{y} as \texttt{alpha*x*y{\textquotesingle} + A}.



\end{adjustwidth}
\hypertarget{12739496223053575792}{} 
\hyperlink{12739496223053575792}{\texttt{LinearAlgebra.BLAS.syr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
syr!(uplo, alpha, x, A)
\end{minted}

Rank-1 update of the symmetric matrix \texttt{A} with vector \texttt{x} as \texttt{alpha*x*transpose(x) + A}. \hyperlink{13880289478825450693}{\texttt{uplo}} controls which triangle of \texttt{A} is updated. Returns \texttt{A}.



\end{adjustwidth}
\hypertarget{17626560315865992019}{} 
\hyperlink{17626560315865992019}{\texttt{LinearAlgebra.BLAS.syrk!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
syrk!(uplo, trans, alpha, A, beta, C)
\end{minted}

Rank-k update of the symmetric matrix \texttt{C} as \texttt{alpha*A*transpose(A) + beta*C} or \texttt{alpha*transpose(A)*A + beta*C} according to \hyperlink{15951037910221396131}{\texttt{trans}}. Only the \hyperlink{13880289478825450693}{\texttt{uplo}} triangle of \texttt{C} is used. Returns \texttt{C}.



\end{adjustwidth}
\hypertarget{13051593926705442778}{} 
\hyperlink{13051593926705442778}{\texttt{LinearAlgebra.BLAS.syrk}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
syrk(uplo, trans, alpha, A)
\end{minted}

Returns either the upper triangle or the lower triangle of \texttt{A}, according to \hyperlink{13880289478825450693}{\texttt{uplo}}, of \texttt{alpha*A*transpose(A)} or \texttt{alpha*transpose(A)*A}, according to \hyperlink{15951037910221396131}{\texttt{trans}}.



\end{adjustwidth}
\hypertarget{4077074915146270084}{} 
\hyperlink{4077074915146270084}{\texttt{LinearAlgebra.BLAS.syr2k!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
syr2k!(uplo, trans, alpha, A, B, beta, C)
\end{minted}

Rank-2k update of the symmetric matrix \texttt{C} as \texttt{alpha*A*transpose(B) + alpha*B*transpose(A) + beta*C} or \texttt{alpha*transpose(A)*B + alpha*transpose(B)*A + beta*C} according to \hyperlink{15951037910221396131}{\texttt{trans}}. Only the \hyperlink{13880289478825450693}{\texttt{uplo}} triangle of \texttt{C} is used. Returns \texttt{C}.



\end{adjustwidth}
\hypertarget{8760875486589937064}{} 
\hyperlink{8760875486589937064}{\texttt{LinearAlgebra.BLAS.syr2k}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
syr2k(uplo, trans, alpha, A, B)
\end{minted}

Returns the \hyperlink{13880289478825450693}{\texttt{uplo}} triangle of \texttt{alpha*A*transpose(B) + alpha*B*transpose(A)} or \texttt{alpha*transpose(A)*B + alpha*transpose(B)*A}, according to \hyperlink{15951037910221396131}{\texttt{trans}}.




\begin{lstlisting}
syr2k(uplo, trans, A, B)
\end{lstlisting}

Returns the \hyperlink{13880289478825450693}{\texttt{uplo}} triangle of \texttt{A*transpose(B) + B*transpose(A)} or \texttt{transpose(A)*B + transpose(B)*A}, according to \hyperlink{15951037910221396131}{\texttt{trans}}.



\end{adjustwidth}
\hypertarget{13391948874280376128}{} 
\hyperlink{13391948874280376128}{\texttt{LinearAlgebra.BLAS.her!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
her!(uplo, alpha, x, A)
\end{minted}

Methods for complex arrays only. Rank-1 update of the Hermitian matrix \texttt{A} with vector \texttt{x} as \texttt{alpha*x*x{\textquotesingle} + A}. \hyperlink{13880289478825450693}{\texttt{uplo}} controls which triangle of \texttt{A} is updated. Returns \texttt{A}.



\end{adjustwidth}
\hypertarget{13961548415194246627}{} 
\hyperlink{13961548415194246627}{\texttt{LinearAlgebra.BLAS.herk!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
herk!(uplo, trans, alpha, A, beta, C)
\end{minted}

Methods for complex arrays only. Rank-k update of the Hermitian matrix \texttt{C} as \texttt{alpha*A*A{\textquotesingle} + beta*C} or \texttt{alpha*A{\textquotesingle}*A + beta*C} according to \hyperlink{15951037910221396131}{\texttt{trans}}. Only the \hyperlink{13880289478825450693}{\texttt{uplo}} triangle of \texttt{C} is updated. Returns \texttt{C}.



\end{adjustwidth}
\hypertarget{10248669546555807730}{} 
\hyperlink{10248669546555807730}{\texttt{LinearAlgebra.BLAS.herk}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
herk(uplo, trans, alpha, A)
\end{minted}

Methods for complex arrays only. Returns the \hyperlink{13880289478825450693}{\texttt{uplo}} triangle of \texttt{alpha*A*A{\textquotesingle}} or \texttt{alpha*A{\textquotesingle}*A}, according to \hyperlink{15951037910221396131}{\texttt{trans}}.



\end{adjustwidth}
\hypertarget{7429214484576657213}{} 
\hyperlink{7429214484576657213}{\texttt{LinearAlgebra.BLAS.her2k!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
her2k!(uplo, trans, alpha, A, B, beta, C)
\end{minted}

Rank-2k update of the Hermitian matrix \texttt{C} as \texttt{alpha*A*B{\textquotesingle} + alpha*B*A{\textquotesingle} + beta*C} or \texttt{alpha*A{\textquotesingle}*B + alpha*B{\textquotesingle}*A + beta*C} according to \hyperlink{15951037910221396131}{\texttt{trans}}. The scalar \texttt{beta} has to be real. Only the \hyperlink{13880289478825450693}{\texttt{uplo}} triangle of \texttt{C} is used. Returns \texttt{C}.



\end{adjustwidth}
\hypertarget{1414422633857793327}{} 
\hyperlink{1414422633857793327}{\texttt{LinearAlgebra.BLAS.her2k}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
her2k(uplo, trans, alpha, A, B)
\end{minted}

Returns the \hyperlink{13880289478825450693}{\texttt{uplo}} triangle of \texttt{alpha*A*B{\textquotesingle} + alpha*B*A{\textquotesingle}} or \texttt{alpha*A{\textquotesingle}*B + alpha*B{\textquotesingle}*A}, according to \hyperlink{15951037910221396131}{\texttt{trans}}.




\begin{lstlisting}
her2k(uplo, trans, A, B)
\end{lstlisting}

Returns the \hyperlink{13880289478825450693}{\texttt{uplo}} triangle of \texttt{A*B{\textquotesingle} + B*A{\textquotesingle}} or \texttt{A{\textquotesingle}*B + B{\textquotesingle}*A}, according to \hyperlink{15951037910221396131}{\texttt{trans}}.



\end{adjustwidth}
\hypertarget{8676615954581837341}{} 
\hyperlink{8676615954581837341}{\texttt{LinearAlgebra.BLAS.gbmv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gbmv!(trans, m, kl, ku, alpha, A, x, beta, y)
\end{minted}

Update vector \texttt{y} as \texttt{alpha*A*x + beta*y} or \texttt{alpha*A{\textquotesingle}*x + beta*y} according to \hyperlink{15951037910221396131}{\texttt{trans}}. The matrix \texttt{A} is a general band matrix of dimension \texttt{m} by \texttt{size(A,2)} with \texttt{kl} sub-diagonals and \texttt{ku} super-diagonals. \texttt{alpha} and \texttt{beta} are scalars. Return the updated \texttt{y}.



\end{adjustwidth}
\hypertarget{12471388286549789624}{} 
\hyperlink{12471388286549789624}{\texttt{LinearAlgebra.BLAS.gbmv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gbmv(trans, m, kl, ku, alpha, A, x)
\end{minted}

Return \texttt{alpha*A*x} or \texttt{alpha*A{\textquotesingle}*x} according to \hyperlink{15951037910221396131}{\texttt{trans}}. The matrix \texttt{A} is a general band matrix of dimension \texttt{m} by \texttt{size(A,2)} with \texttt{kl} sub-diagonals and \texttt{ku} super-diagonals, and \texttt{alpha} is a scalar.



\end{adjustwidth}
\hypertarget{321677349067447286}{} 
\hyperlink{321677349067447286}{\texttt{LinearAlgebra.BLAS.sbmv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sbmv!(uplo, k, alpha, A, x, beta, y)
\end{minted}

Update vector \texttt{y} as \texttt{alpha*A*x + beta*y} where \texttt{A} is a a symmetric band matrix of order \texttt{size(A,2)} with \texttt{k} super-diagonals stored in the argument \texttt{A}. The storage layout for \texttt{A} is described the reference BLAS module, level-2 BLAS at \href{http://www.netlib.org/lapack/explore-html/}{http://www.netlib.org/lapack/explore-html/}. Only the \hyperlink{13880289478825450693}{\texttt{uplo}} triangle of \texttt{A} is used.

Return the updated \texttt{y}.



\end{adjustwidth}
\hypertarget{17387012353031396238}{} 
\hyperlink{17387012353031396238}{\texttt{LinearAlgebra.BLAS.sbmv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sbmv(uplo, k, alpha, A, x)
\end{minted}

Return \texttt{alpha*A*x} where \texttt{A} is a symmetric band matrix of order \texttt{size(A,2)} with \texttt{k} super-diagonals stored in the argument \texttt{A}. Only the \hyperlink{13880289478825450693}{\texttt{uplo}} triangle of \texttt{A} is used.



\end{adjustwidth}
\hypertarget{7451827779071390643}{} 
\hyperlink{7451827779071390643}{\texttt{LinearAlgebra.BLAS.sbmv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sbmv(uplo, k, A, x)
\end{minted}

Return \texttt{A*x} where \texttt{A} is a symmetric band matrix of order \texttt{size(A,2)} with \texttt{k} super-diagonals stored in the argument \texttt{A}. Only the \hyperlink{13880289478825450693}{\texttt{uplo}} triangle of \texttt{A} is used.



\end{adjustwidth}
\hypertarget{8173170876588438683}{} 
\hyperlink{8173170876588438683}{\texttt{LinearAlgebra.BLAS.gemm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gemm!(tA, tB, alpha, A, B, beta, C)
\end{minted}

Update \texttt{C} as \texttt{alpha*A*B + beta*C} or the other three variants according to \hyperlink{15951037910221396131}{\texttt{tA}} and \texttt{tB}. Return the updated \texttt{C}.



\end{adjustwidth}
\hypertarget{12935993568670314935}{} 
\hyperlink{12935993568670314935}{\texttt{LinearAlgebra.BLAS.gemm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gemm(tA, tB, alpha, A, B)
\end{minted}

Return \texttt{alpha*A*B} or the other three variants according to \hyperlink{15951037910221396131}{\texttt{tA}} and \texttt{tB}.



\end{adjustwidth}
\hypertarget{10789182689496100432}{} 
\hyperlink{10789182689496100432}{\texttt{LinearAlgebra.BLAS.gemm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gemm(tA, tB, A, B)
\end{minted}

Return \texttt{A*B} or the other three variants according to \hyperlink{15951037910221396131}{\texttt{tA}} and \texttt{tB}.



\end{adjustwidth}
\hypertarget{11474194682797565787}{} 
\hyperlink{11474194682797565787}{\texttt{LinearAlgebra.BLAS.gemv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gemv!(tA, alpha, A, x, beta, y)
\end{minted}

Update the vector \texttt{y} as \texttt{alpha*A*x + beta*y} or \texttt{alpha*A{\textquotesingle}x + beta*y} according to \hyperlink{15951037910221396131}{\texttt{tA}}. \texttt{alpha} and \texttt{beta} are scalars. Return the updated \texttt{y}.



\end{adjustwidth}
\hypertarget{1491593334980744629}{} 
\hyperlink{1491593334980744629}{\texttt{LinearAlgebra.BLAS.gemv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gemv(tA, alpha, A, x)
\end{minted}

Return \texttt{alpha*A*x} or \texttt{alpha*A{\textquotesingle}x} according to \hyperlink{15951037910221396131}{\texttt{tA}}. \texttt{alpha} is a scalar.



\end{adjustwidth}
\hypertarget{10250669589948467576}{} 
\hyperlink{10250669589948467576}{\texttt{LinearAlgebra.BLAS.gemv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gemv(tA, A, x)
\end{minted}

Return \texttt{A*x} or \texttt{A{\textquotesingle}x} according to \hyperlink{15951037910221396131}{\texttt{tA}}.



\end{adjustwidth}
\hypertarget{8132740051631912637}{} 
\hyperlink{8132740051631912637}{\texttt{LinearAlgebra.BLAS.symm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
symm!(side, ul, alpha, A, B, beta, C)
\end{minted}

Update \texttt{C} as \texttt{alpha*A*B + beta*C} or \texttt{alpha*B*A + beta*C} according to \hyperlink{3128026147631247774}{\texttt{side}}. \texttt{A} is assumed to be symmetric. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used. Return the updated \texttt{C}.



\end{adjustwidth}
\hypertarget{14160843903859790944}{} 
\hyperlink{14160843903859790944}{\texttt{LinearAlgebra.BLAS.symm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
symm(side, ul, alpha, A, B)
\end{minted}

Return \texttt{alpha*A*B} or \texttt{alpha*B*A} according to \hyperlink{3128026147631247774}{\texttt{side}}. \texttt{A} is assumed to be symmetric. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used.



\end{adjustwidth}
\hypertarget{16069722670191405715}{} 
\hyperlink{16069722670191405715}{\texttt{LinearAlgebra.BLAS.symm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
symm(side, ul, A, B)
\end{minted}

Return \texttt{A*B} or \texttt{B*A} according to \hyperlink{3128026147631247774}{\texttt{side}}. \texttt{A} is assumed to be symmetric. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used.



\end{adjustwidth}
\hypertarget{11756106038468185414}{} 
\hyperlink{11756106038468185414}{\texttt{LinearAlgebra.BLAS.symv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
symv!(ul, alpha, A, x, beta, y)
\end{minted}

Update the vector \texttt{y} as \texttt{alpha*A*x + beta*y}. \texttt{A} is assumed to be symmetric. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used. \texttt{alpha} and \texttt{beta} are scalars. Return the updated \texttt{y}.



\end{adjustwidth}
\hypertarget{9719310770398023656}{} 
\hyperlink{9719310770398023656}{\texttt{LinearAlgebra.BLAS.symv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
symv(ul, alpha, A, x)
\end{minted}

Return \texttt{alpha*A*x}. \texttt{A} is assumed to be symmetric. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used. \texttt{alpha} is a scalar.



\end{adjustwidth}
\hypertarget{5603412151724289616}{} 
\hyperlink{5603412151724289616}{\texttt{LinearAlgebra.BLAS.symv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
symv(ul, A, x)
\end{minted}

Return \texttt{A*x}. \texttt{A} is assumed to be symmetric. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used.



\end{adjustwidth}
\hypertarget{16247072505934468966}{} 
\hyperlink{16247072505934468966}{\texttt{LinearAlgebra.BLAS.hemm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hemm!(side, ul, alpha, A, B, beta, C)
\end{minted}

Update \texttt{C} as \texttt{alpha*A*B + beta*C} or \texttt{alpha*B*A + beta*C} according to \hyperlink{3128026147631247774}{\texttt{side}}. \texttt{A} is assumed to be Hermitian. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used. Return the updated \texttt{C}.



\end{adjustwidth}
\hypertarget{6201781936415538210}{} 
\hyperlink{6201781936415538210}{\texttt{LinearAlgebra.BLAS.hemm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hemm(side, ul, alpha, A, B)
\end{minted}

Return \texttt{alpha*A*B} or \texttt{alpha*B*A} according to \hyperlink{3128026147631247774}{\texttt{side}}. \texttt{A} is assumed to be Hermitian. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used.



\end{adjustwidth}
\hypertarget{4698646581937392256}{} 
\hyperlink{4698646581937392256}{\texttt{LinearAlgebra.BLAS.hemm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hemm(side, ul, A, B)
\end{minted}

Return \texttt{A*B} or \texttt{B*A} according to \hyperlink{3128026147631247774}{\texttt{side}}. \texttt{A} is assumed to be Hermitian. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used.



\end{adjustwidth}
\hypertarget{9920007331130447492}{} 
\hyperlink{9920007331130447492}{\texttt{LinearAlgebra.BLAS.hemv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hemv!(ul, alpha, A, x, beta, y)
\end{minted}

Update the vector \texttt{y} as \texttt{alpha*A*x + beta*y}. \texttt{A} is assumed to be Hermitian. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used. \texttt{alpha} and \texttt{beta} are scalars. Return the updated \texttt{y}.



\end{adjustwidth}
\hypertarget{6944896949603577091}{} 
\hyperlink{6944896949603577091}{\texttt{LinearAlgebra.BLAS.hemv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hemv(ul, alpha, A, x)
\end{minted}

Return \texttt{alpha*A*x}. \texttt{A} is assumed to be Hermitian. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used. \texttt{alpha} is a scalar.



\end{adjustwidth}
\hypertarget{9526750005879662729}{} 
\hyperlink{9526750005879662729}{\texttt{LinearAlgebra.BLAS.hemv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hemv(ul, A, x)
\end{minted}

Return \texttt{A*x}. \texttt{A} is assumed to be Hermitian. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used.



\end{adjustwidth}
\hypertarget{8591334681358631512}{} 
\hyperlink{8591334681358631512}{\texttt{LinearAlgebra.BLAS.trmm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trmm!(side, ul, tA, dA, alpha, A, B)
\end{minted}

Update \texttt{B} as \texttt{alpha*A*B} or one of the other three variants determined by \hyperlink{3128026147631247774}{\texttt{side}} and \hyperlink{15951037910221396131}{\texttt{tA}}. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used. \hyperlink{285101993251198425}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones. Returns the updated \texttt{B}.



\end{adjustwidth}
\hypertarget{1143998968915321685}{} 
\hyperlink{1143998968915321685}{\texttt{LinearAlgebra.BLAS.trmm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trmm(side, ul, tA, dA, alpha, A, B)
\end{minted}

Returns \texttt{alpha*A*B} or one of the other three variants determined by \hyperlink{3128026147631247774}{\texttt{side}} and \hyperlink{15951037910221396131}{\texttt{tA}}. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used. \hyperlink{285101993251198425}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones.



\end{adjustwidth}
\hypertarget{3732597007619096495}{} 
\hyperlink{3732597007619096495}{\texttt{LinearAlgebra.BLAS.trsm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trsm!(side, ul, tA, dA, alpha, A, B)
\end{minted}

Overwrite \texttt{B} with the solution to \texttt{A*X = alpha*B} or one of the other three variants determined by \hyperlink{3128026147631247774}{\texttt{side}} and \hyperlink{15951037910221396131}{\texttt{tA}}. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used. \hyperlink{285101993251198425}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones. Returns the updated \texttt{B}.



\end{adjustwidth}
\hypertarget{5446048787435487351}{} 
\hyperlink{5446048787435487351}{\texttt{LinearAlgebra.BLAS.trsm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trsm(side, ul, tA, dA, alpha, A, B)
\end{minted}

Return the solution to \texttt{A*X = alpha*B} or one of the other three variants determined by determined by \hyperlink{3128026147631247774}{\texttt{side}} and \hyperlink{15951037910221396131}{\texttt{tA}}. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used. \hyperlink{285101993251198425}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones.



\end{adjustwidth}
\hypertarget{12526002304770163470}{} 
\hyperlink{12526002304770163470}{\texttt{LinearAlgebra.BLAS.trmv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trmv!(ul, tA, dA, A, b)
\end{minted}

Return \texttt{op(A)*b}, where \texttt{op} is determined by \hyperlink{15951037910221396131}{\texttt{tA}}. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used. \hyperlink{285101993251198425}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones. The multiplication occurs in-place on \texttt{b}.



\end{adjustwidth}
\hypertarget{17600708624629588635}{} 
\hyperlink{17600708624629588635}{\texttt{LinearAlgebra.BLAS.trmv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trmv(ul, tA, dA, A, b)
\end{minted}

Return \texttt{op(A)*b}, where \texttt{op} is determined by \hyperlink{15951037910221396131}{\texttt{tA}}. Only the \hyperlink{13880289478825450693}{\texttt{ul}} triangle of \texttt{A} is used. \hyperlink{285101993251198425}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones.



\end{adjustwidth}
\hypertarget{10791367515297146957}{} 
\hyperlink{10791367515297146957}{\texttt{LinearAlgebra.BLAS.trsv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trsv!(ul, tA, dA, A, b)
\end{minted}

Overwrite \texttt{b} with the solution to \texttt{A*x = b} or one of the other two variants determined by \hyperlink{15951037910221396131}{\texttt{tA}} and \hyperlink{13880289478825450693}{\texttt{ul}}. \hyperlink{285101993251198425}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones. Return the updated \texttt{b}.



\end{adjustwidth}
\hypertarget{14529375247847983227}{} 
\hyperlink{14529375247847983227}{\texttt{LinearAlgebra.BLAS.trsv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trsv(ul, tA, dA, A, b)
\end{minted}

Return the solution to \texttt{A*x = b} or one of the other two variants determined by \hyperlink{15951037910221396131}{\texttt{tA}} and \hyperlink{13880289478825450693}{\texttt{ul}}. \hyperlink{285101993251198425}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones.



\end{adjustwidth}
\hypertarget{2145233402822007277}{} 
\hyperlink{2145233402822007277}{\texttt{LinearAlgebra.BLAS.set\_num\_threads}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
set_num_threads(n)
\end{minted}

Set the number of threads the BLAS library should use.



\end{adjustwidth}

\hypertarget{12227093091679014988}{}


\section{LAPACK functions}



\texttt{LinearAlgebra.LAPACK} provides wrappers for some of the LAPACK functions for linear algebra.  Those functions that overwrite one of the input arrays have names ending in \texttt{{\textquotesingle}!{\textquotesingle}}.



Usually a function has 4 methods defined, one each for \hyperlink{5027751419500983000}{\texttt{Float64}}, \hyperlink{8101639384272933082}{\texttt{Float32}}, \texttt{ComplexF64} and \texttt{ComplexF32} arrays.



Note that the LAPACK API provided by Julia can and will change in the future. Since this API is not user-facing, there is no commitment to support/deprecate this specific set of functions in future releases.


\hypertarget{5713679047114421298}{} 
\hyperlink{5713679047114421298}{\texttt{LinearAlgebra.LAPACK}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}

Interfaces to LAPACK subroutines.



\end{adjustwidth}
\hypertarget{4626964766607452194}{} 
\hyperlink{4626964766607452194}{\texttt{LinearAlgebra.LAPACK.gbtrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gbtrf!(kl, ku, m, AB) -> (AB, ipiv)
\end{minted}

Compute the LU factorization of a banded matrix \texttt{AB}. \texttt{kl} is the first subdiagonal containing a nonzero band, \texttt{ku} is the last superdiagonal containing one, and \texttt{m} is the first dimension of the matrix \texttt{AB}. Returns the LU factorization in-place and \texttt{ipiv}, the vector of pivots used.



\end{adjustwidth}
\hypertarget{6545699816764482655}{} 
\hyperlink{6545699816764482655}{\texttt{LinearAlgebra.LAPACK.gbtrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gbtrs!(trans, kl, ku, m, AB, ipiv, B)
\end{minted}

Solve the equation \texttt{AB * X = B}. \texttt{trans} determines the orientation of \texttt{AB}. It may be \texttt{N} (no transpose), \texttt{T} (transpose), or \texttt{C} (conjugate transpose). \texttt{kl} is the first subdiagonal containing a nonzero band, \texttt{ku} is the last superdiagonal containing one, and \texttt{m} is the first dimension of the matrix \texttt{AB}. \texttt{ipiv} is the vector of pivots returned from \texttt{gbtrf!}. Returns the vector or matrix \texttt{X}, overwriting \texttt{B} in-place.



\end{adjustwidth}
\hypertarget{16195720455630892558}{} 
\hyperlink{16195720455630892558}{\texttt{LinearAlgebra.LAPACK.gebal!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gebal!(job, A) -> (ilo, ihi, scale)
\end{minted}

Balance the matrix \texttt{A} before computing its eigensystem or Schur factorization. \texttt{job} can be one of \texttt{N} (\texttt{A} will not be permuted or scaled), \texttt{P} (\texttt{A} will only be permuted), \texttt{S} (\texttt{A} will only be scaled), or \texttt{B} (\texttt{A} will be both permuted and scaled). Modifies \texttt{A} in-place and returns \texttt{ilo}, \texttt{ihi}, and \texttt{scale}. If permuting was turned on, \texttt{A[i,j] = 0} if \texttt{j > i} and \texttt{1 < j < ilo} or \texttt{j > ihi}. \texttt{scale} contains information about the scaling/permutations performed.



\end{adjustwidth}
\hypertarget{6051699672892129595}{} 
\hyperlink{6051699672892129595}{\texttt{LinearAlgebra.LAPACK.gebak!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gebak!(job, side, ilo, ihi, scale, V)
\end{minted}

Transform the eigenvectors \texttt{V} of a matrix balanced using \texttt{gebal!} to the unscaled/unpermuted eigenvectors of the original matrix. Modifies \texttt{V} in-place. \texttt{side} can be \texttt{L} (left eigenvectors are transformed) or \texttt{R} (right eigenvectors are transformed).



\end{adjustwidth}
\hypertarget{12871648146516835346}{} 
\hyperlink{12871648146516835346}{\texttt{LinearAlgebra.LAPACK.gebrd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gebrd!(A) -> (A, d, e, tauq, taup)
\end{minted}

Reduce \texttt{A} in-place to bidiagonal form \texttt{A = QBP{\textquotesingle}}. Returns \texttt{A}, containing the bidiagonal matrix \texttt{B}; \texttt{d}, containing the diagonal elements of \texttt{B}; \texttt{e}, containing the off-diagonal elements of \texttt{B}; \texttt{tauq}, containing the elementary reflectors representing \texttt{Q}; and \texttt{taup}, containing the elementary reflectors representing \texttt{P}.



\end{adjustwidth}
\hypertarget{13832119342643409982}{} 
\hyperlink{13832119342643409982}{\texttt{LinearAlgebra.LAPACK.gelqf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gelqf!(A, tau)
\end{minted}

Compute the \texttt{LQ} factorization of \texttt{A}, \texttt{A = LQ}. \texttt{tau} contains scalars which parameterize the elementary reflectors of the factorization. \texttt{tau} must have length greater than or equal to the smallest dimension of \texttt{A}.

Returns \texttt{A} and \texttt{tau} modified in-place.




\begin{lstlisting}
gelqf!(A) -> (A, tau)
\end{lstlisting}

Compute the \texttt{LQ} factorization of \texttt{A}, \texttt{A = LQ}.

Returns \texttt{A}, modified in-place, and \texttt{tau}, which contains scalars which parameterize the elementary reflectors of the factorization.



\end{adjustwidth}
\hypertarget{870700918778332837}{} 
\hyperlink{870700918778332837}{\texttt{LinearAlgebra.LAPACK.geqlf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
geqlf!(A, tau)
\end{minted}

Compute the \texttt{QL} factorization of \texttt{A}, \texttt{A = QL}. \texttt{tau} contains scalars which parameterize the elementary reflectors of the factorization. \texttt{tau} must have length greater than or equal to the smallest dimension of \texttt{A}.

Returns \texttt{A} and \texttt{tau} modified in-place.




\begin{lstlisting}
geqlf!(A) -> (A, tau)
\end{lstlisting}

Compute the \texttt{QL} factorization of \texttt{A}, \texttt{A = QL}.

Returns \texttt{A}, modified in-place, and \texttt{tau}, which contains scalars which parameterize the elementary reflectors of the factorization.



\end{adjustwidth}
\hypertarget{1667844416130160920}{} 
\hyperlink{1667844416130160920}{\texttt{LinearAlgebra.LAPACK.geqrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
geqrf!(A, tau)
\end{minted}

Compute the \texttt{QR} factorization of \texttt{A}, \texttt{A = QR}. \texttt{tau} contains scalars which parameterize the elementary reflectors of the factorization. \texttt{tau} must have length greater than or equal to the smallest dimension of \texttt{A}.

Returns \texttt{A} and \texttt{tau} modified in-place.




\begin{lstlisting}
geqrf!(A) -> (A, tau)
\end{lstlisting}

Compute the \texttt{QR} factorization of \texttt{A}, \texttt{A = QR}.

Returns \texttt{A}, modified in-place, and \texttt{tau}, which contains scalars which parameterize the elementary reflectors of the factorization.



\end{adjustwidth}
\hypertarget{18183103848385216109}{} 
\hyperlink{18183103848385216109}{\texttt{LinearAlgebra.LAPACK.geqp3!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
geqp3!(A, jpvt, tau)
\end{minted}

Compute the pivoted \texttt{QR} factorization of \texttt{A}, \texttt{AP = QR} using BLAS level 3. \texttt{P} is a pivoting matrix, represented by \texttt{jpvt}. \texttt{tau} stores the elementary reflectors. \texttt{jpvt} must have length length greater than or equal to \texttt{n} if \texttt{A} is an \texttt{(m x n)} matrix. \texttt{tau} must have length greater than or equal to the smallest dimension of \texttt{A}.

\texttt{A}, \texttt{jpvt}, and \texttt{tau} are modified in-place.




\begin{lstlisting}
geqp3!(A, jpvt) -> (A, jpvt, tau)
\end{lstlisting}

Compute the pivoted \texttt{QR} factorization of \texttt{A}, \texttt{AP = QR} using BLAS level 3. \texttt{P} is a pivoting matrix, represented by \texttt{jpvt}. \texttt{jpvt} must have length greater than or equal to \texttt{n} if \texttt{A} is an \texttt{(m x n)} matrix.

Returns \texttt{A} and \texttt{jpvt}, modified in-place, and \texttt{tau}, which stores the elementary reflectors.




\begin{lstlisting}
geqp3!(A) -> (A, jpvt, tau)
\end{lstlisting}

Compute the pivoted \texttt{QR} factorization of \texttt{A}, \texttt{AP = QR} using BLAS level 3.

Returns \texttt{A}, modified in-place, \texttt{jpvt}, which represents the pivoting matrix \texttt{P}, and \texttt{tau}, which stores the elementary reflectors.



\end{adjustwidth}
\hypertarget{1345086231036394133}{} 
\hyperlink{1345086231036394133}{\texttt{LinearAlgebra.LAPACK.gerqf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gerqf!(A, tau)
\end{minted}

Compute the \texttt{RQ} factorization of \texttt{A}, \texttt{A = RQ}. \texttt{tau} contains scalars which parameterize the elementary reflectors of the factorization. \texttt{tau} must have length greater than or equal to the smallest dimension of \texttt{A}.

Returns \texttt{A} and \texttt{tau} modified in-place.




\begin{lstlisting}
gerqf!(A) -> (A, tau)
\end{lstlisting}

Compute the \texttt{RQ} factorization of \texttt{A}, \texttt{A = RQ}.

Returns \texttt{A}, modified in-place, and \texttt{tau}, which contains scalars which parameterize the elementary reflectors of the factorization.



\end{adjustwidth}
\hypertarget{6324071823423584289}{} 
\hyperlink{6324071823423584289}{\texttt{LinearAlgebra.LAPACK.geqrt!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
geqrt!(A, T)
\end{minted}

Compute the blocked \texttt{QR} factorization of \texttt{A}, \texttt{A = QR}. \texttt{T} contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization. The first dimension of \texttt{T} sets the block size and it must be between 1 and \texttt{n}. The second dimension of \texttt{T} must equal the smallest dimension of \texttt{A}.

Returns \texttt{A} and \texttt{T} modified in-place.




\begin{lstlisting}
geqrt!(A, nb) -> (A, T)
\end{lstlisting}

Compute the blocked \texttt{QR} factorization of \texttt{A}, \texttt{A = QR}. \texttt{nb} sets the block size and it must be between 1 and \texttt{n}, the second dimension of \texttt{A}.

Returns \texttt{A}, modified in-place, and \texttt{T}, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.



\end{adjustwidth}
\hypertarget{12471188723051727334}{} 
\hyperlink{12471188723051727334}{\texttt{LinearAlgebra.LAPACK.geqrt3!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
geqrt3!(A, T)
\end{minted}

Recursively computes the blocked \texttt{QR} factorization of \texttt{A}, \texttt{A = QR}. \texttt{T} contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.  The first dimension of \texttt{T} sets the block size and it must be between 1 and \texttt{n}. The second dimension of \texttt{T} must equal the smallest dimension of \texttt{A}.

Returns \texttt{A} and \texttt{T} modified in-place.




\begin{lstlisting}
geqrt3!(A) -> (A, T)
\end{lstlisting}

Recursively computes the blocked \texttt{QR} factorization of \texttt{A}, \texttt{A = QR}.

Returns \texttt{A}, modified in-place, and \texttt{T}, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.



\end{adjustwidth}
\hypertarget{2351778938398249720}{} 
\hyperlink{2351778938398249720}{\texttt{LinearAlgebra.LAPACK.getrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getrf!(A) -> (A, ipiv, info)
\end{minted}

Compute the pivoted \texttt{LU} factorization of \texttt{A}, \texttt{A = LU}.

Returns \texttt{A}, modified in-place, \texttt{ipiv}, the pivoting information, and an \texttt{info} code which indicates success (\texttt{info = 0}), a singular value in \texttt{U} (\texttt{info = i}, in which case \texttt{U[i,i]} is singular), or an error code (\texttt{info < 0}).



\end{adjustwidth}
\hypertarget{8099284094733410089}{} 
\hyperlink{8099284094733410089}{\texttt{LinearAlgebra.LAPACK.tzrzf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tzrzf!(A) -> (A, tau)
\end{minted}

Transforms the upper trapezoidal matrix \texttt{A} to upper triangular form in-place. Returns \texttt{A} and \texttt{tau}, the scalar parameters for the elementary reflectors of the transformation.



\end{adjustwidth}
\hypertarget{15550486828362807519}{} 
\hyperlink{15550486828362807519}{\texttt{LinearAlgebra.LAPACK.ormrz!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ormrz!(side, trans, A, tau, C)
\end{minted}

Multiplies the matrix \texttt{C} by \texttt{Q} from the transformation supplied by \texttt{tzrzf!}. Depending on \texttt{side} or \texttt{trans} the multiplication can be left-sided (\texttt{side = L, Q*C}) or right-sided (\texttt{side = R, C*Q}) and \texttt{Q} can be unmodified (\texttt{trans = N}), transposed (\texttt{trans = T}), or conjugate transposed (\texttt{trans = C}). Returns matrix \texttt{C} which is modified in-place with the result of the multiplication.



\end{adjustwidth}
\hypertarget{18299455515085793306}{} 
\hyperlink{18299455515085793306}{\texttt{LinearAlgebra.LAPACK.gels!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gels!(trans, A, B) -> (F, B, ssr)
\end{minted}

Solves the linear equation \texttt{A * X = B}, \texttt{transpose(A) * X = B}, or \texttt{adjoint(A) * X = B} using a QR or LQ factorization. Modifies the matrix/vector \texttt{B} in place with the solution. \texttt{A} is overwritten with its \texttt{QR} or \texttt{LQ} factorization. \texttt{trans} may be one of \texttt{N} (no modification), \texttt{T} (transpose), or \texttt{C} (conjugate transpose). \texttt{gels!} searches for the minimum norm/least squares solution. \texttt{A} may be under or over determined. The solution is returned in \texttt{B}.



\end{adjustwidth}
\hypertarget{1148095264829123239}{} 
\hyperlink{1148095264829123239}{\texttt{LinearAlgebra.LAPACK.gesv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gesv!(A, B) -> (B, A, ipiv)
\end{minted}

Solves the linear equation \texttt{A * X = B} where \texttt{A} is a square matrix using the \texttt{LU} factorization of \texttt{A}. \texttt{A} is overwritten with its \texttt{LU} factorization and \texttt{B} is overwritten with the solution \texttt{X}. \texttt{ipiv} contains the pivoting information for the \texttt{LU} factorization of \texttt{A}.



\end{adjustwidth}
\hypertarget{16091201483800894861}{} 
\hyperlink{16091201483800894861}{\texttt{LinearAlgebra.LAPACK.getrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getrs!(trans, A, ipiv, B)
\end{minted}

Solves the linear equation \texttt{A * X = B}, \texttt{transpose(A) * X = B}, or \texttt{adjoint(A) * X = B} for square \texttt{A}. Modifies the matrix/vector \texttt{B} in place with the solution. \texttt{A} is the \texttt{LU} factorization from \texttt{getrf!}, with \texttt{ipiv} the pivoting information. \texttt{trans} may be one of \texttt{N} (no modification), \texttt{T} (transpose), or \texttt{C} (conjugate transpose).



\end{adjustwidth}
\hypertarget{14980283213207275035}{} 
\hyperlink{14980283213207275035}{\texttt{LinearAlgebra.LAPACK.getri!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getri!(A, ipiv)
\end{minted}

Computes the inverse of \texttt{A}, using its \texttt{LU} factorization found by \texttt{getrf!}. \texttt{ipiv} is the pivot information output and \texttt{A} contains the \texttt{LU} factorization of \texttt{getrf!}. \texttt{A} is overwritten with its inverse.



\end{adjustwidth}
\hypertarget{11990298428229663507}{} 
\hyperlink{11990298428229663507}{\texttt{LinearAlgebra.LAPACK.gesvx!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gesvx!(fact, trans, A, AF, ipiv, equed, R, C, B) -> (X, equed, R, C, B, rcond, ferr, berr, work)
\end{minted}

Solves the linear equation \texttt{A * X = B} (\texttt{trans = N}), \texttt{transpose(A) * X = B} (\texttt{trans = T}), or \texttt{adjoint(A) * X = B} (\texttt{trans = C}) using the \texttt{LU} factorization of \texttt{A}. \texttt{fact} may be \texttt{E}, in which case \texttt{A} will be equilibrated and copied to \texttt{AF}; \texttt{F}, in which case \texttt{AF} and \texttt{ipiv} from a previous \texttt{LU} factorization are inputs; or \texttt{N}, in which case \texttt{A} will be copied to \texttt{AF} and then factored. If \texttt{fact = F}, \texttt{equed} may be \texttt{N}, meaning \texttt{A} has not been equilibrated; \texttt{R}, meaning \texttt{A} was multiplied by \texttt{Diagonal(R)} from the left; \texttt{C}, meaning \texttt{A} was multiplied by \texttt{Diagonal(C)} from the right; or \texttt{B}, meaning \texttt{A} was multiplied by \texttt{Diagonal(R)} from the left and \texttt{Diagonal(C)} from the right. If \texttt{fact = F} and \texttt{equed = R} or \texttt{B} the elements of \texttt{R} must all be positive. If \texttt{fact = F} and \texttt{equed = C} or \texttt{B} the elements of \texttt{C} must all be positive.

Returns the solution \texttt{X}; \texttt{equed}, which is an output if \texttt{fact} is not \texttt{N}, and describes the equilibration that was performed; \texttt{R}, the row equilibration diagonal; \texttt{C}, the column equilibration diagonal; \texttt{B}, which may be overwritten with its equilibrated form \texttt{Diagonal(R)*B} (if \texttt{trans = N} and \texttt{equed = R,B}) or \texttt{Diagonal(C)*B} (if \texttt{trans = T,C} and \texttt{equed = C,B}); \texttt{rcond}, the reciprocal condition number of \texttt{A} after equilbrating; \texttt{ferr}, the forward error bound for each solution vector in \texttt{X}; \texttt{berr}, the forward error bound for each solution vector in \texttt{X}; and \texttt{work}, the reciprocal pivot growth factor.




\begin{lstlisting}
gesvx!(A, B)
\end{lstlisting}

The no-equilibration, no-transpose simplification of \texttt{gesvx!}.



\end{adjustwidth}
\hypertarget{9350383558985209547}{} 
\hyperlink{9350383558985209547}{\texttt{LinearAlgebra.LAPACK.gelsd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gelsd!(A, B, rcond) -> (B, rnk)
\end{minted}

Computes the least norm solution of \texttt{A * X = B} by finding the \texttt{SVD} factorization of \texttt{A}, then dividing-and-conquering the problem. \texttt{B} is overwritten with the solution \texttt{X}. Singular values below \texttt{rcond} will be treated as zero. Returns the solution in \texttt{B} and the effective rank of \texttt{A} in \texttt{rnk}.



\end{adjustwidth}
\hypertarget{4643805579678817866}{} 
\hyperlink{4643805579678817866}{\texttt{LinearAlgebra.LAPACK.gelsy!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gelsy!(A, B, rcond) -> (B, rnk)
\end{minted}

Computes the least norm solution of \texttt{A * X = B} by finding the full \texttt{QR} factorization of \texttt{A}, then dividing-and-conquering the problem. \texttt{B} is overwritten with the solution \texttt{X}. Singular values below \texttt{rcond} will be treated as zero. Returns the solution in \texttt{B} and the effective rank of \texttt{A} in \texttt{rnk}.



\end{adjustwidth}
\hypertarget{6779153008628150661}{} 
\hyperlink{6779153008628150661}{\texttt{LinearAlgebra.LAPACK.gglse!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gglse!(A, c, B, d) -> (X,res)
\end{minted}

Solves the equation \texttt{A * x = c} where \texttt{x} is subject to the equality constraint \texttt{B * x = d}. Uses the formula \texttt{||c - A*x||{\textasciicircum}2 = 0} to solve. Returns \texttt{X} and the residual sum-of-squares.



\end{adjustwidth}
\hypertarget{6944763016389470144}{} 
\hyperlink{6944763016389470144}{\texttt{LinearAlgebra.LAPACK.geev!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
geev!(jobvl, jobvr, A) -> (W, VL, VR)
\end{minted}

Finds the eigensystem of \texttt{A}. If \texttt{jobvl = N}, the left eigenvectors of \texttt{A} aren{\textquotesingle}t computed. If \texttt{jobvr = N}, the right eigenvectors of \texttt{A} aren{\textquotesingle}t computed. If \texttt{jobvl = V} or \texttt{jobvr = V}, the corresponding eigenvectors are computed. Returns the eigenvalues in \texttt{W}, the right eigenvectors in \texttt{VR}, and the left eigenvectors in \texttt{VL}.



\end{adjustwidth}
\hypertarget{15765350085042341790}{} 
\hyperlink{15765350085042341790}{\texttt{LinearAlgebra.LAPACK.gesdd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gesdd!(job, A) -> (U, S, VT)
\end{minted}

Finds the singular value decomposition of \texttt{A}, \texttt{A = U * S * V{\textquotesingle}}, using a divide and conquer approach. If \texttt{job = A}, all the columns of \texttt{U} and the rows of \texttt{V{\textquotesingle}} are computed. If \texttt{job = N}, no columns of \texttt{U} or rows of \texttt{V{\textquotesingle}} are computed. If \texttt{job = O}, \texttt{A} is overwritten with the columns of (thin) \texttt{U} and the rows of (thin) \texttt{V{\textquotesingle}}. If \texttt{job = S}, the columns of (thin) \texttt{U} and the rows of (thin) \texttt{V{\textquotesingle}} are computed and returned separately.



\end{adjustwidth}
\hypertarget{12815780161722855374}{} 
\hyperlink{12815780161722855374}{\texttt{LinearAlgebra.LAPACK.gesvd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gesvd!(jobu, jobvt, A) -> (U, S, VT)
\end{minted}

Finds the singular value decomposition of \texttt{A}, \texttt{A = U * S * V{\textquotesingle}}. If \texttt{jobu = A}, all the columns of \texttt{U} are computed. If \texttt{jobvt = A} all the rows of \texttt{V{\textquotesingle}} are computed. If \texttt{jobu = N}, no columns of \texttt{U} are computed. If \texttt{jobvt = N} no rows of \texttt{V{\textquotesingle}} are computed. If \texttt{jobu = O}, \texttt{A} is overwritten with the columns of (thin) \texttt{U}. If \texttt{jobvt = O}, \texttt{A} is overwritten with the rows of (thin) \texttt{V{\textquotesingle}}. If \texttt{jobu = S}, the columns of (thin) \texttt{U} are computed and returned separately. If \texttt{jobvt = S} the rows of (thin) \texttt{V{\textquotesingle}} are computed and returned separately. \texttt{jobu} and \texttt{jobvt} can{\textquotesingle}t both be \texttt{O}.

Returns \texttt{U}, \texttt{S}, and \texttt{Vt}, where \texttt{S} are the singular values of \texttt{A}.



\end{adjustwidth}
\hypertarget{1835214761811297196}{} 
\hyperlink{1835214761811297196}{\texttt{LinearAlgebra.LAPACK.ggsvd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ggsvd!(jobu, jobv, jobq, A, B) -> (U, V, Q, alpha, beta, k, l, R)
\end{minted}

Finds the generalized singular value decomposition of \texttt{A} and \texttt{B}, \texttt{U{\textquotesingle}*A*Q = D1*R} and \texttt{V{\textquotesingle}*B*Q = D2*R}. \texttt{D1} has \texttt{alpha} on its diagonal and \texttt{D2} has \texttt{beta} on its diagonal. If \texttt{jobu = U}, the orthogonal/unitary matrix \texttt{U} is computed. If \texttt{jobv = V} the orthogonal/unitary matrix \texttt{V} is computed. If \texttt{jobq = Q}, the orthogonal/unitary matrix \texttt{Q} is computed. If \texttt{jobu}, \texttt{jobv} or \texttt{jobq} is \texttt{N}, that matrix is not computed. This function is only available in LAPACK versions prior to 3.6.0.



\end{adjustwidth}
\hypertarget{14749391167207110611}{} 
\hyperlink{14749391167207110611}{\texttt{LinearAlgebra.LAPACK.ggsvd3!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ggsvd3!(jobu, jobv, jobq, A, B) -> (U, V, Q, alpha, beta, k, l, R)
\end{minted}

Finds the generalized singular value decomposition of \texttt{A} and \texttt{B}, \texttt{U{\textquotesingle}*A*Q = D1*R} and \texttt{V{\textquotesingle}*B*Q = D2*R}. \texttt{D1} has \texttt{alpha} on its diagonal and \texttt{D2} has \texttt{beta} on its diagonal. If \texttt{jobu = U}, the orthogonal/unitary matrix \texttt{U} is computed. If \texttt{jobv = V} the orthogonal/unitary matrix \texttt{V} is computed. If \texttt{jobq = Q}, the orthogonal/unitary matrix \texttt{Q} is computed. If \texttt{jobu}, \texttt{jobv}, or \texttt{jobq} is \texttt{N}, that matrix is not computed. This function requires LAPACK 3.6.0.



\end{adjustwidth}
\hypertarget{13160568642977439323}{} 
\hyperlink{13160568642977439323}{\texttt{LinearAlgebra.LAPACK.geevx!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
geevx!(balanc, jobvl, jobvr, sense, A) -> (A, w, VL, VR, ilo, ihi, scale, abnrm, rconde, rcondv)
\end{minted}

Finds the eigensystem of \texttt{A} with matrix balancing. If \texttt{jobvl = N}, the left eigenvectors of \texttt{A} aren{\textquotesingle}t computed. If \texttt{jobvr = N}, the right eigenvectors of \texttt{A} aren{\textquotesingle}t computed. If \texttt{jobvl = V} or \texttt{jobvr = V}, the corresponding eigenvectors are computed. If \texttt{balanc = N}, no balancing is performed. If \texttt{balanc = P}, \texttt{A} is permuted but not scaled. If \texttt{balanc = S}, \texttt{A} is scaled but not permuted. If \texttt{balanc = B}, \texttt{A} is permuted and scaled. If \texttt{sense = N}, no reciprocal condition numbers are computed. If \texttt{sense = E}, reciprocal condition numbers are computed for the eigenvalues only. If \texttt{sense = V}, reciprocal condition numbers are computed for the right eigenvectors only. If \texttt{sense = B}, reciprocal condition numbers are computed for the right eigenvectors and the eigenvectors. If \texttt{sense = E,B}, the right and left eigenvectors must be computed.



\end{adjustwidth}
\hypertarget{11158917129247885932}{} 
\hyperlink{11158917129247885932}{\texttt{LinearAlgebra.LAPACK.ggev!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ggev!(jobvl, jobvr, A, B) -> (alpha, beta, vl, vr)
\end{minted}

Finds the generalized eigendecomposition of \texttt{A} and \texttt{B}. If \texttt{jobvl = N}, the left eigenvectors aren{\textquotesingle}t computed. If \texttt{jobvr = N}, the right eigenvectors aren{\textquotesingle}t computed. If \texttt{jobvl = V} or \texttt{jobvr = V}, the corresponding eigenvectors are computed.



\end{adjustwidth}
\hypertarget{445174240052873549}{} 
\hyperlink{445174240052873549}{\texttt{LinearAlgebra.LAPACK.gtsv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gtsv!(dl, d, du, B)
\end{minted}

Solves the equation \texttt{A * X = B} where \texttt{A} is a tridiagonal matrix with \texttt{dl} on the subdiagonal, \texttt{d} on the diagonal, and \texttt{du} on the superdiagonal.

Overwrites \texttt{B} with the solution \texttt{X} and returns it.



\end{adjustwidth}
\hypertarget{9597724514453362317}{} 
\hyperlink{9597724514453362317}{\texttt{LinearAlgebra.LAPACK.gttrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gttrf!(dl, d, du) -> (dl, d, du, du2, ipiv)
\end{minted}

Finds the \texttt{LU} factorization of a tridiagonal matrix with \texttt{dl} on the subdiagonal, \texttt{d} on the diagonal, and \texttt{du} on the superdiagonal.

Modifies \texttt{dl}, \texttt{d}, and \texttt{du} in-place and returns them and the second superdiagonal \texttt{du2} and the pivoting vector \texttt{ipiv}.



\end{adjustwidth}
\hypertarget{3087963688650638106}{} 
\hyperlink{3087963688650638106}{\texttt{LinearAlgebra.LAPACK.gttrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gttrs!(trans, dl, d, du, du2, ipiv, B)
\end{minted}

Solves the equation \texttt{A * X = B} (\texttt{trans = N}), \texttt{transpose(A) * X = B} (\texttt{trans = T}), or \texttt{adjoint(A) * X = B} (\texttt{trans = C}) using the \texttt{LU} factorization computed by \texttt{gttrf!}. \texttt{B} is overwritten with the solution \texttt{X}.



\end{adjustwidth}
\hypertarget{1878598872812530666}{} 
\hyperlink{1878598872812530666}{\texttt{LinearAlgebra.LAPACK.orglq!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
orglq!(A, tau, k = length(tau))
\end{minted}

Explicitly finds the matrix \texttt{Q} of a \texttt{LQ} factorization after calling \texttt{gelqf!} on \texttt{A}. Uses the output of \texttt{gelqf!}. \texttt{A} is overwritten by \texttt{Q}.



\end{adjustwidth}
\hypertarget{17543646888056798280}{} 
\hyperlink{17543646888056798280}{\texttt{LinearAlgebra.LAPACK.orgqr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
orgqr!(A, tau, k = length(tau))
\end{minted}

Explicitly finds the matrix \texttt{Q} of a \texttt{QR} factorization after calling \texttt{geqrf!} on \texttt{A}. Uses the output of \texttt{geqrf!}. \texttt{A} is overwritten by \texttt{Q}.



\end{adjustwidth}
\hypertarget{15842803237247761842}{} 
\hyperlink{15842803237247761842}{\texttt{LinearAlgebra.LAPACK.orgql!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
orgql!(A, tau, k = length(tau))
\end{minted}

Explicitly finds the matrix \texttt{Q} of a \texttt{QL} factorization after calling \texttt{geqlf!} on \texttt{A}. Uses the output of \texttt{geqlf!}. \texttt{A} is overwritten by \texttt{Q}.



\end{adjustwidth}
\hypertarget{9300570426687705008}{} 
\hyperlink{9300570426687705008}{\texttt{LinearAlgebra.LAPACK.orgrq!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
orgrq!(A, tau, k = length(tau))
\end{minted}

Explicitly finds the matrix \texttt{Q} of a \texttt{RQ} factorization after calling \texttt{gerqf!} on \texttt{A}. Uses the output of \texttt{gerqf!}. \texttt{A} is overwritten by \texttt{Q}.



\end{adjustwidth}
\hypertarget{6791415432360539771}{} 
\hyperlink{6791415432360539771}{\texttt{LinearAlgebra.LAPACK.ormlq!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ormlq!(side, trans, A, tau, C)
\end{minted}

Computes \texttt{Q * C} (\texttt{trans = N}), \texttt{transpose(Q) * C} (\texttt{trans = T}), \texttt{adjoint(Q) * C} (\texttt{trans = C}) for \texttt{side = L} or the equivalent right-sided multiplication for \texttt{side = R} using \texttt{Q} from a \texttt{LQ} factorization of \texttt{A} computed using \texttt{gelqf!}. \texttt{C} is overwritten.



\end{adjustwidth}
\hypertarget{4642443581739897648}{} 
\hyperlink{4642443581739897648}{\texttt{LinearAlgebra.LAPACK.ormqr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ormqr!(side, trans, A, tau, C)
\end{minted}

Computes \texttt{Q * C} (\texttt{trans = N}), \texttt{transpose(Q) * C} (\texttt{trans = T}), \texttt{adjoint(Q) * C} (\texttt{trans = C}) for \texttt{side = L} or the equivalent right-sided multiplication for \texttt{side = R} using \texttt{Q} from a \texttt{QR} factorization of \texttt{A} computed using \texttt{geqrf!}. \texttt{C} is overwritten.



\end{adjustwidth}
\hypertarget{8769001276299575898}{} 
\hyperlink{8769001276299575898}{\texttt{LinearAlgebra.LAPACK.ormql!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ormql!(side, trans, A, tau, C)
\end{minted}

Computes \texttt{Q * C} (\texttt{trans = N}), \texttt{transpose(Q) * C} (\texttt{trans = T}), \texttt{adjoint(Q) * C} (\texttt{trans = C}) for \texttt{side = L} or the equivalent right-sided multiplication for \texttt{side = R} using \texttt{Q} from a \texttt{QL} factorization of \texttt{A} computed using \texttt{geqlf!}. \texttt{C} is overwritten.



\end{adjustwidth}
\hypertarget{5502331798377291988}{} 
\hyperlink{5502331798377291988}{\texttt{LinearAlgebra.LAPACK.ormrq!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ormrq!(side, trans, A, tau, C)
\end{minted}

Computes \texttt{Q * C} (\texttt{trans = N}), \texttt{transpose(Q) * C} (\texttt{trans = T}), \texttt{adjoint(Q) * C} (\texttt{trans = C}) for \texttt{side = L} or the equivalent right-sided multiplication for \texttt{side = R} using \texttt{Q} from a \texttt{RQ} factorization of \texttt{A} computed using \texttt{gerqf!}. \texttt{C} is overwritten.



\end{adjustwidth}
\hypertarget{15151573161204836324}{} 
\hyperlink{15151573161204836324}{\texttt{LinearAlgebra.LAPACK.gemqrt!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gemqrt!(side, trans, V, T, C)
\end{minted}

Computes \texttt{Q * C} (\texttt{trans = N}), \texttt{transpose(Q) * C} (\texttt{trans = T}), \texttt{adjoint(Q) * C} (\texttt{trans = C}) for \texttt{side = L} or the equivalent right-sided multiplication for \texttt{side = R} using \texttt{Q} from a \texttt{QR} factorization of \texttt{A} computed using \texttt{geqrt!}. \texttt{C} is overwritten.



\end{adjustwidth}
\hypertarget{7595784839671568962}{} 
\hyperlink{7595784839671568962}{\texttt{LinearAlgebra.LAPACK.posv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
posv!(uplo, A, B) -> (A, B)
\end{minted}

Finds the solution to \texttt{A * X = B} where \texttt{A} is a symmetric or Hermitian positive definite matrix. If \texttt{uplo = U} the upper Cholesky decomposition of \texttt{A} is computed. If \texttt{uplo = L} the lower Cholesky decomposition of \texttt{A} is computed. \texttt{A} is overwritten by its Cholesky decomposition. \texttt{B} is overwritten with the solution \texttt{X}.



\end{adjustwidth}
\hypertarget{15056431266921985441}{} 
\hyperlink{15056431266921985441}{\texttt{LinearAlgebra.LAPACK.potrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
potrf!(uplo, A)
\end{minted}

Computes the Cholesky (upper if \texttt{uplo = U}, lower if \texttt{uplo = L}) decomposition of positive-definite matrix \texttt{A}. \texttt{A} is overwritten and returned with an info code.



\end{adjustwidth}
\hypertarget{17784788688709608363}{} 
\hyperlink{17784788688709608363}{\texttt{LinearAlgebra.LAPACK.potri!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
potri!(uplo, A)
\end{minted}

Computes the inverse of positive-definite matrix \texttt{A} after calling \texttt{potrf!} to find its (upper if \texttt{uplo = U}, lower if \texttt{uplo = L}) Cholesky decomposition.

\texttt{A} is overwritten by its inverse and returned.



\end{adjustwidth}
\hypertarget{13026081165818770600}{} 
\hyperlink{13026081165818770600}{\texttt{LinearAlgebra.LAPACK.potrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
potrs!(uplo, A, B)
\end{minted}

Finds the solution to \texttt{A * X = B} where \texttt{A} is a symmetric or Hermitian positive definite matrix whose Cholesky decomposition was computed by \texttt{potrf!}. If \texttt{uplo = U} the upper Cholesky decomposition of \texttt{A} was computed. If \texttt{uplo = L} the lower Cholesky decomposition of \texttt{A} was computed. \texttt{B} is overwritten with the solution \texttt{X}.



\end{adjustwidth}
\hypertarget{15908768904043509489}{} 
\hyperlink{15908768904043509489}{\texttt{LinearAlgebra.LAPACK.pstrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pstrf!(uplo, A, tol) -> (A, piv, rank, info)
\end{minted}

Computes the (upper if \texttt{uplo = U}, lower if \texttt{uplo = L}) pivoted Cholesky decomposition of positive-definite matrix \texttt{A} with a user-set tolerance \texttt{tol}. \texttt{A} is overwritten by its Cholesky decomposition.

Returns \texttt{A}, the pivots \texttt{piv}, the rank of \texttt{A}, and an \texttt{info} code. If \texttt{info = 0}, the factorization succeeded. If \texttt{info = i > 0}, then \texttt{A} is indefinite or rank-deficient.



\end{adjustwidth}
\hypertarget{10214325419469953635}{} 
\hyperlink{10214325419469953635}{\texttt{LinearAlgebra.LAPACK.ptsv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ptsv!(D, E, B)
\end{minted}

Solves \texttt{A * X = B} for positive-definite tridiagonal \texttt{A}. \texttt{D} is the diagonal of \texttt{A} and \texttt{E} is the off-diagonal. \texttt{B} is overwritten with the solution \texttt{X} and returned.



\end{adjustwidth}
\hypertarget{9537322497705664212}{} 
\hyperlink{9537322497705664212}{\texttt{LinearAlgebra.LAPACK.pttrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pttrf!(D, E)
\end{minted}

Computes the LDLt factorization of a positive-definite tridiagonal matrix with \texttt{D} as diagonal and \texttt{E} as off-diagonal. \texttt{D} and \texttt{E} are overwritten and returned.



\end{adjustwidth}
\hypertarget{17187703179587619260}{} 
\hyperlink{17187703179587619260}{\texttt{LinearAlgebra.LAPACK.pttrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
pttrs!(D, E, B)
\end{minted}

Solves \texttt{A * X = B} for positive-definite tridiagonal \texttt{A} with diagonal \texttt{D} and off-diagonal \texttt{E} after computing \texttt{A}{\textquotesingle}s LDLt factorization using \texttt{pttrf!}. \texttt{B} is overwritten with the solution \texttt{X}.



\end{adjustwidth}
\hypertarget{16492831209199043329}{} 
\hyperlink{16492831209199043329}{\texttt{LinearAlgebra.LAPACK.trtri!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trtri!(uplo, diag, A)
\end{minted}

Finds the inverse of (upper if \texttt{uplo = U}, lower if \texttt{uplo = L}) triangular matrix \texttt{A}. If \texttt{diag = N}, \texttt{A} has non-unit diagonal elements. If \texttt{diag = U}, all diagonal elements of \texttt{A} are one. \texttt{A} is overwritten with its inverse.



\end{adjustwidth}
\hypertarget{1291729511408073349}{} 
\hyperlink{1291729511408073349}{\texttt{LinearAlgebra.LAPACK.trtrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trtrs!(uplo, trans, diag, A, B)
\end{minted}

Solves \texttt{A * X = B} (\texttt{trans = N}), \texttt{transpose(A) * X = B} (\texttt{trans = T}), or \texttt{adjoint(A) * X = B} (\texttt{trans = C}) for (upper if \texttt{uplo = U}, lower if \texttt{uplo = L}) triangular matrix \texttt{A}. If \texttt{diag = N}, \texttt{A} has non-unit diagonal elements. If \texttt{diag = U}, all diagonal elements of \texttt{A} are one. \texttt{B} is overwritten with the solution \texttt{X}.



\end{adjustwidth}
\hypertarget{9926413427788620088}{} 
\hyperlink{9926413427788620088}{\texttt{LinearAlgebra.LAPACK.trcon!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trcon!(norm, uplo, diag, A)
\end{minted}

Finds the reciprocal condition number of (upper if \texttt{uplo = U}, lower if \texttt{uplo = L}) triangular matrix \texttt{A}. If \texttt{diag = N}, \texttt{A} has non-unit diagonal elements. If \texttt{diag = U}, all diagonal elements of \texttt{A} are one. If \texttt{norm = I}, the condition number is found in the infinity norm. If \texttt{norm = O} or \texttt{1}, the condition number is found in the one norm.



\end{adjustwidth}
\hypertarget{7491620034849793338}{} 
\hyperlink{7491620034849793338}{\texttt{LinearAlgebra.LAPACK.trevc!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trevc!(side, howmny, select, T, VL = similar(T), VR = similar(T))
\end{minted}

Finds the eigensystem of an upper triangular matrix \texttt{T}. If \texttt{side = R}, the right eigenvectors are computed. If \texttt{side = L}, the left eigenvectors are computed. If \texttt{side = B}, both sets are computed. If \texttt{howmny = A}, all eigenvectors are found. If \texttt{howmny = B}, all eigenvectors are found and backtransformed using \texttt{VL} and \texttt{VR}. If \texttt{howmny = S}, only the eigenvectors corresponding to the values in \texttt{select} are computed.



\end{adjustwidth}
\hypertarget{17047065310014133867}{} 
\hyperlink{17047065310014133867}{\texttt{LinearAlgebra.LAPACK.trrfs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trrfs!(uplo, trans, diag, A, B, X, Ferr, Berr) -> (Ferr, Berr)
\end{minted}

Estimates the error in the solution to \texttt{A * X = B} (\texttt{trans = N}), \texttt{transpose(A) * X = B} (\texttt{trans = T}), \texttt{adjoint(A) * X = B} (\texttt{trans = C}) for \texttt{side = L}, or the equivalent equations a right-handed \texttt{side = R} \texttt{X * A} after computing \texttt{X} using \texttt{trtrs!}. If \texttt{uplo = U}, \texttt{A} is upper triangular. If \texttt{uplo = L}, \texttt{A} is lower triangular. If \texttt{diag = N}, \texttt{A} has non-unit diagonal elements. If \texttt{diag = U}, all diagonal elements of \texttt{A} are one. \texttt{Ferr} and \texttt{Berr} are optional inputs. \texttt{Ferr} is the forward error and \texttt{Berr} is the backward error, each component-wise.



\end{adjustwidth}
\hypertarget{14670728896781161925}{} 
\hyperlink{14670728896781161925}{\texttt{LinearAlgebra.LAPACK.stev!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stev!(job, dv, ev) -> (dv, Zmat)
\end{minted}

Computes the eigensystem for a symmetric tridiagonal matrix with \texttt{dv} as diagonal and \texttt{ev} as off-diagonal. If \texttt{job = N} only the eigenvalues are found and returned in \texttt{dv}. If \texttt{job = V} then the eigenvectors are also found and returned in \texttt{Zmat}.



\end{adjustwidth}
\hypertarget{10865649637100518709}{} 
\hyperlink{10865649637100518709}{\texttt{LinearAlgebra.LAPACK.stebz!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stebz!(range, order, vl, vu, il, iu, abstol, dv, ev) -> (dv, iblock, isplit)
\end{minted}

Computes the eigenvalues for a symmetric tridiagonal matrix with \texttt{dv} as diagonal and \texttt{ev} as off-diagonal. If \texttt{range = A}, all the eigenvalues are found. If \texttt{range = V}, the eigenvalues in the half-open interval \texttt{(vl, vu]} are found. If \texttt{range = I}, the eigenvalues with indices between \texttt{il} and \texttt{iu} are found. If \texttt{order = B}, eigvalues are ordered within a block. If \texttt{order = E}, they are ordered across all the blocks. \texttt{abstol} can be set as a tolerance for convergence.



\end{adjustwidth}
\hypertarget{18007684687736525555}{} 
\hyperlink{18007684687736525555}{\texttt{LinearAlgebra.LAPACK.stegr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stegr!(jobz, range, dv, ev, vl, vu, il, iu) -> (w, Z)
\end{minted}

Computes the eigenvalues (\texttt{jobz = N}) or eigenvalues and eigenvectors (\texttt{jobz = V}) for a symmetric tridiagonal matrix with \texttt{dv} as diagonal and \texttt{ev} as off-diagonal. If \texttt{range = A}, all the eigenvalues are found. If \texttt{range = V}, the eigenvalues in the half-open interval \texttt{(vl, vu]} are found. If \texttt{range = I}, the eigenvalues with indices between \texttt{il} and \texttt{iu} are found. The eigenvalues are returned in \texttt{w} and the eigenvectors in \texttt{Z}.



\end{adjustwidth}
\hypertarget{4475992932708638755}{} 
\hyperlink{4475992932708638755}{\texttt{LinearAlgebra.LAPACK.stein!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stein!(dv, ev_in, w_in, iblock_in, isplit_in)
\end{minted}

Computes the eigenvectors for a symmetric tridiagonal matrix with \texttt{dv} as diagonal and \texttt{ev\_in} as off-diagonal. \texttt{w\_in} specifies the input eigenvalues for which to find corresponding eigenvectors. \texttt{iblock\_in} specifies the submatrices corresponding to the eigenvalues in \texttt{w\_in}. \texttt{isplit\_in} specifies the splitting points between the submatrix blocks.



\end{adjustwidth}
\hypertarget{7330295151672323275}{} 
\hyperlink{7330295151672323275}{\texttt{LinearAlgebra.LAPACK.syconv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
syconv!(uplo, A, ipiv) -> (A, work)
\end{minted}

Converts a symmetric matrix \texttt{A} (which has been factorized into a triangular matrix) into two matrices \texttt{L} and \texttt{D}. If \texttt{uplo = U}, \texttt{A} is upper triangular. If \texttt{uplo = L}, it is lower triangular. \texttt{ipiv} is the pivot vector from the triangular factorization. \texttt{A} is overwritten by \texttt{L} and \texttt{D}.



\end{adjustwidth}
\hypertarget{9619199705618830828}{} 
\hyperlink{9619199705618830828}{\texttt{LinearAlgebra.LAPACK.sysv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sysv!(uplo, A, B) -> (B, A, ipiv)
\end{minted}

Finds the solution to \texttt{A * X = B} for symmetric matrix \texttt{A}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored. \texttt{B} is overwritten by the solution \texttt{X}. \texttt{A} is overwritten by its Bunch-Kaufman factorization. \texttt{ipiv} contains pivoting information about the factorization.



\end{adjustwidth}
\hypertarget{4323538288339311968}{} 
\hyperlink{4323538288339311968}{\texttt{LinearAlgebra.LAPACK.sytrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sytrf!(uplo, A) -> (A, ipiv, info)
\end{minted}

Computes the Bunch-Kaufman factorization of a symmetric matrix \texttt{A}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored.

Returns \texttt{A}, overwritten by the factorization, a pivot vector \texttt{ipiv}, and the error code \texttt{info} which is a non-negative integer. If \texttt{info} is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position \texttt{info}.



\end{adjustwidth}
\hypertarget{16079738955302816092}{} 
\hyperlink{16079738955302816092}{\texttt{LinearAlgebra.LAPACK.sytri!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sytri!(uplo, A, ipiv)
\end{minted}

Computes the inverse of a symmetric matrix \texttt{A} using the results of \texttt{sytrf!}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored. \texttt{A} is overwritten by its inverse.



\end{adjustwidth}
\hypertarget{1871905390771924166}{} 
\hyperlink{1871905390771924166}{\texttt{LinearAlgebra.LAPACK.sytrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sytrs!(uplo, A, ipiv, B)
\end{minted}

Solves the equation \texttt{A * X = B} for a symmetric matrix \texttt{A} using the results of \texttt{sytrf!}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored. \texttt{B} is overwritten by the solution \texttt{X}.



\end{adjustwidth}
\hypertarget{4935444719459229500}{} 
\hyperlink{4935444719459229500}{\texttt{LinearAlgebra.LAPACK.hesv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hesv!(uplo, A, B) -> (B, A, ipiv)
\end{minted}

Finds the solution to \texttt{A * X = B} for Hermitian matrix \texttt{A}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored. \texttt{B} is overwritten by the solution \texttt{X}. \texttt{A} is overwritten by its Bunch-Kaufman factorization. \texttt{ipiv} contains pivoting information about the factorization.



\end{adjustwidth}
\hypertarget{13823783742790511702}{} 
\hyperlink{13823783742790511702}{\texttt{LinearAlgebra.LAPACK.hetrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hetrf!(uplo, A) -> (A, ipiv, info)
\end{minted}

Computes the Bunch-Kaufman factorization of a Hermitian matrix \texttt{A}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored.

Returns \texttt{A}, overwritten by the factorization, a pivot vector \texttt{ipiv}, and the error code \texttt{info} which is a non-negative integer. If \texttt{info} is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position \texttt{info}.



\end{adjustwidth}
\hypertarget{3196814042515994361}{} 
\hyperlink{3196814042515994361}{\texttt{LinearAlgebra.LAPACK.hetri!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hetri!(uplo, A, ipiv)
\end{minted}

Computes the inverse of a Hermitian matrix \texttt{A} using the results of \texttt{sytrf!}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored. \texttt{A} is overwritten by its inverse.



\end{adjustwidth}
\hypertarget{16647495205297911695}{} 
\hyperlink{16647495205297911695}{\texttt{LinearAlgebra.LAPACK.hetrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
hetrs!(uplo, A, ipiv, B)
\end{minted}

Solves the equation \texttt{A * X = B} for a Hermitian matrix \texttt{A} using the results of \texttt{sytrf!}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored. \texttt{B} is overwritten by the solution \texttt{X}.



\end{adjustwidth}
\hypertarget{9979432299825280284}{} 
\hyperlink{9979432299825280284}{\texttt{LinearAlgebra.LAPACK.syev!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
syev!(jobz, uplo, A)
\end{minted}

Finds the eigenvalues (\texttt{jobz = N}) or eigenvalues and eigenvectors (\texttt{jobz = V}) of a symmetric matrix \texttt{A}. If \texttt{uplo = U}, the upper triangle of \texttt{A} is used. If \texttt{uplo = L}, the lower triangle of \texttt{A} is used.



\end{adjustwidth}
\hypertarget{9325824410810690137}{} 
\hyperlink{9325824410810690137}{\texttt{LinearAlgebra.LAPACK.syevr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
syevr!(jobz, range, uplo, A, vl, vu, il, iu, abstol) -> (W, Z)
\end{minted}

Finds the eigenvalues (\texttt{jobz = N}) or eigenvalues and eigenvectors (\texttt{jobz = V}) of a symmetric matrix \texttt{A}. If \texttt{uplo = U}, the upper triangle of \texttt{A} is used. If \texttt{uplo = L}, the lower triangle of \texttt{A} is used. If \texttt{range = A}, all the eigenvalues are found. If \texttt{range = V}, the eigenvalues in the half-open interval \texttt{(vl, vu]} are found. If \texttt{range = I}, the eigenvalues with indices between \texttt{il} and \texttt{iu} are found. \texttt{abstol} can be set as a tolerance for convergence.

The eigenvalues are returned in \texttt{W} and the eigenvectors in \texttt{Z}.



\end{adjustwidth}
\hypertarget{8632196472915375761}{} 
\hyperlink{8632196472915375761}{\texttt{LinearAlgebra.LAPACK.sygvd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sygvd!(itype, jobz, uplo, A, B) -> (w, A, B)
\end{minted}

Finds the generalized eigenvalues (\texttt{jobz = N}) or eigenvalues and eigenvectors (\texttt{jobz = V}) of a symmetric matrix \texttt{A} and symmetric positive-definite matrix \texttt{B}. If \texttt{uplo = U}, the upper triangles of \texttt{A} and \texttt{B} are used. If \texttt{uplo = L}, the lower triangles of \texttt{A} and \texttt{B} are used. If \texttt{itype = 1}, the problem to solve is \texttt{A * x = lambda * B * x}. If \texttt{itype = 2}, the problem to solve is \texttt{A * B * x = lambda * x}. If \texttt{itype = 3}, the problem to solve is \texttt{B * A * x = lambda * x}.



\end{adjustwidth}
\hypertarget{13657736097940764011}{} 
\hyperlink{13657736097940764011}{\texttt{LinearAlgebra.LAPACK.bdsqr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
bdsqr!(uplo, d, e_, Vt, U, C) -> (d, Vt, U, C)
\end{minted}

Computes the singular value decomposition of a bidiagonal matrix with \texttt{d} on the diagonal and \texttt{e\_} on the off-diagonal. If \texttt{uplo = U}, \texttt{e\_} is the superdiagonal. If \texttt{uplo = L}, \texttt{e\_} is the subdiagonal. Can optionally also compute the product \texttt{Q{\textquotesingle} * C}.

Returns the singular values in \texttt{d}, and the matrix \texttt{C} overwritten with \texttt{Q{\textquotesingle} * C}.



\end{adjustwidth}
\hypertarget{2117266507846761835}{} 
\hyperlink{2117266507846761835}{\texttt{LinearAlgebra.LAPACK.bdsdc!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
bdsdc!(uplo, compq, d, e_) -> (d, e, u, vt, q, iq)
\end{minted}

Computes the singular value decomposition of a bidiagonal matrix with \texttt{d} on the diagonal and \texttt{e\_} on the off-diagonal using a divide and conqueq method. If \texttt{uplo = U}, \texttt{e\_} is the superdiagonal. If \texttt{uplo = L}, \texttt{e\_} is the subdiagonal. If \texttt{compq = N}, only the singular values are found. If \texttt{compq = I}, the singular values and vectors are found. If \texttt{compq = P}, the singular values and vectors are found in compact form. Only works for real types.

Returns the singular values in \texttt{d}, and if \texttt{compq = P}, the compact singular vectors in \texttt{iq}.



\end{adjustwidth}
\hypertarget{3277861361503147277}{} 
\hyperlink{3277861361503147277}{\texttt{LinearAlgebra.LAPACK.gecon!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gecon!(normtype, A, anorm)
\end{minted}

Finds the reciprocal condition number of matrix \texttt{A}. If \texttt{normtype = I}, the condition number is found in the infinity norm. If \texttt{normtype = O} or \texttt{1}, the condition number is found in the one norm. \texttt{A} must be the result of \texttt{getrf!} and \texttt{anorm} is the norm of \texttt{A} in the relevant norm.



\end{adjustwidth}
\hypertarget{14367369116295032587}{} 
\hyperlink{14367369116295032587}{\texttt{LinearAlgebra.LAPACK.gehrd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gehrd!(ilo, ihi, A) -> (A, tau)
\end{minted}

Converts a matrix \texttt{A} to Hessenberg form. If \texttt{A} is balanced with \texttt{gebal!} then \texttt{ilo} and \texttt{ihi} are the outputs of \texttt{gebal!}. Otherwise they should be \texttt{ilo = 1} and \texttt{ihi = size(A,2)}. \texttt{tau} contains the elementary reflectors of the factorization.



\end{adjustwidth}
\hypertarget{17531257454072185780}{} 
\hyperlink{17531257454072185780}{\texttt{LinearAlgebra.LAPACK.orghr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
orghr!(ilo, ihi, A, tau)
\end{minted}

Explicitly finds \texttt{Q}, the orthogonal/unitary matrix from \texttt{gehrd!}. \texttt{ilo}, \texttt{ihi}, \texttt{A}, and \texttt{tau} must correspond to the input/output to \texttt{gehrd!}.



\end{adjustwidth}
\hypertarget{7554800805540125473}{} 
\hyperlink{7554800805540125473}{\texttt{LinearAlgebra.LAPACK.gees!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gees!(jobvs, A) -> (A, vs, w)
\end{minted}

Computes the eigenvalues (\texttt{jobvs = N}) or the eigenvalues and Schur vectors (\texttt{jobvs = V}) of matrix \texttt{A}. \texttt{A} is overwritten by its Schur form.

Returns \texttt{A}, \texttt{vs} containing the Schur vectors, and \texttt{w}, containing the eigenvalues.



\end{adjustwidth}
\hypertarget{9858205807823882594}{} 
\hyperlink{9858205807823882594}{\texttt{LinearAlgebra.LAPACK.gges!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
gges!(jobvsl, jobvsr, A, B) -> (A, B, alpha, beta, vsl, vsr)
\end{minted}

Computes the generalized eigenvalues, generalized Schur form, left Schur vectors (\texttt{jobsvl = V}), or right Schur vectors (\texttt{jobvsr = V}) of \texttt{A} and \texttt{B}.

The generalized eigenvalues are returned in \texttt{alpha} and \texttt{beta}. The left Schur vectors are returned in \texttt{vsl} and the right Schur vectors are returned in \texttt{vsr}.



\end{adjustwidth}
\hypertarget{16392841550634697146}{} 
\hyperlink{16392841550634697146}{\texttt{LinearAlgebra.LAPACK.trexc!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trexc!(compq, ifst, ilst, T, Q) -> (T, Q)
\end{minted}

Reorder the Schur factorization of a matrix. If \texttt{compq = V}, the Schur vectors \texttt{Q} are reordered. If \texttt{compq = N} they are not modified. \texttt{ifst} and \texttt{ilst} specify the reordering of the vectors.



\end{adjustwidth}
\hypertarget{14222318539033253394}{} 
\hyperlink{14222318539033253394}{\texttt{LinearAlgebra.LAPACK.trsen!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trsen!(compq, job, select, T, Q) -> (T, Q, w, s, sep)
\end{minted}

Reorder the Schur factorization of a matrix and optionally finds reciprocal condition numbers. If \texttt{job = N}, no condition numbers are found. If \texttt{job = E}, only the condition number for this cluster of eigenvalues is found. If \texttt{job = V}, only the condition number for the invariant subspace is found. If \texttt{job = B} then the condition numbers for the cluster and subspace are found. If \texttt{compq = V} the Schur vectors \texttt{Q} are updated. If \texttt{compq = N} the Schur vectors are not modified. \texttt{select} determines which eigenvalues are in the cluster.

Returns \texttt{T}, \texttt{Q}, reordered eigenvalues in \texttt{w}, the condition number of the cluster of eigenvalues \texttt{s}, and the condition number of the invariant subspace \texttt{sep}.



\end{adjustwidth}
\hypertarget{4226534331460521506}{} 
\hyperlink{4226534331460521506}{\texttt{LinearAlgebra.LAPACK.tgsen!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tgsen!(select, S, T, Q, Z) -> (S, T, alpha, beta, Q, Z)
\end{minted}

Reorders the vectors of a generalized Schur decomposition. \texttt{select} specifies the eigenvalues in each cluster.



\end{adjustwidth}
\hypertarget{853281004697696312}{} 
\hyperlink{853281004697696312}{\texttt{LinearAlgebra.LAPACK.trsyl!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
trsyl!(transa, transb, A, B, C, isgn=1) -> (C, scale)
\end{minted}

Solves the Sylvester matrix equation \texttt{A * X +/- X * B = scale*C} where \texttt{A} and \texttt{B} are both quasi-upper triangular. If \texttt{transa = N}, \texttt{A} is not modified. If \texttt{transa = T}, \texttt{A} is transposed. If \texttt{transa = C}, \texttt{A} is conjugate transposed. Similarly for \texttt{transb} and \texttt{B}. If \texttt{isgn = 1}, the equation \texttt{A * X + X * B = scale * C} is solved. If \texttt{isgn = -1}, the equation \texttt{A * X - X * B = scale * C} is solved.

Returns \texttt{X} (overwriting \texttt{C}) and \texttt{scale}.



\end{adjustwidth}



\hypertarget{16565866334883334127}{}


\chapter{日志记录}



The \hyperlink{1488091939099076420}{\texttt{Logging}} module provides a way to record the history and progress of a computation as a log of events.  Events are created by inserting a logging statement into the source code, for example:




\begin{minted}{julia}
@warn "Abandon printf debugging, all ye who enter here!"
┌ Warning: Abandon printf debugging, all ye who enter here!
└ @ Main REPL[1]:1
\end{minted}



The system provides several advantages over peppering your source code with calls to \texttt{println()}.  First, it allows you to control the visibility and presentation of messages without editing the source code.  For example, in contrast to the \texttt{@warn} above




\begin{minted}{julia}
@debug "The sum of some values $(sum(rand(100)))"
\end{minted}



will produce no output by default.  Furthermore, it{\textquotesingle}s very cheap to leave debug statements like this in the source code because the system avoids evaluating the message if it would later be ignored.  In this case \texttt{sum(rand(100))} and the associated string processing will never be executed unless debug logging is enabled.



Second, the logging tools allow you to attach arbitrary data to each event as a set of key–value pairs. This allows you to capture local variables and other program state for later analysis. For example, to attach the local array variable \texttt{A} and the sum of a vector \texttt{v} as the key \texttt{s} you can use




\begin{minted}{julia}
A = ones(Int, 4, 4)
v = ones(100)
@info "Some variables"  A  s=sum(v)

# 输出：
┌ Info: Some variables
│   A =
│    4×4 Array{Int64,2}:
│     1  1  1  1
│     1  1  1  1
│     1  1  1  1
│     1  1  1  1
└   s = 100.0
\end{minted}



All of the logging macros \texttt{@debug}, \texttt{@info}, \texttt{@warn} and \texttt{@error} share common features that are described in detail in the documentation for the more general macro \hyperlink{2787319849348710857}{\texttt{@logmsg}}.



\hypertarget{16412881529124994328}{}


\section{日志事件结构}



Each event generates several pieces of data, some provided by the user and some automatically extracted. Let{\textquotesingle}s examine the user-defined data first:



\begin{itemize}
\item The \emph{log level} is a broad category for the message that is used for early filtering. There are several standard levels of type \hyperlink{10879938884267981707}{\texttt{LogLevel}}; user-defined levels are also possible. Each is distinct in purpose:

\begin{itemize}
\item \texttt{Debug} is information intended for the developer of the program.

\end{itemize}
These events are disabled by default.

\begin{itemize}
\item \texttt{Info} is for general information to the user.

\end{itemize}
Think of it as an alternative to using \texttt{println} directly.

\begin{itemize}
\item \texttt{Warn} means something is wrong and action is likely required

\end{itemize}
but that for now the program is still working.

\begin{itemize}
\item \texttt{Error} means something is wrong and it is unlikely to be recovered,

\end{itemize}
at least by this part of the code. Often this log-level is unneeded as throwing an exception can convey all the required information.


\item The \emph{message}  is an object describing the event. By convention \texttt{AbstractString}s passed as messages are assumed to be in markdown format. Other types will be displayed using \texttt{print(io, obj)} or \texttt{string(obj)} for text-based output and possibly \texttt{show(io,mime,obj)} for other multimedia displays used in the installed logger.


\item Optional \emph{key–value pairs} allow arbitrary data to be attached to each event. Some keys have conventional meaning that can affect the way an event is interpreted (see \hyperlink{2787319849348710857}{\texttt{@logmsg}}).

\end{itemize}


The system also generates some standard information for each event:



\begin{itemize}
\item The \texttt{module} in which the logging macro was expanded.


\item The \texttt{file} and \texttt{line} where the logging macro occurs in the source code.


\item A message \texttt{id} that is a unique, fixed identifier for the \emph{source code statement} where the logging macro appears. This identifier is designed to be fairly stable even if the source code of the file changes, as long as the logging statement itself remains the same.


\item A \texttt{group} for the event, which is set to the base name of the file by default, without extension.  This can be used to group messages into categories more finely than the log level (for example, all deprecation warnings have group \texttt{:depwarn}), or into logical groupings across or within modules.

\end{itemize}


Notice that some useful information such as the event time is not included by default. This is because such information can be expensive to extract and is also \emph{dynamically} available to the current logger. It{\textquotesingle}s simple to define a \hyperlink{8132992094414010061}{custom logger} to augment event data with the time, backtrace, values of global variables and other useful information as required.



\hypertarget{1246485954867051804}{}


\section{Processing log events}



As you can see in the examples, logging statements make no mention of where log events go or how they are processed. This is a key design feature that makes the system composable and natural for concurrent use. It does this by separating two different concerns:



\begin{itemize}
\item \emph{Creating} log events is the concern of the module author who needs to decide where events are triggered and which information to include.


\item \emph{Processing} of log events — that is, display, filtering, aggregation and recording — is the concern of the application author who needs to bring multiple modules together into a cooperating application.

\end{itemize}


\hypertarget{9118034371113309221}{}


\subsection{Loggers}



Processing of events is performed by a \emph{logger}, which is the first piece of user configurable code to see the event. All loggers must be subtypes of \hyperlink{16983066617679297643}{\texttt{AbstractLogger}}.



When an event is triggered, the appropriate logger is found by looking for a task-local logger with the global logger as fallback.  The idea here is that the application code knows how log events should be processed and exists somewhere at the top of the call stack. So we should look up through the call stack to discover the logger — that is, the logger should be \emph{dynamically scoped}. (This is a point of contrast with logging frameworks where the logger is \emph{lexically scoped}; provided explicitly by the module author or as a simple global variable. In such a system it{\textquotesingle}s awkward to control logging while composing functionality from multiple modules.)



The global logger may be set with \hyperlink{4306559652149699055}{\texttt{global\_logger}}, and task-local loggers controlled using \hyperlink{14383079235362132941}{\texttt{with\_logger}}.  Newly spawned tasks inherit the logger of the parent task.



There are three logger types provided by the library.  \hyperlink{14105182192150729642}{\texttt{ConsoleLogger}} is the default logger you see when starting the REPL.  It displays events in a readable text format and tries to give simple but user friendly control over formatting and filtering.  \hyperlink{15508205197393226825}{\texttt{NullLogger}} is a convenient way to drop all messages where necessary; it is the logging equivalent of the \hyperlink{13412111234074215621}{\texttt{devnull}} stream.  \hyperlink{206724342092815568}{\texttt{SimpleLogger}} is a very simplistic text formatting logger, mainly useful for debugging the logging system itself.



Custom loggers should come with overloads for the functions described in the \hyperlink{8132992094414010061}{reference section}.



\hypertarget{6918254684898348274}{}


\subsection{Early filtering and message handling}



When an event occurs, a few steps of early filtering occur to avoid generating messages that will be discarded:



\begin{itemize}
\item[1. ] The message log level is checked against a global minimum level (set via \hyperlink{10677278458507378523}{\texttt{disable\_logging}}).  This is a crude but extremely cheap global setting.


\item[2. ] The current logger state is looked up and the message level checked against the logger{\textquotesingle}s cached minimum level, as found by calling \hyperlink{1177702033979282781}{\texttt{Logging.min\_enabled\_level}}. This behavior can be overridden via environment variables (more on this later).


\item[3. ] The \hyperlink{10642364941499317938}{\texttt{Logging.shouldlog}} function is called with the current logger, taking some minimal information (level, module, group, id) which can be computed statically.  Most usefully, \texttt{shouldlog} is passed an event \texttt{id} which can be used to discard events early based on a cached predicate.

\end{itemize}


If all these checks pass, the message and key–value pairs are evaluated in full and passed to the current logger via the \hyperlink{1528450952930149457}{\texttt{Logging.handle\_message}} function. \texttt{handle\_message()} may perform additional filtering as required and display the event to the screen, save it to a file, etc.



Exceptions that occur while generating the log event are captured and logged by default.  This prevents individual broken events from crashing the application, which is helpful when enabling little-used debug events in a production system.  This behavior can be customized per logger type by extending \hyperlink{13546483368377724892}{\texttt{Logging.catch\_exceptions}}.



\hypertarget{5760891326467658260}{}


\section{Testing log events}



Log events are a side effect of running normal code, but you might find yourself wanting to test particular informational messages and warnings. The \texttt{Test} module provides a \hyperlink{1395021091279173086}{\texttt{@test\_logs}} macro that can be used to pattern match against the log event stream.



\hypertarget{2137823180188774840}{}


\section{Environment variables}



Message filtering can be influenced through the \texttt{JULIA\_DEBUG} environment variable, and serves as an easy way to enable debug logging for a file or module. For example, loading julia with \texttt{JULIA\_DEBUG=loading} will activate \texttt{@debug} log messages in \texttt{loading.jl}:




\begin{lstlisting}
$ JULIA_DEBUG=loading julia -e 'using OhMyREPL'
┌ Debug: Rejecting cache file /home/user/.julia/compiled/v0.7/OhMyREPL.ji due to it containing an invalid cache header
└ @ Base loading.jl:1328
[ Info: Recompiling stale cache file /home/user/.julia/compiled/v0.7/OhMyREPL.ji for module OhMyREPL
┌ Debug: Rejecting cache file /home/user/.julia/compiled/v0.7/Tokenize.ji due to it containing an invalid cache header
└ @ Base loading.jl:1328
...
\end{lstlisting}



Similarly, the environment variable can be used to enable debug logging of modules, such as \texttt{Pkg}, or module roots (see \hyperlink{10679300263900972054}{\texttt{Base.moduleroot}}). To enable all debug logging, use the special value \texttt{all}.



To turn debug logging on from the REPL, set \texttt{ENV[{\textquotedbl}JULIA\_DEBUG{\textquotedbl}]} to the name of the module of interest. Functions defined in the REPL belong to module \texttt{Main}; logging for them can be enabled like this:




\begin{minted}{jlcon}
julia> foo() = @debug "foo"
foo (generic function with 1 method)

julia> foo()

julia> ENV["JULIA_DEBUG"] = Main
Main

julia> foo()
┌ Debug: foo
└ @ Main REPL[1]:1

\end{minted}



\hypertarget{13723157150790493828}{}


\section{Writing log events to a file}



Sometimes it can be useful to write log events to a file. Here is an example of how to use a task-local and global logger to write information to a text file:




\begin{minted}{jlcon}
# Load the logging module
julia> using Logging

# Open a textfile for writing
julia> io = open("log.txt", "w+")
IOStream(<file log.txt>)

# Create a simple logger
julia> logger = SimpleLogger(io)
SimpleLogger(IOStream(<file log.txt>), Info, Dict{Any,Int64}())

# Log a task-specific message
julia> with_logger(logger) do
           @info("a context specific log message")
       end

# Write all buffered messages to the file
julia> flush(io)

# Set the global logger to logger
julia> global_logger(logger)
SimpleLogger(IOStream(<file log.txt>), Info, Dict{Any,Int64}())

# This message will now also be written to the file
julia> @info("a global log message")

# Close the file
julia> close(io)
\end{minted}



\hypertarget{15956208855154540711}{}


\section{Reference}



\hypertarget{9952495786425959332}{}


\subsection{Logging module}


\hypertarget{1488091939099076420}{} 
\hyperlink{1488091939099076420}{\texttt{Logging.Logging}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}

Utilities for capturing, filtering and presenting streams of log events. Normally you don{\textquotesingle}t need to import \texttt{Logging} to create log events; for this the standard logging macros such as \texttt{@info} are already exported by \texttt{Base} and available by default.



\end{adjustwidth}

\hypertarget{16245113775601037343}{}


\subsection{Creating events}


\hypertarget{2787319849348710857}{} 
\hyperlink{2787319849348710857}{\texttt{Logging.@logmsg}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@debug message  [key=value | value ...]
@info  message  [key=value | value ...]
@warn  message  [key=value | value ...]
@error message  [key=value | value ...]

@logmsg level message [key=value | value ...]
\end{minted}

Create a log record with an informational \texttt{message}.  For convenience, four logging macros \texttt{@debug}, \texttt{@info}, \texttt{@warn} and \texttt{@error} are defined which log at the standard severity levels \texttt{Debug}, \texttt{Info}, \texttt{Warn} and \texttt{Error}.  \texttt{@logmsg} allows \texttt{level} to be set programmatically to any \texttt{LogLevel} or custom log level types.

\texttt{message} should be an expression which evaluates to a string which is a human readable description of the log event.  By convention, this string will be formatted as markdown when presented.

The optional list of \texttt{key=value} pairs supports arbitrary user defined metadata which will be passed through to the logging backend as part of the log record.  If only a \texttt{value} expression is supplied, a key representing the expression will be generated using \hyperlink{18332791376992528422}{\texttt{Symbol}}. For example, \texttt{x} becomes \texttt{x=x}, and \texttt{foo(10)} becomes \texttt{Symbol({\textquotedbl}foo(10){\textquotedbl})=foo(10)}.  For splatting a list of key value pairs, use the normal splatting syntax, \texttt{@info {\textquotedbl}blah{\textquotedbl} kws...}.

There are some keys which allow automatically generated log data to be overridden:

\begin{itemize}
\item \texttt{\_module=mod} can be used to specify a different originating module from the source location of the message.


\item \texttt{\_group=symbol} can be used to override the message group (this is normally derived from the base name of the source file).


\item \texttt{\_id=symbol} can be used to override the automatically generated unique message identifier.  This is useful if you need to very closely associate messages generated on different source lines.


\item \texttt{\_file=string} and \texttt{\_line=integer} can be used to override the apparent source location of a log message.

\end{itemize}
There{\textquotesingle}s also some key value pairs which have conventional meaning:

\begin{itemize}
\item \texttt{maxlog=integer} should be used as a hint to the backend that the message should be displayed no more than \texttt{maxlog} times.


\item \texttt{exception=ex} should be used to transport an exception with a log message, often used with \texttt{@error}. An associated backtrace \texttt{bt} may be attached using the tuple \texttt{exception=(ex,bt)}.

\end{itemize}
\textbf{Examples}


\begin{lstlisting}
@debug "Verbose debugging information.  Invisible by default"
@info  "An informational message"
@warn  "Something was odd.  You should pay attention"
@error "A non fatal error occurred"

x = 10
@info "Some variables attached to the message" x a=42.0

@debug begin
    sA = sum(A)
    "sum(A) = $sA is an expensive operation, evaluated only when `shouldlog` returns true"
end

for i=1:10000
    @info "With the default backend, you will only see (i = $i) ten times"  maxlog=10
    @debug "Algorithm1" i progress=i/10000
end
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L219-L286}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10879938884267981707}{} 
\hyperlink{10879938884267981707}{\texttt{Logging.LogLevel}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
LogLevel(level)
\end{minted}

Severity/verbosity of a log record.

The log level provides a key against which potential log records may be filtered, before any other work is done to construct the log record data structure itself.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L91-L99}{\texttt{source}}


\end{adjustwidth}

\hypertarget{10335028777960461011}{}


\subsection{Processing events with AbstractLogger}



Event processing is controlled by overriding functions associated with \texttt{AbstractLogger}:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Methods to implement &  & Brief description \\
\hline
\hyperlink{1528450952930149457}{\texttt{Logging.handle\_message}} &  & Handle a log event \\
\hline
\hyperlink{10642364941499317938}{\texttt{Logging.shouldlog}} &  & Early filtering of events \\
\hline
\hyperlink{1177702033979282781}{\texttt{Logging.min\_enabled\_level}} &  & Lower bound for log level of accepted events \\
\hline
\textbf{Optional methods} & \textbf{Default definition} & \textbf{Brief description} \\
\hline
\hyperlink{13546483368377724892}{\texttt{Logging.catch\_exceptions}} & \texttt{true} & Catch exceptions during event evaluation \\
\hline
\end{tabulary}

\end{table}


\hypertarget{16983066617679297643}{} 
\hyperlink{16983066617679297643}{\texttt{Logging.AbstractLogger}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

A logger controls how log records are filtered and dispatched.  When a log record is generated, the logger is the first piece of user configurable code which gets to inspect the record and decide what to do with it.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L24-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1528450952930149457}{} 
\hyperlink{1528450952930149457}{\texttt{Logging.handle\_message}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
handle_message(logger, level, message, _module, group, id, file, line; key1=val1, ...)
\end{minted}

Log a message to \texttt{logger} at \texttt{level}.  The logical location at which the message was generated is given by module \texttt{\_module} and \texttt{group}; the source location by \texttt{file} and \texttt{line}. \texttt{id} is an arbitrary unique value (typically a \hyperlink{18332791376992528422}{\texttt{Symbol}}) to be used as a key to identify the log statement when filtering.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L31-L39}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10642364941499317938}{} 
\hyperlink{10642364941499317938}{\texttt{Logging.shouldlog}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
shouldlog(logger, level, _module, group, id)
\end{minted}

Return true when \texttt{logger} accepts a message at \texttt{level}, generated for \texttt{\_module}, \texttt{group} and with unique log identifier \texttt{id}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L42-L47}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1177702033979282781}{} 
\hyperlink{1177702033979282781}{\texttt{Logging.min\_enabled\_level}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
min_enabled_level(logger)
\end{minted}

Return the minimum enabled level for \texttt{logger} for early filtering.  That is, the log level below or equal to which all messages are filtered.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L50-L55}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13546483368377724892}{} 
\hyperlink{13546483368377724892}{\texttt{Logging.catch\_exceptions}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
catch_exceptions(logger)
\end{minted}

Return true if the logger should catch exceptions which happen during log record construction.  By default, messages are caught

By default all exceptions are caught to prevent log message generation from crashing the program.  This lets users confidently toggle little-used functionality - such as debug logging - in a production system.

If you want to use logging as an audit trail you should disable this for your logger type.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L58-L70}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10677278458507378523}{} 
\hyperlink{10677278458507378523}{\texttt{Logging.disable\_logging}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
disable_logging(level)
\end{minted}

Disable all log messages at log levels equal to or less than \texttt{level}.  This is a \emph{global} setting, intended to make debug logging extremely cheap when disabled.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L408-L414}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14824596935687234191}{}


\subsection{Using Loggers}



Logger installation and inspection:


\hypertarget{4306559652149699055}{} 
\hyperlink{4306559652149699055}{\texttt{Logging.global\_logger}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
global_logger()
\end{minted}

Return the global logger, used to receive messages when no specific logger exists for the current task.


\begin{lstlisting}
global_logger(logger)
\end{lstlisting}

Set the global logger to \texttt{logger}, and return the previous global logger.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L469-L478}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14383079235362132941}{} 
\hyperlink{14383079235362132941}{\texttt{Logging.with\_logger}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
with_logger(function, logger)
\end{minted}

Execute \texttt{function}, directing all log messages to \texttt{logger}.

\textbf{Example}


\begin{minted}{julia}
function test(x)
    @info "x = $x"
end

with_logger(logger) do
    test(1)
    test([1,2])
end
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L487-L504}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1207364331935599285}{} 
\hyperlink{1207364331935599285}{\texttt{Logging.current\_logger}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
current_logger()
\end{minted}

Return the logger for the current task, or the global logger if none is attached to the task.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L507-L512}{\texttt{source}}


\end{adjustwidth}

Loggers that are supplied with the system:


\hypertarget{15508205197393226825}{} 
\hyperlink{15508205197393226825}{\texttt{Logging.NullLogger}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
NullLogger()
\end{minted}

Logger which disables all messages and produces no output - the logger equivalent of /dev/null.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L75-L80}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14105182192150729642}{} 
\hyperlink{14105182192150729642}{\texttt{Logging.ConsoleLogger}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ConsoleLogger(stream=stderr, min_level=Info; meta_formatter=default_metafmt,
              show_limited=true, right_justify=0)
\end{minted}

Logger with formatting optimized for readability in a text console, for example interactive work with the Julia REPL.

Log levels less than \texttt{min\_level} are filtered out.

Message formatting can be controlled by setting keyword arguments:

\begin{itemize}
\item \texttt{meta\_formatter} is a function which takes the log event metadata \texttt{(level, \_module, group, id, file, line)} and returns a color (as would be passed to printstyled), prefix and suffix for the log message.  The default is to prefix with the log level and a suffix containing the module, file and line location.


\item \texttt{show\_limited} limits the printing of large data structures to something which can fit on the screen by setting the \texttt{:limit} \texttt{IOContext} key during formatting.


\item \texttt{right\_justify} is the integer column which log metadata is right justified at. The default is zero (metadata goes on its own line).

\end{itemize}


\end{adjustwidth}
\hypertarget{206724342092815568}{} 
\hyperlink{206724342092815568}{\texttt{Logging.SimpleLogger}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SimpleLogger(stream=stderr, min_level=Info)
\end{minted}

Simplistic logger for logging all messages with level greater than or equal to \texttt{min\_level} to \texttt{stream}.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/logging.jl#L518-L523}{\texttt{source}}


\end{adjustwidth}

\hypertarget{6677165778934209668}{}


\chapter{Markdown}



This section describes Julia{\textquotesingle}s markdown syntax, which is enabled by the Markdown standard library. The following Markdown elements are supported:



\hypertarget{8063626144587397226}{}


\section{Inline elements}



Here {\textquotedbl}inline{\textquotedbl} refers to elements that can be found within blocks of text, i.e. paragraphs. These include the following elements.



\hypertarget{10166533682417016306}{}


\subsection{Bold}



Surround words with two asterisks, \texttt{**}, to display the enclosed text in boldface.




\begin{lstlisting}
A paragraph containing a **bold** word.
\end{lstlisting}



\hypertarget{4277603997710742460}{}


\subsection{Italics}



Surround words with one asterisk, \texttt{*}, to display the enclosed text in italics.




\begin{lstlisting}
A paragraph containing an *italicized* word.
\end{lstlisting}



\hypertarget{6850088772867679045}{}


\subsection{Literals}



Surround text that should be displayed exactly as written with single backticks, \texttt{`} .




\begin{lstlisting}
A paragraph containing a `literal` word.
\end{lstlisting}



Literals should be used when writing text that refers to names of variables, functions, or other parts of a Julia program.



\begin{quote}
\textbf{Tip}

To include a backtick character within literal text use three backticks rather than one to enclose the text.


\begin{lstlisting}
A paragraph containing ``` `backtick` characters ```.
\end{lstlisting}

By extension any odd number of backticks may be used to enclose a lesser number of backticks.

\end{quote}


\hypertarget{6917271240677862304}{}


\subsection{ \LaTeX }



Surround text that should be displayed as mathematics using  \LaTeX  syntax with double backticks, \texttt{``} .




\begin{lstlisting}
A paragraph containing some ``\LaTeX`` markup.
\end{lstlisting}



\begin{quote}
\textbf{Tip}

As with literals in the previous section, if literal backticks need to be written within double backticks use an even number greater than two. Note that if a single literal backtick needs to be included within  \LaTeX  markup then two enclosing backticks is sufficient.

\end{quote}


\begin{quote}
\textbf{Note}

The \texttt{{\textbackslash}} character should be escaped appropriately if the text is embedded in a Julia source code, for example, \texttt{{\textquotedbl}``{\textbackslash}{\textbackslash}LaTeX`` syntax in a docstring.{\textquotedbl}}, since it is interpreted as a string literal. Alternatively, in order to avoid escaping, it is possible to use the \texttt{raw} string macro together with the \texttt{@doc} macro:


\begin{lstlisting}
@doc raw"``\LaTeX`` syntax in a docstring." functionname
\end{lstlisting}

\end{quote}


\hypertarget{10395937766942848638}{}


\subsection{Links}



Links to either external or internal targets can be written using the following syntax, where the text enclosed in square brackets, \texttt{[ ]}, is the name of the link and the text enclosed in parentheses, \texttt{( )}, is the URL.




\begin{lstlisting}
A paragraph containing a link to [Julia](http://www.julialang.org).
\end{lstlisting}



It{\textquotesingle}s also possible to add cross-references to other documented functions/methods/variables within the Julia documentation itself. For example:




\begin{minted}{julia}
"""
    tryparse(type, str; base)

Like [`parse`](@ref), but returns either a value of the requested type,
or [`nothing`](@ref) if the string does not contain a valid number.
"""
\end{minted}



This will create a link in the generated docs to the \hyperlink{14207407853646164654}{\texttt{parse}} documentation (which has more information about what this function actually does), and to the \hyperlink{9331422207248206047}{\texttt{nothing}} documentation. It{\textquotesingle}s good to include cross references to mutating/non-mutating versions of a function, or to highlight a difference between two similar-seeming functions.



\begin{quote}
\textbf{Note}

The above cross referencing is \emph{not} a Markdown feature, and relies on \href{https://github.com/JuliaDocs/Documenter.jl}{Documenter.jl}, which is used to build base Julia{\textquotesingle}s documentation.

\end{quote}


\hypertarget{1886176754537713588}{}


\subsection{Footnote references}



Named and numbered footnote references can be written using the following syntax. A footnote name must be a single alphanumeric word containing no punctuation.




\begin{lstlisting}
A paragraph containing a numbered footnote [^1] and a named one [^named].
\end{lstlisting}



\begin{quote}
\textbf{Note}

The text associated with a footnote can be written anywhere within the same page as the footnote reference. The syntax used to define the footnote text is discussed in the \hyperlink{16845496644619434430}{Footnotes} section below.

\end{quote}


\hypertarget{1299449328577314863}{}


\section{Toplevel elements}



The following elements can be written either at the {\textquotedbl}toplevel{\textquotedbl} of a document or within another {\textquotedbl}toplevel{\textquotedbl} element.



\hypertarget{7653906193491884111}{}


\subsection{Paragraphs}



A paragraph is a block of plain text, possibly containing any number of inline elements defined in the \hyperlink{17997341109973101587}{Inline elements} section above, with one or more blank lines above and below it.




\begin{lstlisting}
This is a paragraph.

And this is *another* paragraph containing some emphasized text.
A new line, but still part of the same paragraph.
\end{lstlisting}



\hypertarget{14939650886219602329}{}


\subsection{Headers}



A document can be split up into different sections using headers. Headers use the following syntax:




\begin{minted}{julia}
# Level One
## Level Two
### Level Three
#### Level Four
##### Level Five
###### Level Six
\end{minted}



A header line can contain any inline syntax in the same way as a paragraph can.



\begin{quote}
\textbf{Tip}

Try to avoid using too many levels of header within a single document. A heavily nested document may be indicative of a need to restructure it or split it into several pages covering separate topics.

\end{quote}


\hypertarget{9246544299434150790}{}


\subsection{Code blocks}



Source code can be displayed as a literal block using an indent of four spaces as shown in the following example.




\begin{lstlisting}
This is a paragraph.

    function func(x)
        # ...
    end

Another paragraph.
\end{lstlisting}



Additionally, code blocks can be enclosed using triple backticks with an optional {\textquotedbl}language{\textquotedbl} to specify how a block of code should be highlighted.




\begin{lstlisting}
A code block without a "language":

```
function func(x)
    # ...
end
```

and another one with the "language" specified as `julia`:

```julia
function func(x)
    # ...
end
```
\end{lstlisting}



\begin{quote}
\textbf{Note}

{\textquotedbl}Fenced{\textquotedbl} code blocks, as shown in the last example, should be preferred over indented code blocks since there is no way to specify what language an indented code block is written in.

\end{quote}


\hypertarget{12305052721486916392}{}


\subsection{Block quotes}



Text from external sources, such as quotations from books or websites, can be quoted using \texttt{>} characters prepended to each line of the quote as follows.




\begin{lstlisting}
Here's a quote:

> Julia is a high-level, high-performance dynamic programming language for
> technical computing, with syntax that is familiar to users of other
> technical computing environments.
\end{lstlisting}



Note that a single space must appear after the \texttt{>} character on each line. Quoted blocks may themselves contain other toplevel or inline elements.



\hypertarget{9122787766607047979}{}


\subsection{Images}



The syntax for images is similar to the link syntax mentioned above. Prepending a \texttt{!} character to a link will display an image from the specified URL rather than a link to it.




\begin{minted}{julia}
![alternative text](link/to/image.png)
\end{minted}



\hypertarget{5671077042730580546}{}


\subsection{Lists}



Unordered lists can be written by prepending each item in a list with either \texttt{*}, \texttt{+}, or \texttt{-}.




\begin{lstlisting}
A list of items:

  * item one
  * item two
  * item three
\end{lstlisting}



Note the two spaces before each \texttt{*} and the single space after each one.



Lists can contain other nested toplevel elements such as lists, code blocks, or quoteblocks. A blank line should be left between each list item when including any toplevel elements within a list.




\begin{lstlisting}
Another list:

  * item one

  * item two

    ```
    f(x) = x
    ```

  * And a sublist:

      + sub-item one
      + sub-item two
\end{lstlisting}



\begin{quote}
\textbf{Note}

The contents of each item in the list must line up with the first line of the item. In the above example the fenced code block must be indented by four spaces to align with the \texttt{i} in \texttt{item two}.

\end{quote}


Ordered lists are written by replacing the {\textquotedbl}bullet{\textquotedbl} character, either \texttt{*}, \texttt{+}, or \texttt{-}, with a positive integer followed by either \texttt{.} or \texttt{)}.




\begin{lstlisting}
Two ordered lists:

 1. item one
 2. item two
 3. item three

 5) item five
 6) item six
 7) item seven
\end{lstlisting}



An ordered list may start from a number other than one, as in the second list of the above example, where it is numbered from five. As with unordered lists, ordered lists can contain nested toplevel elements.



\hypertarget{8249559303631128892}{}


\subsection{Display equations}



Large  \LaTeX  equations that do not fit inline within a paragraph may be written as display equations using a fenced code block with the {\textquotedbl}language{\textquotedbl} \texttt{math} as in the example below.




\begin{minted}{julia}
```math
f(a) = \frac{1}{2\pi}\int_{0}^{2\pi} (\alpha+R\cos(\theta))d\theta
```
\end{minted}



\hypertarget{1021238270223877775}{}


\subsection{Footnotes}



This syntax is paired with the inline syntax for \hyperlink{1545049731521220959}{Footnote references}. Make sure to read that section as well.



Footnote text is defined using the following syntax, which is similar to footnote reference syntax, aside from the \texttt{:} character that is appended to the footnote label.




\begin{lstlisting}
[^1]: Numbered footnote text.

[^note]:

    Named footnote text containing several toplevel elements.

      * item one
      * item two
      * item three

    ```julia
    function func(x)
        # ...
    end
    ```
\end{lstlisting}



\begin{quote}
\textbf{Note}

No checks are done during parsing to make sure that all footnote references have matching footnotes.

\end{quote}


\hypertarget{5663489325501471007}{}


\subsection{Horizontal rules}



The equivalent of an \texttt{<hr>} HTML tag can be achieved using three hyphens (\texttt{---}). For example:




\begin{lstlisting}
Text above the line.

---

And text below the line.
\end{lstlisting}



\hypertarget{13092196581825070152}{}


\subsection{Tables}



Basic tables can be written using the syntax described below. Note that markdown tables have limited features and cannot contain nested toplevel elements unlike other elements discussed above – only inline elements are allowed. Tables must always contain a header row with column names. Cells cannot span multiple rows or columns of the table.




\begin{lstlisting}
| Column One | Column Two | Column Three |
|:---------- | ---------- |:------------:|
| Row `1`    | Column `2` |              |
| *Row* 2    | **Row** 2  | Column ``3`` |
\end{lstlisting}



\begin{quote}
\textbf{Note}

As illustrated in the above example each column of \texttt{|} characters must be aligned vertically.

A \texttt{:} character on either end of a column{\textquotesingle}s header separator (the row containing \texttt{-} characters) specifies whether the row is left-aligned, right-aligned, or (when \texttt{:} appears on both ends) center-aligned. Providing no \texttt{:} characters will default to right-aligning the column.

\end{quote}


\hypertarget{7215905182614360565}{}


\subsection{Admonitions}



Specially formatted blocks, known as admonitions, can be used to highlight particular remarks. They can be defined using the following \texttt{!!!} syntax:




\begin{lstlisting}
!!! note

    This is the content of the note.

!!! warning "Beware!"

    And this is another one.

    This warning admonition has a custom title: `"Beware!"`.
\end{lstlisting}



The type of the admonition can be any word made up of only lowercase Latin characters (a-z), but some types produce special styling, namely (in order of decreasing severity): \texttt{danger}, \texttt{warning}, \texttt{info}, \texttt{note}, and \texttt{tip}.



A custom title for the box can be provided as a string (in double quotes) after the admonition type. For that standard types (\texttt{danger}, \texttt{warning}... etc\_, if no title text is specified after the admonition type, then the type title used will be the type of the block. E.g. \texttt{{\textquotedbl}Note{\textquotedbl}} in the case of the \texttt{note} admonition.



If you would like to define your own block, for example a \texttt{terminology}  block used like so:




\begin{lstlisting}
!!! terminology "julia vs Julia"
    Strictly speaking, Julia refers to the language,
    and julia the standard implementation.
\end{lstlisting}



Admonitions, like most other toplevel elements, can contain other toplevel elements.



\hypertarget{10627994621615977524}{}


\section{Markdown Syntax Extensions}



Julia{\textquotesingle}s markdown supports interpolation in a very similar way to basic string literals, with the difference that it will store the object itself in the Markdown tree (as opposed to converting it to a string). When the Markdown content is rendered the usual \texttt{show} methods will be called, and these can be overridden as usual. This design allows the Markdown to be extended with arbitrarily complex features (such as references) without cluttering the basic syntax.



In principle, the Markdown parser itself can also be arbitrarily extended by packages, or an entirely custom flavour of Markdown can be used, but this should generally be unnecessary.



\hypertarget{1528138219436012362}{}


\chapter{内存映射 I/O}


\hypertarget{8426825172443272214}{} 
\hyperlink{8426825172443272214}{\texttt{Mmap.Anonymous}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Mmap.Anonymous(name::AbstractString="", readonly::Bool=false, create::Bool=true)
\end{minted}

Create an \texttt{IO}-like object for creating zeroed-out mmapped-memory that is not tied to a file for use in \hyperlink{1028440884226576897}{\texttt{Mmap.mmap}}. Used by \texttt{SharedArray} for creating shared memory arrays.

\textbf{Examples}


\begin{minted}{jlcon}
julia> anon = Mmap.Anonymous();

julia> isreadable(anon)
true

julia> iswritable(anon)
true

julia> isopen(anon)
true
\end{minted}



\end{adjustwidth}
\hypertarget{1028440884226576897}{} 
\hyperlink{1028440884226576897}{\texttt{Mmap.mmap}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Mmap.mmap(io::Union{IOStream,AbstractString,Mmap.AnonymousMmap}[, type::Type{Array{T,N}}, dims, offset]; grow::Bool=true, shared::Bool=true)
Mmap.mmap(type::Type{Array{T,N}}, dims)
\end{minted}

Create an \texttt{Array} whose values are linked to a file, using memory-mapping. This provides a convenient way of working with data too large to fit in the computer{\textquotesingle}s memory.

The type is an \texttt{Array\{T,N\}} with a bits-type element of \texttt{T} and dimension \texttt{N} that determines how the bytes of the array are interpreted. Note that the file must be stored in binary format, and no format conversions are possible (this is a limitation of operating systems, not Julia).

\texttt{dims} is a tuple or single \hyperlink{8469131683393450448}{\texttt{Integer}} specifying the size or length of the array.

The file is passed via the stream argument, either as an open \hyperlink{12496894737220238417}{\texttt{IOStream}} or filename string. When you initialize the stream, use \texttt{{\textquotedbl}r{\textquotedbl}} for a {\textquotedbl}read-only{\textquotedbl} array, and \texttt{{\textquotedbl}w+{\textquotedbl}} to create a new array used to write values to disk.

If no \texttt{type} argument is specified, the default is \texttt{Vector\{UInt8\}}.

Optionally, you can specify an offset (in bytes) if, for example, you want to skip over a header in the file. The default value for the offset is the current stream position for an \texttt{IOStream}.

The \texttt{grow} keyword argument specifies whether the disk file should be grown to accommodate the requested size of array (if the total file size is < requested array size). Write privileges are required to grow the file.

The \texttt{shared} keyword argument specifies whether the resulting \texttt{Array} and changes made to it will be visible to other processes mapping the same file.

For example, the following code


\begin{minted}{julia}
# Create a file for mmapping
# (you could alternatively use mmap to do this step, too)
A = rand(1:20, 5, 30)
s = open("/tmp/mmap.bin", "w+")
# We'll write the dimensions of the array as the first two Ints in the file
write(s, size(A,1))
write(s, size(A,2))
# Now write the data
write(s, A)
close(s)

# Test by reading it back in
s = open("/tmp/mmap.bin")   # default is read-only
m = read(s, Int)
n = read(s, Int)
A2 = Mmap.mmap(s, Matrix{Int}, (m,n))
\end{minted}

creates a \texttt{m}-by-\texttt{n} \texttt{Matrix\{Int\}}, linked to the file associated with stream \texttt{s}.

A more portable file would need to encode the word size – 32 bit or 64 bit – and endianness information in the header. In practice, consider encoding binary data using standard formats like HDF5 (which can be used with memory-mapping).




\begin{lstlisting}
Mmap.mmap(io, BitArray, [dims, offset])
\end{lstlisting}

Create a \hyperlink{18015155802543401629}{\texttt{BitArray}} whose values are linked to a file, using memory-mapping; it has the same purpose, works in the same way, and has the same arguments, as \hyperlink{1028440884226576897}{\texttt{mmap}}, but the byte representation is different.

\textbf{Examples}


\begin{minted}{jlcon}
julia> io = open("mmap.bin", "w+");

julia> B = Mmap.mmap(io, BitArray, (25,30000));

julia> B[3, 4000] = true;

julia> Mmap.sync!(B);

julia> close(io);

julia> io = open("mmap.bin", "r+");

julia> C = Mmap.mmap(io, BitArray, (25,30000));

julia> C[3, 4000]
true

julia> C[2, 4000]
false

julia> close(io)

julia> rm("mmap.bin")
\end{minted}

This creates a 25-by-30000 \texttt{BitArray}, linked to the file associated with stream \texttt{io}.



\end{adjustwidth}
\hypertarget{10364432000624675045}{} 
\hyperlink{10364432000624675045}{\texttt{Mmap.sync!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Mmap.sync!(array)
\end{minted}

Forces synchronization between the in-memory version of a memory-mapped \texttt{Array} or \hyperlink{18015155802543401629}{\texttt{BitArray}} and the on-disk version.



\end{adjustwidth}

\hypertarget{16222174321033129856}{}


\chapter{Pkg}



\hypertarget{7253998760451691688}{}


\section{介绍}



Pkg 是 Julia 1.0 及后续新版本的标准包管理器。与那些安装和管理单个全局软件包集的传统包管理器不同，Pkg 是围绕「环境」设计的。每个项目都有一套独立与其他项目的软件包集合。同一个软件包也可以在多个项目中通过名字共享。项目环境的软件包信息是保存在 \emph{清单文件} 里的。清单文件确切的描述了每一个依赖软件包和它的版本。清单文件可以检入项目存储库并在版本控制中进行跟踪，从而显着提高项目的可重复性。如果你曾经试图运行一段时间未曾使用过的代码，但发现其完全无法工作，而这只是因为你更新或卸载了项目使用的一些软件包，那么你会理解这种方法的意图。在 Pkg 中，由于每个项目都维护着各自独立的软件包集，你再也不会遇到这个问题了。 此外，如果你签出项目到新系统中，搭建出其清单文件所描述的环境将会非常地简单，并且你可以立即启动和并运行该项目，因为我们知道项目依赖项是好的。



由于项目包环境是彼此独立地进行管理和更新的， Pkg 显著地缓解了「依赖地狱」问题。你如果想在新项目中使用最新、最棒的包，但在另一个项目中却卡在了使用旧版本的包，那也没问题——因为它们的环境是彼此分离的，不同项目可以使用装在系统的不同位置的不同版本的包。每个版本的包的位置都是规范的，所以当多个环境使用的包版本相同时，它们可以共享同一安装包，这就避免不必要的重复安装。不被任何环境使用的老旧版本的包，会被包管理器定期「垃圾收集」掉。



Pkg 对本地环境的处理方法可能让曾经使用过 Python 的 \texttt{virtualenv} 或 Ruby 的 \texttt{bundler} 的人感到熟悉。在 Julia 中，我们不仅没有通过破解语言的代码加载机制来支持环境，而且还有 Julia 本身就理解它们的好处。此外，Julia 环境是「可堆叠的」：你可以将一个环境叠加在另一个环境上，从而可以访问主环境之外的其它包。这使得更容易在提供主环境的项目上工作，同时依然访问所有你常用的开发工具，如分析器、调试器等，这只需在加载路径中更后地包含具有这些开发环境的路径。



Last but not least, Pkg is designed to support federated package registries. This means that it allows multiple registries managed by different parties to interact seamlessly. In particular, this includes private registries which can live behind corporate firewalls. You can install and update your own packages from a private registry with exactly the same tools and workflows that you use to install and manage official Julia packages. If you urgently need to apply a hotfix for a public package that’s critical to your company’s product, you can tag a private version of it in your company’s internal registry and get a fix to your developers and ops teams quickly and easily without having to wait for an upstream patch to be accepted and published. Once an official fix is published, however, you can just upgrade your dependencies and you{\textquotesingle}ll be back on an official release again.



\hypertarget{11820197359252038124}{}


\section{词汇表}



\textbf{项目（Project）：}一个具有标准布局的源代码树，包括了用来放置主要的 Julia 代码的 \texttt{src} 目录、用来放置测试的 \texttt{test} 目录、用来放置文档的 \texttt{docs} 目录和可选的用来放置构建脚本及其输出的 \texttt{deps} 目录。项目通常有一个项目文件和一个可选的清单文件：



\begin{itemize}
\item \textbf{项目文件（Project file）：}一个在项目根目录下的文件，叫做 \texttt{Project.toml}（或 \texttt{JuliaProject.toml}），用来描述项目的元数据，包括项目的名称、UUID（针对包）、作者、许可证和它所依赖的包和库的名称及 UUID。


\item \textbf{清单文件（Manifest file）：}一个在项目根目录下的文件，叫做 \texttt{Manifest.toml}（或 \texttt{JuliaManifest.toml}），用来描述完整的依赖关系图、每个包的确切版本以及项目使用的库。

\end{itemize}


\textbf{包（Package）：}一个提供可重用功能的项目，其它 Julia 项目可以同 \texttt{import X} 或 \texttt{using X} 使用它。一个包应该包含一个具有 \texttt{uuid} 条目（此条目给出该包 UUID）的项目文件。此 UUID 用于在依赖它的项目中标识该包。



\begin{quote}
\textbf{Note}

由于历史原因，可以在 REPL 或脚本的顶级中加载没有项目文件或 UUID 的包。但是，无法在具有项目文件或 UUID 的项目中加载没有它们的包。一旦你曾从项目文件加载包，所有包就都需要项目文件和 UUID。

\end{quote}


\textbf{应用（application）：}一个提供独立功能的项目，不打算被其它 Julia 项目重用。例如，Web 应用、命令行工具或者科学论文附带的模拟或分析代码。应用可以有 UUID 但也可以没有。应用还可以为其所依赖的包提供全局配置选项。另一方面，包不可能提供全局配置，因为这可能与主应用的配置相冲突。



\begin{quote}
\textbf{Note}

\textbf{项目 \emph{vs.} 包 \emph{vs.} 应用：}

\begin{itemize}
\item[1. ] \textbf{项目}是一个总称：包和应用都是一种项目。


\item[2. ] \textbf{包}应该有 UUID，而应用可以有也可以没有。


\item[3. ] \textbf{应用}可以提供全局的配置，而包不行。

\end{itemize}
\end{quote}


\textbf{Library (future work):} a compiled binary dependency (not written in Julia) packaged to be used by a Julia project. These are currently typically built in- place by a \texttt{deps/build.jl} script in a project’s source tree, but in the future we plan to make libraries first-class entities directly installed and upgraded by the package manager.



\textbf{环境（Environment）：}项目文件和清单文件的组合，项目文件与依赖关系图相结合后提供了顶级名称映射，而清单文件提供了包到它们入口点的映射。有关的详细信息，请参阅手册中代码加载的相关章节。



\begin{itemize}
\item \textbf{显式环境（Explicit environment）：}在同一目录下具有显式的项目文件和可选的与其对应的清单文件。如果清单文件不存在，那么隐含的依赖关系图和位置映射为空。


\item \textbf{隐式环境（Implicit environment）：}作为目录提供的环境（没有项目文件或清单文件），此目录包含包且包含的包具有形式为 \texttt{X.jl}、\texttt{X.jl/src/X.jl} 或 \texttt{X/src/X.jl} 的入口点，这些包的入口点隐含了顶级名称映射。依赖关系图隐含在这些包所在目录的项目文件里，例如 \texttt{X.jl/Project.toml} 或 \texttt{X/Project.toml}。如果 \texttt{X} 存在对应的项目文件，则其依赖关系就是其项目文件的依赖关系。入口点本身就隐含了位置映射。

\end{itemize}


\textbf{Registry:} a source tree with a standard layout recording metadata about a registered set of packages, the tagged versions of them which are available, and which versions of packages are compatible or incompatible with each other. A registry is indexed by package name and UUID, and has a directory for each registered package providing the following metadata about it:



\begin{itemize}
\item name——例如 \texttt{DataFrames}


\item UUID——例如 \texttt{a93c6f00-e57d-5684-b7b6-d8193f3e46c0}


\item authors——例如 \texttt{Jane Q. Developer <jane@example.com>}


\item license——例如 MIT，BSD3 或 GPLv2


\item repository——例如 \texttt{https://github.com/JuliaData/DataFrames.jl.git}


\item description——一个总结包功能的文本块


\item keywords——例如 \texttt{data}，\texttt{tabular}，\texttt{analysis}，\texttt{statistics}


\item versions——所有已注册版本的标签列表

\end{itemize}


每个包的已注册版本都会提供以下信息：



\begin{itemize}
\item its semantic version number – e.g. \texttt{v1.2.3}


\item its git tree SHA-1 hash – e.g. \texttt{7ffb18ea3245ef98e368b02b81e8a86543a11103}


\item a map from names to UUIDs of dependencies


\item which versions of other packages it is compatible/incompatible with

\end{itemize}


Dependencies and compatibility are stored in a compressed but human-readable format using ranges of package versions.



\textbf{Depot:} a directory on a system where various package-related resources live, including:



\begin{itemize}
\item \texttt{environments}: shared named environments (e.g. \texttt{v0.7}, \texttt{devtools})


\item \texttt{clones}: bare clones of package repositories


\item \texttt{compiled}: cached compiled package images (\texttt{.ji} files)


\item \texttt{config}: global configuration files (e.g. \texttt{startup.jl})


\item \texttt{dev}: default directory for package development


\item \texttt{logs}: log files (e.g. \texttt{manifest\_usage.toml}, \texttt{repl\_history.jl})


\item \texttt{packages}: installed package versions


\item \texttt{registries}: clones of registries (e.g. \texttt{General})

\end{itemize}


\textbf{Load path:} a stack of environments where package identities, their dependencies, and entry-points are searched for. The load path is controlled in Julia by the \texttt{LOAD\_PATH} global variable which is populated at startup based on the value of the \texttt{JULIA\_LOAD\_PATH} environment variable. The first entry is your primary environment, often the current project, while later entries provide additional packages one may want to use from the REPL or top-level scripts.



\textbf{Depot path:} a stack of depot locations where the package manager, as well as Julia{\textquotesingle}s code loading mechanisms, look for registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files. The depot path is controlled by the Julia \texttt{DEPOT\_PATH} global variable which is populated at startup based on the value of the \texttt{JULIA\_DEPOT\_PATH} environment variable. The first entry is the “user depot” and should be writable by and owned by the current user. The user depot is where: registries are cloned, new package versions are installed, named environments are created and updated, package repos are cloned, newly compiled package image files are saved, log files are written, development packages are checked out by default, and global configuration data is saved. Later entries in the depot path are treated as read-only and are appropriate for registries, packages, etc. installed and managed by system administrators.



\hypertarget{4066476927559720001}{}


\section{入门}



在 Julia REPL 中使用 \texttt{]} 键即可进入 Pkg 模式。




\begin{lstlisting}
(v0.7) pkg>
\end{lstlisting}



提示符括号内的部分显示当前项目的名称。由于我们尚未创建自己的项目，我们正处于默认项目中，其位于 \texttt{{\textasciitilde}/.julia/environments/v0.7}（或任何你恰巧在运行的 Julia 版本）。



要返回 \texttt{julia>} 提示符，请在输入行为空时按退格键或直接按 Ctrl+C。可通过调用 \texttt{pkg>help} 获得帮助。如果你所处的环境无法访问 PEPL，你仍可以通过字符串宏 \texttt{pkg}（其在 \texttt{using Pkg} 后可用）使用 REPL 模式的命令。命令 \texttt{pkg{\textquotedbl}cms{\textquotedbl}} 将等价于在 RPEL 模式中执行 \texttt{cmd}。



此处的文档介绍了如何使用 REPL 的 Pkg 模式。使用 Pkg API（通过调用 \texttt{Pkg.} 函数）的文档正在编写中。



\hypertarget{17544737972677030323}{}


\subsection{添加包}



有两种方法可以添加包，分别是使用 \texttt{add} 命令和 \texttt{dev} 命令。最常用的是 \texttt{add}，我们首先介绍它的用法。



\hypertarget{8492524675297016695}{}


\subsubsection{添加已注册的包}



在 REPL 的 Pkg 模式中，添加包可以使用 \texttt{add} 命令，其后接包的名称，例如：




\begin{lstlisting}
(v0.7) pkg> add Example
   Cloning default registries into /Users/kristoffer/.julia/registries
   Cloning registry General from "https://github.com/JuliaRegistries/General.git"
  Updating registry at `~/.julia/registries/General`
  Updating git-repo `https://github.com/JuliaRegistries/General.git`
 Resolving package versions...
  Updating `~/.julia/environments/v0.7/Project.toml`
  [7876af07] + Example v0.5.1
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [7876af07] + Example v0.5.1
  [8dfed614] + Test
\end{lstlisting}



在这里，我们将包 Example 添加到当前项目中。此例中，我们使用的是全新的 Julia 安装，并且这是我们第一次使用 Pkg 添加包。默认情况下，Pkg 会克隆 Julia 的 General 注册表，并使用此注册表来查找需要包含在当前环境中的包。状态更新在左侧显示了简短形式的包 UUID，接着是包名称和版本号。因为标准库（例如 \texttt{Test}）随 Julia 一起提供，所以它们没有版本号。项目状态包含你自己添加的包，在此例中为 \texttt{Example}：




\begin{lstlisting}
(v0.7) pkg> st
    Status `Project.toml`
  [7876af07] Example v0.5.1
\end{lstlisting}



此外，清单状态包含了显式添加的包的依赖项。




\begin{lstlisting}
(v0.7) pkg> st --manifest
    Status `Manifest.toml`
  [7876af07] Example v0.5.1
  [8dfed614] Test
\end{lstlisting}



可以在一次命令中添加多个包，例如 \texttt{pkg> add A B C}。



在包已添加进项目中后，可在 Julia 中加载它：




\begin{lstlisting}
julia> using Example

julia> Example.hello("User")
"Hello, User"
\end{lstlisting}



可以通过在 \texttt{@} 符号后附加版本号来安装特定版本，例如在包名称后附加 \texttt{@v0.4}：




\begin{lstlisting}
(v0.7) pkg> add Example@0.4
 Resolving package versions...
  Updating `~/.julia/environments/v0.7/Project.toml`
  [7876af07] + Example v0.4.1
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [7876af07] + Example v0.4.1
\end{lstlisting}



如果 \texttt{Example} 的主分支（或某个提交 SHA）有尚未包含在已注册版本中的修补程序，我们可以通过在包名称后附加 \texttt{\#branch}（或 \texttt{\#commit}）来显式跟踪该分支（或提交）：




\begin{lstlisting}
(v0.7) pkg> add Example#master
  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`
 Resolving package versions...
  Updating `~/.julia/environments/v0.7/Project.toml`
  [7876af07] ~ Example v0.5.1 ⇒ v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git)
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [7876af07] ~ Example v0.5.1 ⇒ v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git)
\end{lstlisting}



状态输出现在显示我们正在跟踪 \texttt{Example} 的 \texttt{master} 分支。在更新包时，我们将从该分支中拉取更新。



要返回到跟踪 \texttt{Example} 的注册表版本，请使用 \texttt{free} 命令：




\begin{lstlisting}
(v0.7) pkg> free Example
 Resolving package versions...
  Updating `~/.julia/environments/v0.7/Project.toml`
  [7876af07] ~ Example v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git) ⇒ v0.5.1
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [7876af07] ~ Example v0.5.1+ #master )https://github.com/JuliaLang/Example.jl.git) ⇒ v0.5.1
\end{lstlisting}



\hypertarget{16019413810897191556}{}


\subsubsection{添加未注册包}



如果某个包不在注册表中，通过将其存储库的 URL 传给 \texttt{add} 而不是包名称，仍然可以添加它。




\begin{lstlisting}
(v0.7) pkg> add https://github.com/fredrikekre/ImportMacros.jl
  Updating git-repo `https://github.com/fredrikekre/ImportMacros.jl`
 Resolving package versions...
Downloaded MacroTools ─ v0.4.1
  Updating `~/.julia/environments/v0.7/Project.toml`
  [e6797606] + ImportMacros v0.0.0 # (https://github.com/fredrikekre/ImportMacros.jl)
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [e6797606] + ImportMacros v0.0.0 # (https://github.com/fredrikekre/ImportMacros.jl)
  [1914dd2f] + MacroTools v0.4.1
\end{lstlisting}



可以看到，未注册包的依赖项（此处为 \texttt{MacroTools}）已被添加。对于未注册包，我们可以使用 \texttt{\#} 来给定一个分支（或 commit SHA）来进行跟踪，就像已注册包一样。



\hypertarget{7534124019894702517}{}


\subsubsection{添加本地包}



我们可以将一个 git 存储库的本地路径传给 \texttt{add} 而不是其 URL，其效果类似于传 URL。该本地存储库（的某个分支）会被跟踪，并在包更新时从已拉取的本地存储库中获取更新。请注意，本地包存储库中的文件更改不会在包加载时立即反映出来。为了拉取更改，必须提交该更改并更新包。



\hypertarget{14425308659963754723}{}


\subsubsection{开发包}



仅使用 \texttt{add} 会让你的清单始终为「可再现状态」，换句话说，只要所使用的存储库和注册表仍然可以访问，就可以检索出项目中所有依赖项的确切状态。这样做的好处是你可以将你的项目（\texttt{Project.toml} 和 \texttt{Manifest.toml}）发送该其他人，然后他们可以该项目「实例化」到与你本地项目相同的状态。但是，当你在开发包时，在某个路径上以当前状态加载包会更方便。因此，命令 \texttt{dev} 有存在必要。



让我们来尝试 \texttt{dev} 一个已注册的包：




\begin{lstlisting}
(v0.7) pkg> dev Example
  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`
 Resolving package versions...
  Updating `~/.julia/environments/v0.7/Project.toml`
  [7876af07] + Example v0.5.1+ [`~/.julia/dev/Example`]
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [7876af07] + Example v0.5.1+ [`~/.julia/dev/Example`]
\end{lstlisting}



\texttt{dev} 命令会获取包的完整克隆到 \texttt{{\textasciitilde}/.julia/dev/} 目录下（可通过设置环境变量 \texttt{JULIA\_PKG\_DEVDIR} 来更改此路径）。在导入 \texttt{Example} 时，julia 现在将从 \texttt{{\textasciitilde}/.julia/dev/Example} 导入它，并且该路径下文件的所有本地更改都将反映在加载的代码中。在使用 \texttt{add} 时，我们说我们跟踪了包存储库，在这里则说我们跟踪了路径本身。请注意，包管理器永远不会触碰已跟踪路径上的任何文件。因此，需要你自己拉取更新、更改分支等。如果我们尝试 \texttt{dev} 包的某个已经存在于 \texttt{{\textasciitilde}/.julia/dev/} 里的分支，则包管理器只会使用已存在的路径。例如：




\begin{lstlisting}
(v0.7) pkg> dev Example
  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`
[ Info: Path `/Users/kristoffer/.julia/dev/Example` exists and looks like the correct package, using existing path instead of cloning
\end{lstlisting}



请注意，info 信息表明它正在使用现有路径。一般来说，包管理器不会触碰正在跟踪的路径文件。



如果在本地路径上使用 \texttt{dev}，则该包的路径会被记录并在该包加载时使用之。除非该路径以绝对路径的形式给出，否则它会以相对于项目文件的形式记录下来。



要停止跟踪路径并再次使用已注册版本，请使用 \texttt{free}




\begin{lstlisting}
(v0.7) pkg> free Example
 Resolving package versions...
  Updating `~/.julia/environments/v0.7/Project.toml`
  [7876af07] ↓ Example v0.5.1+ [`~/.julia/dev/Example`] ⇒ v0.5.1
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [7876af07] ↓ Example v0.5.1+ [`~/.julia/dev/Example`] ⇒ v0.5.1
\end{lstlisting}



值得提及的是，通过使用 \texttt{dev}，你的项目现在具有其内在状态。其状态取决于该路径中文件的当前内容，并且在不知道所跟踪路径中所有包的确切内容的情况下，其他人无法「实例化」清单。



Note that if you add a dependency to a package that tracks a local path, the Manifest (which contains the whole dependency graph) will become out of sync with the actual dependency graph. This means that the package will not be able to load that dependency since it is not recorded in the Manifest. To update sync the Manifest, use the REPL command \texttt{resolve}.



\hypertarget{11999055779830288138}{}


\subsection{删除包}



通过使用 \texttt{pkg> rm Package}，可从当前项目中删除包。这只会删除已存在于项目中的包，要删除仅作为依赖项的包，请使用 \texttt{pkg> rm --manifest DepPackage}。请注意，这会删除所有依赖于 \texttt{DepPackage} 的包。



\hypertarget{682348977546152420}{}


\subsection{更新包}



当项目正在使用的包发布新版本时，最好进行更新。简单地调用 \texttt{up} 会尝试将项目的\emph{所有}依赖项更新到最新的兼容版本。有时这并不是你想要的。通过将依赖项子集作为参数传给 \texttt{up}，你可以指定要升级的依赖项，例如




\begin{lstlisting}
(v0.7) pkg> up Example
\end{lstlisting}



所有其他包直接依赖项的版本会保持不变。如果你为了降低项目中断的风险，只想要更新包的次版本号，你可以加上 \texttt{--minor} 标志，例如：




\begin{lstlisting}
(v0.7) pkg> up --minor Example
\end{lstlisting}



跟踪存储库的包在进行次要更新时不会被更新，而跟踪路径的包永远不会被包管理器所触及。



\hypertarget{2188017839608631681}{}


\subsection{Pinning a package}



A pinned package will never be updated. A package can be pinned using \texttt{pin} as for example




\begin{lstlisting}
(v0.7) pkg> pin Example
 Resolving package versions...
  Updating `~/.julia/environments/v0.7/Project.toml`
  [7876af07] ~ Example v0.5.1 ⇒ v0.5.1 ⚲
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [7876af07] ~ Example v0.5.1 ⇒ v0.5.1 ⚲
\end{lstlisting}



Note the pin symbol \texttt{⚲} showing that the package is pinned. Removing the pin is done using \texttt{free}




\begin{lstlisting}
(v0.7) pkg> free Example
  Updating `~/.julia/environments/v0.7/Project.toml`
  [7876af07] ~ Example v0.5.1 ⚲ ⇒ v0.5.1
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [7876af07] ~ Example v0.5.1 ⚲ ⇒ v0.5.1
\end{lstlisting}



\hypertarget{6952888041784542494}{}


\subsection{测试包}



包的测试可通过 \texttt{test} 命令来运行：




\begin{lstlisting}
(v0.7) pkg> test Example
   Testing Example
   Testing Example tests passed
\end{lstlisting}



\hypertarget{1142310729597694114}{}


\subsection{构建包}



第一次安装某个包时，会自动执行该包的构建步骤。构建过程的输出会被重定向到文件中。要显式执行包的构建步骤，请使用 \texttt{build} 命令：




\begin{lstlisting}
(v0.7) pkg> build MbedTLS
  Building MbedTLS → `~/.julia/packages/MbedTLS/h1Vu/deps/build.log`

shell> cat ~/.julia/packages/MbedTLS/h1Vu/deps/build.log
┌ Warning: `wait(t::Task)` is deprecated, use `fetch(t)` instead.
│   caller = macro expansion at OutputCollector.jl:63 [inlined]
└ @ Core OutputCollector.jl:63
...
[ Info: using prebuilt binaries
\end{lstlisting}



\hypertarget{9268299237854436907}{}


\section{Creating your own projects}



So far we have added packages to the default project at \texttt{{\textasciitilde}/.julia/environments/v0.7}, it is, however, easy to create other, independent, projects. It should be pointed out if two projects uses the same package at the same version, the content of this package is not duplicated. In order to create a new project, create a directory for it and then activate that directory to make it the {\textquotedbl}active project{\textquotedbl} which package operations manipulate:




\begin{lstlisting}
shell> mkdir MyProject

shell> cd MyProject
/Users/kristoffer/MyProject

(v0.7) pkg> activate .

(MyProject) pkg> st
    Status `Project.toml`
\end{lstlisting}



Note that the REPL prompt changed when the new project is activated. Since this is a newly created project, the status command show it contains no packages, and in fact, it has no project or manifest file until we add a package to it:




\begin{lstlisting}
shell> ls -l
total 0

(MyProject) pkg> add Example
  Updating registry at `~/.julia/registries/General`
  Updating git-repo `https://github.com/JuliaRegistries/General.git`
 Resolving package versions...
  Updating `Project.toml`
  [7876af07] + Example v0.5.1
  Updating `Manifest.toml`
  [7876af07] + Example v0.5.1
  [8dfed614] + Test

shell> ls -l
total 8
-rw-r--r-- 1 stefan staff 207 Jul  3 16:35 Manifest.toml
-rw-r--r-- 1 stefan staff  56 Jul  3 16:35 Project.toml

shell> cat Project.toml
[deps]
Example = "7876af07-990d-54b4-ab0e-23690620f79a"

shell> cat Manifest.toml
[[Example]]
deps = ["Test"]
git-tree-sha1 = "8eb7b4d4ca487caade9ba3e85932e28ce6d6e1f8"
uuid = "7876af07-990d-54b4-ab0e-23690620f79a"
version = "0.5.1"

[[Test]]
uuid = "8dfed614-e22c-5e08-85e1-65c5234f0b40"
\end{lstlisting}



This new environment is completely separate from the one we used earlier.



\hypertarget{5812058120249017191}{}


\section{垃圾收集旧的、不再使用的包}



随着包的更新和项目被删除，曾经使用的已安装的包将不可避免地变旧，并且不被用于任何现有项目。Pkg 会记录所有已使用项目的日志，这样便可通过遍历日志，明确知道哪些项目仍然存在以及这些项目使用了哪些包，剩下的包则会被删除。命令 \texttt{gc} 可执行此操作：




\begin{lstlisting}
(v0.7) pkg> gc
    Active manifests at:
        `/Users/kristoffer/BinaryProvider/Manifest.toml`
        ...
        `/Users/kristoffer/Compat.jl/Manifest.toml`
   Deleted /Users/kristoffer/.julia/packages/BenchmarkTools/1cAj: 146.302 KiB
   Deleted /Users/kristoffer/.julia/packages/Cassette/BXVB: 795.557 KiB
   ...
   Deleted /Users/kristoffer/.julia/packages/WeakRefStrings/YrK6: 27.328 KiB
   Deleted 36 package installations: 113.205 MiB
\end{lstlisting}



请注意，只有在 \texttt{{\textasciitilde}/.julia/packages} 中的包才会被删除。



\hypertarget{5867084990704441204}{}


\section{Creating your own packages}



A package is a project with a \texttt{name}, \texttt{uuid} and \texttt{version} entry in the \texttt{Project.toml} file \texttt{src/PackageName.jl} file that defines the module \texttt{PackageName}. This file is executed when the package is loaded.



\hypertarget{14149589589287981755}{}


\subsection{Generating files for a package}



To generate files for a new package, use \texttt{pkg> generate}.




\begin{lstlisting}
(v0.7) pkg> generate HelloWorld
\end{lstlisting}



This creates a new project \texttt{HelloWorld} with the following files (visualized with the external \href{https://linux.die.net/man/1/tree}{\texttt{tree} command}):




\begin{lstlisting}
shell> cd HelloWorld

shell> tree .
.
├── Project.toml
└── src
    └── HelloWorld.jl

1 directory, 2 files
\end{lstlisting}



The \texttt{Project.toml} file contains the name of the package, its unique UUID, its version, the author and eventual dependencies:




\begin{lstlisting}
name = "HelloWorld"
uuid = "b4cd1eb8-1e24-11e8-3319-93036a3eb9f3"
version = "0.1.0"
author = ["Some One <someone@email.com>"]

[deps]
\end{lstlisting}



The content of \texttt{src/HelloWorld.jl} is:




\begin{lstlisting}
module HelloWorld

greet() = print("Hello World!")

end # module
\end{lstlisting}



We can now activate the project and load the package:




\begin{lstlisting}
pkg> activate .

julia> import HelloWorld

julia> HelloWorld.greet()
Hello World!
\end{lstlisting}



\hypertarget{15262021635183704764}{}


\subsection{Adding dependencies to the project}



Let’s say we want to use the standard library package \texttt{Random} and the registered package \texttt{JSON} in our project. We simply \texttt{add} these packages (note how the prompt now shows the name of the newly generated project, since we are inside the \texttt{HelloWorld} project directory):




\begin{lstlisting}
(HelloWorld) pkg> add Random JSON
 Resolving package versions...
  Updating "~/Documents/HelloWorld/Project.toml"
 [682c06a0] + JSON v0.17.1
 [9a3f8284] + Random
  Updating "~/Documents/HelloWorld/Manifest.toml"
 [34da2185] + Compat v0.57.0
 [682c06a0] + JSON v0.17.1
 [4d1e1d77] + Nullables v0.0.4
 ...
\end{lstlisting}



Both \texttt{Random} and \texttt{JSON} got added to the project’s \texttt{Project.toml} file, and the resulting dependencies got added to the \texttt{Manifest.toml} file. The resolver has installed each package with the highest possible version, while still respecting the compatibility that each package enforce on its dependencies.



We can now use both \texttt{Random} and \texttt{JSON} in our project. Changing \texttt{src/HelloWorld.jl} to




\begin{lstlisting}
module HelloWorld

import Random
import JSON

greet() = print("Hello World!")
greet_alien() = print("Hello ", Random.randstring(8))

end # module
\end{lstlisting}



and reloading the package, the new \texttt{greet\_alien} function that uses \texttt{Random} can be used:




\begin{lstlisting}
julia> HelloWorld.greet_alien()
Hello aT157rHV
\end{lstlisting}



\hypertarget{7089821536805504415}{}


\subsection{Adding a build step to the package.}



The build step is executed the first time a package is installed or when explicitly invoked with \texttt{build}. A package is built by executing the file \texttt{deps/build.jl}.




\begin{lstlisting}
shell> cat deps/build.log
I am being built...

(HelloWorld) pkg> build
  Building HelloWorld → `deps/build.log`
 Resolving package versions...

shell> cat deps/build.log
I am being built...
\end{lstlisting}



If the build step fails, the output of the build step is printed to the console




\begin{lstlisting}
shell> cat deps/build.jl
error("Ooops")

(HelloWorld) pkg> build
  Building HelloWorld → `deps/build.log`
 Resolving package versions...
┌ Error: Error building `HelloWorld`:
│ ERROR: LoadError: Ooops
│ Stacktrace:
│  [1] error(::String) at ./error.jl:33
│  [2] top-level scope at none:0
│  [3] include at ./boot.jl:317 [inlined]
│  [4] include_relative(::Module, ::String) at ./loading.jl:1071
│  [5] include(::Module, ::String) at ./sysimg.jl:29
│  [6] include(::String) at ./client.jl:393
│  [7] top-level scope at none:0
│ in expression starting at /Users/kristoffer/.julia/dev/Pkg/HelloWorld/deps/build.jl:1
└ @ Pkg.Operations Operations.jl:938
\end{lstlisting}



\hypertarget{4923930195335946322}{}


\subsection{Adding tests to the package}



When a package is tested the file \texttt{test/runtests.jl} is executed.




\begin{lstlisting}
shell> cat test/runtests.jl
println("Testing...")
(HelloWorld) pkg> test
   Testing HelloWorld
 Resolving package versions...
Testing...
   Testing HelloWorld tests passed
\end{lstlisting}



\hypertarget{3762020746930282199}{}


\subsubsection{Test-specific dependencies}



Sometimes one might want to use some packages only at testing time but not enforce a dependency on them when the package is used. This is possible by adding dependencies to \texttt{[extras]} and a \texttt{test} target in \texttt{[targets]} to the Project file. Here we add the \texttt{Test} standard library as a test-only dependency by adding the following to the Project file:




\begin{lstlisting}
[extras]
Test = "8dfed614-e22c-5e08-85e1-65c5234f0b40"

[targets]
test = ["Test"]
\end{lstlisting}



We can now use \texttt{Test} in the test script and we can see that it gets installed on testing:




\begin{lstlisting}
shell> cat test/runtests.jl
using Test
@test 1 == 1

(HelloWorld) pkg> test
   Testing HelloWorld
 Resolving package versions...
  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Project.toml`
  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]
  [8dfed614] + Test
  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Manifest.toml`
  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]
   Testing HelloWorld tests passed```
\end{lstlisting}



\hypertarget{16280680646707854087}{}


\subsection{Compatibility}



Compatibility refers to the ability to restrict what version of the dependencies that your project is compatible with. If the compatibility for a dependency is not given, the project is assumed to be compatible with all versions of that dependency.



Compatibility for a dependency is entered in the \texttt{Project.toml} file as for example:




\begin{lstlisting}
[compat]
Example = "0.4.3"
\end{lstlisting}



After a compatibility entry is put into the project file, \texttt{up} can be used to apply it.



The format of the version specifier is described in detail below.



\begin{quote}
\textbf{Info}

There is currently no way to give compatibility from the Pkg REPL mode so for now, one has to manually edit the project file.

\end{quote}


\hypertarget{15488851848435252363}{}


\subsubsection{Version specifier format}



Similar to other package managers, the Julia package manager respects \href{https://semver.org/}{semantic versioning} (semver). As an example, a version specifier is given as e.g. \texttt{1.2.3} is therefore assumed to be compatible with the versions \texttt{[1.2.3 - 2.0.0)} where \texttt{)} is a non-inclusive upper bound. More specifically, a version specifier is either given as a \textbf{caret specifier}, e.g. \texttt{{\textasciicircum}1.2.3}  or a \textbf{tilde specifier} \texttt{{\textasciitilde}1.2.3}. Caret specifiers are the default and hence \texttt{1.2.3 == {\textasciicircum}1.2.3}. The difference between a caret and tilde is described in the next section. The intersection of multiple version specifiers can be formed by comma separating indiviual version specifiers.



\hypertarget{15797390643720760817}{}


\paragraph{Caret specifiers}



A caret specifier allows upgrade that would be compatible according to semver. An updated dependency is considered compatible if the new version does not modify the left-most non zero digit in the version specifier.



Some examples are shown below.




\begin{lstlisting}
^1.2.3 = [1.2.3, 2.0.0)
^1.2 = [1.2.0, 2.0.0)
^1 =  [1.0.0, 2.0.0)
^0.2.3 = [0.2.3, 0.3.0)
^0.0.3 = [0.0.3, 0.0.4)
^0.0 = [0.0.0, 0.1.0)
^0 = [0.0.0, 1.0.0)
\end{lstlisting}



While the semver specification says that all versions with a major version of 0 are incompatible with each other, we have made that choice that a version given as \texttt{0.a.b} is considered compatible with \texttt{0.a.c} if \texttt{a != 0} and  \texttt{c >= b}.



\hypertarget{15862646148226490878}{}


\paragraph{Tilde specifiers}



A tilde specifier provides more limited upgrade possibilities. With a tilde, only the last specified digit is allowed to increment by one. This gives the following example.




\begin{lstlisting}
~1.2.3 = [1.2.3, 1.2.4)
~1.2 = [1.2.0, 1.3.0)
~1 = [1.0.0, 2.0.0)
\end{lstlisting}



\hypertarget{3271687203032681122}{}


\subsubsection{Inequality specifiers}



Inequalities can also be used to specify version ranges:




\begin{lstlisting}
>= 1.2.3 = [1.2.3,  ∞)
≥ 1.2.3 = [1.2.3,  ∞)
= 1.2.3 = [1.2.3, 1.2.3]
< 1.2.3 = [0.0.0, 1.2.2]
\end{lstlisting}



\hypertarget{11268172833265643313}{}


\section{预编译项目}



REPL 命令 \texttt{precompile} 可用于预编译项目中的所有依赖。例如，这样做可以




\begin{lstlisting}
(HelloWorld) pkg> update; precompile
\end{lstlisting}



更新依赖项，然后预编译它们。



\hypertarget{1315229974566698548}{}


\section{预览模式}



如果你只想查看某个命令运行的效果，但不想更改包的状态，则可以 \texttt{preview} 该命令。例如：




\begin{lstlisting}
(HelloWorld) pkg> preview add Plots
\end{lstlisting}



或




\begin{lstlisting}
(HelloWorld) pkg> preview up
\end{lstlisting}



将向你展示添加 \texttt{Plots}、或者进行完全升级分别会对你的项目产生的影响。但是，这没有安装任何东西，也不会触及你的 \texttt{Project.toml} 和 \texttt{Manifest.toml}。



\hypertarget{6833241097141421015}{}


\section{使用别人的项目}



只需使用诸如 \texttt{git clone} 来克隆项目，接着 \texttt{cd} 到项目目录并调用




\begin{lstlisting}
(v0.7) pkg> activate .

(SomeProject) pkg> instantiate
\end{lstlisting}



如果该项目包含了清单，则会以与该清单给定的相同状态安装包。否则，它将解析为与项目兼容的最新版本的依赖项。



\hypertarget{13487828328085508990}{}


\section{References}



This section describes the {\textquotedbl}API mode{\textquotedbl} of interacting with Pkg.jl which is recommended for non-interactive usage, in i.e. scripts. In the REPL mode packages (with associated version, UUID, URL etc) are parsed from strings, for example, \texttt{{\textquotedbl}Package\#master{\textquotedbl}},\texttt{{\textquotedbl}Package@v0.1{\textquotedbl}}, \texttt{{\textquotedbl}www.mypkg.com/MyPkg\#my/feature{\textquotedbl}}. It is possible to use strings as arguments for simple commands in the API mode (like \texttt{Pkg.add([{\textquotedbl}PackageA{\textquotedbl}, {\textquotedbl}PackageB{\textquotedbl}])}, more complicated commands, that e.g. specify URLs or version range, uses a more structured format over strings. This is done by creating an instance of a \hyperlink{7769325907319883786}{\texttt{PackageSpec}} which are passed in to functions.


\hypertarget{7769325907319883786}{} 
\hyperlink{7769325907319883786}{\texttt{Pkg.PackageSpec}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
PackageSpec(name::String, [uuid::UUID, version::VersionNumber])
PackageSpec(; name, url, path, rev, version, mode, level)
\end{minted}

A \texttt{PackageSpec} is a representation of a package with various metadata. This includes:

\begin{itemize}
\item The \texttt{name} of the package.


\item The package{\textquotesingle}s unique \texttt{uuid}.


\item A \texttt{version} (for example when adding a package). When upgrading, can also be an instance of

\end{itemize}
the enum \hyperlink{13785530562686832335}{\texttt{UpgradeLevel}}.

\begin{itemize}
\item A \texttt{url} and an optional git \texttt{rev}ision. \texttt{rev} can be a branch name or a git commit SHA1.


\item A local \texttt{path}. This is equivalent to using the \texttt{url} argument but can be more descriptive.


\item A \texttt{mode}, which is an instance of the enum \hyperlink{3271836720350904911}{\texttt{PackageMode}}, with possible values \texttt{PKGMODE\_PROJECT}

\end{itemize}
(the default) or \texttt{PKGMODE\_MANIFEST}. Used in e.g. \hyperlink{4147981366221469810}{\texttt{Pkg.rm}}.

Most functions in Pkg take a \texttt{Vector} of \texttt{PackageSpec} and do the operation on all the packages in the vector.

Below is a comparison between the REPL version and the API version:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\texttt{REPL} & \texttt{API} \\
\hline
\texttt{Package} & \texttt{PackageSpec({\textquotedbl}Package{\textquotedbl})} \\
\hline
\texttt{Package@0.2} & \texttt{PackageSpec(name={\textquotedbl}Package{\textquotedbl}, version={\textquotedbl}0.2{\textquotedbl})} \\
\hline
\texttt{Package=a67d...} & \texttt{PackageSpec(name={\textquotedbl}Package{\textquotedbl}, uuid={\textquotedbl}a67d...{\textquotedbl})} \\
\hline
\texttt{Package\#master} & \texttt{PackageSpec(name={\textquotedbl}Package{\textquotedbl}, rev={\textquotedbl}master{\textquotedbl})} \\
\hline
\texttt{local/path\#feature} & \texttt{PackageSpec(path={\textquotedbl}local/path{\textquotedbl}; rev={\textquotedbl}feature{\textquotedbl})} \\
\hline
\texttt{www.mypkg.com} & \texttt{PackageSpec(url={\textquotedbl}www.mypkg.com{\textquotedbl})} \\
\hline
\texttt{--manifest Package} & \texttt{PackageSpec(name={\textquotedbl}Package{\textquotedbl}, mode=PKGSPEC\_MANIFEST)} \\
\hline
\texttt{--major Package} & \texttt{PackageSpec(name={\textquotedbl}Package{\textquotedbl}, version=PKGLEVEL\_MAJOR)} \\
\hline
\end{tabulary}

\end{table}



\end{adjustwidth}
\hypertarget{3271836720350904911}{} 
\hyperlink{3271836720350904911}{\texttt{Pkg.PackageMode}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
PackageMode
\end{minted}

An enum with the instances

\begin{itemize}
\item \texttt{PKGMODE\_MANIFEST}


\item \texttt{PKGMODE\_PROJECT}

\end{itemize}
Determines if operations should be made on a project or manifest level. Used as an argument to  \hyperlink{7769325907319883786}{\texttt{PackageSpec}} or as an argument to \hyperlink{4147981366221469810}{\texttt{Pkg.rm}}.



\end{adjustwidth}
\hypertarget{13785530562686832335}{} 
\hyperlink{13785530562686832335}{\texttt{Pkg.UpgradeLevel}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UpgradeLevel
\end{minted}

An enum with the instances

\begin{itemize}
\item \texttt{UPLEVEL\_FIXED}


\item \texttt{UPLEVEL\_PATCH}


\item \texttt{UPLEVEL\_MINOR}


\item \texttt{UPLEVEL\_MAJOR}

\end{itemize}
Determines how much a package is allowed to be updated. Used as an argument to  \hyperlink{7769325907319883786}{\texttt{PackageSpec}} or as an argument to \hyperlink{10543171283952432470}{\texttt{Pkg.update}}.



\end{adjustwidth}
\hypertarget{8338790878119011265}{} 
\hyperlink{8338790878119011265}{\texttt{Pkg.add}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Pkg.add(pkg::Union{String, Vector{String}}; preserve=PRESERVE_TIERED)
Pkg.add(pkg::Union{PackageSpec, Vector{PackageSpec}}; preserve=PRESERVE_TIERED)
\end{minted}

Add a package to the current project. This package will be available by using the \texttt{import} and \texttt{using} keywords in the Julia REPL, and if the current project is a package, also inside that package.

\textbf{Resolution Tiers}

\texttt{Pkg} resolves the set of packages in your environment using a tiered algorithm. The \texttt{preserve} keyword argument allows you to key into a specific tier in the resolve algorithm. The following table describes the argument values for \texttt{preserve} (in order of strictness):


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Value & Description \\
\hline
\texttt{PRESERVE\_ALL} & Preserve the state of all existing dependencies (including recursive dependencies) \\
\hline
\texttt{PRESERVE\_DIRECT} & Preserve the state of all existing direct dependencies \\
\hline
\texttt{PRESERVE\_SEMVER} & Preserve semver-compatible versions of direct dependencies \\
\hline
\texttt{PRESERVE\_NONE} & Do not attempt to preserve any version information \\
\hline
\texttt{PRESERVE\_TIERED} & Use the tier which will preserve the most version information (this is the default) \\
\hline
\end{tabulary}

\end{table}

\textbf{Examples}


\begin{minted}{julia}
Pkg.add("Example") # Add a package from registry
Pkg.add("Example"; preserve=Pkg.PRESERVE_ALL) # Add the `Example` package and preserve existing dependencies
Pkg.add(PackageSpec(name="Example", version="0.3")) # Specify version; latest release in the 0.3 series
Pkg.add(PackageSpec(name="Example", version="0.3.1")) # Specify version; exact release
Pkg.add(PackageSpec(url="https://github.com/JuliaLang/Example.jl", rev="master")) # From url to remote gitrepo
Pkg.add(PackageSpec(url="/remote/mycompany/juliapackages/OurPackage")) # From path to local gitrepo
\end{minted}

See also \hyperlink{7769325907319883786}{\texttt{PackageSpec}}.



\end{adjustwidth}
\hypertarget{9095967362638559586}{} 
\hyperlink{9095967362638559586}{\texttt{Pkg.develop}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Pkg.develop(pkg::Union{String, Vector{String}})
Pkg.develop(pkgs::Union{Packagespec, Vector{Packagespec}})
\end{minted}

Make a package available for development by tracking it by path. If \texttt{pkg} is given with only a name or by a URL, the package will be downloaded to the location specified by the environment variable \texttt{JULIA\_PKG\_DEVDIR}, with \texttt{.julia/dev} as the default.

If \texttt{pkg} is given as a local path, the package at that path will be tracked.

\textbf{Examples}


\begin{minted}{julia}
# By name
Pkg.develop("Example")

# By url
Pkg.develop(PackageSpec(url="https://github.com/JuliaLang/Compat.jl"))

# By path
Pkg.develop(PackageSpec(path="MyJuliaPackages/Package.jl"))
\end{minted}

See also \hyperlink{7769325907319883786}{\texttt{PackageSpec}}



\end{adjustwidth}
\hypertarget{16970816085069386648}{} 
\hyperlink{16970816085069386648}{\texttt{Pkg.activate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Pkg.activate([s::String]; shared::Bool=false)
\end{minted}

Activate the environment at \texttt{s}. The active environment is the environment that is modified by executing package commands. The logic for what path is activated is as follows:

\begin{itemize}
\item If \texttt{shared} is \texttt{true}, the first existing environment named \texttt{s} from the depots in the depot stack will be activated. If no such environment exists, create and activate that environment in the first depot.


\item If \texttt{s} is an existing path, then activate the environment at that path.


\item If \texttt{s} is a package in the current project and \texttt{s} is tracking a path, then activate the environment at the tracked path.


\item Otherwise, \texttt{s} is interpreted as a non-existing path, which is then activated.

\end{itemize}
If no argument is given to \texttt{activate}, then activate the home project. The home project is specified by either the \texttt{--project} command line option to the julia executable, or the \texttt{JULIA\_PROJECT} environment variable.

\textbf{Examples}


\begin{lstlisting}
Pkg.activate()
Pkg.activate("local/path")
Pkg.activate("MyDependency")
\end{lstlisting}



\end{adjustwidth}
\hypertarget{4147981366221469810}{} 
\hyperlink{4147981366221469810}{\texttt{Pkg.rm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Pkg.rm(pkg::Union{String, Vector{String}})
Pkg.rm(pkg::Union{PackageSpec, Vector{PackageSpec}})
\end{minted}

Remove a package from the current project. If the \texttt{mode} of \texttt{pkg} is \texttt{PKGMODE\_MANIFEST} also remove it from the manifest including all recursive dependencies of \texttt{pkg}.

See also \hyperlink{7769325907319883786}{\texttt{PackageSpec}}, \hyperlink{3271836720350904911}{\texttt{PackageMode}}.



\end{adjustwidth}
\hypertarget{10543171283952432470}{} 
\hyperlink{10543171283952432470}{\texttt{Pkg.update}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Pkg.update(; level::UpgradeLevel=UPLEVEL_MAJOR, mode::PackageMode = PKGMODE_PROJECT)
Pkg.update(pkg::Union{String, Vector{String}})
Pkg.update(pkg::Union{PackageSpec, Vector{PackageSpec}})
\end{minted}

Update a package \texttt{pkg}. If no posistional argument is given, update all packages in the manifest if \texttt{mode} is \texttt{PKGMODE\_MANIFEST} and packages in both manifest and project if \texttt{mode} is \texttt{PKGMODE\_PROJECT}. If no positional argument is given, \texttt{level} can be used to control by how much packages are allowed to be upgraded (major, minor, patch, fixed).

See also \hyperlink{7769325907319883786}{\texttt{PackageSpec}}, \hyperlink{3271836720350904911}{\texttt{PackageMode}}, \hyperlink{13785530562686832335}{\texttt{UpgradeLevel}}.



\end{adjustwidth}
\hypertarget{7033600981039054461}{} 
\hyperlink{7033600981039054461}{\texttt{Pkg.test}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Pkg.test(; kwargs...)
Pkg.test(pkg::Union{String, Vector{String}; kwargs...)
Pkg.test(pkgs::Union{PackageSpec, Vector{PackageSpec}}; kwargs...)
\end{minted}

\textbf{Keyword arguments:}

\begin{itemize}
\item \texttt{coverage::Bool=false}: enable or disable generation of coverage statistics.


\item \texttt{julia\_args::Union\{Cmd, Vector\{String\}\}}: options to be passed the test process.


\item \texttt{test\_args::Union\{Cmd, Vector\{String\}\}}: test arguments (\texttt{ARGS}) available in the test process.

\end{itemize}
\begin{quote}
\textbf{Julia 1.3}

\texttt{julia\_args} and \texttt{test\_args} requires at least Julia 1.3.

\end{quote}
Run the tests for package \texttt{pkg}, or for the current project (which thus needs to be a package) if no positional argument is given to \texttt{Pkg.test}. A package is tested by running its \texttt{test/runtests.jl} file.

The tests are run by generating a temporary environment with only \texttt{pkg} and its (recursive) dependencies in it. If a manifest exists, the versions in that manifest are used, otherwise a feasible set of packages is resolved and installed.

During the tests, test-specific dependencies are active, which are given in the project file as e.g.


\begin{lstlisting}
[extras]
Test = "8dfed614-e22c-5e08-85e1-65c5234f0b40"

[targets]
test = ["Test"]
\end{lstlisting}

The tests are executed in a new process with \texttt{check-bounds=yes} and by default \texttt{startup-file=no}. If using the startup file (\texttt{{\textasciitilde}/.julia/config/startup.jl}) is desired, start julia with \texttt{--startup-file=yes}. Inlining of functions during testing can be disabled (for better coverage accuracy) by starting julia with \texttt{--inline=no}.



\end{adjustwidth}
\hypertarget{1343006981993025790}{} 
\hyperlink{1343006981993025790}{\texttt{Pkg.build}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Pkg.build(; verbose = false)
Pkg.build(pkg::Union{String, Vector{String}}; verbose = false)
Pkg.build(pkgs::Union{PackageSpec, Vector{PackageSpec}}; verbose = false)
\end{minted}

Run the build script in \texttt{deps/build.jl} for \texttt{pkg} and all of its dependencies in depth-first recursive order. If no argument is given to \texttt{build}, the current project is built, which thus needs to be a package. This function is called automatically on any package that gets installed for the first time. \texttt{verbose = true} prints the build output to \texttt{stdout}/\texttt{stderr} instead of redirecting to the \texttt{build.log} file.



\end{adjustwidth}
\hypertarget{9776080518771630101}{} 
\hyperlink{9776080518771630101}{\texttt{Pkg.pin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Pkg.pin(pkg::Union{String, Vector{String}})
Pkg.pin(pkgs::Union{PackageSpec, Vector{PackageSpec}})
\end{minted}

Pin a package to the current version (or the one given in the \texttt{PackageSpec}) or to a certain git revision. A pinned package is never updated.

\textbf{Examples}


\begin{minted}{julia}
Pkg.pin("Example")
Pkg.pin(PackageSpec(name="Example", version="0.3.1"))
\end{minted}



\end{adjustwidth}
\hypertarget{11960612719163184326}{} 
\hyperlink{11960612719163184326}{\texttt{Pkg.free}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Pkg.free(pkg::Union{String, Vector{String}})
Pkg.free(pkgs::Union{PackageSpec, Vector{PackageSpec}})
\end{minted}

If \texttt{pkg} is pinned, remove the pin. If \texttt{pkg} is tracking a path, e.g. after \hyperlink{9095967362638559586}{\texttt{Pkg.develop}}, go back to tracking registered versions.

\textbf{Examples}


\begin{minted}{julia}
Pkg.free("Package")
Pkg.free(PackageSpec("Package"))
\end{minted}



\end{adjustwidth}
\hypertarget{14292589817666425387}{} 
\hyperlink{14292589817666425387}{\texttt{Pkg.instantiate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Pkg.instantiate(; verbose = false)
\end{minted}

If a \texttt{Manifest.toml} file exists in the active project, download all the packages declared in that manifest. Otherwise, resolve a set of feasible packages from the \texttt{Project.toml} files and install them. \texttt{verbose = true} prints the build output to \texttt{stdout}/\texttt{stderr} instead of redirecting to the \texttt{build.log} file. If no \texttt{Project.toml} exist in the current active project, create one with all the dependencies in the manifest and instantiate the resulting project.



\end{adjustwidth}
\hypertarget{13977221485522627510}{} 
\hyperlink{13977221485522627510}{\texttt{Pkg.resolve}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Pkg.resolve()
\end{minted}

Update the current manifest with potential changes to the dependency graph from packages that are tracking a path.



\end{adjustwidth}
\hypertarget{1574626393961447104}{} 
\hyperlink{1574626393961447104}{\texttt{Pkg.setprotocol!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
setprotocol!(;
    domain::AbstractString = "github.com",
    protocol::Union{Nothing, AbstractString}=nothing
)
\end{minted}

Set the protocol used to access hosted packages when \texttt{add}ing a url or \texttt{develop}ing a package. Defaults to delegating the choice to the package developer (\texttt{protocol === nothing}). Other choices for \texttt{protocol} are \texttt{{\textquotedbl}https{\textquotedbl}} or \texttt{{\textquotedbl}git{\textquotedbl}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Pkg.setprotocol!(domain = "github.com", protocol = "ssh")

julia> Pkg.setprotocol!(domain = "gitlab.mycompany.com")
\end{minted}



\end{adjustwidth}

\hypertarget{5039001780758746770}{}


\chapter{Printf}


\hypertarget{13954719910189591998}{} 
\hyperlink{13954719910189591998}{\texttt{Printf.@printf}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@printf([io::IOStream], "%Fmt", args...)
\end{minted}

Print \texttt{args} using C \texttt{printf} style format specification string, with some caveats: \texttt{Inf} and \texttt{NaN} are printed consistently as \texttt{Inf} and \texttt{NaN} for flags \texttt{\%a}, \texttt{\%A}, \texttt{\%e}, \texttt{\%E}, \texttt{\%f}, \texttt{\%F}, \texttt{\%g}, and \texttt{\%G}. Furthermore, if a floating point number is equally close to the numeric values of two possible output strings, the output string further away from zero is chosen.

Optionally, an \hyperlink{12496894737220238417}{\texttt{IOStream}} may be passed as the first argument to redirect output.

See also: \hyperlink{13977800180580695709}{\texttt{@sprintf}}

\textbf{Examples}


\begin{minted}{jlcon}
julia> @printf("%f %F %f %F\n", Inf, Inf, NaN, NaN)
Inf Inf NaN NaN


julia> @printf "%.0f %.1f %f\n" 0.5 0.025 -0.0078125
1 0.0 -0.007813
\end{minted}



\end{adjustwidth}
\hypertarget{13977800180580695709}{} 
\hyperlink{13977800180580695709}{\texttt{Printf.@sprintf}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@sprintf("%Fmt", args...)
\end{minted}

Return \texttt{@printf} formatted output as string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> s = @sprintf "this is a %s %15.1f" "test" 34.567;

julia> println(s)
this is a test            34.6
\end{minted}



\end{adjustwidth}

\hypertarget{13446659783021526147}{}


\chapter{性能分析}


\hypertarget{9691715859147716436}{} 
\hyperlink{9691715859147716436}{\texttt{Profile.@profile}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@profile
\end{minted}

\texttt{@profile <expression>} runs your expression while taking periodic backtraces. These are appended to an internal buffer of backtraces.



\end{adjustwidth}

\texttt{Profile} 里的方法均未导出，需要通过 \texttt{Profile.print()} 的方式调用。


\hypertarget{15414823368700214048}{} 
\hyperlink{15414823368700214048}{\texttt{Profile.clear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
clear()
\end{minted}

Clear any existing backtraces from the internal buffer.



\end{adjustwidth}
\hypertarget{2955792207246042270}{} 
\hyperlink{2955792207246042270}{\texttt{Profile.print}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
print([io::IO = stdout,] [data::Vector]; kwargs...)
\end{minted}

Prints profiling results to \texttt{io} (by default, \texttt{stdout}). If you do not supply a \texttt{data} vector, the internal buffer of accumulated backtraces will be used.

The keyword arguments can be any combination of:

\begin{itemize}
\item \texttt{format} – Determines whether backtraces are printed with (default, \texttt{:tree}) or without (\texttt{:flat}) indentation indicating tree structure.


\item \texttt{C} – If \texttt{true}, backtraces from C and Fortran code are shown (normally they are excluded).


\item \texttt{combine} – If \texttt{true} (default), instruction pointers are merged that correspond to the same line of code.


\item \texttt{maxdepth} – Limits the depth higher than \texttt{maxdepth} in the \texttt{:tree} format.


\item \texttt{sortedby} – Controls the order in \texttt{:flat} format. \texttt{:filefuncline} (default) sorts by the source  line, \texttt{:count} sorts in order of number of collected samples, and \texttt{:overhead} sorts by the number of samples  incurred by each function by itself.


\item \texttt{noisefloor} – Limits frames that exceed the heuristic noise floor of the sample (only applies to format \texttt{:tree}).  A suggested value to try for this is 2.0 (the default is 0). This parameter hides samples for which \texttt{n <= noisefloor * √N},  where \texttt{n} is the number of samples on this line, and \texttt{N} is the number of samples for the callee.


\item \texttt{mincount} – Limits the printout to only those lines with at least \texttt{mincount} occurrences.


\item \texttt{recur} – Controls the recursion handling in \texttt{:tree} format. \texttt{:off} (default) prints the tree as normal. \texttt{:flat} instead  compresses any recursion (by ip), showing the approximate effect of converting any self-recursion into an iterator.  \texttt{:flatc} does the same but also includes collapsing of C frames (may do odd things around \texttt{jl\_apply}).

\end{itemize}



\begin{lstlisting}
print([io::IO = stdout,] data::Vector, lidict::LineInfoDict; kwargs...)
\end{lstlisting}

Prints profiling results to \texttt{io}. This variant is used to examine results exported by a previous call to \hyperlink{10202508103131430980}{\texttt{retrieve}}. Supply the vector \texttt{data} of backtraces and a dictionary \texttt{lidict} of line information.

See \texttt{Profile.print([io], data)} for an explanation of the valid keyword arguments.



\end{adjustwidth}
\hypertarget{11074776852943687092}{} 
\hyperlink{11074776852943687092}{\texttt{Profile.init}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
init(; n::Integer, delay::Real))
\end{minted}

Configure the \texttt{delay} between backtraces (measured in seconds), and the number \texttt{n} of instruction pointers that may be stored. Each instruction pointer corresponds to a single line of code; backtraces generally consist of a long list of instruction pointers. Default settings can be obtained by calling this function with no arguments, and each can be set independently using keywords or in the order \texttt{(n, delay)}.



\end{adjustwidth}
\hypertarget{3578108280181558112}{} 
\hyperlink{3578108280181558112}{\texttt{Profile.fetch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
fetch() -> data
\end{minted}

Returns a copy of the buffer of profile backtraces. Note that the values in \texttt{data} have meaning only on this machine in the current session, because it depends on the exact memory addresses used in JIT-compiling. This function is primarily for internal use; \hyperlink{10202508103131430980}{\texttt{retrieve}} may be a better choice for most users.



\end{adjustwidth}
\hypertarget{10202508103131430980}{} 
\hyperlink{10202508103131430980}{\texttt{Profile.retrieve}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
retrieve() -> data, lidict
\end{minted}

{\textquotedbl}Exports{\textquotedbl} profiling results in a portable format, returning the set of all backtraces (\texttt{data}) and a dictionary that maps the (session-specific) instruction pointers in \texttt{data} to \texttt{LineInfo} values that store the file name, function name, and line number. This function allows you to save profiling results for future analysis.



\end{adjustwidth}
\hypertarget{14497996294492518181}{} 
\hyperlink{14497996294492518181}{\texttt{Profile.callers}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
callers(funcname, [data, lidict], [filename=<filename>], [linerange=<start:stop>]) -> Vector{Tuple{count, lineinfo}}
\end{minted}

Given a previous profiling run, determine who called a particular function. Supplying the filename (and optionally, range of line numbers over which the function is defined) allows you to disambiguate an overloaded method. The returned value is a vector containing a count of the number of calls and line information about the caller. One can optionally supply backtrace \texttt{data} obtained from \hyperlink{10202508103131430980}{\texttt{retrieve}}; otherwise, the current internal profile buffer is used.



\end{adjustwidth}
\hypertarget{12697816172521511938}{} 
\hyperlink{12697816172521511938}{\texttt{Profile.clear\_malloc\_data}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
clear_malloc_data()
\end{minted}

Clears any stored memory allocation data when running julia with \texttt{--track-allocation}. Execute the command(s) you want to test (to force JIT-compilation), then call \hyperlink{12697816172521511938}{\texttt{clear\_malloc\_data}}. Then execute your command(s) again, quit Julia, and examine the resulting \texttt{*.mem} files.



\end{adjustwidth}

\hypertarget{2176533558823998019}{}


\chapter{Julia REPL}



Julia 附带了一个全功能的交互式命令行 REPL（read-eval-print loop），其内置于 \texttt{julia} 可执行文件中。它除了允许快速简便地执行 Julia 语句外，还具有可搜索的历史记录，tab 补全，许多有用的按键绑定以及专用的 help 和 shell 模式。只需不附带任何参数地调用 \texttt{julia} 或双击可执行文件即可启动 REPL：




\begin{lstlisting}
$ julia

               _
   _       _ _(_)_     |  Documentation: https://docs.julialang.org
  (_)     | (_) (_)    |
   _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 1.4.2 (2020-05-23)
 _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release
|__/                   |


julia>
\end{lstlisting}



To exit the interactive session, type \texttt{{\textasciicircum}D} – the control key together with the \texttt{d} key on a blank line – or type \texttt{exit()} followed by the return or enter key. The REPL greets you with a banner and a \texttt{julia>} prompt.



\hypertarget{13843805802306265376}{}


\section{不同的提示符模式}



\hypertarget{2631446594844418165}{}


\subsection{Julian 模式}



REPL 有四种主要的操作模式。第一个也是最常见的是 Julian 提示符。这是默认的操作模式；每个新行最初都以 \texttt{julia>} 开头。就在这里，你可以输入 Julia 表达式。在输入完整表达式后按下 return 或 enter 将执行该表达式，并显示最后一个表达式的结果。




\begin{minted}{jlcon}
julia> string(1 + 2)
"3"
\end{minted}



交互式运行有许多独特的实用功能。除了显示结果外，REPL 还将结果绑定到变量 \texttt{ans} 上。一行的尾随分号可用作禁止显示结果的标志。




\begin{minted}{jlcon}
julia> string(3 * 4);

julia> ans
"12"
\end{minted}



In Julia mode, the REPL supports something called \emph{prompt pasting}. This activates when pasting text that starts with \texttt{julia>} into the REPL. In that case, only expressions starting with \texttt{julia>} are parsed, others are removed. This makes it is possible to paste a chunk of code that has been copied from a REPL session without having to scrub away prompts and outputs. This feature is enabled by default but can be disabled or enabled at will with \texttt{REPL.enable\_promptpaste(::Bool)}. If it is enabled, you can try it out by pasting the code block above this paragraph straight into the REPL. This feature does not work on the standard Windows command prompt due to its limitation at detecting when a paste occurs.



Objects are printed at the REPL using the \hyperlink{14071376285304310153}{\texttt{show}} function with a specific \hyperlink{13454403377667762339}{\texttt{IOContext}}. In particular, the \texttt{:limit} attribute is set to \texttt{true}. Other attributes can receive in certain \texttt{show} methods a default value if it{\textquotesingle}s not already set, like \texttt{:compact}. It{\textquotesingle}s possible, as an experimental feature, to specify the attributes used by the REPL via the \texttt{Base.active\_repl.options.iocontext} dictionary (associating values to attributes). For example:




\begin{minted}{jlcon}
julia> rand(2, 2)
2×2 Array{Float64,2}:
 0.8833    0.329197
 0.719708  0.59114

julia> show(IOContext(stdout, :compact => false), "text/plain", rand(2, 2))
 0.43540323669187075  0.15759787870609387
 0.2540832269192739   0.4597637838786053
julia> Base.active_repl.options.iocontext[:compact] = false;

julia> rand(2, 2)
2×2 Array{Float64,2}:
 0.2083967319174056  0.13330606013126012
 0.6244375177790158  0.9777957560761545
\end{minted}



In order to define automatically the values of this dictionary at startup time, one can use the \hyperlink{1741947168860119796}{\texttt{atreplinit}} function in the \texttt{{\textasciitilde}/.julia/config/startup.jl} file, for example:




\begin{minted}{julia}
atreplinit() do repl
    repl.options.iocontext[:compact] = false
end
\end{minted}



\hypertarget{8090123169740528583}{}


\subsection{Help mode}



When the cursor is at the beginning of the line, the prompt can be changed to a help mode by typing \texttt{?}. Julia will attempt to print help or documentation for anything entered in help mode:




\begin{minted}{jlcon}
julia> ? # upon typing ?, the prompt changes (in place) to: help?>

help?> string
search: string String Cstring Cwstring RevString randstring bytestring SubString

  string(xs...)

  Create a string from any values using the print function.
\end{minted}



Macros, types and variables can also be queried:




\begin{lstlisting}
help?> @time
  @time

  A macro to execute an expression, printing the time it took to execute, the number of allocations,
  and the total number of bytes its execution caused to be allocated, before returning the value of the
  expression.

  See also @timev, @timed, @elapsed, and @allocated.

help?> Int32
search: Int32 UInt32

  Int32 <: Signed

  32-bit signed integer type.
\end{lstlisting}



Help mode can be exited by pressing backspace at the beginning of the line.



\hypertarget{17654100848947676892}{}


\subsection{Shell mode}



Just as help mode is useful for quick access to documentation, another common task is to use the system shell to execute system commands. Just as \texttt{?} entered help mode when at the beginning of the line, a semicolon (\texttt{;}) will enter the shell mode. And it can be exited by pressing backspace at the beginning of the line.




\begin{minted}{jlcon}
julia> ; # upon typing ;, the prompt changes (in place) to: shell>

shell> echo hello
hello
\end{minted}



\begin{quote}
\textbf{Note}

For Windows users, Julia{\textquotesingle}s shell mode does not expose windows shell commands. Hence, this will fail:

\end{quote}



\begin{minted}{jlcon}
julia> ; # upon typing ;, the prompt changes (in place) to: shell>

shell> dir
ERROR: IOError: could not spawn `dir`: no such file or directory (ENOENT)
Stacktrace!
.......
\end{minted}



However, you can get access to \texttt{PowerShell} like this:




\begin{minted}{jlcon}
julia> ; # upon typing ;, the prompt changes (in place) to: shell>

shell> powershell
Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.
PS C:\Users\elm>
\end{minted}



... and to \texttt{cmd.exe} like that (see the \texttt{dir} command):




\begin{minted}{jlcon}
julia> ; # upon typing ;, the prompt changes (in place) to: shell>

shell> cmd
Microsoft Windows [version 10.0.17763.973]
(c) 2018 Microsoft Corporation. All rights reserved.
C:\Users\elm>dir
 Volume in drive C has no label
 Volume Serial Number is 1643-0CD7
  Directory of C:\Users\elm

29/01/2020  22:15    <DIR>          .
29/01/2020  22:15    <DIR>          ..
02/02/2020  08:06    <DIR>          .atom
\end{minted}



\hypertarget{13961930499248375782}{}


\subsection{Search modes}



In all of the above modes, the executed lines get saved to a history file, which can be searched.  To initiate an incremental search through the previous history, type \texttt{{\textasciicircum}R} – the control key together with the \texttt{r} key. The prompt will change to \texttt{(reverse-i-search)`{\textquotesingle}:}, and as you type the search query will appear in the quotes. The most recent result that matches the query will dynamically update to the right of the colon as more is typed. To find an older result using the same query, simply type \texttt{{\textasciicircum}R} again.



Just as \texttt{{\textasciicircum}R} is a reverse search, \texttt{{\textasciicircum}S} is a forward search, with the prompt \texttt{(i-search)`{\textquotesingle}:}.  The two may be used in conjunction with each other to move through the previous or next matching results, respectively.



\hypertarget{11229238099061625177}{}


\section{Key bindings}



The Julia REPL makes great use of key bindings. Several control-key bindings were already introduced above (\texttt{{\textasciicircum}D} to exit, \texttt{{\textasciicircum}R} and \texttt{{\textasciicircum}S} for searching), but there are many more. In addition to the control-key, there are also meta-key bindings. These vary more by platform, but most terminals default to using alt- or option- held down with a key to send the meta-key (or can be configured to do so), or pressing Esc and then the key.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Keybinding & Description \\
\hline
\textbf{Program control} &  \\
\hline
\texttt{{\textasciicircum}D} & Exit (when buffer is empty) \\
\hline
\texttt{{\textasciicircum}C} & Interrupt or cancel \\
\hline
\texttt{{\textasciicircum}L} & Clear console screen \\
\hline
Return/Enter, \texttt{{\textasciicircum}J} & New line, executing if it is complete \\
\hline
meta-Return/Enter & Insert new line without executing it \\
\hline
\texttt{?} or \texttt{;} & Enter help or shell mode (when at start of a line) \\
\hline
\texttt{{\textasciicircum}R}, \texttt{{\textasciicircum}S} & Incremental history search, described above \\
\hline
\textbf{Cursor movement} &  \\
\hline
Right arrow, \texttt{{\textasciicircum}F} & Move right one character \\
\hline
Left arrow, \texttt{{\textasciicircum}B} & Move left one character \\
\hline
ctrl-Right, \texttt{meta-F} & Move right one word \\
\hline
ctrl-Left, \texttt{meta-B} & Move left one word \\
\hline
Home, \texttt{{\textasciicircum}A} & Move to beginning of line \\
\hline
End, \texttt{{\textasciicircum}E} & Move to end of line \\
\hline
Up arrow, \texttt{{\textasciicircum}P} & Move up one line (or change to the previous history entry that matches the text before the cursor) \\
\hline
Down arrow, \texttt{{\textasciicircum}N} & Move down one line (or change to the next history entry that matches the text before the cursor) \\
\hline
Shift-Arrow Key & Move cursor according to the direction of the Arrow key, while activating the region ({\textquotedbl}shift selection{\textquotedbl}) \\
\hline
Page-up, \texttt{meta-P} & Change to the previous history entry \\
\hline
Page-down, \texttt{meta-N} & Change to the next history entry \\
\hline
\texttt{meta-<} & Change to the first history entry (of the current session if it is before the current position in history) \\
\hline
\texttt{meta->} & Change to the last history entry \\
\hline
\texttt{{\textasciicircum}-Space} & Set the {\textquotedbl}mark{\textquotedbl} in the editing region (and de-activate the region if it{\textquotesingle}s active) \\
\hline
\texttt{{\textasciicircum}-Space {\textasciicircum}-Space} & Set the {\textquotedbl}mark{\textquotedbl} in the editing region and make the region {\textquotedbl}active{\textquotedbl}, i.e. highlighted \\
\hline
\texttt{{\textasciicircum}G} & De-activate the region (i.e. make it not highlighted) \\
\hline
\texttt{{\textasciicircum}X{\textasciicircum}X} & Exchange the current position with the mark \\
\hline
\textbf{Editing} &  \\
\hline
Backspace, \texttt{{\textasciicircum}H} & Delete the previous character, or the whole region when it{\textquotesingle}s active \\
\hline
Delete, \texttt{{\textasciicircum}D} & Forward delete one character (when buffer has text) \\
\hline
meta-Backspace & Delete the previous word \\
\hline
\texttt{meta-d} & Forward delete the next word \\
\hline
\texttt{{\textasciicircum}W} & Delete previous text up to the nearest whitespace \\
\hline
\texttt{meta-w} & Copy the current region in the kill ring \\
\hline
\texttt{meta-W} & {\textquotedbl}Kill{\textquotedbl} the current region, placing the text in the kill ring \\
\hline
\texttt{{\textasciicircum}K} & {\textquotedbl}Kill{\textquotedbl} to end of line, placing the text in the kill ring \\
\hline
\texttt{{\textasciicircum}Y} & {\textquotedbl}Yank{\textquotedbl} insert the text from the kill ring \\
\hline
\texttt{meta-y} & Replace a previously yanked text with an older entry from the kill ring \\
\hline
\texttt{{\textasciicircum}T} & Transpose the characters about the cursor \\
\hline
\texttt{meta-Up arrow} & Transpose current line with line above \\
\hline
\texttt{meta-Down arrow} & Transpose current line with line below \\
\hline
\texttt{meta-u} & Change the next word to uppercase \\
\hline
\texttt{meta-c} & Change the next word to titlecase \\
\hline
\texttt{meta-l} & Change the next word to lowercase \\
\hline
\texttt{{\textasciicircum}/}, \texttt{{\textasciicircum}\_} & Undo previous editing action \\
\hline
\texttt{{\textasciicircum}Q} & Write a number in REPL and press \texttt{{\textasciicircum}Q} to open editor at corresponding stackframe or method \\
\hline
\texttt{meta-Left Arrow} & indent the current line on the left \\
\hline
\texttt{meta-Right Arrow} & indent the current line on the right \\
\hline
\texttt{meta-.} & insert last word from previous history entry \\
\hline
\end{tabulary}

\end{table}



\hypertarget{12600332236460824227}{}


\subsection{Customizing keybindings}



Julia{\textquotesingle}s REPL keybindings may be fully customized to a user{\textquotesingle}s preferences by passing a dictionary to \texttt{REPL.setup\_interface}. The keys of this dictionary may be characters or strings. The key \texttt{{\textquotesingle}*{\textquotesingle}} refers to the default action. Control plus character \texttt{x} bindings are indicated with \texttt{{\textquotedbl}{\textasciicircum}x{\textquotedbl}}. Meta plus \texttt{x} can be written \texttt{{\textquotedbl}{\textbackslash}{\textbackslash}M-x{\textquotedbl}} or \texttt{{\textquotedbl}{\textbackslash}ex{\textquotedbl}}, and Control plus \texttt{x} can be written \texttt{{\textquotedbl}{\textbackslash}{\textbackslash}C-x{\textquotedbl}} or \texttt{{\textquotedbl}{\textasciicircum}x{\textquotedbl}}. The values of the custom keymap must be \texttt{nothing} (indicating that the input should be ignored) or functions that accept the signature \texttt{(PromptState, AbstractREPL, Char)}. The \texttt{REPL.setup\_interface} function must be called before the REPL is initialized, by registering the operation with \hyperlink{1741947168860119796}{\texttt{atreplinit}} . For example, to bind the up and down arrow keys to move through history without prefix search, one could put the following code in \texttt{{\textasciitilde}/.julia/config/startup.jl}:




\begin{minted}{julia}
import REPL
import REPL.LineEdit

const mykeys = Dict{Any,Any}(
    # Up Arrow
    "\e[A" => (s,o...)->(LineEdit.edit_move_up(s) || LineEdit.history_prev(s, LineEdit.mode(s).hist)),
    # Down Arrow
    "\e[B" => (s,o...)->(LineEdit.edit_move_down(s) || LineEdit.history_next(s, LineEdit.mode(s).hist))
)

function customize_keys(repl)
    repl.interface = REPL.setup_interface(repl; extra_repl_keymap = mykeys)
end

atreplinit(customize_keys)
\end{minted}



Users should refer to \texttt{LineEdit.jl} to discover the available actions on key input.



\hypertarget{9567689438493430677}{}


\section{Tab completion}



In both the Julian and help modes of the REPL, one can enter the first few characters of a function or type and then press the tab key to get a list all matches:




\begin{minted}{jlcon}
julia> stri[TAB]
stride     strides     string      strip

julia> Stri[TAB]
StridedArray    StridedMatrix    StridedVecOrMat  StridedVector    String
\end{minted}



The tab key can also be used to substitute LaTeX math symbols with their Unicode equivalents, and get a list of LaTeX matches as well:




\begin{minted}{jlcon}
julia> \pi[TAB]
julia> π
π = 3.1415926535897...

julia> e\_1[TAB] = [1,0]
julia> e₁ = [1,0]
2-element Array{Int64,1}:
 1
 0

julia> e\^1[TAB] = [1 0]
julia> e¹ = [1 0]
1×2 Array{Int64,2}:
 1  0

julia> \sqrt[TAB]2     # √ is equivalent to the sqrt function
julia> √2
1.4142135623730951

julia> \hbar[TAB](h) = h / 2\pi[TAB]
julia> ħ(h) = h / 2π
ħ (generic function with 1 method)

julia> \h[TAB]
\hat              \hermitconjmatrix  \hkswarow          \hrectangle
\hatapprox        \hexagon           \hookleftarrow     \hrectangleblack
\hbar             \hexagonblack      \hookrightarrow    \hslash
\heartsuit        \hksearow          \house             \hspace

julia> α="\alpha[TAB]"   # LaTeX completion also works in strings
julia> α="α"
\end{minted}



A full list of tab-completions can be found in the \href{@ref}{Unicode Input} section of the manual.



Completion of paths works for strings and julia{\textquotesingle}s shell mode:




\begin{minted}{jlcon}
julia> path="/[TAB]"
.dockerenv  .juliabox/   boot/        etc/         lib/         media/       opt/         root/        sbin/        sys/         usr/
.dockerinit bin/         dev/         home/        lib64/       mnt/         proc/        run/         srv/         tmp/         var/
shell> /[TAB]
.dockerenv  .juliabox/   boot/        etc/         lib/         media/       opt/         root/        sbin/        sys/         usr/
.dockerinit bin/         dev/         home/        lib64/       mnt/         proc/        run/         srv/         tmp/         var/
\end{minted}



Tab completion can help with investigation of the available methods matching the input arguments:




\begin{minted}{jlcon}
julia> max([TAB] # All methods are displayed, not shown here due to size of the list

julia> max([1, 2], [TAB] # All methods where `Vector{Int}` matches as first argument
max(x, y) in Base at operators.jl:215
max(a, b, c, xs...) in Base at operators.jl:281

julia> max([1, 2], max(1, 2), [TAB] # All methods matching the arguments.
max(x, y) in Base at operators.jl:215
max(a, b, c, xs...) in Base at operators.jl:281
\end{minted}



Keywords are also displayed in the suggested methods after \texttt{;}, see below line where \texttt{limit} and \texttt{keepempty} are keyword arguments:




\begin{minted}{jlcon}
julia> split("1 1 1", [TAB]
split(str::AbstractString; limit, keepempty) in Base at strings/util.jl:302
split(str::T, splitter; limit, keepempty) where T<:AbstractString in Base at strings/util.jl:277
\end{minted}



The completion of the methods uses type inference and can therefore see if the arguments match even if the arguments are output from functions. The function needs to be type stable for the completion to be able to remove non-matching methods.



Tab completion can also help completing fields:




\begin{minted}{jlcon}
julia> import UUIDs

julia> UUIDs.uuid[TAB]
uuid1        uuid4         uuid_version
\end{minted}



Fields for output from functions can also be completed:




\begin{minted}{jlcon}
julia> split("","")[1].[TAB]
lastindex  offset  string
\end{minted}



The completion of fields for output from functions uses type inference, and it can only suggest fields if the function is type stable.



Dictionary keys can also be tab completed:




\begin{minted}{jlcon}
julia> foo = Dict("qwer1"=>1, "qwer2"=>2, "asdf"=>3)
Dict{String,Int64} with 3 entries:
  "qwer2" => 2
  "asdf"  => 3
  "qwer1" => 1

julia> foo["q[TAB]

"qwer1" "qwer2"
julia> foo["qwer
\end{minted}



\hypertarget{17268458035861597176}{}


\section{Customizing Colors}



The colors used by Julia and the REPL can be customized, as well. To change the color of the Julia prompt you can add something like the following to your \texttt{{\textasciitilde}/.julia/config/startup.jl} file, which is to be placed inside your home directory:




\begin{minted}{julia}
function customize_colors(repl)
    repl.prompt_color = Base.text_colors[:cyan]
end

atreplinit(customize_colors)
\end{minted}



The available color keys can be seen by typing \texttt{Base.text\_colors} in the help mode of the REPL. In addition, the integers 0 to 255 can be used as color keys for terminals with 256 color support.



You can also change the colors for the help and shell prompts and input and answer text by setting the appropriate field of \texttt{repl} in the \texttt{customize\_colors} function above (respectively, \texttt{help\_color}, \texttt{shell\_color}, \texttt{input\_color}, and \texttt{answer\_color}). For the latter two, be sure that the \texttt{envcolors} field is also set to false.



It is also possible to apply boldface formatting by using \texttt{Base.text\_colors[:bold]} as a color. For instance, to print answers in boldface font, one can use the following as a \texttt{{\textasciitilde}/.julia/config/startup.jl}:




\begin{minted}{julia}
function customize_colors(repl)
    repl.envcolors = false
    repl.answer_color = Base.text_colors[:bold]
end

atreplinit(customize_colors)
\end{minted}



You can also customize the color used to render warning and informational messages by setting the appropriate environment variables. For instance, to render error, warning, and informational messages respectively in magenta, yellow, and cyan you can add the following to your \texttt{{\textasciitilde}/.julia/config/startup.jl} file:




\begin{minted}{julia}
ENV["JULIA_ERROR_COLOR"] = :magenta
ENV["JULIA_WARN_COLOR"] = :yellow
ENV["JULIA_INFO_COLOR"] = :cyan
\end{minted}



\hypertarget{12083895020192706202}{}


\section{TerminalMenus}



TerminalMenus is a submodule of the Julia REPL and enables small, low-profile interactive menus in the terminal.



\hypertarget{15337950170852396133}{}


\subsection{Examples}




\begin{minted}{julia}
import REPL
using REPL.TerminalMenus

options = ["apple", "orange", "grape", "strawberry",
            "blueberry", "peach", "lemon", "lime"]

\end{minted}



\hypertarget{10421324822656120463}{}


\subsubsection{RadioMenu}



The RadioMenu allows the user to select one option from the list. The \texttt{request} function displays the interactive menu and returns the index of the selected choice. If a user presses {\textquotesingle}q{\textquotesingle} or \texttt{ctrl-c}, \texttt{request} will return a \texttt{-1}.




\begin{minted}{julia}
# `pagesize` is the number of items to be displayed at a time.
#  The UI will scroll if the number of options is greater
#   than the `pagesize`
menu = RadioMenu(options, pagesize=4)

# `request` displays the menu and returns the index after the
#   user has selected a choice
choice = request("Choose your favorite fruit:", menu)

if choice != -1
    println("Your favorite fruit is ", options[choice], "!")
else
    println("Menu canceled.")
end

\end{minted}



Output:




\begin{lstlisting}
Choose your favorite fruit:
^  grape
   strawberry
 > blueberry
v  peach
Your favorite fruit is blueberry!
\end{lstlisting}



\hypertarget{6295927836435212296}{}


\subsubsection{MultiSelectMenu}



The MultiSelectMenu allows users to select many choices from a list.




\begin{minted}{julia}
# here we use the default `pagesize` 10
menu = MultiSelectMenu(options)

# `request` returns a `Set` of selected indices
# if the menu us canceled (ctrl-c or q), return an empty set
choices = request("Select the fruits you like:", menu)

if length(choices) > 0
    println("You like the following fruits:")
    for i in choices
        println("  - ", options[i])
    end
else
    println("Menu canceled.")
end
\end{minted}



Output:




\begin{lstlisting}
Select the fruits you like:
[press: d=done, a=all, n=none]
   [ ] apple
 > [X] orange
   [X] grape
   [ ] strawberry
   [ ] blueberry
   [X] peach
   [ ] lemon
   [ ] lime
You like the following fruits:
  - orange
  - grape
  - peach
\end{lstlisting}



\hypertarget{664736390801158626}{}


\subsection{Customization / Configuration}



All interface customization is done through the keyword only \texttt{TerminalMenus.config()} function.



\hypertarget{10322653734691696332}{}


\subsubsection{Arguments}



\begin{itemize}
\item \texttt{charset::Symbol=:na}: ui characters to use (\texttt{:ascii} or \texttt{:unicode}); overridden by other arguments


\item \texttt{cursor::Char={\textquotesingle}>{\textquotesingle}|{\textquotesingle}→{\textquotesingle}}: character to use for cursor


\item \texttt{up\_arrow::Char={\textquotesingle}{\textasciicircum}{\textquotesingle}|{\textquotesingle}↑{\textquotesingle}}: character to use for up arrow


\item \texttt{down\_arrow::Char={\textquotesingle}v{\textquotesingle}|{\textquotesingle}↓{\textquotesingle}}: character to use for down arrow


\item \texttt{checked::String={\textquotedbl}[X]{\textquotedbl}|{\textquotedbl}✓{\textquotedbl}}: string to use for checked


\item \texttt{unchecked::String={\textquotedbl}[ ]{\textquotedbl}|{\textquotedbl}⬚{\textquotedbl})}: string to use for unchecked


\item \texttt{scroll::Symbol=:na}: If \texttt{:wrap} then wrap the cursor around top and bottom, if :\texttt{nowrap} do not wrap cursor


\item \texttt{supress\_output::Bool=false}: For testing. If true, menu will not be printed to console.


\item \texttt{ctrl\_c\_interrupt::Bool=true}: If \texttt{false}, return empty on {\textasciicircum}C, if \texttt{true} throw InterruptException() on {\textasciicircum}C

\end{itemize}


\hypertarget{18222617908278532347}{}


\subsubsection{Examples}




\begin{minted}{julia}
julia> menu = MultiSelectMenu(options, pagesize=5);

julia> request(menu) # ASCII is used by default
[press: d=done, a=all, n=none]
   [ ] apple
   [X] orange
   [ ] grape
 > [X] strawberry
v  [ ] blueberry
Set([4, 2])

julia> TerminalMenus.config(charset=:unicode)

julia> request(menu)
[press: d=done, a=all, n=none]
   ⬚ apple
   ✓ orange
   ⬚ grape
 → ✓ strawberry
↓  ⬚ blueberry
Set([4, 2])

julia> TerminalMenus.config(checked="YEP!", unchecked="NOPE", cursor='⧐')

julia> request(menu)
[press: d=done, a=all, n=none]
   NOPE apple
   YEP! orange
   NOPE grape
 ⧐ YEP! strawberry
↓  NOPE blueberry
Set([4, 2])

\end{minted}



\hypertarget{13487828328085508990}{}


\section{References}


\hypertarget{1741947168860119796}{} 
\hyperlink{1741947168860119796}{\texttt{Base.atreplinit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
atreplinit(f)
\end{minted}

Register a one-argument function to be called before the REPL interface is initialized in interactive sessions; this is useful to customize the interface. The argument of \texttt{f} is the REPL object. This function should be called from within the \texttt{.julia/config/startup.jl} initialization file.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/client.jl#L326-L333}{\texttt{source}}


\end{adjustwidth}

\hypertarget{686205674013349701}{}


\chapter{随机数}





Random number generation in Julia uses the \href{http://www.math.sci.hiroshima-u.ac.jp/{\textasciitilde}m-mat/MT/SFMT/\#dSFMT}{Mersenne Twister library} via \texttt{MersenneTwister} objects. Julia has a global RNG, which is used by default. Other RNG types can be plugged in by inheriting the \texttt{AbstractRNG} type; they can then be used to have multiple streams of random numbers. Besides \texttt{MersenneTwister}, Julia also provides the \texttt{RandomDevice} RNG type, which is a wrapper over the OS provided entropy.



大部分与随机数生成相关的函数都接受一个可选的 \texttt{AbstractRNG} 对象作为第一个参数，如果不指定则使用全局默认的。此外，某些函数还接受一个可选的维度参数 \texttt{dims...} (可以是元组）来生成随机数组。



一个 \texttt{MersenneTwister} 或 \texttt{RandomDevice} RNG 能够生成如下类型的随机数： \hyperlink{2727296760866702904}{\texttt{Float16}}, \hyperlink{8101639384272933082}{\texttt{Float32}}, \hyperlink{5027751419500983000}{\texttt{Float64}}, \hyperlink{749816618809421837}{\texttt{BigFloat}}, \hyperlink{46725311238864537}{\texttt{Bool}}, \hyperlink{5857518405103968275}{\texttt{Int8}}, \hyperlink{6609065134969660118}{\texttt{UInt8}}, \hyperlink{6667287249103968645}{\texttt{Int16}}, \hyperlink{7018610346698168012}{\texttt{UInt16}}, \hyperlink{10103694114785108551}{\texttt{Int32}}, \hyperlink{8690996847580776341}{\texttt{UInt32}}, \hyperlink{7720564657383125058}{\texttt{Int64}}, \hyperlink{5500998675195555601}{\texttt{UInt64}}, \hyperlink{8012327724714767060}{\texttt{Int128}}, \hyperlink{14811222188335428522}{\texttt{UInt128}}, \hyperlink{423405808990690832}{\texttt{BigInt}} （或者这些类型的复数）。 随机浮点数在  \([0, 1)\)  区间均匀生成。由于 \texttt{BigInt} 代表无界的整数，必须要指定区间（如 \texttt{rand(big.(1:6))}）。



另外，正态和指数分布是针对某些 \texttt{AbstractFloat} 和 \texttt{Complex} 类型，详细内容见 \hyperlink{7347069443766288058}{\texttt{randn}} 和 \hyperlink{17131026676213441996}{\texttt{randexp}}。



\begin{quote}
\textbf{Warn}

Because the precise way in which random numbers are generated is considered an implementation detail, bug fixes and speed improvements may change the stream of numbers that are generated after a version change. Relying on a specific seed or generated stream of numbers during unit testing is thus discouraged - consider testing properties of the methods in question instead.

\end{quote}


\hypertarget{4356963021367801788}{}


\section{Random numbers module}


\hypertarget{10183586789119175812}{} 
\hyperlink{10183586789119175812}{\texttt{Random.Random}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Random
\end{minted}

Support for generating random numbers. Provides \hyperlink{7668863842145012694}{\texttt{rand}}, \hyperlink{7347069443766288058}{\texttt{randn}}, \hyperlink{17421972100838426566}{\texttt{AbstractRNG}}, \hyperlink{4960058165975837552}{\texttt{MersenneTwister}}, and \hyperlink{14367539717133476780}{\texttt{RandomDevice}}.



\end{adjustwidth}

\hypertarget{17130229276474091458}{}


\section{Random generation functions}


\hypertarget{7668863842145012694}{} 
\hyperlink{7668863842145012694}{\texttt{Base.rand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rand([rng=GLOBAL_RNG], [S], [dims...])
\end{minted}

Pick a random element or array of random elements from the set of values specified by \texttt{S}; \texttt{S} can be

\begin{itemize}
\item an indexable collection (for example \texttt{1:9} or \texttt{({\textquotesingle}x{\textquotesingle}, {\textquotedbl}y{\textquotedbl}, :z)}),


\item an \texttt{AbstractDict} or \texttt{AbstractSet} object,


\item a string (considered as a collection of characters), or


\item a type: the set of values to pick from is then equivalent to \texttt{typemin(S):typemax(S)} for integers (this is not applicable to \hyperlink{423405808990690832}{\texttt{BigInt}}), to  \([0, 1)\)  for floating point numbers and to  \([0, 1)+i[0, 1)]\)  for complex floating point numbers;

\end{itemize}
\texttt{S} defaults to \hyperlink{5027751419500983000}{\texttt{Float64}}. When only one argument is passed besides the optional \texttt{rng} and is a \texttt{Tuple}, it is interpreted as a collection of values (\texttt{S}) and not as \texttt{dims}.

\begin{quote}
\textbf{Julia 1.1}

Support for \texttt{S} as a tuple requires at least Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> rand(Int, 2)
2-element Array{Int64,1}:
 1339893410598768192
 1575814717733606317

julia> using Random

julia> rand(MersenneTwister(0), Dict(1=>2, 3=>4))
1=>2

julia> rand((2, 3))
3

julia> rand(Float64, (2, 3))
2×3 Array{Float64,2}:
 0.999717  0.0143835  0.540787
 0.696556  0.783855   0.938235
\end{minted}

\begin{quote}
\textbf{Note}

The complexity of \texttt{rand(rng, s::Union\{AbstractDict,AbstractSet\})} is linear in the length of \texttt{s}, unless an optimized method with constant complexity is available, which is the case for \texttt{Dict}, \texttt{Set} and \texttt{BitSet}. For more than a few calls, use \texttt{rand(rng, collect(s))} instead, or either \texttt{rand(rng, Dict(s))} or \texttt{rand(rng, Set(s))} as appropriate.

\end{quote}


\end{adjustwidth}
\hypertarget{7078395971362144272}{} 
\hyperlink{7078395971362144272}{\texttt{Random.rand!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rand!([rng=GLOBAL_RNG], A, [S=eltype(A)])
\end{minted}

Populate the array \texttt{A} with random values. If \texttt{S} is specified (\texttt{S} can be a type or a collection, cf. \hyperlink{7668863842145012694}{\texttt{rand}} for details), the values are picked randomly from \texttt{S}. This is equivalent to \texttt{copyto!(A, rand(rng, S, size(A)))} but without allocating a new array.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> rand!(rng, zeros(5))
5-element Array{Float64,1}:
 0.5908446386657102
 0.7667970365022592
 0.5662374165061859
 0.4600853424625171
 0.7940257103317943
\end{minted}



\end{adjustwidth}
\hypertarget{6994846923428691074}{} 
\hyperlink{6994846923428691074}{\texttt{Random.bitrand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
bitrand([rng=GLOBAL_RNG], [dims...])
\end{minted}

Generate a \texttt{BitArray} of random boolean values.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> bitrand(rng, 10)
10-element BitArray{1}:
 0
 1
 1
 1
 1
 0
 1
 0
 0
 1
\end{minted}



\end{adjustwidth}
\hypertarget{7347069443766288058}{} 
\hyperlink{7347069443766288058}{\texttt{Base.randn}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
randn([rng=GLOBAL_RNG], [T=Float64], [dims...])
\end{minted}

Generate a normally-distributed random number of type \texttt{T} with mean 0 and standard deviation 1. Optionally generate an array of normally-distributed random numbers. The \texttt{Base} module currently provides an implementation for the types \hyperlink{2727296760866702904}{\texttt{Float16}}, \hyperlink{8101639384272933082}{\texttt{Float32}}, and \hyperlink{5027751419500983000}{\texttt{Float64}} (the default), and their \hyperlink{11302502367029942782}{\texttt{Complex}} counterparts. When the type argument is complex, the values are drawn from the circularly symmetric complex normal distribution of variance 1 (corresponding to real and imaginary part having independent normal distribution with mean zero and variance \texttt{1/2}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> using Random

julia> rng = MersenneTwister(1234);

julia> randn(rng, ComplexF64)
0.6133070881429037 - 0.6376291670853887im

julia> randn(rng, ComplexF32, (2, 3))
2×3 Array{Complex{Float32},2}:
 -0.349649-0.638457im  0.376756-0.192146im  -0.396334-0.0136413im
  0.611224+1.56403im   0.355204-0.365563im  0.0905552+1.31012im
\end{minted}



\end{adjustwidth}
\hypertarget{15194943605954659727}{} 
\hyperlink{15194943605954659727}{\texttt{Random.randn!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
randn!([rng=GLOBAL_RNG], A::AbstractArray) -> A
\end{minted}

Fill the array \texttt{A} with normally-distributed (mean 0, standard deviation 1) random numbers. Also see the \hyperlink{7668863842145012694}{\texttt{rand}} function.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> randn!(rng, zeros(5))
5-element Array{Float64,1}:
  0.8673472019512456
 -0.9017438158568171
 -0.4944787535042339
 -0.9029142938652416
  0.8644013132535154
\end{minted}



\end{adjustwidth}
\hypertarget{17131026676213441996}{} 
\hyperlink{17131026676213441996}{\texttt{Random.randexp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
randexp([rng=GLOBAL_RNG], [T=Float64], [dims...])
\end{minted}

Generate a random number of type \texttt{T} according to the exponential distribution with scale 1. Optionally generate an array of such random numbers. The \texttt{Base} module currently provides an implementation for the types \hyperlink{2727296760866702904}{\texttt{Float16}}, \hyperlink{8101639384272933082}{\texttt{Float32}}, and \hyperlink{5027751419500983000}{\texttt{Float64}} (the default).

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> randexp(rng, Float32)
2.4835055f0

julia> randexp(rng, 3, 3)
3×3 Array{Float64,2}:
 1.5167    1.30652   0.344435
 0.604436  2.78029   0.418516
 0.695867  0.693292  0.643644
\end{minted}



\end{adjustwidth}
\hypertarget{3451932378818354751}{} 
\hyperlink{3451932378818354751}{\texttt{Random.randexp!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
randexp!([rng=GLOBAL_RNG], A::AbstractArray) -> A
\end{minted}

Fill the array \texttt{A} with random numbers following the exponential distribution (with scale 1).

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> randexp!(rng, zeros(5))
5-element Array{Float64,1}:
 2.4835053723904896
 1.516703605376473
 0.6044364871025417
 0.6958665886385867
 1.3065196315496677
\end{minted}



\end{adjustwidth}
\hypertarget{3465524779478434258}{} 
\hyperlink{3465524779478434258}{\texttt{Random.randstring}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
randstring([rng=GLOBAL_RNG], [chars], [len=8])
\end{minted}

Create a random string of length \texttt{len}, consisting of characters from \texttt{chars}, which defaults to the set of upper- and lower-case letters and the digits 0-9. The optional \texttt{rng} argument specifies a random number generator, see \href{@ref}{Random Numbers}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Random.seed!(0); randstring()
"0IPrGg0J"

julia> randstring(MersenneTwister(0), 'a':'z', 6)
"aszvqk"

julia> randstring("ACGT")
"TATCGGTC"
\end{minted}

\begin{quote}
\textbf{Note}

\texttt{chars} can be any collection of characters, of type \texttt{Char} or \texttt{UInt8} (more efficient), provided \hyperlink{7668863842145012694}{\texttt{rand}} can randomly pick characters from it.

\end{quote}


\end{adjustwidth}

\hypertarget{1694954649783113139}{}


\section{Subsequences, permutations and shuffling}


\hypertarget{10454370655022505544}{} 
\hyperlink{10454370655022505544}{\texttt{Random.randsubseq}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
randsubseq([rng=GLOBAL_RNG,] A, p) -> Vector
\end{minted}

Return a vector consisting of a random subsequence of the given array \texttt{A}, where each element of \texttt{A} is included (in order) with independent probability \texttt{p}. (Complexity is linear in \texttt{p*length(A)}, so this function is efficient even if \texttt{p} is small and \texttt{A} is large.) Technically, this process is known as {\textquotedbl}Bernoulli sampling{\textquotedbl} of \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> randsubseq(rng, collect(1:8), 0.3)
2-element Array{Int64,1}:
 7
 8
\end{minted}



\end{adjustwidth}
\hypertarget{16120735695998231549}{} 
\hyperlink{16120735695998231549}{\texttt{Random.randsubseq!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
randsubseq!([rng=GLOBAL_RNG,] S, A, p)
\end{minted}

Like \hyperlink{10454370655022505544}{\texttt{randsubseq}}, but the results are stored in \texttt{S} (which is resized as needed).

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> S = Int64[];

julia> randsubseq!(rng, S, collect(1:8), 0.3);

julia> S
2-element Array{Int64,1}:
 7
 8
\end{minted}



\end{adjustwidth}
\hypertarget{7342203624124611352}{} 
\hyperlink{7342203624124611352}{\texttt{Random.randperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
randperm([rng=GLOBAL_RNG,] n::Integer)
\end{minted}

Construct a random permutation of length \texttt{n}. The optional \texttt{rng} argument specifies a random number generator (see \href{@ref}{Random Numbers}). The element type of the result is the same as the type of \texttt{n}.

To randomly permute an arbitrary vector, see \hyperlink{16742615893822221762}{\texttt{shuffle}} or \hyperlink{15315300334019616632}{\texttt{shuffle!}}.

\begin{quote}
\textbf{Julia 1.1}

In Julia 1.1 \texttt{randperm} returns a vector \texttt{v} with \texttt{eltype(v) == typeof(n)} while in Julia 1.0 \texttt{eltype(v) == Int}.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> randperm(MersenneTwister(1234), 4)
4-element Array{Int64,1}:
 2
 1
 4
 3
\end{minted}



\end{adjustwidth}
\hypertarget{9956290992837499502}{} 
\hyperlink{9956290992837499502}{\texttt{Random.randperm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
randperm!([rng=GLOBAL_RNG,] A::Array{<:Integer})
\end{minted}

Construct in \texttt{A} a random permutation of length \texttt{length(A)}. The optional \texttt{rng} argument specifies a random number generator (see \href{@ref}{Random Numbers}). To randomly permute an arbitrary vector, see \hyperlink{16742615893822221762}{\texttt{shuffle}} or \hyperlink{15315300334019616632}{\texttt{shuffle!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> randperm!(MersenneTwister(1234), Vector{Int}(undef, 4))
4-element Array{Int64,1}:
 2
 1
 4
 3
\end{minted}



\end{adjustwidth}
\hypertarget{8716855906711617057}{} 
\hyperlink{8716855906711617057}{\texttt{Random.randcycle}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
randcycle([rng=GLOBAL_RNG,] n::Integer)
\end{minted}

Construct a random cyclic permutation of length \texttt{n}. The optional \texttt{rng} argument specifies a random number generator, see \href{@ref}{Random Numbers}. The element type of the result is the same as the type of \texttt{n}.

\begin{quote}
\textbf{Julia 1.1}

In Julia 1.1 \texttt{randcycle} returns a vector \texttt{v} with \texttt{eltype(v) == typeof(n)} while in Julia 1.0 \texttt{eltype(v) == Int}.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> randcycle(MersenneTwister(1234), 6)
6-element Array{Int64,1}:
 3
 5
 4
 6
 1
 2
\end{minted}



\end{adjustwidth}
\hypertarget{6946208329788361422}{} 
\hyperlink{6946208329788361422}{\texttt{Random.randcycle!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
randcycle!([rng=GLOBAL_RNG,] A::Array{<:Integer})
\end{minted}

Construct in \texttt{A} a random cyclic permutation of length \texttt{length(A)}. The optional \texttt{rng} argument specifies a random number generator, see \href{@ref}{Random Numbers}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> randcycle!(MersenneTwister(1234), Vector{Int}(undef, 6))
6-element Array{Int64,1}:
 3
 5
 4
 6
 1
 2
\end{minted}



\end{adjustwidth}
\hypertarget{16742615893822221762}{} 
\hyperlink{16742615893822221762}{\texttt{Random.shuffle}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
shuffle([rng=GLOBAL_RNG,] v::AbstractArray)
\end{minted}

Return a randomly permuted copy of \texttt{v}. The optional \texttt{rng} argument specifies a random number generator (see \href{@ref}{Random Numbers}). To permute \texttt{v} in-place, see \hyperlink{15315300334019616632}{\texttt{shuffle!}}. To obtain randomly permuted indices, see \hyperlink{7342203624124611352}{\texttt{randperm}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> shuffle(rng, Vector(1:10))
10-element Array{Int64,1}:
  6
  1
 10
  2
  3
  9
  5
  7
  4
  8
\end{minted}



\end{adjustwidth}
\hypertarget{15315300334019616632}{} 
\hyperlink{15315300334019616632}{\texttt{Random.shuffle!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
shuffle!([rng=GLOBAL_RNG,] v::AbstractArray)
\end{minted}

In-place version of \hyperlink{16742615893822221762}{\texttt{shuffle}}: randomly permute \texttt{v} in-place, optionally supplying the random-number generator \texttt{rng}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> shuffle!(rng, Vector(1:16))
16-element Array{Int64,1}:
  2
 15
  5
 14
  1
  9
 10
  6
 11
  3
 16
  7
  4
 12
  8
 13
\end{minted}



\end{adjustwidth}

\hypertarget{16600936393177391619}{}


\section{Generators (creation and seeding)}


\hypertarget{9373195541397142847}{} 
\hyperlink{9373195541397142847}{\texttt{Random.seed!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
seed!([rng=GLOBAL_RNG], seed) -> rng
seed!([rng=GLOBAL_RNG]) -> rng
\end{minted}

Reseed the random number generator: \texttt{rng} will give a reproducible sequence of numbers if and only if a \texttt{seed} is provided. Some RNGs don{\textquotesingle}t accept a seed, like \texttt{RandomDevice}. After the call to \texttt{seed!}, \texttt{rng} is equivalent to a newly created object initialized with the same seed.

If \texttt{rng} is not specified, it defaults to seeding the state of the shared thread-local generator.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Random.seed!(1234);

julia> x1 = rand(2)
2-element Array{Float64,1}:
 0.590845
 0.766797

julia> Random.seed!(1234);

julia> x2 = rand(2)
2-element Array{Float64,1}:
 0.590845
 0.766797

julia> x1 == x2
true

julia> rng = MersenneTwister(1234); rand(rng, 2) == x1
true

julia> MersenneTwister(1) == Random.seed!(rng, 1)
true

julia> rand(Random.seed!(rng), Bool) # not reproducible
true

julia> rand(Random.seed!(rng), Bool)
false

julia> rand(MersenneTwister(), Bool) # not reproducible either
true
\end{minted}



\end{adjustwidth}
\hypertarget{17421972100838426566}{} 
\hyperlink{17421972100838426566}{\texttt{Random.AbstractRNG}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractRNG
\end{minted}

Supertype for random number generators such as \hyperlink{4960058165975837552}{\texttt{MersenneTwister}} and \hyperlink{14367539717133476780}{\texttt{RandomDevice}}.



\end{adjustwidth}
\hypertarget{4960058165975837552}{} 
\hyperlink{4960058165975837552}{\texttt{Random.MersenneTwister}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
MersenneTwister(seed)
MersenneTwister()
\end{minted}

Create a \texttt{MersenneTwister} RNG object. Different RNG objects can have their own seeds, which may be useful for generating different streams of random numbers. The \texttt{seed} may be a non-negative integer or a vector of \texttt{UInt32} integers. If no seed is provided, a randomly generated one is created (using entropy from the system). See the \hyperlink{9373195541397142847}{\texttt{seed!}} function for reseeding an already existing \texttt{MersenneTwister} object.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> x1 = rand(rng, 2)
2-element Array{Float64,1}:
 0.5908446386657102
 0.7667970365022592

julia> rng = MersenneTwister(1234);

julia> x2 = rand(rng, 2)
2-element Array{Float64,1}:
 0.5908446386657102
 0.7667970365022592

julia> x1 == x2
true
\end{minted}



\end{adjustwidth}
\hypertarget{14367539717133476780}{} 
\hyperlink{14367539717133476780}{\texttt{Random.RandomDevice}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RandomDevice()
\end{minted}

Create a \texttt{RandomDevice} RNG object. Two such objects will always generate different streams of random numbers. The entropy is obtained from the operating system.



\end{adjustwidth}

\hypertarget{17771818288641906623}{}


\section{Hooking into the \texttt{Random} API}



There are two mostly orthogonal ways to extend \texttt{Random} functionalities:



\begin{itemize}
\item[1. ] generating random values of custom types


\item[2. ] creating new generators

\end{itemize}


The API for 1) is quite functional, but is relatively recent so it may still have to evolve in subsequent releases of the \texttt{Random} module. For example, it{\textquotesingle}s typically sufficient to implement one \texttt{rand} method in order to have all other usual methods work automatically.



The API for 2) is still rudimentary, and may require more work than strictly necessary from the implementor, in order to support usual types of generated values.



\hypertarget{7184618023384207012}{}


\subsection{Generating random values of custom types}



Generating random values for some distributions may involve various trade-offs. \emph{Pre-computed} values, such as an \href{https://en.wikipedia.org/wiki/Alias\_method}{alias table} for discrete distributions, or \href{https://en.wikipedia.org/wiki/Rejection\_sampling}{“squeezing” functions} for univariate distributions, can speed up sampling considerably. How much information should be pre-computed can depend on the number of values we plan to draw from a distribution. Also, some random number generators can have certain properties that various algorithms may want to exploit.



The \texttt{Random} module defines a customizable framework for obtaining random values that can address these issues. Each invocation of \texttt{rand} generates a \emph{sampler} which can be customized with the above trade-offs in mind, by adding methods to \texttt{Sampler}, which in turn can dispatch on the random number generator, the object that characterizes the distribution, and a suggestion for the number of repetitions. Currently, for the latter, \texttt{Val\{1\}} (for a single sample) and \texttt{Val\{Inf\}} (for an arbitrary number) are used, with \texttt{Random.Repetition} an alias for both.



The object returned by \texttt{Sampler} is then used to generate the random values. When implementing the random generation interface for a value \texttt{X} that can be sampled from, the implementor should define the method




\begin{minted}{julia}
rand(rng, sampler)
\end{minted}



for the particular \texttt{sampler} returned by \texttt{Sampler(rng, X, repetition)}.



Samplers can be arbitrary values that implement \texttt{rand(rng, sampler)}, but for most applications the following predefined samplers may be sufficient:



\begin{itemize}
\item[1. ] \texttt{SamplerType\{T\}()} can be used for implementing samplers that draw from type \texttt{T} (e.g. \texttt{rand(Int)}). This is the default returned by \texttt{Sampler} for \emph{types}.


\item[2. ] \texttt{SamplerTrivial(self)} is a simple wrapper for \texttt{self}, which can be accessed with \texttt{[]}. This is the recommended sampler when no pre-computed information is needed (e.g. \texttt{rand(1:3)}), and is the default returned by \texttt{Sampler} for \emph{values}.


\item[3. ] \texttt{SamplerSimple(self, data)} also contains the additional \texttt{data} field, which can be used to store arbitrary pre-computed values, which should be computed in a \emph{custom method} of \texttt{Sampler}.

\end{itemize}


We provide examples for each of these. We assume here that the choice of algorithm is independent of the RNG, so we use \texttt{AbstractRNG} in our signatures.


\hypertarget{6931553397315604036}{} 
\hyperlink{6931553397315604036}{\texttt{Random.Sampler}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Sampler(rng, x, repetition = Val(Inf))
\end{minted}

Return a sampler object that can be used to generate random values from \texttt{rng} for \texttt{x}.

When \texttt{sp = Sampler(rng, x, repetition)}, \texttt{rand(rng, sp)} will be used to draw random values, and should be defined accordingly.

\texttt{repetition} can be \texttt{Val(1)} or \texttt{Val(Inf)}, and should be used as a suggestion for deciding the amount of precomputation, if applicable.

\hyperlink{2169729397706095790}{\texttt{Random.SamplerType}} and \hyperlink{2575204551890994411}{\texttt{Random.SamplerTrivial}} are default fallbacks for \emph{types} and \emph{values}, respectively. \hyperlink{17949645161476858061}{\texttt{Random.SamplerSimple}} can be used to store pre-computed values without defining extra types for only this purpose.



\end{adjustwidth}
\hypertarget{2169729397706095790}{} 
\hyperlink{2169729397706095790}{\texttt{Random.SamplerType}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SamplerType{T}()
\end{minted}

A sampler for types, containing no other information. The default fallback for \texttt{Sampler} when called with types.



\end{adjustwidth}
\hypertarget{2575204551890994411}{} 
\hyperlink{2575204551890994411}{\texttt{Random.SamplerTrivial}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SamplerTrivial(x)
\end{minted}

Create a sampler that just wraps the given value \texttt{x}. This is the default fall-back for values. The \texttt{eltype} of this sampler is equal to \texttt{eltype(x)}.

The recommended use case is sampling from values without precomputed data.



\end{adjustwidth}
\hypertarget{17949645161476858061}{} 
\hyperlink{17949645161476858061}{\texttt{Random.SamplerSimple}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SamplerSimple(x, data)
\end{minted}

Create a sampler that wraps the given value \texttt{x} and the \texttt{data}. The \texttt{eltype} of this sampler is equal to \texttt{eltype(x)}.

The recommended use case is sampling from values with precomputed data.



\end{adjustwidth}

Decoupling pre-computation from actually generating the values is part of the API, and is also available to the user. As an example, assume that \texttt{rand(rng, 1:20)} has to be called repeatedly in a loop: the way to take advantage of this decoupling is as follows:




\begin{minted}{julia}
rng = MersenneTwister()
sp = Random.Sampler(rng, 1:20) # or Random.Sampler(MersenneTwister, 1:20)
for x in X
    n = rand(rng, sp) # similar to n = rand(rng, 1:20)
    # use n
end
\end{minted}



This is the mechanism that is also used in the standard library, e.g. by the default implementation of random array generation (like in \texttt{rand(1:20, 10)}).



\hypertarget{15852577436081724496}{}


\subsubsection{Generating values from a type}



Given a type \texttt{T}, it{\textquotesingle}s currently assumed that if \texttt{rand(T)} is defined, an object of type \texttt{T} will be produced. \texttt{SamplerType} is the \emph{default sampler for types}. In order to define random generation of values of type \texttt{T}, the \texttt{rand(rng::AbstractRNG, ::Random.SamplerType\{T\})} method should be defined, and should return values what \texttt{rand(rng, T)} is expected to return.



Let{\textquotesingle}s take the following example: we implement a \texttt{Die} type, with a variable number \texttt{n} of sides, numbered from \texttt{1} to \texttt{n}. We want \texttt{rand(Die)} to produce a \texttt{Die} with a random number of up to 20 sides (and at least 4):




\begin{minted}{julia}
struct Die
    nsides::Int # number of sides
end

Random.rand(rng::AbstractRNG, ::Random.SamplerType{Die}) = Die(rand(rng, 4:20))

# output

\end{minted}



Scalar and array methods for \texttt{Die} now work as expected:




\begin{minted}{jlcon}
julia> rand(Die)
Die(10)

julia> rand(MersenneTwister(0), Die)
Die(16)

julia> rand(Die, 3)
3-element Array{Die,1}:
 Die(5)
 Die(20)
 Die(9)

julia> a = Vector{Die}(undef, 3); rand!(a)
3-element Array{Die,1}:
 Die(11)
 Die(20)
 Die(10)
\end{minted}



\hypertarget{14351717451744151937}{}


\subsubsection{A simple sampler without pre-computed data}



Here we define a sampler for a collection. If no pre-computed data is required, it can be implemented with a \texttt{SamplerTrivial} sampler, which is in fact the \emph{default fallback for values}.



In order to define random generation out of objects of type \texttt{S}, the following method should be defined: \texttt{rand(rng::AbstractRNG, sp::Random.SamplerTrivial\{S\})}. Here, \texttt{sp} simply wraps an object of type \texttt{S}, which can be accessed via \texttt{sp[]}. Continuing the \texttt{Die} example, we want now to define \texttt{rand(d::Die)} to produce an \texttt{Int} corresponding to one of \texttt{d}{\textquotesingle}s sides:




\begin{minted}{jlcon}
julia> Random.rand(rng::AbstractRNG, d::Random.SamplerTrivial{Die}) = rand(rng, 1:d[].nsides);

julia> rand(Die(4))
2

julia> rand(Die(4), 3)
3-element Array{Any,1}:
 1
 4
 2
\end{minted}



Given a collection type \texttt{S}, it{\textquotesingle}s currently assumed that if \texttt{rand(::S)} is defined, an object of type \texttt{eltype(S)} will be produced. In the last example, a \texttt{Vector\{Any\}} is produced; the reason is that \texttt{eltype(Die) == Any}. The remedy is to define \texttt{Base.eltype(::Type\{Die\}) = Int}.



\hypertarget{1884287946239364410}{}


\subsubsection{Generating values for an \texttt{AbstractFloat} type}



\texttt{AbstractFloat} types are special-cased, because by default random values are not produced in the whole type domain, but rather in \texttt{[0,1)}. The following method should be implemented for \texttt{T <: AbstractFloat}: \texttt{Random.rand(::AbstractRNG, ::Random.SamplerTrivial\{Random.CloseOpen01\{T\}\})}



\hypertarget{11354689514356683227}{}


\subsubsection{An optimized sampler with pre-computed data}



Consider a discrete distribution, where numbers \texttt{1:n} are drawn with given probabilities that sum to one. When many values are needed from this distribution, the fastest method is using an \href{https://en.wikipedia.org/wiki/Alias\_method}{alias table}. We don{\textquotesingle}t provide the algorithm for building such a table here, but suppose it is available in \texttt{make\_alias\_table(probabilities)} instead, and \texttt{draw\_number(rng, alias\_table)} can be used to draw a random number from it.



Suppose that the distribution is described by




\begin{minted}{julia}
struct DiscreteDistribution{V <: AbstractVector}
    probabilities::V
end
\end{minted}



and that we \emph{always} want to build an alias table, regardless of the number of values needed (we learn how to customize this below). The methods




\begin{minted}{julia}
Random.eltype(::Type{<:DiscreteDistribution}) = Int

function Random.Sampler(::Type{<:AbstractRNG}, distribution::DiscreteDistribution, ::Repetition)
    SamplerSimple(disribution, make_alias_table(distribution.probabilities))
end
\end{minted}



should be defined to return a sampler with pre-computed data, then




\begin{minted}{julia}
function rand(rng::AbstractRNG, sp::SamplerSimple{<:DiscreteDistribution})
    draw_number(rng, sp.data)
end
\end{minted}



will be used to draw the values.



\hypertarget{4100919623062869062}{}


\subsubsection{Custom sampler types}



The \texttt{SamplerSimple} type is sufficient for most use cases with precomputed data. However, in order to demonstrate how to use custom sampler types, here we implement something similar to \texttt{SamplerSimple}.



Going back to our \texttt{Die} example: \texttt{rand(::Die)} uses random generation from a range, so there is an opportunity for this optimization. We call our custom sampler \texttt{SamplerDie}.




\begin{minted}{julia}
import Random: Sampler, rand

struct SamplerDie <: Sampler{Int} # generates values of type Int
    die::Die
    sp::Sampler{Int} # this is an abstract type, so this could be improved
end

Sampler(RNG::Type{<:AbstractRNG}, die::Die, r::Random.Repetition) =
    SamplerDie(die, Sampler(RNG, 1:die.nsides, r))
# the `r` parameter will be explained later on

rand(rng::AbstractRNG, sp::SamplerDie) = rand(rng, sp.sp)
\end{minted}



It{\textquotesingle}s now possible to get a sampler with \texttt{sp = Sampler(rng, die)}, and use \texttt{sp} instead of \texttt{die} in any \texttt{rand} call involving \texttt{rng}. In the simplistic example above, \texttt{die} doesn{\textquotesingle}t need to be stored in \texttt{SamplerDie} but this is often the case in practice.



Of course, this pattern is so frequent that the helper type used above, namely \texttt{Random.SamplerSimple}, is available, saving us the definition of \texttt{SamplerDie}: we could have implemented our decoupling with:




\begin{minted}{julia}
Sampler(RNG::Type{<:AbstractRNG}, die::Die, r::Random.Repetition) =
    SamplerSimple(die, Sampler(RNG, 1:die.nsides, r))

rand(rng::AbstractRNG, sp::SamplerSimple{Die}) = rand(rng, sp.data)
\end{minted}



Here, \texttt{sp.data} refers to the second parameter in the call to the \texttt{SamplerSimple} constructor (in this case equal to \texttt{Sampler(rng, 1:die.nsides, r)}), while the \texttt{Die} object can be accessed via \texttt{sp[]}.



Like \texttt{SamplerDie}, any custom sampler must be a subtype of \texttt{Sampler\{T\}} where \texttt{T} is the type of the generated values. Note that \texttt{SamplerSimple(x, data) isa Sampler\{eltype(x)\}}, so this constrains what the first argument to \texttt{SamplerSimple} can be (it{\textquotesingle}s recommended to use \texttt{SamplerSimple} like in the \texttt{Die} example, where \texttt{x} is simply forwarded while defining a \texttt{Sampler} method). Similarly, \texttt{SamplerTrivial(x) isa Sampler\{eltype(x)\}}.



Another helper type is currently available for other cases, \texttt{Random.SamplerTag}, but is considered as internal API, and can break at any time without proper deprecations.



\hypertarget{6227859827856272297}{}


\subsubsection{Using distinct algorithms for scalar or array generation}



In some cases, whether one wants to generate only a handful of values or a large number of values will have an impact on the choice of algorithm. This is handled with the third parameter of the \texttt{Sampler} constructor. Let{\textquotesingle}s assume we defined two helper types for \texttt{Die}, say \texttt{SamplerDie1} which should be used to generate only few random values, and \texttt{SamplerDieMany} for many values. We can use those types as follows:




\begin{minted}{julia}
Sampler(RNG::Type{<:AbstractRNG}, die::Die, ::Val{1}) = SamplerDie1(...)
Sampler(RNG::Type{<:AbstractRNG}, die::Die, ::Val{Inf}) = SamplerDieMany(...)
\end{minted}



Of course, \texttt{rand} must also be defined on those types (i.e. \texttt{rand(::AbstractRNG, ::SamplerDie1)} and \texttt{rand(::AbstractRNG, ::SamplerDieMany)}). Note that, as usual, \texttt{SamplerTrivial} and \texttt{SamplerSimple} can be used if custom types are not necessary.



Note: \texttt{Sampler(rng, x)} is simply a shorthand for \texttt{Sampler(rng, x, Val(Inf))}, and \texttt{Random.Repetition} is an alias for \texttt{Union\{Val\{1\}, Val\{Inf\}\}}.



\hypertarget{17633591859123150}{}


\subsection{Creating new generators}



The API is not clearly defined yet, but as a rule of thumb:



\begin{itemize}
\item[1. ] any \texttt{rand} method producing {\textquotedbl}basic{\textquotedbl} types (\texttt{isbitstype} integer and floating types in \texttt{Base}) should be defined for this specific RNG, if they are needed;


\item[2. ] other documented \texttt{rand} methods accepting an \texttt{AbstractRNG} should work out of the box, (provided the methods from 1) what are relied on are implemented), but can of course be specialized for this RNG if there is room for optimization;


\item[3. ] \texttt{copy} for pseudo-RNGs should return an independent copy that generates the exact same random sequence as the original from that point when called in the same way. When this is not feasible (e.g. hardware-based RNGs), \texttt{copy} must not be implemented.

\end{itemize}


Concerning 1), a \texttt{rand} method may happen to work automatically, but it{\textquotesingle}s not officially supported and may break without warnings in a subsequent release.



To define a new \texttt{rand} method for an hypothetical \texttt{MyRNG} generator, and a value specification \texttt{s} (e.g. \texttt{s == Int}, or \texttt{s == 1:10}) of type \texttt{S==typeof(s)} or \texttt{S==Type\{s\}} if \texttt{s} is a type, the same two methods as we saw before must be defined:



\begin{itemize}
\item[1. ] \texttt{Sampler(::Type\{MyRNG\}, ::S, ::Repetition)}, which returns an object of type say \texttt{SamplerS}


\item[2. ] \texttt{rand(rng::MyRNG, sp::SamplerS)}

\end{itemize}


It can happen that \texttt{Sampler(rng::AbstractRNG, ::S, ::Repetition)} is already defined in the \texttt{Random} module. It would then be possible to skip step 1) in practice (if one wants to specialize generation for this particular RNG type), but the corresponding \texttt{SamplerS} type is considered as internal detail, and may be changed without warning.



\hypertarget{9194362945868125985}{}


\subsubsection{Specializing array generation}



In some cases, for a given RNG type, generating an array of random values can be more efficient with a specialized method than by merely using the decoupling technique explained before. This is for example the case for \texttt{MersenneTwister}, which natively writes random values in an array.



To implement this specialization for \texttt{MyRNG} and for a specification \texttt{s}, producing elements of type \texttt{S}, the following method can be defined: \texttt{rand!(rng::MyRNG, a::AbstractArray\{S\}, ::SamplerS)}, where \texttt{SamplerS} is the type of the sampler returned by \texttt{Sampler(MyRNG, s, Val(Inf))}. Instead of \texttt{AbstractArray}, it{\textquotesingle}s possible to implement the functionality only for a subtype, e.g. \texttt{Array\{S\}}. The non-mutating array method of \texttt{rand} will automatically call this specialization internally.





\hypertarget{3655118098996655995}{}


\chapter{Reproducibility}



By using an RNG parameter initialized with a given seed, you can reproduce the same pseudorandom number sequence when running your program multiple times.  However, a minor release of Julia (e.g. 1.3 to 1.4) \emph{may change} the sequence of pseudorandom numbers generated from a specific seed.  (Even if the sequence produced by a low-level function like \hyperlink{7668863842145012694}{\texttt{rand}} does not change, the output of higher-level functions like \hyperlink{10454370655022505544}{\texttt{randsubseq}} may change due to algorithm updates.)   Rationale: guaranteeing that pseudorandom streams never change prohibits many algorithmic improvements.



If you need to guarantee exact reproducibility of random data, it is advisable to simply \emph{save the data} (e.g. as a supplementary attachment in a scientific publication).  (You can also, of course, specify a particular Julia version and package manifest, especially if you require bit reproducibility.)



Software tests that rely on \emph{specific} {\textquotedbl}random{\textquotedbl} data should also generally save the data or embed it into the test code.  On the other hand, tests that should pass for \emph{most} random data (e.g. testing \texttt{A {\textbackslash} (A*x) ≈ x} for a random matrix \texttt{A = randn(n,n)}) can use an RNG with a fixed seed to ensure that simply running the test many times does not encounter a failure due to very improbable data (e.g. an extremely ill-conditioned matrix).



The statistical \emph{distribution} from which random samples are drawn \emph{is} guaranteed to be the same across any minor Julia releases.



\hypertarget{15457917914318839048}{}


\chapter{SHA}



用法非常直接：




\begin{minted}{julia}
julia> using SHA

julia> bytes2hex(sha256("test"))
"9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08"
\end{minted}



每个导出函数（SHA-1, SHA-2 224, 256, 384, 512, 以及 SHA-3 224, 256, 384, 512 函数在本文撰写时都已实现）都可以接受 \texttt{Array\{UInt8\}}, \texttt{ByteString} 或 \texttt{IO} 对象。这使计算文件校验和变得轻而易举：




\begin{minted}{julia}
shell> cat /tmp/test.txt
test
julia> using SHA

julia> open("/tmp/test.txt") do f
           sha2_256(f)
       end
32-element Array{UInt8,1}:
 0x9f
 0x86
 0xd0
 0x81
 0x88
 0x4c
 0x7d
 0x65
    ⋮
 0x5d
 0x6c
 0x15
 0xb0
 0xf0
 0x0a
 0x08
\end{minted}



注意 \texttt{/tmp/text.txt} 文件结尾缺少换行符。Julia 会自动在 \texttt{julia>} 提示符前插入换行符。



由于 \texttt{sha256} 通常指的是 \texttt{sha2\_256}，因此提供了函数名简写，将 \texttt{shaxxx()} 函数调用映射到 \texttt{sha2\_xxx()}。SHA-3 不存在这样的俗称，用户必须使用完整的函数名 \texttt{sha3\_xxx()}。



\texttt{shaxxx()} 接受 \texttt{UInt8} 类型的 \texttt{AbstractString} 和类数组对象（\texttt{NTuple} 和 \texttt{Array}）。



请注意，在本文撰写时，SHA-3 代码还未进行优化，因此会比 SHA-2 慢大约一个数量级。



\hypertarget{13724487893001117879}{}


\chapter{序列化}


\hypertarget{17931089632175850899}{} 
\hyperlink{17931089632175850899}{\texttt{Serialization.serialize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
serialize(stream::IO, value)
\end{minted}

Write an arbitrary value to a stream in an opaque format, such that it can be read back by \hyperlink{5889257128684048834}{\texttt{deserialize}}. The read-back value will be as identical as possible to the original. In general, this process will not work if the reading and writing are done by different versions of Julia, or an instance of Julia with a different system image. \texttt{Ptr} values are serialized as all-zero bit patterns (\texttt{NULL}).

An 8-byte identifying header is written to the stream first. To avoid writing the header, construct a \texttt{Serializer} and use it as the first argument to \texttt{serialize} instead. See also \hyperlink{165660671771374050}{\texttt{Serialization.writeheader}}.




\begin{lstlisting}
serialize(filename::AbstractString, value)
\end{lstlisting}

Open a file and serialize the given value to it.

\begin{quote}
\textbf{Julia 1.1}

This method is available as of Julia 1.1.

\end{quote}


\end{adjustwidth}
\hypertarget{5889257128684048834}{} 
\hyperlink{5889257128684048834}{\texttt{Serialization.deserialize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
deserialize(stream)
\end{minted}

Read a value written by \hyperlink{17931089632175850899}{\texttt{serialize}}. \texttt{deserialize} assumes the binary data read from \texttt{stream} is correct and has been serialized by a compatible implementation of \hyperlink{17931089632175850899}{\texttt{serialize}}. It has been designed with simplicity and performance as a goal and does not validate the data read. Malformed data can result in process termination. The caller has to ensure the integrity and correctness of data read from \texttt{stream}.




\begin{lstlisting}
deserialize(filename::AbstractString)
\end{lstlisting}

Open a file and deserialize its contents.

\begin{quote}
\textbf{Julia 1.1}

This method is available as of Julia 1.1.

\end{quote}


\end{adjustwidth}
\hypertarget{165660671771374050}{} 
\hyperlink{165660671771374050}{\texttt{Serialization.writeheader}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Serialization.writeheader(s::AbstractSerializer)
\end{minted}

Write an identifying header to the specified serializer. The header consists of 8 bytes as follows:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Offset & Description \\
\hline
0 & tag byte (0x37) \\
\hline
1-2 & signature bytes {\textquotedbl}JL{\textquotedbl} \\
\hline
3 & protocol version \\
\hline
4 & bits 0-1: endianness: 0 = little, 1 = big \\
\hline
4 & bits 2-3: platform: 0 = 32-bit, 1 = 64-bit \\
\hline
5-7 & reserved \\
\hline
\end{tabulary}

\end{table}



\end{adjustwidth}

\hypertarget{3058127117657456394}{}


\chapter{共享数组}


\hypertarget{15069300442338861576}{} 
\hyperlink{15069300442338861576}{\texttt{SharedArrays.SharedArray}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SharedArray{T}(dims::NTuple; init=false, pids=Int[])
SharedArray{T,N}(...)
\end{minted}

Construct a \texttt{SharedArray} of a bits type \texttt{T} and size \texttt{dims} across the processes specified by \texttt{pids} - all of which have to be on the same host.  If \texttt{N} is specified by calling \texttt{SharedArray\{T,N\}(dims)}, then \texttt{N} must match the length of \texttt{dims}.

If \texttt{pids} is left unspecified, the shared array will be mapped across all processes on the current host, including the master. But, \texttt{localindices} and \texttt{indexpids} will only refer to worker processes. This facilitates work distribution code to use workers for actual computation with the master process acting as a driver.

If an \texttt{init} function of the type \texttt{initfn(S::SharedArray)} is specified, it is called on all the participating workers.

The shared array is valid as long as a reference to the \texttt{SharedArray} object exists on the node which created the mapping.


\begin{lstlisting}
SharedArray{T}(filename::AbstractString, dims::NTuple, [offset=0]; mode=nothing, init=false, pids=Int[])
SharedArray{T,N}(...)
\end{lstlisting}

Construct a \texttt{SharedArray} backed by the file \texttt{filename}, with element type \texttt{T} (must be a bits type) and size \texttt{dims}, across the processes specified by \texttt{pids} - all of which have to be on the same host. This file is mmapped into the host memory, with the following consequences:

\begin{itemize}
\item The array data must be represented in binary format (e.g., an ASCII format like CSV cannot be supported)


\item Any changes you make to the array values (e.g., \texttt{A[3] = 0}) will also change the values on disk

\end{itemize}
If \texttt{pids} is left unspecified, the shared array will be mapped across all processes on the current host, including the master. But, \texttt{localindices} and \texttt{indexpids} will only refer to worker processes. This facilitates work distribution code to use workers for actual computation with the master process acting as a driver.

\texttt{mode} must be one of \texttt{{\textquotedbl}r{\textquotedbl}}, \texttt{{\textquotedbl}r+{\textquotedbl}}, \texttt{{\textquotedbl}w+{\textquotedbl}}, or \texttt{{\textquotedbl}a+{\textquotedbl}}, and defaults to \texttt{{\textquotedbl}r+{\textquotedbl}} if the file specified by \texttt{filename} already exists, or \texttt{{\textquotedbl}w+{\textquotedbl}} if not. If an \texttt{init} function of the type \texttt{initfn(S::SharedArray)} is specified, it is called on all the participating workers. You cannot specify an \texttt{init} function if the file is not writable.

\texttt{offset} allows you to skip the specified number of bytes at the beginning of the file.



\end{adjustwidth}
\hypertarget{7409079308721392752}{} 
\hyperlink{7409079308721392752}{\texttt{SharedArrays.SharedVector}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SharedVector
\end{minted}

A one-dimensional \hyperlink{15069300442338861576}{\texttt{SharedArray}}.



\end{adjustwidth}
\hypertarget{4014464484316382916}{} 
\hyperlink{4014464484316382916}{\texttt{SharedArrays.SharedMatrix}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SharedMatrix
\end{minted}

A two-dimensional \hyperlink{15069300442338861576}{\texttt{SharedArray}}.



\end{adjustwidth}
\hypertarget{379512234313781053}{} 
\hyperlink{379512234313781053}{\texttt{Distributed.procs}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
procs(S::SharedArray)
\end{minted}

Get the vector of processes mapping the shared array.



\end{adjustwidth}
\hypertarget{5828642841105091437}{} 
\hyperlink{5828642841105091437}{\texttt{SharedArrays.sdata}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sdata(S::SharedArray)
\end{minted}

Returns the actual \texttt{Array} object backing \texttt{S}.



\end{adjustwidth}
\hypertarget{6331641514330199981}{} 
\hyperlink{6331641514330199981}{\texttt{SharedArrays.indexpids}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
indexpids(S::SharedArray)
\end{minted}

Returns the current worker{\textquotesingle}s index in the list of workers mapping the \texttt{SharedArray} (i.e. in the same list returned by \texttt{procs(S)}), or 0 if the \texttt{SharedArray} is not mapped locally.



\end{adjustwidth}
\hypertarget{12447667054613272081}{} 
\hyperlink{12447667054613272081}{\texttt{SharedArrays.localindices}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
localindices(S::SharedArray)
\end{minted}

Returns a range describing the {\textquotedbl}default{\textquotedbl} indices to be handled by the current process.  This range should be interpreted in the sense of linear indexing, i.e., as a sub-range of \texttt{1:length(S)}.  In multi-process contexts, returns an empty range in the parent process (or any process for which \hyperlink{6331641514330199981}{\texttt{indexpids}} returns 0).

It{\textquotesingle}s worth emphasizing that \texttt{localindices} exists purely as a convenience, and you can partition work on the array among workers any way you wish. For a \texttt{SharedArray}, all indices should be equally fast for each worker process.



\end{adjustwidth}

\hypertarget{16962550433784269272}{}


\chapter{套接字}


\hypertarget{16889258743067172297}{} 
\hyperlink{16889258743067172297}{\texttt{Sockets.Sockets}}  -- {Module.}

\begin{adjustwidth}{2em}{0pt}

Support for sockets. Provides \hyperlink{8098410990676145612}{\texttt{IPAddr}} and subtypes, \hyperlink{5453047654537213204}{\texttt{TCPSocket}}, and \hyperlink{5627851531738059255}{\texttt{UDPSocket}}.



\end{adjustwidth}
\hypertarget{9905777280350118583}{} 
\hyperlink{9905777280350118583}{\texttt{Sockets.connect}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
connect([host], port::Integer) -> TCPSocket
\end{minted}

Connect to the host \texttt{host} on port \texttt{port}.



\end{adjustwidth}
\hypertarget{15285016070454152057}{} 
\hyperlink{15285016070454152057}{\texttt{Sockets.connect}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
connect(path::AbstractString) -> PipeEndpoint
\end{minted}

Connect to the named pipe / UNIX domain socket at \texttt{path}.



\end{adjustwidth}
\hypertarget{780704944207038170}{} 
\hyperlink{780704944207038170}{\texttt{Sockets.listen}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
listen([addr, ]port::Integer; backlog::Integer=BACKLOG_DEFAULT) -> TCPServer
\end{minted}

Listen on port on the address specified by \texttt{addr}. By default this listens on \texttt{localhost} only. To listen on all interfaces pass \texttt{IPv4(0)} or \texttt{IPv6(0)} as appropriate. \texttt{backlog} determines how many connections can be pending (not having called \hyperlink{1426793569216032849}{\texttt{accept}}) before the server will begin to reject them. The default value of \texttt{backlog} is 511.



\end{adjustwidth}
\hypertarget{10346115046291513570}{} 
\hyperlink{10346115046291513570}{\texttt{Sockets.listen}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
listen(path::AbstractString) -> PipeServer
\end{minted}

Create and listen on a named pipe / UNIX domain socket.



\end{adjustwidth}
\hypertarget{10301989504197190983}{} 
\hyperlink{10301989504197190983}{\texttt{Sockets.getaddrinfo}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getaddrinfo(host::AbstractString, IPAddr=IPv4) -> IPAddr
\end{minted}

Gets the first IP address of the \texttt{host} of the specified \texttt{IPAddr} type. Uses the operating system{\textquotesingle}s underlying getaddrinfo implementation, which may do a DNS lookup.



\end{adjustwidth}
\hypertarget{11265435361532665287}{} 
\hyperlink{11265435361532665287}{\texttt{Sockets.getipaddr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getipaddr() -> IPAddr
\end{minted}

Get an IP address of the local machine, preferring IPv4 over IPv6. Throws if no addresses are available.


\begin{lstlisting}
getipaddr(addr_type::Type{T}) where T<:IPAddr -> T
\end{lstlisting}

Get an IP address of the local machine of the specified type. Throws if no addresses of the specified type are available.

\textbf{Examples}


\begin{minted}{jlcon}
julia> getipaddr()
ip"192.168.1.28"

julia> getipaddr(IPv6)
ip"fe80::9731:35af:e1c5:6e49"
\end{minted}



\end{adjustwidth}
\hypertarget{11225054155479915290}{} 
\hyperlink{11225054155479915290}{\texttt{Sockets.getipaddrs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getipaddrs(; loopback::Bool=false) -> Vector{IPAddr}
\end{minted}

Get the IPv4 addresses of the local machine.


\begin{lstlisting}
getipaddrs(addr_type::Type{T}; loopback::Bool=false) where T<:IPAddr -> Vector{T}
\end{lstlisting}

Get the IP addresses of the local machine of the specified type.

The \texttt{loopback} keyword argument dictates whether loopback addresses are included.

\begin{quote}
\textbf{Julia 1.2}

This function is available as of Julia 1.2.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> getipaddrs()
2-element Array{IPv4,1}:
 ip"10.255.0.183"
 ip"172.17.0.1"

julia> getipaddrs(IPv6)
2-element Array{IPv6,1}:
 ip"fe80::9731:35af:e1c5:6e49"
 ip"fe80::445e:5fff:fe5d:5500"
\end{minted}



\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Sockets.islinklocaladdr}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{14820421424669368163}{} 
\hyperlink{14820421424669368163}{\texttt{Sockets.getalladdrinfo}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getalladdrinfo(host::AbstractString) -> Vector{IPAddr}
\end{minted}

Gets all of the IP addresses of the \texttt{host}. Uses the operating system{\textquotesingle}s underlying \texttt{getaddrinfo} implementation, which may do a DNS lookup.

\textbf{Example}


\begin{minted}{jlcon}
julia> getalladdrinfo("google.com")
2-element Array{IPAddr,1}:
 ip"172.217.6.174"
 ip"2607:f8b0:4000:804::200e"
\end{minted}



\end{adjustwidth}

\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{Sockets.DNSError}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}

\hypertarget{8933801763213702510}{} 
\hyperlink{8933801763213702510}{\texttt{Sockets.getnameinfo}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getnameinfo(host::IPAddr) -> String
\end{minted}

Performs a reverse-lookup for IP address to return a hostname and service using the operating system{\textquotesingle}s underlying \texttt{getnameinfo} implementation.

\textbf{Examples}


\begin{minted}{jlcon}
julia> getnameinfo(Sockets.IPv4("8.8.8.8"))
"google-public-dns-a.google.com"
\end{minted}



\end{adjustwidth}
\hypertarget{16393779334284193287}{} 
\hyperlink{16393779334284193287}{\texttt{Sockets.getsockname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getsockname(sock::Union{TCPServer, TCPSocket}) -> (IPAddr, UInt16)
\end{minted}

Get the IP address and port that the given socket is bound to.



\end{adjustwidth}
\hypertarget{3342627656847235889}{} 
\hyperlink{3342627656847235889}{\texttt{Sockets.getpeername}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
getpeername(sock::TCPSocket) -> (IPAddr, UInt16)
\end{minted}

Get the IP address and port of the remote endpoint that the given socket is connected to. Valid only for connected TCP sockets.



\end{adjustwidth}
\hypertarget{8098410990676145612}{} 
\hyperlink{8098410990676145612}{\texttt{Sockets.IPAddr}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IPAddr
\end{minted}

Abstract supertype for IP addresses. \hyperlink{3367105148999996858}{\texttt{IPv4}} and \hyperlink{14863381148391509384}{\texttt{IPv6}} are subtypes of this.



\end{adjustwidth}
\hypertarget{3367105148999996858}{} 
\hyperlink{3367105148999996858}{\texttt{Sockets.IPv4}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IPv4(host::Integer) -> IPv4
\end{minted}

Returns an IPv4 object from ip address \texttt{host} formatted as an \hyperlink{8469131683393450448}{\texttt{Integer}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> IPv4(3223256218)
ip"192.30.252.154"
\end{minted}



\end{adjustwidth}
\hypertarget{14863381148391509384}{} 
\hyperlink{14863381148391509384}{\texttt{Sockets.IPv6}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
IPv6(host::Integer) -> IPv6
\end{minted}

Returns an IPv6 object from ip address \texttt{host} formatted as an \hyperlink{8469131683393450448}{\texttt{Integer}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> IPv6(3223256218)
ip"::c01e:fc9a"
\end{minted}



\end{adjustwidth}
\hypertarget{5293313767861803133}{} 
\hyperlink{5293313767861803133}{\texttt{Sockets.@ip\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@ip_str str -> IPAddr
\end{minted}

Parse \texttt{str} as an IP address.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ip"127.0.0.1"
ip"127.0.0.1"

julia> @ip_str "2001:db8:0:0:0:0:2:1"
ip"2001:db8::2:1"
\end{minted}



\end{adjustwidth}
\hypertarget{5453047654537213204}{} 
\hyperlink{5453047654537213204}{\texttt{Sockets.TCPSocket}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
TCPSocket(; delay=true)
\end{minted}

Open a TCP socket using libuv. If \texttt{delay} is true, libuv delays creation of the socket{\textquotesingle}s file descriptor till the first \hyperlink{13811388816704022260}{\texttt{bind}} call. \texttt{TCPSocket} has various fields to denote the state of the socket as well as its send/receive buffers.



\end{adjustwidth}
\hypertarget{5627851531738059255}{} 
\hyperlink{5627851531738059255}{\texttt{Sockets.UDPSocket}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
UDPSocket()
\end{minted}

Open a UDP socket using libuv. \texttt{UDPSocket} has various fields to denote the state of the socket.



\end{adjustwidth}
\hypertarget{1426793569216032849}{} 
\hyperlink{1426793569216032849}{\texttt{Sockets.accept}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
accept(server[, client])
\end{minted}

Accepts a connection on the given server and returns a connection to the client. An uninitialized client stream may be provided, in which case it will be used instead of creating a new stream.



\end{adjustwidth}
\hypertarget{9909318444396548981}{} 
\hyperlink{9909318444396548981}{\texttt{Sockets.listenany}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
listenany([host::IPAddr,] port_hint) -> (UInt16, TCPServer)
\end{minted}

Create a \texttt{TCPServer} on any port, using hint as a starting point. Returns a tuple of the actual port that the server was created on and the server itself.



\end{adjustwidth}
\hypertarget{13811388816704022260}{} 
\hyperlink{13811388816704022260}{\texttt{Base.bind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
bind(socket::Union{UDPSocket, TCPSocket}, host::IPAddr, port::Integer; ipv6only=false, reuseaddr=false, kws...)
\end{minted}

Bind \texttt{socket} to the given \texttt{host:port}. Note that \texttt{0.0.0.0} will listen on all devices.

\begin{itemize}
\item The \texttt{ipv6only} parameter disables dual stack mode. If \texttt{ipv6only=true}, only an IPv6 stack is created.


\item If \texttt{reuseaddr=true}, multiple threads or processes can bind to the same address without error if they all set \texttt{reuseaddr=true}, but only the last to bind will receive any traffic.

\end{itemize}



\begin{minted}{julia}
bind(chnl::Channel, task::Task)
\end{minted}

Associate the lifetime of \texttt{chnl} with a task. \texttt{Channel} \texttt{chnl} is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on \texttt{chnl}.

The \texttt{chnl} object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed \texttt{Channel} objects.

When a channel is bound to multiple tasks, the first task to terminate will close the channel. When multiple channels are bound to the same task, termination of the task will close all of the bound channels.

\textbf{Examples}


\begin{minted}{jlcon}
julia> c = Channel(0);

julia> task = @async foreach(i->put!(c, i), 1:4);

julia> bind(c,task);

julia> for i in c
           @show i
       end;
i = 1
i = 2
i = 3
i = 4

julia> isopen(c)
false
\end{minted}


\begin{minted}{jlcon}
julia> c = Channel(0);

julia> task = @async (put!(c,1);error("foo"));

julia> bind(c,task);

julia> take!(c)
1

julia> put!(c,1);
ERROR: foo
Stacktrace:
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/channels.jl#L194-L243}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14996317088638800111}{} 
\hyperlink{14996317088638800111}{\texttt{Sockets.send}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
send(socket::UDPSocket, host::IPAddr, port::Integer, msg)
\end{minted}

Send \texttt{msg} over \texttt{socket} to \texttt{host:port}.



\end{adjustwidth}
\hypertarget{8720184196970920051}{} 
\hyperlink{8720184196970920051}{\texttt{Sockets.recv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
recv(socket::UDPSocket)
\end{minted}

Read a UDP packet from the specified socket, and return the bytes received. This call blocks.



\end{adjustwidth}
\hypertarget{10286416413585635173}{} 
\hyperlink{10286416413585635173}{\texttt{Sockets.recvfrom}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
recvfrom(socket::UDPSocket) -> (host_port, data)
\end{minted}

Read a UDP packet from the specified socket, returning a tuple of \texttt{(host\_port, data)}, where \texttt{host\_port} will be an InetAddr\{IPv4\} or InetAddr\{IPv6\}, as appropriate.

\begin{quote}
\textbf{Julia 1.3}

Prior to Julia version 1.3, the first returned value was an address (\texttt{IPAddr}). In version 1.3 it was changed to an \texttt{InetAddr}.

\end{quote}


\end{adjustwidth}
\hypertarget{16113505891345104473}{} 
\hyperlink{16113505891345104473}{\texttt{Sockets.setopt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
setopt(sock::UDPSocket; multicast_loop=nothing, multicast_ttl=nothing, enable_broadcast=nothing, ttl=nothing)
\end{minted}

Set UDP socket options.

\begin{itemize}
\item \texttt{multicast\_loop}: loopback for multicast packets (default: \texttt{true}).


\item \texttt{multicast\_ttl}: TTL for multicast packets (default: \texttt{nothing}).


\item \texttt{enable\_broadcast}: flag must be set to \texttt{true} if socket will be used for broadcast messages, or else the UDP system will return an access error (default: \texttt{false}).


\item \texttt{ttl}: Time-to-live of packets sent on the socket (default: \texttt{nothing}).

\end{itemize}


\end{adjustwidth}
\hypertarget{6421218738057495658}{} 
\hyperlink{6421218738057495658}{\texttt{Sockets.nagle}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nagle(socket::Union{TCPServer, TCPSocket}, enable::Bool)
\end{minted}

Enables or disables Nagle{\textquotesingle}s algorithm on a given TCP server or socket.



\end{adjustwidth}
\hypertarget{14774922472341203206}{} 
\hyperlink{14774922472341203206}{\texttt{Sockets.quickack}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
quickack(socket::Union{TCPServer, TCPSocket}, enable::Bool)
\end{minted}

On Linux systems, the TCP\_QUICKACK is disabled or enabled on \texttt{socket}.



\end{adjustwidth}

\hypertarget{13048400462292431190}{}


\chapter{稀疏数组}





Julia 在 \texttt{SparseArrays} 标准库模块中提供了对稀疏向量和\href{https://en.wikipedia.org/wiki/Sparse\_matrix}{稀疏矩阵}的支持。与稠密数组相比，包含足够多零值的稀疏数组在以特殊的数据结构存储时可以节省大量的空间和运算时间。



\hypertarget{4438718230137239554}{}


\section{压缩稀疏列(CSC)稀疏矩阵存储}



在Julia中，稀疏矩阵是按照\href{https://en.wikipedia.org/wiki/Sparse\_matrix\#Compressed\_sparse\_column\_.28CSC\_or\_CCS.29}{压缩稀疏列(CSC)格式}存储的。Julia稀疏矩阵具有\hyperlink{15099699527958384292}{\texttt{SparseMatrixCSC\{Tv,Ti\}}}类型，其中\texttt{Tv}是存储值的类型，\texttt{Ti}是存储列指针和行索引的整型类型。\texttt{SparseMatrixCSC}的内部表示如下所示：




\begin{minted}{julia}
struct SparseMatrixCSC{Tv,Ti<:Integer} <: AbstractSparseMatrix{Tv,Ti}
    m::Int                  # Number of rows
    n::Int                  # Number of columns
    colptr::Vector{Ti}      # Column j is in colptr[j]:(colptr[j+1]-1)
    rowval::Vector{Ti}      # Row indices of stored values
    nzval::Vector{Tv}       # Stored values, typically nonzeros
end
\end{minted}



压缩稀疏列存储格式使得访问稀疏矩阵的列元素非常简单快速，而访问稀疏矩阵的行会非常缓慢。在CSC稀疏矩阵中执行类似插入新元素的操作也会非常慢。这是由于在稀疏矩阵中插入新元素时，在插入点之后的所有元素都要向后移动一位。



All operations on sparse matrices are carefully implemented to exploit the CSC data structure for performance, and to avoid expensive operations.



If you have data in CSC format from a different application or library, and wish to import it in Julia, make sure that you use 1-based indexing. The row indices in every column need to be sorted. If your \texttt{SparseMatrixCSC} object contains unsorted row indices, one quick way to sort them is by doing a double transpose.



In some applications, it is convenient to store explicit zero values in a \texttt{SparseMatrixCSC}. These \emph{are} accepted by functions in \texttt{Base} (but there is no guarantee that they will be preserved in mutating operations). Such explicitly stored zeros are treated as structural nonzeros by many routines. The \hyperlink{4231069364201374387}{\texttt{nnz}} function returns the number of elements explicitly stored in the sparse data structure, including structural nonzeros. In order to count the exact number of numerical nonzeros, use \hyperlink{4123799324867706690}{\texttt{count(!iszero, x)}}, which inspects every stored element of a sparse matrix. \hyperlink{10222793754853330762}{\texttt{dropzeros}}, and the in-place \hyperlink{13132808383029320263}{\texttt{dropzeros!}}, can be used to remove stored zeros from the sparse matrix.




\begin{minted}{jlcon}
julia> A = sparse([1, 1, 2, 3], [1, 3, 2, 3], [0, 1, 2, 0])
3×3 SparseMatrixCSC{Int64,Int64} with 4 stored entries:
  [1, 1]  =  0
  [2, 2]  =  2
  [1, 3]  =  1
  [3, 3]  =  0

julia> dropzeros(A)
3×3 SparseMatrixCSC{Int64,Int64} with 2 stored entries:
  [2, 2]  =  2
  [1, 3]  =  1
\end{minted}



\hypertarget{6464897929371876878}{}


\section{稀疏向量储存}



Sparse vectors are stored in a close analog to compressed sparse column format for sparse matrices. In Julia, sparse vectors have the type \hyperlink{17594730109701296640}{\texttt{SparseVector\{Tv,Ti\}}} where \texttt{Tv} is the type of the stored values and \texttt{Ti} the integer type for the indices. The internal representation is as follows:




\begin{minted}{julia}
struct SparseVector{Tv,Ti<:Integer} <: AbstractSparseVector{Tv,Ti}
    n::Int              # Length of the sparse vector
    nzind::Vector{Ti}   # Indices of stored values
    nzval::Vector{Tv}   # Stored values, typically nonzeros
end
\end{minted}



As for \hyperlink{15099699527958384292}{\texttt{SparseMatrixCSC}}, the \texttt{SparseVector} type can also contain explicitly stored zeros. (See \hyperlink{4286524230912717228}{Sparse Matrix Storage}.).



\hypertarget{2715559278970050628}{}


\section{稀疏向量与矩阵构造函数}



The simplest way to create a sparse array is to use a function equivalent to the \hyperlink{13837674686090348619}{\texttt{zeros}} function that Julia provides for working with dense arrays. To produce a sparse array instead, you can use the same name with an \texttt{sp} prefix:




\begin{minted}{jlcon}
julia> spzeros(3)
3-element SparseVector{Float64,Int64} with 0 stored entries
\end{minted}



The \hyperlink{10167157011990389788}{\texttt{sparse}} function is often a handy way to construct sparse arrays. For example, to construct a sparse matrix we can input a vector \texttt{I} of row indices, a vector \texttt{J} of column indices, and a vector \texttt{V} of stored values (this is also known as the \href{https://en.wikipedia.org/wiki/Sparse\_matrix\#Coordinate\_list\_.28COO.29}{COO (coordinate) format}). \texttt{sparse(I,J,V)} then constructs a sparse matrix such that \texttt{S[I[k], J[k]] = V[k]}. The equivalent sparse vector constructor is \hyperlink{13364181309585533450}{\texttt{sparsevec}}, which takes the (row) index vector \texttt{I} and the vector \texttt{V} with the stored values and constructs a sparse vector \texttt{R} such that \texttt{R[I[k]] = V[k]}.




\begin{minted}{jlcon}
julia> I = [1, 4, 3, 5]; J = [4, 7, 18, 9]; V = [1, 2, -5, 3];

julia> S = sparse(I,J,V)
5×18 SparseMatrixCSC{Int64,Int64} with 4 stored entries:
  [1,  4]  =  1
  [4,  7]  =  2
  [5,  9]  =  3
  [3, 18]  =  -5

julia> R = sparsevec(I,V)
5-element SparseVector{Int64,Int64} with 4 stored entries:
  [1]  =  1
  [3]  =  -5
  [4]  =  2
  [5]  =  3
\end{minted}



The inverse of the \hyperlink{10167157011990389788}{\texttt{sparse}} and \hyperlink{13364181309585533450}{\texttt{sparsevec}} functions is \hyperlink{15430174447643444721}{\texttt{findnz}}, which retrieves the inputs used to create the sparse array. \hyperlink{16067208921941164599}{\texttt{findall(!iszero, x)}} returns the cartesian indices of non-zero entries in \texttt{x} (including stored entries equal to zero).




\begin{minted}{jlcon}
julia> findnz(S)
([1, 4, 5, 3], [4, 7, 9, 18], [1, 2, 3, -5])

julia> findall(!iszero, S)
4-element Array{CartesianIndex{2},1}:
 CartesianIndex(1, 4)
 CartesianIndex(4, 7)
 CartesianIndex(5, 9)
 CartesianIndex(3, 18)

julia> findnz(R)
([1, 3, 4, 5], [1, -5, 2, 3])

julia> findall(!iszero, R)
4-element Array{Int64,1}:
 1
 3
 4
 5
\end{minted}



Another way to create a sparse array is to convert a dense array into a sparse array using the \hyperlink{10167157011990389788}{\texttt{sparse}} function:




\begin{minted}{jlcon}
julia> sparse(Matrix(1.0I, 5, 5))
5×5 SparseMatrixCSC{Float64,Int64} with 5 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0
  [4, 4]  =  1.0
  [5, 5]  =  1.0

julia> sparse([1.0, 0.0, 1.0])
3-element SparseVector{Float64,Int64} with 2 stored entries:
  [1]  =  1.0
  [3]  =  1.0
\end{minted}



You can go in the other direction using the \hyperlink{15492651498431872487}{\texttt{Array}} constructor. The \hyperlink{14062776301471954766}{\texttt{issparse}} function can be used to query if a matrix is sparse.




\begin{minted}{jlcon}
julia> issparse(spzeros(5))
true
\end{minted}



\hypertarget{16554788793770073287}{}


\section{稀疏矩阵的操作}



Arithmetic operations on sparse matrices also work as they do on dense matrices. Indexing of, assignment into, and concatenation of sparse matrices work in the same way as dense matrices. Indexing operations, especially assignment, are expensive, when carried out one element at a time. In many cases it may be better to convert the sparse matrix into \texttt{(I,J,V)} format using \hyperlink{15430174447643444721}{\texttt{findnz}}, manipulate the values or the structure in the dense vectors \texttt{(I,J,V)}, and then reconstruct the sparse matrix.



\hypertarget{3328350436064607795}{}


\section{Correspondence of dense and sparse methods}



The following table gives a correspondence between built-in methods on sparse matrices and their corresponding methods on dense matrix types. In general, methods that generate sparse matrices differ from their dense counterparts in that the resulting matrix follows the same sparsity pattern as a given sparse matrix \texttt{S}, or that the resulting sparse matrix has density \texttt{d}, i.e. each matrix element has a probability \texttt{d} of being non-zero.



Details can be found in the \hyperlink{2592358466672034664}{Sparse Vectors and Matrices} section of the standard library reference.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
构造函数 & 密度 & 说明 \\
\hline
\hyperlink{10306793690101482847}{\texttt{spzeros(m,n)}} & \hyperlink{13837674686090348619}{\texttt{zeros(m,n)}} & Creates a \emph{m}-by-\emph{n} matrix of zeros. (\hyperlink{10306793690101482847}{\texttt{spzeros(m,n)}} is empty.) \\
\hline
\hyperlink{10167157011990389788}{\texttt{sparse(I, n, n)}} & \hyperlink{5448927444601277512}{\texttt{Matrix(I,n,n)}} & Creates a \emph{n}-by-\emph{n} identity matrix. \\
\hline
\hyperlink{15492651498431872487}{\texttt{Array(S)}} & \hyperlink{10167157011990389788}{\texttt{sparse(A)}} & Interconverts between dense and sparse formats. \\
\hline
\hyperlink{10437881912081266792}{\texttt{sprand(m,n,d)}} & \hyperlink{7668863842145012694}{\texttt{rand(m,n)}} & Creates a \emph{m}-by-\emph{n} random matrix (of density \emph{d}) with iid non-zero elements distributed uniformly on the half-open interval  \([0, 1)\) . \\
\hline
\hyperlink{3588082437273281277}{\texttt{sprandn(m,n,d)}} & \hyperlink{7347069443766288058}{\texttt{randn(m,n)}} & Creates a \emph{m}-by-\emph{n} random matrix (of density \emph{d}) with iid non-zero elements distributed according to the standard normal (Gaussian) distribution. \\
\hline
\hyperlink{3588082437273281277}{\texttt{sprandn(rng,m,n,d)}} & \hyperlink{7347069443766288058}{\texttt{randn(rng,m,n)}} & Creates a \emph{m}-by-\emph{n} random matrix (of density \emph{d}) with iid non-zero elements generated with the \texttt{rng} random number generator \\
\hline
\end{tabulary}

\end{table}



\hypertarget{2402954669804328212}{}


\chapter{Sparse Arrays}


\hypertarget{428748181300158251}{} 
\hyperlink{428748181300158251}{\texttt{SparseArrays.AbstractSparseArray}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractSparseArray{Tv,Ti,N}
\end{minted}

Supertype for \texttt{N}-dimensional sparse arrays (or array-like types) with elements of type \texttt{Tv} and index type \texttt{Ti}. \hyperlink{15099699527958384292}{\texttt{SparseMatrixCSC}}, \hyperlink{17594730109701296640}{\texttt{SparseVector}} and \texttt{SuiteSparse.CHOLMOD.Sparse} are subtypes of this.



\end{adjustwidth}
\hypertarget{7311510774978482969}{} 
\hyperlink{7311510774978482969}{\texttt{SparseArrays.AbstractSparseVector}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractSparseVector{Tv,Ti}
\end{minted}

Supertype for one-dimensional sparse arrays (or array-like types) with elements of type \texttt{Tv} and index type \texttt{Ti}. Alias for \texttt{AbstractSparseArray\{Tv,Ti,1\}}.



\end{adjustwidth}
\hypertarget{7507379576530105001}{} 
\hyperlink{7507379576530105001}{\texttt{SparseArrays.AbstractSparseMatrix}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
AbstractSparseMatrix{Tv,Ti}
\end{minted}

Supertype for two-dimensional sparse arrays (or array-like types) with elements of type \texttt{Tv} and index type \texttt{Ti}. Alias for \texttt{AbstractSparseArray\{Tv,Ti,2\}}.



\end{adjustwidth}
\hypertarget{17594730109701296640}{} 
\hyperlink{17594730109701296640}{\texttt{SparseArrays.SparseVector}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SparseVector{Tv,Ti<:Integer} <: AbstractSparseVector{Tv,Ti}
\end{minted}

Vector type for storing sparse vectors.



\end{adjustwidth}
\hypertarget{15099699527958384292}{} 
\hyperlink{15099699527958384292}{\texttt{SparseArrays.SparseMatrixCSC}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
SparseMatrixCSC{Tv,Ti<:Integer} <: AbstractSparseMatrixCSC{Tv,Ti}
\end{minted}

Matrix type for storing sparse matrices in the \hyperlink{4286524230912717228}{Compressed Sparse Column} format. The standard way of constructing SparseMatrixCSC is through the \hyperlink{10167157011990389788}{\texttt{sparse}} function. See also \hyperlink{10306793690101482847}{\texttt{spzeros}}, \hyperlink{10407455986460913397}{\texttt{spdiagm}} and \hyperlink{10437881912081266792}{\texttt{sprand}}.



\end{adjustwidth}
\hypertarget{10167157011990389788}{} 
\hyperlink{10167157011990389788}{\texttt{SparseArrays.sparse}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sparse(A)
\end{minted}

Convert an AbstractMatrix \texttt{A} into a sparse matrix.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = Matrix(1.0I, 3, 3)
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia> sparse(A)
3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0
\end{minted}




\begin{lstlisting}
sparse(I, J, V,[ m, n, combine])
\end{lstlisting}

Create a sparse matrix \texttt{S} of dimensions \texttt{m x n} such that \texttt{S[I[k], J[k]] = V[k]}. The \texttt{combine} function is used to combine duplicates. If \texttt{m} and \texttt{n} are not specified, they are set to \texttt{maximum(I)} and \texttt{maximum(J)} respectively. If the \texttt{combine} function is not supplied, \texttt{combine} defaults to \texttt{+} unless the elements of \texttt{V} are Booleans in which case \texttt{combine} defaults to \texttt{|}. All elements of \texttt{I} must satisfy \texttt{1 <= I[k] <= m}, and all elements of \texttt{J} must satisfy \texttt{1 <= J[k] <= n}. Numerical zeros in (\texttt{I}, \texttt{J}, \texttt{V}) are retained as structural nonzeros; to drop numerical zeros, use \hyperlink{13132808383029320263}{\texttt{dropzeros!}}.

For additional documentation and an expert driver, see \texttt{SparseArrays.sparse!}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Is = [1; 2; 3];

julia> Js = [1; 2; 3];

julia> Vs = [1; 2; 3];

julia> sparse(Is, Js, Vs)
3×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:
  [1, 1]  =  1
  [2, 2]  =  2
  [3, 3]  =  3
\end{minted}



\end{adjustwidth}
\hypertarget{13364181309585533450}{} 
\hyperlink{13364181309585533450}{\texttt{SparseArrays.sparsevec}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sparsevec(I, V, [m, combine])
\end{minted}

Create a sparse vector \texttt{S} of length \texttt{m} such that \texttt{S[I[k]] = V[k]}. Duplicates are combined using the \texttt{combine} function, which defaults to \texttt{+} if no \texttt{combine} argument is provided, unless the elements of \texttt{V} are Booleans in which case \texttt{combine} defaults to \texttt{|}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> II = [1, 3, 3, 5]; V = [0.1, 0.2, 0.3, 0.2];

julia> sparsevec(II, V)
5-element SparseVector{Float64,Int64} with 3 stored entries:
  [1]  =  0.1
  [3]  =  0.5
  [5]  =  0.2

julia> sparsevec(II, V, 8, -)
8-element SparseVector{Float64,Int64} with 3 stored entries:
  [1]  =  0.1
  [3]  =  -0.1
  [5]  =  0.2

julia> sparsevec([1, 3, 1, 2, 2], [true, true, false, false, false])
3-element SparseVector{Bool,Int64} with 3 stored entries:
  [1]  =  1
  [2]  =  0
  [3]  =  1
\end{minted}




\begin{lstlisting}
sparsevec(d::Dict, [m])
\end{lstlisting}

Create a sparse vector of length \texttt{m} where the nonzero indices are keys from the dictionary, and the nonzero values are the values from the dictionary.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sparsevec(Dict(1 => 3, 2 => 2))
2-element SparseVector{Int64,Int64} with 2 stored entries:
  [1]  =  3
  [2]  =  2
\end{minted}




\begin{lstlisting}
sparsevec(A)
\end{lstlisting}

Convert a vector \texttt{A} into a sparse vector of length \texttt{m}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sparsevec([1.0, 2.0, 0.0, 0.0, 3.0, 0.0])
6-element SparseVector{Float64,Int64} with 3 stored entries:
  [1]  =  1.0
  [2]  =  2.0
  [5]  =  3.0
\end{minted}



\end{adjustwidth}
\hypertarget{14062776301471954766}{} 
\hyperlink{14062776301471954766}{\texttt{SparseArrays.issparse}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issparse(S)
\end{minted}

Returns \texttt{true} if \texttt{S} is sparse, and \texttt{false} otherwise.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sv = sparsevec([1, 4], [2.3, 2.2], 10)
10-element SparseVector{Float64,Int64} with 2 stored entries:
  [1 ]  =  2.3
  [4 ]  =  2.2

julia> issparse(sv)
true

julia> issparse(Array(sv))
false
\end{minted}



\end{adjustwidth}
\hypertarget{4231069364201374387}{} 
\hyperlink{4231069364201374387}{\texttt{SparseArrays.nnz}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nnz(A)
\end{minted}

Returns the number of stored (filled) elements in a sparse array.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = sparse(2I, 3, 3)
3×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:
  [1, 1]  =  2
  [2, 2]  =  2
  [3, 3]  =  2

julia> nnz(A)
3
\end{minted}



\end{adjustwidth}
\hypertarget{15430174447643444721}{} 
\hyperlink{15430174447643444721}{\texttt{SparseArrays.findnz}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
findnz(A)
\end{minted}

Return a tuple \texttt{(I, J, V)} where \texttt{I} and \texttt{J} are the row and column indices of the stored ({\textquotedbl}structurally non-zero{\textquotedbl}) values in sparse matrix \texttt{A}, and \texttt{V} is a vector of the values.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = sparse([1 2 0; 0 0 3; 0 4 0])
3×3 SparseMatrixCSC{Int64,Int64} with 4 stored entries:
  [1, 1]  =  1
  [1, 2]  =  2
  [3, 2]  =  4
  [2, 3]  =  3

julia> findnz(A)
([1, 1, 3, 2], [1, 2, 2, 3], [1, 2, 4, 3])
\end{minted}



\end{adjustwidth}
\hypertarget{10306793690101482847}{} 
\hyperlink{10306793690101482847}{\texttt{SparseArrays.spzeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
spzeros([type,]m[,n])
\end{minted}

Create a sparse vector of length \texttt{m} or sparse matrix of size \texttt{m x n}. This sparse array will not contain any nonzero values. No storage will be allocated for nonzero values during construction. The type defaults to \hyperlink{5027751419500983000}{\texttt{Float64}} if not specified.

\textbf{Examples}


\begin{minted}{jlcon}
julia> spzeros(3, 3)
3×3 SparseMatrixCSC{Float64,Int64} with 0 stored entries

julia> spzeros(Float32, 4)
4-element SparseVector{Float32,Int64} with 0 stored entries
\end{minted}



\end{adjustwidth}
\hypertarget{10407455986460913397}{} 
\hyperlink{10407455986460913397}{\texttt{SparseArrays.spdiagm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
spdiagm(kv::Pair{<:Integer,<:AbstractVector}...)
spdiagm(m::Integer, n::Ingeger, kv::Pair{<:Integer,<:AbstractVector}...)
\end{minted}

Construct a sparse diagonal matrix from \texttt{Pair}s of vectors and diagonals. Each vector \texttt{kv.second} will be placed on the \texttt{kv.first} diagonal.  By default (if \texttt{size=nothing}), the matrix is square and its size is inferred from \texttt{kv}, but a non-square size \texttt{m}×\texttt{n} (padded with zeros as needed) can be specified by passing \texttt{m,n} as the first arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> spdiagm(-1 => [1,2,3,4], 1 => [4,3,2,1])
5×5 SparseMatrixCSC{Int64,Int64} with 8 stored entries:
  [2, 1]  =  1
  [1, 2]  =  4
  [3, 2]  =  2
  [2, 3]  =  3
  [4, 3]  =  3
  [3, 4]  =  2
  [5, 4]  =  4
  [4, 5]  =  1
\end{minted}



\end{adjustwidth}
\hypertarget{12222128005156653307}{} 
\hyperlink{12222128005156653307}{\texttt{SparseArrays.blockdiag}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
blockdiag(A...)
\end{minted}

Concatenate matrices block-diagonally. Currently only implemented for sparse matrices.

\textbf{Examples}


\begin{minted}{jlcon}
julia> blockdiag(sparse(2I, 3, 3), sparse(4I, 2, 2))
5×5 SparseMatrixCSC{Int64,Int64} with 5 stored entries:
  [1, 1]  =  2
  [2, 2]  =  2
  [3, 3]  =  2
  [4, 4]  =  4
  [5, 5]  =  4
\end{minted}



\end{adjustwidth}
\hypertarget{10437881912081266792}{} 
\hyperlink{10437881912081266792}{\texttt{SparseArrays.sprand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sprand([rng],[type],m,[n],p::AbstractFloat,[rfn])
\end{minted}

Create a random length \texttt{m} sparse vector or \texttt{m} by \texttt{n} sparse matrix, in which the probability of any element being nonzero is independently given by \texttt{p} (and hence the mean density of nonzeros is also exactly \texttt{p}). Nonzero values are sampled from the distribution specified by \texttt{rfn} and have the type \texttt{type}. The uniform distribution is used in case \texttt{rfn} is not specified. The optional \texttt{rng} argument specifies a random number generator, see \href{@ref}{Random Numbers}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sprand(Bool, 2, 2, 0.5)
2×2 SparseMatrixCSC{Bool,Int64} with 1 stored entry:
  [2, 2]  =  1

julia> sprand(Float64, 3, 0.75)
3-element SparseVector{Float64,Int64} with 1 stored entry:
  [3]  =  0.298614
\end{minted}



\end{adjustwidth}
\hypertarget{3588082437273281277}{} 
\hyperlink{3588082437273281277}{\texttt{SparseArrays.sprandn}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
sprandn([rng][,Type],m[,n],p::AbstractFloat)
\end{minted}

Create a random sparse vector of length \texttt{m} or sparse matrix of size \texttt{m} by \texttt{n} with the specified (independent) probability \texttt{p} of any entry being nonzero, where nonzero values are sampled from the normal distribution. The optional \texttt{rng} argument specifies a random number generator, see \href{@ref}{Random Numbers}.

\begin{quote}
\textbf{Julia 1.1}

Specifying the output element type \texttt{Type} requires at least Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> sprandn(2, 2, 0.75)
2×2 SparseMatrixCSC{Float64,Int64} with 2 stored entries:
  [1, 2]  =  0.586617
  [2, 2]  =  0.297336
\end{minted}



\end{adjustwidth}
\hypertarget{2553509978651134823}{} 
\hyperlink{2553509978651134823}{\texttt{SparseArrays.nonzeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nonzeros(A)
\end{minted}

Return a vector of the structural nonzero values in sparse array \texttt{A}. This includes zeros that are explicitly stored in the sparse array. The returned vector points directly to the internal nonzero storage of \texttt{A}, and any modifications to the returned vector will mutate \texttt{A} as well. See \hyperlink{11529930160190690800}{\texttt{rowvals}} and \hyperlink{4192027552568489301}{\texttt{nzrange}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = sparse(2I, 3, 3)
3×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:
  [1, 1]  =  2
  [2, 2]  =  2
  [3, 3]  =  2

julia> nonzeros(A)
3-element Array{Int64,1}:
 2
 2
 2
\end{minted}



\end{adjustwidth}
\hypertarget{11529930160190690800}{} 
\hyperlink{11529930160190690800}{\texttt{SparseArrays.rowvals}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
rowvals(A::AbstractSparseMatrixCSC)
\end{minted}

Return a vector of the row indices of \texttt{A}. Any modifications to the returned vector will mutate \texttt{A} as well. Providing access to how the row indices are stored internally can be useful in conjunction with iterating over structural nonzero values. See also \hyperlink{2553509978651134823}{\texttt{nonzeros}} and \hyperlink{4192027552568489301}{\texttt{nzrange}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = sparse(2I, 3, 3)
3×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:
  [1, 1]  =  2
  [2, 2]  =  2
  [3, 3]  =  2

julia> rowvals(A)
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



\end{adjustwidth}
\hypertarget{4192027552568489301}{} 
\hyperlink{4192027552568489301}{\texttt{SparseArrays.nzrange}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
nzrange(A::AbstractSparseMatrixCSC, col::Integer)
\end{minted}

Return the range of indices to the structural nonzero values of a sparse matrix column. In conjunction with \hyperlink{2553509978651134823}{\texttt{nonzeros}} and \hyperlink{11529930160190690800}{\texttt{rowvals}}, this allows for convenient iterating over a sparse matrix :


\begin{lstlisting}
A = sparse(I,J,V)
rows = rowvals(A)
vals = nonzeros(A)
m, n = size(A)
for j = 1:n
   for i in nzrange(A, j)
      row = rows[i]
      val = vals[i]
      # perform sparse wizardry...
   end
end
\end{lstlisting}



\end{adjustwidth}
\hypertarget{10473482629417875992}{} 
\hyperlink{10473482629417875992}{\texttt{SparseArrays.droptol!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
droptol!(A::AbstractSparseMatrixCSC, tol; trim::Bool = true)
\end{minted}

Removes stored values from \texttt{A} whose absolute value is less than or equal to \texttt{tol}, optionally trimming resulting excess space from \texttt{rowvals(A)} and \texttt{nonzeros(A)} when \texttt{trim} is \texttt{true}.




\begin{lstlisting}
droptol!(x::SparseVector, tol; trim::Bool = true)
\end{lstlisting}

Removes stored values from \texttt{x} whose absolute value is less than or equal to \texttt{tol}, optionally trimming resulting excess space from \texttt{nonzeroinds(x)} and \texttt{nonzeros(x)} when \texttt{trim} is \texttt{true}.



\end{adjustwidth}
\hypertarget{13132808383029320263}{} 
\hyperlink{13132808383029320263}{\texttt{SparseArrays.dropzeros!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dropzeros!(A::AbstractSparseMatrixCSC; trim::Bool = true)
\end{minted}

Removes stored numerical zeros from \texttt{A}, optionally trimming resulting excess space from \texttt{rowvals(A)} and \texttt{nonzeros(A)} when \texttt{trim} is \texttt{true}.

For an out-of-place version, see \hyperlink{10222793754853330762}{\texttt{dropzeros}}. For algorithmic information, see \texttt{fkeep!}.




\begin{lstlisting}
dropzeros!(x::SparseVector; trim::Bool = true)
\end{lstlisting}

Removes stored numerical zeros from \texttt{x}, optionally trimming resulting excess space from \texttt{nonzeroinds(x)} and \texttt{nonzeros(x)} when \texttt{trim} is \texttt{true}.

For an out-of-place version, see \hyperlink{10222793754853330762}{\texttt{dropzeros}}. For algorithmic information, see \texttt{fkeep!}.



\end{adjustwidth}
\hypertarget{10222793754853330762}{} 
\hyperlink{10222793754853330762}{\texttt{SparseArrays.dropzeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dropzeros(A::AbstractSparseMatrixCSC; trim::Bool = true)
\end{minted}

Generates a copy of \texttt{A} and removes stored numerical zeros from that copy, optionally trimming excess space from the result{\textquotesingle}s \texttt{rowval} and \texttt{nzval} arrays when \texttt{trim} is \texttt{true}.

For an in-place version and algorithmic information, see \hyperlink{13132808383029320263}{\texttt{dropzeros!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = sparse([1, 2, 3], [1, 2, 3], [1.0, 0.0, 1.0])
3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  0.0
  [3, 3]  =  1.0

julia> dropzeros(A)
3×3 SparseMatrixCSC{Float64,Int64} with 2 stored entries:
  [1, 1]  =  1.0
  [3, 3]  =  1.0
\end{minted}




\begin{lstlisting}
dropzeros(x::SparseVector; trim::Bool = true)
\end{lstlisting}

Generates a copy of \texttt{x} and removes numerical zeros from that copy, optionally trimming excess space from the result{\textquotesingle}s \texttt{nzind} and \texttt{nzval} arrays when \texttt{trim} is \texttt{true}.

For an in-place version and algorithmic information, see \hyperlink{13132808383029320263}{\texttt{dropzeros!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = sparsevec([1, 2, 3], [1.0, 0.0, 1.0])
3-element SparseVector{Float64,Int64} with 3 stored entries:
  [1]  =  1.0
  [2]  =  0.0
  [3]  =  1.0

julia> dropzeros(A)
3-element SparseVector{Float64,Int64} with 2 stored entries:
  [1]  =  1.0
  [3]  =  1.0
\end{minted}



\end{adjustwidth}
\hypertarget{12003442917636022234}{} 
\hyperlink{12003442917636022234}{\texttt{SparseArrays.permute}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
permute(A::AbstractSparseMatrixCSC{Tv,Ti}, p::AbstractVector{<:Integer},
        q::AbstractVector{<:Integer}) where {Tv,Ti}
\end{minted}

Bilaterally permute \texttt{A}, returning \texttt{PAQ} (\texttt{A[p,q]}). Column-permutation \texttt{q}{\textquotesingle}s length must match \texttt{A}{\textquotesingle}s column count (\texttt{length(q) == size(A, 2)}). Row-permutation \texttt{p}{\textquotesingle}s length must match \texttt{A}{\textquotesingle}s row count (\texttt{length(p) == size(A, 1)}).

For expert drivers and additional information, see \hyperlink{17157632988142440888}{\texttt{permute!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = spdiagm(0 => [1, 2, 3, 4], 1 => [5, 6, 7])
4×4 SparseMatrixCSC{Int64,Int64} with 7 stored entries:
  [1, 1]  =  1
  [1, 2]  =  5
  [2, 2]  =  2
  [2, 3]  =  6
  [3, 3]  =  3
  [3, 4]  =  7
  [4, 4]  =  4

julia> permute(A, [4, 3, 2, 1], [1, 2, 3, 4])
4×4 SparseMatrixCSC{Int64,Int64} with 7 stored entries:
  [4, 1]  =  1
  [3, 2]  =  2
  [4, 2]  =  5
  [2, 3]  =  3
  [3, 3]  =  6
  [1, 4]  =  4
  [2, 4]  =  7

julia> permute(A, [1, 2, 3, 4], [4, 3, 2, 1])
4×4 SparseMatrixCSC{Int64,Int64} with 7 stored entries:
  [3, 1]  =  7
  [4, 1]  =  4
  [2, 2]  =  6
  [3, 2]  =  3
  [1, 3]  =  5
  [2, 3]  =  2
  [1, 4]  =  1
\end{minted}



\end{adjustwidth}
\hypertarget{10817887949404037920}{} 
\hyperlink{10817887949404037920}{\texttt{Base.permute!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
permute!(X::AbstractSparseMatrixCSC{Tv,Ti}, A::AbstractSparseMatrixCSC{Tv,Ti},
         p::AbstractVector{<:Integer}, q::AbstractVector{<:Integer},
         [C::AbstractSparseMatrixCSC{Tv,Ti}]) where {Tv,Ti}
\end{minted}

Bilaterally permute \texttt{A}, storing result \texttt{PAQ} (\texttt{A[p,q]}) in \texttt{X}. Stores intermediate result \texttt{(AQ){\textasciicircum}T} (\texttt{transpose(A[:,q])}) in optional argument \texttt{C} if present. Requires that none of \texttt{X}, \texttt{A}, and, if present, \texttt{C} alias each other; to store result \texttt{PAQ} back into \texttt{A}, use the following method lacking \texttt{X}:


\begin{lstlisting}
permute!(A::AbstractSparseMatrixCSC{Tv,Ti}, p::AbstractVector{<:Integer},
         q::AbstractVector{<:Integer}[, C::AbstractSparseMatrixCSC{Tv,Ti},
         [workcolptr::Vector{Ti}]]) where {Tv,Ti}
\end{lstlisting}

\texttt{X}{\textquotesingle}s dimensions must match those of \texttt{A} (\texttt{size(X, 1) == size(A, 1)} and \texttt{size(X, 2) == size(A, 2)}), and \texttt{X} must have enough storage to accommodate all allocated entries in \texttt{A} (\texttt{length(rowvals(X)) >= nnz(A)} and \texttt{length(nonzeros(X)) >= nnz(A)}). Column-permutation \texttt{q}{\textquotesingle}s length must match \texttt{A}{\textquotesingle}s column count (\texttt{length(q) == size(A, 2)}). Row-permutation \texttt{p}{\textquotesingle}s length must match \texttt{A}{\textquotesingle}s row count (\texttt{length(p) == size(A, 1)}).

\texttt{C}{\textquotesingle}s dimensions must match those of \texttt{transpose(A)} (\texttt{size(C, 1) == size(A, 2)} and \texttt{size(C, 2) == size(A, 1)}), and \texttt{C} must have enough storage to accommodate all allocated entries in \texttt{A} (\texttt{length(rowvals(C)) >= nnz(A)} and \texttt{length(nonzeros(C)) >= nnz(A)}).

For additional (algorithmic) information, and for versions of these methods that forgo argument checking, see (unexported) parent methods \texttt{unchecked\_noalias\_permute!} and \texttt{unchecked\_aliasing\_permute!}.

See also: \hyperlink{12003442917636022234}{\texttt{permute}}.



\end{adjustwidth}



\hypertarget{3919294208060022612}{}


\chapter{统计}





统计模块包含了基本的统计函数。


\hypertarget{1955374586742019663}{} 
\hyperlink{1955374586742019663}{\texttt{Statistics.std}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
std(itr; corrected::Bool=true, mean=nothing[, dims])
\end{minted}

Compute the sample standard deviation of collection \texttt{itr}.

The algorithm returns an estimator of the generative distribution{\textquotesingle}s standard deviation under the assumption that each entry of \texttt{itr} is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating \texttt{sqrt(sum((itr .- mean(itr)).{\textasciicircum}2) / (length(itr) - 1))}. If \texttt{corrected} is \texttt{true}, then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} with \texttt{n} the number of elements in \texttt{itr}.

A pre-computed \texttt{mean} may be provided.

If \texttt{itr} is an \texttt{AbstractArray}, \texttt{dims} can be provided to compute the standard deviation over dimensions, and \texttt{means} may contain means for each dimension of \texttt{itr}.

\begin{quote}
\textbf{Note}

If array contains \texttt{NaN} or \hyperlink{14596725676261444434}{\texttt{missing}} values, the result is also \texttt{NaN} or \texttt{missing} (\texttt{missing} takes precedence if array contains both). Use the \hyperlink{2012470681884771400}{\texttt{skipmissing}} function to omit \texttt{missing} entries and compute the standard deviation of non-missing values.

\end{quote}


\end{adjustwidth}
\hypertarget{11197607150486088950}{} 
\hyperlink{11197607150486088950}{\texttt{Statistics.stdm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stdm(itr, m; corrected::Bool=true)
\end{minted}

Compute the sample standard deviation of collection \texttt{itr}, with known mean(s) \texttt{m}.

The algorithm returns an estimator of the generative distribution{\textquotesingle}s standard deviation under the assumption that each entry of \texttt{itr} is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating \texttt{sqrt(sum((itr .- mean(itr)).{\textasciicircum}2) / (length(itr) - 1))}. If \texttt{corrected} is \texttt{true}, then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} with \texttt{n} the number of elements in \texttt{itr}.

A pre-computed \texttt{mean} may be provided.

If \texttt{itr} is an \texttt{AbstractArray}, \texttt{dims} can be provided to compute the standard deviation over dimensions, and \texttt{m} may contain means for each dimension of \texttt{itr}.

\begin{quote}
\textbf{Note}

If array contains \texttt{NaN} or \hyperlink{14596725676261444434}{\texttt{missing}} values, the result is also \texttt{NaN} or \texttt{missing} (\texttt{missing} takes precedence if array contains both). Use the \hyperlink{2012470681884771400}{\texttt{skipmissing}} function to omit \texttt{missing} entries and compute the standard deviation of non-missing values.

\end{quote}


\end{adjustwidth}
\hypertarget{3113715888143479678}{} 
\hyperlink{3113715888143479678}{\texttt{Statistics.var}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
var(itr; dims, corrected::Bool=true, mean=nothing)
\end{minted}

Compute the sample variance of collection \texttt{itr}.

The algorithm returns an estimator of the generative distribution{\textquotesingle}s variance under the assumption that each entry of \texttt{itr} is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating \texttt{sum((itr .- mean(itr)).{\textasciicircum}2) / (length(itr) - 1)). If}corrected\texttt{is}true\texttt{, then the sum is scaled with}n-1\texttt{, whereas the sum is scaled with}n\texttt{if}corrected\texttt{is}false\texttt{with}n\texttt{the number of elements in}itr`.

A pre-computed \texttt{mean} may be provided.

If \texttt{itr} is an \texttt{AbstractArray}, \texttt{dims} can be provided to compute the variance over dimensions, and \texttt{mean} may contain means for each dimension of \texttt{itr}.

\begin{quote}
\textbf{Note}

If array contains \texttt{NaN} or \hyperlink{14596725676261444434}{\texttt{missing}} values, the result is also \texttt{NaN} or \texttt{missing} (\texttt{missing} takes precedence if array contains both). Use the \hyperlink{2012470681884771400}{\texttt{skipmissing}} function to omit \texttt{missing} entries and compute the variance of non-missing values.

\end{quote}


\end{adjustwidth}
\hypertarget{11347311999392006255}{} 
\hyperlink{11347311999392006255}{\texttt{Statistics.varm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
varm(itr, m; dims, corrected::Bool=true)
\end{minted}

Compute the sample variance of collection \texttt{itr}, with known mean(s) \texttt{m}.

The algorithm returns an estimator of the generative distribution{\textquotesingle}s variance under the assumption that each entry of \texttt{itr} is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating \texttt{sum((itr .- mean(itr)).{\textasciicircum}2) / (length(itr) - 1)}. If \texttt{corrected} is \texttt{true}, then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} with \texttt{n} the number of elements in \texttt{itr}.

If \texttt{itr} is an \texttt{AbstractArray}, \texttt{dims} can be provided to compute the variance over dimensions, and \texttt{m} may contain means for each dimension of \texttt{itr}.

\begin{quote}
\textbf{Note}

If array contains \texttt{NaN} or \hyperlink{14596725676261444434}{\texttt{missing}} values, the result is also \texttt{NaN} or \texttt{missing} (\texttt{missing} takes precedence if array contains both). Use the \hyperlink{2012470681884771400}{\texttt{skipmissing}} function to omit \texttt{missing} entries and compute the variance of non-missing values.

\end{quote}


\end{adjustwidth}
\hypertarget{16231972474237968518}{} 
\hyperlink{16231972474237968518}{\texttt{Statistics.cor}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cor(x::AbstractVector)
\end{minted}

Return the number one.




\begin{lstlisting}
cor(X::AbstractMatrix; dims::Int=1)
\end{lstlisting}

Compute the Pearson correlation matrix of the matrix \texttt{X} along the dimension \texttt{dims}.




\begin{lstlisting}
cor(x::AbstractVector, y::AbstractVector)
\end{lstlisting}

Compute the Pearson correlation between the vectors \texttt{x} and \texttt{y}.




\begin{lstlisting}
cor(X::AbstractVecOrMat, Y::AbstractVecOrMat; dims=1)
\end{lstlisting}

Compute the Pearson correlation between the vectors or matrices \texttt{X} and \texttt{Y} along the dimension \texttt{dims}.



\end{adjustwidth}
\hypertarget{7202855476046698513}{} 
\hyperlink{7202855476046698513}{\texttt{Statistics.cov}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
cov(x::AbstractVector; corrected::Bool=true)
\end{minted}

Compute the variance of the vector \texttt{x}. If \texttt{corrected} is \texttt{true} (the default) then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} where \texttt{n = length(x)}.




\begin{lstlisting}
cov(X::AbstractMatrix; dims::Int=1, corrected::Bool=true)
\end{lstlisting}

Compute the covariance matrix of the matrix \texttt{X} along the dimension \texttt{dims}. If \texttt{corrected} is \texttt{true} (the default) then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} where \texttt{n = size(X, dims)}.




\begin{lstlisting}
cov(x::AbstractVector, y::AbstractVector; corrected::Bool=true)
\end{lstlisting}

Compute the covariance between the vectors \texttt{x} and \texttt{y}. If \texttt{corrected} is \texttt{true} (the default), computes  \(\frac{1}{n-1}\sum_{i=1}^n (x_i-\bar x) (y_i-\bar y)^*\)  where  \(*\)  denotes the complex conjugate and \texttt{n = length(x) = length(y)}. If \texttt{corrected} is \texttt{false}, computes  \(\frac{1}{n}\sum_{i=1}^n (x_i-\bar x) (y_i-\bar y)^*\) .




\begin{lstlisting}
cov(X::AbstractVecOrMat, Y::AbstractVecOrMat; dims::Int=1, corrected::Bool=true)
\end{lstlisting}

Compute the covariance between the vectors or matrices \texttt{X} and \texttt{Y} along the dimension \texttt{dims}. If \texttt{corrected} is \texttt{true} (the default) then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} where \texttt{n = size(X, dims) = size(Y, dims)}.



\end{adjustwidth}
\hypertarget{9852865620009351869}{} 
\hyperlink{9852865620009351869}{\texttt{Statistics.mean!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mean!(r, v)
\end{minted}

Compute the mean of \texttt{v} over the singleton dimensions of \texttt{r}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> mean!([1., 1.], v)
2-element Array{Float64,1}:
 1.5
 3.5

julia> mean!([1. 1.], v)
1×2 Array{Float64,2}:
 2.0  3.0
\end{minted}



\end{adjustwidth}
\hypertarget{15061550543970113934}{} 
\hyperlink{15061550543970113934}{\texttt{Statistics.mean}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
mean(itr)
\end{minted}

Compute the mean of all elements in a collection.

\begin{quote}
\textbf{Note}

If \texttt{itr} contains \texttt{NaN} or \hyperlink{14596725676261444434}{\texttt{missing}} values, the result is also \texttt{NaN} or \texttt{missing} (\texttt{missing} takes precedence if array contains both). Use the \hyperlink{2012470681884771400}{\texttt{skipmissing}} function to omit \texttt{missing} entries and compute the mean of non-missing values.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> mean(1:20)
10.5

julia> mean([1, missing, 3])
missing

julia> mean(skipmissing([1, missing, 3]))
2.0
\end{minted}




\begin{lstlisting}
mean(f::Function, itr)
\end{lstlisting}

Apply the function \texttt{f} to each element of collection \texttt{itr} and take the mean.


\begin{minted}{jlcon}
julia> mean(√, [1, 2, 3])
1.3820881233139908

julia> mean([√1, √2, √3])
1.3820881233139908
\end{minted}




\begin{lstlisting}
mean(f::Function, A::AbstractArray; dims)
\end{lstlisting}

Apply the function \texttt{f} to each element of array \texttt{A} and take the mean over dimensions \texttt{dims}.

\begin{quote}
\textbf{Julia 1.3}

This method requires at least Julia 1.3.

\end{quote}

\begin{minted}{jlcon}
julia> mean(√, [1, 2, 3])
1.3820881233139908

julia> mean([√1, √2, √3])
1.3820881233139908

julia> mean(√, [1 2 3; 4 5 6], dims=2)
2×1 Array{Float64,2}:
 1.3820881233139908
 2.2285192400943226
\end{minted}




\begin{lstlisting}
mean(A::AbstractArray; dims)
\end{lstlisting}

Compute the mean of an array over the given dimensions.

\begin{quote}
\textbf{Julia 1.1}

\texttt{mean} for empty arrays requires at least Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> mean(A, dims=1)
1×2 Array{Float64,2}:
 2.0  3.0

julia> mean(A, dims=2)
2×1 Array{Float64,2}:
 1.5
 3.5
\end{minted}



\end{adjustwidth}
\hypertarget{5238557773914917939}{} 
\hyperlink{5238557773914917939}{\texttt{Statistics.median!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
median!(v)
\end{minted}

Like \hyperlink{7663137055249909841}{\texttt{median}}, but may overwrite the input vector.



\end{adjustwidth}
\hypertarget{7663137055249909841}{} 
\hyperlink{7663137055249909841}{\texttt{Statistics.median}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
median(itr)
\end{minted}

Compute the median of all elements in a collection. For an even number of elements no exact median element exists, so the result is equivalent to calculating mean of two median elements.

\begin{quote}
\textbf{Note}

If \texttt{itr} contains \texttt{NaN} or \hyperlink{14596725676261444434}{\texttt{missing}} values, the result is also \texttt{NaN} or \texttt{missing} (\texttt{missing} takes precedence if \texttt{itr} contains both). Use the \hyperlink{2012470681884771400}{\texttt{skipmissing}} function to omit \texttt{missing} entries and compute the median of non-missing values.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> median([1, 2, 3])
2.0

julia> median([1, 2, 3, 4])
2.5

julia> median([1, 2, missing, 4])
missing

julia> median(skipmissing([1, 2, missing, 4]))
2.0
\end{minted}




\begin{lstlisting}
median(A::AbstractArray; dims)
\end{lstlisting}

Compute the median of an array along the given dimensions.

\textbf{Examples}


\begin{minted}{jlcon}
julia> median([1 2; 3 4], dims=1)
1×2 Array{Float64,2}:
 2.0  3.0
\end{minted}



\end{adjustwidth}
\hypertarget{14662071173540942276}{} 
\hyperlink{14662071173540942276}{\texttt{Statistics.middle}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
middle(x)
\end{minted}

Compute the middle of a scalar value, which is equivalent to \texttt{x} itself, but of the type of \texttt{middle(x, x)} for consistency.




\begin{lstlisting}
middle(x, y)
\end{lstlisting}

Compute the middle of two reals \texttt{x} and \texttt{y}, which is equivalent in both value and type to computing their mean (\texttt{(x + y) / 2}).




\begin{lstlisting}
middle(range)
\end{lstlisting}

Compute the middle of a range, which consists of computing the mean of its extrema. Since a range is sorted, the mean is performed with the first and last element.


\begin{minted}{jlcon}
julia> middle(1:10)
5.5
\end{minted}




\begin{lstlisting}
middle(a)
\end{lstlisting}

Compute the middle of an array \texttt{a}, which consists of finding its extrema and then computing their mean.


\begin{minted}{jlcon}
julia> a = [1,2,3.6,10.9]
4-element Array{Float64,1}:
  1.0
  2.0
  3.6
 10.9

julia> middle(a)
5.95
\end{minted}



\end{adjustwidth}
\hypertarget{14611219682884062063}{} 
\hyperlink{14611219682884062063}{\texttt{Statistics.quantile!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
quantile!([q::AbstractArray, ] v::AbstractVector, p; sorted=false)
\end{minted}

Compute the quantile(s) of a vector \texttt{v} at a specified probability or vector or tuple of probabilities \texttt{p} on the interval [0,1]. If \texttt{p} is a vector, an optional output array \texttt{q} may also be specified. (If not provided, a new output array is created.) The keyword argument \texttt{sorted} indicates whether \texttt{v} can be assumed to be sorted; if \texttt{false} (the default), then the elements of \texttt{v} will be partially sorted in-place.

Quantiles are computed via linear interpolation between the points \texttt{((k-1)/(n-1), v[k])}, for \texttt{k = 1:n} where \texttt{n = length(v)}. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R default.

\begin{quote}
\textbf{Note}

An \texttt{ArgumentError} is thrown if \texttt{v} contains \texttt{NaN} or \hyperlink{14596725676261444434}{\texttt{missing}} values.

\end{quote}
\begin{itemize}
\item Hyndman, R.J and Fan, Y. (1996) {\textquotedbl}Sample Quantiles in Statistical Packages{\textquotedbl}, \emph{The American Statistician}, Vol. 50, No. 4, pp. 361-365

\end{itemize}
\textbf{Examples}


\begin{minted}{jlcon}
julia> x = [3, 2, 1];

julia> quantile!(x, 0.5)
2.0

julia> x
3-element Array{Int64,1}:
 1
 2
 3

julia> y = zeros(3);

julia> quantile!(y, x, [0.1, 0.5, 0.9]) === y
true

julia> y
3-element Array{Float64,1}:
 1.2
 2.0
 2.8
\end{minted}



\end{adjustwidth}
\hypertarget{1313193106257799062}{} 
\hyperlink{1313193106257799062}{\texttt{Statistics.quantile}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
quantile(itr, p; sorted=false)
\end{minted}

Compute the quantile(s) of a collection \texttt{itr} at a specified probability or vector or tuple of probabilities \texttt{p} on the interval [0,1]. The keyword argument \texttt{sorted} indicates whether \texttt{itr} can be assumed to be sorted.

Quantiles are computed via linear interpolation between the points \texttt{((k-1)/(n-1), v[k])}, for \texttt{k = 1:n} where \texttt{n = length(itr)}. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R default.

\begin{quote}
\textbf{Note}

An \texttt{ArgumentError} is thrown if \texttt{itr} contains \texttt{NaN} or \hyperlink{14596725676261444434}{\texttt{missing}} values. Use the \hyperlink{2012470681884771400}{\texttt{skipmissing}} function to omit \texttt{missing} entries and compute the quantiles of non-missing values.

\end{quote}
\begin{itemize}
\item Hyndman, R.J and Fan, Y. (1996) {\textquotedbl}Sample Quantiles in Statistical Packages{\textquotedbl}, \emph{The American Statistician}, Vol. 50, No. 4, pp. 361-365

\end{itemize}
\textbf{Examples}


\begin{minted}{jlcon}
julia> quantile(0:20, 0.5)
10.0

julia> quantile(0:20, [0.1, 0.5, 0.9])
3-element Array{Float64,1}:
  2.0
 10.0
 18.0

julia> quantile(skipmissing([1, 10, missing]), 0.5)
5.5
\end{minted}



\end{adjustwidth}



\hypertarget{17778253023886211260}{}


\chapter{单元测试}





\hypertarget{10440826130497106701}{}


\section{测试 Julia Base 库}



Julia is under rapid development and has an extensive test suite to verify functionality across multiple platforms. If you build Julia from source, you can run this test suite with \texttt{make test}. In a binary install, you can run the test suite using \texttt{Base.runtests()}.


\hypertarget{2272377293323848310}{} 
\hyperlink{2272377293323848310}{\texttt{Base.runtests}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Base.runtests(tests=["all"]; ncores=ceil(Int, Sys.CPU_THREADS / 2),
              exit_on_error=false, [seed])
\end{minted}

Run the Julia unit tests listed in \texttt{tests}, which can be either a string or an array of strings, using \texttt{ncores} processors. If \texttt{exit\_on\_error} is \texttt{false}, when one test fails, all remaining tests in other files will still be run; they are otherwise discarded, when \texttt{exit\_on\_error == true}. If a seed is provided via the keyword argument, it is used to seed the global RNG in the context where the tests are run; otherwise the seed is chosen randomly.



\href{https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/util.jl#L811-L821}{\texttt{source}}


\end{adjustwidth}

\hypertarget{7988833292242463234}{}


\section{基本的单元测试}



The \texttt{Test} module provides simple \emph{unit testing} functionality. Unit testing is a way to see if your code is correct by checking that the results are what you expect. It can be helpful to ensure your code still works after you make changes, and can be used when developing as a way of specifying the behaviors your code should have when complete.



Simple unit testing can be performed with the \texttt{@test} and \texttt{@test\_throws} macros:


\hypertarget{1038355522981819767}{} 
\hyperlink{1038355522981819767}{\texttt{Test.@test}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@test ex
@test f(args...) key=val ...
\end{minted}

Tests that the expression \texttt{ex} evaluates to \texttt{true}. Returns a \texttt{Pass} \texttt{Result} if it does, a \texttt{Fail} \texttt{Result} if it is \texttt{false}, and an \texttt{Error} \texttt{Result} if it could not be evaluated.

\textbf{Examples}


\begin{minted}{jlcon}
julia> @test true
Test Passed

julia> @test [1, 2] + [2, 1] == [3, 3]
Test Passed
\end{minted}

The \texttt{@test f(args...) key=val...} form is equivalent to writing \texttt{@test f(args..., key=val...)} which can be useful when the expression is a call using infix syntax such as approximate comparisons:


\begin{minted}{jlcon}
julia> @test π ≈ 3.14 atol=0.01
Test Passed
\end{minted}

This is equivalent to the uglier test \texttt{@test ≈(π, 3.14, atol=0.01)}. It is an error to supply more than one expression unless the first is a call expression and the rest are assignments (\texttt{k=v}).



\end{adjustwidth}
\hypertarget{5527166796157013832}{} 
\hyperlink{5527166796157013832}{\texttt{Test.@test\_throws}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@test_throws exception expr
\end{minted}

Tests that the expression \texttt{expr} throws \texttt{exception}. The exception may specify either a type, or a value (which will be tested for equality by comparing fields). Note that \texttt{@test\_throws} does not support a trailing keyword form.

\textbf{Examples}


\begin{minted}{jlcon}
julia> @test_throws BoundsError [1, 2, 3][4]
Test Passed
      Thrown: BoundsError

julia> @test_throws DimensionMismatch [1, 2, 3] + [1, 2]
Test Passed
      Thrown: DimensionMismatch
\end{minted}



\end{adjustwidth}

For example, suppose we want to check our new function \texttt{foo(x)} works as expected:




\begin{minted}{jlcon}
julia> using Test

julia> foo(x) = length(x)^2
foo (generic function with 1 method)
\end{minted}



如果条件为真，则返回 \texttt{Pass}：




\begin{minted}{jlcon}
julia> @test foo("bar") == 9
Test Passed

julia> @test foo("fizz") >= 10
Test Passed
\end{minted}



如果条件为假，则返回 \texttt{Fail} 并抛出异常。




\begin{minted}{jlcon}
julia> @test foo("f") == 20
Test Failed at none:1
  Expression: foo("f") == 20
   Evaluated: 1 == 20
ERROR: There was an error during testing
\end{minted}



If the condition could not be evaluated because an exception was thrown, which occurs in this case because \texttt{length} is not defined for symbols, an \texttt{Error} object is returned and an exception is thrown:




\begin{minted}{jlcon}
julia> @test foo(:cat) == 1
Error During Test
  Test threw an exception of type MethodError
  Expression: foo(:cat) == 1
  MethodError: no method matching length(::Symbol)
  Closest candidates are:
    length(::SimpleVector) at essentials.jl:256
    length(::Base.MethodList) at reflection.jl:521
    length(::MethodTable) at reflection.jl:597
    ...
  Stacktrace:
  [...]
ERROR: There was an error during testing
\end{minted}



If we expect that evaluating an expression \emph{should} throw an exception, then we can use \texttt{@test\_throws} to check that this occurs:




\begin{minted}{jlcon}
julia> @test_throws MethodError foo(:cat)
Test Passed
      Thrown: MethodError
\end{minted}



\hypertarget{12305239832165996459}{}


\section{Working with Test Sets}



Typically a large number of tests are used to make sure functions work correctly over a range of inputs. In the event a test fails, the default behavior is to throw an exception immediately. However, it is normally preferable to run the rest of the tests first to get a better picture of how many errors there are in the code being tested.



The \texttt{@testset} macro can be used to group tests into \emph{sets}. All the tests in a test set will be run, and at the end of the test set a summary will be printed. If any of the tests failed, or could not be evaluated due to an error, the test set will then throw a \texttt{TestSetException}.


\hypertarget{6603917731228482697}{} 
\hyperlink{6603917731228482697}{\texttt{Test.@testset}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@testset [CustomTestSet] [option=val  ...] ["description"] begin ... end
@testset [CustomTestSet] [option=val  ...] ["description $v"] for v in (...) ... end
@testset [CustomTestSet] [option=val  ...] ["description $v, $w"] for v in (...), w in (...) ... end
\end{minted}

Starts a new test set, or multiple test sets if a \texttt{for} loop is provided.

If no custom testset type is given it defaults to creating a \texttt{DefaultTestSet}. \texttt{DefaultTestSet} records all the results and, if there are any \texttt{Fail}s or \texttt{Error}s, throws an exception at the end of the top-level (non-nested) test set, along with a summary of the test results.

Any custom testset type (subtype of \texttt{AbstractTestSet}) can be given and it will also be used for any nested \texttt{@testset} invocations. The given options are only applied to the test set where they are given. The default test set type does not take any options.

The description string accepts interpolation from the loop indices. If no description is provided, one is constructed based on the variables.

By default the \texttt{@testset} macro will return the testset object itself, though this behavior can be customized in other testset types. If a \texttt{for} loop is used then the macro collects and returns a list of the return values of the \texttt{finish} method, which by default will return a list of the testset objects used in each iteration.

Before the execution of the body of a \texttt{@testset}, there is an implicit call to \texttt{Random.seed!(seed)} where \texttt{seed} is the current seed of the global RNG. Moreover, after the execution of the body, the state of the global RNG is restored to what it was before the \texttt{@testset}. This is meant to ease reproducibility in case of failure, and to allow seamless re-arrangements of \texttt{@testset}s regardless of their side-effect on the global RNG state.

\textbf{Examples}


\begin{minted}{jlcon}
julia> @testset "trigonometric identities" begin
           θ = 2/3*π
           @test sin(-θ) ≈ -sin(θ)
           @test cos(-θ) ≈ cos(θ)
           @test sin(2θ) ≈ 2*sin(θ)*cos(θ)
           @test cos(2θ) ≈ cos(θ)^2 - sin(θ)^2
       end;
Test Summary:            | Pass  Total
trigonometric identities |    4      4
\end{minted}



\end{adjustwidth}

We can put our tests for the \texttt{foo(x)} function in a test set:




\begin{minted}{jlcon}
julia> @testset "Foo Tests" begin
           @test foo("a")   == 1
           @test foo("ab")  == 4
           @test foo("abc") == 9
       end;
Test Summary: | Pass  Total
Foo Tests     |    3      3
\end{minted}



测试集可以嵌套：




\begin{minted}{jlcon}
julia> @testset "Foo Tests" begin
           @testset "Animals" begin
               @test foo("cat") == 9
               @test foo("dog") == foo("cat")
           end
           @testset "Arrays $i" for i in 1:3
               @test foo(zeros(i)) == i^2
               @test foo(fill(1.0, i)) == i^2
           end
       end;
Test Summary: | Pass  Total
Foo Tests     |    8      8
\end{minted}



In the event that a nested test set has no failures, as happened here, it will be hidden in the summary. If we do have a test failure, only the details for the failed test sets will be shown:




\begin{minted}{jlcon}
julia> @testset "Foo Tests" begin
           @testset "Animals" begin
               @testset "Felines" begin
                   @test foo("cat") == 9
               end
               @testset "Canines" begin
                   @test foo("dog") == 9
               end
           end
           @testset "Arrays" begin
               @test foo(zeros(2)) == 4
               @test foo(fill(1.0, 4)) == 15
           end
       end

Arrays: Test Failed
  Expression: foo(fill(1.0, 4)) == 15
   Evaluated: 16 == 15
[...]
Test Summary: | Pass  Fail  Total
Foo Tests     |    3     1      4
  Animals     |    2            2
  Arrays      |    1     1      2
ERROR: Some tests did not pass: 3 passed, 1 failed, 0 errored, 0 broken.
\end{minted}



\hypertarget{13684669007939877444}{}


\section{其他测试宏}



As calculations on floating-point values can be imprecise, you can perform approximate equality checks using either \texttt{@test a ≈ b} (where \texttt{≈}, typed via tab completion of \texttt{{\textbackslash}approx}, is the \hyperlink{12499503887608197213}{\texttt{isapprox}} function) or use \hyperlink{12499503887608197213}{\texttt{isapprox}} directly.




\begin{minted}{jlcon}
julia> @test 1 ≈ 0.999999999
Test Passed

julia> @test 1 ≈ 0.999999
Test Failed at none:1
  Expression: 1 ≈ 0.999999
   Evaluated: 1 ≈ 0.999999
ERROR: There was an error during testing
\end{minted}


\hypertarget{14660196658788499514}{} 
\hyperlink{14660196658788499514}{\texttt{Test.@inferred}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@inferred [AllowedType] f(x)
\end{minted}

Tests that the call expression \texttt{f(x)} returns a value of the same type inferred by the compiler. It is useful to check for type stability.

\texttt{f(x)} can be any call expression. Returns the result of \texttt{f(x)} if the types match, and an \texttt{Error} \texttt{Result} if it finds different types.

Optionally, \texttt{AllowedType} relaxes the test, by making it pass when either the type of \texttt{f(x)} matches the inferred type modulo \texttt{AllowedType}, or when the return type is a subtype of \texttt{AllowedType}. This is useful when testing type stability of functions returning a small union such as \texttt{Union\{Nothing, T\}} or \texttt{Union\{Missing, T\}}.


\begin{minted}{jlcon}
julia> f(a) = a > 1 ? 1 : 1.0
f (generic function with 1 method)

julia> typeof(f(2))
Int64

julia> @code_warntype f(2)
Variables
  #self#::Core.Compiler.Const(f, false)
  a::Int64

Body::UNION{FLOAT64, INT64}
1 ─ %1 = (a > 1)::Bool
└──      goto #3 if not %1
2 ─      return 1
3 ─      return 1.0

julia> @inferred f(2)
ERROR: return type Int64 does not match inferred return type Union{Float64, Int64}
[...]

julia> @inferred max(1, 2)
2

julia> g(a) = a < 10 ? missing : 1.0
g (generic function with 1 method)

julia> @inferred g(20)
ERROR: return type Float64 does not match inferred return type Union{Missing, Float64}
[...]

julia> @inferred Missing g(20)
1.0

julia> h(a) = a < 10 ? missing : f(a)
h (generic function with 1 method)

julia> @inferred Missing h(20)
ERROR: return type Int64 does not match inferred return type Union{Missing, Float64, Int64}
[...]
\end{minted}



\end{adjustwidth}
\hypertarget{1395021091279173086}{} 
\hyperlink{1395021091279173086}{\texttt{Test.@test\_logs}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@test_logs [log_patterns...] [keywords] expression
\end{minted}

Collect a list of log records generated by \texttt{expression} using \texttt{collect\_test\_logs}, check that they match the sequence \texttt{log\_patterns}, and return the value of \texttt{expression}.  The \texttt{keywords} provide some simple filtering of log records: the \texttt{min\_level} keyword controls the minimum log level which will be collected for the test, the \texttt{match\_mode} keyword defines how matching will be performed (the default \texttt{:all} checks that all logs and patterns match pairwise; use \texttt{:any} to check that the pattern matches at least once somewhere in the sequence.)

The most useful log pattern is a simple tuple of the form \texttt{(level,message)}. A different number of tuple elements may be used to match other log metadata, corresponding to the arguments to passed to \texttt{AbstractLogger} via the \texttt{handle\_message} function: \texttt{(level,message,module,group,id,file,line)}. Elements which are present will be matched pairwise with the log record fields using \texttt{==} by default, with the special cases that \texttt{Symbol}s may be used for the standard log levels, and \texttt{Regex}s in the pattern will match string or Symbol fields using \texttt{occursin}.

\textbf{Examples}

Consider a function which logs a warning, and several debug messages:


\begin{lstlisting}
function foo(n)
    @info "Doing foo with n=$n"
    for i=1:n
        @debug "Iteration $i"
    end
    42
end
\end{lstlisting}

We can test the info message using


\begin{lstlisting}
@test_logs (:info,"Doing foo with n=2") foo(2)
\end{lstlisting}

If we also wanted to test the debug messages, these need to be enabled with the \texttt{min\_level} keyword:


\begin{lstlisting}
@test_logs (:info,"Doing foo with n=2") (:debug,"Iteration 1") (:debug,"Iteration 2") min_level=Debug foo(2)
\end{lstlisting}

If you want to test that some particular messages are generated while ignoring the rest, you can set the keyword \texttt{match\_mode=:any}:


\begin{lstlisting}
@test_logs (:info,) (:debug,"Iteration 42") min_level=Debug match_mode=:any foo(100)
\end{lstlisting}

The macro may be chained with \texttt{@test} to also test the returned value:


\begin{lstlisting}
@test (@test_logs (:info,"Doing foo with n=2") foo(2)) == 42
\end{lstlisting}



\end{adjustwidth}
\hypertarget{3450176127005416215}{} 
\hyperlink{3450176127005416215}{\texttt{Test.@test\_deprecated}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@test_deprecated [pattern] expression
\end{minted}

When \texttt{--depwarn=yes}, test that \texttt{expression} emits a deprecation warning and return the value of \texttt{expression}.  The log message string will be matched against \texttt{pattern} which defaults to \texttt{r{\textquotedbl}deprecated{\textquotedbl}i}.

When \texttt{--depwarn=no}, simply return the result of executing \texttt{expression}.  When \texttt{--depwarn=error}, check that an ErrorException is thrown.

\textbf{Examples}


\begin{lstlisting}
# Deprecated in julia 0.7
@test_deprecated num2hex(1)

# The returned value can be tested by chaining with @test:
@test (@test_deprecated num2hex(1)) == "0000000000000001"
\end{lstlisting}



\end{adjustwidth}
\hypertarget{12478857733960407392}{} 
\hyperlink{12478857733960407392}{\texttt{Test.@test\_warn}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@test_warn msg expr
\end{minted}

Test whether evaluating \texttt{expr} results in \hyperlink{6150355911915549172}{\texttt{stderr}} output that contains the \texttt{msg} string or matches the \texttt{msg} regular expression.  If \texttt{msg} is a boolean function, tests whether \texttt{msg(output)} returns \texttt{true}.  If \texttt{msg} is a tuple or array, checks that the error output contains/matches each item in \texttt{msg}. Returns the result of evaluating \texttt{expr}.

See also \hyperlink{14168562674427079535}{\texttt{@test\_nowarn}} to check for the absence of error output.

Note: Warnings generated by \texttt{@warn} cannot be tested with this macro. Use \texttt{@test\_logs} instead.



\end{adjustwidth}
\hypertarget{14168562674427079535}{} 
\hyperlink{14168562674427079535}{\texttt{Test.@test\_nowarn}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@test_nowarn expr
\end{minted}

Test whether evaluating \texttt{expr} results in empty \hyperlink{6150355911915549172}{\texttt{stderr}} output (no warnings or other messages).  Returns the result of evaluating \texttt{expr}.

Note: The absence of warnings generated by \texttt{@warn} cannot be tested with this macro. Use \texttt{@test\_logs expr} instead.



\end{adjustwidth}

\hypertarget{17956725815872473676}{}


\section{损坏的测试}



If a test fails consistently it can be changed to use the \texttt{@test\_broken} macro. This will denote the test as \texttt{Broken} if the test continues to fail and alerts the user via an \texttt{Error} if the test succeeds.


\hypertarget{5668051953647432783}{} 
\hyperlink{5668051953647432783}{\texttt{Test.@test\_broken}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@test_broken ex
@test_broken f(args...) key=val ...
\end{minted}

Indicates a test that should pass but currently consistently fails. Tests that the expression \texttt{ex} evaluates to \texttt{false} or causes an exception. Returns a \texttt{Broken} \texttt{Result} if it does, or an \texttt{Error} \texttt{Result} if the expression evaluates to \texttt{true}.

The \texttt{@test\_broken f(args...) key=val...} form works as for the \texttt{@test} macro.

\textbf{Examples}


\begin{minted}{jlcon}
julia> @test_broken 1 == 2
Test Broken
  Expression: 1 == 2

julia> @test_broken 1 == 2 atol=0.1
Test Broken
  Expression: ==(1, 2, atol = 0.1)
\end{minted}



\end{adjustwidth}

\texttt{@test\_skip} is also available to skip a test without evaluation, but counting the skipped test in the test set reporting. The test will not run but gives a \texttt{Broken} \texttt{Result}.


\hypertarget{612751920735042674}{} 
\hyperlink{612751920735042674}{\texttt{Test.@test\_skip}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
@test_skip ex
@test_skip f(args...) key=val ...
\end{minted}

Marks a test that should not be executed but should be included in test summary reporting as \texttt{Broken}. This can be useful for tests that intermittently fail, or tests of not-yet-implemented functionality.

The \texttt{@test\_skip f(args...) key=val...} form works as for the \texttt{@test} macro.

\textbf{Examples}


\begin{minted}{jlcon}
julia> @test_skip 1 == 2
Test Broken
  Skipped: 1 == 2

julia> @test_skip 1 == 2 atol=0.1
Test Broken
  Skipped: ==(1, 2, atol = 0.1)
\end{minted}



\end{adjustwidth}

\hypertarget{641042127845318623}{}


\section{自定义 \texttt{AbstractTestSet} 类型}



Packages can create their own \texttt{AbstractTestSet} subtypes by implementing the \texttt{record} and \texttt{finish} methods. The subtype should have a one-argument constructor taking a description string, with any options passed in as keyword arguments.


\hypertarget{5358474705981864018}{} 
\hyperlink{5358474705981864018}{\texttt{Test.record}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
record(ts::AbstractTestSet, res::Result)
\end{minted}

Record a result to a testset. This function is called by the \texttt{@testset} infrastructure each time a contained \texttt{@test} macro completes, and is given the test result (which could be an \texttt{Error}). This will also be called with an \texttt{Error} if an exception is thrown inside the test block but outside of a \texttt{@test} context.



\end{adjustwidth}
\hypertarget{3045207246411142824}{} 
\hyperlink{3045207246411142824}{\texttt{Test.finish}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
finish(ts::AbstractTestSet)
\end{minted}

Do any final processing necessary for the given testset. This is called by the \texttt{@testset} infrastructure after a test block executes. One common use for this function is to record the testset to the parent{\textquotesingle}s results list, using \texttt{get\_testset}.



\end{adjustwidth}

\texttt{Test} takes responsibility for maintaining a stack of nested testsets as they are executed, but any result accumulation is the responsibility of the \texttt{AbstractTestSet} subtype. You can access this stack with the \texttt{get\_testset} and \texttt{get\_testset\_depth} methods. Note that these functions are not exported.


\hypertarget{16535119297156519849}{} 
\hyperlink{16535119297156519849}{\texttt{Test.get\_testset}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
get_testset()
\end{minted}

Retrieve the active test set from the task{\textquotesingle}s local storage. If no test set is active, use the fallback default test set.



\end{adjustwidth}
\hypertarget{6664474132755078304}{} 
\hyperlink{6664474132755078304}{\texttt{Test.get\_testset\_depth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
get_testset_depth()
\end{minted}

Returns the number of active test sets, not including the default test set



\end{adjustwidth}

\texttt{Test} also makes sure that nested \texttt{@testset} invocations use the same \texttt{AbstractTestSet} subtype as their parent unless it is set explicitly. It does not propagate any properties of the testset. Option inheritance behavior can be implemented by packages using the stack infrastructure that \texttt{Test} provides.



定义一个基本的 \texttt{AbstractTestSet} 子类：




\begin{minted}{julia}
import Test: Test, record, finish
using Test: AbstractTestSet, Result, Pass, Fail, Error
using Test: get_testset_depth, get_testset
struct CustomTestSet <: Test.AbstractTestSet
    description::AbstractString
    foo::Int
    results::Vector
    # constructor takes a description string and options keyword arguments
    CustomTestSet(desc; foo=1) = new(desc, foo, [])
end

record(ts::CustomTestSet, child::AbstractTestSet) = push!(ts.results, child)
record(ts::CustomTestSet, res::Result) = push!(ts.results, res)
function finish(ts::CustomTestSet)
    # just record if we're not the top-level parent
    if get_testset_depth() > 0
        record(get_testset(), ts)
    end
    ts
end
\end{minted}



使用测试集：




\begin{minted}{julia}
@testset CustomTestSet foo=4 "custom testset inner 2" begin
    # this testset should inherit the type, but not the argument.
    @testset "custom testset inner" begin
        @test true
    end
end
\end{minted}





\hypertarget{2767829618755343548}{}


\chapter{UUIDs}


\hypertarget{16892127995397163681}{} 
\hyperlink{16892127995397163681}{\texttt{UUIDs.uuid1}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
uuid1([rng::AbstractRNG=GLOBAL_RNG]) -> UUID
\end{minted}

Generates a version 1 (time-based) universally unique identifier (UUID), as specified by RFC 4122. Note that the Node ID is randomly generated (does not identify the host) according to section 4.5 of the RFC.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> uuid1(rng)
UUID("cfc395e8-590f-11e8-1f13-43a2532b2fa8")
\end{minted}



\end{adjustwidth}
\hypertarget{15125074142528432744}{} 
\hyperlink{15125074142528432744}{\texttt{UUIDs.uuid4}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
uuid4([rng::AbstractRNG=GLOBAL_RNG]) -> UUID
\end{minted}

Generates a version 4 (random or pseudo-random) universally unique identifier (UUID), as specified by RFC 4122.

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> uuid4(rng)
UUID("196f2941-2d58-45ba-9f13-43a2532b2fa8")
\end{minted}



\end{adjustwidth}
\hypertarget{16798189732863707215}{} 
\hyperlink{16798189732863707215}{\texttt{UUIDs.uuid5}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
uuid5(ns::UUID, name::String) -> UUID
\end{minted}

Generates a version 5 (namespace and domain-based) universally unique identifier (UUID), as specified by RFC 4122.

\begin{quote}
\textbf{Julia 1.1}

This function requires at least Julia 1.1.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> u4 = uuid4(rng)
UUID("196f2941-2d58-45ba-9f13-43a2532b2fa8")

julia> u5 = uuid5(u4, "julia")
UUID("b37756f8-b0c0-54cd-a466-19b3d25683bc")
\end{minted}



\end{adjustwidth}
\hypertarget{2328416264059500569}{} 
\hyperlink{2328416264059500569}{\texttt{UUIDs.uuid\_version}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
uuid_version(u::UUID) -> Int
\end{minted}

Inspects the given UUID and returns its version (see \href{https://www.ietf.org/rfc/rfc4122}{RFC 4122}).

\textbf{Examples}


\begin{minted}{jlcon}
julia> uuid_version(uuid4())
4
\end{minted}



\end{adjustwidth}

\hypertarget{1111253146082274876}{}


\chapter{Unicode}


\hypertarget{3408928680045716107}{} 
\hyperlink{3408928680045716107}{\texttt{Unicode.isassigned}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Unicode.isassigned(c) -> Bool
\end{minted}

Returns \texttt{true} if the given char or integer is an assigned Unicode code point.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Unicode.isassigned(101)
true

julia> Unicode.isassigned('\x01')
true
\end{minted}



\end{adjustwidth}
\hypertarget{6168731775693095830}{} 
\hyperlink{6168731775693095830}{\texttt{Unicode.normalize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Unicode.normalize(s::AbstractString, normalform::Symbol)
\end{minted}

Normalize the string \texttt{s} according to one of the four {\textquotedbl}normal forms{\textquotedbl} of the Unicode standard: \texttt{normalform} can be \texttt{:NFC}, \texttt{:NFD}, \texttt{:NFKC}, or \texttt{:NFKD}.  Normal forms C (canonical composition) and D (canonical decomposition) convert different visually identical representations of the same abstract string into a single canonical form, with form C being more compact.  Normal forms KC and KD additionally canonicalize {\textquotedbl}compatibility equivalents{\textquotedbl}: they convert characters that are abstractly similar but visually distinct into a single canonical choice (e.g. they expand ligatures into the individual characters), with form KC being more compact.

Alternatively, finer control and additional transformations may be be obtained by calling \texttt{Unicode.normalize(s; keywords...)}, where any number of the following boolean keywords options (which all default to \texttt{false} except for \texttt{compose}) are specified:

\begin{itemize}
\item \texttt{compose=false}: do not perform canonical composition


\item \texttt{decompose=true}: do canonical decomposition instead of canonical composition (\texttt{compose=true} is ignored if present)


\item \texttt{compat=true}: compatibility equivalents are canonicalized


\item \texttt{casefold=true}: perform Unicode case folding, e.g. for case-insensitive string comparison


\item \texttt{newline2lf=true}, \texttt{newline2ls=true}, or \texttt{newline2ps=true}: convert various newline sequences (LF, CRLF, CR, NEL) into a linefeed (LF), line-separation (LS), or paragraph-separation (PS) character, respectively


\item \texttt{stripmark=true}: strip diacritical marks (e.g. accents)


\item \texttt{stripignore=true}: strip Unicode{\textquotesingle}s {\textquotedbl}default ignorable{\textquotedbl} characters (e.g. the soft hyphen or the left-to-right marker)


\item \texttt{stripcc=true}: strip control characters; horizontal tabs and form feeds are converted to spaces; newlines are also converted to spaces unless a newline-conversion flag was specified


\item \texttt{rejectna=true}: throw an error if unassigned code points are found


\item \texttt{stable=true}: enforce Unicode Versioning Stability

\end{itemize}
For example, NFKC corresponds to the options \texttt{compose=true, compat=true, stable=true}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> "μ" == Unicode.normalize("µ", compat=true) #LHS: Unicode U+03bc, RHS: Unicode U+00b5
true

julia> Unicode.normalize("JuLiA", casefold=true)
"julia"

julia> Unicode.normalize("JúLiA", stripmark=true)
"JuLiA"
\end{minted}



\end{adjustwidth}
\hypertarget{15282403158595139101}{} 
\hyperlink{15282403158595139101}{\texttt{Unicode.graphemes}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
graphemes(s::AbstractString) -> GraphemeIterator
\end{minted}

Returns an iterator over substrings of \texttt{s} that correspond to the extended graphemes in the string, as defined by Unicode UAX \#29. (Roughly, these are what users would perceive as single characters, even though they may contain more than one codepoint; for example a letter combined with an accent mark is a single grapheme.)

\end{adjustwidth}






